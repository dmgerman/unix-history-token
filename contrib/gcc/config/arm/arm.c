begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output routines for GCC for ARM.    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)    and Martin Simmons (@harleqn.co.uk).    More major hacks by Richard Earnshaw (rearnsha@arm.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_comment
comment|/* Forward definitions of types.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|minipool_node
name|Mnode
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|minipool_fixup
name|Mfix
typedef|;
end_typedef

begin_comment
comment|/* In order to improve the layout of the prototypes below    some short type abbreviations are defined here.  */
end_comment

begin_define
define|#
directive|define
name|Hint
value|HOST_WIDE_INT
end_define

begin_define
define|#
directive|define
name|Mmode
value|enum machine_mode
end_define

begin_define
define|#
directive|define
name|Ulong
value|unsigned long
end_define

begin_define
define|#
directive|define
name|Ccstar
value|const char *
end_define

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|arm_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward function declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|arm_add_gc_roots
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_gen_constant
name|PARAMS
argument_list|(
operator|(
expr|enum
name|rtx_code
operator|,
name|Mmode
operator|,
name|Hint
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Ulong
name|bit_count
name|PARAMS
argument_list|(
operator|(
name|signed
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|const_ok_for_op
name|PARAMS
argument_list|(
operator|(
name|Hint
operator|,
expr|enum
name|rtx_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eliminate_lr2ip
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|emit_multi_reg_push
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|emit_sfm
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
end_ifndef

begin_decl_stmt
specifier|static
name|bool
name|arm_assemble_integer
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|Ccstar
name|fp_const_from_val
name|PARAMS
argument_list|(
operator|(
name|REAL_VALUE_TYPE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|arm_cc
name|get_arm_condition_code
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_fpa_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Hint
name|int_log2
name|PARAMS
argument_list|(
operator|(
name|Hint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|is_jump_table
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Ccstar
name|output_multi_immediate
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|Ccstar
operator|,
name|Ccstar
operator|,
name|int
operator|,
name|Hint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_multi_reg
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|Ccstar
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Mmode
name|select_dominance_cc_mode
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|Hint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Ccstar
name|shift_op
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|Hint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arm_init_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arm_mark_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arm_free_machine_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|function
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|number_of_first_bit_set
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_symbols_in_block
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thumb_exit
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thumb_pushpop
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Ccstar
name|thumb_condition_code
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|is_jump_table
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Hint
name|get_jump_table_size
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_forward_ref
name|PARAMS
argument_list|(
operator|(
name|Mnode
operator|*
operator|,
name|Mnode
operator|*
operator|,
name|Hint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Mnode
modifier|*
name|add_minipool_forward_ref
name|PARAMS
argument_list|(
operator|(
name|Mfix
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_backward_ref
name|PARAMS
argument_list|(
operator|(
name|Mnode
operator|*
operator|,
name|Mnode
operator|*
operator|,
name|Hint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Mnode
modifier|*
name|add_minipool_backward_ref
name|PARAMS
argument_list|(
operator|(
name|Mfix
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assign_minipool_offsets
name|PARAMS
argument_list|(
operator|(
name|Mfix
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arm_print_value
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_minipool
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_barrier_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Mfix
modifier|*
name|create_fix_barrier
name|PARAMS
argument_list|(
operator|(
name|Mfix
operator|*
operator|,
name|Hint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_minipool_barrier
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|Hint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_minipool_fix
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|Hint
operator|,
name|rtx
operator|*
operator|,
name|Mmode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|note_invalid_constants
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|Hint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_file_function_operand
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Ulong
name|arm_compute_save_reg0_reg12_mask
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Ulong
name|arm_compute_save_reg_mask
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Ulong
name|arm_isr_value
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Ulong
name|arm_compute_func_type
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|arm_handle_fndecl_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|arm_handle_isr_attribute
name|PARAMS
argument_list|(
operator|(
name|tree
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
name|bool
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arm_output_function_epilogue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|Hint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arm_output_function_prologue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|Hint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thumb_output_function_prologue
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|Hint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_comp_type_attributes
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|arm_set_default_type_attributes
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_adjust_cost
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|arm_elf_asm_named_section
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|Hint
end_undef

begin_undef
undef|#
directive|undef
name|Mmode
end_undef

begin_undef
undef|#
directive|undef
name|Ulong
end_undef

begin_undef
undef|#
directive|undef
name|Ccstar
end_undef

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_MERGE_DECL_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_MERGE_DECL_ATTRIBUTES
value|merge_dllimport_decl_attributes
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|arm_attribute_table
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_BYTE_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_BYTE_OP
value|"\tDCB\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\tDCW\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|"\tDCD\t"
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|NULL
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|arm_assemble_integer
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|arm_output_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|arm_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_COMP_TYPE_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_COMP_TYPE_ATTRIBUTES
value|arm_comp_type_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SET_DEFAULT_TYPE_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_SET_DEFAULT_TYPE_ATTRIBUTES
value|arm_set_default_type_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|arm_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|arm_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|arm_adjust_cost
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Obstack for minipool constant handling.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|minipool_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|minipool_startobj
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* The maximum number of insns skipped which    will be conditionalised if possible.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_insns_skipped
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we are currently building a constant table.  */
end_comment

begin_decl_stmt
name|int
name|making_const_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the information needed to generate branch insns.  This is    stored from the compare operation.  */
end_comment

begin_decl_stmt
name|rtx
name|arm_compare_op0
decl_stmt|,
name|arm_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What type of floating point are we tuning for?  */
end_comment

begin_decl_stmt
name|enum
name|floating_point_type
name|arm_fpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What type of floating point instructions are available?  */
end_comment

begin_decl_stmt
name|enum
name|floating_point_type
name|arm_fpu_arch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What program mode is the cpu running in? 26-bit mode or 32-bit mode.  */
end_comment

begin_decl_stmt
name|enum
name|prog_mode_type
name|arm_prgmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by the -mfp=... option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|target_fp_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to parse -mstructure_size_boundary command line option.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|structure_size_string
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arm_structure_size_boundary
init|=
name|DEFAULT_STRUCTURE_SIZE_BOUNDARY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit values used to identify processor capabilities.  */
end_comment

begin_define
define|#
directive|define
name|FL_CO_PROC
value|(1<< 0)
end_define

begin_comment
comment|/* Has external co-processor bus */
end_comment

begin_define
define|#
directive|define
name|FL_FAST_MULT
value|(1<< 1)
end_define

begin_comment
comment|/* Fast multiply */
end_comment

begin_define
define|#
directive|define
name|FL_MODE26
value|(1<< 2)
end_define

begin_comment
comment|/* 26-bit mode support */
end_comment

begin_define
define|#
directive|define
name|FL_MODE32
value|(1<< 3)
end_define

begin_comment
comment|/* 32-bit mode support */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH4
value|(1<< 4)
end_define

begin_comment
comment|/* Architecture rel 4 */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH5
value|(1<< 5)
end_define

begin_comment
comment|/* Architecture rel 5 */
end_comment

begin_define
define|#
directive|define
name|FL_THUMB
value|(1<< 6)
end_define

begin_comment
comment|/* Thumb aware */
end_comment

begin_define
define|#
directive|define
name|FL_LDSCHED
value|(1<< 7)
end_define

begin_comment
comment|/* Load scheduling necessary */
end_comment

begin_define
define|#
directive|define
name|FL_STRONG
value|(1<< 8)
end_define

begin_comment
comment|/* StrongARM */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH5E
value|(1<< 9)
end_define

begin_comment
comment|/* DSP extenstions to v5 */
end_comment

begin_define
define|#
directive|define
name|FL_XSCALE
value|(1<< 10)
end_define

begin_comment
comment|/* XScale */
end_comment

begin_comment
comment|/* The bits in this mask specify which    instructions we are allowed to generate.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|insn_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The bits in this mask specify which instruction scheduling options should    be used.  Note - there is an overlap with the FL_FAST_MULT.  For some    hardware we want to be able to generate the multiply instructions, but to    tune as if they were not present in the architecture.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tune_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following are used in the arm.md file as equivalents to bits    in the above two flag variables.  */
end_comment

begin_comment
comment|/* Nonzero if this is an "M" variant of the processor.  */
end_comment

begin_decl_stmt
name|int
name|arm_fast_multiply
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 4 extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch4
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 5 extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch5
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 5E extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch5e
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip can benefit from load scheduling.  */
end_comment

begin_decl_stmt
name|int
name|arm_ld_sched
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip is a StrongARM.  */
end_comment

begin_decl_stmt
name|int
name|arm_is_strong
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip is an XScale.  */
end_comment

begin_decl_stmt
name|int
name|arm_is_xscale
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip is an ARM6 or an ARM7.  */
end_comment

begin_decl_stmt
name|int
name|arm_is_6_or_7
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating Thumb instructions.  */
end_comment

begin_decl_stmt
name|int
name|thumb_code
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we    must report the mode of the memory reference from PRINT_OPERAND to    PRINT_OPERAND_ADDRESS.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|output_memory_reference_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the prologue must setup `fp'.  */
end_comment

begin_decl_stmt
name|int
name|current_function_anonymous_args
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The register number to be used for the PIC offset register.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|arm_pic_register_string
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arm_pic_register
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 when a return insn is output, this means that the epilogue    is not needed.  */
end_comment

begin_decl_stmt
name|int
name|return_used_this_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 after arm_reorg has started.  Reset to start at the start of    the next function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|after_arm_reorg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum number of insns to be used when loading a constant.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arm_constant_limit
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an explanation of these variables, see final_prescan_insn below.  */
end_comment

begin_decl_stmt
name|int
name|arm_ccfsm_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|arm_cond_code
name|arm_current_cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|arm_target_insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arm_target_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The condition codes of the ARM, and the inverse function.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|arm_condition_codes
index|[]
init|=
block|{
literal|"eq"
block|,
literal|"ne"
block|,
literal|"cs"
block|,
literal|"cc"
block|,
literal|"mi"
block|,
literal|"pl"
block|,
literal|"vs"
block|,
literal|"vc"
block|,
literal|"hi"
block|,
literal|"ls"
block|,
literal|"ge"
block|,
literal|"lt"
block|,
literal|"gt"
block|,
literal|"le"
block|,
literal|"al"
block|,
literal|"nv"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|)
value|(strcmp (string1, string2) == 0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialization code.  */
end_comment

begin_struct
struct|struct
name|processors
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|unsigned
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Not all of these give usefully different compilation alternatives,    but there is no simple way of generalizing them.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processors
name|all_cores
index|[]
init|=
block|{
comment|/* ARM Cores */
block|{
literal|"arm2"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
block|}
block|,
block|{
literal|"arm250"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
block|}
block|,
block|{
literal|"arm3"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
block|}
block|,
block|{
literal|"arm6"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm60"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm600"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm610"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm620"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm7"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
comment|/* arm7m doesn't exist on its own, but only with D, (and I), but      those don't alter the code, so arm7m is sometimes used.  */
block|{
literal|"arm7m"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
block|}
block|,
block|{
literal|"arm7d"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm7dm"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
block|}
block|,
block|{
literal|"arm7di"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm7dmi"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
block|}
block|,
block|{
literal|"arm70"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm700"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm700i"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm710"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm710t"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_THUMB
block|}
block|,
block|{
literal|"arm720"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm720t"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_THUMB
block|}
block|,
block|{
literal|"arm740t"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_THUMB
block|}
block|,
block|{
literal|"arm710c"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm7100"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm7500"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
comment|/* Doesn't have an external co-proc, but does have embedded fpu.  */
block|{
literal|"arm7500fe"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"arm7tdmi"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
block|}
block|,
block|{
literal|"arm8"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm810"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm9"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm920"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm920t"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm940t"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm9tdmi"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"arm9e"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
block|}
block|,
block|{
literal|"strongarm"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
block|}
block|,
block|{
literal|"strongarm110"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
block|}
block|,
block|{
literal|"strongarm1100"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
block|}
block|,
block|{
literal|"strongarm1110"
block|,
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
block|}
block|,
block|{
literal|"arm10tdmi"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
operator||
name|FL_ARCH5
block|}
block|,
block|{
literal|"arm1020t"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
operator||
name|FL_ARCH5
block|}
block|,
block|{
literal|"xscale"
block|,
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_LDSCHED
operator||
name|FL_STRONG
operator||
name|FL_ARCH5
operator||
name|FL_ARCH5E
operator||
name|FL_XSCALE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processors
name|all_architectures
index|[]
init|=
block|{
comment|/* ARM Architectures */
block|{
literal|"armv2"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
block|}
block|,
block|{
literal|"armv2a"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
block|}
block|,
block|{
literal|"armv3"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
block|}
block|,
block|{
literal|"armv3m"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
block|}
block|,
block|{
literal|"armv4"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
block|}
block|,
comment|/* Strictly, FL_MODE26 is a permitted option for v4t, but there are no      implementations that support it, so we will leave it out for now.  */
block|{
literal|"armv4t"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
block|}
block|,
block|{
literal|"armv5"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_ARCH5
block|}
block|,
block|{
literal|"armv5t"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_ARCH5
block|}
block|,
block|{
literal|"armv5te"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE32
operator||
name|FL_FAST_MULT
operator||
name|FL_ARCH4
operator||
name|FL_THUMB
operator||
name|FL_ARCH5
operator||
name|FL_ARCH5E
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a magic stucture.  The 'string' field is magically filled in    with a pointer to the value specified by the user on the command line    assuming that the user has specified such a value.  */
end_comment

begin_decl_stmt
name|struct
name|arm_cpu_select
name|arm_select
index|[]
init|=
block|{
comment|/* string	  name            processors  */
block|{
name|NULL
block|,
literal|"-mcpu="
block|,
name|all_cores
block|}
block|,
block|{
name|NULL
block|,
literal|"-march="
block|,
name|all_architectures
block|}
block|,
block|{
name|NULL
block|,
literal|"-mtune="
block|,
name|all_cores
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the number of bits set in value' */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|bit_count
parameter_list|(
name|value
parameter_list|)
name|signed
name|int
name|value
decl_stmt|;
block|{
name|unsigned
name|long
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|value
condition|)
block|{
name|value
operator|&=
operator|~
operator|(
name|value
operator|&
operator|-
name|value
operator|)
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Fix up any incompatible options that the user has specified.    This has now turned into a maze.  */
end_comment

begin_function
name|void
name|arm_override_options
parameter_list|()
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Set up the flags based on the cpu/architecture selected by the user.  */
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|arm_select
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|struct
name|arm_cpu_select
modifier|*
name|ptr
init|=
name|arm_select
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|string
operator|!=
name|NULL
operator|&&
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
specifier|const
name|struct
name|processors
modifier|*
name|sel
decl_stmt|;
for|for
control|(
name|sel
operator|=
name|ptr
operator|->
name|processors
init|;
name|sel
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sel
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|ptr
operator|->
name|string
argument_list|,
name|sel
operator|->
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|2
condition|)
name|tune_flags
operator|=
name|sel
operator|->
name|flags
expr_stmt|;
else|else
block|{
comment|/* If we have been given an architecture and a processor 		       make sure that they are compatible.  We only generate 		       a warning though, and we prefer the CPU over the 		       architecture.  */
if|if
condition|(
name|insn_flags
operator|!=
literal|0
operator|&&
operator|(
name|insn_flags
operator|^
name|sel
operator|->
name|flags
operator|)
condition|)
name|warning
argument_list|(
literal|"switch -mcpu=%s conflicts with -march= switch"
argument_list|,
name|ptr
operator|->
name|string
argument_list|)
expr_stmt|;
name|insn_flags
operator|=
name|sel
operator|->
name|flags
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|sel
operator|->
name|name
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"bad value (%s) for %s switch"
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the user did not specify a processor, choose one for them.  */
if|if
condition|(
name|insn_flags
operator|==
literal|0
condition|)
block|{
specifier|const
name|struct
name|processors
modifier|*
name|sel
decl_stmt|;
name|unsigned
name|int
name|sought
decl_stmt|;
specifier|static
specifier|const
struct|struct
name|cpu_default
block|{
specifier|const
name|int
name|cpu
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|}
name|cpu_defaults
index|[]
init|=
block|{
block|{
name|TARGET_CPU_arm2
block|,
literal|"arm2"
block|}
block|,
block|{
name|TARGET_CPU_arm6
block|,
literal|"arm6"
block|}
block|,
block|{
name|TARGET_CPU_arm610
block|,
literal|"arm610"
block|}
block|,
block|{
name|TARGET_CPU_arm710
block|,
literal|"arm710"
block|}
block|,
block|{
name|TARGET_CPU_arm7m
block|,
literal|"arm7m"
block|}
block|,
block|{
name|TARGET_CPU_arm7500fe
block|,
literal|"arm7500fe"
block|}
block|,
block|{
name|TARGET_CPU_arm7tdmi
block|,
literal|"arm7tdmi"
block|}
block|,
block|{
name|TARGET_CPU_arm8
block|,
literal|"arm8"
block|}
block|,
block|{
name|TARGET_CPU_arm810
block|,
literal|"arm810"
block|}
block|,
block|{
name|TARGET_CPU_arm9
block|,
literal|"arm9"
block|}
block|,
block|{
name|TARGET_CPU_strongarm
block|,
literal|"strongarm"
block|}
block|,
block|{
name|TARGET_CPU_xscale
block|,
literal|"xscale"
block|}
block|,
block|{
name|TARGET_CPU_generic
block|,
literal|"arm"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
specifier|const
name|struct
name|cpu_default
modifier|*
name|def
decl_stmt|;
comment|/* Find the default.  */
for|for
control|(
name|def
operator|=
name|cpu_defaults
init|;
name|def
operator|->
name|name
condition|;
name|def
operator|++
control|)
if|if
condition|(
name|def
operator|->
name|cpu
operator|==
name|TARGET_CPU_DEFAULT
condition|)
break|break;
comment|/* Make sure we found the default CPU.  */
if|if
condition|(
name|def
operator|->
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the default CPU's flags.  */
for|for
control|(
name|sel
operator|=
name|all_cores
init|;
name|sel
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sel
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|def
operator|->
name|name
argument_list|,
name|sel
operator|->
name|name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|sel
operator|->
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insn_flags
operator|=
name|sel
operator|->
name|flags
expr_stmt|;
comment|/* Now check to see if the user has specified some command line 	 switch that require certain abilities from the cpu.  */
name|sought
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_INTERWORK
operator|||
name|TARGET_THUMB
condition|)
block|{
name|sought
operator||=
operator|(
name|FL_THUMB
operator||
name|FL_MODE32
operator|)
expr_stmt|;
comment|/* Force apcs-32 to be used for interworking.  */
name|target_flags
operator||=
name|ARM_FLAG_APCS_32
expr_stmt|;
comment|/* There are no ARM processors that support both APCS-26 and 	     interworking.  Therefore we force FL_MODE26 to be removed 	     from insn_flags here (if it was set), so that the search 	     below will always be able to find a compatible processor.  */
name|insn_flags
operator|&=
operator|~
name|FL_MODE26
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_APCS_32
condition|)
name|sought
operator||=
name|FL_MODE26
expr_stmt|;
if|if
condition|(
name|sought
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|sought
operator|&
name|insn_flags
operator|)
operator|!=
name|sought
operator|)
condition|)
block|{
comment|/* Try to locate a CPU type that supports all of the abilities 	     of the default CPU, plus the extra abilities requested by 	     the user.  */
for|for
control|(
name|sel
operator|=
name|all_cores
init|;
name|sel
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sel
operator|++
control|)
if|if
condition|(
operator|(
name|sel
operator|->
name|flags
operator|&
name|sought
operator|)
operator|==
operator|(
name|sought
operator||
name|insn_flags
operator|)
condition|)
break|break;
if|if
condition|(
name|sel
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|int
name|current_bit_count
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|processors
modifier|*
name|best_fit
init|=
name|NULL
decl_stmt|;
comment|/* Ideally we would like to issue an error message here 		 saying that it was not possible to find a CPU compatible 		 with the default CPU, but which also supports the command 		 line options specified by the programmer, and so they 		 ought to use the -mcpu=<name> command line option to 		 override the default CPU type.  		 Unfortunately this does not work with multilibing.  We 		 need to be able to support multilibs for -mapcs-26 and for 		 -mthumb-interwork and there is no CPU that can support both 		 options.  Instead if we cannot find a cpu that has both the 		 characteristics of the default cpu and the given command line 		 options we scan the array again looking for a best match.  */
for|for
control|(
name|sel
operator|=
name|all_cores
init|;
name|sel
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sel
operator|++
control|)
if|if
condition|(
operator|(
name|sel
operator|->
name|flags
operator|&
name|sought
operator|)
operator|==
name|sought
condition|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|count
operator|=
name|bit_count
argument_list|(
name|sel
operator|->
name|flags
operator|&
name|insn_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|current_bit_count
condition|)
block|{
name|best_fit
operator|=
name|sel
expr_stmt|;
name|current_bit_count
operator|=
name|count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_fit
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|sel
operator|=
name|best_fit
expr_stmt|;
block|}
name|insn_flags
operator|=
name|sel
operator|->
name|flags
expr_stmt|;
block|}
block|}
comment|/* If tuning has not been specified, tune for whichever processor or      architecture has been selected.  */
if|if
condition|(
name|tune_flags
operator|==
literal|0
condition|)
name|tune_flags
operator|=
name|insn_flags
expr_stmt|;
comment|/* Make sure that the processor choice does not conflict with any of the      other command line choices.  */
if|if
condition|(
name|TARGET_APCS_32
operator|&&
operator|!
operator|(
name|insn_flags
operator|&
name|FL_MODE32
operator|)
condition|)
block|{
comment|/* If APCS-32 was not the default then it must have been set by the 	 user, so issue a warning message.  If the user has specified 	 "-mapcs-32 -mcpu=arm2" then we loose here.  */
if|if
condition|(
operator|(
name|TARGET_DEFAULT
operator|&
name|ARM_FLAG_APCS_32
operator|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"target CPU does not support APCS-32"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|ARM_FLAG_APCS_32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TARGET_APCS_32
operator|&&
operator|!
operator|(
name|insn_flags
operator|&
name|FL_MODE26
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"target CPU does not support APCS-26"
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|ARM_FLAG_APCS_32
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_INTERWORK
operator|&&
operator|!
operator|(
name|insn_flags
operator|&
name|FL_THUMB
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"target CPU does not support interworking"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|ARM_FLAG_INTERWORK
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_THUMB
operator|&&
operator|!
operator|(
name|insn_flags
operator|&
name|FL_THUMB
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"target CPU does not support THUMB instructions"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|ARM_FLAG_THUMB
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_APCS_FRAME
operator|&&
name|TARGET_THUMB
condition|)
block|{
comment|/* warning ("ignoring -mapcs-frame because -mthumb was used"); */
name|target_flags
operator|&=
operator|~
name|ARM_FLAG_APCS_FRAME
expr_stmt|;
block|}
comment|/* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done      from here where no function is being compiled currently.  */
if|if
condition|(
operator|(
name|target_flags
operator|&
operator|(
name|THUMB_FLAG_LEAF_BACKTRACE
operator||
name|THUMB_FLAG_BACKTRACE
operator|)
operator|)
operator|&&
name|TARGET_ARM
condition|)
name|warning
argument_list|(
literal|"enabling backtrace support is only meaningful when compiling for the Thumb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
operator|&&
name|TARGET_CALLEE_INTERWORKING
condition|)
name|warning
argument_list|(
literal|"enabling callee interworking support is only meaningful when compiling for the Thumb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
operator|&&
name|TARGET_CALLER_INTERWORKING
condition|)
name|warning
argument_list|(
literal|"enabling caller interworking support is only meaningful when compiling for the Thumb"
argument_list|)
expr_stmt|;
comment|/* If interworking is enabled then APCS-32 must be selected as well.  */
if|if
condition|(
name|TARGET_INTERWORK
condition|)
block|{
if|if
condition|(
operator|!
name|TARGET_APCS_32
condition|)
name|warning
argument_list|(
literal|"interworking forces APCS-32 to be used"
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|ARM_FLAG_APCS_32
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_APCS_STACK
operator|&&
operator|!
name|TARGET_APCS_FRAME
condition|)
block|{
name|warning
argument_list|(
literal|"-mapcs-stack-check incompatible with -mno-apcs-frame"
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|ARM_FLAG_APCS_FRAME
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_POKE_FUNCTION_NAME
condition|)
name|target_flags
operator||=
name|ARM_FLAG_APCS_FRAME
expr_stmt|;
if|if
condition|(
name|TARGET_APCS_REENT
operator|&&
name|flag_pic
condition|)
name|error
argument_list|(
literal|"-fpic and -mapcs-reent are incompatible"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_APCS_REENT
condition|)
name|warning
argument_list|(
literal|"APCS reentrant code not supported.  Ignored"
argument_list|)
expr_stmt|;
comment|/* If this target is normally configured to use APCS frames, warn if they      are turned off and debugging is turned on.  */
if|if
condition|(
name|TARGET_ARM
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
operator|!
name|TARGET_APCS_FRAME
operator|&&
operator|(
name|TARGET_DEFAULT
operator|&
name|ARM_FLAG_APCS_FRAME
operator|)
condition|)
name|warning
argument_list|(
literal|"-g with -mno-apcs-frame may not give sensible debugging"
argument_list|)
expr_stmt|;
comment|/* If stack checking is disabled, we can use r10 as the PIC register,      which keeps r9 available.  */
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|TARGET_APCS_STACK
condition|)
name|arm_pic_register
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|TARGET_APCS_FLOAT
condition|)
name|warning
argument_list|(
literal|"passing floating point arguments in fp regs not yet supported"
argument_list|)
expr_stmt|;
comment|/* Initialise boolean versions of the flags, for use in the arm.md file.  */
name|arm_fast_multiply
operator|=
operator|(
name|insn_flags
operator|&
name|FL_FAST_MULT
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch4
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH4
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch5
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH5
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch5e
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH5E
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_is_xscale
operator|=
operator|(
name|insn_flags
operator|&
name|FL_XSCALE
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_ld_sched
operator|=
operator|(
name|tune_flags
operator|&
name|FL_LDSCHED
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_is_strong
operator|=
operator|(
name|tune_flags
operator|&
name|FL_STRONG
operator|)
operator|!=
literal|0
expr_stmt|;
name|thumb_code
operator|=
operator|(
name|TARGET_ARM
operator|==
literal|0
operator|)
expr_stmt|;
name|arm_is_6_or_7
operator|=
operator|(
operator|(
operator|(
name|tune_flags
operator|&
operator|(
name|FL_MODE26
operator||
name|FL_MODE32
operator|)
operator|)
operator|&&
operator|!
operator|(
name|tune_flags
operator|&
name|FL_ARCH4
operator|)
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Default value for floating point code... if no co-processor      bus, then schedule for emulated floating point.  Otherwise,      assume the user has an FPA.      Note: this does not prevent use of floating point instructions,      -msoft-float does that.  */
name|arm_fpu
operator|=
operator|(
name|tune_flags
operator|&
name|FL_CO_PROC
operator|)
condition|?
name|FP_HARD
else|:
name|FP_SOFT3
expr_stmt|;
if|if
condition|(
name|target_fp_name
condition|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|target_fp_name
argument_list|,
literal|"2"
argument_list|)
condition|)
name|arm_fpu_arch
operator|=
name|FP_SOFT2
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|target_fp_name
argument_list|,
literal|"3"
argument_list|)
condition|)
name|arm_fpu_arch
operator|=
name|FP_SOFT3
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid floating point emulation option: -mfpe-%s"
argument_list|,
name|target_fp_name
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_fpu_arch
operator|=
name|FP_DEFAULT
expr_stmt|;
if|if
condition|(
name|TARGET_FPE
operator|&&
name|arm_fpu
operator|!=
name|FP_HARD
condition|)
name|arm_fpu
operator|=
name|FP_SOFT2
expr_stmt|;
comment|/* For arm2/3 there is no need to do any scheduling if there is only      a floating point emulator, or we are doing software floating-point.  */
if|if
condition|(
operator|(
name|TARGET_SOFT_FLOAT
operator|||
name|arm_fpu
operator|!=
name|FP_HARD
operator|)
operator|&&
operator|(
name|tune_flags
operator|&
name|FL_MODE32
operator|)
operator|==
literal|0
condition|)
name|flag_schedule_insns
operator|=
name|flag_schedule_insns_after_reload
operator|=
literal|0
expr_stmt|;
name|arm_prgmode
operator|=
name|TARGET_APCS_32
condition|?
name|PROG_MODE_PROG32
else|:
name|PROG_MODE_PROG26
expr_stmt|;
if|if
condition|(
name|structure_size_string
operator|!=
name|NULL
condition|)
block|{
name|int
name|size
init|=
name|strtol
argument_list|(
name|structure_size_string
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|8
operator|||
name|size
operator|==
literal|32
condition|)
name|arm_structure_size_boundary
operator|=
name|size
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"structure size boundary can only be set to 8 or 32"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arm_pic_register_string
operator|!=
name|NULL
condition|)
block|{
name|int
name|pic_register
decl_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|warning
argument_list|(
literal|"-mpic-register= is useless without -fpic"
argument_list|)
expr_stmt|;
name|pic_register
operator|=
name|decode_reg_name
argument_list|(
name|arm_pic_register_string
argument_list|)
expr_stmt|;
comment|/* Prevent the user from choosing an obviously stupid PIC register.  */
if|if
condition|(
name|pic_register
operator|<
literal|0
operator|||
name|call_used_regs
index|[
name|pic_register
index|]
operator|||
name|pic_register
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|pic_register
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|pic_register
operator|>=
name|PC_REGNUM
condition|)
name|error
argument_list|(
literal|"unable to use '%s' for PIC register"
argument_list|,
name|arm_pic_register_string
argument_list|)
expr_stmt|;
else|else
name|arm_pic_register
operator|=
name|pic_register
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_THUMB
operator|&&
name|flag_schedule_insns
condition|)
block|{
comment|/* Don't warn since it's on by default in -O2.  */
name|flag_schedule_insns
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If optimizing for space, don't synthesize constants.      For processors with load scheduling, it never costs more than 2 cycles      to load a constant, and the load scheduler may well reduce that to 1.  */
if|if
condition|(
name|optimize_size
operator|||
operator|(
name|tune_flags
operator|&
name|FL_LDSCHED
operator|)
condition|)
name|arm_constant_limit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arm_is_xscale
condition|)
name|arm_constant_limit
operator|=
literal|2
expr_stmt|;
comment|/* If optimizing for size, bump the number of instructions that we      are prepared to conditionally execute (even on a StrongARM).       Otherwise for the StrongARM, which has early execution of branches,      a sequence that is worth skipping is shorter.  */
if|if
condition|(
name|optimize_size
condition|)
name|max_insns_skipped
operator|=
literal|6
expr_stmt|;
elseif|else
if|if
condition|(
name|arm_is_strong
condition|)
name|max_insns_skipped
operator|=
literal|3
expr_stmt|;
comment|/* Register global variables with the garbage collector.  */
name|arm_add_gc_roots
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_add_gc_roots
parameter_list|()
block|{
name|ggc_add_rtx_root
argument_list|(
operator|&
name|arm_compare_op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|arm_compare_op1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|arm_target_insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Not sure this is really a root.  */
name|gcc_obstack_init
argument_list|(
operator|&
name|minipool_obstack
argument_list|)
expr_stmt|;
name|minipool_startobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A table of known ARM exception types.    For use with the interrupt function attribute.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|arg
decl_stmt|;
specifier|const
name|unsigned
name|long
name|return_value
decl_stmt|;
block|}
name|isr_attribute_arg
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|isr_attribute_arg
name|isr_attribute_args
index|[]
init|=
block|{
block|{
literal|"IRQ"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"irq"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"FIQ"
block|,
name|ARM_FT_FIQ
block|}
block|,
block|{
literal|"fiq"
block|,
name|ARM_FT_FIQ
block|}
block|,
block|{
literal|"ABORT"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"abort"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"ABORT"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"abort"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"UNDEF"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
literal|"undef"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
literal|"SWI"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
literal|"swi"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
name|NULL
block|,
name|ARM_FT_NORMAL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns the (interrupt) function type of the current    function, or ARM_FT_UNKNOWN if the type cannot be determined.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_isr_value
parameter_list|(
name|argument
parameter_list|)
name|tree
name|argument
decl_stmt|;
block|{
specifier|const
name|isr_attribute_arg
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* No argument - default to IRQ.  */
if|if
condition|(
name|argument
operator|==
name|NULL_TREE
condition|)
return|return
name|ARM_FT_ISR
return|;
comment|/* Get the value of the argument.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return
name|ARM_FT_UNKNOWN
return|;
name|arg
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check it against the list of known arguments.  */
for|for
control|(
name|ptr
operator|=
name|isr_attribute_args
init|;
name|ptr
operator|->
name|arg
operator|!=
name|NULL
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|arg
argument_list|,
name|ptr
operator|->
name|arg
argument_list|)
condition|)
return|return
name|ptr
operator|->
name|return_value
return|;
comment|/* An unrecognised interrupt type.  */
return|return
name|ARM_FT_UNKNOWN
return|;
block|}
end_function

begin_comment
comment|/* Computes the type of the current function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_compute_func_type
parameter_list|()
block|{
name|unsigned
name|long
name|type
init|=
name|ARM_FT_UNKNOWN
decl_stmt|;
name|tree
name|a
decl_stmt|;
name|tree
name|attr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Decide if the current function is volatile.  Such functions      never return, and many memory cycles can be saved by not storing      register values that will never be needed again.  This optimization      was added to speed up context switching in a kernel application.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|current_function_nothrow
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|type
operator||=
name|ARM_FT_VOLATILE
expr_stmt|;
if|if
condition|(
name|current_function_needs_context
condition|)
name|type
operator||=
name|ARM_FT_NESTED
expr_stmt|;
name|attr
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|a
operator|=
name|lookup_attribute
argument_list|(
literal|"naked"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL_TREE
condition|)
name|type
operator||=
name|ARM_FT_NAKED
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|eh_epilogue_sp_ofs
operator|!=
name|NULL_RTX
condition|)
name|type
operator||=
name|ARM_FT_EXCEPTION_HANDLER
expr_stmt|;
else|else
block|{
name|a
operator|=
name|lookup_attribute
argument_list|(
literal|"isr"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL_TREE
condition|)
name|a
operator|=
name|lookup_attribute
argument_list|(
literal|"interrupt"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL_TREE
condition|)
name|type
operator||=
name|TARGET_INTERWORK
condition|?
name|ARM_FT_INTERWORKED
else|:
name|ARM_FT_NORMAL
expr_stmt|;
else|else
name|type
operator||=
name|arm_isr_value
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Returns the type of the current function.  */
end_comment

begin_function
name|unsigned
name|long
name|arm_current_func_type
parameter_list|()
block|{
if|if
condition|(
name|ARM_FUNC_TYPE
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|func_type
argument_list|)
operator|==
name|ARM_FT_UNKNOWN
condition|)
name|cfun
operator|->
name|machine
operator|->
name|func_type
operator|=
name|arm_compute_func_type
argument_list|()
expr_stmt|;
return|return
name|cfun
operator|->
name|machine
operator|->
name|func_type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if it is possible to return using a single instruction.  */
end_comment

begin_function
name|int
name|use_return_insn
parameter_list|(
name|iscond
parameter_list|)
name|int
name|iscond
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|func_type
decl_stmt|;
comment|/* Never use a return instruction before reload has run.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
comment|/* Naked functions, volatile functiond and interrupt      functions all need special consideration.  */
if|if
condition|(
name|func_type
operator|&
operator|(
name|ARM_FT_INTERRUPT
operator||
name|ARM_FT_VOLATILE
operator||
name|ARM_FT_NAKED
operator|)
condition|)
return|return
literal|0
return|;
comment|/* As do variadic functions.  */
if|if
condition|(
name|current_function_pretend_args_size
operator|||
name|current_function_anonymous_args
comment|/* Of if the function calls __builtin_eh_return () */
operator|||
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_EXCEPTION_HANDLER
comment|/* Or if there is no frame pointer and there is a stack adjustment.  */
operator|||
operator|(
operator|(
name|get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|frame_pointer_needed
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Can't be done if interworking with Thumb, and any registers have been      stacked.  Similarly, on StrongARM, conditional returns are expensive      if they aren't taken and registers have been stacked.  */
if|if
condition|(
name|iscond
operator|&&
name|arm_is_strong
operator|&&
name|frame_pointer_needed
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|iscond
operator|&&
name|arm_is_strong
operator|)
operator|||
name|TARGET_INTERWORK
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag_pic
operator|&&
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
return|return
literal|0
return|;
block|}
comment|/* Can't be done if any of the FPU regs are pushed,      since this also requires an insn.  */
if|if
condition|(
name|TARGET_HARD_FLOAT
condition|)
for|for
control|(
name|regno
operator|=
name|FIRST_ARM_FP_REGNUM
init|;
name|regno
operator|<=
name|LAST_ARM_FP_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if int I is a valid immediate ARM constant.  */
end_comment

begin_function
name|int
name|const_ok_for_arm
parameter_list|(
name|i
parameter_list|)
name|HOST_WIDE_INT
name|i
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xFF
decl_stmt|;
comment|/* For machines with>32 bit HOST_WIDE_INT, the bits above bit 31 must       be all zero, or all one.  */
if|if
condition|(
operator|(
name|i
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|i
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|!=
operator|(
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Fast return for 0 and powers of 2 */
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|i
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
do|do
block|{
if|if
condition|(
operator|(
name|i
operator|&
name|mask
operator|&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|>>
operator|(
literal|32
operator|-
literal|2
operator|)
operator|)
operator||
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
expr_stmt|;
block|}
do|while
condition|(
name|mask
operator|!=
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xFF
condition|)
do|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if I is a valid constant for the operation CODE.  */
end_comment

begin_function
specifier|static
name|int
name|const_ok_for_op
parameter_list|(
name|i
parameter_list|,
name|code
parameter_list|)
name|HOST_WIDE_INT
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
block|{
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
return|return
name|const_ok_for_arm
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
operator|-
name|i
argument_list|)
argument_list|)
return|;
case|case
name|MINUS
case|:
comment|/* Should only occur with (MINUS I reg) => rsb */
case|case
name|XOR
case|:
case|case
name|IOR
case|:
return|return
literal|0
return|;
case|case
name|AND
case|:
return|return
name|const_ok_for_arm
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|i
argument_list|)
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a sequence of insns to handle a large constant.    CODE is the code of the operation required, it can be any of SET, PLUS,    IOR, AND, XOR, MINUS;    MODE is the mode in which the operation is being performed;    VAL is the integer to operate on;    SOURCE is the other operand (a register, or a null-pointer for SET);    SUBTARGETS means it is safe to create scratch registers if that will    either produce a simpler sequence, or we will want to cse the values.    Return value is the number of insns emitted.  */
end_comment

begin_function
name|int
name|arm_split_constant
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|val
parameter_list|,
name|target
parameter_list|,
name|source
parameter_list|,
name|subtargets
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|source
decl_stmt|;
name|int
name|subtargets
decl_stmt|;
block|{
if|if
condition|(
name|subtargets
operator|||
name|code
operator|==
name|SET
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|source
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|source
argument_list|)
operator|)
condition|)
block|{
comment|/* After arm_reorg has been called, we can't fix up expensive 	 constants by pushing them into memory so we must synthesise 	 them in-line, regardless of the cost.  This is only likely to 	 be more costly on chips that have load delay slots and we are 	 compiling without running the scheduler (so no splitting 	 occurred before the final instruction emission).  	 Ref: gcc -O1 -mcpu=strongarm gcc.c-torture/compile/980506-2.c       */
if|if
condition|(
operator|!
name|after_arm_reorg
operator|&&
operator|(
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|val
argument_list|,
name|target
argument_list|,
name|source
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|>
name|arm_constant_limit
operator|+
operator|(
name|code
operator|!=
name|SET
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
comment|/* Currently SET is the only monadic value for CODE, all 		 the rest are diadic.  */
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|rtx
name|temp
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For MINUS, the value is subtracted from, since we never 		 have subtraction of a constant.  */
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|temp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
block|}
return|return
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|val
argument_list|,
name|target
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|count_insns_for_constant
parameter_list|(
name|HOST_WIDE_INT
name|remainder
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|HOST_WIDE_INT
name|temp1
decl_stmt|;
name|int
name|num_insns
init|=
literal|0
decl_stmt|;
do|do
block|{
name|int
name|end
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
operator|(
name|i
operator|-
literal|2
operator|)
operator|)
condition|)
block|{
name|end
operator|=
name|i
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
literal|32
expr_stmt|;
name|temp1
operator|=
name|remainder
operator|&
operator|(
operator|(
literal|0x0ff
operator|<<
name|end
operator|)
operator||
operator|(
operator|(
name|i
operator|<
name|end
operator|)
condition|?
operator|(
literal|0xff
operator|>>
operator|(
literal|32
operator|-
name|end
operator|)
operator|)
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|remainder
operator|&=
operator|~
name|temp1
expr_stmt|;
name|num_insns
operator|++
expr_stmt|;
name|i
operator|-=
literal|6
expr_stmt|;
block|}
name|i
operator|-=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|remainder
condition|)
do|;
return|return
name|num_insns
return|;
block|}
end_function

begin_comment
comment|/* As above, but extra parameter GENERATE which, if clear, suppresses    RTL generation.  */
end_comment

begin_function
specifier|static
name|int
name|arm_gen_constant
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|val
parameter_list|,
name|target
parameter_list|,
name|source
parameter_list|,
name|subtargets
parameter_list|,
name|generate
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|source
decl_stmt|;
name|int
name|subtargets
decl_stmt|;
name|int
name|generate
decl_stmt|;
block|{
name|int
name|can_invert
init|=
literal|0
decl_stmt|;
name|int
name|can_negate
init|=
literal|0
decl_stmt|;
name|int
name|can_negate_initial
init|=
literal|0
decl_stmt|;
name|int
name|can_shift
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_bits_set
init|=
literal|0
decl_stmt|;
name|int
name|set_sign_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|clear_sign_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|clear_zero_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|set_zero_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|insns
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|temp1
decl_stmt|,
name|temp2
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|remainder
init|=
name|val
operator|&
literal|0xffffffff
decl_stmt|;
comment|/* Find out which operations are safe for a given CODE.  Also do a quick      check for degenerate cases; these can occur when DImode operations      are split.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SET
case|:
name|can_invert
operator|=
literal|1
expr_stmt|;
name|can_shift
operator|=
literal|1
expr_stmt|;
name|can_negate
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|can_negate
operator|=
literal|1
expr_stmt|;
name|can_negate_initial
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|remainder
operator|==
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|&&
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|remainder
operator|==
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|&&
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|can_invert
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XOR
case|:
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|&&
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|remainder
operator|==
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* We don't know how to handle this yet below.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|MINUS
case|:
comment|/* We treat MINUS as (val - source), since (source - val) is always 	 passed as (source + (-val)).  */
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|can_negate
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If we can do it in one insn get out quickly.  */
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|val
argument_list|)
operator|||
operator|(
name|can_negate_initial
operator|&&
name|const_ok_for_arm
argument_list|(
operator|-
name|val
argument_list|)
operator|)
operator|||
operator|(
name|can_invert
operator|&&
name|const_ok_for_arm
argument_list|(
operator|~
name|val
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
operator|(
name|source
condition|?
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
else|:
name|GEN_INT
argument_list|(
name|val
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Calculate a few attributes that may be useful for specific      optimizations.  */
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|clear_sign_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|set_sign_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|31
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|clear_zero_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|31
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|set_zero_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SET
case|:
comment|/* See if we can do this by sign_extending a constant that is known 	 to be negative.  This is a good, way of doing it, since the shift 	 may well merge into a subsequent insn.  */
if|if
condition|(
name|set_sign_bit_copies
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|temp1
operator|=
name|ARM_SIGN_EXTEND
argument_list|(
name|remainder
operator|<<
operator|(
name|set_sign_bit_copies
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|set_sign_bit_copies
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
comment|/* For an inverted constant, we will need to set the low bits, 	     these will be shifted out of harm's way.  */
name|temp1
operator||=
operator|(
literal|1
operator|<<
operator|(
name|set_sign_bit_copies
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|const_ok_for_arm
argument_list|(
operator|~
name|temp1
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashrsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|set_sign_bit_copies
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
block|}
comment|/* See if we can generate this by setting the bottom (or the top) 	 16 bits, and then shifting these into the other half of the 	 word.  We only look for the simplest cases, to do more would cost 	 too much.  Be careful, however, not to generate this when the 	 alternative would take fewer insns.  */
if|if
condition|(
name|val
operator|&
literal|0xffff0000
condition|)
block|{
name|temp1
operator|=
name|remainder
operator|&
literal|0xffff0000
expr_stmt|;
name|temp2
operator|=
name|remainder
operator|&
literal|0x0000ffff
expr_stmt|;
comment|/* Overlaps outside this range are best done using other methods.  */
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|temp2
operator||
operator|(
name|temp2
operator|<<
name|i
operator|)
operator|)
operator|&
literal|0xffffffff
operator|)
operator|==
name|remainder
operator|)
operator|&&
operator|!
name|const_ok_for_arm
argument_list|(
name|temp2
argument_list|)
condition|)
block|{
name|rtx
name|new_src
init|=
operator|(
name|subtargets
condition|?
operator|(
name|generate
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|NULL_RTX
operator|)
else|:
name|target
operator|)
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|temp2
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
name|generate
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|mode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insns
operator|+
literal|1
return|;
block|}
block|}
comment|/* Don't duplicate cases already considered.  */
for|for
control|(
name|i
operator|=
literal|17
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|temp1
operator||
operator|(
name|temp1
operator|>>
name|i
operator|)
operator|)
operator|==
name|remainder
operator|)
operator|&&
operator|!
name|const_ok_for_arm
argument_list|(
name|temp1
argument_list|)
condition|)
block|{
name|rtx
name|new_src
init|=
operator|(
name|subtargets
condition|?
operator|(
name|generate
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|NULL_RTX
operator|)
else|:
name|target
operator|)
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|temp1
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
name|generate
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
if|if
condition|(
name|generate
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insns
operator|+
literal|1
return|;
block|}
block|}
block|}
break|break;
case|case
name|IOR
case|:
case|case
name|XOR
case|:
comment|/* If we have IOR or XOR, and the constant can be loaded in a 	 single instruction, and we can find a temporary to put it in, 	 then this can be done in two instructions instead of 3-4.  */
if|if
condition|(
name|subtargets
comment|/* TARGET can't be NULL if SUBTARGETS is 0 */
operator|||
operator|(
name|reload_completed
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|val
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|sub
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|XOR
condition|)
break|break;
if|if
condition|(
name|set_sign_bit_copies
operator|>
literal|8
operator|&&
operator|(
name|val
operator|&
operator|(
operator|-
literal|1
operator|<<
operator|(
literal|32
operator|-
name|set_sign_bit_copies
operator|)
operator|)
operator|)
operator|==
name|val
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|set_sign_bit_copies
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|sub
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
if|if
condition|(
name|set_zero_bit_copies
operator|>
literal|8
operator|&&
operator|(
name|remainder
operator|&
operator|(
operator|(
literal|1
operator|<<
name|set_zero_bit_copies
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|remainder
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|set_zero_bit_copies
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|sub
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|temp1
operator|=
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|val
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|source
operator|=
name|sub
expr_stmt|;
if|if
condition|(
name|subtargets
condition|)
name|sub
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|sub
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|3
return|;
block|}
break|break;
case|case
name|AND
case|:
comment|/* See if two shifts will do 2 or more insn's worth of work.  */
if|if
condition|(
name|clear_sign_bit_copies
operator|>=
literal|16
operator|&&
name|clear_sign_bit_copies
operator|<
literal|24
condition|)
block|{
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|(
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|32
operator|-
name|clear_sign_bit_copies
operator|)
operator|)
operator|&
literal|0xffffffff
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|remainder
operator||
name|shift_mask
operator|)
operator|!=
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|targ
init|=
name|subtargets
condition|?
name|NULL_RTX
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|targ
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|clear_sign_bit_copies
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|new_src
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|insns
operator|+
literal|2
return|;
block|}
if|if
condition|(
name|clear_zero_bit_copies
operator|>=
literal|16
operator|&&
name|clear_zero_bit_copies
operator|<
literal|24
condition|)
block|{
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|(
literal|1
operator|<<
name|clear_zero_bit_copies
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|remainder
operator||
name|shift_mask
operator|)
operator|!=
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|targ
init|=
name|subtargets
condition|?
name|NULL_RTX
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|targ
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|clear_zero_bit_copies
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|new_src
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|insns
operator|+
literal|2
return|;
block|}
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|num_bits_set
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|AND
operator|||
operator|(
name|can_invert
operator|&&
name|num_bits_set
operator|>
literal|16
operator|)
condition|)
name|remainder
operator|=
operator|(
operator|~
name|remainder
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|num_bits_set
operator|>
literal|16
condition|)
name|remainder
operator|=
operator|(
operator|-
name|remainder
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
else|else
block|{
name|can_invert
operator|=
literal|0
expr_stmt|;
name|can_negate
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now try and find a way of doing the job in either two or three      instructions.      We start by looking for the largest block of zeros that are aligned on      a 2-bit boundary, we then fill up the temps, wrapping around to the      top of the word when we drop off the bottom.      In the worst case this code should produce no more than four insns.  */
block|{
name|int
name|best_start
init|=
literal|0
decl_stmt|;
name|int
name|best_consecutive_zeros
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|int
name|consecutive_zeros
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
name|i
operator|)
operator|)
condition|)
block|{
while|while
condition|(
operator|(
name|i
operator|<
literal|32
operator|)
operator|&&
operator|!
operator|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
name|i
operator|)
operator|)
condition|)
block|{
name|consecutive_zeros
operator|+=
literal|2
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|consecutive_zeros
operator|>
name|best_consecutive_zeros
condition|)
block|{
name|best_consecutive_zeros
operator|=
name|consecutive_zeros
expr_stmt|;
name|best_start
operator|=
name|i
operator|-
name|consecutive_zeros
expr_stmt|;
block|}
name|i
operator|-=
literal|2
expr_stmt|;
block|}
block|}
comment|/* So long as it won't require any more insns to do so, it's        desirable to emit a small constant (in bits 0...9) in the last        insn.  This way there is more chance that it can be combined with        a later addressing insn to form a pre-indexed load or store        operation.  Consider:  	       *((volatile int *)0xe0000100) = 1; 	       *((volatile int *)0xe0000110) = 2;         We want this to wind up as:  		mov rA, #0xe0000000 		mov rB, #1 		str rB, [rA, #0x100] 		mov rB, #2 		str rB, [rA, #0x110]         rather than having to synthesize both large constants from scratch.         Therefore, we calculate how many insns would be required to emit        the constant starting from `best_start', and also starting from         zero (ie with bit 31 first to be output).  If `best_start' doesn't         yield a shorter sequence, we may as well use zero.  */
if|if
condition|(
name|best_start
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|best_start
operator|)
operator|<
name|remainder
operator|)
operator|&&
operator|(
name|count_insns_for_constant
argument_list|(
name|remainder
argument_list|,
literal|0
argument_list|)
operator|<=
name|count_insns_for_constant
argument_list|(
name|remainder
argument_list|,
name|best_start
argument_list|)
operator|)
condition|)
name|best_start
operator|=
literal|0
expr_stmt|;
comment|/* Now start emitting the insns.  */
name|i
operator|=
name|best_start
expr_stmt|;
do|do
block|{
name|int
name|end
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
operator|(
name|i
operator|-
literal|2
operator|)
operator|)
condition|)
block|{
name|end
operator|=
name|i
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
literal|32
expr_stmt|;
name|temp1
operator|=
name|remainder
operator|&
operator|(
operator|(
literal|0x0ff
operator|<<
name|end
operator|)
operator||
operator|(
operator|(
name|i
operator|<
name|end
operator|)
condition|?
operator|(
literal|0xff
operator|>>
operator|(
literal|32
operator|-
name|end
operator|)
operator|)
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|remainder
operator|&=
operator|~
name|temp1
expr_stmt|;
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
decl_stmt|,
name|temp1_rtx
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|MINUS
condition|)
block|{
name|new_src
operator|=
operator|(
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
operator|)
expr_stmt|;
if|if
condition|(
name|can_invert
operator|&&
name|code
operator|!=
name|MINUS
condition|)
name|temp1
operator|=
operator|~
name|temp1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remainder
operator|&&
name|subtargets
condition|)
name|new_src
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|new_src
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|can_invert
condition|)
name|temp1
operator|=
operator|~
name|temp1
expr_stmt|;
elseif|else
if|if
condition|(
name|can_negate
condition|)
name|temp1
operator|=
operator|-
name|temp1
expr_stmt|;
block|}
name|temp1
operator|=
name|trunc_int_for_mode
argument_list|(
name|temp1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|temp1_rtx
operator|=
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|temp1_rtx
operator|=
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|temp1_rtx
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
name|temp1_rtx
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|temp1_rtx
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_src
argument_list|,
name|temp1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|can_invert
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|PLUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|code
operator|=
name|PLUS
expr_stmt|;
name|insns
operator|++
expr_stmt|;
name|i
operator|-=
literal|6
expr_stmt|;
block|}
name|i
operator|-=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|remainder
condition|)
do|;
block|}
return|return
name|insns
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize a comparison so that we are more likely to recognize it.    This can be done for a few constant compares, where we can make the    immediate value easier to load.  */
end_comment

begin_function
name|enum
name|rtx_code
name|arm_canonicalize_comparison
parameter_list|(
name|code
parameter_list|,
name|op1
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
modifier|*
name|op1
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
name|INTVAL
argument_list|(
operator|*
name|op1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
name|code
return|;
case|case
name|GT
case|:
case|case
name|LE
case|:
if|if
condition|(
name|i
operator|!=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GT
condition|?
name|GE
else|:
name|LT
return|;
block|}
break|break;
case|case
name|GE
case|:
case|case
name|LT
case|:
if|if
condition|(
name|i
operator|!=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
literal|1
operator|)
operator|)
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GE
condition|?
name|GT
else|:
name|LE
return|;
block|}
break|break;
case|case
name|GTU
case|:
case|case
name|LEU
case|:
if|if
condition|(
name|i
operator|!=
operator|~
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GTU
condition|?
name|GEU
else|:
name|LTU
return|;
block|}
break|break;
case|case
name|GEU
case|:
case|case
name|LTU
case|:
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GEU
condition|?
name|GTU
else|:
name|LEU
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Decide whether a type should be returned in memory (true)    or in a register (false).  This is called by the macro    RETURN_IN_MEMORY.  */
end_comment

begin_function
name|int
name|arm_return_in_memory
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* All simple types are returned in registers.  */
return|return
literal|0
return|;
comment|/* For the arm-wince targets we choose to be compitable with Microsoft's      ARM and Thumb compilers, which always return aggregates in memory.  */
ifndef|#
directive|ifndef
name|ARM_WINCE
comment|/* All structures/unions bigger than one word are returned in memory.      Also catch the case where int_size_in_bytes returns -1.  In this case      the aggregate is either huge or of varaible size, and in either case      we will want to return it via memory and not in a register.  */
if|if
condition|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|)
operator|>
name|UNITS_PER_WORD
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* For a struct the APCS says that we only return in a register 	 if the type is 'integer like' and every addressable element 	 has an offset of zero.  For practical purposes this means 	 that the structure can have at most one non bit-field element 	 and that this element must be the first one in the structure.  */
comment|/* Find the first field, ignoring non FIELD_DECL things which will 	 have been created by C++.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
continue|continue;
if|if
condition|(
name|field
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* An empty structure.  Allowed by an extension to ANSI C.  */
comment|/* Check that the first field is valid for returning in a register.  */
comment|/* ... Floats are not allowed */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* ... Aggregates that are not themselves valid for returning in 	 a register are not allowed.  */
if|if
condition|(
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Now check the remaining fields, if any.  Only bitfields are allowed, 	 since they are not addressable.  */
for|for
control|(
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* Unions can be returned in registers if every element is 	 integral, or can be returned in an integer register.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* not ARM_WINCE */
comment|/* Return all other types in memory.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is NULL.  */
end_comment

begin_function
name|void
name|arm_init_cumulative_args
parameter_list|(
name|pcum
parameter_list|,
name|fntype
parameter_list|,
name|libname
parameter_list|,
name|indirect
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|pcum
decl_stmt|;
name|tree
name|fntype
decl_stmt|;
name|rtx
name|libname
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|indirect
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* On the ARM, the offset starts at 0.  */
name|pcum
operator|->
name|nregs
operator|=
operator|(
operator|(
name|fntype
operator|&&
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|fntype
argument_list|)
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_NORMAL
expr_stmt|;
if|if
condition|(
name|TARGET_LONG_CALLS
condition|)
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_LONG
expr_stmt|;
comment|/* Check for long call/short call attributes.  The attributes      override any command line option.  */
if|if
condition|(
name|fntype
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_SHORT
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_LONG
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine where to put an argument to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).  */
end_comment

begin_function
name|rtx
name|arm_function_arg
parameter_list|(
name|pcum
parameter_list|,
name|mode
parameter_list|,
name|type
parameter_list|,
name|named
parameter_list|)
name|CUMULATIVE_ARGS
modifier|*
name|pcum
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|named
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
comment|/* Compute operand 2 of the call insn.  */
return|return
name|GEN_INT
argument_list|(
name|pcum
operator|->
name|call_cookie
argument_list|)
return|;
if|if
condition|(
operator|!
name|named
operator|||
name|pcum
operator|->
name|nregs
operator|>=
name|NUM_ARG_REGS
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|pcum
operator|->
name|nregs
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Encode the current state of the #pragma [no_]long_calls.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|OFF
block|,
comment|/* No #pramgma [no_]long_calls is in effect.  */
name|LONG
block|,
comment|/* #pragma long_calls is in effect.  */
name|SHORT
comment|/* #pragma no_long_calls is in effect.  */
block|}
name|arm_pragma_enum
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|arm_pragma_enum
name|arm_pragma_long_calls
init|=
name|OFF
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|arm_pr_long_calls
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|arm_pragma_long_calls
operator|=
name|LONG
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_pr_no_long_calls
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|arm_pragma_long_calls
operator|=
name|SHORT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_pr_long_calls_off
parameter_list|(
name|pfile
parameter_list|)
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|arm_pragma_long_calls
operator|=
name|OFF
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of machine attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|arm_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
comment|/* Function calls made to this symbol must be done indirectly, because      it may lie outside of the 26 bit addressing range of a normal function      call.  */
block|{
literal|"long_call"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|NULL
block|}
block|,
comment|/* Whereas these functions are always known to reside within the 26 bit      addressing range.  */
block|{
literal|"short_call"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|NULL
block|}
block|,
comment|/* Interrupt Service Routines have special prologue and epilogue requirements.  */
block|{
literal|"isr"
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|arm_handle_isr_attribute
block|}
block|,
block|{
literal|"interrupt"
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|arm_handle_isr_attribute
block|}
block|,
block|{
literal|"naked"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|arm_handle_fndecl_attribute
block|}
block|,
ifdef|#
directive|ifdef
name|ARM_PE
comment|/* ARM/PE has three new attributes:      interfacearm - ?      dllexport - for exporting a function/variable that will live in a dll      dllimport - for importing a function/variable from a dll       Microsoft allows multiple declspecs in one __declspec, separating      them with spaces.  We do NOT support this.  Instead, use __declspec      multiple times.   */
block|{
literal|"dllimport"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"dllexport"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"interfacearm"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|arm_handle_fndecl_attribute
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle an attribute requiring a FUNCTION_DECL;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|arm_handle_fndecl_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|flags
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle an "interrupt" or "isr" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|arm_handle_isr_attribute
parameter_list|(
name|node
parameter_list|,
name|name
parameter_list|,
name|args
parameter_list|,
name|flags
parameter_list|,
name|no_add_attrs
parameter_list|)
name|tree
modifier|*
name|node
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|tree
name|args
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|bool
modifier|*
name|no_add_attrs
decl_stmt|;
block|{
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
comment|/* FIXME: the argument if any is checked for type attributes; 	 should it be checked for decl ones?  */
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|arm_isr_value
argument_list|(
name|args
argument_list|)
operator|==
name|ARM_FT_UNKNOWN
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
name|arm_isr_value
argument_list|(
name|args
argument_list|)
operator|!=
name|ARM_FT_UNKNOWN
condition|)
block|{
operator|*
name|node
operator|=
name|build_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
name|build_type_attribute_variant
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* Possibly pass this attribute on from the type to a decl.  */
if|if
condition|(
name|flags
operator|&
operator|(
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
operator|)
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return 0 if the attributes for two types are incompatible, 1 if they    are compatible, and 2 if they are nearly compatible (which causes a    warning to be generated).  */
end_comment

begin_function
specifier|static
name|int
name|arm_comp_type_attributes
parameter_list|(
name|type1
parameter_list|,
name|type2
parameter_list|)
name|tree
name|type1
decl_stmt|;
name|tree
name|type2
decl_stmt|;
block|{
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|;
comment|/* Check for mismatch of non-default calling convention.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
return|return
literal|1
return|;
comment|/* Check for mismatched call attributes.  */
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|l2
operator|=
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|s1
operator|=
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|s2
operator|=
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
comment|/* Only bother to check if an attribute is defined.  */
if|if
condition|(
name|l1
operator||
name|l2
operator||
name|s1
operator||
name|s2
condition|)
block|{
comment|/* If one type has an attribute, the other must have the same attribute.  */
if|if
condition|(
operator|(
name|l1
operator|!=
name|l2
operator|)
operator|||
operator|(
name|s1
operator|!=
name|s2
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Disallow mixed attributes.  */
if|if
condition|(
operator|(
name|l1
operator|&
name|s2
operator|)
operator|||
operator|(
name|l2
operator|&
name|s1
operator|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Check for mismatched ISR attribute.  */
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"isr"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|l1
condition|)
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"interrupt"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|l2
operator|=
name|lookup_attribute
argument_list|(
literal|"isr"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|l2
condition|)
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"interrupt"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|l1
operator|!=
name|l2
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  Encode long_call or short_call attribute by prefixing     symbol name in DECL with a special character FLAG.  */
end_comment

begin_function
name|void
name|arm_encode_call_attribute
parameter_list|(
name|decl
parameter_list|,
name|flag
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newstr
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return;
comment|/* Do not allow weak functions to be treated as short call.  */
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|&&
name|flag
operator|==
name|SHORT_CALL_FLAG_CHAR
condition|)
return|return;
name|newstr
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|newstr
index|[
literal|0
index|]
operator|=
name|flag
expr_stmt|;
name|strcpy
argument_list|(
name|newstr
operator|+
literal|1
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|newstr
operator|=
operator|(
name|char
operator|*
operator|)
name|ggc_alloc_string
argument_list|(
name|newstr
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|newstr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Assigns default attributes to newly defined type.  This is used to     set short_call/long_call attributes for function types of     functions defined inside corresponding #pragma scopes.  */
end_comment

begin_function
specifier|static
name|void
name|arm_set_default_type_attributes
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
comment|/* Add __attribute__ ((long_call)) to all functions, when      inside #pragma long_calls or __attribute__ ((short_call)),      when inside #pragma no_long_calls.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|type_attr_list
decl_stmt|,
name|attr_name
decl_stmt|;
name|type_attr_list
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_pragma_long_calls
operator|==
name|LONG
condition|)
name|attr_name
operator|=
name|get_identifier
argument_list|(
literal|"long_call"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arm_pragma_long_calls
operator|==
name|SHORT
condition|)
name|attr_name
operator|=
name|get_identifier
argument_list|(
literal|"short_call"
argument_list|)
expr_stmt|;
else|else
return|return;
name|type_attr_list
operator|=
name|tree_cons
argument_list|(
name|attr_name
argument_list|,
name|NULL_TREE
argument_list|,
name|type_attr_list
argument_list|)
expr_stmt|;
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
operator|=
name|type_attr_list
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the operand is a SYMBOL_REF for a function known to be    defined within the current compilation unit.  If this caanot be    determined, then 0 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|current_file_function_operand
parameter_list|(
name|sym_ref
parameter_list|)
name|rtx
name|sym_ref
decl_stmt|;
block|{
comment|/* This is a bit of a fib.  A function will have a short call flag      applied to its name if it has the short call attribute, or it has      already been defined within the current compilation unit.  */
if|if
condition|(
name|ENCODED_SHORT_CALL_ATTR_P
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The current function is always defined within the current compilation      unit.  if it s a weak definition however, then this may not be the real      definition of the function, and so we have to say no.  */
if|if
condition|(
name|sym_ref
operator|==
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|current_function_decl
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We cannot make the determination - default to returning 0.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if a 32 bit "long_call" should be generated for    this call.  We generate a long_call if the function:          a.  has an __attribute__((long call))      or b.  is within the scope of a #pragma long_calls      or c.  the -mlong-calls command line switch has been specified     However we do not generate a long call if the function:             d.  has an __attribute__ ((short_call))      or e.  is inside the scope of a #pragma no_long_calls      or f.  has an __attribute__ ((section))      or g.  is defined within the current compilation unit.        This function will be called by C fragments contained in the machine    description file.  CALL_REF and CALL_COOKIE correspond to the matched    rtl operands.  CALL_SYMBOL is used to distinguish between    two different callers of the function.  It is set to 1 in the    "call_symbol" and "call_symbol_value" patterns and to 0 in the "call"    and "call_value" patterns.  This is because of the difference in the    SYM_REFs passed by these patterns.  */
end_comment

begin_function
name|int
name|arm_is_longcall_p
parameter_list|(
name|sym_ref
parameter_list|,
name|call_cookie
parameter_list|,
name|call_symbol
parameter_list|)
name|rtx
name|sym_ref
decl_stmt|;
name|int
name|call_cookie
decl_stmt|;
name|int
name|call_symbol
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|call_symbol
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|sym_ref
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|sym_ref
operator|=
name|XEXP
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|sym_ref
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|call_cookie
operator|&
name|CALL_SHORT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_LONG_CALLS
operator|&&
name|flag_function_sections
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|current_file_function_operand
argument_list|(
name|sym_ref
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|call_cookie
operator|&
name|CALL_LONG
operator|)
operator|||
name|ENCODED_LONG_CALL_ATTR_P
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|TARGET_LONG_CALLS
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if it is ok to make a tail-call to DECL.  */
end_comment

begin_function
name|int
name|arm_function_ok_for_sibcall
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|int
name|call_type
init|=
name|TARGET_LONG_CALLS
condition|?
name|CALL_LONG
else|:
name|CALL_NORMAL
decl_stmt|;
comment|/* Never tailcall something for which we have no decl, or if we      are in Thumb mode.  */
if|if
condition|(
name|decl
operator|==
name|NULL
operator|||
name|TARGET_THUMB
condition|)
return|return
literal|0
return|;
comment|/* Get the calling method.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|call_type
operator|=
name|CALL_SHORT
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|call_type
operator|=
name|CALL_LONG
expr_stmt|;
comment|/* Cannot tail-call to long calls, since these are out of range of      a branch instruction.  However, if not compiling PIC, we know      we can reach the symbol if it is in this compilation unit.  */
if|if
condition|(
name|call_type
operator|==
name|CALL_LONG
operator|&&
operator|(
name|flag_pic
operator|||
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* If we are interworking and the function is not declared static      then we can't tail-call it unless we know that it exists in this       compilation unit (since it might be a Thumb routine).  */
if|if
condition|(
name|TARGET_INTERWORK
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Never tailcall from an ISR routine - it needs a special exit sequence.  */
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|arm_current_func_type
argument_list|()
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Everything else is ok.  */
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|legitimate_pic_operand_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|flag_pic
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|orig
parameter_list|,
name|mode
parameter_list|,
name|reg
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
name|rtx
name|pic_ref
decl_stmt|,
name|address
decl_stmt|;
endif|#
directive|endif
name|rtx
name|insn
decl_stmt|;
name|int
name|subregs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|no_new_pseudos
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|subregs
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
comment|/* The AOF assembler can generate relocations for these directly, and 	 understands that the PIC register has to be added into the offset.  */
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_pic_load_addr_based
argument_list|(
name|reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|subregs
condition|)
name|address
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
else|else
name|address
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
condition|)
name|emit_insn
argument_list|(
name|gen_pic_load_addr_arm
argument_list|(
name|address
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_pic_load_addr_thumb
argument_list|(
name|address
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|NEED_GOT_RELOC
condition|)
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|address
argument_list|)
expr_stmt|;
else|else
block|{
name|pic_ref
operator|=
name|gen_rtx_MEM
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|pic_offset_table_rtx
argument_list|,
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|pic_ref
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
comment|/* Put a REG_EQUAL note on this insn, so that it can be optimized 	 by loop.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|orig
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|pic_offset_table_rtx
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|no_new_pseudos
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|offset
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* The base register doesn't really matter, we only want to 	     test the index for the appropriate mode.  */
name|ARM_GO_IF_LEGITIMATE_INDEX
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|,
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_new_pseudos
condition|)
name|offset
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|win
label|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|4
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|TARGET_SOFT_FLOAT
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|reg
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
return|return
name|orig
return|;
block|}
end_function

begin_comment
comment|/* Generate code to load the PIC register.  PROLOGUE is true if    called from arm_expand_prologue (in which case we want the     generated insns at the start of the function);  false if called    by an exception receiver that needs the PIC register reloaded    (in which case the insns are just dumped at the current location).  */
end_comment

begin_function
name|void
name|arm_finalize_pic
parameter_list|(
name|prologue
parameter_list|)
name|int
name|prologue
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
name|rtx
name|l1
decl_stmt|,
name|pic_tmp
decl_stmt|,
name|pic_tmp2
decl_stmt|,
name|seq
decl_stmt|,
name|pic_rtx
decl_stmt|;
name|rtx
name|global_offset_table
decl_stmt|;
if|if
condition|(
name|current_function_uses_pic_offset_table
operator|==
literal|0
operator|||
name|TARGET_SINGLE_PIC_BASE
condition|)
return|return;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|abort
argument_list|()
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|l1
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|global_offset_table
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
comment|/* On the ARM the PC register contains 'dot + 8' at the time of the      addition, on the Thumb it is 'dot + 4'.  */
name|pic_tmp
operator|=
name|plus_constant
argument_list|(
name|gen_rtx_LABEL_REF
argument_list|(
name|Pmode
argument_list|,
name|l1
argument_list|)
argument_list|,
name|TARGET_ARM
condition|?
literal|8
else|:
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|GOT_PCREL
condition|)
name|pic_tmp2
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|global_offset_table
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pic_tmp2
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|global_offset_table
argument_list|)
expr_stmt|;
name|pic_rtx
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|pic_tmp2
argument_list|,
name|pic_tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_pic_load_addr_arm
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|pic_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pic_add_dot_plus_eight
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|l1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_pic_load_addr_thumb
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|pic_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pic_add_dot_plus_four
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|l1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|prologue
condition|)
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* Need to emit this whether or not we obey regdecls,      since setjmp/longjmp can cause life info to screw up.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|pic_offset_table_rtx
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AOF_ASSEMBLER */
block|}
end_function

begin_define
define|#
directive|define
name|REG_OR_SUBREG_REG
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == REG							\    || (GET_CODE (X) == SUBREG&& GET_CODE (SUBREG_REG (X)) == REG))
end_define

begin_define
define|#
directive|define
name|REG_OR_SUBREG_RTX
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == REG ? (X) : SUBREG_REG (X))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|COSTS_N_INSNS
end_ifndef

begin_define
define|#
directive|define
name|COSTS_N_INSNS
parameter_list|(
name|N
parameter_list|)
value|((N) * 4 - 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|arm_rtx_costs
parameter_list|(
name|x
parameter_list|,
name|code
parameter_list|,
name|outer
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|enum
name|rtx_code
name|outer
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|subcode
decl_stmt|;
name|int
name|extra_cost
decl_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|COMPARE
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
return|return
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|MULT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|cycles
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
condition|)
block|{
name|i
operator|>>=
literal|2
expr_stmt|;
name|cycles
operator|++
expr_stmt|;
block|}
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
operator|+
name|cycles
return|;
block|}
return|return
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|16
return|;
case|case
name|SET
case|:
return|return
operator|(
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|4
operator|*
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|+
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|)
return|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|outer
operator|==
name|SET
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|thumb_shiftable_const
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
return|;
return|return
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|outer
operator|==
name|PLUS
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>
operator|-
literal|256
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|outer
operator|==
name|COMPARE
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|outer
operator|==
name|ASHIFT
operator|||
name|outer
operator|==
name|ASHIFTRT
operator|||
name|outer
operator|==
name|LSHIFTRT
condition|)
return|return
literal|0
return|;
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
return|;
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
return|;
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
return|return
literal|100
return|;
case|case
name|TRUNCATE
case|:
return|return
literal|99
return|;
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|IOR
case|:
comment|/* XXX guess. */
return|return
literal|8
return|;
case|case
name|ADDRESSOF
case|:
case|case
name|MEM
case|:
comment|/* XXX another guess.  */
comment|/* Memory costs quite a lot for the first word, but subsequent words 	     load at the equivalent of a single insn each.  */
return|return
operator|(
literal|10
operator|+
literal|4
operator|*
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|IF_THEN_ELSE
case|:
comment|/* XXX a guess. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
return|return
literal|14
return|;
return|return
literal|2
return|;
case|case
name|ZERO_EXTEND
case|:
comment|/* XXX still guessing.  */
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|HImode
case|:
return|return
operator|(
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|SImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
default|default:
return|return
literal|99
return|;
block|}
default|default:
return|return
literal|99
return|;
if|#
directive|if
literal|0
block|case FFS: 	case FLOAT: 	case FIX: 	case UNSIGNED_FIX:
comment|/* XXX guess */
block|fprintf (stderr, "unexpected code for thumb in rtx_costs: %s\n", 		   rtx_name[code]); 	  abort ();
endif|#
directive|endif
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
comment|/* Memory costs quite a lot for the first word, but subsequent words 	 load at the equivalent of a single insn each.  */
return|return
operator|(
literal|10
operator|+
literal|4
operator|*
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|DIV
case|:
case|case
name|MOD
case|:
return|return
literal|100
return|;
case|case
name|ROTATE
case|:
if|if
condition|(
name|mode
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|4
return|;
comment|/* Fall through */
case|case
name|ROTATERT
case|:
if|if
condition|(
name|mode
operator|!=
name|SImode
condition|)
return|return
literal|8
return|;
comment|/* Fall through */
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
operator|(
literal|8
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
return|return
operator|(
literal|1
operator|+
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|+
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
return|;
case|case
name|MINUS
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
operator|(
literal|4
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
operator|(
literal|2
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|const_double_rtx_ok_for_fpu
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|const_double_rtx_ok_for_fpu
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|subcode
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|ASHIFT
operator|||
name|subcode
operator|==
name|ASHIFTRT
operator|||
name|subcode
operator|==
name|LSHIFTRT
operator|||
name|subcode
operator|==
name|ROTATE
operator|||
name|subcode
operator|==
name|ROTATERT
operator|||
operator|(
name|subcode
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Fall through */
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
operator|(
literal|2
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|const_double_rtx_ok_for_fpu
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
comment|/* Fall through */
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|IOR
case|:
name|extra_cost
operator|=
literal|0
expr_stmt|;
comment|/* Normally the frame registers will be spilt into reg+const during 	 reload, so it is a bad idea to combine them with other instructions, 	 since then they might not be moved outside of loops.  As a compromise 	 we allow integration with ops that have a constant as their second 	 operand.  */
if|if
condition|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|ARM_FRAME_RTX
argument_list|(
name|REG_OR_SUBREG_RTX
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
operator|||
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|ARM_FRAME_RTX
argument_list|(
name|REG_OR_SUBREG_RTX
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|extra_cost
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
operator|(
literal|4
operator|+
name|extra_cost
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_op
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|code
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
if|if
condition|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|?
literal|0
else|:
name|extra_cost
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_op
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|code
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|+
name|extra_cost
operator|+
operator|(
operator|(
operator|(
operator|(
name|subcode
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|==
name|ASHIFT
operator|||
name|subcode
operator|==
name|LSHIFTRT
operator|||
name|subcode
operator|==
name|ASHIFTRT
operator|||
name|subcode
operator|==
name|ROTATE
operator|||
name|subcode
operator|==
name|ROTATERT
operator|||
operator|(
name|subcode
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
return|;
return|return
literal|8
return|;
case|case
name|MULT
case|:
comment|/* There is no point basing this on the tuning, since it is always the 	 fast variant if it exists at all.  */
if|if
condition|(
name|arm_fast_multiply
operator|&&
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
condition|)
return|return
literal|8
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|mode
operator|==
name|DImode
condition|)
return|return
literal|30
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
decl_stmt|;
name|int
name|add_cost
init|=
name|const_ok_for_arm
argument_list|(
name|i
argument_list|)
condition|?
literal|4
else|:
literal|8
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Tune as appropriate.  */
name|int
name|booth_unit_size
init|=
operator|(
operator|(
name|tune_flags
operator|&
name|FL_FAST_MULT
operator|)
condition|?
literal|8
else|:
literal|2
operator|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|&&
name|j
operator|<
literal|32
condition|;
name|j
operator|+=
name|booth_unit_size
control|)
block|{
name|i
operator|>>=
name|booth_unit_size
expr_stmt|;
name|add_cost
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|add_cost
return|;
block|}
return|return
operator|(
operator|(
operator|(
name|tune_flags
operator|&
name|FL_FAST_MULT
operator|)
condition|?
literal|8
else|:
literal|30
operator|)
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
return|;
case|case
name|TRUNCATE
case|:
if|if
condition|(
name|arm_fast_multiply
operator|&&
name|mode
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
condition|)
return|return
literal|8
return|;
return|return
literal|99
return|;
case|case
name|NEG
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|4
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|6
operator|)
return|;
comment|/* Fall through */
case|case
name|NOT
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
literal|4
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
return|;
return|return
literal|1
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
return|;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
return|return
literal|14
return|;
return|return
literal|2
return|;
case|case
name|COMPARE
case|:
return|return
literal|1
return|;
case|case
name|ABS
case|:
return|return
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
return|;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|QImode
condition|)
return|return
operator|(
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
comment|/* Fall through */
case|case
name|ZERO_EXTEND
case|:
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|HImode
case|:
return|return
operator|(
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|SImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
default|default:
break|break;
block|}
name|abort
argument_list|()
expr_stmt|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|outer
operator|==
name|SET
condition|?
literal|2
else|:
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|outer
operator|==
name|AND
operator|&&
name|const_ok_for_arm
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|outer
operator|==
name|COMPARE
operator|||
name|outer
operator|==
name|PLUS
operator|||
name|outer
operator|==
name|MINUS
operator|)
operator|&&
name|const_ok_for_arm
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|5
return|;
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
literal|6
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|const_double_rtx_ok_for_fpu
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|outer
operator|==
name|SET
condition|?
literal|2
else|:
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|outer
operator|==
name|COMPARE
operator|||
name|outer
operator|==
name|PLUS
operator|)
operator|&&
name|neg_const_double_rtx_ok_for_fpu
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|7
return|;
default|default:
return|return
literal|99
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|arm_adjust_cost
parameter_list|(
name|insn
parameter_list|,
name|link
parameter_list|,
name|dep
parameter_list|,
name|cost
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|rtx
name|dep
decl_stmt|;
name|int
name|cost
decl_stmt|;
block|{
name|rtx
name|i_pat
decl_stmt|,
name|d_pat
decl_stmt|;
comment|/* Some true dependencies can have a higher cost depending      on precisely how certain input operands are used.  */
if|if
condition|(
name|arm_is_xscale
operator|&&
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
operator|&&
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|<
literal|0
operator|&&
name|recog_memoized
argument_list|(
name|dep
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|shift_opnum
init|=
name|get_attr_shift
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|enum
name|attr_type
name|attr_type
init|=
name|get_attr_type
argument_list|(
name|dep
argument_list|)
decl_stmt|;
comment|/* If nonzero, SHIFT_OPNUM contains the operand number of a shifted 	 operand for INSN.  If we have a shifted input operand and the 	 instruction we depend on is another ALU instruction, then we may 	 have to account for an additional stall.  */
if|if
condition|(
name|shift_opnum
operator|!=
literal|0
operator|&&
name|attr_type
operator|==
name|TYPE_NORMAL
condition|)
block|{
name|rtx
name|shifted_operand
decl_stmt|;
name|int
name|opno
decl_stmt|;
comment|/* Get the shifted operand.  */
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|shifted_operand
operator|=
name|recog_data
operator|.
name|operand
index|[
name|shift_opnum
index|]
expr_stmt|;
comment|/* Iterate over all the operands in DEP.  If we write an operand 	     that overlaps with SHIFTED_OPERAND, then we have increase the 	     cost of this dependency.  */
name|extract_insn
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|preprocess_constraints
argument_list|()
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
block|{
comment|/* We can ignore strict inputs.  */
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|opno
index|]
operator|==
name|OP_IN
condition|)
continue|continue;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
argument_list|,
name|shifted_operand
argument_list|)
condition|)
return|return
literal|2
return|;
block|}
block|}
block|}
comment|/* XXX This is not strictly true for the FPA.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_ANTI
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_OUTPUT
condition|)
return|return
literal|0
return|;
comment|/* Call insns don't incur a stall, even if they follow a load.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|i_pat
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|i_pat
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|d_pat
operator|=
name|single_set
argument_list|(
name|dep
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|d_pat
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* This is a load after a store, there is no conflict if the load reads 	 from a cached area.  Assume that loads from the stack, and from the 	 constant pool are cached, and that others will miss.  This is a  	 hack.  */
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|i_pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|i_pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|i_pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|i_pat
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/* This code has been fixed for cross compilation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fpa_consts_inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|strings_fpa
index|[
literal|8
index|]
init|=
block|{
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"0.5"
block|,
literal|"10"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|REAL_VALUE_TYPE
name|values_fpa
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_fpa_table
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|strings_fpa
index|[
name|i
index|]
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|values_fpa
index|[
name|i
index|]
operator|=
name|r
expr_stmt|;
block|}
name|fpa_consts_inited
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return TRUE if rtx X is a valid immediate FPU constant.  */
end_comment

begin_function
name|int
name|const_double_rtx_ok_for_fpu
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fpa_consts_inited
condition|)
name|init_fpa_table
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|values_fpa
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if rtx X is a valid immediate FPU constant.  */
end_comment

begin_function
name|int
name|neg_const_double_rtx_ok_for_fpu
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fpa_consts_inited
condition|)
name|init_fpa_table
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|r
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|values_fpa
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Predicates for `match_operand' and `match_operator'.  */
end_comment

begin_comment
comment|/* s_register_operand is the same as register_operand, but it doesn't accept    (SUBREG (MEM)...).     This function exists because at the time it was put in it led to better    code.  SUBREG(MEM) always needs a reload in the places where    s_register_operand is used, and this seemed to lead to excessive    reloading.  */
end_comment

begin_function
name|int
name|s_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
comment|/* XXX might have to check for lo regs only for thumb ??? */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A hard register operand (even before reload.  */
end_comment

begin_function
name|int
name|arm_hard_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Only accept reg, subreg(reg), const_int.  */
end_comment

begin_function
name|int
name|reg_or_int_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|!=
name|NO_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is an item in memory, given that we are in reload.  */
end_comment

begin_function
name|int
name|arm_reload_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|regno
init|=
name|true_regnum
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
operator|(
operator|!
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
operator|&&
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a valid memory address, but not valid for a signed byte    memory access (architecture V4).    MODE is QImode if called when computing constraints, or VOIDmode when    emitting patterns.  In this latter case we cannot use memory_operand()    because it will fail on badly formed MEMs, which is precisly what we are    trying to catch.  */
end_comment

begin_function
name|int
name|bad_signed_byte_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|if ((mode == QImode&& !memory_operand (op, mode)) || GET_CODE (op) != MEM)     return 0;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* A sum of anything more complex than reg + reg or reg + const is bad.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
operator|(
operator|!
name|s_register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|||
operator|(
operator|!
name|s_register_operand
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Big constants are also bad.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0xff
operator|||
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
literal|0xff
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Everything else is good, or can will automatically be made so.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid operands for the rhs of an ARM instruction.  */
end_comment

begin_function
name|int
name|arm_rhs_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid operands for the    rhs of an ARM instruction, or a load.  */
end_comment

begin_function
name|int
name|arm_rhsm_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|||
name|memory_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid operands for the rhs of an ARM instruction, or if a    constant that is valid when negated.  */
end_comment

begin_function
name|int
name|arm_add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_THUMB
condition|)
return|return
name|thumb_cmp_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
return|;
return|return
operator|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arm_not_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the operand is a memory reference which contains an    offsettable address.  */
end_comment

begin_function
name|int
name|offsettable_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|offsettable_address_p
argument_list|(
name|reload_completed
operator||
name|reload_in_progress
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the operand is a memory reference which is, or can be    made word aligned by adjusting the offset.  */
end_comment

begin_function
name|int
name|alignable_memory_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|op
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|)
operator|)
operator|&&
name|REGNO_POINTER_ALIGN
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|>=
literal|32
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Similar to s_register_operand, but does not allow hard integer     registers.  */
end_comment

begin_function
name|int
name|f_register_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* We don't consider registers whose class is NO_REGS      to be a register operand.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|op
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|op
argument_list|)
argument_list|)
operator|==
name|FPU_REGS
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid operands for the rhs of an FPU instruction.  */
end_comment

begin_function
name|int
name|fpu_rhs_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
name|const_double_rtx_ok_for_fpu
argument_list|(
name|op
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|fpu_add_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
return|return
operator|(
name|const_double_rtx_ok_for_fpu
argument_list|(
name|op
argument_list|)
operator|||
name|neg_const_double_rtx_ok_for_fpu
argument_list|(
name|op
argument_list|)
operator|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if OP is a constant power of two.  */
end_comment

begin_function
name|int
name|power_of_two_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|value
init|=
name|INTVAL
argument_list|(
name|op
argument_list|)
decl_stmt|;
return|return
name|value
operator|!=
literal|0
operator|&&
operator|(
name|value
operator|&
operator|(
name|value
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for a valid operand of a DImode operation.    Either: REG, SUBREG, CONST_DOUBLE or MEM(DImode_address).    Note that this disallows MEM(REG+REG), but allows    MEM(PRE/POST_INC/DEC(REG)).  */
end_comment

begin_function
name|int
name|di_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|DImode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
return|return
name|TRUE
return|;
case|case
name|MEM
case|:
return|return
name|memory_address_p
argument_list|(
name|DImode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like di_operand, but don't accept constants.  */
end_comment

begin_function
name|int
name|nonimmediate_di_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|DImode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|memory_address_p
argument_list|(
name|DImode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for a valid operand of a DFmode operation when -msoft-float.    Either: REG, SUBREG, CONST_DOUBLE or MEM(DImode_address).    Note that this disallows MEM(REG+REG), but allows    MEM(PRE/POST_INC/DEC(REG)).  */
end_comment

begin_function
name|int
name|soft_df_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
operator|&&
name|CONSTANT_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
return|return
name|TRUE
return|;
case|case
name|MEM
case|:
return|return
name|memory_address_p
argument_list|(
name|DFmode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Like soft_df_operand, but don't accept constants.  */
end_comment

begin_function
name|int
name|nonimmediate_soft_df_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
operator|&&
name|GET_MODE
argument_list|(
name|op
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|SUBREG
condition|)
name|op
operator|=
name|SUBREG_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|memory_address_p
argument_list|(
name|DFmode
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid index operands.  */
end_comment

begin_function
name|int
name|index_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|s_register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|immediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|4096
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
operator|-
literal|4096
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for valid shifts by a constant. This also accepts any    power of two on the (somewhat overly relaxed) assumption that the    shift operator in this case was a mult.  */
end_comment

begin_function
name|int
name|const_shift_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|power_of_two_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|||
operator|(
name|immediate_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<
literal|32
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
literal|0
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for arithmetic operators which can be combined with a multiply    (shift).  */
end_comment

begin_function
name|int
name|shiftable_operator
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|||
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|||
name|code
operator|==
name|AND
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for binary logical operators.  */
end_comment

begin_function
name|int
name|logical_binary_operator
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|==
name|IOR
operator|||
name|code
operator|==
name|XOR
operator|||
name|code
operator|==
name|AND
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for shift operators.  */
end_comment

begin_function
name|int
name|shift_operator
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|MULT
condition|)
return|return
name|power_of_two_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
return|return
operator|(
name|code
operator|==
name|ASHIFT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ROTATERT
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if x is EQ or NE.  */
end_comment

begin_function
name|int
name|equality_operator
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
return|return
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if x is a comparison operator other than LTGT or UNEQ.  */
end_comment

begin_function
name|int
name|arm_comparison_operator
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
name|comparison_operator
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|LTGT
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|UNEQ
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE for SMIN SMAX UMIN UMAX operators.  */
end_comment

begin_function
name|int
name|minmax_operator
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
condition|)
return|return
name|FALSE
return|;
return|return
name|code
operator|==
name|SMIN
operator|||
name|code
operator|==
name|SMAX
operator|||
name|code
operator|==
name|UMIN
operator|||
name|code
operator|==
name|UMAX
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if this is the condition code register, if we aren't given    a mode, accept any class CCmode register.  */
end_comment

begin_function
name|int
name|cc_register
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|mode
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|CC_REGNUM
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if this is the condition code register, if we aren't given    a mode, accept any class CCmode register which indicates a dominance    expression.  */
end_comment

begin_function
name|int
name|dominant_cc_register
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|mode
operator|!=
name|CC_DNEmode
operator|&&
name|mode
operator|!=
name|CC_DEQmode
operator|&&
name|mode
operator|!=
name|CC_DLEmode
operator|&&
name|mode
operator|!=
name|CC_DLTmode
operator|&&
name|mode
operator|!=
name|CC_DGEmode
operator|&&
name|mode
operator|!=
name|CC_DGTmode
operator|&&
name|mode
operator|!=
name|CC_DLEUmode
operator|&&
name|mode
operator|!=
name|CC_DLTUmode
operator|&&
name|mode
operator|!=
name|CC_DGEUmode
operator|&&
name|mode
operator|!=
name|CC_DGTUmode
condition|)
return|return
name|FALSE
return|;
return|return
name|cc_register
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if X references a SYMBOL_REF.  */
end_comment

begin_function
name|int
name|symbol_mentioned_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbol_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbol_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if X references a LABEL_REF.  */
end_comment

begin_function
name|int
name|label_mentioned_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|label_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|label_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|enum
name|rtx_code
name|minmax_code
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SMAX
condition|)
return|return
name|GE
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|SMIN
condition|)
return|return
name|LE
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|UMIN
condition|)
return|return
name|LEU
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|UMAX
condition|)
return|return
name|GEU
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return 1 if memory locations are adjacent.  */
end_comment

begin_function
name|int
name|adjacent_mem_locations
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|rtx
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
name|int
name|val0
init|=
literal|0
decl_stmt|,
name|val1
init|=
literal|0
decl_stmt|;
name|int
name|reg0
decl_stmt|,
name|reg1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|reg0
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|val0
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|reg0
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|reg1
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|val1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|reg1
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|reg0
operator|==
name|reg1
operator|)
operator|&&
operator|(
operator|(
name|val1
operator|-
name|val0
operator|)
operator|==
literal|4
operator|||
operator|(
name|val0
operator|-
name|val1
operator|)
operator|==
literal|4
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a load multiple operation.  It is known to be    parallel and the first section will be tested.  */
end_comment

begin_function
name|int
name|load_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|dest_regno
decl_stmt|;
name|rtx
name|src_addr
decl_stmt|;
name|HOST_WIDE_INT
name|i
init|=
literal|1
decl_stmt|,
name|base
init|=
literal|0
decl_stmt|;
name|rtx
name|elt
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
comment|/* Check to see if this might be a write-back.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|base
operator|=
literal|1
expr_stmt|;
comment|/* Now check it more carefully.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
name|i
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|dest_regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|src_addr
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|elt
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|dest_regno
operator|+
name|i
operator|-
name|base
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|src_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|(
name|i
operator|-
name|base
operator|)
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if OP is a store multiple operation.  It is known to be    parallel and the first section will be tested.  */
end_comment

begin_function
name|int
name|store_multiple_operation
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|count
init|=
name|XVECLEN
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|src_regno
decl_stmt|;
name|rtx
name|dest_addr
decl_stmt|;
name|HOST_WIDE_INT
name|i
init|=
literal|1
decl_stmt|,
name|base
init|=
literal|0
decl_stmt|;
name|rtx
name|elt
decl_stmt|;
if|if
condition|(
name|count
operator|<=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
comment|/* Check to see if this might be a write-back.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|base
operator|=
literal|1
expr_stmt|;
comment|/* Now check it more carefully.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
comment|/* Perform a quick check so we don't blow up below.  */
if|if
condition|(
name|count
operator|<=
name|i
operator|||
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|src_regno
operator|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|elt
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
call|(
name|unsigned
name|int
call|)
argument_list|(
name|src_regno
operator|+
name|i
operator|-
name|base
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|)
operator|!=
name|SImode
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|dest_addr
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|elt
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|(
name|i
operator|-
name|base
operator|)
operator|*
literal|4
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|load_multiple_sequence
parameter_list|(
name|operands
parameter_list|,
name|nops
parameter_list|,
name|regs
parameter_list|,
name|base
parameter_list|,
name|load_offset
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|nops
decl_stmt|;
name|int
modifier|*
name|regs
decl_stmt|;
name|int
modifier|*
name|base
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|load_offset
decl_stmt|;
block|{
name|int
name|unsorted_regs
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|unsorted_offsets
index|[
literal|4
index|]
decl_stmt|;
name|int
name|order
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Can only handle 2, 3, or 4 insns at present,      though could be easily extended if required.  */
if|if
condition|(
name|nops
operator|<
literal|2
operator|||
name|nops
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Loop over the operands and check that the memory references are      suitable (ie immediate offsets from the same base register).  At      the same time, extract the target register, and the memory      offsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
comment|/* Convert a subreg of a mem into the mem itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|operands
index|[
name|nops
operator|+
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|operands
operator|+
operator|(
name|nops
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Don't reorder volatile memory references; it doesn't seem worth 	 looking for the case where the order is ok anyway.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|base_reg
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|unsorted_regs
index|[
literal|0
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|order
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|base_reg
operator|!=
operator|(
name|int
operator|)
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
comment|/* Not addressed from the same base register.  */
return|return
literal|0
return|;
name|unsorted_regs
index|[
name|i
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
literal|0
index|]
index|]
condition|)
name|order
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* If it isn't an integer register, or if it overwrites the 	     base register but isn't the last insn in the list, then 	     we can't do this.  */
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|unsorted_regs
index|[
name|i
index|]
operator|>
literal|14
operator|||
operator|(
name|i
operator|!=
name|nops
operator|-
literal|1
operator|&&
name|unsorted_regs
index|[
name|i
index|]
operator|==
name|base_reg
operator|)
condition|)
return|return
literal|0
return|;
name|unsorted_offsets
index|[
name|i
index|]
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not a suitable memory address.  */
return|return
literal|0
return|;
block|}
comment|/* All the useful information has now been extracted from the      operands into unsorted_regs and unsorted_offsets; additionally,      order[0] has been set to the lowest numbered register in the      list.  Sort the registers into order, and check that the memory      offsets are ascending and adjacent.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|order
index|[
name|i
index|]
operator|=
name|order
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nops
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|unsorted_regs
index|[
name|j
index|]
operator|>
name|unsorted_regs
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|&&
operator|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
operator|||
name|unsorted_regs
index|[
name|j
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
operator|)
condition|)
name|order
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
comment|/* Have we found a suitable register? if not, one must be used more 	 than once.  */
if|if
condition|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return
literal|0
return|;
comment|/* Is the memory address adjacent and ascending? */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|i
index|]
index|]
operator|!=
name|unsorted_offsets
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|+
literal|4
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|base
condition|)
block|{
operator|*
name|base
operator|=
name|base_reg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|regs
index|[
name|i
index|]
operator|=
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
expr_stmt|;
operator|*
name|load_offset
operator|=
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
expr_stmt|;
block|}
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* ldmia */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|4
condition|)
return|return
literal|2
return|;
comment|/* ldmib */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|3
return|;
comment|/* ldmda */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
operator|-
literal|4
condition|)
return|return
literal|4
return|;
comment|/* ldmdb */
comment|/* For ARM8,9& StrongARM, 2 ldr instructions are faster than an ldm      if the offset isn't small enough.  The reason 2 ldrs are faster      is because these ARMs are able to do more than one cache access      in a single cycle.  The ARM9 and StrongARM have Harvard caches,      whilst the ARM8 has a double bandwidth cache.  This means that      these cores can do both an instruction fetch and a data fetch in      a single cycle, so the trick of calculating the address into a      scratch register (one of the result regs) and then doing a load      multiple actually becomes slower (and no smaller in code size).      That is the transformation    	ldr	rd1, [rbase + offset]  	ldr	rd2, [rbase + offset + 4]        to    	add	rd1, rbase, offset  	ldmia	rd1, {rd1, rd2}        produces worse code -- '3 cycles + any stalls on rd2' instead of      '2 cycles + any stalls on rd2'.  On ARMs with only one cache      access per cycle, the first sequence could never complete in less      than 6 cycles, whereas the ldm sequence would only take 5 and      would make better use of sequential accesses if not hitting the      cache.       We cheat here and test 'arm_ld_sched' which we currently know to      only be true for the ARM8, ARM9 and StrongARM.  If this ever      changes, then the test below needs to be reworked.  */
if|if
condition|(
name|nops
operator|==
literal|2
operator|&&
name|arm_ld_sched
condition|)
return|return
literal|0
return|;
comment|/* Can't do it without setting up the offset, only do this if it takes      no more than one insn.  */
return|return
operator|(
name|const_ok_for_arm
argument_list|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
argument_list|)
operator|)
condition|?
literal|5
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|emit_ldm_seq
parameter_list|(
name|operands
parameter_list|,
name|nops
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|nops
decl_stmt|;
block|{
name|int
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|load_multiple_sequence
argument_list|(
name|operands
argument_list|,
name|nops
argument_list|,
name|regs
argument_list|,
operator|&
name|base_reg
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?ia\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?ib\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?da\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?db\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"add%%?\t%s%s, %s%s, #%ld"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"sub%%?\t%s%s, %s%s, #%ld"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
operator|(
name|long
operator|)
operator|-
name|offset
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|buf
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|base_reg
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?ia\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s, {%s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|", %s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"}\t%@ phole ldm"
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|buf
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_function
name|int
name|store_multiple_sequence
parameter_list|(
name|operands
parameter_list|,
name|nops
parameter_list|,
name|regs
parameter_list|,
name|base
parameter_list|,
name|load_offset
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|nops
decl_stmt|;
name|int
modifier|*
name|regs
decl_stmt|;
name|int
modifier|*
name|base
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|load_offset
decl_stmt|;
block|{
name|int
name|unsorted_regs
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|unsorted_offsets
index|[
literal|4
index|]
decl_stmt|;
name|int
name|order
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Can only handle 2, 3, or 4 insns at present, though could be easily      extended if required.  */
if|if
condition|(
name|nops
operator|<
literal|2
operator|||
name|nops
operator|>
literal|4
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Loop over the operands and check that the memory references are      suitable (ie immediate offsets from the same base register).  At      the same time, extract the target register, and the memory      offsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
comment|/* Convert a subreg of a mem into the mem itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|operands
index|[
name|nops
operator|+
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|operands
operator|+
operator|(
name|nops
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Don't reorder volatile memory references; it doesn't seem worth 	 looking for the case where the order is ok anyway.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|base_reg
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|unsorted_regs
index|[
literal|0
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|order
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|base_reg
operator|!=
operator|(
name|int
operator|)
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
comment|/* Not addressed from the same base register.  */
return|return
literal|0
return|;
name|unsorted_regs
index|[
name|i
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
literal|0
index|]
index|]
condition|)
name|order
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* If it isn't an integer register, then we can't do this.  */
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|unsorted_regs
index|[
name|i
index|]
operator|>
literal|14
condition|)
return|return
literal|0
return|;
name|unsorted_offsets
index|[
name|i
index|]
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not a suitable memory address.  */
return|return
literal|0
return|;
block|}
comment|/* All the useful information has now been extracted from the      operands into unsorted_regs and unsorted_offsets; additionally,      order[0] has been set to the lowest numbered register in the      list.  Sort the registers into order, and check that the memory      offsets are ascending and adjacent.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|order
index|[
name|i
index|]
operator|=
name|order
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nops
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|unsorted_regs
index|[
name|j
index|]
operator|>
name|unsorted_regs
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|&&
operator|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
operator|||
name|unsorted_regs
index|[
name|j
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
operator|)
condition|)
name|order
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
comment|/* Have we found a suitable register? if not, one must be used more 	 than once.  */
if|if
condition|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return
literal|0
return|;
comment|/* Is the memory address adjacent and ascending? */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|i
index|]
index|]
operator|!=
name|unsorted_offsets
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|+
literal|4
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|base
condition|)
block|{
operator|*
name|base
operator|=
name|base_reg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|regs
index|[
name|i
index|]
operator|=
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
expr_stmt|;
operator|*
name|load_offset
operator|=
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
expr_stmt|;
block|}
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* stmia */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|4
condition|)
return|return
literal|2
return|;
comment|/* stmib */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|3
return|;
comment|/* stmda */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
operator|-
literal|4
condition|)
return|return
literal|4
return|;
comment|/* stmdb */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|emit_stm_seq
parameter_list|(
name|operands
parameter_list|,
name|nops
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
name|int
name|nops
decl_stmt|;
block|{
name|int
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|store_multiple_sequence
argument_list|(
name|operands
argument_list|,
name|nops
argument_list|,
name|regs
argument_list|,
operator|&
name|base_reg
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?ia\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?ib\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?da\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?db\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s, {%s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|", %s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"}\t%@ phole stm"
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|buf
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_function
name|int
name|multi_register_push
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|PARALLEL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SET
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|UNSPEC
operator|)
operator|||
operator|(
name|XINT
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|!=
name|UNSPEC_PUSH_MULT
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines for use in generating RTL.  */
end_comment

begin_function
name|rtx
name|arm_gen_load_multiple
parameter_list|(
name|base_regno
parameter_list|,
name|count
parameter_list|,
name|from
parameter_list|,
name|up
parameter_list|,
name|write_back
parameter_list|,
name|unchanging_p
parameter_list|,
name|in_struct_p
parameter_list|,
name|scalar_p
parameter_list|)
name|int
name|base_regno
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
name|from
decl_stmt|;
name|int
name|up
decl_stmt|;
name|int
name|write_back
decl_stmt|;
name|int
name|unchanging_p
decl_stmt|;
name|int
name|in_struct_p
decl_stmt|;
name|int
name|scalar_p
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|int
name|sign
init|=
name|up
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
comment|/* XScale has load-store double instructions, but they have stricter      alignment requirements than load-store multiple, so we can not      use them.       For XScale ldm requires 2 + NREGS cycles to complete and blocks      the pipeline until completion.  	NREGS		CYCLES 	  1		  3 	  2		  4 	  3		  5 	  4		  6       An ldr instruction takes 1-3 cycles, but does not block the      pipeline.  	NREGS		CYCLES 	  1		 1-3 	  2		 2-6 	  3		 3-9 	  4		 4-12       Best case ldr will always win.  However, the more ldr instructions      we issue, the less likely we are to be able to schedule them well.      Using ldr instructions also increases code size.       As a compromise, we use ldr for counts of 1 or 2 regs, and ldm      for counts of 3 or 4 regs.  */
if|if
condition|(
name|arm_is_xscale
operator|&&
name|count
operator|<=
literal|2
operator|&&
operator|!
name|optimize_size
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|from
argument_list|,
name|i
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_back
condition|)
name|emit_move_insn
argument_list|(
name|from
argument_list|,
name|plus_constant
argument_list|(
name|from
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
name|result
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
operator|+
operator|(
name|write_back
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_back
condition|)
block|{
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|GET_MODE
argument_list|(
name|from
argument_list|)
argument_list|,
name|from
argument_list|,
name|plus_constant
argument_list|(
name|from
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|from
argument_list|,
name|j
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|scalar_p
expr_stmt|;
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|j
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|rtx
name|arm_gen_store_multiple
parameter_list|(
name|base_regno
parameter_list|,
name|count
parameter_list|,
name|to
parameter_list|,
name|up
parameter_list|,
name|write_back
parameter_list|,
name|unchanging_p
parameter_list|,
name|in_struct_p
parameter_list|,
name|scalar_p
parameter_list|)
name|int
name|base_regno
decl_stmt|;
name|int
name|count
decl_stmt|;
name|rtx
name|to
decl_stmt|;
name|int
name|up
decl_stmt|;
name|int
name|write_back
decl_stmt|;
name|int
name|unchanging_p
decl_stmt|;
name|int
name|in_struct_p
decl_stmt|;
name|int
name|scalar_p
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|int
name|sign
init|=
name|up
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
comment|/* See arm_gen_load_multiple for discussion of      the pros/cons of ldm/stm usage for XScale.  */
if|if
condition|(
name|arm_is_xscale
operator|&&
name|count
operator|<=
literal|2
operator|&&
operator|!
name|optimize_size
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|to
argument_list|,
name|i
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write_back
condition|)
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|plus_constant
argument_list|(
name|to
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
name|result
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
operator|+
operator|(
name|write_back
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_back
condition|)
block|{
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|GET_MODE
argument_list|(
name|to
argument_list|)
argument_list|,
name|to
argument_list|,
name|plus_constant
argument_list|(
name|to
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|to
argument_list|,
name|j
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|scalar_p
expr_stmt|;
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|arm_gen_movstrqi
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|in_words_to_go
decl_stmt|,
name|out_words_to_go
decl_stmt|,
name|last_bytes
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|rtx
name|st_src
decl_stmt|,
name|st_dst
decl_stmt|,
name|fin_src
decl_stmt|,
name|fin_dst
decl_stmt|;
name|rtx
name|part_bytes_reg
init|=
name|NULL
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
name|int
name|dst_unchanging_p
decl_stmt|,
name|dst_in_struct_p
decl_stmt|,
name|src_unchanging_p
decl_stmt|,
name|src_in_struct_p
decl_stmt|;
name|int
name|dst_scalar_p
decl_stmt|,
name|src_scalar_p
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|>
literal|64
operator|||
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|&
literal|3
condition|)
return|return
literal|0
return|;
name|st_dst
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st_src
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dst_unchanging_p
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dst_in_struct_p
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dst_scalar_p
operator|=
name|MEM_SCALAR_P
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|src_unchanging_p
operator|=
name|RTX_UNCHANGING_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|src_in_struct_p
operator|=
name|MEM_IN_STRUCT_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|src_scalar_p
operator|=
name|MEM_SCALAR_P
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fin_dst
operator|=
name|dst
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|st_dst
argument_list|)
expr_stmt|;
name|fin_src
operator|=
name|src
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|st_src
argument_list|)
expr_stmt|;
name|in_words_to_go
operator|=
name|NUM_INTS
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|out_words_to_go
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|/
literal|4
expr_stmt|;
name|last_bytes
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|out_words_to_go
operator|!=
name|in_words_to_go
operator|&&
operator|(
operator|(
name|in_words_to_go
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|part_bytes_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
operator|(
name|in_words_to_go
operator|-
literal|1
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|in_words_to_go
operator|>=
literal|2
condition|;
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|in_words_to_go
operator|>
literal|4
condition|)
name|emit_insn
argument_list|(
name|arm_gen_load_multiple
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
name|src
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|src_unchanging_p
argument_list|,
name|src_in_struct_p
argument_list|,
name|src_scalar_p
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|arm_gen_load_multiple
argument_list|(
literal|0
argument_list|,
name|in_words_to_go
argument_list|,
name|src
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|src_unchanging_p
argument_list|,
name|src_in_struct_p
argument_list|,
name|src_scalar_p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_words_to_go
condition|)
block|{
if|if
condition|(
name|out_words_to_go
operator|>
literal|4
condition|)
name|emit_insn
argument_list|(
name|arm_gen_store_multiple
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
name|dst
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|dst_unchanging_p
argument_list|,
name|dst_in_struct_p
argument_list|,
name|dst_scalar_p
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|out_words_to_go
operator|!=
literal|1
condition|)
name|emit_insn
argument_list|(
name|arm_gen_store_multiple
argument_list|(
literal|0
argument_list|,
name|out_words_to_go
argument_list|,
name|dst
argument_list|,
name|TRUE
argument_list|,
operator|(
name|last_bytes
operator|==
literal|0
condition|?
name|FALSE
else|:
name|TRUE
operator|)
argument_list|,
name|dst_unchanging_p
argument_list|,
name|dst_in_struct_p
argument_list|,
name|dst_scalar_p
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_bytes
operator|!=
literal|0
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dst
argument_list|,
name|dst
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|in_words_to_go
operator|-=
name|in_words_to_go
operator|<
literal|4
condition|?
name|in_words_to_go
else|:
literal|4
expr_stmt|;
name|out_words_to_go
operator|-=
name|out_words_to_go
operator|<
literal|4
condition|?
name|out_words_to_go
else|:
literal|4
expr_stmt|;
block|}
comment|/* OUT_WORDS_TO_GO will be zero here if there are byte stores to do.  */
if|if
condition|(
name|out_words_to_go
condition|)
block|{
name|rtx
name|sreg
decl_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|sreg
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|fin_src
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|src
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|fin_dst
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|dst
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|in_words_to_go
operator|--
expr_stmt|;
if|if
condition|(
name|in_words_to_go
condition|)
comment|/* Sanity check */
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|in_words_to_go
condition|)
block|{
if|if
condition|(
name|in_words_to_go
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|src_scalar_p
expr_stmt|;
name|part_bytes_reg
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_bytes
operator|&&
name|part_bytes_reg
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|last_bytes
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
comment|/* The bytes we want are in the top end of the word.  */
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmp
argument_list|,
name|part_bytes_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|8
operator|*
operator|(
literal|4
operator|-
name|last_bytes
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part_bytes_reg
operator|=
name|tmp
expr_stmt|;
while|while
condition|(
name|last_bytes
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|dst
argument_list|,
name|last_bytes
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|part_bytes_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|last_bytes
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmp
argument_list|,
name|part_bytes_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part_bytes_reg
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|last_bytes
operator|>
literal|1
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|HImode
argument_list|,
name|part_bytes_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|last_bytes
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|last_bytes
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dst
argument_list|,
name|dst
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmp
argument_list|,
name|part_bytes_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part_bytes_reg
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_bytes
condition|)
block|{
name|mem
operator|=
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_unchanging_p
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_in_struct_p
expr_stmt|;
name|MEM_SCALAR_P
argument_list|(
name|mem
argument_list|)
operator|=
name|dst_scalar_p
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|part_bytes_reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generate a memory reference for a half word, such that it will be loaded    into the top 16 bits of the word.  We can assume that the address is    known to be alignable and of the form reg, or plus (reg, const).  */
end_comment

begin_function
name|rtx
name|arm_gen_rotated_half_load
parameter_list|(
name|memref
parameter_list|)
name|rtx
name|memref
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|base
init|=
name|XEXP
argument_list|(
name|memref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we aren't allowed to generate unaligned addresses, then fail.  */
if|if
condition|(
name|TARGET_MMU_TRAPS
operator|&&
operator|(
operator|(
name|BYTES_BIG_ENDIAN
condition|?
literal|1
else|:
literal|0
operator|)
operator|^
operator|(
operator|(
name|offset
operator|&
literal|2
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
name|NULL
return|;
name|base
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|&
operator|~
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|BYTES_BIG_ENDIAN
condition|?
literal|1
else|:
literal|0
operator|)
operator|^
operator|(
operator|(
name|offset
operator|&
literal|2
operator|)
operator|==
literal|2
operator|)
condition|)
return|return
name|base
return|;
return|return
name|gen_rtx_ROTATE
argument_list|(
name|SImode
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Select a dominance comparison mode if possible.  We support three forms.    COND_OR == 0 => (X&& Y)     COND_OR == 1 => ((! X( || Y)    COND_OR == 2 => (X || Y)     If we are unable to support a dominance comparsison we return CC mode.      This will then fail to match for the RTL expressions that generate this    call.  */
end_comment

begin_function
specifier|static
name|enum
name|machine_mode
name|select_dominance_cc_mode
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|cond_or
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|y
decl_stmt|;
name|HOST_WIDE_INT
name|cond_or
decl_stmt|;
block|{
name|enum
name|rtx_code
name|cond1
decl_stmt|,
name|cond2
decl_stmt|;
name|int
name|swapped
init|=
literal|0
decl_stmt|;
comment|/* Currently we will probably get the wrong result if the individual      comparisons are not simple.  This also ensures that it is safe to      reverse a comparison if necessary.  */
if|if
condition|(
operator|(
name|arm_select_cc_mode
argument_list|(
name|cond1
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CCmode
operator|)
operator|||
operator|(
name|arm_select_cc_mode
argument_list|(
name|cond2
operator|=
name|GET_CODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CCmode
operator|)
condition|)
return|return
name|CCmode
return|;
comment|/* The if_then_else variant of this tests the second condition if the      first passes, but is true if the first fails.  Reverse the first      condition to get a true "inclusive-or" expression.  */
if|if
condition|(
name|cond_or
operator|==
literal|1
condition|)
name|cond1
operator|=
name|reverse_condition
argument_list|(
name|cond1
argument_list|)
expr_stmt|;
comment|/* If the comparisons are not equal, and one doesn't dominate the other,      then we can't do this.  */
if|if
condition|(
name|cond1
operator|!=
name|cond2
operator|&&
operator|!
name|comparison_dominates_p
argument_list|(
name|cond1
argument_list|,
name|cond2
argument_list|)
operator|&&
operator|(
name|swapped
operator|=
literal|1
operator|,
operator|!
name|comparison_dominates_p
argument_list|(
name|cond2
argument_list|,
name|cond1
argument_list|)
operator|)
condition|)
return|return
name|CCmode
return|;
if|if
condition|(
name|swapped
condition|)
block|{
name|enum
name|rtx_code
name|temp
init|=
name|cond1
decl_stmt|;
name|cond1
operator|=
name|cond2
expr_stmt|;
name|cond2
operator|=
name|temp
expr_stmt|;
block|}
switch|switch
condition|(
name|cond1
condition|)
block|{
case|case
name|EQ
case|:
if|if
condition|(
name|cond2
operator|==
name|EQ
operator|||
operator|!
name|cond_or
condition|)
return|return
name|CC_DEQmode
return|;
switch|switch
condition|(
name|cond2
condition|)
block|{
case|case
name|LE
case|:
return|return
name|CC_DLEmode
return|;
case|case
name|LEU
case|:
return|return
name|CC_DLEUmode
return|;
case|case
name|GE
case|:
return|return
name|CC_DGEmode
return|;
case|case
name|GEU
case|:
return|return
name|CC_DGEUmode
return|;
default|default:
break|break;
block|}
break|break;
case|case
name|LT
case|:
if|if
condition|(
name|cond2
operator|==
name|LT
operator|||
operator|!
name|cond_or
condition|)
return|return
name|CC_DLTmode
return|;
if|if
condition|(
name|cond2
operator|==
name|LE
condition|)
return|return
name|CC_DLEmode
return|;
if|if
condition|(
name|cond2
operator|==
name|NE
condition|)
return|return
name|CC_DNEmode
return|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|cond2
operator|==
name|GT
operator|||
operator|!
name|cond_or
condition|)
return|return
name|CC_DGTmode
return|;
if|if
condition|(
name|cond2
operator|==
name|GE
condition|)
return|return
name|CC_DGEmode
return|;
if|if
condition|(
name|cond2
operator|==
name|NE
condition|)
return|return
name|CC_DNEmode
return|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|cond2
operator|==
name|LTU
operator|||
operator|!
name|cond_or
condition|)
return|return
name|CC_DLTUmode
return|;
if|if
condition|(
name|cond2
operator|==
name|LEU
condition|)
return|return
name|CC_DLEUmode
return|;
if|if
condition|(
name|cond2
operator|==
name|NE
condition|)
return|return
name|CC_DNEmode
return|;
break|break;
case|case
name|GTU
case|:
if|if
condition|(
name|cond2
operator|==
name|GTU
operator|||
operator|!
name|cond_or
condition|)
return|return
name|CC_DGTUmode
return|;
if|if
condition|(
name|cond2
operator|==
name|GEU
condition|)
return|return
name|CC_DGEUmode
return|;
if|if
condition|(
name|cond2
operator|==
name|NE
condition|)
return|return
name|CC_DNEmode
return|;
break|break;
comment|/* The remaining cases only occur when both comparisons are the        same.  */
case|case
name|NE
case|:
return|return
name|CC_DNEmode
return|;
case|case
name|LE
case|:
return|return
name|CC_DLEmode
return|;
case|case
name|GE
case|:
return|return
name|CC_DGEmode
return|;
case|case
name|LEU
case|:
return|return
name|CC_DLEUmode
return|;
case|case
name|GEU
case|:
return|return
name|CC_DGEUmode
return|;
default|default:
break|break;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|machine_mode
name|arm_select_cc_mode
parameter_list|(
name|op
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|enum
name|rtx_code
name|op
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|y
decl_stmt|;
block|{
comment|/* All floating point compares return CCFP if it is an equality      comparison, and CCFPE otherwise.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
return|return
name|CCFPmode
return|;
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
return|return
name|CCFPEmode
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* A compare with a shifted operand.  Because of canonicalization, the      comparison will have to be swapped when we emit the assembler.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ROTATE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ROTATERT
operator|)
condition|)
return|return
name|CC_SWPmode
return|;
comment|/* This is a special case that is used by combine to allow a       comparison of a shifted byte load to be split into a zero-extend      followed by a comparison of the shifted integer (only valid for      equalities and unsigned inequalities).  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|24
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|QImode
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|||
name|op
operator|==
name|GEU
operator|||
name|op
operator|==
name|GTU
operator|||
name|op
operator|==
name|LTU
operator|||
name|op
operator|==
name|LEU
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|CC_Zmode
return|;
comment|/* A construct for a conditional compare, if the false arm contains      0, then both conditions must be true, otherwise either condition      must be true.  Not all conditions are possible, so CCmode is      returned if it can't be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|==
name|const1_rtx
operator|)
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|select_dominance_cc_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Alternate canonicalizations of the above.  These are somewhat cleaner.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|select_dominance_cc_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IOR
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
return|return
name|select_dominance_cc_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|2
argument_list|)
return|;
comment|/* An operation that sets the condition codes as a side-effect, the      V flag is not set correctly, so we can only use comparisons where      this doesn't matter.  (For LT and GE we can use "mi" and "pl"      instead.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|&&
name|y
operator|==
name|const0_rtx
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|||
name|op
operator|==
name|LT
operator|||
name|op
operator|==
name|GE
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|XOR
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NOT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NEG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ROTATERT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|)
condition|)
return|return
name|CC_NOOVmode
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|QImode
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|)
condition|)
return|return
name|CC_Zmode
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|&&
operator|(
name|op
operator|==
name|LTU
operator|||
name|op
operator|==
name|GEU
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|y
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|y
argument_list|)
operator|)
condition|)
return|return
name|CC_Cmode
return|;
return|return
name|CCmode
return|;
block|}
end_function

begin_comment
comment|/* X and Y are two things to compare using CODE.  Emit the compare insn and    return the rtx for register 0 in the proper mode.  FP means this is a    floating point compare: I don't think that it is needed on the arm.  */
end_comment

begin_function
name|rtx
name|arm_gen_compare_reg
parameter_list|(
name|code
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|CC_REGNUM
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|cc_reg
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_reg
return|;
block|}
end_function

begin_function
name|void
name|arm_reload_in_hi
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|ref
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|scratch
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|=
name|SUBREG_BYTE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* We have a pseudo which has been spilt onto the stack; there 	 are two cases here: the first where there is a simple 	 stack-slot replacement and a second where the stack-slot is 	 out of range, or is used as a subreg.  */
if|if
condition|(
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
condition|)
block|{
name|ref
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* The slot is out of range, or was dressed up in a SUBREG.  */
name|base
operator|=
name|reg_equiv_address
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
block|}
else|else
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle the case where the address is too complex to be offset by 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MINUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|base_plus
argument_list|,
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The addend must be CONST_INT, or we would have dealt with it above.  */
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Rework the address into a legal sequence of insns.  */
comment|/* Valid range for lo is -4095 -> 4095 */
name|lo
operator|=
operator|(
name|offset
operator|>=
literal|0
condition|?
operator|(
name|offset
operator|&
literal|0xfff
operator|)
else|:
operator|-
operator|(
operator|(
operator|-
name|offset
operator|)
operator|&
literal|0xfff
operator|)
operator|)
expr_stmt|;
comment|/* Corner case, if lo is the max offset then we would be out of range 	 once we have added the additional 1 below, so bump the msb into the 	 pre-loading insn(s).  */
if|if
condition|(
name|lo
operator|==
literal|4095
condition|)
name|lo
operator|&=
literal|0x7ff
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
operator|(
operator|(
name|offset
operator|-
name|lo
operator|)
operator|&
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|^
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
expr_stmt|;
if|if
condition|(
name|hi
operator|+
name|lo
operator|!=
name|offset
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Get the base address; addsi3 knows how to handle constants 	     that require more than one insn.  */
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|base_plus
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
name|hi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
name|offset
operator|=
name|lo
expr_stmt|;
block|}
block|}
name|scratch
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendqisi2
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendqisi2
argument_list|(
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|SImode
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle storing a half-word to memory during reload by synthesising as two    byte stores.  Take care not to clobber the input values until after we    have moved them somewhere safe.  This code assumes that if the DImode    scratch in operands[2] overlaps either the input value or output address    in some way, then that value must die in this insn (we absolutely need    two scratch registers for some corner cases).  */
end_comment

begin_function
name|void
name|arm_reload_out_hi
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|ref
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|outval
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|scratch
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|=
name|SUBREG_BYTE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* We have a pseudo which has been spilt onto the stack; there 	 are two cases here: the first where there is a simple 	 stack-slot replacement and a second where the stack-slot is 	 out of range, or is used as a subreg.  */
if|if
condition|(
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
condition|)
block|{
name|ref
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* The slot is out of range, or was dressed up in a SUBREG.  */
name|base
operator|=
name|reg_equiv_address
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
block|}
else|else
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle the case where the address is too complex to be offset by 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MINUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Be careful not to destroy OUTVAL.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|base_plus
argument_list|,
name|outval
argument_list|)
condition|)
block|{
comment|/* Updating base_plus might destroy outval, see if we can 	     swap the scratch and base_plus.  */
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|scratch
argument_list|,
name|outval
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|scratch
decl_stmt|;
name|scratch
operator|=
name|base_plus
expr_stmt|;
name|base_plus
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|scratch_hi
init|=
name|gen_rtx_REG
argument_list|(
name|HImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Be conservative and copy OUTVAL into the scratch now, 		 this should only be necessary if outval is a subreg 		 of something larger than a word.  */
comment|/* XXX Might this clobber base?  I can't see how it can, 		 since scratch is known to overlap with OUTVAL, and 		 must be wider than a word.  */
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|scratch_hi
argument_list|,
name|outval
argument_list|)
argument_list|)
expr_stmt|;
name|outval
operator|=
name|scratch_hi
expr_stmt|;
block|}
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|base_plus
argument_list|,
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The addend must be CONST_INT, or we would have dealt with it above.  */
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Rework the address into a legal sequence of insns.  */
comment|/* Valid range for lo is -4095 -> 4095 */
name|lo
operator|=
operator|(
name|offset
operator|>=
literal|0
condition|?
operator|(
name|offset
operator|&
literal|0xfff
operator|)
else|:
operator|-
operator|(
operator|(
operator|-
name|offset
operator|)
operator|&
literal|0xfff
operator|)
operator|)
expr_stmt|;
comment|/* Corner case, if lo is the max offset then we would be out of range 	 once we have added the additional 1 below, so bump the msb into the 	 pre-loading insn(s).  */
if|if
condition|(
name|lo
operator|==
literal|4095
condition|)
name|lo
operator|&=
literal|0x7ff
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
operator|(
operator|(
name|offset
operator|-
name|lo
operator|)
operator|&
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|^
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
expr_stmt|;
if|if
condition|(
name|hi
operator|+
name|lo
operator|!=
name|offset
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Be careful not to destroy OUTVAL.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|base_plus
argument_list|,
name|outval
argument_list|)
condition|)
block|{
comment|/* Updating base_plus might destroy outval, see if we 		 can swap the scratch and base_plus.  */
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|scratch
argument_list|,
name|outval
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|scratch
decl_stmt|;
name|scratch
operator|=
name|base_plus
expr_stmt|;
name|base_plus
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|scratch_hi
init|=
name|gen_rtx_REG
argument_list|(
name|HImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Be conservative and copy outval into scratch now, 		     this should only be necessary if outval is a 		     subreg of something larger than a word.  */
comment|/* XXX Might this clobber base?  I can't see how it 		     can, since scratch is known to overlap with 		     outval.  */
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|scratch_hi
argument_list|,
name|outval
argument_list|)
argument_list|)
expr_stmt|;
name|outval
operator|=
name|scratch_hi
expr_stmt|;
block|}
block|}
comment|/* Get the base address; addsi3 knows how to handle constants 	     that require more than one insn.  */
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|base_plus
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
name|hi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
name|offset
operator|=
name|lo
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|outval
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|outval
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|scratch
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|outval
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|outval
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|QImode
argument_list|,
name|scratch
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a symbolic form of X to the debug file, F.  */
end_comment

begin_function
specifier|static
name|void
name|arm_print_value
parameter_list|(
name|f
parameter_list|,
name|x
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST_DOUBLE
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"<0x%lx,0x%lx>"
argument_list|,
operator|(
name|long
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST_STRING
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\"%s\""
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SYMBOL_REF
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"`%s'"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|LABEL_REF
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"L%d"
argument_list|,
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST
case|:
name|arm_print_value
argument_list|(
name|f
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS
case|:
name|arm_print_value
argument_list|(
name|f
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|arm_print_value
argument_list|(
name|f
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|PC
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"pc"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"????"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines for manipulation of the constant pool.  */
end_comment

begin_comment
comment|/* Arm instructions cannot load a large constant directly into a    register; they have to come from a pc relative load.  The constant    must therefore be placed in the addressable range of the pc    relative load.  Depending on the precise pc relative load    instruction the range is somewhere between 256 bytes and 4k.  This    means that we often have to dump a constant inside a function, and    generate code to branch around it.     It is important to minimize this, since the branches will slow    things down and make the code larger.     Normally we can hide the table after an existing unconditional    branch so that there is no interruption of the flow, but in the    worst case the code looks like this:  	ldr	rn, L1 	... 	b	L2 	align 	L1:	.long value 	L2: 	...  	ldr	rn, L3 	... 	b	L4 	align 	L3:	.long value 	L4: 	...     We fix this by performing a scan after scheduling, which notices    which instructions need to have their operands fetched from the    constant table and builds the table.     The algorithm starts by building a table of all the constants that    need fixing up and all the natural barriers in the function (places    where a constant table can be dropped without breaking the flow).    For each fixup we note how far the pc-relative replacement will be    able to reach and the offset of the instruction into the function.     Having built the table we then group the fixes together to form    tables that are as large as possible (subject to addressing    constraints) and emit each table of constants after the last    barrier that is within range of all the instructions in the group.    If a group does not contain a barrier, then we forcibly create one    by inserting a jump instruction into the flow.  Once the table has    been inserted, the insns are then modified to reference the    relevant entry in the pool.     Possible enhancements to the algorithm (not implemented) are:     1) For some processors and object formats, there may be benefit in    aligning the pools to the start of cache lines; this alignment    would need to be taken into account when calculating addressability    of a pool.  */
end_comment

begin_comment
comment|/* These typedefs are located at the start of this file, so that    they can be used in the prototypes there.  This comment is to    remind readers of that fact so that the following structures    can be understood more easily.       typedef struct minipool_node    Mnode;      typedef struct minipool_fixup   Mfix;  */
end_comment

begin_struct
struct|struct
name|minipool_node
block|{
comment|/* Doubly linked chain of entries.  */
name|Mnode
modifier|*
name|next
decl_stmt|;
name|Mnode
modifier|*
name|prev
decl_stmt|;
comment|/* The maximum offset into the code that this entry can be placed.  While      pushing fixes for forward references, all entries are sorted in order      of increasing max_address.  */
name|HOST_WIDE_INT
name|max_address
decl_stmt|;
comment|/* Similarly for an entry inserted for a backwards ref.  */
name|HOST_WIDE_INT
name|min_address
decl_stmt|;
comment|/* The number of fixes referencing this entry.  This can become zero      if we "unpush" an entry.  In this case we ignore the entry when we      come to emit the code.  */
name|int
name|refcount
decl_stmt|;
comment|/* The offset from the start of the minipool.  */
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* The value in table.  */
name|rtx
name|value
decl_stmt|;
comment|/* The mode of value.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|fix_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|minipool_fixup
block|{
name|Mfix
modifier|*
name|next
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|HOST_WIDE_INT
name|address
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|fix_size
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|Mnode
modifier|*
name|minipool
decl_stmt|;
name|HOST_WIDE_INT
name|forwards
decl_stmt|;
name|HOST_WIDE_INT
name|backwards
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Fixes less than a word need padding out to a word boundary.  */
end_comment

begin_define
define|#
directive|define
name|MINIPOOL_FIX_SIZE
parameter_list|(
name|mode
parameter_list|)
define|\
value|(GET_MODE_SIZE ((mode))>= 4 ? GET_MODE_SIZE ((mode)) : 4)
end_define

begin_decl_stmt
specifier|static
name|Mnode
modifier|*
name|minipool_vector_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Mnode
modifier|*
name|minipool_vector_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|minipool_vector_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The linked list of all minipool fixes required for this function.  */
end_comment

begin_decl_stmt
name|Mfix
modifier|*
name|minipool_fix_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Mfix
modifier|*
name|minipool_fix_tail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The fix entry for the current minipool, once it has been placed.  */
end_comment

begin_decl_stmt
name|Mfix
modifier|*
name|minipool_barrier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determines if INSN is the start of a jump table.  Returns the end    of the TABLE or NULL_RTX.  */
end_comment

begin_function
specifier|static
name|rtx
name|is_jump_table
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|table
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|table
operator|=
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|==
name|next_real_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|table
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|table
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
return|return
name|table
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_function
specifier|static
name|HOST_WIDE_INT
name|get_jump_table_size
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|elt
init|=
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|?
literal|1
else|:
literal|0
decl_stmt|;
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|*
name|XVECLEN
argument_list|(
name|body
argument_list|,
name|elt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Move a minipool fix MP from its current location to before MAX_MP.    If MAX_MP is NULL, then MP doesn't need moving, but the addressing    contrains may need updating.  */
end_comment

begin_function
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_forward_ref
parameter_list|(
name|mp
parameter_list|,
name|max_mp
parameter_list|,
name|max_address
parameter_list|)
name|Mnode
modifier|*
name|mp
decl_stmt|;
name|Mnode
modifier|*
name|max_mp
decl_stmt|;
name|HOST_WIDE_INT
name|max_address
decl_stmt|;
block|{
comment|/* This should never be true and the code below assumes these are      different.  */
if|if
condition|(
name|mp
operator|==
name|max_mp
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|max_mp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|max_address
operator|<
name|mp
operator|->
name|max_address
condition|)
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|max_address
operator|>
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|max_address
operator|=
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
expr_stmt|;
else|else
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
comment|/* Unlink MP from its current position.  Since max_mp is non-null,        mp->prev must be non-null.  */
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
else|else
name|minipool_vector_tail
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
comment|/* Re-insert it before MAX_MP.  */
name|mp
operator|->
name|next
operator|=
name|max_mp
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|max_mp
operator|->
name|prev
expr_stmt|;
name|max_mp
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
block|}
comment|/* Save the new entry.  */
name|max_mp
operator|=
name|mp
expr_stmt|;
comment|/* Scan over the preceding entries and adjust their addresses as      required.  */
while|while
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
operator|&&
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|>
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
condition|)
block|{
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|=
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
block|}
return|return
name|max_mp
return|;
block|}
end_function

begin_comment
comment|/* Add a constant to the minipool for a forward reference.  Returns the    node added or NULL if the constant will not fit in this pool.  */
end_comment

begin_function
specifier|static
name|Mnode
modifier|*
name|add_minipool_forward_ref
parameter_list|(
name|fix
parameter_list|)
name|Mfix
modifier|*
name|fix
decl_stmt|;
block|{
comment|/* If set, max_mp is the first pool_entry that has a lower      constraint than the one we are trying to add.  */
name|Mnode
modifier|*
name|max_mp
init|=
name|NULL
decl_stmt|;
name|HOST_WIDE_INT
name|max_address
init|=
name|fix
operator|->
name|address
operator|+
name|fix
operator|->
name|forwards
decl_stmt|;
name|Mnode
modifier|*
name|mp
decl_stmt|;
comment|/* If this fix's address is greater than the address of the first      entry, then we can't put the fix in this pool.  We subtract the      size of the current fix to ensure that if the table is fully      packed we still have enough room to insert this value by suffling      the other fixes forwards.  */
if|if
condition|(
name|minipool_vector_head
operator|&&
name|fix
operator|->
name|address
operator|>=
name|minipool_vector_head
operator|->
name|max_address
operator|-
name|fix
operator|->
name|fix_size
condition|)
return|return
name|NULL
return|;
comment|/* Scan the pool to see if a constant with the same value has      already been added.  While we are doing this, also note the      location where we must insert the constant if it doesn't already      exist.  */
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|&&
name|fix
operator|->
name|mode
operator|==
name|mp
operator|->
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
operator|(
name|CODE_LABEL_NUMBER
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|CODE_LABEL_NUMBER
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|fix
operator|->
name|value
argument_list|,
name|mp
operator|->
name|value
argument_list|)
condition|)
block|{
comment|/* More than one fix references this entry.  */
name|mp
operator|->
name|refcount
operator|++
expr_stmt|;
return|return
name|move_minipool_fix_forward_ref
argument_list|(
name|mp
argument_list|,
name|max_mp
argument_list|,
name|max_address
argument_list|)
return|;
block|}
comment|/* Note the insertion point if necessary.  */
if|if
condition|(
name|max_mp
operator|==
name|NULL
operator|&&
name|mp
operator|->
name|max_address
operator|>
name|max_address
condition|)
name|max_mp
operator|=
name|mp
expr_stmt|;
block|}
comment|/* The value is not currently in the minipool, so we need to create      a new entry for it.  If MAX_MP is NULL, the entry will be put on      the end of the list since the placement is less constrained than      any existing entry.  Otherwise, we insert the new fix before      MAX_MP and, if neceesary, adjust the constraints on the other      entries.  */
name|mp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|fix_size
operator|=
name|fix
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|->
name|mode
operator|=
name|fix
operator|->
name|mode
expr_stmt|;
name|mp
operator|->
name|value
operator|=
name|fix
operator|->
name|value
expr_stmt|;
name|mp
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
comment|/* Not yet required for a backwards ref.  */
name|mp
operator|->
name|min_address
operator|=
operator|-
literal|65536
expr_stmt|;
if|if
condition|(
name|max_mp
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|minipool_vector_tail
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
name|minipool_vector_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
expr_stmt|;
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|max_address
operator|>
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|max_address
operator|=
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
expr_stmt|;
else|else
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|max_mp
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|max_mp
operator|->
name|prev
expr_stmt|;
name|max_mp
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
block|}
comment|/* Save the new entry.  */
name|max_mp
operator|=
name|mp
expr_stmt|;
comment|/* Scan over the preceding entries and adjust their addresses as      required.  */
while|while
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
operator|&&
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|>
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
condition|)
block|{
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|=
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
block|}
return|return
name|max_mp
return|;
block|}
end_function

begin_function
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_backward_ref
parameter_list|(
name|mp
parameter_list|,
name|min_mp
parameter_list|,
name|min_address
parameter_list|)
name|Mnode
modifier|*
name|mp
decl_stmt|;
name|Mnode
modifier|*
name|min_mp
decl_stmt|;
name|HOST_WIDE_INT
name|min_address
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* This should never be true, and the code below assumes these are      different.  */
if|if
condition|(
name|mp
operator|==
name|min_mp
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|min_mp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|min_address
operator|>
name|mp
operator|->
name|min_address
condition|)
name|mp
operator|->
name|min_address
operator|=
name|min_address
expr_stmt|;
block|}
else|else
block|{
comment|/* We will adjust this below if it is too loose.  */
name|mp
operator|->
name|min_address
operator|=
name|min_address
expr_stmt|;
comment|/* Unlink MP from its current position.  Since min_mp is non-null, 	 mp->next must be non-null.  */
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
operator|->
name|next
expr_stmt|;
else|else
name|minipool_vector_head
operator|=
name|mp
operator|->
name|next
expr_stmt|;
comment|/* Reinsert it after MIN_MP.  */
name|mp
operator|->
name|prev
operator|=
name|min_mp
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|min_mp
operator|->
name|next
expr_stmt|;
name|min_mp
operator|->
name|next
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
block|}
name|min_mp
operator|=
name|mp
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
name|mp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|refcount
operator|>
literal|0
condition|)
name|offset
operator|+=
name|mp
operator|->
name|fix_size
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|&&
name|mp
operator|->
name|next
operator|->
name|min_address
operator|<
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|next
operator|->
name|min_address
operator|=
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
expr_stmt|;
block|}
return|return
name|min_mp
return|;
block|}
end_function

begin_comment
comment|/* Add a constant to the minipool for a backward reference.  Returns the    node added or NULL if the constant will not fit in this pool.       Note that the code for insertion for a backwards reference can be    somewhat confusing because the calculated offsets for each fix do    not take into account the size of the pool (which is still under    construction.  */
end_comment

begin_function
specifier|static
name|Mnode
modifier|*
name|add_minipool_backward_ref
parameter_list|(
name|fix
parameter_list|)
name|Mfix
modifier|*
name|fix
decl_stmt|;
block|{
comment|/* If set, min_mp is the last pool_entry that has a lower constraint      than the one we are trying to add.  */
name|Mnode
modifier|*
name|min_mp
init|=
name|NULL
decl_stmt|;
comment|/* This can be negative, since it is only a constraint.  */
name|HOST_WIDE_INT
name|min_address
init|=
name|fix
operator|->
name|address
operator|-
name|fix
operator|->
name|backwards
decl_stmt|;
name|Mnode
modifier|*
name|mp
decl_stmt|;
comment|/* If we can't reach the current pool from this insn, or if we can't      insert this entry at the end of the pool without pushing other      fixes out of range, then we don't try.  This ensures that we      can't fail later on.  */
if|if
condition|(
name|min_address
operator|>=
name|minipool_barrier
operator|->
name|address
operator|||
operator|(
name|minipool_vector_tail
operator|->
name|min_address
operator|+
name|fix
operator|->
name|fix_size
operator|>=
name|minipool_barrier
operator|->
name|address
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Scan the pool to see if a constant with the same value has      already been added.  While we are doing this, also note the      location where we must insert the constant if it doesn't already      exist.  */
for|for
control|(
name|mp
operator|=
name|minipool_vector_tail
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|&&
name|fix
operator|->
name|mode
operator|==
name|mp
operator|->
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
operator|(
name|CODE_LABEL_NUMBER
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|CODE_LABEL_NUMBER
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|fix
operator|->
name|value
argument_list|,
name|mp
operator|->
name|value
argument_list|)
comment|/* Check that there is enough slack to move this entry to the 	     end of the table (this is conservative).  */
operator|&&
operator|(
name|mp
operator|->
name|max_address
operator|>
operator|(
name|minipool_barrier
operator|->
name|address
operator|+
name|minipool_vector_tail
operator|->
name|offset
operator|+
name|minipool_vector_tail
operator|->
name|fix_size
operator|)
operator|)
condition|)
block|{
name|mp
operator|->
name|refcount
operator|++
expr_stmt|;
return|return
name|move_minipool_fix_backward_ref
argument_list|(
name|mp
argument_list|,
name|min_mp
argument_list|,
name|min_address
argument_list|)
return|;
block|}
if|if
condition|(
name|min_mp
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|min_address
operator|+=
name|fix
operator|->
name|fix_size
expr_stmt|;
else|else
block|{
comment|/* Note the insertion point if necessary.  */
if|if
condition|(
name|mp
operator|->
name|min_address
operator|<
name|min_address
condition|)
name|min_mp
operator|=
name|mp
expr_stmt|;
elseif|else
if|if
condition|(
name|mp
operator|->
name|max_address
operator|<
name|minipool_barrier
operator|->
name|address
operator|+
name|mp
operator|->
name|offset
operator|+
name|fix
operator|->
name|fix_size
condition|)
block|{
comment|/* Inserting before this entry would push the fix beyond 		 its maximum address (which can happen if we have 		 re-located a forwards fix); force the new fix to come 		 after it.  */
name|min_mp
operator|=
name|mp
expr_stmt|;
name|min_address
operator|=
name|mp
operator|->
name|min_address
operator|+
name|fix
operator|->
name|fix_size
expr_stmt|;
block|}
block|}
block|}
comment|/* We need to create a new entry.  */
name|mp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|fix_size
operator|=
name|fix
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|->
name|mode
operator|=
name|fix
operator|->
name|mode
expr_stmt|;
name|mp
operator|->
name|value
operator|=
name|fix
operator|->
name|value
expr_stmt|;
name|mp
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|max_address
operator|=
name|minipool_barrier
operator|->
name|address
operator|+
literal|65536
expr_stmt|;
name|mp
operator|->
name|min_address
operator|=
name|min_address
expr_stmt|;
if|if
condition|(
name|min_mp
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|minipool_vector_head
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
name|minipool_vector_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|next
operator|=
name|min_mp
operator|->
name|next
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|min_mp
expr_stmt|;
name|min_mp
operator|->
name|next
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
block|}
comment|/* Save the new entry.  */
name|min_mp
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
condition|)
name|mp
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
else|else
name|mp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Scan over the following entries and adjust their offsets.  */
while|while
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|next
operator|->
name|min_address
operator|<
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|next
operator|->
name|min_address
operator|=
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|refcount
condition|)
name|mp
operator|->
name|next
operator|->
name|offset
operator|=
name|mp
operator|->
name|offset
operator|+
name|mp
operator|->
name|fix_size
expr_stmt|;
else|else
name|mp
operator|->
name|next
operator|->
name|offset
operator|=
name|mp
operator|->
name|offset
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|next
expr_stmt|;
block|}
return|return
name|min_mp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|assign_minipool_offsets
parameter_list|(
name|barrier
parameter_list|)
name|Mfix
modifier|*
name|barrier
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|Mnode
modifier|*
name|mp
decl_stmt|;
name|minipool_barrier
operator|=
name|barrier
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
name|mp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|refcount
operator|>
literal|0
condition|)
name|offset
operator|+=
name|mp
operator|->
name|fix_size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the literal table */
end_comment

begin_function
specifier|static
name|void
name|dump_minipool
parameter_list|(
name|scan
parameter_list|)
name|rtx
name|scan
decl_stmt|;
block|{
name|Mnode
modifier|*
name|mp
decl_stmt|;
name|Mnode
modifier|*
name|nmp
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Emitting minipool after insn %u; address %ld\n"
argument_list|,
name|INSN_UID
argument_list|(
name|scan
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|minipool_barrier
operator|->
name|address
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_label_after
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_align_4
argument_list|()
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_label_after
argument_list|(
name|minipool_vector_label
argument_list|,
name|scan
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|nmp
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";;  Offset %u, min %ld, max %ld "
argument_list|,
operator|(
name|unsigned
operator|)
name|mp
operator|->
name|offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|mp
operator|->
name|min_address
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|mp
operator|->
name|max_address
argument_list|)
expr_stmt|;
name|arm_print_value
argument_list|(
name|rtl_dump_file
argument_list|,
name|mp
operator|->
name|value
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mp
operator|->
name|fix_size
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_consttable_1
case|case
literal|1
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_1
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_consttable_2
case|case
literal|2
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_2
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_consttable_4
case|case
literal|4
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_4
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_consttable_8
case|case
literal|8
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_8
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|nmp
operator|=
name|mp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|minipool_vector_head
operator|=
name|minipool_vector_tail
operator|=
name|NULL
expr_stmt|;
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_end
argument_list|()
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_barrier_after
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the cost of forcibly inserting a barrier after INSN.  */
end_comment

begin_function
specifier|static
name|int
name|arm_barrier_cost
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Basing the location of the pool on the loop depth is preferable,      but at the moment, the basic block information seems to be      corrupt by this stage of the compilation.  */
name|int
name|base_cost
init|=
literal|50
decl_stmt|;
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|base_cost
operator|-=
literal|20
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
comment|/* It will always be better to place the table before the label, rather 	 than after it.  */
return|return
literal|50
return|;
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
return|return
name|base_cost
return|;
case|case
name|JUMP_INSN
case|:
return|return
name|base_cost
operator|-
literal|10
return|;
default|default:
return|return
name|base_cost
operator|+
literal|10
return|;
block|}
block|}
end_function

begin_comment
comment|/* Find the best place in the insn stream in the range    (FIX->address,MAX_ADDRESS) to forcibly insert a minipool barrier.    Create the barrier by inserting a jump and add a new fix entry for    it.  */
end_comment

begin_function
specifier|static
name|Mfix
modifier|*
name|create_fix_barrier
parameter_list|(
name|fix
parameter_list|,
name|max_address
parameter_list|)
name|Mfix
modifier|*
name|fix
decl_stmt|;
name|HOST_WIDE_INT
name|max_address
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|barrier
decl_stmt|;
name|rtx
name|from
init|=
name|fix
operator|->
name|insn
decl_stmt|;
name|rtx
name|selected
init|=
name|from
decl_stmt|;
name|int
name|selected_cost
decl_stmt|;
name|HOST_WIDE_INT
name|selected_address
decl_stmt|;
name|Mfix
modifier|*
name|new_fix
decl_stmt|;
name|HOST_WIDE_INT
name|max_count
init|=
name|max_address
operator|-
name|fix
operator|->
name|address
decl_stmt|;
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|selected_cost
operator|=
name|arm_barrier_cost
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|selected_address
operator|=
name|fix
operator|->
name|address
expr_stmt|;
while|while
condition|(
name|from
operator|&&
name|count
operator|<
name|max_count
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|int
name|new_cost
decl_stmt|;
comment|/* This code shouldn't have been called if there was a natural barrier 	 within range.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Count the length of this insn.  */
name|count
operator|+=
name|get_attr_length
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* If there is a jump table, add its length.  */
name|tmp
operator|=
name|is_jump_table
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|count
operator|+=
name|get_jump_table_size
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* Jump tables aren't in a basic block, so base the cost on 	     the dispatch insn.  If we select this location, we will 	     still put the pool after the table.  */
name|new_cost
operator|=
name|arm_barrier_cost
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|max_count
operator|&&
name|new_cost
operator|<=
name|selected_cost
condition|)
block|{
name|selected
operator|=
name|tmp
expr_stmt|;
name|selected_cost
operator|=
name|new_cost
expr_stmt|;
name|selected_address
operator|=
name|fix
operator|->
name|address
operator|+
name|count
expr_stmt|;
block|}
comment|/* Continue after the dispatch table.  */
name|from
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|new_cost
operator|=
name|arm_barrier_cost
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|max_count
operator|&&
name|new_cost
operator|<=
name|selected_cost
condition|)
block|{
name|selected
operator|=
name|from
expr_stmt|;
name|selected_cost
operator|=
name|new_cost
expr_stmt|;
name|selected_address
operator|=
name|fix
operator|->
name|address
operator|+
name|count
expr_stmt|;
block|}
name|from
operator|=
name|NEXT_INSN
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
comment|/* Create a new JUMP_INSN that branches around a barrier.  */
name|from
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|selected
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|from
argument_list|)
operator|=
name|label
expr_stmt|;
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
comment|/* Create a minipool barrier entry for the new barrier.  */
name|new_fix
operator|=
operator|(
name|Mfix
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_fix
argument_list|)
argument_list|)
expr_stmt|;
name|new_fix
operator|->
name|insn
operator|=
name|barrier
expr_stmt|;
name|new_fix
operator|->
name|address
operator|=
name|selected_address
expr_stmt|;
name|new_fix
operator|->
name|next
operator|=
name|fix
operator|->
name|next
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|new_fix
expr_stmt|;
return|return
name|new_fix
return|;
block|}
end_function

begin_comment
comment|/* Record that there is a natural barrier in the insn stream at    ADDRESS.  */
end_comment

begin_function
specifier|static
name|void
name|push_minipool_barrier
parameter_list|(
name|insn
parameter_list|,
name|address
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|HOST_WIDE_INT
name|address
decl_stmt|;
block|{
name|Mfix
modifier|*
name|fix
init|=
operator|(
name|Mfix
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fix
argument_list|)
argument_list|)
decl_stmt|;
name|fix
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|fix
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|minipool_fix_head
operator|!=
name|NULL
condition|)
name|minipool_fix_tail
operator|->
name|next
operator|=
name|fix
expr_stmt|;
else|else
name|minipool_fix_head
operator|=
name|fix
expr_stmt|;
name|minipool_fix_tail
operator|=
name|fix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record INSN, which will need fixing up to load a value from the    minipool.  ADDRESS is the offset of the insn since the start of the    function; LOC is a pointer to the part of the insn which requires    fixing; VALUE is the constant that must be loaded, which is of type    MODE.  */
end_comment

begin_function
specifier|static
name|void
name|push_minipool_fix
parameter_list|(
name|insn
parameter_list|,
name|address
parameter_list|,
name|loc
parameter_list|,
name|mode
parameter_list|,
name|value
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|HOST_WIDE_INT
name|address
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|value
decl_stmt|;
block|{
name|Mfix
modifier|*
name|fix
init|=
operator|(
name|Mfix
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fix
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
comment|/* PIC symbol refereneces need to be converted into offsets into the      based area.  */
comment|/* XXX This shouldn't be done here.  */
if|if
condition|(
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|value
operator|=
name|aof_pic_entry
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AOF_ASSEMBLER */
name|fix
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|fix
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|fix
operator|->
name|loc
operator|=
name|loc
expr_stmt|;
name|fix
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|fix
operator|->
name|fix_size
operator|=
name|MINIPOOL_FIX_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|fix
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|fix
operator|->
name|forwards
operator|=
name|get_attr_pool_range
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fix
operator|->
name|backwards
operator|=
name|get_attr_neg_pool_range
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fix
operator|->
name|minipool
operator|=
name|NULL
expr_stmt|;
comment|/* If an insn doesn't have a range defined for it, then it isn't      expecting to be reworked by this code.  Better to abort now than      to generate duff assembly code.  */
if|if
condition|(
name|fix
operator|->
name|forwards
operator|==
literal|0
operator|&&
name|fix
operator|->
name|backwards
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; %smode fixup for i%d; addr %lu, range (%ld,%ld): "
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address
argument_list|,
operator|-
literal|1
operator|*
operator|(
name|long
operator|)
name|fix
operator|->
name|backwards
argument_list|,
operator|(
name|long
operator|)
name|fix
operator|->
name|forwards
argument_list|)
expr_stmt|;
name|arm_print_value
argument_list|(
name|rtl_dump_file
argument_list|,
name|fix
operator|->
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Add it to the chain of fixes.  */
name|fix
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|minipool_fix_head
operator|!=
name|NULL
condition|)
name|minipool_fix_tail
operator|->
name|next
operator|=
name|fix
expr_stmt|;
else|else
name|minipool_fix_head
operator|=
name|fix
expr_stmt|;
name|minipool_fix_tail
operator|=
name|fix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan INSN and note any of its operands that need fixing.  */
end_comment

begin_function
specifier|static
name|void
name|note_invalid_constants
parameter_list|(
name|insn
parameter_list|,
name|address
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|HOST_WIDE_INT
name|address
decl_stmt|;
block|{
name|int
name|opno
decl_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Fill in recog_op_alt with information about the constraints of this      insn.  */
name|preprocess_constraints
argument_list|()
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
block|{
comment|/* Things we need to fix can only occur in inputs.  */
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|opno
index|]
operator|!=
name|OP_IN
condition|)
continue|continue;
comment|/* If this alternative is a memory reference, then any mention 	 of constants in this alternative is really to fool reload 	 into allowing us to accept one there.  We need to fix them up 	 now so that we output the right code.  */
if|if
condition|(
name|recog_op_alt
index|[
name|opno
index|]
index|[
name|which_alternative
index|]
operator|.
name|memory_ok
condition|)
block|{
name|rtx
name|op
init|=
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
name|push_minipool_fix
argument_list|(
name|insn
argument_list|,
name|address
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|opno
index|]
argument_list|,
name|recog_data
operator|.
name|operand_mode
index|[
name|opno
index|]
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* RWE: Now we look correctly at the operands for the insn, 	     this shouldn't be needed any more.  */
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
comment|/* XXX Is this still needed?  */
if|else if (GET_CODE (op) == UNSPEC&& XINT (op, 1) == UNSPEC_PIC_SYM) 	    push_minipool_fix (insn, address, recog_data.operand_loc[opno], 			       recog_data.operand_mode[opno], 			       XVECEXP (op, 0, 0));
endif|#
directive|endif
endif|#
directive|endif
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|push_minipool_fix
argument_list|(
name|insn
argument_list|,
name|address
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|opno
index|]
argument_list|,
name|recog_data
operator|.
name|operand_mode
index|[
name|opno
index|]
argument_list|,
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|arm_reorg
parameter_list|(
name|first
parameter_list|)
name|rtx
name|first
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|HOST_WIDE_INT
name|address
init|=
literal|0
decl_stmt|;
name|Mfix
modifier|*
name|fix
decl_stmt|;
name|minipool_fix_head
operator|=
name|minipool_fix_tail
operator|=
name|NULL
expr_stmt|;
comment|/* The first insn must always be a note, or the code below won't      scan it properly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|first
argument_list|)
operator|!=
name|NOTE
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Scan all the insns and record the operands that will need fixing.  */
for|for
control|(
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|first
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|push_minipool_barrier
argument_list|(
name|insn
argument_list|,
name|address
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|table
decl_stmt|;
name|note_invalid_constants
argument_list|(
name|insn
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|address
operator|+=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If the insn is a vector jump, add the size of the table 	     and skip the table.  */
if|if
condition|(
operator|(
name|table
operator|=
name|is_jump_table
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|address
operator|+=
name|get_jump_table_size
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|insn
operator|=
name|table
expr_stmt|;
block|}
block|}
block|}
name|fix
operator|=
name|minipool_fix_head
expr_stmt|;
comment|/* Now scan the fixups and perform the required changes.  */
while|while
condition|(
name|fix
condition|)
block|{
name|Mfix
modifier|*
name|ftmp
decl_stmt|;
name|Mfix
modifier|*
name|fdel
decl_stmt|;
name|Mfix
modifier|*
name|last_added_fix
decl_stmt|;
name|Mfix
modifier|*
name|last_barrier
init|=
name|NULL
decl_stmt|;
name|Mfix
modifier|*
name|this_fix
decl_stmt|;
comment|/* Skip any further barriers before the next fix.  */
while|while
condition|(
name|fix
operator|&&
name|GET_CODE
argument_list|(
name|fix
operator|->
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|fix
operator|=
name|fix
operator|->
name|next
expr_stmt|;
comment|/* No more fixes.  */
if|if
condition|(
name|fix
operator|==
name|NULL
condition|)
break|break;
name|last_added_fix
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ftmp
operator|=
name|fix
init|;
name|ftmp
condition|;
name|ftmp
operator|=
name|ftmp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ftmp
operator|->
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
if|if
condition|(
name|ftmp
operator|->
name|address
operator|>=
name|minipool_vector_head
operator|->
name|max_address
condition|)
break|break;
name|last_barrier
operator|=
name|ftmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ftmp
operator|->
name|minipool
operator|=
name|add_minipool_forward_ref
argument_list|(
name|ftmp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|last_added_fix
operator|=
name|ftmp
expr_stmt|;
comment|/* Keep track of the last fix added.  */
block|}
comment|/* If we found a barrier, drop back to that; any fixes that we 	 could have reached but come after the barrier will now go in 	 the next mini-pool.  */
if|if
condition|(
name|last_barrier
operator|!=
name|NULL
condition|)
block|{
comment|/* Reduce the refcount for those fixes that won't go into this  	     pool after all.  */
for|for
control|(
name|fdel
operator|=
name|last_barrier
operator|->
name|next
init|;
name|fdel
operator|&&
name|fdel
operator|!=
name|ftmp
condition|;
name|fdel
operator|=
name|fdel
operator|->
name|next
control|)
block|{
name|fdel
operator|->
name|minipool
operator|->
name|refcount
operator|--
expr_stmt|;
name|fdel
operator|->
name|minipool
operator|=
name|NULL
expr_stmt|;
block|}
name|ftmp
operator|=
name|last_barrier
expr_stmt|;
block|}
else|else
block|{
comment|/* ftmp is first fix that we can't fit into this pool and 	     there no natural barriers that we could use.  Insert a 	     new barrier in the code somewhere between the previous 	     fix and this one, and arrange to jump around it.  */
name|HOST_WIDE_INT
name|max_address
decl_stmt|;
comment|/* The last item on the list of fixes must be a barrier, so 	     we can never run off the end of the list of fixes without 	     last_barrier being set.  */
if|if
condition|(
name|ftmp
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|max_address
operator|=
name|minipool_vector_head
operator|->
name|max_address
expr_stmt|;
comment|/* Check that there isn't another fix that is in range that 	     we couldn't fit into this pool because the pool was 	     already too large: we need to put the pool before such an 	     instruction.  */
if|if
condition|(
name|ftmp
operator|->
name|address
operator|<
name|max_address
condition|)
name|max_address
operator|=
name|ftmp
operator|->
name|address
expr_stmt|;
name|last_barrier
operator|=
name|create_fix_barrier
argument_list|(
name|last_added_fix
argument_list|,
name|max_address
argument_list|)
expr_stmt|;
block|}
name|assign_minipool_offsets
argument_list|(
name|last_barrier
argument_list|)
expr_stmt|;
while|while
condition|(
name|ftmp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ftmp
operator|->
name|insn
argument_list|)
operator|!=
name|BARRIER
operator|&&
operator|(
operator|(
name|ftmp
operator|->
name|minipool
operator|=
name|add_minipool_backward_ref
argument_list|(
name|ftmp
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
break|break;
name|ftmp
operator|=
name|ftmp
operator|->
name|next
expr_stmt|;
block|}
comment|/* Scan over the fixes we have identified for this pool, fixing them 	 up and adding the constants to the pool itself.  */
for|for
control|(
name|this_fix
operator|=
name|fix
init|;
name|this_fix
operator|&&
name|ftmp
operator|!=
name|this_fix
condition|;
name|this_fix
operator|=
name|this_fix
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_fix
operator|->
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
name|rtx
name|addr
init|=
name|plus_constant
argument_list|(
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|minipool_vector_label
argument_list|)
argument_list|,
name|this_fix
operator|->
name|minipool
operator|->
name|offset
argument_list|)
decl_stmt|;
operator|*
name|this_fix
operator|->
name|loc
operator|=
name|gen_rtx_MEM
argument_list|(
name|this_fix
operator|->
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|dump_minipool
argument_list|(
name|last_barrier
operator|->
name|insn
argument_list|)
expr_stmt|;
name|fix
operator|=
name|ftmp
expr_stmt|;
block|}
comment|/* From now on we must synthesize any constants that we can't handle      directly.  This can happen if the RTL gets split during final      instruction generation.  */
name|after_arm_reorg
operator|=
literal|1
expr_stmt|;
comment|/* Free the minipool memory.  */
name|obstack_free
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
name|minipool_startobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines to output assembly language.  */
end_comment

begin_comment
comment|/* If the rtx is the correct value then return the string of the number.    In this way we can ensure that valid double constants are generated even    when cross compiling.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|fp_immediate_constant
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fpa_consts_inited
condition|)
name|init_fpa_table
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|values_fpa
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|strings_fpa
index|[
name|i
index|]
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As for fp_immediate_constant, but value is passed directly, not in rtx.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fp_const_from_val
parameter_list|(
name|r
parameter_list|)
name|REAL_VALUE_TYPE
modifier|*
name|r
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fpa_consts_inited
condition|)
name|init_fpa_table
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
operator|*
name|r
argument_list|,
name|values_fpa
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|strings_fpa
index|[
name|i
index|]
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the operands of a LDM/STM instruction to STREAM.    MASK is the ARM register set mask of which only bits 0-15 are important.    REG is the base register, either the frame pointer or the stack pointer,    INSTR is the possibly suffixed load or store instruction.  */
end_comment

begin_function
specifier|static
name|void
name|print_multi_reg
parameter_list|(
name|stream
parameter_list|,
name|instr
parameter_list|,
name|reg
parameter_list|,
name|mask
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|instr
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|mask
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|not_first
init|=
name|FALSE
decl_stmt|;
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
name|instr
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|", {"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|not_first
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|not_first
operator|=
name|TRUE
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}%s\n"
argument_list|,
name|TARGET_APCS_32
condition|?
literal|""
else|:
literal|"^"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a 'call' insn.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_call
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
comment|/* Handle calls to lr using ip (which may be clobbered in subr anyway).  */
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|LR_REGNUM
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%0, %|lr"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|lr, %|pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_INTERWORK
condition|)
name|output_asm_insn
argument_list|(
literal|"bx%?\t%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|pc, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eliminate_lr2ip
parameter_list|(
name|x
parameter_list|)
name|rtx
modifier|*
name|x
decl_stmt|;
block|{
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
name|rtx
name|x0
init|=
operator|*
name|x
decl_stmt|;
name|int
name|code
init|=
name|GET_CODE
argument_list|(
name|x0
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x0
argument_list|)
operator|==
name|LR_REGNUM
condition|)
block|{
operator|*
name|x
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
default|default:
comment|/* Scan through the sub-elements and change any references there.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|something_changed
operator||=
name|eliminate_lr2ip
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x0
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|something_changed
operator||=
name|eliminate_lr2ip
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x0
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|something_changed
return|;
block|}
block|}
end_function

begin_comment
comment|/* Output a 'call' insn that is a reference in memory.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_call_mem
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|copy_rtx
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Be ultra careful.  */
comment|/* Handle calls using lr by using ip (which may be clobbered in subr anyway).  */
if|if
condition|(
name|eliminate_lr2ip
argument_list|(
operator|&
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|ip, %|lr"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_INTERWORK
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%|ip, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|lr, %|pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bx%?\t%|ip"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|lr, %|pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%|pc, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from arm registers to an fpu registers.    OPERANDS[0] is an fpu register.    OPERANDS[1] is the first registers of an arm register pair.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_long_double_fpu_from_arm
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|arm_reg0
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stm%?fd\t%|sp!, {%0, %1, %2}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldf%?e\t%0, [%|sp], #12"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from an fpu register to arm registers.    OPERANDS[0] is the first registers of an arm register pair.    OPERANDS[1] is an fpu register.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_long_double_arm_from_fpu
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|arm_reg0
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stf%?e\t%1, [%|sp, #-12]!"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldm%?fd\t%|sp!, {%0, %1, %2}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from arm registers to arm registers of a long double    OPERANDS[0] is the destination.    OPERANDS[1] is the source.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_long_double_arm_from_arm
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
comment|/* We have to be careful here because the two might overlap.  */
name|int
name|dest_start
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|src_start
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dest_start
operator|<
name|src_start
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|dest_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|src_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%0, %1"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|dest_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|src_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%0, %1"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from arm registers to an fpu registers.    OPERANDS[0] is an fpu register.    OPERANDS[1] is the first registers of an arm register pair.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_double_fpu_from_arm
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|arm_reg0
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stm%?fd\t%|sp!, {%0, %1}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldf%?d\t%0, [%|sp], #8"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from an fpu register to arm registers.    OPERANDS[0] is the first registers of an arm register pair.    OPERANDS[1] is an fpu register.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_double_arm_from_fpu
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|arm_reg0
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stf%?d\t%1, [%|sp, #-8]!"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldm%?fd\t%|sp!, {%0, %1}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move between double words.    It must be REG<-REG, REG<-CONST_DOUBLE, REG<-CONST_INT, REG<-MEM    or MEM<-REG and all MEMs must be offsettable addresses.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_move_double
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|otherops
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
name|int
name|reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|otherops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|reg0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|REG
condition|)
block|{
name|int
name|reg1
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg1
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ensure the second source is not overwritten.  */
if|if
condition|(
name|reg1
operator|==
name|reg0
operator|+
operator|(
name|WORDS_BIG_ENDIAN
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"mov%?\t%Q0, %Q1\n\tmov%?\t%R0, %R1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov%?\t%R0, %R1\n\tmov%?\t%Q0, %Q1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|DFmode
condition|)
block|{
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|union
name|real_extract
name|u
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|u
operator|.
name|d
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|output_mov_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
name|output_mov_immediate
argument_list|(
name|otherops
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|CONST_INT
condition|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|32
comment|/* If HOST_WIDE_INT is more than 32 bits, the intval tells us 	     what the upper word is.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>>
literal|32
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Sign extend the intval into the high-order word.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
operator|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
name|const0_rtx
operator|)
expr_stmt|;
block|}
else|else
name|otherops
index|[
literal|1
index|]
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|?
name|constm1_rtx
else|:
name|const0_rtx
expr_stmt|;
endif|#
directive|endif
name|output_mov_immediate
argument_list|(
name|otherops
argument_list|)
expr_stmt|;
name|output_mov_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|MEM
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?ia\t%m1, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen now.  */
break|break;
case|case
name|PRE_DEC
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?db\t%m1!, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?ia\t%m1!, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen now.  */
break|break;
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
name|output_asm_insn
argument_list|(
literal|"adr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldm%?ia\t%0, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|arm_add_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|otherops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
switch|switch
condition|(
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
case|case
operator|-
literal|8
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?db\t%1, %M0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
operator|-
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?da\t%1, %M0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?ib\t%1, %M0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"sub%?\t%0, %1, #%n2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"add%?\t%0, %1, %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"add%?\t%0, %1, %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"sub%?\t%0, %1, %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|"ldm%?ia\t%0, %M0"
return|;
block|}
else|else
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Take care of overlapping base/data reg.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Constraints should prevent this.  */
block|}
elseif|else
if|if
condition|(
name|code0
operator|==
name|MEM
operator|&&
name|code1
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|IP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?ia\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen now.  */
break|break;
case|case
name|PRE_DEC
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?db\t%m0!, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?ia\t%m0!, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* Should never happen now.  */
break|break;
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
switch|switch
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
case|case
operator|-
literal|8
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?db\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
operator|-
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?da\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?ib\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
comment|/* Fall through */
default|default:
name|otherops
index|[
literal|0
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|VOIDmode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"str%?\t%1, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"str%?\t%1, %0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Constraints should prevent this.  */
name|abort
argument_list|()
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output an arbitrary MOV reg, #n.    OPERANDS[0] is a register.  OPERANDS[1] is a const_int.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_immediate
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|n
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
comment|/* Try to use one MOV.  */
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|n
argument_list|)
condition|)
name|output_asm_insn
argument_list|(
literal|"mov%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
comment|/* Try to use one MVN.  */
elseif|else
if|if
condition|(
name|const_ok_for_arm
argument_list|(
operator|~
name|n
argument_list|)
condition|)
block|{
name|operands
index|[
literal|1
index|]
operator|=
name|GEN_INT
argument_list|(
operator|~
name|n
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mvn%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|n_ones
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If all else fails, make it out of ORRs or BICs as appropriate.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|n
operator|&
literal|1
operator|<<
name|i
condition|)
name|n_ones
operator|++
expr_stmt|;
if|if
condition|(
name|n_ones
operator|>
literal|16
condition|)
comment|/* Shorter to use MVN with BIC in this case.  */
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"mvn%?\t%0, %1"
argument_list|,
literal|"bic%?\t%0, %0, %1"
argument_list|,
literal|1
argument_list|,
operator|~
name|n
argument_list|)
expr_stmt|;
else|else
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"mov%?\t%0, %1"
argument_list|,
literal|"orr%?\t%0, %0, %1"
argument_list|,
literal|1
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output an ADD r, s, #n where n may be too big for one instruction.    If adding zero to one register, output nothing.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_add_immediate
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|n
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
operator|||
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"sub%?\t%0, %1, %2"
argument_list|,
literal|"sub%?\t%0, %0, %2"
argument_list|,
literal|2
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
else|else
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"add%?\t%0, %1, %2"
argument_list|,
literal|"add%?\t%0, %0, %2"
argument_list|,
literal|2
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a multiple immediate operation.    OPERANDS is the vector of operands referred to in the output patterns.    INSTR1 is the output pattern to use for the first constant.    INSTR2 is the output pattern to use for subsequent constants.    IMMED_OP is the index of the constant slot in OPERANDS.    N is the constant value.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|output_multi_immediate
parameter_list|(
name|operands
parameter_list|,
name|instr1
parameter_list|,
name|instr2
parameter_list|,
name|immed_op
parameter_list|,
name|n
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
specifier|const
name|char
modifier|*
name|instr1
decl_stmt|;
specifier|const
name|char
modifier|*
name|instr2
decl_stmt|;
name|int
name|immed_op
decl_stmt|;
name|HOST_WIDE_INT
name|n
decl_stmt|;
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|32
name|n
operator|&=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* Quick and easy output.  */
name|operands
index|[
name|immed_op
index|]
operator|=
name|const0_rtx
expr_stmt|;
name|output_asm_insn
argument_list|(
name|instr1
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|instr
init|=
name|instr1
decl_stmt|;
comment|/* Note that n is never zero here (which would give no output).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|n
operator|&
operator|(
literal|3
operator|<<
name|i
operator|)
condition|)
block|{
name|operands
index|[
name|immed_op
index|]
operator|=
name|GEN_INT
argument_list|(
name|n
operator|&
operator|(
literal|255
operator|<<
name|i
operator|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|instr
operator|=
name|instr2
expr_stmt|;
name|i
operator|+=
literal|6
expr_stmt|;
block|}
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Return the appropriate ARM instruction for the operation code.    The returned result should not be overwritten.  OP is the rtx of the    operation.  SHIFT_FIRST_ARG is TRUE if the first argument of the operator    was shifted.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|arithmetic_instr
parameter_list|(
name|op
parameter_list|,
name|shift_first_arg
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|int
name|shift_first_arg
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
return|return
literal|"add"
return|;
case|case
name|MINUS
case|:
return|return
name|shift_first_arg
condition|?
literal|"rsb"
else|:
literal|"sub"
return|;
case|case
name|IOR
case|:
return|return
literal|"orr"
return|;
case|case
name|XOR
case|:
return|return
literal|"eor"
return|;
case|case
name|AND
case|:
return|return
literal|"and"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Ensure valid constant shifts and return the appropriate shift mnemonic    for the operation code.  The returned result should not be overwritten.    OP is the rtx code of the shift.    On exit, *AMOUNTP will be -1 if the shift is by a register, or a constant    shift.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|shift_op
parameter_list|(
name|op
parameter_list|,
name|amountp
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|HOST_WIDE_INT
modifier|*
name|amountp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|mnem
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
operator|*
name|amountp
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
operator|*
name|amountp
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ASHIFT
case|:
name|mnem
operator|=
literal|"asl"
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
name|mnem
operator|=
literal|"asr"
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
name|mnem
operator|=
literal|"lsr"
expr_stmt|;
break|break;
case|case
name|ROTATERT
case|:
name|mnem
operator|=
literal|"ror"
expr_stmt|;
break|break;
case|case
name|MULT
case|:
comment|/* We never have to worry about the amount being other than a 	 power of 2, since this case can never be reloaded from a reg.  */
if|if
condition|(
operator|*
name|amountp
operator|!=
operator|-
literal|1
condition|)
operator|*
name|amountp
operator|=
name|int_log2
argument_list|(
operator|*
name|amountp
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
literal|"asl"
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|amountp
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* This is not 100% correct, but follows from the desire to merge 	 multiplication by a power of 2 with the recognizer for a 	 shift.>=32 is not a valid shift for "asl", so we must try and 	 output a shift that produces the correct arithmetical result. 	 Using lsr #32 is identical except for the fact that the carry bit 	 is not set correctly if we set the flags; but we never use the  	 carry bit from such an operation, so we can ignore that.  */
if|if
condition|(
name|code
operator|==
name|ROTATERT
condition|)
comment|/* Rotate is just modulo 32.  */
operator|*
name|amountp
operator|&=
literal|31
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|amountp
operator|!=
operator|(
operator|*
name|amountp
operator|&
literal|31
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|ASHIFT
condition|)
name|mnem
operator|=
literal|"lsr"
expr_stmt|;
operator|*
name|amountp
operator|=
literal|32
expr_stmt|;
block|}
comment|/* Shifts of 0 are no-ops.  */
if|if
condition|(
operator|*
name|amountp
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|mnem
return|;
block|}
end_function

begin_comment
comment|/* Obtain the shift from the POWER of two.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|int_log2
parameter_list|(
name|power
parameter_list|)
name|HOST_WIDE_INT
name|power
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|shift
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|shift
operator|)
operator|&
name|power
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|shift
operator|>
literal|31
condition|)
name|abort
argument_list|()
expr_stmt|;
name|shift
operator|++
expr_stmt|;
block|}
return|return
name|shift
return|;
block|}
end_function

begin_comment
comment|/* Output a .ascii pseudo-op, keeping track of lengths.  This is because    /bin/as is horribly restrictive.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ASCII_LEN
value|51
end_define

begin_function
name|void
name|output_ascii_pseudo_op
parameter_list|(
name|stream
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|len_so_far
init|=
literal|0
decl_stmt|;
name|fputs
argument_list|(
literal|"\t.ascii\t\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|len_so_far
operator|>=
name|MAX_ASCII_LEN
condition|)
block|{
name|fputs
argument_list|(
literal|"\"\n\t.ascii\t\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TARGET_TAB
case|:
name|fputs
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TARGET_FF
case|:
name|fputs
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TARGET_BS
case|:
name|fputs
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TARGET_CR
case|:
name|fputs
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|TARGET_NEWLINE
case|:
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|c
operator|=
name|p
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
operator|)
operator|||
name|c
operator|==
name|TARGET_TAB
condition|)
comment|/* This is a good place for a line break.  */
name|len_so_far
operator|=
name|MAX_ASCII_LEN
expr_stmt|;
else|else
name|len_so_far
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\\'
case|:
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|++
expr_stmt|;
comment|/* drop through.  */
default|default:
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
condition|)
block|{
name|putc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
block|}
block|}
name|fputs
argument_list|(
literal|"\"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the register sabe mask for registers 0 through 12    inclusive.  This code is used by both arm_compute_save_reg_mask    and arm_compute_initial_elimination_offset.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_compute_save_reg0_reg12_mask
parameter_list|()
block|{
name|unsigned
name|long
name|func_type
init|=
name|arm_current_func_type
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|save_reg_mask
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|max_reg
decl_stmt|;
comment|/* Interrupt functions must not corrupt any registers, 	 even call clobbered ones.  If this is a leaf function 	 we can just examine the registers used by the RTL, but 	 otherwise we have to assume that whatever function is 	 called might clobber anything, and so we have to save 	 all the call-clobbered registers as well.  */
if|if
condition|(
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_FIQ
condition|)
comment|/* FIQ handlers have registers r8 - r12 banked, so 	   we only need to check r0 - r7, Normal ISRs only 	   bank r14 and r15, so we must check up to r12. 	   r13 is the stack pointer which is always preserved, 	   so we do not need to consider it here.  */
name|max_reg
operator|=
literal|7
expr_stmt|;
else|else
name|max_reg
operator|=
literal|12
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
name|max_reg
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|||
operator|(
operator|!
name|current_function_is_leaf
operator|&&
name|call_used_regs
index|[
name|reg
index|]
operator|)
condition|)
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* In the normal case we only need to save those registers 	 which are call saved and which are used by this function.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
literal|10
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
comment|/* Handle the frame pointer as a special case.  */
if|if
condition|(
operator|!
name|TARGET_APCS_FRAME
operator|&&
operator|!
name|frame_pointer_needed
operator|&&
name|regs_ever_live
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
condition|)
name|save_reg_mask
operator||=
literal|1
operator|<<
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
comment|/* If we aren't loading the PIC register, 	 don't stack it even though it may be live.  */
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|TARGET_SINGLE_PIC_BASE
operator|&&
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|save_reg_mask
operator||=
literal|1
operator|<<
name|PIC_OFFSET_TABLE_REGNUM
expr_stmt|;
block|}
return|return
name|save_reg_mask
return|;
block|}
end_function

begin_comment
comment|/* Compute a bit mask of which registers need to be    saved on the stack for the current function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_compute_save_reg_mask
parameter_list|()
block|{
name|unsigned
name|int
name|save_reg_mask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|func_type
init|=
name|arm_current_func_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
comment|/* This should never really happen.  */
return|return
literal|0
return|;
comment|/* If we are creating a stack frame, then we must save the frame pointer,      IP (which will hold the old stack pointer), LR and the PC.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
name|ARM_HARD_FRAME_POINTER_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
expr_stmt|;
comment|/* Volatile functions do not return, so there      is no need to save any other registers.  */
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
return|return
name|save_reg_mask
return|;
name|save_reg_mask
operator||=
name|arm_compute_save_reg0_reg12_mask
argument_list|()
expr_stmt|;
comment|/* Decide if we need to save the link register.      Interrupt routines have their own banked link register,      so they never need to save it.      Otheriwse if we do not use the link register we do not need to save      it.  If we are pushing other registers onto the stack however, we      can save an instruction in the epilogue by pushing the link register      now and then popping it back into the PC.  This incurs extra memory      accesses though, so we only do it when optimising for size, and only      if we know that we will not need a fancy return sequence.  */
if|if
condition|(
operator|!
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
operator|&&
operator|(
name|regs_ever_live
index|[
name|LR_REGNUM
index|]
operator|||
operator|(
name|save_reg_mask
operator|&&
name|optimize_size
operator|&&
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_NORMAL
operator|)
operator|)
condition|)
name|save_reg_mask
operator||=
literal|1
operator|<<
name|LR_REGNUM
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
condition|)
name|save_reg_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
return|return
name|save_reg_mask
return|;
block|}
end_function

begin_comment
comment|/* Generate a function exit sequence.  If REALLY_RETURN is true, then do    everything bar the final return instruction.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_return_instruction
parameter_list|(
name|operand
parameter_list|,
name|really_return
parameter_list|,
name|reverse
parameter_list|)
name|rtx
name|operand
decl_stmt|;
name|int
name|really_return
decl_stmt|;
name|int
name|reverse
decl_stmt|;
block|{
name|char
name|conditional
index|[
literal|10
index|]
decl_stmt|;
name|char
name|instr
index|[
literal|100
index|]
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|unsigned
name|long
name|live_regs_mask
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
operator|&&
name|TARGET_ABORT_NORETURN
condition|)
block|{
comment|/* If this function was declared non-returning, and we have found a tail  	 call, then we have to trust that the called function won't return.  */
if|if
condition|(
name|really_return
condition|)
block|{
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
comment|/* Otherwise, trap an attempted return by aborting.  */
name|ops
index|[
literal|0
index|]
operator|=
name|operand
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|NEED_PLT_RELOC
condition|?
literal|"abort(PLT)"
else|:
literal|"abort"
argument_list|)
expr_stmt|;
name|assemble_external_libcall
argument_list|(
name|ops
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|reverse
condition|?
literal|"bl%D0\t%a1"
else|:
literal|"bl%d0\t%a1"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
if|if
condition|(
name|current_function_calls_alloca
operator|&&
operator|!
name|really_return
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Construct the conditional part of the instruction(s) to be emitted.  */
name|sprintf
argument_list|(
name|conditional
argument_list|,
literal|"%%?%%%c0"
argument_list|,
name|reverse
condition|?
literal|'D'
else|:
literal|'d'
argument_list|)
expr_stmt|;
name|return_used_this_function
operator|=
literal|1
expr_stmt|;
name|live_regs_mask
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
comment|/* On some ARM architectures it is faster to use LDR rather than LDM to      load a single register.  On other architectures, the cost is the same.      In 26 bit mode we have to use LDM in order to be able to restore the CPSR.  */
if|if
condition|(
operator|(
name|live_regs_mask
operator|==
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|&&
operator|!
name|TARGET_INTERWORK
operator|&&
operator|!
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
operator|&&
operator|(
operator|!
name|really_return
operator|||
name|TARGET_APCS_32
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|really_return
condition|)
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldr%s\t%%|lr, [%%|sp], #4"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldr%s\t%%|pc, [%%|sp], #4"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|live_regs_mask
condition|)
block|{
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
operator|)
operator|==
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
condition|)
comment|/* There are two possible reasons for the IP register being saved. 	   Either a stack frame was created, in which case IP contains the 	   old stack pointer, or an ISR routine corrupted it.  If this in an 	   ISR routine then just restore IP, otherwise restore IP into SP.  */
if|if
condition|(
operator|!
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
name|live_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
expr_stmt|;
name|live_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
expr_stmt|;
block|}
comment|/* Generate the load multiple instruction to restore the registers.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldm%sea\t%%|fp, {"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldm%sfd\t%%|sp!, {"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
name|SP_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
condition|)
block|{
name|strcat
argument_list|(
name|instr
argument_list|,
literal|"%|"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|instr
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|instr
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* If we are not restoring the LR register then we will 	     have added one too many commas to the list above. 	     Replace it with a closing brace.  */
name|instr
index|[
name|strlen
argument_list|(
name|instr
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'}'
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|instr
argument_list|,
literal|"%|"
argument_list|)
expr_stmt|;
comment|/* At this point there should only be one or two registers left in 	     live_regs_mask: always LR, and possibly PC if we created a stack 	     frame.  LR contains the return address.  If we do not have any 	     special requirements for function exit (eg interworking, or ISR) 	     then we can load this value directly into the PC and save an 	     instruction.  */
if|if
condition|(
operator|!
name|TARGET_INTERWORK
operator|&&
operator|!
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
operator|&&
name|really_return
condition|)
name|strcat
argument_list|(
name|instr
argument_list|,
name|reg_names
index|[
name|PC_REGNUM
index|]
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|instr
argument_list|,
name|reg_names
index|[
name|LR_REGNUM
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|instr
argument_list|,
operator|(
name|TARGET_APCS_32
operator|||
operator|!
name|really_return
operator|)
condition|?
literal|"}"
else|:
literal|"}^"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|really_return
condition|)
block|{
comment|/* See if we need to generate an extra instruction to 	     perform the actual function return.  */
switch|switch
condition|(
operator|(
name|int
operator|)
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
case|case
name|ARM_FT_ISR
case|:
case|case
name|ARM_FT_FIQ
case|:
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
operator|&
name|operand
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|instr
argument_list|,
literal|"sub"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|instr
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|instr
argument_list|,
literal|"s\t%|pc, %|lr, #4"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION
case|:
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
operator|&
name|operand
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|instr
argument_list|,
literal|"mov"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|instr
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|instr
argument_list|,
literal|"s\t%|pc, %|lr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_INTERWORKED
case|:
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
operator|&
name|operand
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|instr
argument_list|,
literal|"bx"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|instr
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|instr
argument_list|,
literal|"\t%|lr"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* The return has already been handled 		 by loading the LR into the PC.  */
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
operator|&
name|operand
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|instr
argument_list|,
literal|"mov"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|instr
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TARGET_APCS_32
condition|)
name|strcat
argument_list|(
name|instr
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|instr
argument_list|,
literal|"\t%|pc, %|lr"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|really_return
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
case|case
name|ARM_FT_ISR
case|:
case|case
name|ARM_FT_FIQ
case|:
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"sub%ss\t%%|pc, %%|lr, #4"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_INTERWORKED
case|:
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"bx%s\t%%|lr"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION
case|:
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"mov%ss\t%%|pc, %%|lr"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"mov%s%s\t%%|pc, %%|lr"
argument_list|,
name|conditional
argument_list|,
name|TARGET_APCS_32
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* Nothing to load off the stack, and        no return instruction to generate.  */
return|return
literal|""
return|;
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
operator|&
name|operand
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Write the function name into the code section, directly preceding    the function prologue.     Code will be output similar to this:      t0 	 .ascii "arm_poke_function_name", 0 	 .align      t1 	 .word 0xff000000 + (t1 - t0)      arm_poke_function_name 	 mov     ip, sp 	 stmfd   sp!, {fp, ip, lr, pc} 	 sub     fp, ip, #4     When performing a stack backtrace, code can inspect the value    of 'pc' stored at 'fp' + 0.  If the trace function then looks    at location pc - 12 and the top 8 bits are set, then we know    that there is a function name embedded immediately preceding this    location and has length ((pc[-3])& 0xff000000).     We assume that pc is declared as a pointer to an unsigned long.     It is of no benefit to output the function name if we are assembling    a leaf function.  These function types will not contain a stack    backtrace structure, therefore it is not possible to determine the    function name.  */
end_comment

begin_function
name|void
name|arm_poke_function_name
parameter_list|(
name|stream
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|long
name|alignlength
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|alignlength
operator|=
name|ROUND_UP
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ASCII
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|stream
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|x
operator|=
name|GEN_INT
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xff000000
operator|+
name|alignlength
argument_list|)
expr_stmt|;
name|assemble_aligned_integer
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place some comments into the assembler stream    describing the current function.  */
end_comment

begin_function
specifier|static
name|void
name|arm_output_function_prologue
parameter_list|(
name|f
parameter_list|,
name|frame_size
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
block|{
name|unsigned
name|long
name|func_type
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_ARM
condition|)
block|{
name|thumb_output_function_prologue
argument_list|(
name|f
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Sanity check.  */
if|if
condition|(
name|arm_ccfsm_state
operator|||
name|arm_target_insn
condition|)
name|abort
argument_list|()
expr_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
default|default:
case|case
name|ARM_FT_NORMAL
case|:
break|break;
case|case
name|ARM_FT_INTERWORKED
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Function supports interworking.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION_HANDLER
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ C++ Exception Handler.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_ISR
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Interrupt Service Routine.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_FIQ
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Fast Interrupt Service Routine.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ ARM Exception Handler.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Naked Function: prologue and epilogue provided by programmer.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Volatile: function does not return.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_NESTED
argument_list|(
name|func_type
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Nested: function declared inside another function.\n"
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ args = %d, pretend = %d, frame = %d\n"
argument_list|,
name|current_function_args_size
argument_list|,
name|current_function_pretend_args_size
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ frame_needed = %d, current_function_anonymous_args = %d\n"
argument_list|,
name|frame_pointer_needed
argument_list|,
name|current_function_anonymous_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ link register save eliminated.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
if|if
condition|(
name|flag_pic
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|return_used_this_function
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|arm_output_epilogue
parameter_list|(
name|really_return
parameter_list|)
name|int
name|really_return
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
name|unsigned
name|long
name|saved_regs_mask
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
comment|/* If we need this, then it will always be at least this much.  */
name|int
name|floats_offset
init|=
literal|12
decl_stmt|;
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|int
name|frame_size
init|=
name|get_frame_size
argument_list|()
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|asm_out_file
decl_stmt|;
name|rtx
name|eh_ofs
init|=
name|cfun
operator|->
name|machine
operator|->
name|eh_epilogue_sp_ofs
decl_stmt|;
comment|/* If we have already generated the return instruction      then it is futile to generate anything else.  */
if|if
condition|(
name|use_return_insn
argument_list|(
name|FALSE
argument_list|)
operator|&&
name|return_used_this_function
condition|)
return|return
literal|""
return|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
comment|/* Naked functions don't have epilogues.  */
return|return
literal|""
return|;
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
operator|&&
name|TARGET_ABORT_NORETURN
condition|)
block|{
name|rtx
name|op
decl_stmt|;
comment|/* A volatile function should never return.  Call abort.  */
name|op
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|NEED_PLT_RELOC
condition|?
literal|"abort(PLT)"
else|:
literal|"abort"
argument_list|)
expr_stmt|;
name|assemble_external_libcall
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bl\t%a0"
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
if|if
condition|(
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_EXCEPTION_HANDLER
operator|&&
operator|!
name|really_return
condition|)
comment|/* If we are throwing an exception, then we really must        be doing a return,  so we can't tail-call.  */
name|abort
argument_list|()
expr_stmt|;
name|saved_regs_mask
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
comment|/* Compute how far away the floats will be.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
condition|)
name|floats_offset
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|arm_fpu_arch
operator|==
name|FP_SOFT2
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|LAST_ARM_FP_REGNUM
init|;
name|reg
operator|>=
name|FIRST_ARM_FP_REGNUM
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|floats_offset
operator|+=
literal|12
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tldfe\t%r, [%r, #-%d]\n"
argument_list|,
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|start_reg
init|=
name|LAST_ARM_FP_REGNUM
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|LAST_ARM_FP_REGNUM
init|;
name|reg
operator|>=
name|FIRST_ARM_FP_REGNUM
condition|;
name|reg
operator|--
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|floats_offset
operator|+=
literal|12
expr_stmt|;
comment|/* We can't unstack more than four registers at once.  */
if|if
condition|(
name|start_reg
operator|-
name|reg
operator|==
literal|3
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfm\t%r, 4, [%r, #-%d]\n"
argument_list|,
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfm\t%r, %d, [%r, #-%d]\n"
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Just in case the last register checked also needs unstacking.  */
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfm\t%r, %d, [%r, #-%d]\n"
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
argument_list|)
expr_stmt|;
block|}
comment|/* saved_regs_mask should contain the IP, which at the time of stack 	 frame generation actually contains the old stack pointer.  So a 	 quick way to unwind the stack is just pop the IP register directly 	 into the stack pointer.  */
if|if
condition|(
operator|(
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
expr_stmt|;
name|saved_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
expr_stmt|;
comment|/* There are two registers left in saved_regs_mask - LR and PC.  We 	 only need to restore the LR register (the return address), but to 	 save time we can load it directly into the PC, unless we need a 	 special function exit sequence, or we are not really returning.  */
if|if
condition|(
name|really_return
operator|&&
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_NORMAL
condition|)
comment|/* Delete the LR from the register mask, so that the LR on 	   the stack is loaded into the PC in the register mask.  */
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
else|else
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
expr_stmt|;
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmea\t%r"
argument_list|,
name|FP_REGNUM
argument_list|,
name|saved_regs_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
comment|/* Interrupt handlers will have pushed the 	   IP onto the stack, so restore it now.  */
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\t%r"
argument_list|,
name|SP_REGNUM
argument_list|,
literal|1
operator|<<
name|IP_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Restore stack pointer if necessary.  */
if|if
condition|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
operator|!=
literal|0
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
argument_list|)
expr_stmt|;
name|output_add_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arm_fpu_arch
operator|==
name|FP_SOFT2
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|FIRST_ARM_FP_REGNUM
init|;
name|reg
operator|<=
name|LAST_ARM_FP_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tldfe\t%r, [%r], #12\n"
argument_list|,
name|reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|start_reg
init|=
name|FIRST_ARM_FP_REGNUM
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|FIRST_ARM_FP_REGNUM
init|;
name|reg
operator|<=
name|LAST_ARM_FP_REGNUM
condition|;
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
if|if
condition|(
name|reg
operator|-
name|start_reg
operator|==
literal|3
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfmfd\t%r, 4, [%r]!\n"
argument_list|,
name|start_reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfmfd\t%r, %d, [%r]!\n"
argument_list|,
name|start_reg
argument_list|,
name|reg
operator|-
name|start_reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Just in case the last register checked also needs unstacking.  */
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfmfd\t%r, %d, [%r]!\n"
argument_list|,
name|start_reg
argument_list|,
name|reg
operator|-
name|start_reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
comment|/* If we can, restore the LR into the PC.  */
if|if
condition|(
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_NORMAL
operator|&&
name|really_return
operator|&&
name|current_function_pretend_args_size
operator|==
literal|0
operator|&&
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
condition|)
block|{
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
name|saved_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
expr_stmt|;
block|}
comment|/* Load the registers off the stack.  If we only have one register 	 to load use the LDR instruction - it is faster.  */
if|if
condition|(
name|saved_regs_mask
operator|==
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
condition|)
block|{
comment|/* The excpetion handler ignores the LR, so we do 	     not really need to load it off the stack.  */
if|if
condition|(
name|eh_ofs
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r, #4\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
else|else
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tldr\t%r, [%r], #4\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|saved_regs_mask
condition|)
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\t%r!"
argument_list|,
name|SP_REGNUM
argument_list|,
name|saved_regs_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_pretend_args_size
condition|)
block|{
comment|/* Unwind the pre-pushed regs.  */
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
name|output_add_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|if (ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER)
comment|/* Adjust the stack to remove the exception handler stuff.  */
block|asm_fprintf (f, "\tadd\t%r, %r, %r\n", SP_REGNUM, SP_REGNUM, 		 REGNO (eh_ofs));
endif|#
directive|endif
if|if
condition|(
operator|!
name|really_return
condition|)
return|return
literal|""
return|;
comment|/* Generate the return instruction.  */
switch|switch
condition|(
operator|(
name|int
operator|)
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
case|case
name|ARM_FT_EXCEPTION_HANDLER
case|:
comment|/* Even in 26-bit mode we do a mov (rather than a movs) 	 because we don't have the PSR bits set in the address.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|EXCEPTION_LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_ISR
case|:
case|case
name|ARM_FT_FIQ
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsubs\t%r, %r, #4\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmovs\t%r, %r\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_INTERWORKED
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|frame_pointer_needed
condition|)
comment|/* If we used the frame pointer then the return adddress 	   will have been loaded off the stack directly into the 	   PC, so there is no need to issue a MOV instruction 	   here.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|current_function_pretend_args_size
operator|==
literal|0
operator|&&
operator|(
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
condition|)
comment|/* Similarly we may have been able to load LR into the PC 	   even if we did not create a stack frame.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TARGET_APCS_32
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
else|else
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmovs\t%r, %r\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_output_function_epilogue
parameter_list|(
name|file
parameter_list|,
name|frame_size
parameter_list|)
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
comment|/* ??? Probably not safe to set this here, since it assumes that a 	 function will be emitted as assembly immediately after we generate 	 RTL for it.  This does not happen for inline functions.  */
name|return_used_this_function
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|use_return_insn
argument_list|(
name|FALSE
argument_list|)
operator|&&
name|return_used_this_function
operator|&&
operator|(
name|frame_size
operator|+
name|current_function_outgoing_args_size
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|frame_pointer_needed
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Reset the ARM-specific per-function variables.  */
name|current_function_anonymous_args
operator|=
literal|0
expr_stmt|;
name|after_arm_reorg
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate and emit an insn that we will recognize as a push_multi.    Unfortunately, since this insn does not reflect very well the actual    semantics of the operation, we need to annotate the insn for the benefit    of DWARF2 frame unwind information.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_multi_reg_push
parameter_list|(
name|mask
parameter_list|)
name|int
name|mask
decl_stmt|;
block|{
name|int
name|num_regs
init|=
literal|0
decl_stmt|;
name|int
name|num_dwarf_regs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|par
decl_stmt|;
name|rtx
name|dwarf
decl_stmt|;
name|int
name|dwarf_par_index
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|reg
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|num_regs
operator|++
expr_stmt|;
if|if
condition|(
name|num_regs
operator|==
literal|0
operator|||
name|num_regs
operator|>
literal|16
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We don't record the PC in the dwarf frame information.  */
name|num_dwarf_regs
operator|=
name|num_regs
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
condition|)
name|num_dwarf_regs
operator|--
expr_stmt|;
comment|/* For the body of the insn we are going to generate an UNSPEC in      parallel with several USEs.  This allows the insn to be recognised      by the push_multi pattern in the arm.md file.  The insn looks      something like this:         (parallel [             (set (mem:BLK (pre_dec:BLK (reg:SI sp))) 	        (unspec:BLK [(reg:SI r4)] UNSPEC_PUSH_MULT))            (use (reg:SI 11 fp))            (use (reg:SI 12 ip))            (use (reg:SI 14 lr))            (use (reg:SI 15 pc))         ])       For the frame note however, we try to be more explicit and actually      show each register being stored into the stack frame, plus a (single)      decrement of the stack pointer.  We do it this way in order to be      friendly to the stack unwinding code, which only wants to see a single      stack decrement per instruction.  The RTL we generate for the note looks      something like this:        (sequence [             (set (reg:SI sp) (plus:SI (reg:SI sp) (const_int -20)))            (set (mem:SI (reg:SI sp)) (reg:SI r4))            (set (mem:SI (plus:SI (reg:SI sp) (const_int 4))) (reg:SI fp))            (set (mem:SI (plus:SI (reg:SI sp) (const_int 8))) (reg:SI ip))            (set (mem:SI (plus:SI (reg:SI sp) (const_int 12))) (reg:SI lr))         ])        This sequence is used both by the code to support stack unwinding for       exceptions handlers and the code to generate dwarf2 frame debugging.  */
name|par
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num_regs
argument_list|)
argument_list|)
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_SEQUENCE
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num_dwarf_regs
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|dwarf
argument_list|)
operator|=
literal|1
expr_stmt|;
name|dwarf_par_index
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|BLKmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
argument_list|,
name|UNSPEC_PUSH_MULT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|PC_REGNUM
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|dwarf_par_index
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|dwarf_par_index
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|i
operator|++
init|;
name|j
operator|<
name|num_regs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|PC_REGNUM
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|4
operator|*
name|j
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|dwarf_par_index
operator|++
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
block|}
block|}
name|par
operator|=
name|emit_insn
argument_list|(
name|par
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|4
operator|*
name|num_regs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|REG_NOTES
argument_list|(
name|par
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|par
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|par
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|emit_sfm
parameter_list|(
name|base_reg
parameter_list|,
name|count
parameter_list|)
name|int
name|base_reg
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|rtx
name|par
decl_stmt|;
name|rtx
name|dwarf
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|par
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|dwarf
argument_list|)
operator|=
literal|1
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|base_reg
operator|++
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|BLKmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
argument_list|,
name|UNSPEC_PUSH_MULT
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|XFmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|BLKmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|count
operator|-
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|base_reg
operator|++
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|XFmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|BLKmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|count
operator|-
name|i
operator|-
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
name|par
operator|=
name|emit_insn
argument_list|(
name|par
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|par
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|par
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|par
return|;
block|}
end_function

begin_comment
comment|/* Compute the distance from register FROM to register TO.    These can be the arg pointer (26), the soft frame pointer (25),    the stack pointer (13) or the hard frame pointer (11).    Typical stack layout looks like this:         old stack pointer -> |    |                              ----                             |    | \                             |    |   saved arguments for                             |    |   vararg functions 			    |    | /                               --    hard FP& arg pointer -> |    | \                             |    |   stack                             |    |   frame                             |    | /                               --                             |    | \                             |    |   call saved                             |    |   registers       soft frame pointer -> |    | /                               --                             |    | \                             |    |   local                             |    |   variables                             |    | /                               --                             |    | \                             |    |   outgoing                             |    |   arguments    current stack pointer -> |    | /                               --    For a given funciton some or all of these stack compomnents   may not be needed, giving rise to the possibility of   eliminating some of the registers.    The values returned by this function must reflect the behaviour   of arm_expand_prologue() and arm_compute_save_reg_mask().    The sign of the number returned reflects the direction of stack   growth, so the values are positive for all eliminations except   from the soft frame pointer to the hard frame pointer.  */
end_comment

begin_function
name|unsigned
name|int
name|arm_compute_initial_elimination_offset
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|unsigned
name|int
name|from
decl_stmt|;
name|unsigned
name|int
name|to
decl_stmt|;
block|{
name|unsigned
name|int
name|local_vars
init|=
operator|(
name|get_frame_size
argument_list|()
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
decl_stmt|;
name|unsigned
name|int
name|outgoing_args
init|=
name|current_function_outgoing_args_size
decl_stmt|;
name|unsigned
name|int
name|stack_frame
decl_stmt|;
name|unsigned
name|int
name|call_saved_registers
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
comment|/* Volatile functions never return, so there is      no need to save call saved registers.  */
name|call_saved_registers
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|reg_mask
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
comment|/* Make sure that we compute which registers will be saved 	 on the stack using the same algorithm that is used by 	 arm_compute_save_reg_mask().  */
name|reg_mask
operator|=
name|arm_compute_save_reg0_reg12_mask
argument_list|()
expr_stmt|;
comment|/* Now count the number of bits set in save_reg_mask. 	 For each set bit we need 4 bytes of stack space.  */
while|while
condition|(
name|reg_mask
condition|)
block|{
name|call_saved_registers
operator|+=
literal|4
expr_stmt|;
name|reg_mask
operator|=
name|reg_mask
operator|&
operator|~
operator|(
name|reg_mask
operator|&
operator|-
name|reg_mask
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|regs_ever_live
index|[
name|LR_REGNUM
index|]
comment|/* If a stack frame is going to be created, the LR will 	     be saved as part of that, so we do not need to allow 	     for it here.  */
operator|&&
operator|!
name|frame_pointer_needed
condition|)
name|call_saved_registers
operator|+=
literal|4
expr_stmt|;
comment|/* If the hard floating point registers are going to be 	 used then they must be saved on the stack as well.          Each register occupies 12 bytes of stack space.  */
for|for
control|(
name|reg
operator|=
name|FIRST_ARM_FP_REGNUM
init|;
name|reg
operator|<=
name|LAST_ARM_FP_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|call_saved_registers
operator|+=
literal|12
expr_stmt|;
block|}
comment|/* The stack frame contains 4 registers - the old frame pointer,      the old stack pointer, the return address and PC of the start      of the function.  */
name|stack_frame
operator|=
name|frame_pointer_needed
condition|?
literal|16
else|:
literal|0
expr_stmt|;
comment|/* OK, now we have enough information to compute the distances.      There must be an entry in these switch tables for each pair      of registers in ELIMINABLE_REGS, even if some of the entries      seem to be redundant or useless.  */
switch|switch
condition|(
name|from
condition|)
block|{
case|case
name|ARG_POINTER_REGNUM
case|:
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|THUMB_HARD_FRAME_POINTER_REGNUM
case|:
return|return
literal|0
return|;
case|case
name|FRAME_POINTER_REGNUM
case|:
comment|/* This is the reverse of the soft frame pointer 	     to hard frame pointer elimination below.  */
if|if
condition|(
name|call_saved_registers
operator|==
literal|0
operator|&&
name|stack_frame
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|call_saved_registers
operator|+
name|stack_frame
operator|-
literal|4
operator|)
return|;
case|case
name|ARM_HARD_FRAME_POINTER_REGNUM
case|:
comment|/* If there is no stack frame then the hard 	     frame pointer and the arg pointer coincide.  */
if|if
condition|(
name|stack_frame
operator|==
literal|0
operator|&&
name|call_saved_registers
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */
return|return
operator|(
name|frame_pointer_needed
operator|&&
name|current_function_needs_context
operator|&&
operator|!
name|current_function_anonymous_args
operator|)
condition|?
literal|4
else|:
literal|0
return|;
case|case
name|STACK_POINTER_REGNUM
case|:
comment|/* If nothing has been pushed on the stack at all 	     then this will return -4.  This *is* correct!  */
return|return
name|call_saved_registers
operator|+
name|stack_frame
operator|+
name|local_vars
operator|+
name|outgoing_args
operator|-
literal|4
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|FRAME_POINTER_REGNUM
case|:
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|THUMB_HARD_FRAME_POINTER_REGNUM
case|:
return|return
literal|0
return|;
case|case
name|ARM_HARD_FRAME_POINTER_REGNUM
case|:
comment|/* The hard frame pointer points to the top entry in the 	     stack frame.  The soft frame pointer to the bottom entry 	     in the stack frame.  If there is no stack frame at all, 	     then they are identical.  */
if|if
condition|(
name|call_saved_registers
operator|==
literal|0
operator|&&
name|stack_frame
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|-
operator|(
name|call_saved_registers
operator|+
name|stack_frame
operator|-
literal|4
operator|)
return|;
case|case
name|STACK_POINTER_REGNUM
case|:
return|return
name|local_vars
operator|+
name|outgoing_args
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
comment|/* You cannot eliminate from the stack pointer. 	 In theory you could eliminate from the hard frame 	 pointer to the stack pointer, but this will never 	 happen, since if a stack frame is not needed the 	 hard frame pointer will never be used.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the prologue instructions for entry into an ARM function.  */
end_comment

begin_function
name|void
name|arm_expand_prologue
parameter_list|()
block|{
name|int
name|reg
decl_stmt|;
name|rtx
name|amount
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|ip_rtx
decl_stmt|;
name|unsigned
name|long
name|live_regs_mask
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|int
name|fp_offset
init|=
literal|0
decl_stmt|;
name|int
name|saved_pretend_args
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|args_to_push
decl_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
comment|/* Naked functions don't have prologues.  */
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
return|return;
comment|/* Make a copy of c_f_p_a_s as we may need to modify it locally.  */
name|args_to_push
operator|=
name|current_function_pretend_args_size
expr_stmt|;
comment|/* Compute which register we will have to save onto the stack.  */
name|live_regs_mask
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
name|ip_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* Interrupt functions must not corrupt any registers. 	     Creating a frame pointer however, corrupts the IP 	     register, so we must push it first.  */
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
literal|1
operator|<<
name|IP_REGNUM
argument_list|)
expr_stmt|;
comment|/* Do not set RTX_FRAME_RELATED_P on this insn. 	     The dwarf stack unwinding code only wants to see one 	     stack decrement per function, and this is not it.  If 	     this instruction is labeled as being part of the frame 	     creation sequence then dwarf2out_frame_debug_expr will 	     abort when it encounters the assignment of IP to FP 	     later on, since the use of SP here establishes SP as 	     the CFA register and not IP.  	     Anyway this instruction is not really part of the stack 	     frame creation although it is part of the prologue.  */
block|}
elseif|else
if|if
condition|(
name|IS_NESTED
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* The Static chain register is the same as the IP register 	     used as a scratch register during stack frame creation. 	     To get around this need to find somewhere to store IP 	     whilst the frame is being created.  We try the following 	     places in order: 	      	       1. The last argument register. 	       2. A slot on the stack above the frame.  (This only 	          works if the function is not a varargs function). 	       3. Register r3, after pushing the argument registers 	          onto the stack.  	     Note - we only need to tell the dwarf2 backend about the SP 	     adjustment in the second variant; the static chain register 	     doesn't need to be unwound, as it doesn't contain a value 	     inherited from the caller.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|3
index|]
operator|==
literal|0
condition|)
block|{
name|insn
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|insn
argument_list|,
name|ip_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args_to_push
operator|==
literal|0
condition|)
block|{
name|rtx
name|dwarf
decl_stmt|;
name|insn
operator|=
name|gen_rtx_PRE_DEC
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|ip_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fp_offset
operator|=
literal|4
expr_stmt|;
comment|/* Just tell the dwarf backend that we adjusted SP.  */
name|dwarf
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|fp_offset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Store the args on the stack.  */
if|if
condition|(
name|current_function_anonymous_args
condition|)
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
operator|(
literal|0xf0
operator|>>
operator|(
name|args_to_push
operator|/
literal|4
operator|)
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|args_to_push
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|saved_pretend_args
operator|=
literal|1
expr_stmt|;
name|fp_offset
operator|=
name|args_to_push
expr_stmt|;
name|args_to_push
operator|=
literal|0
expr_stmt|;
comment|/* Now reuse r3 to preserve IP.  */
name|insn
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|insn
argument_list|,
name|ip_rtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fp_offset
condition|)
block|{
name|insn
operator|=
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|fp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|ip_rtx
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|insn
operator|=
name|gen_movsi
argument_list|(
name|ip_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|args_to_push
condition|)
block|{
comment|/* Push the argument registers, or reserve space for them.  */
if|if
condition|(
name|current_function_anonymous_args
condition|)
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
operator|(
literal|0xf0
operator|>>
operator|(
name|args_to_push
operator|/
literal|4
operator|)
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|args_to_push
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|live_regs_mask
condition|)
block|{
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
name|live_regs_mask
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* Save any floating point call-saved registers used by this function.  */
if|if
condition|(
name|arm_fpu_arch
operator|==
name|FP_SOFT2
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|LAST_ARM_FP_REGNUM
init|;
name|reg
operator|>=
name|FIRST_ARM_FP_REGNUM
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|insn
operator|=
name|gen_rtx_PRE_DEC
argument_list|(
name|XFmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_MEM
argument_list|(
name|XFmode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|start_reg
init|=
name|LAST_ARM_FP_REGNUM
decl_stmt|;
for|for
control|(
name|reg
operator|=
name|LAST_ARM_FP_REGNUM
init|;
name|reg
operator|>=
name|FIRST_ARM_FP_REGNUM
condition|;
name|reg
operator|--
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
if|if
condition|(
name|start_reg
operator|-
name|reg
operator|==
literal|3
condition|)
block|{
name|insn
operator|=
name|emit_sfm
argument_list|(
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
block|{
name|insn
operator|=
name|emit_sfm
argument_list|(
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
block|{
name|insn
operator|=
name|emit_sfm
argument_list|(
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
comment|/* Create the new frame pointer.  */
name|insn
operator|=
name|GEN_INT
argument_list|(
operator|-
operator|(
literal|4
operator|+
name|args_to_push
operator|+
name|fp_offset
operator|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|ip_rtx
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_NESTED
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* Recover the static chain register.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|3
index|]
operator|==
literal|0
operator|||
name|saved_pretend_args
condition|)
name|insn
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
comment|/* if (current_function_pretend_args_size == 0) */
block|{
name|insn
operator|=
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|SImode
argument_list|,
name|ip_rtx
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add a USE to stop propagate_one_insn() from barfing.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|ip_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|amount
operator|=
name|GEN_INT
argument_list|(
operator|-
operator|(
name|get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|!=
name|const0_rtx
condition|)
block|{
comment|/* This add can produce multiple insns for a large constant, so we 	 need to get tricky.  */
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|amount
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|last
operator|=
name|last
condition|?
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
else|:
name|get_insns
argument_list|()
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|last
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|last
operator|!=
name|insn
condition|)
do|;
comment|/* If the frame pointer is needed, emit a special barrier that 	 will prevent the scheduler from moving stores to the frame 	 before the stack adjustment.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|rtx
name|unspec
init|=
name|gen_rtx_UNSPEC
argument_list|(
name|SImode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|,
name|UNSPEC_PRLG_STK
argument_list|)
decl_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|unspec
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are profiling, make sure no instructions are scheduled before      the call to mcount.  Similarly if the user has requested no      scheduling in the prolog.  */
if|if
condition|(
name|current_function_profile
operator|||
name|TARGET_NO_SCHED_PRO
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If the link register is being kept alive, with the return address in it,      then make sure that it does not get reused by the ce2 pass.  */
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If CODE is 'd', then the X is a condition operand and the instruction    should only be executed if the condition is true.    if CODE is 'D', then the X is a condition operand and the instruction    should only be executed if the condition is false: however, if the mode    of the comparison is CCFPEmode, then always execute the instruction -- we    do this because in these circumstances !GE does not necessarily imply LT;    in these cases the instruction pattern will take care to make sure that    an instruction containing %d will follow, thereby undoing the effects of    doing this instruction unconditionally.    If CODE is 'N' then X is a floating point operand that must be negated    before output.    If CODE is 'B' then output a bitwise inverted value of X (a const int).    If X is a REG and CODE is `M', output a ldm/stm style multi-reg.  */
end_comment

begin_function
name|void
name|arm_print_operand
parameter_list|(
name|stream
parameter_list|,
name|x
parameter_list|,
name|code
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'@'
case|:
name|fputs
argument_list|(
name|ASM_COMMENT_START
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'_'
case|:
name|fputs
argument_list|(
name|user_label_prefix
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'|'
case|:
name|fputs
argument_list|(
name|REGISTER_PREFIX
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'?'
case|:
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|3
operator|||
name|arm_ccfsm_state
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|TARGET_THUMB
operator|||
name|current_insn_predicate
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|arm_current_cc
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_insn_predicate
condition|)
block|{
name|enum
name|arm_cond_code
name|code
decl_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
name|abort
argument_list|()
expr_stmt|;
name|code
operator|=
name|get_arm_condition_code
argument_list|(
name|current_insn_predicate
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|code
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'N'
case|:
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|r
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|fp_const_from_val
argument_list|(
operator|&
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'B'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|val
operator|=
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|'~'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|stream
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'i'
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arithmetic_instr
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arithmetic_instr
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
block|{
name|HOST_WIDE_INT
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|shift
init|=
name|shift_op
argument_list|(
name|x
argument_list|,
operator|&
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|shift
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", %s "
argument_list|,
name|shift_op
argument_list|(
name|x
argument_list|,
operator|&
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|arm_print_operand
argument_list|(
name|stream
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|fputc
argument_list|(
literal|'#'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
comment|/* An explanation of the 'Q', 'R' and 'H' register operands: 	  	 In a pair of registers containing a DI or DF value the 'Q' 	 operand returns the register number of the register containing 	 the least signficant part of the value.  The 'R' operand returns 	 the register number of the register containing the most 	 significant part of the value. 	  	 The 'H' operand returns the higher of the two register numbers. 	 On a run where WORDS_BIG_ENDIAN is true the 'H' operand is the 	 same as the 'Q' operand, since the most signficant part of the 	 value is held in the lower number register.  The reverse is true 	 on systems where WORDS_BIG_ENDIAN is false. 	  	 The purpose of these operands is to distinguish between cases 	 where the endian-ness of the values is important (for example 	 when they are added together), and cases where the endian-ness 	 is irrelevant, but the order of register operations is important. 	 For example when loading a value from memory into a register 	 pair, the endian-ness does not matter.  Provided that the value 	 from the lower memory address is put into the lower numbered 	 register, and the value from the higher address is put into the 	 higher numbered register, the load will work regardless of whether 	 the value being loaded is big-wordian or little-wordian.  The 	 order of the two register loads can matter however, if the address 	 of the memory location is actually held in one of the registers 	 being overwritten by the load.  */
case|case
literal|'Q'
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_ARM_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'R'
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_ARM_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_ARM_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'m'
case|:
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"{%r-%r}"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|NUM_REGS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|x
condition|)
return|return;
if|if
condition|(
name|TARGET_ARM
condition|)
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|get_arm_condition_code
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|thumb_condition_code
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'D'
case|:
if|if
condition|(
operator|!
name|x
condition|)
return|return;
if|if
condition|(
name|TARGET_ARM
condition|)
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|get_arm_condition_code
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|thumb_condition_code
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|output_memory_reference_mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"#%s"
argument_list|,
name|fp_immediate_constant
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NEG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* This should never happen now.  */
else|else
block|{
name|fputc
argument_list|(
literal|'#'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|stream
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
end_ifndef

begin_comment
comment|/* Target hook for assembling integer objects.  The ARM version needs to    handle word-sized values specially.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_assemble_integer
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|,
name|aligned_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|int
name|aligned_p
decl_stmt|;
block|{
if|if
condition|(
name|size
operator|==
name|UNITS_PER_WORD
operator|&&
name|aligned_p
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.word\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Mark symbols as position independent.  We only do this in the 	 .text segment, not in the .data segment. */
if|if
condition|(
name|NEED_GOT_RELOC
operator|&&
name|flag_pic
operator|&&
name|making_const_table
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|)
name|fputs
argument_list|(
literal|"(GOTOFF)"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|fputs
argument_list|(
literal|"(GOTOFF)"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"(GOT)"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* A finite state machine takes care of noticing whether or not instructions    can be conditionally executed, and thus decrease execution time and code    size by deleting branch instructions.  The fsm is controlled by    final_prescan_insn, and controls the actions of ASM_OUTPUT_OPCODE.  */
end_comment

begin_comment
comment|/* The state of the fsm controlling condition codes are:    0: normal, do nothing special    1: make ASM_OUTPUT_OPCODE not output this instruction    2: make ASM_OUTPUT_OPCODE not output this instruction    3: make instructions conditional    4: make instructions conditional     State transitions (state->state by whom under condition):    0 -> 1 final_prescan_insn if the `target' is a label    0 -> 2 final_prescan_insn if the `target' is an unconditional branch    1 -> 3 ASM_OUTPUT_OPCODE after not having output the conditional branch    2 -> 4 ASM_OUTPUT_OPCODE after not having output the conditional branch    3 -> 0 ASM_OUTPUT_INTERNAL_LABEL if the `target' label is reached           (the target label has CODE_LABEL_NUMBER equal to arm_target_label).    4 -> 0 final_prescan_insn if the `target' unconditional branch is reached           (the target insn is arm_target_insn).     If the jump clobbers the conditions then we use states 2 and 4.     A similar thing can be done with conditional return insns.     XXX In case the `target' is an unconditional branch, this conditionalising    of the instructions always reduces code size, but not always execution    time.  But then, I want to reduce the code size to somewhere near what    /bin/cc produces.  */
end_comment

begin_comment
comment|/* Returns the index of the ARM condition code string in    `arm_condition_codes'.  COMPARISON should be an rtx like    `(eq (...) (...))'.  */
end_comment

begin_function
specifier|static
name|enum
name|arm_cond_code
name|get_arm_condition_code
parameter_list|(
name|comparison
parameter_list|)
name|rtx
name|comparison
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
name|enum
name|rtx_code
name|comp_code
init|=
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
name|mode
operator|=
name|SELECT_CC_MODE
argument_list|(
name|comp_code
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|CC_DNEmode
case|:
name|code
operator|=
name|ARM_NE
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DEQmode
case|:
name|code
operator|=
name|ARM_EQ
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGEmode
case|:
name|code
operator|=
name|ARM_GE
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGTmode
case|:
name|code
operator|=
name|ARM_GT
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLEmode
case|:
name|code
operator|=
name|ARM_LE
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLTmode
case|:
name|code
operator|=
name|ARM_LT
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGEUmode
case|:
name|code
operator|=
name|ARM_CS
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGTUmode
case|:
name|code
operator|=
name|ARM_HI
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLEUmode
case|:
name|code
operator|=
name|ARM_LS
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLTUmode
case|:
name|code
operator|=
name|ARM_CC
expr_stmt|;
name|dominance
label|:
if|if
condition|(
name|comp_code
operator|!=
name|EQ
operator|&&
name|comp_code
operator|!=
name|NE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|comp_code
operator|==
name|EQ
condition|)
return|return
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|code
argument_list|)
return|;
return|return
name|code
return|;
case|case
name|CC_NOOVmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|GE
case|:
return|return
name|ARM_PL
return|;
case|case
name|LT
case|:
return|return
name|ARM_MI
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|CC_Zmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|CCFPEmode
case|:
case|case
name|CCFPmode
case|:
comment|/* These encodings assume that AC=1 in the FPA system control 	 byte.  This allows us to handle all cases except UNEQ and 	 LTGT.  */
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|GE
case|:
return|return
name|ARM_GE
return|;
case|case
name|GT
case|:
return|return
name|ARM_GT
return|;
case|case
name|LE
case|:
return|return
name|ARM_LS
return|;
case|case
name|LT
case|:
return|return
name|ARM_MI
return|;
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|ORDERED
case|:
return|return
name|ARM_VC
return|;
case|case
name|UNORDERED
case|:
return|return
name|ARM_VS
return|;
case|case
name|UNLT
case|:
return|return
name|ARM_LT
return|;
case|case
name|UNLE
case|:
return|return
name|ARM_LE
return|;
case|case
name|UNGT
case|:
return|return
name|ARM_HI
return|;
case|case
name|UNGE
case|:
return|return
name|ARM_PL
return|;
comment|/* UNEQ and LTGT do not have a representation.  */
case|case
name|UNEQ
case|:
comment|/* Fall through.  */
case|case
name|LTGT
case|:
comment|/* Fall through.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|CC_SWPmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|GE
case|:
return|return
name|ARM_LE
return|;
case|case
name|GT
case|:
return|return
name|ARM_LT
return|;
case|case
name|LE
case|:
return|return
name|ARM_GE
return|;
case|case
name|LT
case|:
return|return
name|ARM_GT
return|;
case|case
name|GEU
case|:
return|return
name|ARM_LS
return|;
case|case
name|GTU
case|:
return|return
name|ARM_CC
return|;
case|case
name|LEU
case|:
return|return
name|ARM_CS
return|;
case|case
name|LTU
case|:
return|return
name|ARM_HI
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|CC_Cmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|LTU
case|:
return|return
name|ARM_CS
return|;
case|case
name|GEU
case|:
return|return
name|ARM_CC
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|CCmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|GE
case|:
return|return
name|ARM_GE
return|;
case|case
name|GT
case|:
return|return
name|ARM_GT
return|;
case|case
name|LE
case|:
return|return
name|ARM_LE
return|;
case|case
name|LT
case|:
return|return
name|ARM_LT
return|;
case|case
name|GEU
case|:
return|return
name|ARM_CS
return|;
case|case
name|GTU
case|:
return|return
name|ARM_HI
return|;
case|case
name|LEU
case|:
return|return
name|ARM_LS
return|;
case|case
name|LTU
case|:
return|return
name|ARM_CC
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_final_prescan_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* BODY will hold the body of INSN.  */
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* This will be 1 if trying to repeat the trick, and things need to be      reversed if it appears to fail.  */
name|int
name|reverse
init|=
literal|0
decl_stmt|;
comment|/* JUMP_CLOBBERS will be one implies that the conditions if a branch is      taken are clobbered, even if the rtl suggests otherwise.  It also      means that we have to grub around within the jump expression to find      out what the conditions are when the jump isn't taken.  */
name|int
name|jump_clobbers
init|=
literal|0
decl_stmt|;
comment|/* If we start with a return insn, we only succeed if we find another one.  */
name|int
name|seeking_return
init|=
literal|0
decl_stmt|;
comment|/* START_INSN will hold the insn from where we start looking.  This is the      first insn after the following code_label if REVERSE is true.  */
name|rtx
name|start_insn
init|=
name|insn
decl_stmt|;
comment|/* If in state 4, check if the target branch is reached, in order to      change back to state 0.  */
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|arm_target_insn
condition|)
block|{
name|arm_target_insn
operator|=
name|NULL
expr_stmt|;
name|arm_ccfsm_state
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
comment|/* If in state 3, it is possible to repeat the trick, if this insn is an      unconditional branch to a label, and immediately following this branch      is the previous target label which is only used once, and the label this      branch jumps to is not too far off.  */
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
comment|/* XXX Isn't this always a barrier?  */
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|CODE_LABEL_NUMBER
argument_list|(
name|start_insn
argument_list|)
operator|==
name|arm_target_label
operator|&&
name|LABEL_NUSES
argument_list|(
name|start_insn
argument_list|)
operator|==
literal|1
condition|)
name|reverse
operator|=
name|TRUE
expr_stmt|;
else|else
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|CODE_LABEL_NUMBER
argument_list|(
name|start_insn
argument_list|)
operator|==
name|arm_target_label
operator|&&
name|LABEL_NUSES
argument_list|(
name|start_insn
argument_list|)
operator|==
literal|1
condition|)
block|{
name|reverse
operator|=
name|TRUE
expr_stmt|;
name|seeking_return
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return;
block|}
else|else
return|return;
block|}
if|if
condition|(
name|arm_ccfsm_state
operator|!=
literal|0
operator|&&
operator|!
name|reverse
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return;
comment|/* This jump might be paralleled with a clobber of the condition codes       the jump should always come first */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|body
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If this is a conditional return then we don't want to know */
block|if (GET_CODE (body) == SET&& GET_CODE (SET_DEST (body)) == PC&& GET_CODE (SET_SRC (body)) == IF_THEN_ELSE&& (GET_CODE (XEXP (SET_SRC (body), 1)) == RETURN           || GET_CODE (XEXP (SET_SRC (body), 2)) == RETURN))     return;
endif|#
directive|endif
if|if
condition|(
name|reverse
operator|||
operator|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|)
condition|)
block|{
name|int
name|insns_skipped
decl_stmt|;
name|int
name|fail
init|=
name|FALSE
decl_stmt|,
name|succeed
init|=
name|FALSE
decl_stmt|;
comment|/* Flag which part of the IF_THEN_ELSE is the LABEL_REF.  */
name|int
name|then_not_else
init|=
name|TRUE
decl_stmt|;
name|rtx
name|this_insn
init|=
name|start_insn
decl_stmt|,
name|label
init|=
literal|0
decl_stmt|;
comment|/* If the jump cannot be done with one instruction, we cannot  	 conditionally execute the instruction in the inverse case.  */
if|if
condition|(
name|get_attr_conds
argument_list|(
name|insn
argument_list|)
operator|==
name|CONDS_JUMP_CLOB
condition|)
block|{
name|jump_clobbers
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Register the insn jumped to.  */
if|if
condition|(
name|reverse
condition|)
block|{
if|if
condition|(
operator|!
name|seeking_return
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|then_not_else
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
name|seeking_return
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|seeking_return
operator|=
literal|1
expr_stmt|;
name|then_not_else
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* See how many insns this branch skips, and what kind of insns.  If all 	 insns are okay, and the label or unconditional branch to the same 	 label is not too far away, succeed.  */
for|for
control|(
name|insns_skipped
operator|=
literal|0
init|;
operator|!
name|fail
operator|&&
operator|!
name|succeed
operator|&&
name|insns_skipped
operator|++
operator|<
name|max_insns_skipped
condition|;
control|)
block|{
name|rtx
name|scanbody
decl_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_insn
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
comment|/* Succeed if it is the target label, otherwise fail since 		 control falls in from somewhere else.  */
if|if
condition|(
name|this_insn
operator|==
name|label
condition|)
block|{
if|if
condition|(
name|jump_clobbers
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_ccfsm_state
operator|=
literal|1
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
comment|/* Succeed if the following insn is the target label. 		 Otherwise fail.   		 If return insns are used then the last insn in a function  		 will be a barrier.  */
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|&&
name|this_insn
operator|==
name|label
condition|)
block|{
if|if
condition|(
name|jump_clobbers
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_ccfsm_state
operator|=
literal|1
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CALL_INSN
case|:
comment|/* If using 32-bit addresses the cc is not preserved over 		 calls.  */
if|if
condition|(
name|TARGET_APCS_32
condition|)
block|{
comment|/* Succeed if the following insn is the target label, 		     or if the following two insns are a barrier and 		     the target label.  */
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|&&
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|&&
name|this_insn
operator|==
name|label
operator|&&
name|insns_skipped
operator|<
name|max_insns_skipped
condition|)
block|{
if|if
condition|(
name|jump_clobbers
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_ccfsm_state
operator|=
literal|1
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
block|}
break|break;
case|case
name|JUMP_INSN
case|:
comment|/* If this is an unconditional branch to the same label, succeed. 		 If it is to another label, do nothing.  If it is conditional, 		 fail.  */
comment|/* XXX Probably, the tests for SET and the PC are unnecessary.  */
name|scanbody
operator|=
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
operator|&&
operator|!
name|reverse
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Fail if a conditional return is undesirable (eg on a 		 StrongARM), but still allow this if optimizing for size.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|RETURN
operator|&&
operator|!
name|use_return_insn
argument_list|(
name|TRUE
argument_list|)
operator|&&
operator|!
name|optimize_size
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|RETURN
operator|&&
name|seeking_return
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
switch|switch
condition|(
name|get_attr_conds
argument_list|(
name|this_insn
argument_list|)
condition|)
block|{
case|case
name|CONDS_NOCOND
case|:
break|break;
default|default:
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
comment|/* Unrecognized jump (eg epilogue).  */
break|break;
case|case
name|INSN
case|:
comment|/* Instructions using or affecting the condition codes make it 		 fail.  */
name|scanbody
operator|=
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|PARALLEL
operator|)
operator|||
name|get_attr_conds
argument_list|(
name|this_insn
argument_list|)
operator|!=
name|CONDS_NOCOND
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|succeed
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|seeking_return
operator|)
operator|&&
operator|(
name|arm_ccfsm_state
operator|==
literal|1
operator|||
name|reverse
operator|)
condition|)
name|arm_target_label
operator|=
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|seeking_return
operator|||
name|arm_ccfsm_state
operator|==
literal|2
condition|)
block|{
while|while
condition|(
name|this_insn
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
operator|==
name|BARRIER
operator|||
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this_insn
condition|)
block|{
comment|/* Oh, dear! we ran off the end.. give up */
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|arm_ccfsm_state
operator|=
literal|0
expr_stmt|;
name|arm_target_insn
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|arm_target_insn
operator|=
name|this_insn
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|jump_clobbers
condition|)
block|{
if|if
condition|(
name|reverse
condition|)
name|abort
argument_list|()
expr_stmt|;
name|arm_current_cc
operator|=
name|get_arm_condition_code
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
name|arm_current_cc
operator|=
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|arm_current_cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NE
condition|)
name|arm_current_cc
operator|=
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|arm_current_cc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If REVERSE is true, ARM_CURRENT_CC needs to be inverted from 		 what it was.  */
if|if
condition|(
operator|!
name|reverse
condition|)
name|arm_current_cc
operator|=
name|get_arm_condition_code
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reverse
operator|||
name|then_not_else
condition|)
name|arm_current_cc
operator|=
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|arm_current_cc
argument_list|)
expr_stmt|;
block|}
comment|/* Restore recog_data (getting the attributes of other insns can 	 destroy this array, but final.c assumes that it remains intact 	 across this call; since the insn has been recognized already we 	 call recog direct).  */
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if REGNO is a valid register    for holding a quantity of tyoe MODE.  */
end_comment

begin_function
name|int
name|arm_hard_regno_mode_ok
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
condition|)
return|return
name|regno
operator|==
name|CC_REGNUM
return|;
if|if
condition|(
name|TARGET_THUMB
condition|)
comment|/* For the Thumb we only allow values bigger than SImode in        registers 0 - 6, so that there is always a second low        register available to hold the upper part of the value.        We probably we ought to ensure that the register is the        start of an even numbered register pair.  */
return|return
operator|(
name|NUM_REGS
argument_list|(
name|mode
argument_list|)
operator|<
literal|2
operator|)
operator|||
operator|(
name|regno
operator|<
name|LAST_LO_REGNUM
operator|)
return|;
if|if
condition|(
name|regno
operator|<=
name|LAST_ARM_REGNUM
condition|)
comment|/* We allow an SImode or smaller value to be stored in any        general purpose register.  This does not mean, for example        that GCC will choose to store a variable in the stack pointer        since it is a fixed register.  But it is important to allow        access to these special registers, so that they can be        referenced from C code via the asm assembler alias, eg:            register char * stack_ptr asm ("sp");         For any mode requiring more than one register to hold the        value we restrict the choice so that r13, r14, and r15        cannot be part of the register set.  */
return|return
operator|(
name|NUM_REGS
argument_list|(
name|mode
argument_list|)
operator|<=
literal|1
operator|)
operator|||
operator|(
name|regno
operator|<
operator|(
name|SP_REGNUM
operator|-
operator|(
name|unsigned
operator|)
name|NUM_REGS
argument_list|(
name|mode
argument_list|)
operator|)
operator|)
return|;
if|if
condition|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
condition|)
comment|/* We only allow integers in the fake hard registers.  */
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
return|;
comment|/* The only registers left are the FPU registers      which we only allow to hold FP values.  */
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|regno
operator|>=
name|FIRST_ARM_FP_REGNUM
operator|&&
name|regno
operator|<=
name|LAST_ARM_FP_REGNUM
return|;
block|}
end_function

begin_function
name|int
name|arm_regno_class
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
name|STACK_REG
return|;
if|if
condition|(
name|regno
operator|==
name|CC_REGNUM
condition|)
return|return
name|CC_REG
return|;
if|if
condition|(
name|regno
operator|<
literal|8
condition|)
return|return
name|LO_REGS
return|;
return|return
name|HI_REGS
return|;
block|}
if|if
condition|(
name|regno
operator|<=
name|LAST_ARM_REGNUM
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
condition|)
return|return
name|GENERAL_REGS
return|;
if|if
condition|(
name|regno
operator|==
name|CC_REGNUM
condition|)
return|return
name|NO_REGS
return|;
return|return
name|FPU_REGS
return|;
block|}
end_function

begin_comment
comment|/* Handle a special case when computing the offset    of an argument from the frame pointer.  */
end_comment

begin_function
name|int
name|arm_debugger_arg_offset
parameter_list|(
name|value
parameter_list|,
name|addr
parameter_list|)
name|int
name|value
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* We are only interested if dbxout_parms() failed to compute the offset.  */
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We can only cope with the case where the address is held in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
comment|/* If we are using the frame pointer to point at the argument, then      an offset of 0 is correct.  */
if|if
condition|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
literal|0
return|;
comment|/* If we are using the stack pointer to point at the      argument, then an offset of 0 is correct.  */
if|if
condition|(
operator|(
name|TARGET_THUMB
operator|||
operator|!
name|frame_pointer_needed
operator|)
operator|&&
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|==
name|SP_REGNUM
condition|)
return|return
literal|0
return|;
comment|/* Oh dear.  The argument is pointed to by a register rather      than being held in a register, or being stored at a known      offset from the frame pointer.  Since GDB only understands      those two kinds of argument we must translate the address      held in the register into an offset from the frame pointer.      We do this by searching through the insns for the function      looking to see where this register gets its value.  If the      register is initialised from the frame pointer plus an offset      then we are in luck and we can continue, otherwise we give up.            This code is exercised by producing debugging information      for a function with arguments like this:                  double func (double a, double b, int c, double d) {return d;}            Without this code the stab for parameter 'd' will be set to      an offset of 0 from the frame pointer, rather than 8.  */
comment|/* The if() statement says:       If the insn is a normal instruction      and if the insn is setting the value in a register      and if the register being set is the register holding the address of the argument      and if the address is computing by an addition      that involves adding to a register      which is the frame pointer      a constant integer       then... */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|debug_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"unable to compute real location of stacked parameter"
argument_list|)
expr_stmt|;
name|value
operator|=
literal|8
expr_stmt|;
comment|/* XXX magic hack */
block|}
return|return
name|value
return|;
block|}
end_function

begin_define
define|#
directive|define
name|def_builtin
parameter_list|(
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|builtin_function ((NAME), (TYPE), (CODE), BUILT_IN_MD, NULL)
end_define

begin_function
name|void
name|arm_init_builtins
parameter_list|()
block|{
name|tree
name|endlink
init|=
name|void_list_node
decl_stmt|;
name|tree
name|int_endlink
init|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
decl_stmt|;
name|tree
name|pchar_type_node
init|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int
decl_stmt|,
name|void_ftype_pchar
decl_stmt|;
comment|/* void func (void *) */
name|void_ftype_pchar
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|pchar_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
comment|/* int func (int) */
name|int_ftype_int
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|int_endlink
argument_list|)
expr_stmt|;
comment|/* Initialize arm V5 builtins.  */
if|if
condition|(
name|arm_arch5
condition|)
name|def_builtin
argument_list|(
literal|"__builtin_clz"
argument_list|,
name|int_ftype_int
argument_list|,
name|ARM_BUILTIN_CLZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
name|rtx
name|arm_expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|subtarget
parameter_list|,
name|mode
parameter_list|,
name|ignore
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|,
name|mode0
decl_stmt|;
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
default|default:
break|break;
case|case
name|ARM_BUILTIN_CLZ
case|:
name|icode
operator|=
name|CODE_FOR_clz
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_expr
argument_list|(
name|arg0
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
comment|/* @@@ Should really do something sensible here.  */
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recursively search through all of the blocks in a function    checking to see if any of the variables created in that    function match the RTX called 'orig'.  If they do then    replace them with the RTX called 'new'.  */
end_comment

begin_function
specifier|static
name|void
name|replace_symbols_in_block
parameter_list|(
name|block
parameter_list|,
name|orig
parameter_list|,
name|new
parameter_list|)
name|tree
name|block
decl_stmt|;
name|rtx
name|orig
decl_stmt|;
name|rtx
name|new
decl_stmt|;
block|{
for|for
control|(
init|;
name|block
condition|;
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
control|)
block|{
name|tree
name|sym
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_USED
argument_list|(
name|block
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|sym
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|sym
condition|;
name|sym
operator|=
name|TREE_CHAIN
argument_list|(
name|sym
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|DECL_NAME
argument_list|(
name|sym
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|sym
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
operator|||
name|DECL_IGNORED_P
argument_list|(
name|sym
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|sym
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|DECL_EXTERNAL
argument_list|(
name|sym
argument_list|)
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|DECL_RTL
argument_list|(
name|sym
argument_list|)
argument_list|,
name|orig
argument_list|)
condition|)
continue|continue;
name|SET_DECL_RTL
argument_list|(
name|sym
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
name|replace_symbols_in_block
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|orig
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the number (counting from 0) of    the least significant set bit in MASK.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_function
specifier|inline
endif|#
directive|endif
specifier|static
name|int
name|number_of_first_bit_set
parameter_list|(
name|mask
parameter_list|)
name|int
name|mask
decl_stmt|;
block|{
name|int
name|bit
decl_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
operator|)
operator|==
literal|0
condition|;
operator|++
name|bit
control|)
continue|continue;
return|return
name|bit
return|;
block|}
end_function

begin_comment
comment|/* Generate code to return from a thumb function.    If 'reg_containing_return_addr' is -1, then the return address is    actually on the stack, at the stack pointer.  */
end_comment

begin_function
specifier|static
name|void
name|thumb_exit
parameter_list|(
name|f
parameter_list|,
name|reg_containing_return_addr
parameter_list|,
name|eh_ofs
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|reg_containing_return_addr
decl_stmt|;
name|rtx
name|eh_ofs
decl_stmt|;
block|{
name|unsigned
name|regs_available_for_popping
decl_stmt|;
name|unsigned
name|regs_to_pop
decl_stmt|;
name|int
name|pops_needed
decl_stmt|;
name|unsigned
name|available
decl_stmt|;
name|unsigned
name|required
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|restore_a4
init|=
name|FALSE
decl_stmt|;
comment|/* Compute the registers we need to pop.  */
name|regs_to_pop
operator|=
literal|0
expr_stmt|;
name|pops_needed
operator|=
literal|0
expr_stmt|;
comment|/* There is an assumption here, that if eh_ofs is not NULL, the      normal return address will have been pushed.  */
if|if
condition|(
name|reg_containing_return_addr
operator|==
operator|-
literal|1
operator|||
name|eh_ofs
condition|)
block|{
comment|/* When we are generating a return for __builtin_eh_return,  	 reg_containing_return_addr must specify the return regno.  */
if|if
condition|(
name|eh_ofs
operator|&&
name|reg_containing_return_addr
operator|==
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
name|regs_to_pop
operator||=
literal|1
operator|<<
name|LR_REGNUM
expr_stmt|;
operator|++
name|pops_needed
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_BACKTRACE
condition|)
block|{
comment|/* Restore the (ARM) frame pointer and stack pointer.  */
name|regs_to_pop
operator||=
operator|(
literal|1
operator|<<
name|ARM_HARD_FRAME_POINTER_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
expr_stmt|;
name|pops_needed
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* If there is nothing to pop then just emit the BX instruction and      return.  */
if|if
condition|(
name|pops_needed
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|eh_ofs
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|REGNO
argument_list|(
name|eh_ofs
argument_list|)
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|reg_containing_return_addr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise if we are not supporting interworking and we have not created      a backtrace structure and the function was not entered in ARM mode then      just pop the return address straight into the PC.  */
elseif|else
if|if
condition|(
operator|!
name|TARGET_INTERWORK
operator|&&
operator|!
name|TARGET_BACKTRACE
operator|&&
operator|!
name|is_called_in_ARM_mode
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|eh_ofs
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, #4\n"
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|REGNO
argument_list|(
name|eh_ofs
argument_list|)
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|reg_containing_return_addr
argument_list|)
expr_stmt|;
block|}
else|else
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tpop\t{%r}\n"
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find out how many of the (return) argument registers we can corrupt.  */
name|regs_available_for_popping
operator|=
literal|0
expr_stmt|;
comment|/* If returning via __builtin_eh_return, the bottom three registers      all contain information needed for the return.  */
if|if
condition|(
name|eh_ofs
condition|)
name|size
operator|=
literal|12
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|RTX_CODE
comment|/* If we can deduce the registers used from the function's 	 return value.  This is more reliable that examining 	 regs_ever_live[] because that will be set if the register is 	 ever used in the function, not just if the register is used 	 to hold a return value.  */
if|if
condition|(
name|current_function_return_rtx
operator|!=
literal|0
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|current_function_return_rtx
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* In a void function we can use any argument register. 	     In a function that returns a structure on the stack 	     we can use the second and third argument registers.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|1
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|2
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
else|else
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|2
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
literal|4
condition|)
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|2
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<=
literal|8
condition|)
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Match registers to be popped with registers into which we pop them.  */
for|for
control|(
name|available
operator|=
name|regs_available_for_popping
operator|,
name|required
operator|=
name|regs_to_pop
init|;
name|required
operator|!=
literal|0
operator|&&
name|available
operator|!=
literal|0
condition|;
name|available
operator|&=
operator|~
operator|(
name|available
operator|&
operator|-
name|available
operator|)
operator|,
name|required
operator|&=
operator|~
operator|(
name|required
operator|&
operator|-
name|required
operator|)
control|)
operator|--
name|pops_needed
expr_stmt|;
comment|/* If we have any popping registers left over, remove them.  */
if|if
condition|(
name|available
operator|>
literal|0
condition|)
name|regs_available_for_popping
operator|&=
operator|~
name|available
expr_stmt|;
comment|/* Otherwise if we need another popping register we can use      the fourth argument register.  */
elseif|else
if|if
condition|(
name|pops_needed
condition|)
block|{
comment|/* If we have not found any free argument registers and 	 reg a4 contains the return address, we must move it.  */
if|if
condition|(
name|regs_available_for_popping
operator|==
literal|0
operator|&&
name|reg_containing_return_addr
operator|==
name|LAST_ARG_REGNUM
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|LR_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>
literal|12
condition|)
block|{
comment|/* Register a4 is being used to hold part of the return value, 	     but we have dire need of a free, low register.  */
name|restore_a4
operator|=
name|TRUE
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_containing_return_addr
operator|!=
name|LAST_ARG_REGNUM
condition|)
block|{
comment|/* The fourth argument register is available.  */
name|regs_available_for_popping
operator||=
literal|1
operator|<<
name|LAST_ARG_REGNUM
expr_stmt|;
operator|--
name|pops_needed
expr_stmt|;
block|}
block|}
comment|/* Pop as many registers as we can.  */
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|regs_available_for_popping
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Process the registers we popped.  */
if|if
condition|(
name|reg_containing_return_addr
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* The return address was popped into the lowest numbered register.  */
name|regs_to_pop
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* Remove this register for the mask of available registers, so that          the return address will not be corrupted by futher pops.  */
name|regs_available_for_popping
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|reg_containing_return_addr
operator|)
expr_stmt|;
block|}
comment|/* If we popped other registers then handle them here.  */
if|if
condition|(
name|regs_available_for_popping
condition|)
block|{
name|int
name|frame_pointer
decl_stmt|;
comment|/* Work out which register currently contains the frame pointer.  */
name|frame_pointer
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* Move it into the correct place.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|,
name|frame_pointer
argument_list|)
expr_stmt|;
comment|/* (Temporarily) remove it from the mask of popped registers.  */
name|regs_available_for_popping
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|frame_pointer
operator|)
expr_stmt|;
name|regs_to_pop
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ARM_HARD_FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
if|if
condition|(
name|regs_available_for_popping
condition|)
block|{
name|int
name|stack_pointer
decl_stmt|;
comment|/* We popped the stack pointer as well, 	     find the register that contains it.  */
name|stack_pointer
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* Move it into the stack register.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|stack_pointer
argument_list|)
expr_stmt|;
comment|/* At this point we have popped all necessary registers, so 	     do not worry about restoring regs_available_for_popping 	     to its correct value:  	     assert (pops_needed == 0) 	     assert (regs_available_for_popping == (1<< frame_pointer)) 	     assert (regs_to_pop == (1<< STACK_POINTER))  */
block|}
else|else
block|{
comment|/* Since we have just move the popped value into the frame 	     pointer, the popping register is available for reuse, and 	     we know that we still have the stack pointer left to pop.  */
name|regs_available_for_popping
operator||=
operator|(
literal|1
operator|<<
name|frame_pointer
operator|)
expr_stmt|;
block|}
block|}
comment|/* If we still have registers left on the stack, but we no longer have      any registers into which we can pop them, then we must move the return      address into the link register and make available the register that      contained it.  */
if|if
condition|(
name|regs_available_for_popping
operator|==
literal|0
operator|&&
name|pops_needed
operator|>
literal|0
condition|)
block|{
name|regs_available_for_popping
operator||=
literal|1
operator|<<
name|reg_containing_return_addr
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|reg_containing_return_addr
argument_list|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|LR_REGNUM
expr_stmt|;
block|}
comment|/* If we have registers left on the stack then pop some more.      We know that at most we will want to pop FP and SP.  */
if|if
condition|(
name|pops_needed
operator|>
literal|0
condition|)
block|{
name|int
name|popped_into
decl_stmt|;
name|int
name|move_to
decl_stmt|;
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|regs_available_for_popping
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* We have popped either FP or SP. 	 Move whichever one it is into the correct register.  */
name|popped_into
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
name|move_to
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_to_pop
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|move_to
argument_list|,
name|popped_into
argument_list|)
expr_stmt|;
name|regs_to_pop
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|move_to
operator|)
expr_stmt|;
operator|--
name|pops_needed
expr_stmt|;
block|}
comment|/* If we still have not popped everything then we must have only      had one register available to us and we are now popping the SP.  */
if|if
condition|(
name|pops_needed
operator|>
literal|0
condition|)
block|{
name|int
name|popped_into
decl_stmt|;
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|regs_available_for_popping
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|popped_into
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|popped_into
argument_list|)
expr_stmt|;
comment|/* 	assert (regs_to_pop == (1<< STACK_POINTER)) 	assert (pops_needed == 1)       */
block|}
comment|/* If necessary restore the a4 register.  */
if|if
condition|(
name|restore_a4
condition|)
block|{
if|if
condition|(
name|reg_containing_return_addr
operator|!=
name|LR_REGNUM
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|LR_REGNUM
expr_stmt|;
block|}
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LAST_ARG_REGNUM
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eh_ofs
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|REGNO
argument_list|(
name|eh_ofs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return to caller.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|reg_containing_return_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit code to push or pop registers to or from the stack.  */
end_comment

begin_function
specifier|static
name|void
name|thumb_pushpop
parameter_list|(
name|f
parameter_list|,
name|mask
parameter_list|,
name|push
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|push
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|int
name|lo_mask
init|=
name|mask
operator|&
literal|0xFF
decl_stmt|;
if|if
condition|(
name|lo_mask
operator|==
literal|0
operator|&&
operator|!
name|push
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
literal|15
operator|)
operator|)
condition|)
block|{
comment|/* Special case.  Do not generate a POP PC statement here, do it in 	 thumb_exit() */
name|thumb_exit
argument_list|(
name|f
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t{"
argument_list|,
name|push
condition|?
literal|"push"
else|:
literal|"pop"
argument_list|)
expr_stmt|;
comment|/* Look at the low registers first.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
operator|,
name|lo_mask
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|lo_mask
operator|&
literal|1
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lo_mask
operator|&
operator|~
literal|1
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|push
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
condition|)
block|{
comment|/* Catch pushing the LR.  */
if|if
condition|(
name|mask
operator|&
literal|0xFF
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r"
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|push
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
operator|)
condition|)
block|{
comment|/* Catch popping the PC.  */
if|if
condition|(
name|TARGET_INTERWORK
operator|||
name|TARGET_BACKTRACE
condition|)
block|{
comment|/* The PC is never poped directly, instead 	     it is popped into r3 and then BX is used.  */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|thumb_exit
argument_list|(
name|f
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|mask
operator|&
literal|0xFF
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r"
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|thumb_final_prescan_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|flag_print_asm_name
condition|)
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%@ 0x%04x\n"
argument_list|,
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|thumb_shiftable_const
parameter_list|(
name|val
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|val
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
literal|0xff
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
comment|/* XXX */
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|mask
operator|<<
name|i
operator|)
operator|)
operator|==
name|val
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the current function contains,    or might contain a far jump.  */
end_comment

begin_function
name|int
name|thumb_far_jump_used_p
parameter_list|(
name|int
name|in_prologue
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* This test is only important for leaf functions.  */
comment|/* assert (!leaf_function_p ()); */
comment|/* If we have already decided that far jumps may be used,      do not bother checking again, and always return true even if      it turns out that they are not being used.  Once we have made      the decision that far jumps are present (and that hence the link      register will be pushed onto the stack) we cannot go back on it.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|far_jump_used
condition|)
return|return
literal|1
return|;
comment|/* If this function is not being called from the prologue/epilogue      generation code then it must be being called from the      INITIAL_ELIMINATION_OFFSET macro.  */
if|if
condition|(
operator|!
name|in_prologue
condition|)
block|{
comment|/* In this case we know that we are being asked about the elimination 	 of the arg pointer register.  If that register is not being used, 	 then there are no arguments on the stack, and we do not have to 	 worry that a far jump might force the prologue to push the link 	 register, changing the stack offsets.  In this case we can just 	 return false, since the presence of far jumps in the function will 	 not affect stack offsets.  	 If the arg pointer is live (or if it was live, but has now been 	 eliminated and so set to dead) then we do have to test to see if 	 the function might contain a far jump.  This test can lead to some 	 false negatives, since before reload is completed, then length of 	 branch instructions is not known, so gcc defaults to returning their 	 longest length, which in turn sets the far jump attribute to true.  	 A false negative will not result in bad code being generated, but it 	 will result in a needless push and pop of the link register.  We 	 hope that this does not occur too often.  */
if|if
condition|(
name|regs_ever_live
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
name|cfun
operator|->
name|machine
operator|->
name|arg_pointer_live
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cfun
operator|->
name|machine
operator|->
name|arg_pointer_live
condition|)
return|return
literal|0
return|;
block|}
comment|/* Check to see if the function contains a branch      insn with the far jump attribute set.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
comment|/* Ignore tablejump patterns.  */
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|&&
name|get_attr_far_jump
argument_list|(
name|insn
argument_list|)
operator|==
name|FAR_JUMP_YES
condition|)
block|{
comment|/* Record the fact that we have decied that 	     the function does use far jumps.  */
name|cfun
operator|->
name|machine
operator|->
name|far_jump_used
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if FUNC must be entered in ARM mode.  */
end_comment

begin_function
name|int
name|is_called_in_ARM_mode
parameter_list|(
name|func
parameter_list|)
name|tree
name|func
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|func
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Ignore the problem about functions whoes address is taken.  */
if|if
condition|(
name|TARGET_CALLEE_INTERWORKING
operator|&&
name|TREE_PUBLIC
argument_list|(
name|func
argument_list|)
condition|)
return|return
name|TRUE
return|;
ifdef|#
directive|ifdef
name|ARM_PE
return|return
name|lookup_attribute
argument_list|(
literal|"interfacearm"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|func
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
return|;
else|#
directive|else
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The bits which aren't usefully expanded as rtl. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|thumb_unexpanded_epilogue
parameter_list|()
block|{
name|int
name|regno
decl_stmt|;
name|int
name|live_regs_mask
init|=
literal|0
decl_stmt|;
name|int
name|high_regs_pushed
init|=
literal|0
decl_stmt|;
name|int
name|leaf_function
init|=
name|leaf_function_p
argument_list|()
decl_stmt|;
name|int
name|had_to_push_lr
decl_stmt|;
name|rtx
name|eh_ofs
init|=
name|cfun
operator|->
name|machine
operator|->
name|eh_epilogue_sp_ofs
decl_stmt|;
if|if
condition|(
name|return_used_this_function
condition|)
return|return
literal|""
return|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
operator|(
name|TARGET_SINGLE_PIC_BASE
operator|&&
operator|(
name|regno
operator|==
name|arm_pic_register
operator|)
operator|)
condition|)
name|live_regs_mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|8
init|;
name|regno
operator|<
literal|13
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
operator|(
name|TARGET_SINGLE_PIC_BASE
operator|&&
operator|(
name|regno
operator|==
name|arm_pic_register
operator|)
operator|)
condition|)
name|high_regs_pushed
operator|++
expr_stmt|;
block|}
comment|/* The prolog may have pushed some high registers to use as      work registers.  eg the testuite file:      gcc/testsuite/gcc/gcc.c-torture/execute/complex-2.c      compiles to produce: 	push	{r4, r5, r6, r7, lr} 	mov	r7, r9 	mov	r6, r8 	push	{r6, r7}      as part of the prolog.  We have to undo that pushing here.  */
if|if
condition|(
name|high_regs_pushed
condition|)
block|{
name|int
name|mask
init|=
name|live_regs_mask
decl_stmt|;
name|int
name|next_hi_reg
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|mode
decl_stmt|;
ifdef|#
directive|ifdef
name|RTX_CODE
comment|/* If we can deduce the registers used from the function's return value. 	 This is more reliable that examining regs_ever_live[] because that 	 will be set if the register is ever used in the function, not just if 	 the register is used to hold a return value.  */
if|if
condition|(
name|current_function_return_rtx
operator|!=
literal|0
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|current_function_return_rtx
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Unless we are returning a type of size> 12 register r3 is          available.  */
if|if
condition|(
name|size
operator|<
literal|13
condition|)
name|mask
operator||=
literal|1
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
comment|/* Oh dear!  We have no low registers into which we can pop            high registers!  */
name|internal_error
argument_list|(
literal|"no low registers available for popping high registers"
argument_list|)
expr_stmt|;
for|for
control|(
name|next_hi_reg
operator|=
literal|8
init|;
name|next_hi_reg
operator|<
literal|13
condition|;
name|next_hi_reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|next_hi_reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|next_hi_reg
index|]
operator|&&
operator|!
operator|(
name|TARGET_SINGLE_PIC_BASE
operator|&&
operator|(
name|next_hi_reg
operator|==
name|arm_pic_register
operator|)
operator|)
condition|)
break|break;
while|while
condition|(
name|high_regs_pushed
condition|)
block|{
comment|/* Find lo register(s) into which the high register(s) can              be popped.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
name|high_regs_pushed
operator|--
expr_stmt|;
if|if
condition|(
name|high_regs_pushed
operator|==
literal|0
condition|)
break|break;
block|}
name|mask
operator|&=
operator|(
literal|2
operator|<<
name|regno
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* A noop if regno == 8 */
comment|/* Pop the values into the low register(s). */
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Move the value(s) into the high registers.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|next_hi_reg
argument_list|,
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|next_hi_reg
operator|++
init|;
name|next_hi_reg
operator|<
literal|13
condition|;
name|next_hi_reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|next_hi_reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|next_hi_reg
index|]
operator|&&
operator|!
operator|(
name|TARGET_SINGLE_PIC_BASE
operator|&&
operator|(
name|next_hi_reg
operator|==
name|arm_pic_register
operator|)
operator|)
condition|)
break|break;
block|}
block|}
block|}
block|}
name|had_to_push_lr
operator|=
operator|(
name|live_regs_mask
operator|||
operator|!
name|leaf_function
operator|||
name|thumb_far_jump_used_p
argument_list|(
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_BACKTRACE
operator|&&
operator|(
operator|(
name|live_regs_mask
operator|&
literal|0xFF
operator|)
operator|==
literal|0
operator|)
operator|&&
name|regs_ever_live
index|[
name|LAST_ARG_REGNUM
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* The stack backtrace structure creation code had to 	 push R7 in order to get a work register, so we pop 	 it now.   */
name|live_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|LAST_LO_REGNUM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_pretend_args_size
operator|==
literal|0
operator|||
name|TARGET_BACKTRACE
condition|)
block|{
if|if
condition|(
name|had_to_push_lr
operator|&&
operator|!
name|is_called_in_ARM_mode
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
name|eh_ofs
condition|)
name|live_regs_mask
operator||=
literal|1
operator|<<
name|PC_REGNUM
expr_stmt|;
comment|/* Either no argument registers were pushed or a backtrace 	 structure was created which includes an adjusted stack 	 pointer, so just pop everything.  */
if|if
condition|(
name|live_regs_mask
condition|)
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
name|live_regs_mask
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_ofs
condition|)
name|thumb_exit
argument_list|(
name|asm_out_file
argument_list|,
literal|2
argument_list|,
name|eh_ofs
argument_list|)
expr_stmt|;
comment|/* We have either just popped the return address into the 	 PC or it is was kept in LR for the entire function or 	 it is still on the stack because we do not want to 	 return by doing a pop {pc}.  */
elseif|else
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
operator|)
operator|==
literal|0
condition|)
name|thumb_exit
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|had_to_push_lr
operator|&&
name|is_called_in_ARM_mode
argument_list|(
name|current_function_decl
argument_list|)
operator|)
condition|?
operator|-
literal|1
else|:
name|LR_REGNUM
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pop everything but the return address.  */
name|live_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
expr_stmt|;
if|if
condition|(
name|live_regs_mask
condition|)
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
name|live_regs_mask
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|had_to_push_lr
condition|)
comment|/* Get the return address into a temporary register.  */
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
literal|1
operator|<<
name|LAST_ARG_REGNUM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Remove the argument registers that were pushed onto the stack.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tadd\t%r, %r, #%d\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_ofs
condition|)
name|thumb_exit
argument_list|(
name|asm_out_file
argument_list|,
literal|2
argument_list|,
name|eh_ofs
argument_list|)
expr_stmt|;
else|else
name|thumb_exit
argument_list|(
name|asm_out_file
argument_list|,
name|had_to_push_lr
condition|?
name|LAST_ARG_REGNUM
else|:
name|LR_REGNUM
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Functions to save and restore machine-specific function data.  */
end_comment

begin_function
specifier|static
name|void
name|arm_mark_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|machine_function
modifier|*
name|machine
init|=
name|p
operator|->
name|machine
decl_stmt|;
if|if
condition|(
name|machine
condition|)
name|ggc_mark_rtx
argument_list|(
name|machine
operator|->
name|eh_epilogue_sp_ofs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_init_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
name|p
operator|->
name|machine
operator|=
operator|(
name|machine_function
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|machine_function
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARM_FT_UNKNOWWN
operator|!=
literal|0
operator|(
operator|(
name|machine_function
operator|*
operator|)
name|p
operator|->
name|machine
operator|)
operator|->
name|func_type
operator|=
name|ARM_FT_UNKNOWN
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|arm_free_machine_status
parameter_list|(
name|p
parameter_list|)
name|struct
name|function
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|->
name|machine
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|machine
argument_list|)
expr_stmt|;
name|p
operator|->
name|machine
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return an RTX indicating where the return address to the    calling function can be found.  */
end_comment

begin_function
name|rtx
name|arm_return_addr
parameter_list|(
name|count
parameter_list|,
name|frame
parameter_list|)
name|int
name|count
decl_stmt|;
name|rtx
name|frame
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|TARGET_APCS_32
condition|)
return|return
name|get_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|LR_REGNUM
argument_list|)
return|;
else|else
block|{
name|rtx
name|lr
init|=
name|gen_rtx_AND
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|RETURN_ADDR_MASK26
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|get_func_hard_reg_initial_val
argument_list|(
name|cfun
argument_list|,
name|lr
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Do anything needed before RTL is emitted for each function.  */
end_comment

begin_function
name|void
name|arm_init_expanders
parameter_list|()
block|{
comment|/* Arrange to initialize and mark the machine per-function status.  */
name|init_machine_status
operator|=
name|arm_init_machine_status
expr_stmt|;
name|mark_machine_status
operator|=
name|arm_mark_machine_status
expr_stmt|;
name|free_machine_status
operator|=
name|arm_free_machine_status
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the rest of a function's prologue.  */
end_comment

begin_function
name|void
name|thumb_expand_prologue
parameter_list|()
block|{
name|HOST_WIDE_INT
name|amount
init|=
operator|(
name|get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
operator|)
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
comment|/* Naked functions don't have prologues.  */
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"interrupt Service Routines cannot be coded in Thumb mode"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
condition|)
block|{
name|amount
operator|=
name|ROUND_UP
argument_list|(
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|<
literal|512
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|regno
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
comment|/* The stack decrement is too big for an immediate value in a single 	     insn.  In theory we could issue multiple subtracts, but after 	     three of them it becomes more space efficient to place the full 	     value in the constant pool and load into a register.  (Also the 	     ARM debugger really likes to see only one stack decrement per 	     function).  So instead we look for a scratch register into which 	     we can load the decrement, and then we subtract this from the 	     stack pointer.  Unfortunately on the thumb the only available 	     scratch registers are the argument registers, and we cannot use 	     these as they may hold arguments to the function.  Instead we 	     attempt to locate a call preserved register which is used by this 	     function.  If we can find one, then we know that it will have 	     been pushed at the start of the prologue and so we can corrupt 	     it now.  */
for|for
control|(
name|regno
operator|=
name|LAST_ARG_REGNUM
operator|+
literal|1
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
comment|/* Paranoia */
operator|&&
operator|!
operator|(
name|TARGET_SINGLE_PIC_BASE
operator|&&
operator|(
name|regno
operator|==
name|arm_pic_register
operator|)
operator|)
operator|&&
operator|!
operator|(
name|frame_pointer_needed
operator|&&
operator|(
name|regno
operator|==
name|THUMB_HARD_FRAME_POINTER_REGNUM
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|regno
operator|>
name|LAST_LO_REGNUM
condition|)
comment|/* Very unlikely */
block|{
name|rtx
name|spare
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|IP_REGNUM
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Choose an arbitary, non-argument low register.  */
name|reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|LAST_LO_REGNUM
argument_list|)
expr_stmt|;
comment|/* Save it by copying it into a high, scratch register.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|spare
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add a USE to stop propagate_one_insn() from barfing.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|spare
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decrement the stack.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the low register's original value.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|spare
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit a USE of the restored scratch register, so that flow 		 analysis will not consider the restore redundant.  The 		 register won't be used again in this function and isn't 		 restored by the epilogue.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|current_function_profile
operator|||
name|TARGET_NO_SCHED_PRO
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|thumb_expand_epilogue
parameter_list|()
block|{
name|HOST_WIDE_INT
name|amount
init|=
operator|(
name|get_frame_size
argument_list|()
operator|+
name|current_function_outgoing_args_size
operator|)
decl_stmt|;
comment|/* Naked functions don't have prologues.  */
if|if
condition|(
name|IS_NAKED
argument_list|(
name|arm_current_func_type
argument_list|()
argument_list|)
condition|)
return|return;
if|if
condition|(
name|frame_pointer_needed
condition|)
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|amount
condition|)
block|{
name|amount
operator|=
name|ROUND_UP
argument_list|(
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
operator|<
literal|512
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* r3 is always free in the epilogue.  */
name|rtx
name|reg
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|SImode
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Emit a USE (stack_pointer_rtx), so that      the stack adjustment will not be deleted.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_profile
operator|||
name|TARGET_NO_SCHED_PRO
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thumb_output_function_prologue
parameter_list|(
name|f
parameter_list|,
name|size
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|live_regs_mask
init|=
literal|0
decl_stmt|;
name|int
name|high_regs_pushed
init|=
literal|0
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|arm_current_func_type
argument_list|()
argument_list|)
condition|)
return|return;
if|if
condition|(
name|is_called_in_ARM_mode
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|name
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Generate code sequence to switch us into Thumb mode.  */
comment|/* The .code 32 directive has already been emitted by 	 ASM_DECLARE_FUNCTION_NAME.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\torr\t%r, %r, #1\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
comment|/* Generate a label, so that the debugger will notice the 	 change in instruction sets.  This label is also used by 	 the assembler to bypass the ARM code when this function 	 is called from a Thumb encoded function elsewhere in the 	 same file.  Hence the definition of STUB_NAME here must 	 agree with the definition in gas/config/tc-arm.c  */
define|#
directive|define
name|STUB_NAME
value|".real_start_of"
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.code\t16\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARM_PE
if|if
condition|(
name|arm_dllexport_name_p
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|arm_strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.globl %s%U%s\n"
argument_list|,
name|STUB_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.thumb_func\n"
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%s%U%s:\n"
argument_list|,
name|STUB_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_pretend_args_size
condition|)
block|{
if|if
condition|(
name|current_function_anonymous_args
condition|)
block|{
name|int
name|num_pushes
decl_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tpush\t{"
argument_list|)
expr_stmt|;
name|num_pushes
operator|=
name|NUM_INTS
argument_list|(
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|LAST_ARG_REGNUM
operator|+
literal|1
operator|-
name|num_pushes
init|;
name|regno
operator|<=
name|LAST_ARG_REGNUM
condition|;
name|regno
operator|++
control|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r%s"
argument_list|,
name|regno
argument_list|,
name|regno
operator|==
name|LAST_ARG_REGNUM
condition|?
literal|""
else|:
literal|", "
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsub\t%r, %r, #%d\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
operator|(
name|TARGET_SINGLE_PIC_BASE
operator|&&
operator|(
name|regno
operator|==
name|arm_pic_register
operator|)
operator|)
condition|)
name|live_regs_mask
operator||=
literal|1
operator|<<
name|regno
expr_stmt|;
if|if
condition|(
name|live_regs_mask
operator|||
operator|!
name|leaf_function_p
argument_list|()
operator|||
name|thumb_far_jump_used_p
argument_list|(
literal|1
argument_list|)
condition|)
name|live_regs_mask
operator||=
literal|1
operator|<<
name|LR_REGNUM
expr_stmt|;
if|if
condition|(
name|TARGET_BACKTRACE
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|int
name|work_register
init|=
literal|0
decl_stmt|;
name|int
name|wr
decl_stmt|;
comment|/* We have been asked to create a stack backtrace structure.          The code looks like this: 	  	 0   .align 2 	 0   func:          0     sub   SP, #16         Reserve space for 4 registers. 	 2     push  {R7}            Get a work register.          4     add   R7, SP, #20     Get the stack pointer before the push.          6     str   R7, [SP, #8]    Store the stack pointer (before reserving the space).          8     mov   R7, PC          Get hold of the start of this code plus 12.         10     str   R7, [SP, #16]   Store it.         12     mov   R7, FP          Get hold of the current frame pointer.         14     str   R7, [SP, #4]    Store it.         16     mov   R7, LR          Get hold of the current return address.         18     str   R7, [SP, #12]   Store it.         20     add   R7, SP, #16     Point at the start of the backtrace structure.         22     mov   FP, R7          Put this value into the frame pointer.  */
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
literal|0xFF
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* See if the a4 register is free.  */
if|if
condition|(
name|regs_ever_live
index|[
name|LAST_ARG_REGNUM
index|]
operator|==
literal|0
condition|)
name|work_register
operator|=
name|LAST_ARG_REGNUM
expr_stmt|;
else|else
comment|/* We must push a register of our own */
name|live_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|LAST_LO_REGNUM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|work_register
operator|==
literal|0
condition|)
block|{
comment|/* Select a register from the list that will be pushed to              use as our work register.  */
for|for
control|(
name|work_register
operator|=
operator|(
name|LAST_LO_REGNUM
operator|+
literal|1
operator|)
init|;
name|work_register
operator|--
condition|;
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|work_register
operator|)
operator|&
name|live_regs_mask
condition|)
break|break;
block|}
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsub\t%r, %r, #16\t%@ Create stack backtrace structure\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|live_regs_mask
condition|)
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|live_regs_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|wr
operator|=
literal|1
operator|<<
literal|15
init|;
name|wr
operator|!=
literal|0
condition|;
name|wr
operator|>>=
literal|1
control|)
if|if
condition|(
name|wr
operator|&
name|live_regs_mask
condition|)
name|offset
operator|+=
literal|4
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r, #%d\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|16
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Make sure that the instruction fetching the PC is in the right place 	 to calculate "start of backtrace creation code + 12".  */
if|if
condition|(
name|live_regs_mask
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r, #%d\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\t\t%@ Backtrace structure created\n"
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|,
name|work_register
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|live_regs_mask
condition|)
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|live_regs_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|8
init|;
name|regno
operator|<
literal|13
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
operator|&&
operator|!
operator|(
name|TARGET_SINGLE_PIC_BASE
operator|&&
operator|(
name|regno
operator|==
name|arm_pic_register
operator|)
operator|)
condition|)
name|high_regs_pushed
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|high_regs_pushed
condition|)
block|{
name|int
name|pushable_regs
init|=
literal|0
decl_stmt|;
name|int
name|mask
init|=
name|live_regs_mask
operator|&
literal|0xff
decl_stmt|;
name|int
name|next_hi_reg
decl_stmt|;
for|for
control|(
name|next_hi_reg
operator|=
literal|12
init|;
name|next_hi_reg
operator|>
name|LAST_LO_REGNUM
condition|;
name|next_hi_reg
operator|--
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|next_hi_reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|next_hi_reg
index|]
operator|&&
operator|!
operator|(
name|TARGET_SINGLE_PIC_BASE
operator|&&
operator|(
name|next_hi_reg
operator|==
name|arm_pic_register
operator|)
operator|)
condition|)
break|break;
block|}
name|pushable_regs
operator|=
name|mask
expr_stmt|;
if|if
condition|(
name|pushable_regs
operator|==
literal|0
condition|)
block|{
comment|/* Desperation time -- this probably will never happen.  */
if|if
condition|(
name|regs_ever_live
index|[
name|LAST_ARG_REGNUM
index|]
operator|||
operator|!
name|call_used_regs
index|[
name|LAST_ARG_REGNUM
index|]
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
name|LAST_ARG_REGNUM
expr_stmt|;
block|}
while|while
condition|(
name|high_regs_pushed
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|regno
operator|=
name|LAST_LO_REGNUM
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|regno
argument_list|,
name|next_hi_reg
argument_list|)
expr_stmt|;
name|high_regs_pushed
operator|--
expr_stmt|;
if|if
condition|(
name|high_regs_pushed
condition|)
for|for
control|(
name|next_hi_reg
operator|--
init|;
name|next_hi_reg
operator|>
name|LAST_LO_REGNUM
condition|;
name|next_hi_reg
operator|--
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|next_hi_reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|next_hi_reg
index|]
operator|&&
operator|!
operator|(
name|TARGET_SINGLE_PIC_BASE
operator|&&
operator|(
name|next_hi_reg
operator|==
name|arm_pic_register
operator|)
operator|)
condition|)
break|break;
block|}
else|else
block|{
name|mask
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|regno
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pushable_regs
operator|==
literal|0
operator|&&
operator|(
name|regs_ever_live
index|[
name|LAST_ARG_REGNUM
index|]
operator|||
operator|!
name|call_used_regs
index|[
name|LAST_ARG_REGNUM
index|]
operator|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LAST_ARG_REGNUM
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the case of a double word load into a low register from    a computed memory address.  The computed address may involve a    register which is overwritten by the load.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|thumb_load_double_from_address
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|addr
decl_stmt|;
name|rtx
name|base
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|rtx
name|arg1
decl_stmt|;
name|rtx
name|arg2
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the memory address.  */
name|addr
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Work out how the memory address is computed.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST
case|:
comment|/* Compute<address> + 4 for the high order load.  */
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|arg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|arg1
argument_list|)
condition|)
name|base
operator|=
name|arg2
operator|,
name|offset
operator|=
name|arg1
expr_stmt|;
else|else
name|base
operator|=
name|arg1
operator|,
name|offset
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Catch the case of<address> =<reg> +<reg> */
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|reg_offset
init|=
name|REGNO
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|int
name|reg_base
init|=
name|REGNO
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|int
name|reg_dest
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* Add the base and offset registers together into the              higher destination register.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tadd\t%r, %r, %r"
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|,
name|reg_base
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
comment|/* Load the lower destination register from the address in              the higher destination register.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tldr\t%r, [%r, #0]"
argument_list|,
name|reg_dest
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Load the higher destination register from its own address              plus 4.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tldr\t%r, [%r, #4]"
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute<address> + 4 for the high order load.  */
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the computed address is held in the low order register 	     then load the high order register first, otherwise always 	     load the low order register first.  */
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LABEL_REF
case|:
comment|/* With no registers to worry about we can just load the value          directly.  */
name|operands
index|[
literal|2
index|]
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|thumb_output_move_mem_multiple
parameter_list|(
name|n
parameter_list|,
name|operands
parameter_list|)
name|int
name|n
decl_stmt|;
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|tmp
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"ldmia\t%1!, {%4, %5}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stmia\t%0!, {%4, %5}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|6
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|operands
index|[
literal|6
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"ldmia\t%1!, {%4, %5, %6}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stmia\t%0!, {%4, %5, %6}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Routines for generating rtl.  */
end_comment

begin_function
name|void
name|thumb_expand_movstrqi
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|rtx
name|out
init|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|in
init|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|len
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|12
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movmem12b
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|12
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movmem8b
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|SImode
argument_list|,
name|out
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|2
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|in
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|out
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|in
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|out
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|thumb_cmp_operand
parameter_list|(
name|op
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|op
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|op
argument_list|)
argument_list|)
operator|<
literal|256
operator|)
operator|||
name|register_operand
argument_list|(
name|op
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|thumb_condition_code
parameter_list|(
name|x
parameter_list|,
name|invert
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|invert
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|conds
index|[]
init|=
block|{
literal|"eq"
block|,
literal|"ne"
block|,
literal|"cs"
block|,
literal|"cc"
block|,
literal|"mi"
block|,
literal|"pl"
block|,
literal|"vs"
block|,
literal|"vc"
block|,
literal|"hi"
block|,
literal|"ls"
block|,
literal|"ge"
block|,
literal|"lt"
block|,
literal|"gt"
block|,
literal|"le"
block|}
decl_stmt|;
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|EQ
case|:
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|val
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|GEU
case|:
name|val
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|LTU
case|:
name|val
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|GTU
case|:
name|val
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|LEU
case|:
name|val
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|val
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|val
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|val
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|val
operator|=
literal|13
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|conds
index|[
name|val
operator|^
name|invert
index|]
return|;
block|}
end_function

begin_comment
comment|/* Handle storing a half-word to memory during reload.  */
end_comment

begin_function
name|void
name|thumb_reload_out_hi
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
decl_stmt|;
block|{
name|emit_insn
argument_list|(
name|gen_thumb_movhi_clobber
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle storing a half-word to memory during reload.  */
end_comment

begin_function
name|void
name|thumb_reload_in_hi
parameter_list|(
name|operands
parameter_list|)
name|rtx
modifier|*
name|operands
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the length of a function name prefix     that starts with the character 'c'.  */
end_comment

begin_function
specifier|static
name|int
name|arm_get_strip_length
parameter_list|(
name|char
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
name|ARM_NAME_ENCODING_LENGTHS
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to a function's name with any    and all prefix encodings stripped from it.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|arm_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|skip
decl_stmt|;
while|while
condition|(
operator|(
name|skip
operator|=
name|arm_get_strip_length
argument_list|(
operator|*
name|name
argument_list|)
operator|)
condition|)
name|name
operator|+=
name|skip
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
end_ifdef

begin_comment
comment|/* Special functions only needed when producing AOF syntax assembler.  */
end_comment

begin_decl_stmt
name|rtx
name|aof_pic_label
init|=
name|NULL_RTX
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pic_chain
block|{
name|struct
name|pic_chain
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pic_chain
modifier|*
name|aof_pic_chain
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|rtx
name|aof_pic_entry
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|pic_chain
modifier|*
modifier|*
name|chainp
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|aof_pic_label
operator|==
name|NULL_RTX
condition|)
block|{
comment|/* We mark this here and not in arm_add_gc_roots() to avoid 	 polluting even more code with ifdefs, and because it never 	 contains anything useful until we assign to it here.  */
name|ggc_add_rtx_root
argument_list|(
operator|&
name|aof_pic_label
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|aof_pic_label
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"x$adcons"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|chainp
operator|=
operator|&
name|aof_pic_chain
init|;
operator|*
name|chainp
condition|;
name|offset
operator|+=
literal|4
operator|,
name|chainp
operator|=
operator|&
operator|(
operator|*
name|chainp
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|chainp
operator|)
operator|->
name|symname
operator|==
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|plus_constant
argument_list|(
name|aof_pic_label
argument_list|,
name|offset
argument_list|)
return|;
operator|*
name|chainp
operator|=
operator|(
expr|struct
name|pic_chain
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pic_chain
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|chainp
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|chainp
operator|)
operator|->
name|symname
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|aof_pic_label
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|aof_dump_pic_table
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|struct
name|pic_chain
modifier|*
name|chain
decl_stmt|;
if|if
condition|(
name|aof_pic_chain
operator|==
name|NULL
condition|)
return|return;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tAREA |%r$$adcons|, BASED %r\n"
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"|x$adcons|\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|aof_pic_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|fputs
argument_list|(
literal|"\tDCD\t"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|f
argument_list|,
name|chain
operator|->
name|symname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|arm_text_section_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|aof_text_section
parameter_list|()
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\tAREA |C$$code%d|, CODE, READONLY"
argument_list|,
name|arm_text_section_count
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|", PIC, REENTRANT"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|arm_data_section_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|aof_data_section
parameter_list|()
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\tAREA |C$$data%d|, DATA"
argument_list|,
name|arm_data_section_count
operator|++
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* The AOF assembler is religiously strict about declarations of    imported and exported symbols, so that it is impossible to declare    a function as imported near the beginning of the file, and then to    export it later on.  It is, however, possible to delay the decision    until all the functions in the file have been compiled.  To get    around this, we maintain a list of the imports and exports, and    delete from it any that are subsequently defined.  At the end of    compilation we spit the remainder of the list out before the END    directive.  */
end_comment

begin_struct
struct|struct
name|import
block|{
name|struct
name|import
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|import
modifier|*
name|imports_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|aof_add_import
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|import
modifier|*
name|new
decl_stmt|;
for|for
control|(
name|new
operator|=
name|imports_list
init|;
name|new
condition|;
name|new
operator|=
name|new
operator|->
name|next
control|)
if|if
condition|(
name|new
operator|->
name|name
operator|==
name|name
condition|)
return|return;
name|new
operator|=
operator|(
expr|struct
name|import
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|import
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|imports_list
expr_stmt|;
name|imports_list
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aof_delete_import
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|import
modifier|*
modifier|*
name|old
decl_stmt|;
for|for
control|(
name|old
operator|=
operator|&
name|imports_list
init|;
operator|*
name|old
condition|;
name|old
operator|=
operator|&
operator|(
operator|*
name|old
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|old
operator|)
operator|->
name|name
operator|==
name|name
condition|)
block|{
operator|*
name|old
operator|=
operator|(
operator|*
name|old
operator|)
operator|->
name|next
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|int
name|arm_main_function
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|aof_dump_imports
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
comment|/* The AOF assembler needs this to cause the startup code to be extracted      from the library.  Brining in __main causes the whole thing to work      automagically.  */
if|if
condition|(
name|arm_main_function
condition|)
block|{
name|text_section
argument_list|()
expr_stmt|;
name|fputs
argument_list|(
literal|"\tIMPORT __main\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tDCD __main\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* Now dump the remaining imports.  */
while|while
condition|(
name|imports_list
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\tIMPORT\t"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|f
argument_list|,
name|imports_list
operator|->
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|imports_list
operator|=
name|imports_list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AOF_ASSEMBLER */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_comment
comment|/* Switch to an arbitrary section NAME with attributes as specified    by FLAGS.  ALIGN specifies any known alignment requirements for    the section; 0 if the default should be used.     Differs from the default elf version only in the prefix character    used before the section type.  */
end_comment

begin_function
specifier|static
name|void
name|arm_elf_asm_named_section
parameter_list|(
name|name
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
name|char
name|flagchars
index|[
literal|8
index|]
decl_stmt|,
modifier|*
name|f
init|=
name|flagchars
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SECTION_DEBUG
operator|)
condition|)
operator|*
name|f
operator|++
operator|=
literal|'a'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_WRITE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_CODE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'x'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_SMALL
condition|)
operator|*
name|f
operator|++
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_MERGE
condition|)
operator|*
name|f
operator|++
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_STRINGS
condition|)
operator|*
name|f
operator|++
operator|=
literal|'S'
expr_stmt|;
operator|*
name|f
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_BSS
condition|)
name|type
operator|=
literal|"nobits"
expr_stmt|;
else|else
name|type
operator|=
literal|"progbits"
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SECTION_ENTSIZE
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\",%%%s,%d\n"
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|,
name|type
argument_list|,
name|flags
operator|&
name|SECTION_ENTSIZE
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.section\t%s,\"%s\",%%%s\n"
argument_list|,
name|name
argument_list|,
name|flagchars
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

