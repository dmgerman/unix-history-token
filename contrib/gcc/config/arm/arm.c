begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output routines for GCC for ARM.    Copyright (C) 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002, 2003, 2004, 2005, 2006  Free Software Foundation, Inc.    Contributed by Pieter `Tiggr' Schoenmakers (rcpieter@win.tue.nl)    and Martin Simmons (@harleqn.co.uk).    More major hacks by Richard Earnshaw (rearnsha@arm.com).     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published    by the Free Software Foundation; either version 2, or (at your    option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public    License for more details.     You should have received a copy of the GNU General Public License    along with GCC; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street, Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"conditions.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"insn-attr.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"integrate.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"target-def.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_comment
comment|/* Forward definitions of types.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|minipool_node
name|Mnode
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|minipool_fixup
name|Mfix
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|arm_attribute_table
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward function declarations.  */
end_comment

begin_function_decl
specifier|static
name|arm_stack_offsets
modifier|*
name|arm_get_frame_offsets
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_add_gc_roots
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_gen_constant
parameter_list|(
name|enum
name|rtx_code
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|bit_count
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_address_register_rtx_p
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_legitimate_index_p
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|RTX_CODE
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|thumb_base_register_rtx_p
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|inline
specifier|static
name|int
name|thumb_index_register_rtx_p
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|thumb_far_jump_used_p
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|thumb_force_lr_save
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|const_ok_for_op
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|emit_sfm
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_size_return_regs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
end_ifndef

begin_function_decl
specifier|static
name|bool
name|arm_assemble_integer
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|fp_const_from_val
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arm_cc
name|get_arm_condition_code
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|int_log2
parameter_list|(
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|is_jump_table
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|output_multi_immediate
parameter_list|(
name|rtx
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|shift_op
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|machine_function
modifier|*
name|arm_init_machine_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thumb_exit
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|is_jump_table
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|get_jump_table_size
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_forward_ref
parameter_list|(
name|Mnode
modifier|*
parameter_list|,
name|Mnode
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Mnode
modifier|*
name|add_minipool_forward_ref
parameter_list|(
name|Mfix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_backward_ref
parameter_list|(
name|Mnode
modifier|*
parameter_list|,
name|Mnode
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Mnode
modifier|*
name|add_minipool_backward_ref
parameter_list|(
name|Mfix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|assign_minipool_offsets
parameter_list|(
name|Mfix
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_print_value
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_minipool
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_barrier_cost
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Mfix
modifier|*
name|create_fix_barrier
parameter_list|(
name|Mfix
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_minipool_barrier
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_minipool_fix
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|rtx
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_reorg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|note_invalid_constants
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|current_file_function_operand
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|arm_compute_save_reg0_reg12_mask
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|arm_compute_save_reg_mask
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|arm_isr_value
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|arm_compute_func_type
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|arm_handle_fndecl_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|arm_handle_isr_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
end_if

begin_function_decl
specifier|static
name|tree
name|arm_handle_notshared_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|arm_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_output_function_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thumb_output_function_prologue
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_comp_type_attributes
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_set_default_type_attributes
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_adjust_cost
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_insns_for_constant
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_get_strip_length
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_function_ok_for_sibcall
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_internal_label
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|HOST_WIDE_INT
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_rtx_costs_1
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|enum
name|rtx_code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_size_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_slowmul_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_fastmul_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_xscale_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_9e_rtx_costs
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_address_cost
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_memory_load_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_cirrus_insn_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cirrus_reorg
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_init_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|arm_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_init_iwmmxt_builtins
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|safe_vector_operand
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|arm_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|arm_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
parameter_list|,
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|arm_expand_builtin
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_constant_insn
parameter_list|(
name|rtx
name|cond
parameter_list|,
name|rtx
name|pattern
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|emit_set_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arm_arg_partial_bytes
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_function_decl
specifier|static
name|void
name|arm_elf_asm_constructor
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ARM_PE
end_ifndef

begin_function_decl
specifier|static
name|void
name|arm_encode_section_info
parameter_list|(
name|tree
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|arm_file_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
end_ifdef

begin_function_decl
specifier|static
name|void
name|aof_globalize_label
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aof_dump_imports
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aof_dump_pic_table
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aof_file_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aof_file_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aof_asm_init_sections
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|arm_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_promote_prototypes
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_default_short_enums
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_align_anon_bitfield
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_return_in_msb
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_must_pass_in_stack
parameter_list|(
name|enum
name|machine_mode
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_UNWIND_INFO
end_ifdef

begin_function_decl
specifier|static
name|void
name|arm_unwind_emit
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_output_ttype
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|tree
name|arm_cxx_guard_type
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_cxx_guard_mask_bit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|arm_get_cookie_size
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_cookie_has_size
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_cxx_cdtor_returns_this
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_cxx_key_method_may_be_inline
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_cxx_determine_class_data_visibility
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_cxx_class_data_always_comdat
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_cxx_use_aeabi_atexit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arm_init_libfuncs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_handle_option
parameter_list|(
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|arm_shift_truncation_mask
parameter_list|(
name|enum
name|machine_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_cannot_copy_insn_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arm_tls_symbol_p
parameter_list|(
name|rtx
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Initialize the GCC target structure.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
end_if

begin_undef
undef|#
directive|undef
name|TARGET_MERGE_DECL_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_MERGE_DECL_ATTRIBUTES
value|merge_dllimport_decl_attributes
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ATTRIBUTE_TABLE
end_undef

begin_define
define|#
directive|define
name|TARGET_ATTRIBUTE_TABLE
value|arm_attribute_table
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START
value|arm_file_start
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_END
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_END
value|arm_file_end
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_ASM_BYTE_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_BYTE_OP
value|"\tDCB\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_HI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_HI_OP
value|"\tDCW\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|"\tDCD\t"
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_GLOBALIZE_LABEL
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_GLOBALIZE_LABEL
value|aof_globalize_label
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_START
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_START
value|aof_file_start
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FILE_END
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FILE_END
value|aof_file_end
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|TARGET_ASM_ALIGNED_SI_OP
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_ALIGNED_SI_OP
value|NULL
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTEGER
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTEGER
value|arm_assemble_integer
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_PROLOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_PROLOGUE
value|arm_output_function_prologue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_FUNCTION_EPILOGUE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_FUNCTION_EPILOGUE
value|arm_output_function_epilogue
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DEFAULT_TARGET_FLAGS
end_undef

begin_define
define|#
directive|define
name|TARGET_DEFAULT_TARGET_FLAGS
value|(TARGET_DEFAULT | MASK_SCHED_PROLOG)
end_define

begin_undef
undef|#
directive|undef
name|TARGET_HANDLE_OPTION
end_undef

begin_define
define|#
directive|define
name|TARGET_HANDLE_OPTION
value|arm_handle_option
end_define

begin_undef
undef|#
directive|undef
name|TARGET_COMP_TYPE_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_COMP_TYPE_ATTRIBUTES
value|arm_comp_type_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SET_DEFAULT_TYPE_ATTRIBUTES
end_undef

begin_define
define|#
directive|define
name|TARGET_SET_DEFAULT_TYPE_ATTRIBUTES
value|arm_set_default_type_attributes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SCHED_ADJUST_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_SCHED_ADJUST_COST
value|arm_adjust_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ENCODE_SECTION_INFO
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|ARM_PE
end_ifdef

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|arm_pe_encode_section_info
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TARGET_ENCODE_SECTION_INFO
value|arm_encode_section_info
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_STRIP_NAME_ENCODING
end_undef

begin_define
define|#
directive|define
name|TARGET_STRIP_NAME_ENCODING
value|arm_strip_name_encoding
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_INTERNAL_LABEL
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_INTERNAL_LABEL
value|arm_internal_label
end_define

begin_undef
undef|#
directive|undef
name|TARGET_FUNCTION_OK_FOR_SIBCALL
end_undef

begin_define
define|#
directive|define
name|TARGET_FUNCTION_OK_FOR_SIBCALL
value|arm_function_ok_for_sibcall
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_OUTPUT_MI_THUNK
value|arm_output_mi_thunk
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_CAN_OUTPUT_MI_THUNK
value|default_can_output_mi_thunk_no_vcall
end_define

begin_comment
comment|/* This will be overridden in arm_override_options.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_RTX_COSTS
end_undef

begin_define
define|#
directive|define
name|TARGET_RTX_COSTS
value|arm_slowmul_rtx_costs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ADDRESS_COST
end_undef

begin_define
define|#
directive|define
name|TARGET_ADDRESS_COST
value|arm_address_cost
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SHIFT_TRUNCATION_MASK
end_undef

begin_define
define|#
directive|define
name|TARGET_SHIFT_TRUNCATION_MASK
value|arm_shift_truncation_mask
end_define

begin_undef
undef|#
directive|undef
name|TARGET_VECTOR_MODE_SUPPORTED_P
end_undef

begin_define
define|#
directive|define
name|TARGET_VECTOR_MODE_SUPPORTED_P
value|arm_vector_mode_supported_p
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MACHINE_DEPENDENT_REORG
end_undef

begin_define
define|#
directive|define
name|TARGET_MACHINE_DEPENDENT_REORG
value|arm_reorg
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_BUILTINS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_BUILTINS
value|arm_init_builtins
end_define

begin_undef
undef|#
directive|undef
name|TARGET_EXPAND_BUILTIN
end_undef

begin_define
define|#
directive|define
name|TARGET_EXPAND_BUILTIN
value|arm_expand_builtin
end_define

begin_undef
undef|#
directive|undef
name|TARGET_INIT_LIBFUNCS
end_undef

begin_define
define|#
directive|define
name|TARGET_INIT_LIBFUNCS
value|arm_init_libfuncs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_ARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_ARGS
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_FUNCTION_RETURN
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_FUNCTION_RETURN
value|hook_bool_tree_true
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PROMOTE_PROTOTYPES
end_undef

begin_define
define|#
directive|define
name|TARGET_PROMOTE_PROTOTYPES
value|arm_promote_prototypes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_PASS_BY_REFERENCE
end_undef

begin_define
define|#
directive|define
name|TARGET_PASS_BY_REFERENCE
value|arm_pass_by_reference
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ARG_PARTIAL_BYTES
end_undef

begin_define
define|#
directive|define
name|TARGET_ARG_PARTIAL_BYTES
value|arm_arg_partial_bytes
end_define

begin_undef
undef|#
directive|undef
name|TARGET_SETUP_INCOMING_VARARGS
end_undef

begin_define
define|#
directive|define
name|TARGET_SETUP_INCOMING_VARARGS
value|arm_setup_incoming_varargs
end_define

begin_undef
undef|#
directive|undef
name|TARGET_DEFAULT_SHORT_ENUMS
end_undef

begin_define
define|#
directive|define
name|TARGET_DEFAULT_SHORT_ENUMS
value|arm_default_short_enums
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ALIGN_ANON_BITFIELD
end_undef

begin_define
define|#
directive|define
name|TARGET_ALIGN_ANON_BITFIELD
value|arm_align_anon_bitfield
end_define

begin_undef
undef|#
directive|undef
name|TARGET_NARROW_VOLATILE_BITFIELD
end_undef

begin_define
define|#
directive|define
name|TARGET_NARROW_VOLATILE_BITFIELD
value|hook_bool_void_false
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CXX_GUARD_TYPE
end_undef

begin_define
define|#
directive|define
name|TARGET_CXX_GUARD_TYPE
value|arm_cxx_guard_type
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CXX_GUARD_MASK_BIT
end_undef

begin_define
define|#
directive|define
name|TARGET_CXX_GUARD_MASK_BIT
value|arm_cxx_guard_mask_bit
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CXX_GET_COOKIE_SIZE
end_undef

begin_define
define|#
directive|define
name|TARGET_CXX_GET_COOKIE_SIZE
value|arm_get_cookie_size
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CXX_COOKIE_HAS_SIZE
end_undef

begin_define
define|#
directive|define
name|TARGET_CXX_COOKIE_HAS_SIZE
value|arm_cookie_has_size
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CXX_CDTOR_RETURNS_THIS
end_undef

begin_define
define|#
directive|define
name|TARGET_CXX_CDTOR_RETURNS_THIS
value|arm_cxx_cdtor_returns_this
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CXX_KEY_METHOD_MAY_BE_INLINE
end_undef

begin_define
define|#
directive|define
name|TARGET_CXX_KEY_METHOD_MAY_BE_INLINE
value|arm_cxx_key_method_may_be_inline
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CXX_USE_AEABI_ATEXIT
end_undef

begin_define
define|#
directive|define
name|TARGET_CXX_USE_AEABI_ATEXIT
value|arm_cxx_use_aeabi_atexit
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY
end_undef

begin_define
define|#
directive|define
name|TARGET_CXX_DETERMINE_CLASS_DATA_VISIBILITY
define|\
value|arm_cxx_determine_class_data_visibility
end_define

begin_undef
undef|#
directive|undef
name|TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT
end_undef

begin_define
define|#
directive|define
name|TARGET_CXX_CLASS_DATA_ALWAYS_COMDAT
value|arm_cxx_class_data_always_comdat
end_define

begin_undef
undef|#
directive|undef
name|TARGET_RETURN_IN_MSB
end_undef

begin_define
define|#
directive|define
name|TARGET_RETURN_IN_MSB
value|arm_return_in_msb
end_define

begin_undef
undef|#
directive|undef
name|TARGET_MUST_PASS_IN_STACK
end_undef

begin_define
define|#
directive|define
name|TARGET_MUST_PASS_IN_STACK
value|arm_must_pass_in_stack
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_UNWIND_INFO
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_UNWIND_EMIT
end_undef

begin_define
define|#
directive|define
name|TARGET_UNWIND_EMIT
value|arm_unwind_emit
end_define

begin_comment
comment|/* EABI unwinding tables use a different format for the typeinfo tables.  */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_ASM_TTYPE
end_undef

begin_define
define|#
directive|define
name|TARGET_ASM_TTYPE
value|arm_output_ttype
end_define

begin_undef
undef|#
directive|undef
name|TARGET_ARM_EABI_UNWINDER
end_undef

begin_define
define|#
directive|define
name|TARGET_ARM_EABI_UNWINDER
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_UNWIND_INFO */
end_comment

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_COPY_INSN_P
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_COPY_INSN_P
value|arm_cannot_copy_insn_p
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_TLS
end_ifdef

begin_undef
undef|#
directive|undef
name|TARGET_HAVE_TLS
end_undef

begin_define
define|#
directive|define
name|TARGET_HAVE_TLS
value|true
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|TARGET_CANNOT_FORCE_CONST_MEM
end_undef

begin_define
define|#
directive|define
name|TARGET_CANNOT_FORCE_CONST_MEM
value|arm_tls_referenced_p
end_define

begin_decl_stmt
name|struct
name|gcc_target
name|targetm
init|=
name|TARGET_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Obstack for minipool constant handling.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|minipool_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|minipool_startobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum number of insns skipped which    will be conditionalised if possible.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_insns_skipped
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we are currently building a constant table.  */
end_comment

begin_decl_stmt
name|int
name|making_const_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the information needed to generate branch insns.  This is    stored from the compare operation.  */
end_comment

begin_decl_stmt
name|rtx
name|arm_compare_op0
decl_stmt|,
name|arm_compare_op1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The processor for which instructions should be scheduled.  */
end_comment

begin_decl_stmt
name|enum
name|processor_type
name|arm_tune
init|=
name|arm_none
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default processor used if not overriden by commandline.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|processor_type
name|arm_default_cpu
init|=
name|arm_none
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which floating point model to use.  */
end_comment

begin_decl_stmt
name|enum
name|arm_fp_model
name|arm_fp_model
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which floating point hardware is available.  */
end_comment

begin_decl_stmt
name|enum
name|fputype
name|arm_fpu_arch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which floating point hardware to schedule for.  */
end_comment

begin_decl_stmt
name|enum
name|fputype
name|arm_fpu_tune
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to use floating point hardware.  */
end_comment

begin_decl_stmt
name|enum
name|float_abi_type
name|arm_float_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which ABI to use.  */
end_comment

begin_decl_stmt
name|enum
name|arm_abi_type
name|arm_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which thread pointer model to use.  */
end_comment

begin_decl_stmt
name|enum
name|arm_tp_type
name|target_thread_pointer
init|=
name|TP_AUTO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to parse -mstructure_size_boundary command line option.  */
end_comment

begin_decl_stmt
name|int
name|arm_structure_size_boundary
init|=
name|DEFAULT_STRUCTURE_SIZE_BOUNDARY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for Thumb call_via trampolines.  */
end_comment

begin_decl_stmt
name|rtx
name|thumb_call_via_label
index|[
literal|14
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|thumb_call_reg_needed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bit values used to identify processor capabilities.  */
end_comment

begin_define
define|#
directive|define
name|FL_CO_PROC
value|(1<< 0)
end_define

begin_comment
comment|/* Has external co-processor bus */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH3M
value|(1<< 1)
end_define

begin_comment
comment|/* Extended multiply */
end_comment

begin_define
define|#
directive|define
name|FL_MODE26
value|(1<< 2)
end_define

begin_comment
comment|/* 26-bit mode support */
end_comment

begin_define
define|#
directive|define
name|FL_MODE32
value|(1<< 3)
end_define

begin_comment
comment|/* 32-bit mode support */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH4
value|(1<< 4)
end_define

begin_comment
comment|/* Architecture rel 4 */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH5
value|(1<< 5)
end_define

begin_comment
comment|/* Architecture rel 5 */
end_comment

begin_define
define|#
directive|define
name|FL_THUMB
value|(1<< 6)
end_define

begin_comment
comment|/* Thumb aware */
end_comment

begin_define
define|#
directive|define
name|FL_LDSCHED
value|(1<< 7)
end_define

begin_comment
comment|/* Load scheduling necessary */
end_comment

begin_define
define|#
directive|define
name|FL_STRONG
value|(1<< 8)
end_define

begin_comment
comment|/* StrongARM */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH5E
value|(1<< 9)
end_define

begin_comment
comment|/* DSP extensions to v5 */
end_comment

begin_define
define|#
directive|define
name|FL_XSCALE
value|(1<< 10)
end_define

begin_comment
comment|/* XScale */
end_comment

begin_define
define|#
directive|define
name|FL_CIRRUS
value|(1<< 11)
end_define

begin_comment
comment|/* Cirrus/DSP.  */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH6
value|(1<< 12)
end_define

begin_comment
comment|/* Architecture rel 6.  Adds 					 media instructions.  */
end_comment

begin_define
define|#
directive|define
name|FL_VFPV2
value|(1<< 13)
end_define

begin_comment
comment|/* Vector Floating Point V2.  */
end_comment

begin_define
define|#
directive|define
name|FL_WBUF
value|(1<< 14)
end_define

begin_comment
comment|/* Schedule for write buffer ops. 					 Note: ARM6& 7 derivatives only.  */
end_comment

begin_define
define|#
directive|define
name|FL_ARCH6K
value|(1<< 15)
end_define

begin_comment
comment|/* Architecture rel 6 K extensions.  */
end_comment

begin_define
define|#
directive|define
name|FL_IWMMXT
value|(1<< 29)
end_define

begin_comment
comment|/* XScale v2 or "Intel Wireless MMX technology".  */
end_comment

begin_define
define|#
directive|define
name|FL_FOR_ARCH2
value|0
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH3
value|FL_MODE32
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH3M
value|(FL_FOR_ARCH3 | FL_ARCH3M)
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH4
value|(FL_FOR_ARCH3M | FL_ARCH4)
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH4T
value|(FL_FOR_ARCH4 | FL_THUMB)
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH5
value|(FL_FOR_ARCH4 | FL_ARCH5)
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH5T
value|(FL_FOR_ARCH5 | FL_THUMB)
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH5E
value|(FL_FOR_ARCH5 | FL_ARCH5E)
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH5TE
value|(FL_FOR_ARCH5E | FL_THUMB)
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH5TEJ
value|FL_FOR_ARCH5TE
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH6
value|(FL_FOR_ARCH5TE | FL_ARCH6)
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH6J
value|FL_FOR_ARCH6
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH6K
value|(FL_FOR_ARCH6 | FL_ARCH6K)
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH6Z
value|FL_FOR_ARCH6
end_define

begin_define
define|#
directive|define
name|FL_FOR_ARCH6ZK
value|FL_FOR_ARCH6K
end_define

begin_comment
comment|/* The bits in this mask specify which    instructions we are allowed to generate.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|insn_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The bits in this mask specify which instruction scheduling options should    be used.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|tune_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following are used in the arm.md file as equivalents to bits    in the above two flag variables.  */
end_comment

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 3M extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch3m
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 4 extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch4
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 4t extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch4t
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 5 extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch5
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 5E extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch5e
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM Architecture 6 extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch6
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports the ARM 6K extensions.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch6k
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip can benefit from load scheduling.  */
end_comment

begin_decl_stmt
name|int
name|arm_ld_sched
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip is a StrongARM.  */
end_comment

begin_decl_stmt
name|int
name|arm_tune_strongarm
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip is a Cirrus variant.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch_cirrus
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip supports Intel Wireless MMX technology.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch_iwmmxt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if this chip is an XScale.  */
end_comment

begin_decl_stmt
name|int
name|arm_arch_xscale
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if tuning for XScale  */
end_comment

begin_decl_stmt
name|int
name|arm_tune_xscale
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to tune for stores that access the write-buffer.    This typically means an ARM6 or ARM7 with MMU or MPU.  */
end_comment

begin_decl_stmt
name|int
name|arm_tune_wbuf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if generating Thumb instructions.  */
end_comment

begin_decl_stmt
name|int
name|thumb_code
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should define __THUMB_INTERWORK__ in the    preprocessor.    XXX This is a bit of a hack, it's intended to help work around    problems in GLD which doesn't understand that armv5t code is    interworking clean.  */
end_comment

begin_decl_stmt
name|int
name|arm_cpp_interwork
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In case of a PRE_INC, POST_INC, PRE_DEC, POST_DEC memory reference, we    must report the mode of the memory reference from PRINT_OPERAND to    PRINT_OPERAND_ADDRESS.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|output_memory_reference_mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The register number to be used for the PIC offset register.  */
end_comment

begin_decl_stmt
name|unsigned
name|arm_pic_register
init|=
name|INVALID_REGNUM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 when a return insn is output, this means that the epilogue    is not needed.  */
end_comment

begin_decl_stmt
name|int
name|return_used_this_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 after arm_reorg has started.  Reset to start at the start of    the next function.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|after_arm_reorg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum number of insns to be used when loading a constant.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arm_constant_limit
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For an explanation of these variables, see final_prescan_insn below.  */
end_comment

begin_decl_stmt
name|int
name|arm_ccfsm_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|arm_cond_code
name|arm_current_cc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rtx
name|arm_target_insn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arm_target_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The condition codes of the ARM, and the inverse function.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|arm_condition_codes
index|[]
init|=
block|{
literal|"eq"
block|,
literal|"ne"
block|,
literal|"cs"
block|,
literal|"cc"
block|,
literal|"mi"
block|,
literal|"pl"
block|,
literal|"vs"
block|,
literal|"vc"
block|,
literal|"hi"
block|,
literal|"ls"
block|,
literal|"ge"
block|,
literal|"lt"
block|,
literal|"gt"
block|,
literal|"le"
block|,
literal|"al"
block|,
literal|"nv"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|streq
parameter_list|(
name|string1
parameter_list|,
name|string2
parameter_list|)
value|(strcmp (string1, string2) == 0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialization code.  */
end_comment

begin_struct
struct|struct
name|processors
block|{
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
name|enum
name|processor_type
name|core
decl_stmt|;
specifier|const
name|char
modifier|*
name|arch
decl_stmt|;
specifier|const
name|unsigned
name|long
name|flags
decl_stmt|;
name|bool
function_decl|(
modifier|*
name|rtx_costs
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Not all of these give usefully different compilation alternatives,    but there is no simple way of generalizing them.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processors
name|all_cores
index|[]
init|=
block|{
comment|/* ARM Cores */
define|#
directive|define
name|ARM_CORE
parameter_list|(
name|NAME
parameter_list|,
name|IDENT
parameter_list|,
name|ARCH
parameter_list|,
name|FLAGS
parameter_list|,
name|COSTS
parameter_list|)
define|\
value|{NAME, arm_none, #ARCH, FLAGS | FL_FOR_ARCH##ARCH, arm_##COSTS##_rtx_costs},
include|#
directive|include
file|"arm-cores.def"
undef|#
directive|undef
name|ARM_CORE
block|{
name|NULL
block|,
name|arm_none
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|processors
name|all_architectures
index|[]
init|=
block|{
comment|/* ARM Architectures */
comment|/* We don't specify rtx_costs here as it will be figured out      from the core.  */
block|{
literal|"armv2"
block|,
name|arm2
block|,
literal|"2"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_FOR_ARCH2
block|,
name|NULL
block|}
block|,
block|{
literal|"armv2a"
block|,
name|arm2
block|,
literal|"2"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_FOR_ARCH2
block|,
name|NULL
block|}
block|,
block|{
literal|"armv3"
block|,
name|arm6
block|,
literal|"3"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_FOR_ARCH3
block|,
name|NULL
block|}
block|,
block|{
literal|"armv3m"
block|,
name|arm7m
block|,
literal|"3M"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_FOR_ARCH3M
block|,
name|NULL
block|}
block|,
block|{
literal|"armv4"
block|,
name|arm7tdmi
block|,
literal|"4"
block|,
name|FL_CO_PROC
operator||
name|FL_MODE26
operator||
name|FL_FOR_ARCH4
block|,
name|NULL
block|}
block|,
comment|/* Strictly, FL_MODE26 is a permitted option for v4t, but there are no      implementations that support it, so we will leave it out for now.  */
block|{
literal|"armv4t"
block|,
name|arm7tdmi
block|,
literal|"4T"
block|,
name|FL_CO_PROC
operator||
name|FL_FOR_ARCH4T
block|,
name|NULL
block|}
block|,
block|{
literal|"armv5"
block|,
name|arm10tdmi
block|,
literal|"5"
block|,
name|FL_CO_PROC
operator||
name|FL_FOR_ARCH5
block|,
name|NULL
block|}
block|,
block|{
literal|"armv5t"
block|,
name|arm10tdmi
block|,
literal|"5T"
block|,
name|FL_CO_PROC
operator||
name|FL_FOR_ARCH5T
block|,
name|NULL
block|}
block|,
block|{
literal|"armv5e"
block|,
name|arm1026ejs
block|,
literal|"5E"
block|,
name|FL_CO_PROC
operator||
name|FL_FOR_ARCH5E
block|,
name|NULL
block|}
block|,
block|{
literal|"armv5te"
block|,
name|arm1026ejs
block|,
literal|"5TE"
block|,
name|FL_CO_PROC
operator||
name|FL_FOR_ARCH5TE
block|,
name|NULL
block|}
block|,
block|{
literal|"armv6"
block|,
name|arm1136js
block|,
literal|"6"
block|,
name|FL_CO_PROC
operator||
name|FL_FOR_ARCH6
block|,
name|NULL
block|}
block|,
block|{
literal|"armv6j"
block|,
name|arm1136js
block|,
literal|"6J"
block|,
name|FL_CO_PROC
operator||
name|FL_FOR_ARCH6J
block|,
name|NULL
block|}
block|,
block|{
literal|"armv6k"
block|,
name|mpcore
block|,
literal|"6K"
block|,
name|FL_CO_PROC
operator||
name|FL_FOR_ARCH6K
block|,
name|NULL
block|}
block|,
block|{
literal|"armv6z"
block|,
name|arm1176jzs
block|,
literal|"6Z"
block|,
name|FL_CO_PROC
operator||
name|FL_FOR_ARCH6Z
block|,
name|NULL
block|}
block|,
block|{
literal|"armv6zk"
block|,
name|arm1176jzs
block|,
literal|"6ZK"
block|,
name|FL_CO_PROC
operator||
name|FL_FOR_ARCH6ZK
block|,
name|NULL
block|}
block|,
block|{
literal|"ep9312"
block|,
name|ep9312
block|,
literal|"4T"
block|,
name|FL_LDSCHED
operator||
name|FL_CIRRUS
operator||
name|FL_FOR_ARCH4
block|,
name|NULL
block|}
block|,
block|{
literal|"iwmmxt"
block|,
name|iwmmxt
block|,
literal|"5TE"
block|,
name|FL_LDSCHED
operator||
name|FL_STRONG
operator||
name|FL_FOR_ARCH5TE
operator||
name|FL_XSCALE
operator||
name|FL_IWMMXT
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
name|arm_none
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|arm_cpu_select
block|{
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|processors
modifier|*
name|processors
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is a magic structure.  The 'string' field is magically filled in    with a pointer to the value specified by the user on the command line    assuming that the user has specified such a value.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arm_cpu_select
name|arm_select
index|[]
init|=
block|{
comment|/* string	  name            processors  */
block|{
name|NULL
block|,
literal|"-mcpu="
block|,
name|all_cores
block|}
block|,
block|{
name|NULL
block|,
literal|"-march="
block|,
name|all_architectures
block|}
block|,
block|{
name|NULL
block|,
literal|"-mtune="
block|,
name|all_cores
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defines representing the indexes into the above table.  */
end_comment

begin_define
define|#
directive|define
name|ARM_OPT_SET_CPU
value|0
end_define

begin_define
define|#
directive|define
name|ARM_OPT_SET_ARCH
value|1
end_define

begin_define
define|#
directive|define
name|ARM_OPT_SET_TUNE
value|2
end_define

begin_comment
comment|/* The name of the preprocessor macro to define for this architecture.  */
end_comment

begin_decl_stmt
name|char
name|arm_arch_name
index|[]
init|=
literal|"__ARM_ARCH_0UNK__"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fpu_desc
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|fputype
name|fpu
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Available values for -mfpu=.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|fpu_desc
name|all_fpus
index|[]
init|=
block|{
block|{
literal|"fpa"
block|,
name|FPUTYPE_FPA
block|}
block|,
block|{
literal|"fpe2"
block|,
name|FPUTYPE_FPA_EMU2
block|}
block|,
block|{
literal|"fpe3"
block|,
name|FPUTYPE_FPA_EMU2
block|}
block|,
block|{
literal|"maverick"
block|,
name|FPUTYPE_MAVERICK
block|}
block|,
block|{
literal|"vfp"
block|,
name|FPUTYPE_VFP
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Floating point models used by the different hardware.    See fputype in arm.h.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|enum
name|fputype
name|fp_model_for_fpu
index|[]
init|=
block|{
comment|/* No FP hardware.  */
name|ARM_FP_MODEL_UNKNOWN
block|,
comment|/* FPUTYPE_NONE  */
name|ARM_FP_MODEL_FPA
block|,
comment|/* FPUTYPE_FPA  */
name|ARM_FP_MODEL_FPA
block|,
comment|/* FPUTYPE_FPA_EMU2  */
name|ARM_FP_MODEL_FPA
block|,
comment|/* FPUTYPE_FPA_EMU3  */
name|ARM_FP_MODEL_MAVERICK
block|,
comment|/* FPUTYPE_MAVERICK  */
name|ARM_FP_MODEL_VFP
comment|/* FPUTYPE_VFP  */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|float_abi
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|float_abi_type
name|abi_type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Available values for -mfloat-abi=.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|float_abi
name|all_float_abis
index|[]
init|=
block|{
block|{
literal|"soft"
block|,
name|ARM_FLOAT_ABI_SOFT
block|}
block|,
block|{
literal|"softfp"
block|,
name|ARM_FLOAT_ABI_SOFTFP
block|}
block|,
block|{
literal|"hard"
block|,
name|ARM_FLOAT_ABI_HARD
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|abi_name
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|arm_abi_type
name|abi_type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Available values for -mabi=.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|abi_name
name|arm_all_abis
index|[]
init|=
block|{
block|{
literal|"apcs-gnu"
block|,
name|ARM_ABI_APCS
block|}
block|,
block|{
literal|"atpcs"
block|,
name|ARM_ABI_ATPCS
block|}
block|,
block|{
literal|"aapcs"
block|,
name|ARM_ABI_AAPCS
block|}
block|,
block|{
literal|"iwmmxt"
block|,
name|ARM_ABI_IWMMXT
block|}
block|,
block|{
literal|"aapcs-linux"
block|,
name|ARM_ABI_AAPCS_LINUX
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Supported TLS relocations.  */
end_comment

begin_enum
enum|enum
name|tls_reloc
block|{
name|TLS_GD32
block|,
name|TLS_LDM32
block|,
name|TLS_LDO32
block|,
name|TLS_IE32
block|,
name|TLS_LE32
block|}
enum|;
end_enum

begin_comment
comment|/* Emit an insn that's a simple single-set.  Both the operands must be known    to be valid.  */
end_comment

begin_function
specifier|inline
specifier|static
name|rtx
name|emit_set_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
return|return
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bits set in VALUE.  */
end_comment

begin_function
specifier|static
name|unsigned
name|bit_count
parameter_list|(
name|unsigned
name|long
name|value
parameter_list|)
block|{
name|unsigned
name|long
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|value
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|value
operator|&=
name|value
operator|-
literal|1
expr_stmt|;
comment|/* Clear the least-significant set bit.  */
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Set up library functions unique to ARM.  */
end_comment

begin_function
specifier|static
name|void
name|arm_init_libfuncs
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* There are no special library functions unless we are using the      ARM BPABI.  */
if|if
condition|(
operator|!
name|TARGET_BPABI
condition|)
return|return;
comment|/* The functions below are described in Section 4 of the "Run-Time      ABI for the ARM architecture", Version 1.0.  */
comment|/* Double-precision floating-point arithmetic.  Table 2.  */
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_dadd"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_ddiv"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_dmul"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|neg_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_dneg"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_dsub"
argument_list|)
expr_stmt|;
comment|/* Double-precision comparisons.  Table 3.  */
name|set_optab_libfunc
argument_list|(
name|eq_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_dcmpeq"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ne_optab
argument_list|,
name|DFmode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lt_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_dcmplt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|le_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_dcmple"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ge_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_dcmpge"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|gt_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_dcmpgt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|unord_optab
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_dcmpun"
argument_list|)
expr_stmt|;
comment|/* Single-precision floating-point arithmetic.  Table 4.  */
name|set_optab_libfunc
argument_list|(
name|add_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_fadd"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_fdiv"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_fmul"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|neg_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_fneg"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sub_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_fsub"
argument_list|)
expr_stmt|;
comment|/* Single-precision comparisons.  Table 5.  */
name|set_optab_libfunc
argument_list|(
name|eq_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_fcmpeq"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ne_optab
argument_list|,
name|SFmode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lt_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_fcmplt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|le_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_fcmple"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ge_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_fcmpge"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|gt_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_fcmpgt"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|unord_optab
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_fcmpun"
argument_list|)
expr_stmt|;
comment|/* Floating-point to integer conversions.  Table 6.  */
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_d2iz"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_d2uiz"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|DImode
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_d2lz"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|DImode
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_d2ulz"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|SImode
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_f2iz"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|SImode
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_f2uiz"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfix_optab
argument_list|,
name|DImode
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_f2lz"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufix_optab
argument_list|,
name|DImode
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_f2ulz"
argument_list|)
expr_stmt|;
comment|/* Conversions between floating types.  Table 7.  */
name|set_conv_libfunc
argument_list|(
name|trunc_optab
argument_list|,
name|SFmode
argument_list|,
name|DFmode
argument_list|,
literal|"__aeabi_d2f"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sext_optab
argument_list|,
name|DFmode
argument_list|,
name|SFmode
argument_list|,
literal|"__aeabi_f2d"
argument_list|)
expr_stmt|;
comment|/* Integer to floating-point conversions.  Table 8.  */
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|DFmode
argument_list|,
name|SImode
argument_list|,
literal|"__aeabi_i2d"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufloat_optab
argument_list|,
name|DFmode
argument_list|,
name|SImode
argument_list|,
literal|"__aeabi_ui2d"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|DFmode
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_l2d"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufloat_optab
argument_list|,
name|DFmode
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_ul2d"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|SFmode
argument_list|,
name|SImode
argument_list|,
literal|"__aeabi_i2f"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufloat_optab
argument_list|,
name|SFmode
argument_list|,
name|SImode
argument_list|,
literal|"__aeabi_ui2f"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|sfloat_optab
argument_list|,
name|SFmode
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_l2f"
argument_list|)
expr_stmt|;
name|set_conv_libfunc
argument_list|(
name|ufloat_optab
argument_list|,
name|SFmode
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_ul2f"
argument_list|)
expr_stmt|;
comment|/* Long long.  Table 9.  */
name|set_optab_libfunc
argument_list|(
name|smul_optab
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_lmul"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|sdivmod_optab
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_ldivmod"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udivmod_optab
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_uldivmod"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ashl_optab
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_llsl"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|lshr_optab
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_llsr"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ashr_optab
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_lasr"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|cmp_optab
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_lcmp"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|ucmp_optab
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_ulcmp"
argument_list|)
expr_stmt|;
comment|/* Integer (32/32->32) division.  \S 4.3.1.  */
name|set_optab_libfunc
argument_list|(
name|sdivmod_optab
argument_list|,
name|SImode
argument_list|,
literal|"__aeabi_idivmod"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udivmod_optab
argument_list|,
name|SImode
argument_list|,
literal|"__aeabi_uidivmod"
argument_list|)
expr_stmt|;
comment|/* The divmod functions are designed so that they can be used for      plain division, even though they return both the quotient and the      remainder.  The quotient is returned in the usual location (i.e.,      r0 for SImode, {r0, r1} for DImode), just as would be expected      for an ordinary division routine.  Because the AAPCS calling      conventions specify that all of { r0, r1, r2, r3 } are      callee-saved registers, there is no need to tell the compiler      explicitly that those registers are clobbered by these      routines.  */
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_ldivmod"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|DImode
argument_list|,
literal|"__aeabi_uldivmod"
argument_list|)
expr_stmt|;
comment|/* For SImode division the ABI provides div-without-mod routines,      which are faster.  */
name|set_optab_libfunc
argument_list|(
name|sdiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"__aeabi_idiv"
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|udiv_optab
argument_list|,
name|SImode
argument_list|,
literal|"__aeabi_uidiv"
argument_list|)
expr_stmt|;
comment|/* We don't have mod libcalls.  Fortunately gcc knows how to use the      divmod libcalls instead.  */
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|DImode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|DImode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|smod_optab
argument_list|,
name|SImode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|set_optab_libfunc
argument_list|(
name|umod_optab
argument_list|,
name|SImode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_HANDLE_OPTION.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_handle_option
parameter_list|(
name|size_t
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|value
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|OPT_march_
case|:
name|arm_select
index|[
literal|1
index|]
operator|.
name|string
operator|=
name|arg
expr_stmt|;
return|return
name|true
return|;
case|case
name|OPT_mcpu_
case|:
name|arm_select
index|[
literal|0
index|]
operator|.
name|string
operator|=
name|arg
expr_stmt|;
return|return
name|true
return|;
case|case
name|OPT_mhard_float
case|:
name|target_float_abi_name
operator|=
literal|"hard"
expr_stmt|;
return|return
name|true
return|;
case|case
name|OPT_msoft_float
case|:
name|target_float_abi_name
operator|=
literal|"soft"
expr_stmt|;
return|return
name|true
return|;
case|case
name|OPT_mtune_
case|:
name|arm_select
index|[
literal|2
index|]
operator|.
name|string
operator|=
name|arg
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fix up any incompatible options that the user has specified.    This has now turned into a maze.  */
end_comment

begin_function
name|void
name|arm_override_options
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|enum
name|processor_type
name|target_arch_cpu
init|=
name|arm_none
decl_stmt|;
comment|/* Set up the flags based on the cpu/architecture selected by the user.  */
for|for
control|(
name|i
operator|=
name|ARRAY_SIZE
argument_list|(
name|arm_select
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|struct
name|arm_cpu_select
modifier|*
name|ptr
init|=
name|arm_select
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|string
operator|!=
name|NULL
operator|&&
name|ptr
operator|->
name|string
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
specifier|const
name|struct
name|processors
modifier|*
name|sel
decl_stmt|;
for|for
control|(
name|sel
operator|=
name|ptr
operator|->
name|processors
init|;
name|sel
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sel
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|ptr
operator|->
name|string
argument_list|,
name|sel
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* Set the architecture define.  */
if|if
condition|(
name|i
operator|!=
name|ARM_OPT_SET_TUNE
condition|)
name|sprintf
argument_list|(
name|arm_arch_name
argument_list|,
literal|"__ARM_ARCH_%s__"
argument_list|,
name|sel
operator|->
name|arch
argument_list|)
expr_stmt|;
comment|/* Determine the processor core for which we should 		   tune code-generation.  */
if|if
condition|(
comment|/* -mcpu= is a sensible default.  */
name|i
operator|==
name|ARM_OPT_SET_CPU
comment|/* -mtune= overrides -mcpu= and -march=.  */
operator|||
name|i
operator|==
name|ARM_OPT_SET_TUNE
condition|)
name|arm_tune
operator|=
operator|(
expr|enum
name|processor_type
operator|)
operator|(
name|sel
operator|-
name|ptr
operator|->
name|processors
operator|)
expr_stmt|;
comment|/* Remember the CPU associated with this architecture. 		   If no other option is used to set the CPU type, 		   we'll use this to guess the most suitable tuning 		   options.  */
if|if
condition|(
name|i
operator|==
name|ARM_OPT_SET_ARCH
condition|)
name|target_arch_cpu
operator|=
name|sel
operator|->
name|core
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ARM_OPT_SET_TUNE
condition|)
block|{
comment|/* If we have been given an architecture and a processor 		       make sure that they are compatible.  We only generate 		       a warning though, and we prefer the CPU over the 		       architecture.  */
if|if
condition|(
name|insn_flags
operator|!=
literal|0
operator|&&
operator|(
name|insn_flags
operator|^
name|sel
operator|->
name|flags
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"switch -mcpu=%s conflicts with -march= switch"
argument_list|,
name|ptr
operator|->
name|string
argument_list|)
expr_stmt|;
name|insn_flags
operator|=
name|sel
operator|->
name|flags
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|sel
operator|->
name|name
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"bad value (%s) for %s switch"
argument_list|,
name|ptr
operator|->
name|string
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Guess the tuning options from the architecture if necessary.  */
if|if
condition|(
name|arm_tune
operator|==
name|arm_none
condition|)
name|arm_tune
operator|=
name|target_arch_cpu
expr_stmt|;
comment|/* If the user did not specify a processor, choose one for them.  */
if|if
condition|(
name|insn_flags
operator|==
literal|0
condition|)
block|{
specifier|const
name|struct
name|processors
modifier|*
name|sel
decl_stmt|;
name|unsigned
name|int
name|sought
decl_stmt|;
name|enum
name|processor_type
name|cpu
decl_stmt|;
name|cpu
operator|=
name|TARGET_CPU_DEFAULT
expr_stmt|;
if|if
condition|(
name|cpu
operator|==
name|arm_none
condition|)
block|{
ifdef|#
directive|ifdef
name|SUBTARGET_CPU_DEFAULT
comment|/* Use the subtarget default CPU if none was specified by 	     configure.  */
name|cpu
operator|=
name|SUBTARGET_CPU_DEFAULT
expr_stmt|;
endif|#
directive|endif
comment|/* Default to ARM6.  */
if|if
condition|(
name|cpu
operator|==
name|arm_none
condition|)
name|cpu
operator|=
name|arm6
expr_stmt|;
block|}
name|sel
operator|=
operator|&
name|all_cores
index|[
name|cpu
index|]
expr_stmt|;
name|insn_flags
operator|=
name|sel
operator|->
name|flags
expr_stmt|;
comment|/* Now check to see if the user has specified some command line 	 switch that require certain abilities from the cpu.  */
name|sought
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_INTERWORK
operator|||
name|TARGET_THUMB
condition|)
block|{
name|sought
operator||=
operator|(
name|FL_THUMB
operator||
name|FL_MODE32
operator|)
expr_stmt|;
comment|/* There are no ARM processors that support both APCS-26 and 	     interworking.  Therefore we force FL_MODE26 to be removed 	     from insn_flags here (if it was set), so that the search 	     below will always be able to find a compatible processor.  */
name|insn_flags
operator|&=
operator|~
name|FL_MODE26
expr_stmt|;
block|}
if|if
condition|(
name|sought
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|sought
operator|&
name|insn_flags
operator|)
operator|!=
name|sought
operator|)
condition|)
block|{
comment|/* Try to locate a CPU type that supports all of the abilities 	     of the default CPU, plus the extra abilities requested by 	     the user.  */
for|for
control|(
name|sel
operator|=
name|all_cores
init|;
name|sel
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sel
operator|++
control|)
if|if
condition|(
operator|(
name|sel
operator|->
name|flags
operator|&
name|sought
operator|)
operator|==
operator|(
name|sought
operator||
name|insn_flags
operator|)
condition|)
break|break;
if|if
condition|(
name|sel
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|current_bit_count
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|processors
modifier|*
name|best_fit
init|=
name|NULL
decl_stmt|;
comment|/* Ideally we would like to issue an error message here 		 saying that it was not possible to find a CPU compatible 		 with the default CPU, but which also supports the command 		 line options specified by the programmer, and so they 		 ought to use the -mcpu=<name> command line option to 		 override the default CPU type.  		 If we cannot find a cpu that has both the 		 characteristics of the default cpu and the given 		 command line options we scan the array again looking 		 for a best match.  */
for|for
control|(
name|sel
operator|=
name|all_cores
init|;
name|sel
operator|->
name|name
operator|!=
name|NULL
condition|;
name|sel
operator|++
control|)
if|if
condition|(
operator|(
name|sel
operator|->
name|flags
operator|&
name|sought
operator|)
operator|==
name|sought
condition|)
block|{
name|unsigned
name|count
decl_stmt|;
name|count
operator|=
name|bit_count
argument_list|(
name|sel
operator|->
name|flags
operator|&
name|insn_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|current_bit_count
condition|)
block|{
name|best_fit
operator|=
name|sel
expr_stmt|;
name|current_bit_count
operator|=
name|count
expr_stmt|;
block|}
block|}
name|gcc_assert
argument_list|(
name|best_fit
argument_list|)
expr_stmt|;
name|sel
operator|=
name|best_fit
expr_stmt|;
block|}
name|insn_flags
operator|=
name|sel
operator|->
name|flags
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|arm_arch_name
argument_list|,
literal|"__ARM_ARCH_%s__"
argument_list|,
name|sel
operator|->
name|arch
argument_list|)
expr_stmt|;
name|arm_default_cpu
operator|=
operator|(
expr|enum
name|processor_type
operator|)
operator|(
name|sel
operator|-
name|all_cores
operator|)
expr_stmt|;
if|if
condition|(
name|arm_tune
operator|==
name|arm_none
condition|)
name|arm_tune
operator|=
name|arm_default_cpu
expr_stmt|;
block|}
comment|/* The processor for which we should tune should now have been      chosen.  */
name|gcc_assert
argument_list|(
name|arm_tune
operator|!=
name|arm_none
argument_list|)
expr_stmt|;
name|tune_flags
operator|=
name|all_cores
index|[
operator|(
name|int
operator|)
name|arm_tune
index|]
operator|.
name|flags
expr_stmt|;
if|if
condition|(
name|optimize_size
condition|)
name|targetm
operator|.
name|rtx_costs
operator|=
name|arm_size_rtx_costs
expr_stmt|;
else|else
name|targetm
operator|.
name|rtx_costs
operator|=
name|all_cores
index|[
operator|(
name|int
operator|)
name|arm_tune
index|]
operator|.
name|rtx_costs
expr_stmt|;
comment|/* Make sure that the processor choice does not conflict with any of the      other command line choices.  */
if|if
condition|(
name|TARGET_INTERWORK
operator|&&
operator|!
operator|(
name|insn_flags
operator|&
name|FL_THUMB
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"target CPU does not support interworking"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|MASK_INTERWORK
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_THUMB
operator|&&
operator|!
operator|(
name|insn_flags
operator|&
name|FL_THUMB
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"target CPU does not support THUMB instructions"
argument_list|)
expr_stmt|;
name|target_flags
operator|&=
operator|~
name|MASK_THUMB
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_APCS_FRAME
operator|&&
name|TARGET_THUMB
condition|)
block|{
comment|/* warning (0, "ignoring -mapcs-frame because -mthumb was used"); */
name|target_flags
operator|&=
operator|~
name|MASK_APCS_FRAME
expr_stmt|;
block|}
comment|/* Callee super interworking implies thumb interworking.  Adding      this to the flags here simplifies the logic elsewhere.  */
if|if
condition|(
name|TARGET_THUMB
operator|&&
name|TARGET_CALLEE_INTERWORKING
condition|)
name|target_flags
operator||=
name|MASK_INTERWORK
expr_stmt|;
comment|/* TARGET_BACKTRACE calls leaf_function_p, which causes a crash if done      from here where no function is being compiled currently.  */
if|if
condition|(
operator|(
name|TARGET_TPCS_FRAME
operator|||
name|TARGET_TPCS_LEAF_FRAME
operator|)
operator|&&
name|TARGET_ARM
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"enabling backtrace support is only meaningful when compiling for the Thumb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
operator|&&
name|TARGET_CALLEE_INTERWORKING
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"enabling callee interworking support is only meaningful when compiling for the Thumb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
operator|&&
name|TARGET_CALLER_INTERWORKING
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"enabling caller interworking support is only meaningful when compiling for the Thumb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_APCS_STACK
operator|&&
operator|!
name|TARGET_APCS_FRAME
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-mapcs-stack-check incompatible with -mno-apcs-frame"
argument_list|)
expr_stmt|;
name|target_flags
operator||=
name|MASK_APCS_FRAME
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_POKE_FUNCTION_NAME
condition|)
name|target_flags
operator||=
name|MASK_APCS_FRAME
expr_stmt|;
if|if
condition|(
name|TARGET_APCS_REENT
operator|&&
name|flag_pic
condition|)
name|error
argument_list|(
literal|"-fpic and -mapcs-reent are incompatible"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_APCS_REENT
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"APCS reentrant code not supported.  Ignored"
argument_list|)
expr_stmt|;
comment|/* If this target is normally configured to use APCS frames, warn if they      are turned off and debugging is turned on.  */
if|if
condition|(
name|TARGET_ARM
operator|&&
name|write_symbols
operator|!=
name|NO_DEBUG
operator|&&
operator|!
name|TARGET_APCS_FRAME
operator|&&
operator|(
name|TARGET_DEFAULT
operator|&
name|MASK_APCS_FRAME
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-g with -mno-apcs-frame may not give sensible debugging"
argument_list|)
expr_stmt|;
comment|/* If stack checking is disabled, we can use r10 as the PIC register,      which keeps r9 available.  */
if|if
condition|(
name|flag_pic
operator|&&
name|TARGET_SINGLE_PIC_BASE
condition|)
name|arm_pic_register
operator|=
name|TARGET_APCS_STACK
condition|?
literal|9
else|:
literal|10
expr_stmt|;
if|if
condition|(
name|TARGET_APCS_FLOAT
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"passing floating point arguments in fp regs not yet supported"
argument_list|)
expr_stmt|;
comment|/* Initialize boolean versions of the flags, for use in the arm.md file.  */
name|arm_arch3m
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH3M
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch4
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH4
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch4t
operator|=
name|arm_arch4
operator|&
operator|(
operator|(
name|insn_flags
operator|&
name|FL_THUMB
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|arm_arch5
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH5
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch5e
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH5E
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch6
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH6
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch6k
operator|=
operator|(
name|insn_flags
operator|&
name|FL_ARCH6K
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch_xscale
operator|=
operator|(
name|insn_flags
operator|&
name|FL_XSCALE
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch_cirrus
operator|=
operator|(
name|insn_flags
operator|&
name|FL_CIRRUS
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_ld_sched
operator|=
operator|(
name|tune_flags
operator|&
name|FL_LDSCHED
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_tune_strongarm
operator|=
operator|(
name|tune_flags
operator|&
name|FL_STRONG
operator|)
operator|!=
literal|0
expr_stmt|;
name|thumb_code
operator|=
operator|(
name|TARGET_ARM
operator|==
literal|0
operator|)
expr_stmt|;
name|arm_tune_wbuf
operator|=
operator|(
name|tune_flags
operator|&
name|FL_WBUF
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_tune_xscale
operator|=
operator|(
name|tune_flags
operator|&
name|FL_XSCALE
operator|)
operator|!=
literal|0
expr_stmt|;
name|arm_arch_iwmmxt
operator|=
operator|(
name|insn_flags
operator|&
name|FL_IWMMXT
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* V5 code we generate is completely interworking capable, so we turn off      TARGET_INTERWORK here to avoid many tests later on.  */
comment|/* XXX However, we must pass the right pre-processor defines to CPP      or GLD can get confused.  This is a hack.  */
if|if
condition|(
name|TARGET_INTERWORK
condition|)
name|arm_cpp_interwork
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arm_arch5
condition|)
name|target_flags
operator|&=
operator|~
name|MASK_INTERWORK
expr_stmt|;
if|if
condition|(
name|target_abi_name
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|arm_all_abis
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|arm_all_abis
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|target_abi_name
argument_list|)
condition|)
block|{
name|arm_abi
operator|=
name|arm_all_abis
index|[
name|i
index|]
operator|.
name|abi_type
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|ARRAY_SIZE
argument_list|(
name|arm_all_abis
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid ABI option: -mabi=%s"
argument_list|,
name|target_abi_name
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_abi
operator|=
name|ARM_DEFAULT_ABI
expr_stmt|;
if|if
condition|(
name|TARGET_IWMMXT
operator|&&
operator|!
name|ARM_DOUBLEWORD_ALIGN
condition|)
name|error
argument_list|(
literal|"iwmmxt requires an AAPCS compatible ABI for proper operation"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_IWMMXT_ABI
operator|&&
operator|!
name|TARGET_IWMMXT
condition|)
name|error
argument_list|(
literal|"iwmmxt abi requires an iwmmxt capable cpu"
argument_list|)
expr_stmt|;
name|arm_fp_model
operator|=
name|ARM_FP_MODEL_UNKNOWN
expr_stmt|;
if|if
condition|(
name|target_fpu_name
operator|==
name|NULL
operator|&&
name|target_fpe_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|target_fpe_name
argument_list|,
literal|"2"
argument_list|)
condition|)
name|target_fpu_name
operator|=
literal|"fpe2"
expr_stmt|;
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|target_fpe_name
argument_list|,
literal|"3"
argument_list|)
condition|)
name|target_fpu_name
operator|=
literal|"fpe3"
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid floating point emulation option: -mfpe=%s"
argument_list|,
name|target_fpe_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_fpu_name
operator|!=
name|NULL
condition|)
block|{
comment|/* The user specified a FPU.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|all_fpus
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|all_fpus
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|target_fpu_name
argument_list|)
condition|)
block|{
name|arm_fpu_arch
operator|=
name|all_fpus
index|[
name|i
index|]
operator|.
name|fpu
expr_stmt|;
name|arm_fpu_tune
operator|=
name|arm_fpu_arch
expr_stmt|;
name|arm_fp_model
operator|=
name|fp_model_for_fpu
index|[
name|arm_fpu_arch
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|arm_fp_model
operator|==
name|ARM_FP_MODEL_UNKNOWN
condition|)
name|error
argument_list|(
literal|"invalid floating point option: -mfpu=%s"
argument_list|,
name|target_fpu_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|FPUTYPE_DEFAULT
comment|/* Use the default if it is specified for this platform.  */
name|arm_fpu_arch
operator|=
name|FPUTYPE_DEFAULT
expr_stmt|;
name|arm_fpu_tune
operator|=
name|FPUTYPE_DEFAULT
expr_stmt|;
else|#
directive|else
comment|/* Pick one based on CPU type.  */
comment|/* ??? Some targets assume FPA is the default.       if ((insn_flags& FL_VFP) != 0) 	arm_fpu_arch = FPUTYPE_VFP;       else       */
if|if
condition|(
name|arm_arch_cirrus
condition|)
name|arm_fpu_arch
operator|=
name|FPUTYPE_MAVERICK
expr_stmt|;
else|else
name|arm_fpu_arch
operator|=
name|FPUTYPE_FPA_EMU2
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tune_flags
operator|&
name|FL_CO_PROC
operator|&&
name|arm_fpu_arch
operator|==
name|FPUTYPE_FPA_EMU2
condition|)
name|arm_fpu_tune
operator|=
name|FPUTYPE_FPA
expr_stmt|;
else|else
name|arm_fpu_tune
operator|=
name|arm_fpu_arch
expr_stmt|;
name|arm_fp_model
operator|=
name|fp_model_for_fpu
index|[
name|arm_fpu_arch
index|]
expr_stmt|;
name|gcc_assert
argument_list|(
name|arm_fp_model
operator|!=
name|ARM_FP_MODEL_UNKNOWN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_float_abi_name
operator|!=
name|NULL
condition|)
block|{
comment|/* The user specified a FP ABI.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|all_float_abis
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|all_float_abis
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|target_float_abi_name
argument_list|)
condition|)
block|{
name|arm_float_abi
operator|=
name|all_float_abis
index|[
name|i
index|]
operator|.
name|abi_type
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|ARRAY_SIZE
argument_list|(
name|all_float_abis
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid floating point abi: -mfloat-abi=%s"
argument_list|,
name|target_float_abi_name
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_float_abi
operator|=
name|TARGET_DEFAULT_FLOAT_ABI
expr_stmt|;
if|if
condition|(
name|arm_float_abi
operator|==
name|ARM_FLOAT_ABI_HARD
operator|&&
name|TARGET_VFP
condition|)
name|sorry
argument_list|(
literal|"-mfloat-abi=hard and VFP"
argument_list|)
expr_stmt|;
comment|/* FPA and iWMMXt are incompatible because the insn encodings overlap.      VFP and iWMMXt can theoretically coexist, but it's unlikely such silicon      will ever exist.  GCC makes no attempt to support this combination.  */
if|if
condition|(
name|TARGET_IWMMXT
operator|&&
operator|!
name|TARGET_SOFT_FLOAT
condition|)
name|sorry
argument_list|(
literal|"iWMMXt and hardware floating point"
argument_list|)
expr_stmt|;
comment|/* If soft-float is specified then don't use FPU.  */
if|if
condition|(
name|TARGET_SOFT_FLOAT
condition|)
name|arm_fpu_arch
operator|=
name|FPUTYPE_NONE
expr_stmt|;
comment|/* For arm2/3 there is no need to do any scheduling if there is only      a floating point emulator, or we are doing software floating-point.  */
if|if
condition|(
operator|(
name|TARGET_SOFT_FLOAT
operator|||
name|arm_fpu_tune
operator|==
name|FPUTYPE_FPA_EMU2
operator|||
name|arm_fpu_tune
operator|==
name|FPUTYPE_FPA_EMU3
operator|)
operator|&&
operator|(
name|tune_flags
operator|&
name|FL_MODE32
operator|)
operator|==
literal|0
condition|)
name|flag_schedule_insns
operator|=
name|flag_schedule_insns_after_reload
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|target_thread_switch
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|target_thread_switch
argument_list|,
literal|"soft"
argument_list|)
operator|==
literal|0
condition|)
name|target_thread_pointer
operator|=
name|TP_SOFT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|target_thread_switch
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
name|target_thread_pointer
operator|=
name|TP_AUTO
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|target_thread_switch
argument_list|,
literal|"cp15"
argument_list|)
operator|==
literal|0
condition|)
name|target_thread_pointer
operator|=
name|TP_CP15
expr_stmt|;
else|else
name|error
argument_list|(
literal|"invalid thread pointer option: -mtp=%s"
argument_list|,
name|target_thread_switch
argument_list|)
expr_stmt|;
block|}
comment|/* Use the cp15 method if it is available.  */
if|if
condition|(
name|target_thread_pointer
operator|==
name|TP_AUTO
condition|)
block|{
if|if
condition|(
name|arm_arch6k
operator|&&
operator|!
name|TARGET_THUMB
condition|)
name|target_thread_pointer
operator|=
name|TP_CP15
expr_stmt|;
else|else
name|target_thread_pointer
operator|=
name|TP_SOFT
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_HARD_TP
operator|&&
name|TARGET_THUMB
condition|)
name|error
argument_list|(
literal|"can not use -mtp=cp15 with -mthumb"
argument_list|)
expr_stmt|;
comment|/* Override the default structure alignment for AAPCS ABI.  */
if|if
condition|(
name|TARGET_AAPCS_BASED
condition|)
name|arm_structure_size_boundary
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|structure_size_string
operator|!=
name|NULL
condition|)
block|{
name|int
name|size
init|=
name|strtol
argument_list|(
name|structure_size_string
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|8
operator|||
name|size
operator|==
literal|32
operator|||
operator|(
name|ARM_DOUBLEWORD_ALIGN
operator|&&
name|size
operator|==
literal|64
operator|)
condition|)
name|arm_structure_size_boundary
operator|=
name|size
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"structure size boundary can only be set to %s"
argument_list|,
name|ARM_DOUBLEWORD_ALIGN
condition|?
literal|"8, 32 or 64"
else|:
literal|"8 or 32"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arm_pic_register_string
operator|!=
name|NULL
condition|)
block|{
name|int
name|pic_register
init|=
name|decode_reg_name
argument_list|(
name|arm_pic_register_string
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|flag_pic
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"-mpic-register= is useless without -fpic"
argument_list|)
expr_stmt|;
comment|/* Prevent the user from choosing an obviously stupid PIC register.  */
elseif|else
if|if
condition|(
name|pic_register
operator|<
literal|0
operator|||
name|call_used_regs
index|[
name|pic_register
index|]
operator|||
name|pic_register
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|pic_register
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|pic_register
operator|>=
name|PC_REGNUM
condition|)
name|error
argument_list|(
literal|"unable to use '%s' for PIC register"
argument_list|,
name|arm_pic_register_string
argument_list|)
expr_stmt|;
else|else
name|arm_pic_register
operator|=
name|pic_register
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_THUMB
operator|&&
name|flag_schedule_insns
condition|)
block|{
comment|/* Don't warn since it's on by default in -O2.  */
name|flag_schedule_insns
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|optimize_size
condition|)
block|{
name|arm_constant_limit
operator|=
literal|1
expr_stmt|;
comment|/* If optimizing for size, bump the number of instructions that we          are prepared to conditionally execute (even on a StrongARM).  */
name|max_insns_skipped
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
comment|/* For processors with load scheduling, it never costs more than          2 cycles to load a constant, and the load scheduler may well 	 reduce that to 1.  */
if|if
condition|(
name|arm_ld_sched
condition|)
name|arm_constant_limit
operator|=
literal|1
expr_stmt|;
comment|/* On XScale the longer latency of a load makes it more difficult          to achieve a good schedule, so it's faster to synthesize 	 constants that can be done in two insns.  */
if|if
condition|(
name|arm_tune_xscale
condition|)
name|arm_constant_limit
operator|=
literal|2
expr_stmt|;
comment|/* StrongARM has early execution of branches, so a sequence          that is worth skipping is shorter.  */
if|if
condition|(
name|arm_tune_strongarm
condition|)
name|max_insns_skipped
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Register global variables with the garbage collector.  */
name|arm_add_gc_roots
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_add_gc_roots
parameter_list|(
name|void
parameter_list|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|minipool_obstack
argument_list|)
expr_stmt|;
name|minipool_startobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A table of known ARM exception types.    For use with the interrupt function attribute.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
specifier|const
name|arg
decl_stmt|;
specifier|const
name|unsigned
name|long
name|return_value
decl_stmt|;
block|}
name|isr_attribute_arg
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|isr_attribute_arg
name|isr_attribute_args
index|[]
init|=
block|{
block|{
literal|"IRQ"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"irq"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"FIQ"
block|,
name|ARM_FT_FIQ
block|}
block|,
block|{
literal|"fiq"
block|,
name|ARM_FT_FIQ
block|}
block|,
block|{
literal|"ABORT"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"abort"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"ABORT"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"abort"
block|,
name|ARM_FT_ISR
block|}
block|,
block|{
literal|"UNDEF"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
literal|"undef"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
literal|"SWI"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
literal|"swi"
block|,
name|ARM_FT_EXCEPTION
block|}
block|,
block|{
name|NULL
block|,
name|ARM_FT_NORMAL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns the (interrupt) function type of the current    function, or ARM_FT_UNKNOWN if the type cannot be determined.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_isr_value
parameter_list|(
name|tree
name|argument
parameter_list|)
block|{
specifier|const
name|isr_attribute_arg
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* No argument - default to IRQ.  */
if|if
condition|(
name|argument
operator|==
name|NULL_TREE
condition|)
return|return
name|ARM_FT_ISR
return|;
comment|/* Get the value of the argument.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return
name|ARM_FT_UNKNOWN
return|;
name|arg
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check it against the list of known arguments.  */
for|for
control|(
name|ptr
operator|=
name|isr_attribute_args
init|;
name|ptr
operator|->
name|arg
operator|!=
name|NULL
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|arg
argument_list|,
name|ptr
operator|->
name|arg
argument_list|)
condition|)
return|return
name|ptr
operator|->
name|return_value
return|;
comment|/* An unrecognized interrupt type.  */
return|return
name|ARM_FT_UNKNOWN
return|;
block|}
end_function

begin_comment
comment|/* Computes the type of the current function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_compute_func_type
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|type
init|=
name|ARM_FT_UNKNOWN
decl_stmt|;
name|tree
name|a
decl_stmt|;
name|tree
name|attr
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|current_function_decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
comment|/* Decide if the current function is volatile.  Such functions      never return, and many memory cycles can be saved by not storing      register values that will never be needed again.  This optimization      was added to speed up context switching in a kernel application.  */
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
operator|(
name|TREE_NOTHROW
argument_list|(
name|current_function_decl
argument_list|)
operator|||
operator|!
operator|(
name|flag_unwind_tables
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|)
operator|)
operator|)
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|type
operator||=
name|ARM_FT_VOLATILE
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|static_chain_decl
operator|!=
name|NULL
condition|)
name|type
operator||=
name|ARM_FT_NESTED
expr_stmt|;
name|attr
operator|=
name|DECL_ATTRIBUTES
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|a
operator|=
name|lookup_attribute
argument_list|(
literal|"naked"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL_TREE
condition|)
name|type
operator||=
name|ARM_FT_NAKED
expr_stmt|;
name|a
operator|=
name|lookup_attribute
argument_list|(
literal|"isr"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL_TREE
condition|)
name|a
operator|=
name|lookup_attribute
argument_list|(
literal|"interrupt"
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL_TREE
condition|)
name|type
operator||=
name|TARGET_INTERWORK
condition|?
name|ARM_FT_INTERWORKED
else|:
name|ARM_FT_NORMAL
expr_stmt|;
else|else
name|type
operator||=
name|arm_isr_value
argument_list|(
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Returns the type of the current function.  */
end_comment

begin_function
name|unsigned
name|long
name|arm_current_func_type
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ARM_FUNC_TYPE
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|func_type
argument_list|)
operator|==
name|ARM_FT_UNKNOWN
condition|)
name|cfun
operator|->
name|machine
operator|->
name|func_type
operator|=
name|arm_compute_func_type
argument_list|()
expr_stmt|;
return|return
name|cfun
operator|->
name|machine
operator|->
name|func_type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if it is possible to return using a single instruction.    If SIBLING is non-null, this is a test for a return before a sibling    call.  SIBLING is the call insn, so we can examine its register usage.  */
end_comment

begin_function
name|int
name|use_return_insn
parameter_list|(
name|int
name|iscond
parameter_list|,
name|rtx
name|sibling
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|int
name|func_type
decl_stmt|;
name|unsigned
name|long
name|saved_int_regs
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|stack_adjust
decl_stmt|;
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
comment|/* Never use a return instruction before reload has run.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
return|return
literal|0
return|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
comment|/* Naked functions and volatile functions need special      consideration.  */
if|if
condition|(
name|func_type
operator|&
operator|(
name|ARM_FT_VOLATILE
operator||
name|ARM_FT_NAKED
operator|)
condition|)
return|return
literal|0
return|;
comment|/* So do interrupt functions that use the frame pointer.  */
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
operator|&&
name|frame_pointer_needed
condition|)
return|return
literal|0
return|;
name|offsets
operator|=
name|arm_get_frame_offsets
argument_list|()
expr_stmt|;
name|stack_adjust
operator|=
name|offsets
operator|->
name|outgoing_args
operator|-
name|offsets
operator|->
name|saved_regs
expr_stmt|;
comment|/* As do variadic functions.  */
if|if
condition|(
name|current_function_pretend_args_size
operator|||
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
comment|/* Or if the function calls __builtin_eh_return () */
operator|||
name|current_function_calls_eh_return
comment|/* Or if the function calls alloca */
operator|||
name|current_function_calls_alloca
comment|/* Or if there is a stack adjustment.  However, if the stack pointer 	 is saved on the stack, we can use a pre-incrementing stack load.  */
operator|||
operator|!
operator|(
name|stack_adjust
operator|==
literal|0
operator|||
operator|(
name|frame_pointer_needed
operator|&&
name|stack_adjust
operator|==
literal|4
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|saved_int_regs
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
comment|/* Unfortunately, the insn         ldmib sp, {..., sp, ...}       triggers a bug on most SA-110 based devices, such that the stack      pointer won't be correctly restored if the instruction takes a      page fault.  We work around this problem by popping r3 along with      the other registers, since that is never slower than executing      another instruction.       We test for !arm_arch5 here, because code for any architecture      less than this could potentially be run on one of the buggy      chips.  */
if|if
condition|(
name|stack_adjust
operator|==
literal|4
operator|&&
operator|!
name|arm_arch5
condition|)
block|{
comment|/* Validate that r3 is a call-clobbered register (always true in 	 the default abi) ...  */
if|if
condition|(
operator|!
name|call_used_regs
index|[
literal|3
index|]
condition|)
return|return
literal|0
return|;
comment|/* ... that it isn't being used for a return value ... */
if|if
condition|(
name|arm_size_return_regs
argument_list|()
operator|>=
operator|(
literal|4
operator|*
name|UNITS_PER_WORD
operator|)
condition|)
return|return
literal|0
return|;
comment|/* ... or for a tail-call argument ...  */
if|if
condition|(
name|sibling
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|sibling
argument_list|)
operator|==
name|CALL_INSN
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_regno_fusage
argument_list|(
name|sibling
argument_list|,
name|USE
argument_list|,
literal|3
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* ... and that there are no call-saved registers in r0-r2 	 (always true in the default ABI).  */
if|if
condition|(
name|saved_int_regs
operator|&
literal|0x7
condition|)
return|return
literal|0
return|;
block|}
comment|/* Can't be done if interworking with Thumb, and any registers have been      stacked.  */
if|if
condition|(
name|TARGET_INTERWORK
operator|&&
name|saved_int_regs
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* On StrongARM, conditional returns are expensive if they aren't      taken and multiple registers have been stacked.  */
if|if
condition|(
name|iscond
operator|&&
name|arm_tune_strongarm
condition|)
block|{
comment|/* Conditional return when just the LR is stored is a simple 	 conditional-load instruction, that's not expensive.  */
if|if
condition|(
name|saved_int_regs
operator|!=
literal|0
operator|&&
name|saved_int_regs
operator|!=
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag_pic
operator|&&
name|arm_pic_register
operator|!=
name|INVALID_REGNUM
operator|&&
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
return|return
literal|0
return|;
block|}
comment|/* If there are saved registers but the LR isn't saved, then we need      two instructions for the return.  */
if|if
condition|(
name|saved_int_regs
operator|&&
operator|!
operator|(
name|saved_int_regs
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Can't be done if any of the FPA regs are pushed,      since this also requires an insn.  */
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPA
condition|)
for|for
control|(
name|regno
operator|=
name|FIRST_FPA_REGNUM
init|;
name|regno
operator|<=
name|LAST_FPA_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
comment|/* Likewise VFP regs.  */
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_VFP
condition|)
for|for
control|(
name|regno
operator|=
name|FIRST_VFP_REGNUM
init|;
name|regno
operator|<=
name|LAST_VFP_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_REALLY_IWMMXT
condition|)
for|for
control|(
name|regno
operator|=
name|FIRST_IWMMXT_REGNUM
init|;
name|regno
operator|<=
name|LAST_IWMMXT_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if int I is a valid immediate ARM constant.  */
end_comment

begin_function
name|int
name|const_ok_for_arm
parameter_list|(
name|HOST_WIDE_INT
name|i
parameter_list|)
block|{
name|int
name|lowbit
decl_stmt|;
comment|/* For machines with>32 bit HOST_WIDE_INT, the bits above bit 31 must      be all zero, or all one.  */
if|if
condition|(
operator|(
name|i
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|i
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|!=
operator|(
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
name|i
operator|&=
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
expr_stmt|;
comment|/* Fast return for 0 and small values.  We must do this for zero, since      the code below can't handle that one case.  */
if|if
condition|(
operator|(
name|i
operator|&
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
comment|/* Get the number of trailing zeros, rounded down to the nearest even      number.  */
name|lowbit
operator|=
operator|(
name|ffs
argument_list|(
operator|(
name|int
operator|)
name|i
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
operator|~
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xff
operator|)
operator|<<
name|lowbit
operator|)
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
elseif|else
if|if
condition|(
name|lowbit
operator|<=
literal|4
operator|&&
operator|(
operator|(
name|i
operator|&
operator|~
literal|0xc000003f
operator|)
operator|==
literal|0
operator|||
operator|(
name|i
operator|&
operator|~
literal|0xf000000f
operator|)
operator|==
literal|0
operator|||
operator|(
name|i
operator|&
operator|~
literal|0xfc000003
operator|)
operator|==
literal|0
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if I is a valid constant for the operation CODE.  */
end_comment

begin_function
specifier|static
name|int
name|const_ok_for_op
parameter_list|(
name|HOST_WIDE_INT
name|i
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|)
block|{
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS
case|:
return|return
name|const_ok_for_arm
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
operator|-
name|i
argument_list|)
argument_list|)
return|;
case|case
name|MINUS
case|:
comment|/* Should only occur with (MINUS I reg) => rsb */
case|case
name|XOR
case|:
case|case
name|IOR
case|:
return|return
literal|0
return|;
case|case
name|AND
case|:
return|return
name|const_ok_for_arm
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|i
argument_list|)
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a sequence of insns to handle a large constant.    CODE is the code of the operation required, it can be any of SET, PLUS,    IOR, AND, XOR, MINUS;    MODE is the mode in which the operation is being performed;    VAL is the integer to operate on;    SOURCE is the other operand (a register, or a null-pointer for SET);    SUBTARGETS means it is safe to create scratch registers if that will    either produce a simpler sequence, or we will want to cse the values.    Return value is the number of insns emitted.  */
end_comment

begin_function
name|int
name|arm_split_constant
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|source
parameter_list|,
name|int
name|subtargets
parameter_list|)
block|{
name|rtx
name|cond
decl_stmt|;
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|cond
operator|=
name|COND_EXEC_TEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cond
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|subtargets
operator|||
name|code
operator|==
name|SET
operator|||
operator|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|source
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|target
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|source
argument_list|)
operator|)
condition|)
block|{
comment|/* After arm_reorg has been called, we can't fix up expensive 	 constants by pushing them into memory so we must synthesize 	 them in-line, regardless of the cost.  This is only likely to 	 be more costly on chips that have load delay slots and we are 	 compiling without running the scheduler (so no splitting 	 occurred before the final instruction emission).  	 Ref: gcc -O1 -mcpu=strongarm gcc.c-torture/compile/980506-2.c       */
if|if
condition|(
operator|!
name|after_arm_reorg
operator|&&
operator|!
name|cond
operator|&&
operator|(
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
name|val
argument_list|,
name|target
argument_list|,
name|source
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|>
name|arm_constant_limit
operator|+
operator|(
name|code
operator|!=
name|SET
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
comment|/* Currently SET is the only monadic value for CODE, all 		 the rest are diadic.  */
name|emit_set_insn
argument_list|(
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|rtx
name|temp
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_set_insn
argument_list|(
name|temp
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For MINUS, the value is subtracted from, since we never 		 have subtraction of a constant.  */
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|emit_set_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|temp
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_set_insn
argument_list|(
name|target
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|temp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
block|}
block|}
return|return
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cond
argument_list|,
name|val
argument_list|,
name|target
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|count_insns_for_constant
parameter_list|(
name|HOST_WIDE_INT
name|remainder
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|HOST_WIDE_INT
name|temp1
decl_stmt|;
name|int
name|num_insns
init|=
literal|0
decl_stmt|;
do|do
block|{
name|int
name|end
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
operator|(
name|i
operator|-
literal|2
operator|)
operator|)
condition|)
block|{
name|end
operator|=
name|i
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
literal|32
expr_stmt|;
name|temp1
operator|=
name|remainder
operator|&
operator|(
operator|(
literal|0x0ff
operator|<<
name|end
operator|)
operator||
operator|(
operator|(
name|i
operator|<
name|end
operator|)
condition|?
operator|(
literal|0xff
operator|>>
operator|(
literal|32
operator|-
name|end
operator|)
operator|)
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|remainder
operator|&=
operator|~
name|temp1
expr_stmt|;
name|num_insns
operator|++
expr_stmt|;
name|i
operator|-=
literal|6
expr_stmt|;
block|}
name|i
operator|-=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|remainder
condition|)
do|;
return|return
name|num_insns
return|;
block|}
end_function

begin_comment
comment|/* Emit an instruction with the indicated PATTERN.  If COND is    non-NULL, conditionalize the execution of the instruction on COND    being true.  */
end_comment

begin_function
specifier|static
name|void
name|emit_constant_insn
parameter_list|(
name|rtx
name|cond
parameter_list|,
name|rtx
name|pattern
parameter_list|)
block|{
if|if
condition|(
name|cond
condition|)
name|pattern
operator|=
name|gen_rtx_COND_EXEC
argument_list|(
name|VOIDmode
argument_list|,
name|copy_rtx
argument_list|(
name|cond
argument_list|)
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As above, but extra parameter GENERATE which, if clear, suppresses    RTL generation.  */
end_comment

begin_function
specifier|static
name|int
name|arm_gen_constant
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|cond
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|source
parameter_list|,
name|int
name|subtargets
parameter_list|,
name|int
name|generate
parameter_list|)
block|{
name|int
name|can_invert
init|=
literal|0
decl_stmt|;
name|int
name|can_negate
init|=
literal|0
decl_stmt|;
name|int
name|can_negate_initial
init|=
literal|0
decl_stmt|;
name|int
name|can_shift
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_bits_set
init|=
literal|0
decl_stmt|;
name|int
name|set_sign_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|clear_sign_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|clear_zero_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|set_zero_bit_copies
init|=
literal|0
decl_stmt|;
name|int
name|insns
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|temp1
decl_stmt|,
name|temp2
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|remainder
init|=
name|val
operator|&
literal|0xffffffff
decl_stmt|;
comment|/* Find out which operations are safe for a given CODE.  Also do a quick      check for degenerate cases; these can occur when DImode operations      are split.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SET
case|:
name|can_invert
operator|=
literal|1
expr_stmt|;
name|can_shift
operator|=
literal|1
expr_stmt|;
name|can_negate
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|can_negate
operator|=
literal|1
expr_stmt|;
name|can_negate_initial
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|remainder
operator|==
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|GEN_INT
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|&&
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|generate
condition|)
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
case|case
name|AND
case|:
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|remainder
operator|==
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|&&
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|generate
condition|)
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|can_invert
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|XOR
case|:
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reload_completed
operator|&&
name|rtx_equal_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|generate
condition|)
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* We don't know how to handle other cases yet.  */
name|gcc_assert
argument_list|(
name|remainder
operator|==
literal|0xffffffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|generate
condition|)
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|MINUS
case|:
comment|/* We treat MINUS as (val - source), since (source - val) is always 	 passed as (source + (-val)).  */
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NEG
argument_list|(
name|mode
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|can_negate
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* If we can do it in one insn get out quickly.  */
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|val
argument_list|)
operator|||
operator|(
name|can_negate_initial
operator|&&
name|const_ok_for_arm
argument_list|(
operator|-
name|val
argument_list|)
operator|)
operator|||
operator|(
name|can_invert
operator|&&
name|const_ok_for_arm
argument_list|(
operator|~
name|val
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
operator|(
name|source
condition|?
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
else|:
name|GEN_INT
argument_list|(
name|val
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Calculate a few attributes that may be useful for specific      optimizations.  */
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|clear_sign_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|set_sign_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|31
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
name|clear_zero_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|31
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|set_zero_bit_copies
operator|++
expr_stmt|;
else|else
break|break;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SET
case|:
comment|/* See if we can do this by sign_extending a constant that is known 	 to be negative.  This is a good, way of doing it, since the shift 	 may well merge into a subsequent insn.  */
if|if
condition|(
name|set_sign_bit_copies
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|temp1
operator|=
name|ARM_SIGN_EXTEND
argument_list|(
name|remainder
operator|<<
operator|(
name|set_sign_bit_copies
operator|-
literal|1
operator|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_ashrsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|set_sign_bit_copies
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
comment|/* For an inverted constant, we will need to set the low bits, 	     these will be shifted out of harm's way.  */
name|temp1
operator||=
operator|(
literal|1
operator|<<
operator|(
name|set_sign_bit_copies
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|const_ok_for_arm
argument_list|(
operator|~
name|temp1
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_ashrsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|set_sign_bit_copies
operator|-
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
block|}
comment|/* See if we can calculate the value as the difference between two 	 valid immediates.  */
if|if
condition|(
name|clear_sign_bit_copies
operator|+
name|clear_zero_bit_copies
operator|<=
literal|16
condition|)
block|{
name|int
name|topshift
init|=
name|clear_sign_bit_copies
operator|&
operator|~
literal|1
decl_stmt|;
name|temp1
operator|=
name|ARM_SIGN_EXTEND
argument_list|(
operator|(
name|remainder
operator|+
operator|(
literal|0x00800000
operator|>>
name|topshift
operator|)
operator|)
operator|&
operator|(
literal|0xff000000
operator|>>
name|topshift
operator|)
argument_list|)
expr_stmt|;
comment|/* If temp1 is zero, then that means the 9 most significant 	     bits of remainder were 1 and we've caused it to overflow. 	     When topshift is 0 we don't need to do anything since we 	     can borrow from 'bit 32'.  */
if|if
condition|(
name|temp1
operator|==
literal|0
operator|&&
name|topshift
operator|!=
literal|0
condition|)
name|temp1
operator|=
literal|0x80000000
operator|>>
operator|(
name|topshift
operator|-
literal|1
operator|)
expr_stmt|;
name|temp2
operator|=
name|ARM_SIGN_EXTEND
argument_list|(
name|temp1
operator|-
name|remainder
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|temp2
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_addsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|temp2
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
block|}
comment|/* See if we can generate this by setting the bottom (or the top) 	 16 bits, and then shifting these into the other half of the 	 word.  We only look for the simplest cases, to do more would cost 	 too much.  Be careful, however, not to generate this when the 	 alternative would take fewer insns.  */
if|if
condition|(
name|val
operator|&
literal|0xffff0000
condition|)
block|{
name|temp1
operator|=
name|remainder
operator|&
literal|0xffff0000
expr_stmt|;
name|temp2
operator|=
name|remainder
operator|&
literal|0x0000ffff
expr_stmt|;
comment|/* Overlaps outside this range are best done using other methods.  */
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|temp2
operator||
operator|(
name|temp2
operator|<<
name|i
operator|)
operator|)
operator|&
literal|0xffffffff
operator|)
operator|==
name|remainder
operator|)
operator|&&
operator|!
name|const_ok_for_arm
argument_list|(
name|temp2
argument_list|)
condition|)
block|{
name|rtx
name|new_src
init|=
operator|(
name|subtargets
condition|?
operator|(
name|generate
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|NULL_RTX
operator|)
else|:
name|target
operator|)
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cond
argument_list|,
name|temp2
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
name|generate
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
if|if
condition|(
name|generate
condition|)
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|mode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insns
operator|+
literal|1
return|;
block|}
block|}
comment|/* Don't duplicate cases already considered.  */
for|for
control|(
name|i
operator|=
literal|17
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|temp1
operator||
operator|(
name|temp1
operator|>>
name|i
operator|)
operator|)
operator|==
name|remainder
operator|)
operator|&&
operator|!
name|const_ok_for_arm
argument_list|(
name|temp1
argument_list|)
condition|)
block|{
name|rtx
name|new_src
init|=
operator|(
name|subtargets
condition|?
operator|(
name|generate
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|NULL_RTX
operator|)
else|:
name|target
operator|)
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|cond
argument_list|,
name|temp1
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
name|generate
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
if|if
condition|(
name|generate
condition|)
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|insns
operator|+
literal|1
return|;
block|}
block|}
block|}
break|break;
case|case
name|IOR
case|:
case|case
name|XOR
case|:
comment|/* If we have IOR or XOR, and the constant can be loaded in a 	 single instruction, and we can find a temporary to put it in, 	 then this can be done in two instructions instead of 3-4.  */
if|if
condition|(
name|subtargets
comment|/* TARGET can't be NULL if SUBTARGETS is 0 */
operator|||
operator|(
name|reload_completed
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|source
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|val
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|GEN_INT
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|sub
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
block|}
if|if
condition|(
name|code
operator|==
name|XOR
condition|)
break|break;
if|if
condition|(
name|set_sign_bit_copies
operator|>
literal|8
operator|&&
operator|(
name|val
operator|&
operator|(
operator|-
literal|1
operator|<<
operator|(
literal|32
operator|-
name|set_sign_bit_copies
operator|)
operator|)
operator|)
operator|==
name|val
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|set_sign_bit_copies
argument_list|)
decl_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|sub
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
if|if
condition|(
name|set_zero_bit_copies
operator|>
literal|8
operator|&&
operator|(
name|remainder
operator|&
operator|(
operator|(
literal|1
operator|<<
name|set_zero_bit_copies
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
name|remainder
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|set_zero_bit_copies
argument_list|)
decl_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_LSHIFTRT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|mode
argument_list|,
name|sub
argument_list|,
name|shift
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|2
return|;
block|}
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|temp1
operator|=
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|val
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|sub
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|source
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|source
operator|=
name|sub
expr_stmt|;
if|if
condition|(
name|subtargets
condition|)
name|sub
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|sub
argument_list|,
name|gen_rtx_AND
argument_list|(
name|mode
argument_list|,
name|source
argument_list|,
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|target
argument_list|,
name|gen_rtx_NOT
argument_list|(
name|mode
argument_list|,
name|sub
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|3
return|;
block|}
break|break;
case|case
name|AND
case|:
comment|/* See if two shifts will do 2 or more insn's worth of work.  */
if|if
condition|(
name|clear_sign_bit_copies
operator|>=
literal|16
operator|&&
name|clear_sign_bit_copies
operator|<
literal|24
condition|)
block|{
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|(
operator|(
literal|0xffffffff
operator|<<
operator|(
literal|32
operator|-
name|clear_sign_bit_copies
operator|)
operator|)
operator|&
literal|0xffffffff
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|remainder
operator||
name|shift_mask
operator|)
operator|!=
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|cond
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|targ
init|=
name|subtargets
condition|?
name|NULL_RTX
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|cond
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|targ
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|clear_sign_bit_copies
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|new_src
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|insns
operator|+
literal|2
return|;
block|}
if|if
condition|(
name|clear_zero_bit_copies
operator|>=
literal|16
operator|&&
name|clear_zero_bit_copies
operator|<
literal|24
condition|)
block|{
name|HOST_WIDE_INT
name|shift_mask
init|=
operator|(
literal|1
operator|<<
name|clear_zero_bit_copies
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|remainder
operator||
name|shift_mask
operator|)
operator|!=
literal|0xffffffff
condition|)
block|{
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|cond
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|new_src
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|targ
init|=
name|subtargets
condition|?
name|NULL_RTX
else|:
name|target
decl_stmt|;
name|insns
operator|=
name|arm_gen_constant
argument_list|(
name|AND
argument_list|,
name|mode
argument_list|,
name|cond
argument_list|,
name|remainder
operator||
name|shift_mask
argument_list|,
name|targ
argument_list|,
name|source
argument_list|,
name|subtargets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
init|=
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
decl_stmt|;
name|rtx
name|shift
init|=
name|GEN_INT
argument_list|(
name|clear_zero_bit_copies
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|new_src
argument_list|,
name|source
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_ashlsi3
argument_list|(
name|target
argument_list|,
name|new_src
argument_list|,
name|shift
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|insns
operator|+
literal|2
return|;
block|}
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|remainder
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|num_bits_set
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|AND
operator|||
operator|(
name|can_invert
operator|&&
name|num_bits_set
operator|>
literal|16
operator|)
condition|)
name|remainder
operator|=
operator|(
operator|~
name|remainder
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS
operator|&&
name|num_bits_set
operator|>
literal|16
condition|)
name|remainder
operator|=
operator|(
operator|-
name|remainder
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
else|else
block|{
name|can_invert
operator|=
literal|0
expr_stmt|;
name|can_negate
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now try and find a way of doing the job in either two or three      instructions.      We start by looking for the largest block of zeros that are aligned on      a 2-bit boundary, we then fill up the temps, wrapping around to the      top of the word when we drop off the bottom.      In the worst case this code should produce no more than four insns.  */
block|{
name|int
name|best_start
init|=
literal|0
decl_stmt|;
name|int
name|best_consecutive_zeros
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|int
name|consecutive_zeros
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
name|i
operator|)
operator|)
condition|)
block|{
while|while
condition|(
operator|(
name|i
operator|<
literal|32
operator|)
operator|&&
operator|!
operator|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
name|i
operator|)
operator|)
condition|)
block|{
name|consecutive_zeros
operator|+=
literal|2
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|consecutive_zeros
operator|>
name|best_consecutive_zeros
condition|)
block|{
name|best_consecutive_zeros
operator|=
name|consecutive_zeros
expr_stmt|;
name|best_start
operator|=
name|i
operator|-
name|consecutive_zeros
expr_stmt|;
block|}
name|i
operator|-=
literal|2
expr_stmt|;
block|}
block|}
comment|/* So long as it won't require any more insns to do so, it's        desirable to emit a small constant (in bits 0...9) in the last        insn.  This way there is more chance that it can be combined with        a later addressing insn to form a pre-indexed load or store        operation.  Consider:  	       *((volatile int *)0xe0000100) = 1; 	       *((volatile int *)0xe0000110) = 2;         We want this to wind up as:  		mov rA, #0xe0000000 		mov rB, #1 		str rB, [rA, #0x100] 		mov rB, #2 		str rB, [rA, #0x110]         rather than having to synthesize both large constants from scratch.         Therefore, we calculate how many insns would be required to emit        the constant starting from `best_start', and also starting from        zero (i.e. with bit 31 first to be output).  If `best_start' doesn't        yield a shorter sequence, we may as well use zero.  */
if|if
condition|(
name|best_start
operator|!=
literal|0
operator|&&
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|best_start
operator|)
operator|<
name|remainder
operator|)
operator|&&
operator|(
name|count_insns_for_constant
argument_list|(
name|remainder
argument_list|,
literal|0
argument_list|)
operator|<=
name|count_insns_for_constant
argument_list|(
name|remainder
argument_list|,
name|best_start
argument_list|)
operator|)
condition|)
name|best_start
operator|=
literal|0
expr_stmt|;
comment|/* Now start emitting the insns.  */
name|i
operator|=
name|best_start
expr_stmt|;
do|do
block|{
name|int
name|end
decl_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
name|remainder
operator|&
operator|(
literal|3
operator|<<
operator|(
name|i
operator|-
literal|2
operator|)
operator|)
condition|)
block|{
name|end
operator|=
name|i
operator|-
literal|8
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|+=
literal|32
expr_stmt|;
name|temp1
operator|=
name|remainder
operator|&
operator|(
operator|(
literal|0x0ff
operator|<<
name|end
operator|)
operator||
operator|(
operator|(
name|i
operator|<
name|end
operator|)
condition|?
operator|(
literal|0xff
operator|>>
operator|(
literal|32
operator|-
name|end
operator|)
operator|)
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|remainder
operator|&=
operator|~
name|temp1
expr_stmt|;
if|if
condition|(
name|generate
condition|)
block|{
name|rtx
name|new_src
decl_stmt|,
name|temp1_rtx
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|MINUS
condition|)
block|{
name|new_src
operator|=
operator|(
name|subtargets
condition|?
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
else|:
name|target
operator|)
expr_stmt|;
if|if
condition|(
name|can_invert
operator|&&
name|code
operator|!=
name|MINUS
condition|)
name|temp1
operator|=
operator|~
name|temp1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remainder
operator|&&
name|subtargets
condition|)
name|new_src
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|new_src
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|can_invert
condition|)
name|temp1
operator|=
operator|~
name|temp1
expr_stmt|;
elseif|else
if|if
condition|(
name|can_negate
condition|)
name|temp1
operator|=
operator|-
name|temp1
expr_stmt|;
block|}
name|temp1
operator|=
name|trunc_int_for_mode
argument_list|(
name|temp1
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|temp1_rtx
operator|=
name|GEN_INT
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|temp1_rtx
operator|=
name|gen_rtx_MINUS
argument_list|(
name|mode
argument_list|,
name|temp1_rtx
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
name|temp1_rtx
operator|=
name|gen_rtx_fmt_ee
argument_list|(
name|code
argument_list|,
name|mode
argument_list|,
name|source
argument_list|,
name|temp1_rtx
argument_list|)
expr_stmt|;
name|emit_constant_insn
argument_list|(
name|cond
argument_list|,
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|new_src
argument_list|,
name|temp1_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|source
operator|=
name|new_src
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|can_invert
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|PLUS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|MINUS
condition|)
name|code
operator|=
name|PLUS
expr_stmt|;
name|insns
operator|++
expr_stmt|;
name|i
operator|-=
literal|6
expr_stmt|;
block|}
name|i
operator|-=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|remainder
condition|)
do|;
block|}
return|return
name|insns
return|;
block|}
end_function

begin_comment
comment|/* Canonicalize a comparison so that we are more likely to recognize it.    This can be done for a few constant compares, where we can make the    immediate value easier to load.  */
end_comment

begin_function
name|enum
name|rtx_code
name|arm_canonicalize_comparison
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
modifier|*
name|op1
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
name|INTVAL
argument_list|(
operator|*
name|op1
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|maxval
decl_stmt|;
name|maxval
operator|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
return|return
name|code
return|;
case|case
name|GT
case|:
case|case
name|LE
case|:
if|if
condition|(
name|i
operator|!=
name|maxval
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GT
condition|?
name|GE
else|:
name|LT
return|;
block|}
break|break;
case|case
name|GE
case|:
case|case
name|LT
case|:
if|if
condition|(
name|i
operator|!=
operator|~
name|maxval
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GE
condition|?
name|GT
else|:
name|LE
return|;
block|}
break|break;
case|case
name|GTU
case|:
case|case
name|LEU
case|:
if|if
condition|(
name|i
operator|!=
operator|~
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GTU
condition|?
name|GEU
else|:
name|LTU
return|;
block|}
break|break;
case|case
name|GEU
case|:
case|case
name|LTU
case|:
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|(
name|const_ok_for_arm
argument_list|(
name|i
operator|-
literal|1
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
operator|(
name|i
operator|-
literal|1
operator|)
argument_list|)
operator|)
condition|)
block|{
operator|*
name|op1
operator|=
name|GEN_INT
argument_list|(
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|code
operator|==
name|GEU
condition|?
name|GTU
else|:
name|LEU
return|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Define how to find the value returned by a function.  */
end_comment

begin_function
name|rtx
name|arm_function_value
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|func
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|r
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Promote integer types.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|PROMOTE_FUNCTION_MODE
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Promotes small structs returned in a register to full-word size      for big-endian AAPCS.  */
if|if
condition|(
name|arm_return_in_msb
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|%
name|UNITS_PER_WORD
operator|!=
literal|0
condition|)
block|{
name|size
operator|+=
name|UNITS_PER_WORD
operator|-
name|size
operator|%
name|UNITS_PER_WORD
expr_stmt|;
name|mode
operator|=
name|mode_for_size
argument_list|(
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|LIBCALL_VALUE
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine the amount of memory needed to store the possible return    registers of an untyped call.  */
end_comment

begin_function
name|int
name|arm_apply_result_size
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|size
init|=
literal|16
decl_stmt|;
if|if
condition|(
name|TARGET_ARM
condition|)
block|{
if|if
condition|(
name|TARGET_HARD_FLOAT_ABI
condition|)
block|{
if|if
condition|(
name|TARGET_FPA
condition|)
name|size
operator|+=
literal|12
expr_stmt|;
if|if
condition|(
name|TARGET_MAVERICK
condition|)
name|size
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_IWMMXT_ABI
condition|)
name|size
operator|+=
literal|8
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Decide whether a type should be returned in memory (true)    or in a register (false).  This is called by the macro    RETURN_IN_MEMORY.  */
end_comment

begin_function
name|int
name|arm_return_in_memory
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|HOST_WIDE_INT
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VECTOR_TYPE
operator|)
operator|&&
operator|!
operator|(
name|TARGET_AAPCS_BASED
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
comment|/* All simple types are returned in registers.        For AAPCS, complex types are treated the same as aggregates.  */
return|return
literal|0
return|;
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_abi
operator|!=
name|ARM_ABI_APCS
condition|)
block|{
comment|/* ATPCS and later return aggregate types in memory only if they are 	 larger than a word (or are variable size).  */
return|return
operator|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>
name|UNITS_PER_WORD
operator|)
return|;
block|}
comment|/* To maximize backwards compatibility with previous versions of gcc,      return vectors up to 4 words in registers.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
operator|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>
operator|(
literal|4
operator|*
name|UNITS_PER_WORD
operator|)
operator|)
return|;
comment|/* For the arm-wince targets we choose to be compatible with Microsoft's      ARM and Thumb compilers, which always return aggregates in memory.  */
ifndef|#
directive|ifndef
name|ARM_WINCE
comment|/* All structures/unions bigger than one word are returned in memory.      Also catch the case where int_size_in_bytes returns -1.  In this case      the aggregate is either huge or of variable size, and in either case      we will want to return it via memory and not in a register.  */
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>
name|UNITS_PER_WORD
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* For a struct the APCS says that we only return in a register 	 if the type is 'integer like' and every addressable element 	 has an offset of zero.  For practical purposes this means 	 that the structure can have at most one non bit-field element 	 and that this element must be the first one in the structure.  */
comment|/* Find the first field, ignoring non FIELD_DECL things which will 	 have been created by C++.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
operator|&&
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
continue|continue;
if|if
condition|(
name|field
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* An empty structure.  Allowed by an extension to ANSI C.  */
comment|/* Check that the first field is valid for returning in a register.  */
comment|/* ... Floats are not allowed */
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* ... Aggregates that are not themselves valid for returning in 	 a register are not allowed.  */
if|if
condition|(
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Now check the remaining fields, if any.  Only bitfields are allowed, 	 since they are not addressable.  */
for|for
control|(
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|field
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|tree
name|field
decl_stmt|;
comment|/* Unions can be returned in registers if every element is 	 integral, or can be returned in an integer register.  */
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
continue|continue;
if|if
condition|(
name|FLOAT_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|RETURN_IN_MEMORY
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* not ARM_WINCE */
comment|/* Return all other types in memory.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Indicate whether or not words of a double are in big-endian order.  */
end_comment

begin_function
name|int
name|arm_float_words_big_endian
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|TARGET_MAVERICK
condition|)
return|return
literal|0
return|;
comment|/* For FPA, float words are always big-endian.  For VFP, floats words      follow the memory system mode.  */
if|if
condition|(
name|TARGET_FPA
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|TARGET_VFP
condition|)
return|return
operator|(
name|TARGET_BIG_END
condition|?
literal|1
else|:
literal|0
operator|)
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Initialize a variable CUM of type CUMULATIVE_ARGS    for a call to a function whose data type is FNTYPE.    For a library call, FNTYPE is NULL.  */
end_comment

begin_function
name|void
name|arm_init_cumulative_args
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|pcum
parameter_list|,
name|tree
name|fntype
parameter_list|,
name|rtx
name|libname
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|fndecl
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* On the ARM, the offset starts at 0.  */
name|pcum
operator|->
name|nregs
operator|=
literal|0
expr_stmt|;
name|pcum
operator|->
name|iwmmxt_nregs
operator|=
literal|0
expr_stmt|;
name|pcum
operator|->
name|can_split
operator|=
name|true
expr_stmt|;
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_NORMAL
expr_stmt|;
if|if
condition|(
name|TARGET_LONG_CALLS
condition|)
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_LONG
expr_stmt|;
comment|/* Check for long call/short call attributes.  The attributes      override any command line option.  */
if|if
condition|(
name|fntype
condition|)
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_SHORT
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|fntype
argument_list|)
argument_list|)
condition|)
name|pcum
operator|->
name|call_cookie
operator|=
name|CALL_LONG
expr_stmt|;
block|}
comment|/* Varargs vectors are treated the same as long long.      named_count avoids having to change the way arm handles 'named' */
name|pcum
operator|->
name|named_count
operator|=
literal|0
expr_stmt|;
name|pcum
operator|->
name|nargs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_REALLY_IWMMXT
operator|&&
name|fntype
condition|)
block|{
name|tree
name|fn_arg
decl_stmt|;
for|for
control|(
name|fn_arg
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
init|;
name|fn_arg
condition|;
name|fn_arg
operator|=
name|TREE_CHAIN
argument_list|(
name|fn_arg
argument_list|)
control|)
name|pcum
operator|->
name|named_count
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|pcum
operator|->
name|named_count
condition|)
name|pcum
operator|->
name|named_count
operator|=
name|INT_MAX
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if mode/type need doubleword alignment.  */
end_comment

begin_function
name|bool
name|arm_needs_doubleword_align
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
return|return
operator|(
name|GET_MODE_ALIGNMENT
argument_list|(
name|mode
argument_list|)
operator|>
name|PARM_BOUNDARY
operator|||
operator|(
name|type
operator|&&
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|>
name|PARM_BOUNDARY
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine where to put an argument to a function.    Value is zero to push the argument on the stack,    or a hard register in which to store the argument.     MODE is the argument's machine mode.    TYPE is the data type of the argument (as a tree).     This is null for libcalls where that information may     not be available.    CUM is a variable of type CUMULATIVE_ARGS which gives info about     the preceding args and about the function being called.    NAMED is nonzero if this argument is a named parameter     (otherwise it is an extra parameter matching an ellipsis).  */
end_comment

begin_function
name|rtx
name|arm_function_arg
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|pcum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|named
parameter_list|)
block|{
name|int
name|nregs
decl_stmt|;
comment|/* Varargs vectors are treated the same as long long.      named_count avoids having to change the way arm handles 'named' */
if|if
condition|(
name|TARGET_IWMMXT_ABI
operator|&&
name|arm_vector_mode_supported_p
argument_list|(
name|mode
argument_list|)
operator|&&
name|pcum
operator|->
name|named_count
operator|>
name|pcum
operator|->
name|nargs
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|pcum
operator|->
name|iwmmxt_nregs
operator|<=
literal|9
condition|)
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|pcum
operator|->
name|iwmmxt_nregs
operator|+
name|FIRST_IWMMXT_REGNUM
argument_list|)
return|;
else|else
block|{
name|pcum
operator|->
name|can_split
operator|=
name|false
expr_stmt|;
return|return
name|NULL_RTX
return|;
block|}
block|}
comment|/* Put doubleword aligned quantities in even register pairs.  */
if|if
condition|(
name|pcum
operator|->
name|nregs
operator|&
literal|1
operator|&&
name|ARM_DOUBLEWORD_ALIGN
operator|&&
name|arm_needs_doubleword_align
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
condition|)
name|pcum
operator|->
name|nregs
operator|++
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
comment|/* Compute operand 2 of the call insn.  */
return|return
name|GEN_INT
argument_list|(
name|pcum
operator|->
name|call_cookie
argument_list|)
return|;
comment|/* Only allow splitting an arg between regs and memory if all preceding      args were allocated to regs.  For args passed by reference we only count      the reference pointer.  */
if|if
condition|(
name|pcum
operator|->
name|can_split
condition|)
name|nregs
operator|=
literal|1
expr_stmt|;
else|else
name|nregs
operator|=
name|ARM_NUM_REGS2
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|named
operator|||
name|pcum
operator|->
name|nregs
operator|+
name|nregs
operator|>
name|NUM_ARG_REGS
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|pcum
operator|->
name|nregs
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_arg_partial_bytes
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|pcum
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|nregs
init|=
name|pcum
operator|->
name|nregs
decl_stmt|;
if|if
condition|(
name|arm_vector_mode_supported_p
argument_list|(
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|NUM_ARG_REGS
operator|>
name|nregs
operator|&&
operator|(
name|NUM_ARG_REGS
operator|<
name|nregs
operator|+
name|ARM_NUM_REGS2
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|)
operator|&&
name|pcum
operator|->
name|can_split
condition|)
return|return
operator|(
name|NUM_ARG_REGS
operator|-
name|nregs
operator|)
operator|*
name|UNITS_PER_WORD
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Variable sized types are passed by reference.  This is a GCC    extension to the ARM ABI.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_pass_by_reference
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
parameter_list|,
name|bool
name|named
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Encode the current state of the #pragma [no_]long_calls.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|OFF
block|,
comment|/* No #pragma [no_]long_calls is in effect.  */
name|LONG
block|,
comment|/* #pragma long_calls is in effect.  */
name|SHORT
comment|/* #pragma no_long_calls is in effect.  */
block|}
name|arm_pragma_enum
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|arm_pragma_enum
name|arm_pragma_long_calls
init|=
name|OFF
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|arm_pr_long_calls
parameter_list|(
name|struct
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|arm_pragma_long_calls
operator|=
name|LONG
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_pr_no_long_calls
parameter_list|(
name|struct
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|arm_pragma_long_calls
operator|=
name|SHORT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_pr_long_calls_off
parameter_list|(
name|struct
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|arm_pragma_long_calls
operator|=
name|OFF
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of machine attributes.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|arm_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
comment|/* Function calls made to this symbol must be done indirectly, because      it may lie outside of the 26 bit addressing range of a normal function      call.  */
block|{
literal|"long_call"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|NULL
block|}
block|,
comment|/* Whereas these functions are always known to reside within the 26 bit      addressing range.  */
block|{
literal|"short_call"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|NULL
block|}
block|,
comment|/* Interrupt Service Routines have special prologue and epilogue requirements.  */
block|{
literal|"isr"
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|arm_handle_isr_attribute
block|}
block|,
block|{
literal|"interrupt"
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|arm_handle_isr_attribute
block|}
block|,
block|{
literal|"naked"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|arm_handle_fndecl_attribute
block|}
block|,
ifdef|#
directive|ifdef
name|ARM_PE
comment|/* ARM/PE has three new attributes:      interfacearm - ?      dllexport - for exporting a function/variable that will live in a dll      dllimport - for importing a function/variable from a dll       Microsoft allows multiple declspecs in one __declspec, separating      them with spaces.  We do NOT support this.  Instead, use __declspec      multiple times.   */
block|{
literal|"dllimport"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"dllexport"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"interfacearm"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|arm_handle_fndecl_attribute
block|}
block|,
elif|#
directive|elif
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
block|{
literal|"dllimport"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_dll_attribute
block|}
block|,
block|{
literal|"dllexport"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_dll_attribute
block|}
block|,
block|{
literal|"notshared"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|arm_handle_notshared_attribute
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle an attribute requiring a FUNCTION_DECL;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|arm_handle_fndecl_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle an "interrupt" or "isr" attribute;    arguments as in struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|arm_handle_isr_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute only applies to functions"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
comment|/* FIXME: the argument if any is checked for type attributes; 	 should it be checked for decl ones?  */
block|}
else|else
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|arm_isr_value
argument_list|(
name|args
argument_list|)
operator|==
name|ARM_FT_UNKNOWN
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
name|arm_isr_value
argument_list|(
name|args
argument_list|)
operator|!=
name|ARM_FT_UNKNOWN
condition|)
block|{
operator|*
name|node
operator|=
name|build_variant_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
name|build_type_attribute_variant
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* Possibly pass this attribute on from the type to a decl.  */
if|if
condition|(
name|flags
operator|&
operator|(
operator|(
name|int
operator|)
name|ATTR_FLAG_DECL_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_FUNCTION_NEXT
operator||
operator|(
name|int
operator|)
name|ATTR_FLAG_ARRAY_NEXT
operator|)
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|tree_cons
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qs attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_if
if|#
directive|if
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
end_if

begin_comment
comment|/* Handle the "notshared" attribute.  This attribute is another way of    requesting hidden visibility.  ARM's compiler supports    "__declspec(notshared)"; we support the same thing via an    attribute.  */
end_comment

begin_function
specifier|static
name|tree
name|arm_handle_notshared_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|decl
init|=
name|TYPE_NAME
argument_list|(
operator|*
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|VISIBILITY_HIDDEN
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|false
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return 0 if the attributes for two types are incompatible, 1 if they    are compatible, and 2 if they are nearly compatible (which causes a    warning to be generated).  */
end_comment

begin_function
specifier|static
name|int
name|arm_comp_type_attributes
parameter_list|(
name|tree
name|type1
parameter_list|,
name|tree
name|type2
parameter_list|)
block|{
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|s1
decl_stmt|,
name|s2
decl_stmt|;
comment|/* Check for mismatch of non-default calling convention.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type1
argument_list|)
operator|!=
name|FUNCTION_TYPE
condition|)
return|return
literal|1
return|;
comment|/* Check for mismatched call attributes.  */
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|l2
operator|=
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|s1
operator|=
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|s2
operator|=
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
comment|/* Only bother to check if an attribute is defined.  */
if|if
condition|(
name|l1
operator||
name|l2
operator||
name|s1
operator||
name|s2
condition|)
block|{
comment|/* If one type has an attribute, the other must have the same attribute.  */
if|if
condition|(
operator|(
name|l1
operator|!=
name|l2
operator|)
operator|||
operator|(
name|s1
operator|!=
name|s2
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Disallow mixed attributes.  */
if|if
condition|(
operator|(
name|l1
operator|&
name|s2
operator|)
operator|||
operator|(
name|l2
operator|&
name|s1
operator|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Check for mismatched ISR attribute.  */
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"isr"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|l1
condition|)
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"interrupt"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type1
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|l2
operator|=
name|lookup_attribute
argument_list|(
literal|"isr"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|l2
condition|)
name|l1
operator|=
name|lookup_attribute
argument_list|(
literal|"interrupt"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|l1
operator|!=
name|l2
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  Encode long_call or short_call attribute by prefixing     symbol name in DECL with a special character FLAG.  */
end_comment

begin_function
name|void
name|arm_encode_call_attribute
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
name|char
modifier|*
name|newstr
decl_stmt|;
comment|/* Do not allow weak functions to be treated as short call.  */
if|if
condition|(
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
operator|&&
name|flag
operator|==
name|SHORT_CALL_FLAG_CHAR
condition|)
return|return;
name|newstr
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
name|newstr
index|[
literal|0
index|]
operator|=
name|flag
expr_stmt|;
name|strcpy
argument_list|(
name|newstr
operator|+
literal|1
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|newstr
operator|=
operator|(
name|char
operator|*
operator|)
name|ggc_alloc_string
argument_list|(
name|newstr
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|=
name|newstr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Assigns default attributes to newly defined type.  This is used to     set short_call/long_call attributes for function types of     functions defined inside corresponding #pragma scopes.  */
end_comment

begin_function
specifier|static
name|void
name|arm_set_default_type_attributes
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* Add __attribute__ ((long_call)) to all functions, when      inside #pragma long_calls or __attribute__ ((short_call)),      when inside #pragma no_long_calls.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
name|tree
name|type_attr_list
decl_stmt|,
name|attr_name
decl_stmt|;
name|type_attr_list
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_pragma_long_calls
operator|==
name|LONG
condition|)
name|attr_name
operator|=
name|get_identifier
argument_list|(
literal|"long_call"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arm_pragma_long_calls
operator|==
name|SHORT
condition|)
name|attr_name
operator|=
name|get_identifier
argument_list|(
literal|"short_call"
argument_list|)
expr_stmt|;
else|else
return|return;
name|type_attr_list
operator|=
name|tree_cons
argument_list|(
name|attr_name
argument_list|,
name|NULL_TREE
argument_list|,
name|type_attr_list
argument_list|)
expr_stmt|;
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
operator|=
name|type_attr_list
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the operand is a SYMBOL_REF for a function known to be    defined within the current compilation unit.  If this cannot be    determined, then 0 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|current_file_function_operand
parameter_list|(
name|rtx
name|sym_ref
parameter_list|)
block|{
comment|/* This is a bit of a fib.  A function will have a short call flag      applied to its name if it has the short call attribute, or it has      already been defined within the current compilation unit.  */
if|if
condition|(
name|ENCODED_SHORT_CALL_ATTR_P
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The current function is always defined within the current compilation      unit.  If it s a weak definition however, then this may not be the real      definition of the function, and so we have to say no.  */
if|if
condition|(
name|sym_ref
operator|==
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|current_function_decl
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We cannot make the determination - default to returning 0.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if a 32 bit "long_call" should be generated for    this call.  We generate a long_call if the function:          a.  has an __attribute__((long call))      or b.  is within the scope of a #pragma long_calls      or c.  the -mlong-calls command line switch has been specified          .  and either:                 1. -ffunction-sections is in effect 	     or 2. the current function has __attribute__ ((section)) 	     or 3. the target function has __attribute__ ((section))     However we do not generate a long call if the function:          d.  has an __attribute__ ((short_call))      or e.  is inside the scope of a #pragma no_long_calls      or f.  is defined within the current compilation unit.     This function will be called by C fragments contained in the machine    description file.  SYM_REF and CALL_COOKIE correspond to the matched    rtl operands.  CALL_SYMBOL is used to distinguish between    two different callers of the function.  It is set to 1 in the    "call_symbol" and "call_symbol_value" patterns and to 0 in the "call"    and "call_value" patterns.  This is because of the difference in the    SYM_REFs passed by these patterns.  */
end_comment

begin_function
name|int
name|arm_is_longcall_p
parameter_list|(
name|rtx
name|sym_ref
parameter_list|,
name|int
name|call_cookie
parameter_list|,
name|int
name|call_symbol
parameter_list|)
block|{
if|if
condition|(
operator|!
name|call_symbol
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|sym_ref
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
name|sym_ref
operator|=
name|XEXP
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|sym_ref
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|call_cookie
operator|&
name|CALL_SHORT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TARGET_LONG_CALLS
condition|)
block|{
if|if
condition|(
name|flag_function_sections
operator|||
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
comment|/* c.3 is handled by the definition of the 	   ARM_DECLARE_FUNCTION_SIZE macro.  */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|current_file_function_operand
argument_list|(
name|sym_ref
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|call_cookie
operator|&
name|CALL_LONG
operator|)
operator|||
name|ENCODED_LONG_CALL_ATTR_P
argument_list|(
name|XSTR
argument_list|(
name|sym_ref
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|TARGET_LONG_CALLS
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if it is ok to make a tail-call to DECL.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_function_ok_for_sibcall
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|exp
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|call_type
init|=
name|TARGET_LONG_CALLS
condition|?
name|CALL_LONG
else|:
name|CALL_NORMAL
decl_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|sibcall_blocked
condition|)
return|return
name|false
return|;
comment|/* Never tailcall something for which we have no decl, or if we      are in Thumb mode.  */
if|if
condition|(
name|decl
operator|==
name|NULL
operator|||
name|TARGET_THUMB
condition|)
return|return
name|false
return|;
comment|/* Get the calling method.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"short_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|call_type
operator|=
name|CALL_SHORT
expr_stmt|;
elseif|else
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"long_call"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|call_type
operator|=
name|CALL_LONG
expr_stmt|;
comment|/* Cannot tail-call to long calls, since these are out of range of      a branch instruction.  However, if not compiling PIC, we know      we can reach the symbol if it is in this compilation unit.  */
if|if
condition|(
name|call_type
operator|==
name|CALL_LONG
operator|&&
operator|(
name|flag_pic
operator|||
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* If we are interworking and the function is not declared static      then we can't tail-call it unless we know that it exists in this      compilation unit (since it might be a Thumb routine).  */
if|if
condition|(
name|TARGET_INTERWORK
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Never tailcall from an ISR routine - it needs a special exit sequence.  */
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|arm_current_func_type
argument_list|()
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Everything else is ok.  */
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Addressing mode support functions.  */
end_comment

begin_comment
comment|/* Return nonzero if X is a legitimate immediate operand when compiling    for PIC.  We know that X satisfies CONSTANT_P and flag_pic is true.  */
end_comment

begin_function
name|int
name|legitimate_pic_operand_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|rtx
name|legitimize_pic_address
parameter_list|(
name|rtx
name|orig
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
name|rtx
name|pic_ref
decl_stmt|,
name|address
decl_stmt|;
endif|#
directive|endif
name|rtx
name|insn
decl_stmt|;
name|int
name|subregs
init|=
literal|0
decl_stmt|;
comment|/* If this function doesn't have a pic register, create one now. 	 A lot of the logic here is made obscure by the fact that this 	 routine gets called as part of the rtx cost estimation 	 process.  We don't want those calls to affect any assumptions 	 about the real function; and further, we can't call 	 entry_of_function() until we start the real expansion 	 process.  */
if|if
condition|(
operator|!
name|current_function_uses_pic_offset_table
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|no_new_pseudos
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_pic_register
operator|!=
name|INVALID_REGNUM
condition|)
block|{
if|if
condition|(
operator|!
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
condition|)
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|arm_pic_register
argument_list|)
expr_stmt|;
comment|/* Play games to avoid marking the function as needing pic 		 if we are being called as part of the cost-estimation 		 process.  */
if|if
condition|(
operator|!
name|ir_type
argument_list|()
condition|)
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|seq
decl_stmt|;
if|if
condition|(
operator|!
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
condition|)
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
comment|/* Play games to avoid marking the function as needing pic 		 if we are being called as part of the cost-estimation 		 process.  */
if|if
condition|(
operator|!
name|ir_type
argument_list|()
condition|)
block|{
name|current_function_uses_pic_offset_table
operator|=
literal|1
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|arm_load_pic_register
argument_list|(
literal|0UL
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|entry_of_function
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|no_new_pseudos
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|subregs
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
comment|/* The AOF assembler can generate relocations for these directly, and 	 understands that the PIC register has to be added into the offset.  */
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_pic_load_addr_based
argument_list|(
name|reg
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|subregs
condition|)
name|address
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
else|else
name|address
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
condition|)
name|emit_insn
argument_list|(
name|gen_pic_load_addr_arm
argument_list|(
name|address
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_pic_load_addr_thumb
argument_list|(
name|address
argument_list|,
name|orig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|orig
argument_list|)
operator|)
operator|)
operator|&&
name|NEED_GOT_RELOC
condition|)
name|pic_ref
operator|=
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
argument_list|,
name|address
argument_list|)
expr_stmt|;
else|else
block|{
name|pic_ref
operator|=
name|gen_const_mem
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
argument_list|,
name|address
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|pic_ref
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Put a REG_EQUAL note on this insn, so that it can be optimized 	 by loop.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_EQUAL
argument_list|,
name|orig
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
operator|==
name|CONST
condition|)
block|{
name|rtx
name|base
decl_stmt|,
name|offset
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLS
condition|)
return|return
name|orig
return|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|no_new_pseudos
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
argument_list|)
expr_stmt|;
name|base
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|offset
operator|=
name|legitimize_pic_address
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|base
operator|==
name|reg
condition|?
literal|0
else|:
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* The base register doesn't really matter, we only want to 	     test the index for the appropriate mode.  */
if|if
condition|(
operator|!
name|arm_legitimate_index_p
argument_list|(
name|mode
argument_list|,
name|offset
argument_list|,
name|SET
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|no_new_pseudos
argument_list|)
expr_stmt|;
name|offset
operator|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|plus_constant
argument_list|(
name|base
argument_list|,
name|INTVAL
argument_list|(
name|offset
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|4
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|||
name|TARGET_SOFT_FLOAT
operator|)
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|reg
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|base
argument_list|,
name|offset
argument_list|)
return|;
block|}
return|return
name|orig
return|;
block|}
end_function

begin_comment
comment|/* Find a spare low register to use during the prolog of a function.  */
end_comment

begin_function
specifier|static
name|int
name|thumb_find_work_register
parameter_list|(
name|unsigned
name|long
name|pushed_regs_mask
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
comment|/* Check the argument registers first as these are call-used.  The      register allocation order means that sometimes r3 might be used      but earlier argument registers might not, so check them all.  */
for|for
control|(
name|reg
operator|=
name|LAST_ARG_REGNUM
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|reg
index|]
condition|)
return|return
name|reg
return|;
comment|/* Before going on to check the call-saved registers we can try a couple      more ways of deducing that r3 is available.  The first is when we are      pushing anonymous arguments onto the stack and we have less than 4      registers worth of fixed arguments(*).  In this case r3 will be part of      the variable argument list and so we can be sure that it will be      pushed right at the start of the function.  Hence it will be available      for the rest of the prologue.      (*): ie current_function_pretend_args_size is greater than 0.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
operator|&&
name|current_function_pretend_args_size
operator|>
literal|0
condition|)
return|return
name|LAST_ARG_REGNUM
return|;
comment|/* The other case is when we have fixed arguments but less than 4 registers      worth.  In this case r3 might be used in the body of the function, but      it is not being used to convey an argument into the function.  In theory      we could just check current_function_args_size to see how many bytes are      being passed in argument registers, but it seems that it is unreliable.      Sometimes it will have the value 0 when in fact arguments are being      passed.  (See testcase execute/20021111-1.c for an example).  So we also      check the args_info.nregs field as well.  The problem with this field is      that it makes no allowances for arguments that are passed to the      function but which are not used.  Hence we could miss an opportunity      when a function has an unused argument in r3.  But it is better to be      safe than to be sorry.  */
if|if
condition|(
operator|!
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
operator|&&
name|current_function_args_size
operator|>=
literal|0
operator|&&
name|current_function_args_size
operator|<=
operator|(
name|LAST_ARG_REGNUM
operator|*
name|UNITS_PER_WORD
operator|)
operator|&&
name|cfun
operator|->
name|args_info
operator|.
name|nregs
operator|<
literal|4
condition|)
return|return
name|LAST_ARG_REGNUM
return|;
comment|/* Otherwise look for a call-saved register that is going to be pushed.  */
for|for
control|(
name|reg
operator|=
name|LAST_LO_REGNUM
init|;
name|reg
operator|>
name|LAST_ARG_REGNUM
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|pushed_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
condition|)
return|return
name|reg
return|;
comment|/* Something went wrong - thumb_compute_save_reg_mask()      should have arranged for a suitable register to be pushed.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|pic_labelno
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Generate code to load the PIC register.  In thumb mode SCRATCH is a    low register.  */
end_comment

begin_function
name|void
name|arm_load_pic_register
parameter_list|(
name|unsigned
name|long
name|saved_regs
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
name|rtx
name|l1
decl_stmt|,
name|labelno
decl_stmt|,
name|pic_tmp
decl_stmt|,
name|pic_tmp2
decl_stmt|,
name|pic_rtx
decl_stmt|;
name|rtx
name|global_offset_table
decl_stmt|;
if|if
condition|(
name|current_function_uses_pic_offset_table
operator|==
literal|0
operator|||
name|TARGET_SINGLE_PIC_BASE
condition|)
return|return;
name|gcc_assert
argument_list|(
name|flag_pic
argument_list|)
expr_stmt|;
comment|/* We use an UNSPEC rather than a LABEL_REF because this label never appears      in the code stream.  */
name|labelno
operator|=
name|GEN_INT
argument_list|(
name|pic_labelno
operator|++
argument_list|)
expr_stmt|;
name|l1
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|labelno
argument_list|)
argument_list|,
name|UNSPEC_PIC_LABEL
argument_list|)
expr_stmt|;
name|l1
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|global_offset_table
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
comment|/* On the ARM the PC register contains 'dot + 8' at the time of the      addition, on the Thumb it is 'dot + 4'.  */
name|pic_tmp
operator|=
name|plus_constant
argument_list|(
name|l1
argument_list|,
name|TARGET_ARM
condition|?
literal|8
else|:
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|GOT_PCREL
condition|)
name|pic_tmp2
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|global_offset_table
argument_list|,
name|pc_rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pic_tmp2
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|global_offset_table
argument_list|)
expr_stmt|;
name|pic_rtx
operator|=
name|gen_rtx_CONST
argument_list|(
name|Pmode
argument_list|,
name|gen_rtx_MINUS
argument_list|(
name|Pmode
argument_list|,
name|pic_tmp2
argument_list|,
name|pic_tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_pic_load_addr_arm
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
argument_list|,
name|pic_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pic_add_dot_plus_eight
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
argument_list|,
name|labelno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|arm_pic_register
operator|!=
name|INVALID_REGNUM
operator|&&
name|REGNO
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
argument_list|)
operator|>
name|LAST_LO_REGNUM
condition|)
block|{
comment|/* We will have pushed the pic register, so we should always be 	     able to find a work register.  */
name|pic_tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|thumb_find_work_register
argument_list|(
name|saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pic_load_addr_thumb
argument_list|(
name|pic_tmp
argument_list|,
name|pic_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|pic_offset_table_rtx
argument_list|,
name|pic_tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_insn
argument_list|(
name|gen_pic_load_addr_thumb
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
argument_list|,
name|pic_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_pic_add_dot_plus_four
argument_list|(
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
argument_list|,
name|labelno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Need to emit this whether or not we obey regdecls,      since setjmp/longjmp can cause life info to screw up.  */
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|pic_reg
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AOF_ASSEMBLER */
block|}
end_function

begin_comment
comment|/* Return nonzero if X is valid as an ARM state addressing register.  */
end_comment

begin_function
specifier|static
name|int
name|arm_address_register_rtx_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_p
condition|)
return|return
name|ARM_REGNO_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|)
return|;
return|return
operator|(
name|regno
operator|<=
name|LAST_ARM_REGNUM
operator|||
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if this rtx is the difference of a symbol and a label,    and will reduce to a PC-relative relocation in the object file.    Expressions like this can be left alone when generating PIC, rather    than forced through the GOT.  */
end_comment

begin_function
specifier|static
name|int
name|pcrel_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
condition|)
return|return
name|symbol_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|label_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X is a valid ARM state address operand.  */
end_comment

begin_function
name|int
name|arm_legitimate_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|RTX_CODE
name|outer
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
name|bool
name|use_ldrd
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|arm_address_register_rtx_p
argument_list|(
name|x
argument_list|,
name|strict_p
argument_list|)
condition|)
return|return
literal|1
return|;
name|use_ldrd
operator|=
operator|(
name|TARGET_LDRD
operator|&&
operator|(
name|mode
operator|==
name|DImode
operator|||
operator|(
name|mode
operator|==
name|DFmode
operator|&&
operator|(
name|TARGET_SOFT_FLOAT
operator|||
name|TARGET_VFP
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|POST_INC
operator|||
name|code
operator|==
name|PRE_DEC
operator|||
operator|(
operator|(
name|code
operator|==
name|PRE_INC
operator|||
name|code
operator|==
name|POST_DEC
operator|)
operator|&&
operator|(
name|use_ldrd
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
operator|)
operator|)
condition|)
return|return
name|arm_address_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|code
operator|==
name|POST_MODIFY
operator|||
name|code
operator|==
name|PRE_MODIFY
operator|)
operator|&&
name|arm_address_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|addend
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* Don't allow ldrd post increment by register because it's hard 	 to fixup invalid register choices.  */
if|if
condition|(
name|use_ldrd
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|POST_MODIFY
operator|&&
name|GET_CODE
argument_list|(
name|addend
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|use_ldrd
operator|||
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
operator|)
operator|&&
name|arm_legitimate_index_p
argument_list|(
name|mode
argument_list|,
name|addend
argument_list|,
name|outer
argument_list|,
name|strict_p
argument_list|)
operator|)
return|;
block|}
comment|/* After reload constants split into minipools will have addresses      from a LABEL_REF.  */
elseif|else
if|if
condition|(
name|reload_completed
operator|&&
operator|(
name|code
operator|==
name|LABEL_REF
operator|||
operator|(
name|code
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|TImode
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|xop0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|arm_address_register_rtx_p
argument_list|(
name|xop0
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|arm_legitimate_index_p
argument_list|(
name|mode
argument_list|,
name|xop1
argument_list|,
name|outer
argument_list|,
name|strict_p
argument_list|)
operator|)
operator|||
operator|(
name|arm_address_register_rtx_p
argument_list|(
name|xop1
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|arm_legitimate_index_p
argument_list|(
name|mode
argument_list|,
name|xop0
argument_list|,
name|outer
argument_list|,
name|strict_p
argument_list|)
operator|)
operator|)
return|;
block|}
if|#
directive|if
literal|0
comment|/* Reload currently can't handle MINUS, so disable this for now */
if|else if (GET_CODE (x) == MINUS)     {       rtx xop0 = XEXP (x, 0);       rtx xop1 = XEXP (x, 1);        return (arm_address_register_rtx_p (xop0, strict_p)&& arm_legitimate_index_p (mode, xop1, outer, strict_p));     }
endif|#
directive|endif
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|code
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
operator|(
name|flag_pic
operator|&&
name|symbol_mentioned_p
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|!
name|pcrel_constant_p
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if INDEX is valid for an address index operand in    ARM state.  */
end_comment

begin_function
specifier|static
name|int
name|arm_legitimate_index_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|index
parameter_list|,
name|RTX_CODE
name|outer
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
name|HOST_WIDE_INT
name|range
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|index
argument_list|)
decl_stmt|;
comment|/* Standard coprocessor addressing modes.  */
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
operator|(
name|TARGET_FPA
operator|||
name|TARGET_MAVERICK
operator|)
operator|&&
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
operator|(
name|TARGET_MAVERICK
operator|&&
name|mode
operator|==
name|DImode
operator|)
operator|)
condition|)
return|return
operator|(
name|code
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|<
literal|1024
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|>
operator|-
literal|1024
operator|&&
operator|(
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
return|;
if|if
condition|(
name|TARGET_REALLY_IWMMXT
operator|&&
name|VALID_IWMMXT_REG_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* For DImode assume values will usually live in core regs 	 and only allow LDRD addressing modes.  */
if|if
condition|(
operator|!
name|TARGET_LDRD
operator|||
name|mode
operator|!=
name|DImode
condition|)
return|return
operator|(
name|code
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|<
literal|1024
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|>
operator|-
literal|1024
operator|&&
operator|(
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|arm_address_register_rtx_p
argument_list|(
name|index
argument_list|,
name|strict_p
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
name|mode
operator|==
name|DFmode
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_LDRD
condition|)
return|return
name|val
operator|>
operator|-
literal|256
operator|&&
name|val
operator|<
literal|256
return|;
else|else
return|return
name|val
operator|>
operator|-
literal|4096
operator|&&
name|val
operator|<
literal|4092
return|;
block|}
return|return
name|TARGET_LDRD
operator|&&
name|arm_address_register_rtx_p
argument_list|(
name|index
argument_list|,
name|strict_p
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
operator|&&
operator|!
operator|(
name|arm_arch4
operator|&&
operator|(
name|mode
operator|==
name|HImode
operator|||
operator|(
name|mode
operator|==
name|QImode
operator|&&
name|outer
operator|==
name|SIGN_EXTEND
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|MULT
condition|)
block|{
name|rtx
name|xiop0
init|=
name|XEXP
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xiop1
init|=
name|XEXP
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|arm_address_register_rtx_p
argument_list|(
name|xiop0
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|power_of_two_operand
argument_list|(
name|xiop1
argument_list|,
name|SImode
argument_list|)
operator|)
operator|||
operator|(
name|arm_address_register_rtx_p
argument_list|(
name|xiop1
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|power_of_two_operand
argument_list|(
name|xiop0
argument_list|,
name|SImode
argument_list|)
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LSHIFTRT
operator|||
name|code
operator|==
name|ASHIFTRT
operator|||
name|code
operator|==
name|ASHIFT
operator|||
name|code
operator|==
name|ROTATERT
condition|)
block|{
name|rtx
name|op
init|=
name|XEXP
argument_list|(
name|index
argument_list|,
literal|1
argument_list|)
decl_stmt|;
return|return
operator|(
name|arm_address_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|index
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op
argument_list|)
operator|<=
literal|31
operator|)
return|;
block|}
block|}
comment|/* For ARM v4 we may be doing a sign-extend operation during the      load.  */
if|if
condition|(
name|arm_arch4
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|HImode
operator|||
operator|(
name|outer
operator|==
name|SIGN_EXTEND
operator|&&
name|mode
operator|==
name|QImode
operator|)
condition|)
name|range
operator|=
literal|256
expr_stmt|;
else|else
name|range
operator|=
literal|4096
expr_stmt|;
block|}
else|else
name|range
operator|=
operator|(
name|mode
operator|==
name|HImode
operator|)
condition|?
literal|4095
else|:
literal|4096
expr_stmt|;
return|return
operator|(
name|code
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|<
name|range
operator|&&
name|INTVAL
argument_list|(
name|index
argument_list|)
operator|>
operator|-
name|range
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if X is valid as a Thumb state base register.  */
end_comment

begin_function
specifier|static
name|int
name|thumb_base_register_rtx_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|strict_p
condition|)
return|return
name|THUMB_REGNO_MODE_OK_FOR_BASE_P
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
return|;
return|return
operator|(
name|regno
operator|<=
name|LAST_LO_REGNUM
operator|||
name|regno
operator|>
name|LAST_VIRTUAL_REGISTER
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
operator|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
operator|||
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|x
operator|==
name|hard_frame_pointer_rtx
operator|||
name|x
operator|==
name|arg_pointer_rtx
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if x is a legitimate index register.  This is the case    for any base register that can access a QImode object.  */
end_comment

begin_function
specifier|inline
specifier|static
name|int
name|thumb_index_register_rtx_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
return|return
name|thumb_base_register_rtx_p
argument_list|(
name|x
argument_list|,
name|QImode
argument_list|,
name|strict_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if x is a legitimate Thumb-state address.     The AP may be eliminated to either the SP or the FP, so we use the    least common denominator, e.g. SImode, and offsets from 0 to 64.     ??? Verify whether the above is the right approach.     ??? Also, the FP may be eliminated to the SP, so perhaps that    needs special handling also.     ??? Look at how the mips16 port solves this problem.  It probably uses    better ways to solve some of these problems.     Although it is not incorrect, we don't accept QImode and HImode    addresses based on the frame pointer or arg pointer until the    reload pass starts.  This is so that eliminating such addresses    into stack based ones won't produce impossible code.  */
end_comment

begin_function
name|int
name|thumb_legitimate_address_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|strict_p
parameter_list|)
block|{
comment|/* ??? Not clear if this is right.  Experiment.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
literal|4
operator|&&
operator|!
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|x
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|x
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|x
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|x
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|x
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|x
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Accept any base register.  SP only in SImode or larger.  */
elseif|else
if|if
condition|(
name|thumb_base_register_rtx_p
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|strict_p
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* This is PC relative data before arm_reorg runs.  */
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|flag_pic
condition|)
return|return
literal|1
return|;
comment|/* This is PC relative data after arm_reorg runs.  */
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
name|reload_completed
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Post-inc indexing only supported for SImode and larger.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|POST_INC
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
name|thumb_index_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* REG+REG address can be any two index registers.  */
comment|/* We disallow FRAME+REG addressing since we know that FRAME 	 will be replaced with STACK, and SP relative addressing only 	 permits SP+OFFSET.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|4
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|!=
name|frame_pointer_rtx
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|!=
name|frame_pointer_rtx
operator|&&
name|thumb_index_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
operator|&&
name|thumb_index_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|strict_p
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* REG+const has 5-7 bit offset for non-SP registers.  */
elseif|else
if|if
condition|(
operator|(
name|thumb_index_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strict_p
argument_list|)
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|thumb_legitimate_offset_p
argument_list|(
name|mode
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* REG+const has 10 bit offset for SP, but only SImode and 	 larger is supported.  */
comment|/* ??? Should probably check for DI/DFmode overflow here 	 just like GO_IF_LEGITIMATE_OFFSET does.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<=
literal|1024
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>=
literal|4
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_FLOAT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|4
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
operator|(
name|flag_pic
operator|&&
name|symbol_mentioned_p
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
operator|!
name|pcrel_constant_p
argument_list|(
name|get_pool_constant
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if VAL can be used as an offset in a Thumb-state address    instruction of mode MODE.  */
end_comment

begin_function
name|int
name|thumb_legitimate_offset_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|HOST_WIDE_INT
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|val
operator|>=
literal|0
operator|&&
name|val
operator|<
literal|32
return|;
case|case
literal|2
case|:
return|return
name|val
operator|>=
literal|0
operator|&&
name|val
operator|<
literal|64
operator|&&
operator|(
name|val
operator|&
literal|1
operator|)
operator|==
literal|0
return|;
default|default:
return|return
operator|(
name|val
operator|>=
literal|0
operator|&&
operator|(
name|val
operator|+
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|<=
literal|128
operator|&&
operator|(
name|val
operator|&
literal|3
operator|)
operator|==
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Build the SYMBOL_REF for __tls_get_addr.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|tls_get_addr_libfunc
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|rtx
name|get_tls_get_addr
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tls_get_addr_libfunc
condition|)
name|tls_get_addr_libfunc
operator|=
name|init_one_libfunc
argument_list|(
literal|"__tls_get_addr"
argument_list|)
expr_stmt|;
return|return
name|tls_get_addr_libfunc
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|arm_load_tp
parameter_list|(
name|rtx
name|target
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_HARD_TP
condition|)
block|{
comment|/* Can return in any reg.  */
name|emit_insn
argument_list|(
name|gen_load_tp_hard
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Always returned in r0.  Immediately copy the result into a pseudo, 	 otherwise other uses of r0 (e.g. setting up function arguments) may 	 clobber the value.  */
name|rtx
name|tmp
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_load_tp_soft
argument_list|()
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|load_tls_operand
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL_RTX
condition|)
name|reg
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_CONST
argument_list|(
name|SImode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|arm_call_tls_get_addr
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
modifier|*
name|valuep
parameter_list|,
name|int
name|reloc
parameter_list|)
block|{
name|rtx
name|insns
decl_stmt|,
name|label
decl_stmt|,
name|labelno
decl_stmt|,
name|sum
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|labelno
operator|=
name|GEN_INT
argument_list|(
name|pic_labelno
operator|++
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|labelno
argument_list|)
argument_list|,
name|UNSPEC_PIC_LABEL
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|sum
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|reloc
argument_list|)
argument_list|,
name|label
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_ARM
condition|?
literal|8
else|:
literal|4
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_TLS
argument_list|)
expr_stmt|;
name|reg
operator|=
name|load_tls_operand
argument_list|(
name|sum
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
condition|)
name|emit_insn
argument_list|(
name|gen_pic_add_dot_plus_eight
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|labelno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|gen_pic_add_dot_plus_four
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|labelno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|valuep
operator|=
name|emit_library_call_value
argument_list|(
name|get_tls_get_addr
argument_list|()
argument_list|,
name|NULL_RTX
argument_list|,
name|LCT_PURE
argument_list|,
comment|/* LCT_CONST?  */
name|Pmode
argument_list|,
literal|1
argument_list|,
name|reg
argument_list|,
name|Pmode
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|insns
return|;
block|}
end_function

begin_function
name|rtx
name|legitimize_tls_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|rtx
name|dest
decl_stmt|,
name|tp
decl_stmt|,
name|label
decl_stmt|,
name|labelno
decl_stmt|,
name|sum
decl_stmt|,
name|insns
decl_stmt|,
name|ret
decl_stmt|,
name|eqv
decl_stmt|,
name|addend
decl_stmt|;
name|unsigned
name|int
name|model
init|=
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|model
condition|)
block|{
case|case
name|TLS_MODEL_GLOBAL_DYNAMIC
case|:
name|insns
operator|=
name|arm_call_tls_get_addr
argument_list|(
name|x
argument_list|,
name|reg
argument_list|,
operator|&
name|ret
argument_list|,
name|TLS_GD32
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|dest
argument_list|,
name|ret
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|dest
return|;
case|case
name|TLS_MODEL_LOCAL_DYNAMIC
case|:
name|insns
operator|=
name|arm_call_tls_get_addr
argument_list|(
name|x
argument_list|,
name|reg
argument_list|,
operator|&
name|ret
argument_list|,
name|TLS_LDM32
argument_list|)
expr_stmt|;
comment|/* Attach a unique REG_EQUIV, to allow the RTL optimizers to 	 share the LDM result with other LD model accesses.  */
name|eqv
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|const1_rtx
argument_list|)
argument_list|,
name|UNSPEC_TLS
argument_list|)
expr_stmt|;
name|dest
operator|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
expr_stmt|;
name|emit_libcall_block
argument_list|(
name|insns
argument_list|,
name|dest
argument_list|,
name|ret
argument_list|,
name|eqv
argument_list|)
expr_stmt|;
comment|/* Load the addend.  */
name|addend
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|TLS_LDO32
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_TLS
argument_list|)
expr_stmt|;
name|addend
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|SImode
argument_list|,
name|addend
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|dest
argument_list|,
name|addend
argument_list|)
return|;
case|case
name|TLS_MODEL_INITIAL_EXEC
case|:
name|labelno
operator|=
name|GEN_INT
argument_list|(
name|pic_labelno
operator|++
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|labelno
argument_list|)
argument_list|,
name|UNSPEC_PIC_LABEL
argument_list|)
expr_stmt|;
name|label
operator|=
name|gen_rtx_CONST
argument_list|(
name|VOIDmode
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|sum
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|4
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|TLS_IE32
argument_list|)
argument_list|,
name|label
argument_list|,
name|GEN_INT
argument_list|(
name|TARGET_ARM
condition|?
literal|8
else|:
literal|4
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_TLS
argument_list|)
expr_stmt|;
name|reg
operator|=
name|load_tls_operand
argument_list|(
name|sum
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
condition|)
name|emit_insn
argument_list|(
name|gen_tls_load_dot_plus_eight
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|labelno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_insn
argument_list|(
name|gen_pic_add_dot_plus_four
argument_list|(
name|reg
argument_list|,
name|reg
argument_list|,
name|labelno
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|gen_const_mem
argument_list|(
name|SImode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tp
operator|=
name|arm_load_tp
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tp
argument_list|,
name|reg
argument_list|)
return|;
case|case
name|TLS_MODEL_LOCAL_EXEC
case|:
name|tp
operator|=
name|arm_load_tp
argument_list|(
name|NULL_RTX
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_UNSPEC
argument_list|(
name|Pmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|2
argument_list|,
name|x
argument_list|,
name|GEN_INT
argument_list|(
name|TLS_LE32
argument_list|)
argument_list|)
argument_list|,
name|UNSPEC_TLS
argument_list|)
expr_stmt|;
name|reg
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_CONST
argument_list|(
name|SImode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|tp
argument_list|,
name|reg
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate address    to be legitimate.  If we find one, return the new, valid address.  */
end_comment

begin_function
name|rtx
name|arm_legitimize_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|orig_x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|arm_tls_symbol_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|legitimize_tls_address
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|rtx
name|xop0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xop0
argument_list|)
operator|&&
operator|!
name|symbol_mentioned_p
argument_list|(
name|xop0
argument_list|)
condition|)
name|xop0
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xop1
argument_list|)
operator|&&
operator|!
name|symbol_mentioned_p
argument_list|(
name|xop1
argument_list|)
condition|)
name|xop1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARM_BASE_REGISTER_RTX_P
argument_list|(
name|xop0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|xop1
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|n
decl_stmt|,
name|low_n
decl_stmt|;
name|rtx
name|base_reg
decl_stmt|,
name|val
decl_stmt|;
name|n
operator|=
name|INTVAL
argument_list|(
name|xop1
argument_list|)
expr_stmt|;
comment|/* VFP addressing modes actually allow greater offsets, but for 	     now we just stick with the lowest common denominator.  */
if|if
condition|(
name|mode
operator|==
name|DImode
operator|||
operator|(
operator|(
name|TARGET_SOFT_FLOAT
operator|||
name|TARGET_VFP
operator|)
operator|&&
name|mode
operator|==
name|DFmode
operator|)
condition|)
block|{
name|low_n
operator|=
name|n
operator|&
literal|0x0f
expr_stmt|;
name|n
operator|&=
operator|~
literal|0x0f
expr_stmt|;
if|if
condition|(
name|low_n
operator|>
literal|4
condition|)
block|{
name|n
operator|+=
literal|16
expr_stmt|;
name|low_n
operator|-=
literal|16
expr_stmt|;
block|}
block|}
else|else
block|{
name|low_n
operator|=
operator|(
operator|(
name|mode
operator|)
operator|==
name|TImode
condition|?
literal|0
else|:
name|n
operator|>=
literal|0
condition|?
operator|(
name|n
operator|&
literal|0xfff
operator|)
else|:
operator|-
operator|(
operator|(
operator|-
name|n
operator|)
operator|&
literal|0xfff
operator|)
operator|)
expr_stmt|;
name|n
operator|-=
name|low_n
expr_stmt|;
block|}
name|base_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|val
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|xop0
argument_list|,
name|n
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|base_reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|x
operator|=
name|plus_constant
argument_list|(
name|base_reg
argument_list|,
name|low_n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xop0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|xop1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
block|}
comment|/* XXX We don't allow MINUS any more -- see comment in      arm_legitimate_address_p ().  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
condition|)
block|{
name|rtx
name|xop0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xop0
argument_list|)
condition|)
name|xop0
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|xop1
argument_list|)
operator|&&
operator|!
name|symbol_mentioned_p
argument_list|(
name|xop1
argument_list|)
condition|)
name|xop1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|xop0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|xop1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx_MINUS
argument_list|(
name|SImode
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure to take full advantage of the pre-indexed addressing mode      with absolute addresses which often allows for the base register to      be factorized for multiple adjacent memory references, and it might      even allows for the mini pool to be avoided entirely. */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|optimize
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|bits
decl_stmt|;
name|HOST_WIDE_INT
name|mask
decl_stmt|,
name|base
decl_stmt|,
name|index
decl_stmt|;
name|rtx
name|base_reg
decl_stmt|;
comment|/* ldr and ldrb can use a 12 bit index, ldrsb and the rest can only          use a 8 bit index. So let's use a 12 bit index for SImode only and          hope that arm_gen_constant will enable ldrb to use more bits. */
name|bits
operator|=
operator|(
name|mode
operator|==
name|SImode
operator|)
condition|?
literal|12
else|:
literal|8
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
name|base
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
operator|~
name|mask
expr_stmt|;
name|index
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|bit_count
argument_list|(
name|base
operator|&
literal|0xffffffff
argument_list|)
operator|>
operator|(
literal|32
operator|-
name|bits
operator|)
operator|/
literal|2
condition|)
block|{
comment|/* It'll most probably be more efficient to generate the base 	     with more bits set and use a negative index instead. */
name|base
operator||=
name|mask
expr_stmt|;
name|index
operator|-=
name|mask
expr_stmt|;
block|}
name|base_reg
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|GEN_INT
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|plus_constant
argument_list|(
name|base_reg
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
condition|)
block|{
comment|/* We need to find and carefully transform any SYMBOL and LABEL 	 references; so go back to the original address expression.  */
name|rtx
name|new_x
init|=
name|legitimize_pic_address
argument_list|(
name|orig_x
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_x
operator|!=
name|orig_x
condition|)
name|x
operator|=
name|new_x
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Try machine-dependent ways of modifying an illegitimate Thumb address    to be legitimate.  If we find one, return the new, valid address.  */
end_comment

begin_function
name|rtx
name|thumb_legitimize_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|orig_x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|arm_tls_symbol_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|legitimize_tls_address
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|32
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|||
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|rtx
name|xop0
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|xop1
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
name|INTVAL
argument_list|(
name|xop1
argument_list|)
decl_stmt|;
comment|/* Try and fold the offset into a biasing of the base register and 	 then offsetting that.  Don't do this when optimizing for space 	 since it can cause too many CSEs.  */
if|if
condition|(
name|optimize_size
operator|&&
name|offset
operator|>=
literal|0
operator|&&
name|offset
operator|<
literal|256
operator|+
literal|31
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|delta
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|256
condition|)
name|delta
operator|=
name|offset
operator|-
operator|(
literal|256
operator|-
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|<
literal|32
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|+
literal|8
condition|)
name|delta
operator|=
literal|31
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|delta
operator|=
name|offset
operator|&
operator|(
operator|~
literal|31
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|)
expr_stmt|;
name|xop0
operator|=
name|force_operand
argument_list|(
name|plus_constant
argument_list|(
name|xop0
argument_list|,
name|offset
operator|-
name|delta
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|x
operator|=
name|plus_constant
argument_list|(
name|xop0
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|<
literal|0
operator|&&
name|offset
operator|>
operator|-
literal|256
condition|)
comment|/* Small negative offsets are best done with a subtract before the 	   dereference, forcing these into a register normally takes two 	   instructions.  */
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* For the remaining cases, force the constant into a register.  */
name|xop1
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|xop0
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|s_register_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|SImode
argument_list|)
operator|&&
operator|!
name|s_register_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|SImode
argument_list|)
condition|)
block|{
name|rtx
name|xop0
init|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|x
operator|=
name|gen_rtx_PLUS
argument_list|(
name|SImode
argument_list|,
name|xop0
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
condition|)
block|{
comment|/* We need to find and carefully transform any SYMBOL and LABEL 	 references; so go back to the original address expression.  */
name|rtx
name|new_x
init|=
name|legitimize_pic_address
argument_list|(
name|orig_x
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_x
operator|!=
name|orig_x
condition|)
name|x
operator|=
name|new_x
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_function
name|rtx
name|thumb_legitimize_reload_address
parameter_list|(
name|rtx
modifier|*
name|x_p
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|opnum
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|ind_levels
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|x_p
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
literal|4
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|thumb_legitimate_offset_p
argument_list|(
name|mode
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|orig_x
init|=
name|x
decl_stmt|;
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|orig_x
argument_list|,
name|NULL_RTX
argument_list|,
name|x_p
argument_list|,
name|NULL
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
comment|/* If both registers are hi-regs, then it's better to reload the      entire expression rather than each register individually.  That      only requires one reload register rather than two.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|REG_MODE_OK_FOR_REG_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|&&
operator|!
name|REG_MODE_OK_FOR_REG_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|orig_x
init|=
name|x
decl_stmt|;
name|x
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|push_reload
argument_list|(
name|orig_x
argument_list|,
name|NULL_RTX
argument_list|,
name|x_p
argument_list|,
name|NULL
argument_list|,
name|MODE_BASE_REG_CLASS
argument_list|(
name|mode
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|opnum
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Test for various thread-local symbols.  */
end_comment

begin_comment
comment|/* Return TRUE if X is a thread-local symbol.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_tls_symbol_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_HAVE_TLS
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return
name|false
return|;
return|return
name|SYMBOL_REF_TLS_MODEL
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper for arm_tls_referenced_p.  */
end_comment

begin_function
specifier|static
name|int
name|arm_tls_operand_p_1
parameter_list|(
name|rtx
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
name|SYMBOL_REF_TLS_MODEL
argument_list|(
operator|*
name|x
argument_list|)
operator|!=
literal|0
return|;
comment|/* Don't recurse into UNSPEC_TLS looking for TLS symbols; these are      TLS offsets, not real symbol references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
operator|*
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLS
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if X contains any TLS symbol references.  */
end_comment

begin_function
name|bool
name|arm_tls_referenced_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_HAVE_TLS
condition|)
return|return
name|false
return|;
return|return
name|for_each_rtx
argument_list|(
operator|&
name|x
argument_list|,
name|arm_tls_operand_p_1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|REG_OR_SUBREG_REG
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == REG							\    || (GET_CODE (X) == SUBREG&& GET_CODE (SUBREG_REG (X)) == REG))
end_define

begin_define
define|#
directive|define
name|REG_OR_SUBREG_RTX
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == REG ? (X) : SUBREG_REG (X))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|COSTS_N_INSNS
end_ifndef

begin_define
define|#
directive|define
name|COSTS_N_INSNS
parameter_list|(
name|N
parameter_list|)
value|((N) * 4 - 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|int
name|thumb_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|rtx_code
name|outer
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ASHIFT
case|:
case|case
name|ASHIFTRT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ROTATERT
case|:
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|COMPARE
case|:
case|case
name|NEG
case|:
case|case
name|NOT
case|:
return|return
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
return|;
case|case
name|MULT
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|cycles
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
condition|)
block|{
name|i
operator|>>=
literal|2
expr_stmt|;
name|cycles
operator|++
expr_stmt|;
block|}
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
operator|+
name|cycles
return|;
block|}
return|return
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|16
return|;
case|case
name|SET
case|:
return|return
operator|(
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
literal|4
operator|*
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|+
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
operator|)
return|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|outer
operator|==
name|SET
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|thumb_shiftable_const
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
return|;
return|return
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|outer
operator|==
name|PLUS
operator|||
name|outer
operator|==
name|COMPARE
operator|)
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>
operator|-
literal|256
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|outer
operator|==
name|AND
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|256
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
operator|-
literal|256
condition|)
return|return
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
return|;
elseif|else
if|if
condition|(
name|outer
operator|==
name|ASHIFT
operator|||
name|outer
operator|==
name|ASHIFTRT
operator|||
name|outer
operator|==
name|LSHIFTRT
condition|)
return|return
literal|0
return|;
return|return
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
return|;
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
return|;
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
case|case
name|DIV
case|:
case|case
name|MOD
case|:
return|return
literal|100
return|;
case|case
name|TRUNCATE
case|:
return|return
literal|99
return|;
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|IOR
case|:
comment|/* XXX guess.  */
return|return
literal|8
return|;
case|case
name|MEM
case|:
comment|/* XXX another guess.  */
comment|/* Memory costs quite a lot for the first word, but subsequent words 	 load at the equivalent of a single insn each.  */
return|return
operator|(
literal|10
operator|+
literal|4
operator|*
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|IF_THEN_ELSE
case|:
comment|/* XXX a guess.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
return|return
literal|14
return|;
return|return
literal|2
return|;
case|case
name|ZERO_EXTEND
case|:
comment|/* XXX still guessing.  */
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|HImode
case|:
return|return
operator|(
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|SImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
default|default:
return|return
literal|99
return|;
block|}
default|default:
return|return
literal|99
return|;
block|}
block|}
end_function

begin_comment
comment|/* Worker routine for arm_rtx_costs.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|arm_rtx_costs_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|enum
name|rtx_code
name|outer
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|subcode
decl_stmt|;
name|int
name|extra_cost
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
comment|/* Memory costs quite a lot for the first word, but subsequent words 	 load at the equivalent of a single insn each.  */
return|return
operator|(
literal|10
operator|+
literal|4
operator|*
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
return|return
name|optimize_size
condition|?
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
else|:
literal|100
return|;
case|case
name|ROTATE
case|:
if|if
condition|(
name|mode
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|4
return|;
comment|/* Fall through */
case|case
name|ROTATERT
case|:
if|if
condition|(
name|mode
operator|!=
name|SImode
condition|)
return|return
literal|8
return|;
comment|/* Fall through */
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
operator|(
literal|8
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
return|return
operator|(
literal|1
operator|+
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|+
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
return|;
case|case
name|MINUS
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
operator|(
literal|4
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
operator|(
literal|2
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|arm_const_double_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|arm_const_double_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|subcode
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|==
name|ASHIFT
operator|||
name|subcode
operator|==
name|ASHIFTRT
operator|||
name|subcode
operator|==
name|LSHIFTRT
operator|||
name|subcode
operator|==
name|ROTATE
operator|||
name|subcode
operator|==
name|ROTATERT
operator|||
operator|(
name|subcode
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|&&
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Fall through */
case|case
name|PLUS
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
name|extra_cost
operator|=
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|extra_cost
operator|+=
literal|4
operator|*
name|ARM_NUM_REGS
argument_list|(
name|mode
argument_list|)
expr_stmt|;
return|return
name|extra_cost
return|;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
operator|(
literal|2
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|arm_const_double_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
comment|/* Fall through */
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|IOR
case|:
name|extra_cost
operator|=
literal|0
expr_stmt|;
comment|/* Normally the frame registers will be spilt into reg+const during 	 reload, so it is a bad idea to combine them with other instructions, 	 since then they might not be moved outside of loops.  As a compromise 	 we allow integration with ops that have a constant as their second 	 operand.  */
if|if
condition|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|ARM_FRAME_RTX
argument_list|(
name|REG_OR_SUBREG_RTX
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
operator|||
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|ARM_FRAME_RTX
argument_list|(
name|REG_OR_SUBREG_RTX
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|extra_cost
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
operator|(
literal|4
operator|+
name|extra_cost
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_op
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|code
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|8
operator|)
operator|)
return|;
if|if
condition|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|?
literal|0
else|:
name|extra_cost
operator|)
operator|+
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|const_ok_for_op
argument_list|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|code
argument_list|)
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
return|;
elseif|else
if|if
condition|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|+
name|extra_cost
operator|+
operator|(
operator|(
operator|(
operator|(
name|subcode
operator|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|==
name|ASHIFT
operator|||
name|subcode
operator|==
name|LSHIFTRT
operator|||
name|subcode
operator|==
name|ASHIFTRT
operator|||
name|subcode
operator|==
name|ROTATE
operator|||
name|subcode
operator|==
name|ROTATERT
operator|||
operator|(
name|subcode
operator|==
name|MULT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|)
return|;
return|return
literal|8
return|;
case|case
name|MULT
case|:
comment|/* This should have been handled by the CPU specific routines.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|TRUNCATE
case|:
if|if
condition|(
name|arm_arch3m
operator|&&
name|mode
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LSHIFTRT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
condition|)
return|return
literal|8
return|;
return|return
literal|99
return|;
case|case
name|NEG
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
return|return
literal|4
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|6
operator|)
return|;
comment|/* Fall through */
case|case
name|NOT
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
literal|4
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
return|;
return|return
literal|1
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
return|;
case|case
name|IF_THEN_ELSE
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
return|return
literal|14
return|;
return|return
literal|2
return|;
case|case
name|COMPARE
case|:
return|return
literal|1
return|;
case|case
name|ABS
case|:
return|return
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
return|;
case|case
name|SIGN_EXTEND
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|QImode
condition|)
return|return
operator|(
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
comment|/* Fall through */
case|case
name|ZERO_EXTEND
case|:
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|HImode
case|:
return|return
operator|(
literal|4
operator|+
operator|(
name|mode
operator|==
name|DImode
condition|?
literal|4
else|:
literal|0
operator|)
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|SImode
case|:
return|return
operator|(
literal|1
operator|+
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|?
literal|10
else|:
literal|0
operator|)
operator|)
return|;
case|case
name|V8QImode
case|:
case|case
name|V4HImode
case|:
case|case
name|V2SImode
case|:
case|case
name|V4QImode
case|:
case|case
name|V2HImode
case|:
return|return
literal|1
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
name|outer
operator|==
name|SET
condition|?
literal|2
else|:
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|outer
operator|==
name|AND
operator|&&
name|const_ok_for_arm
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|outer
operator|==
name|COMPARE
operator|||
name|outer
operator|==
name|PLUS
operator|||
name|outer
operator|==
name|MINUS
operator|)
operator|&&
name|const_ok_for_arm
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|5
return|;
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
return|return
literal|6
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|arm_const_double_rtx
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|outer
operator|==
name|SET
condition|?
literal|2
else|:
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|outer
operator|==
name|COMPARE
operator|||
name|outer
operator|==
name|PLUS
operator|)
operator|&&
name|neg_const_double_rtx_ok_for_fpa
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|7
return|;
default|default:
return|return
literal|99
return|;
block|}
block|}
end_function

begin_comment
comment|/* RTX costs when optimizing for size.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_size_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
comment|/* XXX TBD.  For now, use the standard costs.  */
operator|*
name|total
operator|=
name|thumb_rtx_costs
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
comment|/* A memory access costs 1 insn if the mode is small, or the address is 	 a single register, otherwise it costs one insn per word.  */
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ARM_NUM_REGS
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|UDIV
case|:
case|case
name|UMOD
case|:
comment|/* Needs a libcall, so it costs about this.  */
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|ROTATE
case|:
if|if
condition|(
name|mode
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
operator|+
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Fall through */
case|case
name|ROTATERT
case|:
case|case
name|ASHIFT
case|:
case|case
name|LSHIFTRT
case|:
case|case
name|ASHIFTRT
case|:
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
operator|+
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
operator|+
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* Slightly disparage register shifts, but not by much.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
operator|*
name|total
operator|+=
literal|1
operator|+
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Needs a libcall.  */
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|MINUS
case|:
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
block|{
name|enum
name|rtx_code
name|subcode0
init|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|subcode1
init|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|subcode0
operator|==
name|ROTATE
operator|||
name|subcode0
operator|==
name|ROTATERT
operator|||
name|subcode0
operator|==
name|ASHIFT
operator|||
name|subcode0
operator|==
name|LSHIFTRT
operator|||
name|subcode0
operator|==
name|ASHIFTRT
operator|||
name|subcode1
operator|==
name|ROTATE
operator|||
name|subcode1
operator|==
name|ROTATERT
operator|||
name|subcode1
operator|==
name|ASHIFT
operator|||
name|subcode1
operator|==
name|LSHIFTRT
operator|||
name|subcode1
operator|==
name|ASHIFTRT
condition|)
block|{
comment|/* It's just the cost of the two operands.  */
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ARM_NUM_REGS
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|PLUS
case|:
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Fall through */
case|case
name|AND
case|:
case|case
name|XOR
case|:
case|case
name|IOR
case|:
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
block|{
name|enum
name|rtx_code
name|subcode
init|=
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|subcode
operator|==
name|ROTATE
operator|||
name|subcode
operator|==
name|ROTATERT
operator|||
name|subcode
operator|==
name|ASHIFT
operator|||
name|subcode
operator|==
name|LSHIFTRT
operator|||
name|subcode
operator|==
name|ASHIFTRT
operator|||
operator|(
name|code
operator|==
name|AND
operator|&&
name|subcode
operator|==
name|NOT
operator|)
condition|)
block|{
comment|/* It's just the cost of the two operands.  */
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ARM_NUM_REGS
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|MULT
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ARM_NUM_REGS
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|NEG
case|:
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Fall through */
case|case
name|NOT
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ARM_NUM_REGS
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|IF_THEN_ELSE
case|:
operator|*
name|total
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
case|case
name|COMPARE
case|:
if|if
condition|(
name|cc_register
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|ABS
case|:
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
operator|+
name|ARM_NUM_REGS
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|SIGN_EXTEND
case|:
operator|*
name|total
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|4
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|arm_arch4
operator|&&
name|MEM_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
operator|*
name|total
operator|+=
name|COSTS_N_INSNS
argument_list|(
name|arm_arch6
condition|?
literal|1
else|:
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
operator|*
name|total
operator|+=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|ZERO_EXTEND
case|:
operator|*
name|total
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|arm_arch4
operator|&&
name|MEM_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|QImode
case|:
operator|*
name|total
operator|+=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|HImode
case|:
operator|*
name|total
operator|+=
name|COSTS_N_INSNS
argument_list|(
name|arm_arch6
condition|?
literal|1
else|:
literal|2
argument_list|)
expr_stmt|;
case|case
name|SImode
case|:
break|break;
default|default:
operator|*
name|total
operator|+=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
operator|*
name|total
operator|+=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|false
return|;
case|case
name|CONST_INT
case|:
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|outer_code
operator|==
name|SET
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|const_ok_for_arm
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|outer_code
operator|==
name|AND
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|const_ok_for_arm
argument_list|(
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|outer_code
operator|==
name|COMPARE
operator|||
name|outer_code
operator|==
name|PLUS
operator|||
name|outer_code
operator|==
name|MINUS
condition|)
operator|*
name|total
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|CONST
case|:
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|CONST_DOUBLE
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
name|ARM_NUM_REGS
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* How knows?  */
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* RTX costs for cores with a slow MUL implementation.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_slowmul_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
operator|*
name|total
operator|=
name|thumb_rtx_costs
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT
case|:
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|mode
operator|==
name|DImode
condition|)
block|{
operator|*
name|total
operator|=
literal|30
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
decl_stmt|;
name|int
name|cost
decl_stmt|,
name|const_ok
init|=
name|const_ok_for_arm
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|booth_unit_size
decl_stmt|;
comment|/* Tune as appropriate.  */
name|cost
operator|=
name|const_ok
condition|?
literal|4
else|:
literal|8
expr_stmt|;
name|booth_unit_size
operator|=
literal|2
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|&&
name|j
operator|<
literal|32
condition|;
name|j
operator|+=
name|booth_unit_size
control|)
block|{
name|i
operator|>>=
name|booth_unit_size
expr_stmt|;
name|cost
operator|+=
literal|2
expr_stmt|;
block|}
operator|*
name|total
operator|=
name|cost
expr_stmt|;
return|return
name|true
return|;
block|}
operator|*
name|total
operator|=
literal|30
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
expr_stmt|;
return|return
name|true
return|;
default|default:
operator|*
name|total
operator|=
name|arm_rtx_costs_1
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* RTX cost for cores with a fast multiply unit (M variants).  */
end_comment

begin_function
specifier|static
name|bool
name|arm_fastmul_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
operator|*
name|total
operator|=
name|thumb_rtx_costs
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT
case|:
comment|/* There is no point basing this on the tuning, since it is always the 	 fast variant if it exists at all.  */
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
condition|)
block|{
operator|*
name|total
operator|=
literal|8
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|mode
operator|==
name|DImode
condition|)
block|{
operator|*
name|total
operator|=
literal|30
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
decl_stmt|;
name|int
name|cost
decl_stmt|,
name|const_ok
init|=
name|const_ok_for_arm
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|booth_unit_size
decl_stmt|;
comment|/* Tune as appropriate.  */
name|cost
operator|=
name|const_ok
condition|?
literal|4
else|:
literal|8
expr_stmt|;
name|booth_unit_size
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|&&
name|j
operator|<
literal|32
condition|;
name|j
operator|+=
name|booth_unit_size
control|)
block|{
name|i
operator|>>=
name|booth_unit_size
expr_stmt|;
name|cost
operator|+=
literal|2
expr_stmt|;
block|}
operator|*
name|total
operator|=
name|cost
expr_stmt|;
return|return
name|true
return|;
block|}
operator|*
name|total
operator|=
literal|8
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
expr_stmt|;
return|return
name|true
return|;
default|default:
operator|*
name|total
operator|=
name|arm_rtx_costs_1
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* RTX cost for XScale CPUs.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_xscale_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
operator|*
name|total
operator|=
name|thumb_rtx_costs
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT
case|:
comment|/* There is no point basing this on the tuning, since it is always the 	 fast variant if it exists at all.  */
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
condition|)
block|{
operator|*
name|total
operator|=
literal|8
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|||
name|mode
operator|==
name|DImode
condition|)
block|{
operator|*
name|total
operator|=
literal|30
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|i
init|=
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
decl_stmt|;
name|int
name|cost
decl_stmt|,
name|const_ok
init|=
name|const_ok_for_arm
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|masked_const
decl_stmt|;
comment|/* The cost will be related to two insns. 	     First a load of the constant (MOV or LDR), then a multiply.  */
name|cost
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|const_ok
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
comment|/* LDR is probably more expensive because 			       of longer result latency.  */
name|masked_const
operator|=
name|i
operator|&
literal|0xffff8000
expr_stmt|;
if|if
condition|(
name|masked_const
operator|!=
literal|0
operator|&&
name|masked_const
operator|!=
literal|0xffff8000
condition|)
block|{
name|masked_const
operator|=
name|i
operator|&
literal|0xf8000000
expr_stmt|;
if|if
condition|(
name|masked_const
operator|==
literal|0
operator|||
name|masked_const
operator|==
literal|0xf8000000
condition|)
name|cost
operator|+=
literal|1
expr_stmt|;
else|else
name|cost
operator|+=
literal|2
expr_stmt|;
block|}
operator|*
name|total
operator|=
name|cost
expr_stmt|;
return|return
name|true
return|;
block|}
operator|*
name|total
operator|=
literal|8
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
literal|0
else|:
literal|4
operator|)
expr_stmt|;
return|return
name|true
return|;
case|case
name|COMPARE
case|:
comment|/* A COMPARE of a MULT is slow on XScale; the muls instruction 	 will stall until the multiplication is complete.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
operator|*
name|total
operator|=
literal|4
operator|+
name|rtx_cost
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
else|else
operator|*
name|total
operator|=
name|arm_rtx_costs_1
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
operator|*
name|total
operator|=
name|arm_rtx_costs_1
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* RTX costs for 9e (and later) cores.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_9e_rtx_costs
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|outer_code
parameter_list|,
name|int
modifier|*
name|total
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|nonreg_cost
decl_stmt|;
name|int
name|cost
decl_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT
case|:
operator|*
name|total
operator|=
name|COSTS_N_INSNS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
name|true
return|;
default|default:
operator|*
name|total
operator|=
name|thumb_rtx_costs
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MULT
case|:
comment|/* There is no point basing this on the tuning, since it is always the 	 fast variant if it exists at all.  */
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ZERO_EXTEND
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SIGN_EXTEND
operator|)
condition|)
block|{
operator|*
name|total
operator|=
literal|3
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
operator|*
name|total
operator|=
literal|30
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
block|{
name|cost
operator|=
literal|7
expr_stmt|;
name|nonreg_cost
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|cost
operator|=
literal|2
expr_stmt|;
name|nonreg_cost
operator|=
literal|4
expr_stmt|;
block|}
operator|*
name|total
operator|=
name|cost
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|?
literal|0
else|:
name|nonreg_cost
operator|)
operator|+
operator|(
name|REG_OR_SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
literal|0
else|:
name|nonreg_cost
operator|)
expr_stmt|;
return|return
name|true
return|;
default|default:
operator|*
name|total
operator|=
name|arm_rtx_costs_1
argument_list|(
name|x
argument_list|,
name|code
argument_list|,
name|outer_code
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
end_function

begin_comment
comment|/* All address computations that can be done are free, but rtx cost returns    the same for practically all of them.  So we weight the different types    of address here in the order (most pref first):    PRE/POST_INC/DEC, SHIFT or NON-INT sum, INT sum, REG, MEM or LABEL.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|arm_arm_address_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|c
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|PRE_INC
operator|||
name|c
operator|==
name|PRE_DEC
operator|||
name|c
operator|==
name|POST_INC
operator|||
name|c
operator|==
name|POST_DEC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|==
name|MEM
operator|||
name|c
operator|==
name|LABEL_REF
operator|||
name|c
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|10
return|;
if|if
condition|(
name|c
operator|==
name|PLUS
operator|||
name|c
operator|==
name|MINUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|ARITHMETIC_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|ARITHMETIC_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
literal|3
return|;
return|return
literal|4
return|;
block|}
return|return
literal|6
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|arm_thumb_address_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|c
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|REG
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
return|return
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_address_cost
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|TARGET_ARM
condition|?
name|arm_arm_address_cost
argument_list|(
name|x
argument_list|)
else|:
name|arm_thumb_address_cost
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_adjust_cost
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|link
parameter_list|,
name|rtx
name|dep
parameter_list|,
name|int
name|cost
parameter_list|)
block|{
name|rtx
name|i_pat
decl_stmt|,
name|d_pat
decl_stmt|;
comment|/* Some true dependencies can have a higher cost depending      on precisely how certain input operands are used.  */
if|if
condition|(
name|arm_tune_xscale
operator|&&
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
operator|&&
name|recog_memoized
argument_list|(
name|insn
argument_list|)
operator|>=
literal|0
operator|&&
name|recog_memoized
argument_list|(
name|dep
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|int
name|shift_opnum
init|=
name|get_attr_shift
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|enum
name|attr_type
name|attr_type
init|=
name|get_attr_type
argument_list|(
name|dep
argument_list|)
decl_stmt|;
comment|/* If nonzero, SHIFT_OPNUM contains the operand number of a shifted 	 operand for INSN.  If we have a shifted input operand and the 	 instruction we depend on is another ALU instruction, then we may 	 have to account for an additional stall.  */
if|if
condition|(
name|shift_opnum
operator|!=
literal|0
operator|&&
operator|(
name|attr_type
operator|==
name|TYPE_ALU_SHIFT
operator|||
name|attr_type
operator|==
name|TYPE_ALU_SHIFT_REG
operator|)
condition|)
block|{
name|rtx
name|shifted_operand
decl_stmt|;
name|int
name|opno
decl_stmt|;
comment|/* Get the shifted operand.  */
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|shifted_operand
operator|=
name|recog_data
operator|.
name|operand
index|[
name|shift_opnum
index|]
expr_stmt|;
comment|/* Iterate over all the operands in DEP.  If we write an operand 	     that overlaps with SHIFTED_OPERAND, then we have increase the 	     cost of this dependency.  */
name|extract_insn
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|preprocess_constraints
argument_list|()
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
block|{
comment|/* We can ignore strict inputs.  */
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|opno
index|]
operator|==
name|OP_IN
condition|)
continue|continue;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
argument_list|,
name|shifted_operand
argument_list|)
condition|)
return|return
literal|2
return|;
block|}
block|}
block|}
comment|/* XXX This is not strictly true for the FPA.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_ANTI
operator|||
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_DEP_OUTPUT
condition|)
return|return
literal|0
return|;
comment|/* Call insns don't incur a stall, even if they follow a load.  */
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|i_pat
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|i_pat
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|d_pat
operator|=
name|single_set
argument_list|(
name|dep
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|d_pat
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|src_mem
init|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|i_pat
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* This is a load after a store, there is no conflict if the load reads 	 from a cached area.  Assume that loads from the stack, and from the 	 constant pool are cached, and that others will miss.  This is a 	 hack.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|src_mem
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|src_mem
argument_list|)
operator|)
operator|||
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|src_mem
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|src_mem
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|src_mem
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
name|cost
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|fp_consts_inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Only zero is valid for VFP.  Other values are also valid for FPA.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|strings_fp
index|[
literal|8
index|]
init|=
block|{
literal|"0"
block|,
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"0.5"
block|,
literal|"10"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|REAL_VALUE_TYPE
name|values_fp
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_fp_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
if|if
condition|(
name|TARGET_VFP
condition|)
name|fp_consts_inited
operator|=
literal|1
expr_stmt|;
else|else
name|fp_consts_inited
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fp_consts_inited
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|strings_fp
index|[
name|i
index|]
argument_list|,
name|DFmode
argument_list|)
expr_stmt|;
name|values_fp
index|[
name|i
index|]
operator|=
name|r
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return TRUE if rtx X is a valid immediate FP constant.  */
end_comment

begin_function
name|int
name|arm_const_double_rtx
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fp_consts_inited
condition|)
name|init_fp_table
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fp_consts_inited
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|values_fp
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if rtx X is a valid immediate FPA constant.  */
end_comment

begin_function
name|int
name|neg_const_double_rtx_ok_for_fpa
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fp_consts_inited
condition|)
name|init_fp_table
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|r
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUE_MINUS_ZERO
argument_list|(
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|values_fp
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Predicates for `match_operand' and `match_operator'.  */
end_comment

begin_comment
comment|/* Return nonzero if OP is a valid Cirrus memory address pattern.  */
end_comment

begin_function
name|int
name|cirrus_memory_offset
parameter_list|(
name|rtx
name|op
parameter_list|)
block|{
comment|/* Reject eliminable registers.  */
if|if
condition|(
operator|!
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|op
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|ind
decl_stmt|;
name|ind
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Match: (mem (reg)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|REG
condition|)
return|return
literal|1
return|;
comment|/* Match: 	 (mem (plus (reg) 	            (const))).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if OP is a valid coprocessor memory address pattern.    WB if true if writeback address modes are allowed.  */
end_comment

begin_function
name|int
name|arm_coproc_mem_operand
parameter_list|(
name|rtx
name|op
parameter_list|,
name|bool
name|wb
parameter_list|)
block|{
name|rtx
name|ind
decl_stmt|;
comment|/* Reject eliminable registers.  */
if|if
condition|(
operator|!
operator|(
name|reload_in_progress
operator|||
name|reload_completed
operator|)
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|frame_pointer_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_incoming_args_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_outgoing_args_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_stack_dynamic_rtx
argument_list|,
name|op
argument_list|)
operator|||
name|reg_mentioned_p
argument_list|(
name|virtual_stack_vars_rtx
argument_list|,
name|op
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* Constants are converted into offsets from labels.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|FALSE
return|;
name|ind
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reload_completed
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|LABEL_REF
operator|||
operator|(
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|CONST
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* Match: (mem (reg)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|REG
condition|)
return|return
name|arm_address_register_rtx_p
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
return|;
comment|/* Autoincremment addressing modes.  */
if|if
condition|(
name|wb
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|POST_DEC
operator|)
condition|)
return|return
name|arm_address_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|wb
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|POST_MODIFY
operator|||
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|PRE_MODIFY
operator|)
operator|&&
name|arm_address_register_rtx_p
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|ind
operator|=
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Match:      (plus (reg) 	   (const)).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|ind
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REG_MODE_OK_FOR_BASE_P
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>
operator|-
literal|1024
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|1024
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|ind
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if X is a register that will be eliminated later on.  */
end_comment

begin_function
name|int
name|arm_eliminable_register
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|REG_P
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
operator|||
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_VIRTUAL_REGISTER
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<=
name|LAST_VIRTUAL_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return GENERAL_REGS if a scratch register required to reload x to/from    coprocessor registers.  Otherwise return NO_REGS.  */
end_comment

begin_function
name|enum
name|reg_class
name|coproc_secondary_reload_class
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|x
parameter_list|,
name|bool
name|wb
parameter_list|)
block|{
if|if
condition|(
name|arm_coproc_mem_operand
argument_list|(
name|x
argument_list|,
name|wb
argument_list|)
operator|||
name|s_register_operand
argument_list|(
name|x
argument_list|,
name|mode
argument_list|)
condition|)
return|return
name|NO_REGS
return|;
return|return
name|GENERAL_REGS
return|;
block|}
end_function

begin_comment
comment|/* Values which must be returned in the most-significant end of the return    register.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_return_in_msb
parameter_list|(
name|tree
name|valtype
parameter_list|)
block|{
return|return
operator|(
name|TARGET_AAPCS_BASED
operator|&&
name|BYTES_BIG_ENDIAN
operator|&&
operator|(
name|AGGREGATE_TYPE_P
argument_list|(
name|valtype
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns TRUE if INSN is an "LDR REG, ADDR" instruction.    Use by the Cirrus Maverick code which has to workaround    a hardware bug triggered by such instructions.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_memory_load_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|body
decl_stmt|,
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
condition|)
return|return
name|false
return|;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|SET
condition|)
return|return
name|false
return|;
name|lhs
operator|=
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|XEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|REG_OR_SUBREG_RTX
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
comment|/* If the destination is not a general purpose      register we do not have to worry.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|lhs
argument_list|)
argument_list|)
operator|!=
name|GENERAL_REGS
condition|)
return|return
name|false
return|;
comment|/* As well as loads from memory we also have to react      to loads of invalid constants which will be turned      into loads from the minipool.  */
return|return
operator|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|note_invalid_constants
argument_list|(
name|insn
argument_list|,
operator|-
literal|1
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if INSN is a Cirrus instruction.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_cirrus_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|attr_cirrus
name|attr
decl_stmt|;
comment|/* get_attr cannot accept USE or CLOBBER.  */
if|if
condition|(
operator|!
name|insn
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
literal|0
return|;
name|attr
operator|=
name|get_attr_cirrus
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|attr
operator|!=
name|CIRRUS_NOT
return|;
block|}
end_function

begin_comment
comment|/* Cirrus reorg for invalid instruction combinations.  */
end_comment

begin_function
specifier|static
name|void
name|cirrus_reorg
parameter_list|(
name|rtx
name|first
parameter_list|)
block|{
name|enum
name|attr_cirrus
name|attr
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|first
argument_list|)
decl_stmt|;
name|rtx
name|t
decl_stmt|;
name|int
name|nops
decl_stmt|;
comment|/* Any branch must be followed by 2 non Cirrus instructions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|first
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|RETURN
condition|)
block|{
name|nops
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|next_nonnote_insn
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_cirrus_insn_p
argument_list|(
name|t
argument_list|)
condition|)
operator|++
name|nops
expr_stmt|;
if|if
condition|(
name|arm_cirrus_insn_p
argument_list|(
name|next_nonnote_insn
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|++
name|nops
expr_stmt|;
while|while
condition|(
name|nops
operator|--
condition|)
name|emit_insn_after
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* (float (blah)) is in parallel with a clobber.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|body
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|lhs
init|=
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|rhs
init|=
name|XEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* cfldrd, cfldr64, cfstrd, cfstr64 must 	 be followed by a non Cirrus insn.  */
if|if
condition|(
name|get_attr_cirrus
argument_list|(
name|first
argument_list|)
operator|==
name|CIRRUS_DOUBLE
condition|)
block|{
if|if
condition|(
name|arm_cirrus_insn_p
argument_list|(
name|next_nonnote_insn
argument_list|(
name|first
argument_list|)
argument_list|)
condition|)
name|emit_insn_after
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|arm_memory_load_p
argument_list|(
name|first
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|arm_regno
decl_stmt|;
comment|/* Any ldr/cfmvdlr, ldr/cfmvdhr, ldr/cfmvsr, ldr/cfmv64lr, 	     ldr/cfmv64hr combination where the Rd field is the same 	     in both instructions must be split with a non Cirrus 	     insn.  Example:  	     ldr r0, blah 	     nop 	     cfmvsr mvf0, r0.  */
comment|/* Get Arm register number for ldr insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|REG
condition|)
name|arm_regno
operator|=
name|REGNO
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|arm_regno
operator|=
name|REGNO
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
comment|/* Next insn.  */
name|first
operator|=
name|next_nonnote_insn
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arm_cirrus_insn_p
argument_list|(
name|first
argument_list|)
condition|)
return|return;
name|body
operator|=
name|PATTERN
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* (float (blah)) is in parallel with a clobber.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
condition|)
name|body
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|FLOAT
condition|)
name|body
operator|=
name|XEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_attr_cirrus
argument_list|(
name|first
argument_list|)
operator|==
name|CIRRUS_MOVE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|arm_regno
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|body
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|emit_insn_after
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* get_attr cannot accept USE or CLOBBER.  */
if|if
condition|(
operator|!
name|first
operator|||
name|GET_CODE
argument_list|(
name|first
argument_list|)
operator|!=
name|INSN
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return;
name|attr
operator|=
name|get_attr_cirrus
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* Any coprocessor compare instruction (cfcmps, cfcmpd, ...)      must be followed by a non-coprocessor instruction.  */
if|if
condition|(
name|attr
operator|==
name|CIRRUS_COMPARE
condition|)
block|{
name|nops
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|next_nonnote_insn
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_cirrus_insn_p
argument_list|(
name|t
argument_list|)
condition|)
operator|++
name|nops
expr_stmt|;
if|if
condition|(
name|arm_cirrus_insn_p
argument_list|(
name|next_nonnote_insn
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
operator|++
name|nops
expr_stmt|;
while|while
condition|(
name|nops
operator|--
condition|)
name|emit_insn_after
argument_list|(
name|gen_nop
argument_list|()
argument_list|,
name|first
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Return TRUE if X references a SYMBOL_REF.  */
end_comment

begin_function
name|int
name|symbol_mentioned_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
return|return
literal|1
return|;
comment|/* UNSPEC_TLS entries for a symbol include the SYMBOL_REF, but they      are constant offsets, not symbols.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLS
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|symbol_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|symbol_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if X references a LABEL_REF.  */
end_comment

begin_function
name|int
name|label_mentioned_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
literal|1
return|;
comment|/* UNSPEC_TLS entries for a symbol include a LABEL_REF for the referencing      instruction, but they are constant offsets, not symbols.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLS
condition|)
return|return
literal|0
return|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|label_mentioned_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|label_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|tls_mentioned_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST
case|:
return|return
name|tls_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|UNSPEC
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLS
condition|)
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Must not copy a SET whose source operand is PC-relative.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_cannot_copy_insn_p
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|rhs
init|=
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_PIC_BASE
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_PIC_BASE
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|enum
name|rtx_code
name|minmax_code
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|SMAX
case|:
return|return
name|GE
return|;
case|case
name|SMIN
case|:
return|return
name|LE
return|;
case|case
name|UMIN
case|:
return|return
name|LEU
return|;
case|case
name|UMAX
case|:
return|return
name|GEU
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if memory locations are adjacent.  */
end_comment

begin_function
name|int
name|adjacent_mem_locations
parameter_list|(
name|rtx
name|a
parameter_list|,
name|rtx
name|b
parameter_list|)
block|{
comment|/* We don't guarantee to preserve the order of these memory refs.  */
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|a
argument_list|)
operator|||
name|volatile_refs_p
argument_list|(
name|b
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
name|HOST_WIDE_INT
name|val0
init|=
literal|0
decl_stmt|,
name|val1
init|=
literal|0
decl_stmt|;
name|rtx
name|reg0
decl_stmt|,
name|reg1
decl_stmt|;
name|int
name|val_diff
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|reg0
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val0
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|reg0
operator|=
name|XEXP
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|reg1
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val1
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|reg1
operator|=
name|XEXP
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't accept any offset that will require multiple 	 instructions to handle, since this would cause the 	 arith_adjacentmem pattern to output an overlong sequence.  */
if|if
condition|(
operator|!
name|const_ok_for_op
argument_list|(
name|PLUS
argument_list|,
name|val0
argument_list|)
operator|||
operator|!
name|const_ok_for_op
argument_list|(
name|PLUS
argument_list|,
name|val1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Don't allow an eliminable register: register elimination can make 	 the offset too large.  */
if|if
condition|(
name|arm_eliminable_register
argument_list|(
name|reg0
argument_list|)
condition|)
return|return
literal|0
return|;
name|val_diff
operator|=
name|val1
operator|-
name|val0
expr_stmt|;
if|if
condition|(
name|arm_ld_sched
condition|)
block|{
comment|/* If the target has load delay slots, then there's no benefit 	     to using an ldm instruction unless the offset is zero and 	     we are optimizing for size.  */
return|return
operator|(
name|optimize_size
operator|&&
operator|(
name|REGNO
argument_list|(
name|reg0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|)
operator|&&
operator|(
name|val0
operator|==
literal|0
operator|||
name|val1
operator|==
literal|0
operator|||
name|val0
operator|==
literal|4
operator|||
name|val1
operator|==
literal|4
operator|)
operator|&&
operator|(
name|val_diff
operator|==
literal|4
operator|||
name|val_diff
operator|==
operator|-
literal|4
operator|)
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|REGNO
argument_list|(
name|reg0
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg1
argument_list|)
operator|)
operator|&&
operator|(
name|val_diff
operator|==
literal|4
operator|||
name|val_diff
operator|==
operator|-
literal|4
operator|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|load_multiple_sequence
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|nops
parameter_list|,
name|int
modifier|*
name|regs
parameter_list|,
name|int
modifier|*
name|base
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|load_offset
parameter_list|)
block|{
name|int
name|unsorted_regs
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|unsorted_offsets
index|[
literal|4
index|]
decl_stmt|;
name|int
name|order
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Can only handle 2, 3, or 4 insns at present,      though could be easily extended if required.  */
name|gcc_assert
argument_list|(
name|nops
operator|>=
literal|2
operator|&&
name|nops
operator|<=
literal|4
argument_list|)
expr_stmt|;
comment|/* Loop over the operands and check that the memory references are      suitable (i.e. immediate offsets from the same base register).  At      the same time, extract the target register, and the memory      offsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
comment|/* Convert a subreg of a mem into the mem itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|operands
index|[
name|nops
operator|+
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|operands
operator|+
operator|(
name|nops
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
comment|/* Don't reorder volatile memory references; it doesn't seem worth 	 looking for the case where the order is ok anyway.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|base_reg
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|unsorted_regs
index|[
literal|0
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|order
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|base_reg
operator|!=
operator|(
name|int
operator|)
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
comment|/* Not addressed from the same base register.  */
return|return
literal|0
return|;
name|unsorted_regs
index|[
name|i
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
literal|0
index|]
index|]
condition|)
name|order
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* If it isn't an integer register, or if it overwrites the 	     base register but isn't the last insn in the list, then 	     we can't do this.  */
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|unsorted_regs
index|[
name|i
index|]
operator|>
literal|14
operator|||
operator|(
name|i
operator|!=
name|nops
operator|-
literal|1
operator|&&
name|unsorted_regs
index|[
name|i
index|]
operator|==
name|base_reg
operator|)
condition|)
return|return
literal|0
return|;
name|unsorted_offsets
index|[
name|i
index|]
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not a suitable memory address.  */
return|return
literal|0
return|;
block|}
comment|/* All the useful information has now been extracted from the      operands into unsorted_regs and unsorted_offsets; additionally,      order[0] has been set to the lowest numbered register in the      list.  Sort the registers into order, and check that the memory      offsets are ascending and adjacent.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|order
index|[
name|i
index|]
operator|=
name|order
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nops
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|unsorted_regs
index|[
name|j
index|]
operator|>
name|unsorted_regs
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|&&
operator|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
operator|||
name|unsorted_regs
index|[
name|j
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
operator|)
condition|)
name|order
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
comment|/* Have we found a suitable register? if not, one must be used more 	 than once.  */
if|if
condition|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return
literal|0
return|;
comment|/* Is the memory address adjacent and ascending? */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|i
index|]
index|]
operator|!=
name|unsorted_offsets
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|+
literal|4
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|base
condition|)
block|{
operator|*
name|base
operator|=
name|base_reg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|regs
index|[
name|i
index|]
operator|=
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
expr_stmt|;
operator|*
name|load_offset
operator|=
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
expr_stmt|;
block|}
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* ldmia */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|4
condition|)
return|return
literal|2
return|;
comment|/* ldmib */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|3
return|;
comment|/* ldmda */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
operator|-
literal|4
condition|)
return|return
literal|4
return|;
comment|/* ldmdb */
comment|/* For ARM8,9& StrongARM, 2 ldr instructions are faster than an ldm      if the offset isn't small enough.  The reason 2 ldrs are faster      is because these ARMs are able to do more than one cache access      in a single cycle.  The ARM9 and StrongARM have Harvard caches,      whilst the ARM8 has a double bandwidth cache.  This means that      these cores can do both an instruction fetch and a data fetch in      a single cycle, so the trick of calculating the address into a      scratch register (one of the result regs) and then doing a load      multiple actually becomes slower (and no smaller in code size).      That is the transformation   	ldr	rd1, [rbase + offset]  	ldr	rd2, [rbase + offset + 4]       to   	add	rd1, rbase, offset  	ldmia	rd1, {rd1, rd2}       produces worse code -- '3 cycles + any stalls on rd2' instead of      '2 cycles + any stalls on rd2'.  On ARMs with only one cache      access per cycle, the first sequence could never complete in less      than 6 cycles, whereas the ldm sequence would only take 5 and      would make better use of sequential accesses if not hitting the      cache.       We cheat here and test 'arm_ld_sched' which we currently know to      only be true for the ARM8, ARM9 and StrongARM.  If this ever      changes, then the test below needs to be reworked.  */
if|if
condition|(
name|nops
operator|==
literal|2
operator|&&
name|arm_ld_sched
condition|)
return|return
literal|0
return|;
comment|/* Can't do it without setting up the offset, only do this if it takes      no more than one insn.  */
return|return
operator|(
name|const_ok_for_arm
argument_list|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|-
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
argument_list|)
operator|)
condition|?
literal|5
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|emit_ldm_seq
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|nops
parameter_list|)
block|{
name|int
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|load_multiple_sequence
argument_list|(
name|operands
argument_list|,
name|nops
argument_list|,
name|regs
argument_list|,
operator|&
name|base_reg
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?ia\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?ib\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?da\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?db\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"add%%?\t%s%s, %s%s, #%ld"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"sub%%?\t%s%s, %s%s, #%ld"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
operator|(
name|long
operator|)
operator|-
name|offset
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|buf
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|base_reg
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"ldm%?ia\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s, {%s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|", %s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"}\t%@ phole ldm"
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|buf
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_function
name|int
name|store_multiple_sequence
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|nops
parameter_list|,
name|int
modifier|*
name|regs
parameter_list|,
name|int
modifier|*
name|base
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|load_offset
parameter_list|)
block|{
name|int
name|unsorted_regs
index|[
literal|4
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|unsorted_offsets
index|[
literal|4
index|]
decl_stmt|;
name|int
name|order
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Can only handle 2, 3, or 4 insns at present, though could be easily      extended if required.  */
name|gcc_assert
argument_list|(
name|nops
operator|>=
literal|2
operator|&&
name|nops
operator|<=
literal|4
argument_list|)
expr_stmt|;
comment|/* Loop over the operands and check that the memory references are      suitable (i.e. immediate offsets from the same base register).  At      the same time, extract the target register, and the memory      offsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|reg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
comment|/* Convert a subreg of a mem into the mem itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|==
name|SUBREG
condition|)
name|operands
index|[
name|nops
operator|+
name|i
index|]
operator|=
name|alter_subreg
argument_list|(
name|operands
operator|+
operator|(
name|nops
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
comment|/* Don't reorder volatile memory references; it doesn't seem worth 	 looking for the case where the order is ok anyway.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|const0_rtx
expr_stmt|;
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
operator|)
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|offset
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
name|nops
operator|+
name|i
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|base_reg
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|unsorted_regs
index|[
literal|0
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|order
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|base_reg
operator|!=
operator|(
name|int
operator|)
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
comment|/* Not addressed from the same base register.  */
return|return
literal|0
return|;
name|unsorted_regs
index|[
name|i
index|]
operator|=
operator|(
name|GET_CODE
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
else|:
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|operands
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
literal|0
index|]
index|]
condition|)
name|order
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* If it isn't an integer register, then we can't do this.  */
if|if
condition|(
name|unsorted_regs
index|[
name|i
index|]
operator|<
literal|0
operator|||
name|unsorted_regs
index|[
name|i
index|]
operator|>
literal|14
condition|)
return|return
literal|0
return|;
name|unsorted_offsets
index|[
name|i
index|]
operator|=
name|INTVAL
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Not a suitable memory address.  */
return|return
literal|0
return|;
block|}
comment|/* All the useful information has now been extracted from the      operands into unsorted_regs and unsorted_offsets; additionally,      order[0] has been set to the lowest numbered register in the      list.  Sort the registers into order, and check that the memory      offsets are ascending and adjacent.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|order
index|[
name|i
index|]
operator|=
name|order
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nops
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|unsorted_regs
index|[
name|j
index|]
operator|>
name|unsorted_regs
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|&&
operator|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
operator|||
name|unsorted_regs
index|[
name|j
index|]
operator|<
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
operator|)
condition|)
name|order
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
comment|/* Have we found a suitable register? if not, one must be used more 	 than once.  */
if|if
condition|(
name|order
index|[
name|i
index|]
operator|==
name|order
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return
literal|0
return|;
comment|/* Is the memory address adjacent and ascending? */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|i
index|]
index|]
operator|!=
name|unsorted_offsets
index|[
name|order
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|+
literal|4
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|base
condition|)
block|{
operator|*
name|base
operator|=
name|base_reg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|regs
index|[
name|i
index|]
operator|=
name|unsorted_regs
index|[
name|order
index|[
name|i
index|]
index|]
expr_stmt|;
operator|*
name|load_offset
operator|=
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
expr_stmt|;
block|}
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* stmia */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
literal|0
index|]
index|]
operator|==
literal|4
condition|)
return|return
literal|2
return|;
comment|/* stmib */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
literal|0
condition|)
return|return
literal|3
return|;
comment|/* stmda */
if|if
condition|(
name|unsorted_offsets
index|[
name|order
index|[
name|nops
operator|-
literal|1
index|]
index|]
operator|==
operator|-
literal|4
condition|)
return|return
literal|4
return|;
comment|/* stmdb */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|emit_stm_seq
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
name|int
name|nops
parameter_list|)
block|{
name|int
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|base_reg
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|store_multiple_sequence
argument_list|(
name|operands
argument_list|,
name|nops
argument_list|,
name|regs
argument_list|,
operator|&
name|base_reg
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?ia\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?ib\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?da\t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"stm%?db\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s%s, {%s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|base_reg
index|]
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nops
condition|;
name|i
operator|++
control|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|", %s%s"
argument_list|,
name|REGISTER_PREFIX
argument_list|,
name|reg_names
index|[
name|regs
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"}\t%@ phole stm"
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|buf
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines for use in generating RTL.  */
end_comment

begin_function
name|rtx
name|arm_gen_load_multiple
parameter_list|(
name|int
name|base_regno
parameter_list|,
name|int
name|count
parameter_list|,
name|rtx
name|from
parameter_list|,
name|int
name|up
parameter_list|,
name|int
name|write_back
parameter_list|,
name|rtx
name|basemem
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|offsetp
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
operator|*
name|offsetp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|int
name|sign
init|=
name|up
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|addr
decl_stmt|;
comment|/* XScale has load-store double instructions, but they have stricter      alignment requirements than load-store multiple, so we cannot      use them.       For XScale ldm requires 2 + NREGS cycles to complete and blocks      the pipeline until completion.  	NREGS		CYCLES 	  1		  3 	  2		  4 	  3		  5 	  4		  6       An ldr instruction takes 1-3 cycles, but does not block the      pipeline.  	NREGS		CYCLES 	  1		 1-3 	  2		 2-6 	  3		 3-9 	  4		 4-12       Best case ldr will always win.  However, the more ldr instructions      we issue, the less likely we are to be able to schedule them well.      Using ldr instructions also increases code size.       As a compromise, we use ldr for counts of 1 or 2 regs, and ldm      for counts of 3 or 4 regs.  */
if|if
condition|(
name|arm_tune_xscale
operator|&&
name|count
operator|<=
literal|2
operator|&&
operator|!
name|optimize_size
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|from
argument_list|,
name|i
operator|*
literal|4
operator|*
name|sign
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_automodify_address
argument_list|(
name|basemem
argument_list|,
name|SImode
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|i
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
operator|*
name|sign
expr_stmt|;
block|}
if|if
condition|(
name|write_back
condition|)
block|{
name|emit_move_insn
argument_list|(
name|from
argument_list|,
name|plus_constant
argument_list|(
name|from
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|offsetp
operator|=
name|offset
expr_stmt|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
name|result
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
operator|+
operator|(
name|write_back
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_back
condition|)
block|{
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|from
argument_list|,
name|plus_constant
argument_list|(
name|from
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|from
argument_list|,
name|j
operator|*
literal|4
operator|*
name|sign
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|basemem
argument_list|,
name|SImode
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|j
argument_list|)
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
operator|*
name|sign
expr_stmt|;
block|}
if|if
condition|(
name|write_back
condition|)
operator|*
name|offsetp
operator|=
name|offset
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|rtx
name|arm_gen_store_multiple
parameter_list|(
name|int
name|base_regno
parameter_list|,
name|int
name|count
parameter_list|,
name|rtx
name|to
parameter_list|,
name|int
name|up
parameter_list|,
name|int
name|write_back
parameter_list|,
name|rtx
name|basemem
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|offsetp
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
operator|*
name|offsetp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|result
decl_stmt|;
name|int
name|sign
init|=
name|up
condition|?
literal|1
else|:
operator|-
literal|1
decl_stmt|;
name|rtx
name|mem
decl_stmt|,
name|addr
decl_stmt|;
comment|/* See arm_gen_load_multiple for discussion of      the pros/cons of ldm/stm usage for XScale.  */
if|if
condition|(
name|arm_tune_xscale
operator|&&
name|count
operator|<=
literal|2
operator|&&
operator|!
name|optimize_size
condition|)
block|{
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|to
argument_list|,
name|i
operator|*
literal|4
operator|*
name|sign
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_automodify_address
argument_list|(
name|basemem
argument_list|,
name|SImode
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
operator|*
name|sign
expr_stmt|;
block|}
if|if
condition|(
name|write_back
condition|)
block|{
name|emit_move_insn
argument_list|(
name|to
argument_list|,
name|plus_constant
argument_list|(
name|to
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|offsetp
operator|=
name|offset
expr_stmt|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|seq
return|;
block|}
name|result
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
operator|+
operator|(
name|write_back
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_back
condition|)
block|{
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|to
argument_list|,
name|plus_constant
argument_list|(
name|to
argument_list|,
name|count
operator|*
literal|4
operator|*
name|sign
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|addr
operator|=
name|plus_constant
argument_list|(
name|to
argument_list|,
name|j
operator|*
literal|4
operator|*
name|sign
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_automodify_address_nv
argument_list|(
name|basemem
argument_list|,
name|SImode
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|base_regno
operator|+
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
operator|*
name|sign
expr_stmt|;
block|}
if|if
condition|(
name|write_back
condition|)
operator|*
name|offsetp
operator|=
name|offset
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|arm_gen_movmemqi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|HOST_WIDE_INT
name|in_words_to_go
decl_stmt|,
name|out_words_to_go
decl_stmt|,
name|last_bytes
decl_stmt|;
name|HOST_WIDE_INT
name|srcoffset
decl_stmt|,
name|dstoffset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|srcbase
decl_stmt|,
name|dstbase
decl_stmt|;
name|rtx
name|part_bytes_reg
init|=
name|NULL
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|>
literal|64
operator|||
name|INTVAL
argument_list|(
name|operands
index|[
literal|3
index|]
argument_list|)
operator|&
literal|3
condition|)
return|return
literal|0
return|;
name|dstbase
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|srcbase
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|dst
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|dstbase
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|srcbase
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|in_words_to_go
operator|=
name|ARM_NUM_INTS
argument_list|(
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|out_words_to_go
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|/
literal|4
expr_stmt|;
name|last_bytes
operator|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|&
literal|3
expr_stmt|;
name|dstoffset
operator|=
name|srcoffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|out_words_to_go
operator|!=
name|in_words_to_go
operator|&&
operator|(
operator|(
name|in_words_to_go
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
operator|!=
literal|0
condition|)
name|part_bytes_reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
operator|(
name|in_words_to_go
operator|-
literal|1
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|in_words_to_go
operator|>=
literal|2
condition|;
name|i
operator|+=
literal|4
control|)
block|{
if|if
condition|(
name|in_words_to_go
operator|>
literal|4
condition|)
name|emit_insn
argument_list|(
name|arm_gen_load_multiple
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
name|src
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|srcbase
argument_list|,
operator|&
name|srcoffset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_insn
argument_list|(
name|arm_gen_load_multiple
argument_list|(
literal|0
argument_list|,
name|in_words_to_go
argument_list|,
name|src
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|srcbase
argument_list|,
operator|&
name|srcoffset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_words_to_go
condition|)
block|{
if|if
condition|(
name|out_words_to_go
operator|>
literal|4
condition|)
name|emit_insn
argument_list|(
name|arm_gen_store_multiple
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
name|dst
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|dstbase
argument_list|,
operator|&
name|dstoffset
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|out_words_to_go
operator|!=
literal|1
condition|)
name|emit_insn
argument_list|(
name|arm_gen_store_multiple
argument_list|(
literal|0
argument_list|,
name|out_words_to_go
argument_list|,
name|dst
argument_list|,
name|TRUE
argument_list|,
operator|(
name|last_bytes
operator|==
literal|0
condition|?
name|FALSE
else|:
name|TRUE
operator|)
argument_list|,
name|dstbase
argument_list|,
operator|&
name|dstoffset
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|mem
operator|=
name|adjust_automodify_address
argument_list|(
name|dstbase
argument_list|,
name|SImode
argument_list|,
name|dst
argument_list|,
name|dstoffset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_bytes
operator|!=
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dst
argument_list|,
name|dst
argument_list|,
name|GEN_INT
argument_list|(
literal|4
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dstoffset
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
name|in_words_to_go
operator|-=
name|in_words_to_go
operator|<
literal|4
condition|?
name|in_words_to_go
else|:
literal|4
expr_stmt|;
name|out_words_to_go
operator|-=
name|out_words_to_go
operator|<
literal|4
condition|?
name|out_words_to_go
else|:
literal|4
expr_stmt|;
block|}
comment|/* OUT_WORDS_TO_GO will be zero here if there are byte stores to do.  */
if|if
condition|(
name|out_words_to_go
condition|)
block|{
name|rtx
name|sreg
decl_stmt|;
name|mem
operator|=
name|adjust_automodify_address
argument_list|(
name|srcbase
argument_list|,
name|SImode
argument_list|,
name|src
argument_list|,
name|srcoffset
argument_list|)
expr_stmt|;
name|sreg
operator|=
name|copy_to_reg
argument_list|(
name|mem
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_automodify_address
argument_list|(
name|dstbase
argument_list|,
name|SImode
argument_list|,
name|dst
argument_list|,
name|dstoffset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|sreg
argument_list|)
expr_stmt|;
name|in_words_to_go
operator|--
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|in_words_to_go
argument_list|)
expr_stmt|;
comment|/* Sanity check */
block|}
if|if
condition|(
name|in_words_to_go
condition|)
block|{
name|gcc_assert
argument_list|(
name|in_words_to_go
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mem
operator|=
name|adjust_automodify_address
argument_list|(
name|srcbase
argument_list|,
name|SImode
argument_list|,
name|src
argument_list|,
name|srcoffset
argument_list|)
expr_stmt|;
name|part_bytes_reg
operator|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
operator|!
name|last_bytes
operator|||
name|part_bytes_reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|last_bytes
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
comment|/* The bytes we want are in the top end of the word.  */
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmp
argument_list|,
name|part_bytes_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|8
operator|*
operator|(
literal|4
operator|-
name|last_bytes
operator|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part_bytes_reg
operator|=
name|tmp
expr_stmt|;
while|while
condition|(
name|last_bytes
condition|)
block|{
name|mem
operator|=
name|adjust_automodify_address
argument_list|(
name|dstbase
argument_list|,
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|dst
argument_list|,
name|last_bytes
operator|-
literal|1
argument_list|)
argument_list|,
name|dstoffset
operator|+
name|last_bytes
operator|-
literal|1
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|part_bytes_reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|last_bytes
condition|)
block|{
name|tmp
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmp
argument_list|,
name|part_bytes_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part_bytes_reg
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|last_bytes
operator|>
literal|1
condition|)
block|{
name|mem
operator|=
name|adjust_automodify_address
argument_list|(
name|dstbase
argument_list|,
name|HImode
argument_list|,
name|dst
argument_list|,
name|dstoffset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_lowpart
argument_list|(
name|HImode
argument_list|,
name|part_bytes_reg
argument_list|)
argument_list|)
expr_stmt|;
name|last_bytes
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|last_bytes
condition|)
block|{
name|rtx
name|tmp
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|dst
argument_list|,
name|dst
argument_list|,
name|const2_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|tmp
argument_list|,
name|part_bytes_reg
argument_list|,
name|GEN_INT
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|part_bytes_reg
operator|=
name|tmp
expr_stmt|;
name|dstoffset
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_bytes
condition|)
block|{
name|mem
operator|=
name|adjust_automodify_address
argument_list|(
name|dstbase
argument_list|,
name|QImode
argument_list|,
name|dst
argument_list|,
name|dstoffset
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|mem
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|part_bytes_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Select a dominance comparison mode if possible for a test of the general    form (OP (COND_OR (X) (Y)) (const_int 0)).  We support three forms.    COND_OR == DOM_CC_X_AND_Y => (X&& Y)    COND_OR == DOM_CC_NX_OR_Y => ((! X) || Y)    COND_OR == DOM_CC_X_OR_Y => (X || Y)    In all cases OP will be either EQ or NE, but we don't need to know which    here.  If we are unable to support a dominance comparison we return    CC mode.  This will then fail to match for the RTL expressions that    generate this call.  */
end_comment

begin_function
name|enum
name|machine_mode
name|arm_select_dominance_cc_mode
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|,
name|HOST_WIDE_INT
name|cond_or
parameter_list|)
block|{
name|enum
name|rtx_code
name|cond1
decl_stmt|,
name|cond2
decl_stmt|;
name|int
name|swapped
init|=
literal|0
decl_stmt|;
comment|/* Currently we will probably get the wrong result if the individual      comparisons are not simple.  This also ensures that it is safe to      reverse a comparison if necessary.  */
if|if
condition|(
operator|(
name|arm_select_cc_mode
argument_list|(
name|cond1
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CCmode
operator|)
operator|||
operator|(
name|arm_select_cc_mode
argument_list|(
name|cond2
operator|=
name|GET_CODE
argument_list|(
name|y
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CCmode
operator|)
condition|)
return|return
name|CCmode
return|;
comment|/* The if_then_else variant of this tests the second condition if the      first passes, but is true if the first fails.  Reverse the first      condition to get a true "inclusive-or" expression.  */
if|if
condition|(
name|cond_or
operator|==
name|DOM_CC_NX_OR_Y
condition|)
name|cond1
operator|=
name|reverse_condition
argument_list|(
name|cond1
argument_list|)
expr_stmt|;
comment|/* If the comparisons are not equal, and one doesn't dominate the other,      then we can't do this.  */
if|if
condition|(
name|cond1
operator|!=
name|cond2
operator|&&
operator|!
name|comparison_dominates_p
argument_list|(
name|cond1
argument_list|,
name|cond2
argument_list|)
operator|&&
operator|(
name|swapped
operator|=
literal|1
operator|,
operator|!
name|comparison_dominates_p
argument_list|(
name|cond2
argument_list|,
name|cond1
argument_list|)
operator|)
condition|)
return|return
name|CCmode
return|;
if|if
condition|(
name|swapped
condition|)
block|{
name|enum
name|rtx_code
name|temp
init|=
name|cond1
decl_stmt|;
name|cond1
operator|=
name|cond2
expr_stmt|;
name|cond2
operator|=
name|temp
expr_stmt|;
block|}
switch|switch
condition|(
name|cond1
condition|)
block|{
case|case
name|EQ
case|:
if|if
condition|(
name|cond_or
operator|==
name|DOM_CC_X_AND_Y
condition|)
return|return
name|CC_DEQmode
return|;
switch|switch
condition|(
name|cond2
condition|)
block|{
case|case
name|EQ
case|:
return|return
name|CC_DEQmode
return|;
case|case
name|LE
case|:
return|return
name|CC_DLEmode
return|;
case|case
name|LEU
case|:
return|return
name|CC_DLEUmode
return|;
case|case
name|GE
case|:
return|return
name|CC_DGEmode
return|;
case|case
name|GEU
case|:
return|return
name|CC_DGEUmode
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|LT
case|:
if|if
condition|(
name|cond_or
operator|==
name|DOM_CC_X_AND_Y
condition|)
return|return
name|CC_DLTmode
return|;
switch|switch
condition|(
name|cond2
condition|)
block|{
case|case
name|LT
case|:
return|return
name|CC_DLTmode
return|;
case|case
name|LE
case|:
return|return
name|CC_DLEmode
return|;
case|case
name|NE
case|:
return|return
name|CC_DNEmode
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|GT
case|:
if|if
condition|(
name|cond_or
operator|==
name|DOM_CC_X_AND_Y
condition|)
return|return
name|CC_DGTmode
return|;
switch|switch
condition|(
name|cond2
condition|)
block|{
case|case
name|GT
case|:
return|return
name|CC_DGTmode
return|;
case|case
name|GE
case|:
return|return
name|CC_DGEmode
return|;
case|case
name|NE
case|:
return|return
name|CC_DNEmode
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|LTU
case|:
if|if
condition|(
name|cond_or
operator|==
name|DOM_CC_X_AND_Y
condition|)
return|return
name|CC_DLTUmode
return|;
switch|switch
condition|(
name|cond2
condition|)
block|{
case|case
name|LTU
case|:
return|return
name|CC_DLTUmode
return|;
case|case
name|LEU
case|:
return|return
name|CC_DLEUmode
return|;
case|case
name|NE
case|:
return|return
name|CC_DNEmode
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|GTU
case|:
if|if
condition|(
name|cond_or
operator|==
name|DOM_CC_X_AND_Y
condition|)
return|return
name|CC_DGTUmode
return|;
switch|switch
condition|(
name|cond2
condition|)
block|{
case|case
name|GTU
case|:
return|return
name|CC_DGTUmode
return|;
case|case
name|GEU
case|:
return|return
name|CC_DGEUmode
return|;
case|case
name|NE
case|:
return|return
name|CC_DNEmode
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* The remaining cases only occur when both comparisons are the        same.  */
case|case
name|NE
case|:
name|gcc_assert
argument_list|(
name|cond1
operator|==
name|cond2
argument_list|)
expr_stmt|;
return|return
name|CC_DNEmode
return|;
case|case
name|LE
case|:
name|gcc_assert
argument_list|(
name|cond1
operator|==
name|cond2
argument_list|)
expr_stmt|;
return|return
name|CC_DLEmode
return|;
case|case
name|GE
case|:
name|gcc_assert
argument_list|(
name|cond1
operator|==
name|cond2
argument_list|)
expr_stmt|;
return|return
name|CC_DGEmode
return|;
case|case
name|LEU
case|:
name|gcc_assert
argument_list|(
name|cond1
operator|==
name|cond2
argument_list|)
expr_stmt|;
return|return
name|CC_DLEUmode
return|;
case|case
name|GEU
case|:
name|gcc_assert
argument_list|(
name|cond1
operator|==
name|cond2
argument_list|)
expr_stmt|;
return|return
name|CC_DGEUmode
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|enum
name|machine_mode
name|arm_select_cc_mode
parameter_list|(
name|enum
name|rtx_code
name|op
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
comment|/* All floating point compares return CCFP if it is an equality      comparison, and CCFPE otherwise.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|UNORDERED
case|:
case|case
name|ORDERED
case|:
case|case
name|UNLT
case|:
case|case
name|UNLE
case|:
case|case
name|UNGT
case|:
case|case
name|UNGE
case|:
case|case
name|UNEQ
case|:
case|case
name|LTGT
case|:
return|return
name|CCFPmode
return|;
case|case
name|LT
case|:
case|case
name|LE
case|:
case|case
name|GT
case|:
case|case
name|GE
case|:
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_MAVERICK
condition|)
return|return
name|CCFPmode
return|;
return|return
name|CCFPEmode
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* A compare with a shifted operand.  Because of canonicalization, the      comparison will have to be swapped when we emit the assembler.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ROTATE
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ROTATERT
operator|)
condition|)
return|return
name|CC_SWPmode
return|;
comment|/* This operation is performed swapped, but since we only rely on the Z      flag we don't need an additional mode.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|==
name|SImode
operator|&&
name|REG_P
argument_list|(
name|y
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NEG
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|)
condition|)
return|return
name|CC_Zmode
return|;
comment|/* This is a special case that is used by combine to allow a      comparison of a shifted byte load to be split into a zero-extend      followed by a comparison of the shifted integer (only valid for      equalities and unsigned inequalities).  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
literal|24
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|QImode
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|||
name|op
operator|==
name|GEU
operator|||
name|op
operator|==
name|GTU
operator|||
name|op
operator|==
name|LTU
operator|||
name|op
operator|==
name|LEU
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|CC_Zmode
return|;
comment|/* A construct for a conditional compare, if the false arm contains      0, then both conditions must be true, otherwise either condition      must be true.  Not all conditions are possible, so CCmode is      returned if it can't be done.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|==
name|const0_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|==
name|const1_rtx
operator|)
operator|&&
name|COMPARISON_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|COMPARISON_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|arm_select_dominance_cc_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
comment|/* Alternate canonicalizations of the above.  These are somewhat cleaner.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|&&
name|COMPARISON_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|COMPARISON_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|arm_select_dominance_cc_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DOM_CC_X_AND_Y
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IOR
operator|&&
name|COMPARISON_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|COMPARISON_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|arm_select_dominance_cc_mode
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|DOM_CC_X_OR_Y
argument_list|)
return|;
comment|/* An operation (on Thumb) where we want to test for a single bit.      This is done by shifting that bit up into the top bit of a      scratch register; we can then branch on the sign bit.  */
if|if
condition|(
name|TARGET_THUMB
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|const1_rtx
condition|)
return|return
name|CC_Nmode
return|;
comment|/* An operation that sets the condition codes as a side-effect, the      V flag is not set correctly, so we can only use comparisons where      this doesn't matter.  (For LT and GE we can use "mi" and "pl"      instead.)  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|&&
name|y
operator|==
name|const0_rtx
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|||
name|op
operator|==
name|LT
operator|||
name|op
operator|==
name|GE
operator|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|IOR
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|XOR
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NOT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NEG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LSHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ASHIFTRT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ROTATERT
operator|||
operator|(
name|TARGET_ARM
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|)
operator|)
condition|)
return|return
name|CC_NOOVmode
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|QImode
operator|&&
operator|(
name|op
operator|==
name|EQ
operator|||
name|op
operator|==
name|NE
operator|)
condition|)
return|return
name|CC_Zmode
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|SImode
operator|&&
operator|(
name|op
operator|==
name|LTU
operator|||
name|op
operator|==
name|GEU
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|y
argument_list|)
operator|||
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|y
argument_list|)
operator|)
condition|)
return|return
name|CC_Cmode
return|;
return|return
name|CCmode
return|;
block|}
end_function

begin_comment
comment|/* X and Y are two things to compare using CODE.  Emit the compare insn and    return the rtx for register 0 in the proper mode.  FP means this is a    floating point compare: I don't think that it is needed on the arm.  */
end_comment

begin_function
name|rtx
name|arm_gen_compare_reg
parameter_list|(
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|SELECT_CC_MODE
argument_list|(
name|code
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
decl_stmt|;
name|rtx
name|cc_reg
init|=
name|gen_rtx_REG
argument_list|(
name|mode
argument_list|,
name|CC_REGNUM
argument_list|)
decl_stmt|;
name|emit_set_insn
argument_list|(
name|cc_reg
argument_list|,
name|gen_rtx_COMPARE
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_reg
return|;
block|}
end_function

begin_comment
comment|/* Generate a sequence of insns that will generate the correct return    address mask depending on the physical architecture that the program    is running on.  */
end_comment

begin_function
name|rtx
name|arm_gen_return_addr_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|Pmode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_return_addr_mask
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_function
name|void
name|arm_reload_in_hi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|ref
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|scratch
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|=
name|SUBREG_BYTE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* We have a pseudo which has been spilt onto the stack; there 	 are two cases here: the first where there is a simple 	 stack-slot replacement and a second where the stack-slot is 	 out of range, or is used as a subreg.  */
if|if
condition|(
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
condition|)
block|{
name|ref
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* The slot is out of range, or was dressed up in a SUBREG.  */
name|base
operator|=
name|reg_equiv_address
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
block|}
else|else
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle the case where the address is too complex to be offset by 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MINUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|emit_set_insn
argument_list|(
name|base_plus
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The addend must be CONST_INT, or we would have dealt with it above.  */
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Rework the address into a legal sequence of insns.  */
comment|/* Valid range for lo is -4095 -> 4095 */
name|lo
operator|=
operator|(
name|offset
operator|>=
literal|0
condition|?
operator|(
name|offset
operator|&
literal|0xfff
operator|)
else|:
operator|-
operator|(
operator|(
operator|-
name|offset
operator|)
operator|&
literal|0xfff
operator|)
operator|)
expr_stmt|;
comment|/* Corner case, if lo is the max offset then we would be out of range 	 once we have added the additional 1 below, so bump the msb into the 	 pre-loading insn(s).  */
if|if
condition|(
name|lo
operator|==
literal|4095
condition|)
name|lo
operator|&=
literal|0x7ff
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
operator|(
operator|(
name|offset
operator|-
name|lo
operator|)
operator|&
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|^
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|hi
operator|+
name|lo
operator|==
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Get the base address; addsi3 knows how to handle constants 	     that require more than one insn.  */
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|base_plus
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
name|hi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
name|offset
operator|=
name|lo
expr_stmt|;
block|}
block|}
comment|/* Operands[2] may overlap operands[0] (though it won't overlap      operands[1]), that's why we asked for a DImode reg -- so we can      use the bit that does not overlap.  */
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
name|scratch
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|scratch
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendqisi2
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_zero_extendqisi2
argument_list|(
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
name|emit_set_insn
argument_list|(
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|,
name|scratch
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|emit_set_insn
argument_list|(
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_IOR
argument_list|(
name|SImode
argument_list|,
name|gen_rtx_ASHIFT
argument_list|(
name|SImode
argument_list|,
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle storing a half-word to memory during reload by synthesizing as two    byte stores.  Take care not to clobber the input values until after we    have moved them somewhere safe.  This code assumes that if the DImode    scratch in operands[2] overlaps either the input value or output address    in some way, then that value must die in this insn (we absolutely need    two scratch registers for some corner cases).  */
end_comment

begin_function
name|void
name|arm_reload_out_hi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|ref
init|=
name|operands
index|[
literal|0
index|]
decl_stmt|;
name|rtx
name|outval
init|=
name|operands
index|[
literal|1
index|]
decl_stmt|;
name|rtx
name|base
decl_stmt|,
name|scratch
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|=
name|SUBREG_BYTE
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|ref
operator|=
name|SUBREG_REG
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* We have a pseudo which has been spilt onto the stack; there 	 are two cases here: the first where there is a simple 	 stack-slot replacement and a second where the stack-slot is 	 out of range, or is used as a subreg.  */
if|if
condition|(
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
condition|)
block|{
name|ref
operator|=
name|reg_equiv_mem
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* The slot is out of range, or was dressed up in a SUBREG.  */
name|base
operator|=
name|reg_equiv_address
index|[
name|REGNO
argument_list|(
name|ref
argument_list|)
index|]
expr_stmt|;
block|}
else|else
name|base
operator|=
name|find_replacement
argument_list|(
operator|&
name|XEXP
argument_list|(
name|ref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle the case where the address is too complex to be offset by 1.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|MINUS
operator|||
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Be careful not to destroy OUTVAL.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|base_plus
argument_list|,
name|outval
argument_list|)
condition|)
block|{
comment|/* Updating base_plus might destroy outval, see if we can 	     swap the scratch and base_plus.  */
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|scratch
argument_list|,
name|outval
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|scratch
decl_stmt|;
name|scratch
operator|=
name|base_plus
expr_stmt|;
name|base_plus
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|scratch_hi
init|=
name|gen_rtx_REG
argument_list|(
name|HImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Be conservative and copy OUTVAL into the scratch now, 		 this should only be necessary if outval is a subreg 		 of something larger than a word.  */
comment|/* XXX Might this clobber base?  I can't see how it can, 		 since scratch is known to overlap with OUTVAL, and 		 must be wider than a word.  */
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|scratch_hi
argument_list|,
name|outval
argument_list|)
argument_list|)
expr_stmt|;
name|outval
operator|=
name|scratch_hi
expr_stmt|;
block|}
block|}
name|emit_set_insn
argument_list|(
name|base_plus
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|PLUS
condition|)
block|{
comment|/* The addend must be CONST_INT, or we would have dealt with it above.  */
name|HOST_WIDE_INT
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Rework the address into a legal sequence of insns.  */
comment|/* Valid range for lo is -4095 -> 4095 */
name|lo
operator|=
operator|(
name|offset
operator|>=
literal|0
condition|?
operator|(
name|offset
operator|&
literal|0xfff
operator|)
else|:
operator|-
operator|(
operator|(
operator|-
name|offset
operator|)
operator|&
literal|0xfff
operator|)
operator|)
expr_stmt|;
comment|/* Corner case, if lo is the max offset then we would be out of range 	 once we have added the additional 1 below, so bump the msb into the 	 pre-loading insn(s).  */
if|if
condition|(
name|lo
operator|==
literal|4095
condition|)
name|lo
operator|&=
literal|0x7ff
expr_stmt|;
name|hi
operator|=
operator|(
operator|(
operator|(
operator|(
name|offset
operator|-
name|lo
operator|)
operator|&
operator|(
name|HOST_WIDE_INT
operator|)
literal|0xffffffff
operator|)
operator|^
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
operator|-
operator|(
name|HOST_WIDE_INT
operator|)
literal|0x80000000
operator|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|hi
operator|+
name|lo
operator|==
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|!=
literal|0
condition|)
block|{
name|rtx
name|base_plus
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Be careful not to destroy OUTVAL.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|base_plus
argument_list|,
name|outval
argument_list|)
condition|)
block|{
comment|/* Updating base_plus might destroy outval, see if we 		 can swap the scratch and base_plus.  */
if|if
condition|(
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|scratch
argument_list|,
name|outval
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|scratch
decl_stmt|;
name|scratch
operator|=
name|base_plus
expr_stmt|;
name|base_plus
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|scratch_hi
init|=
name|gen_rtx_REG
argument_list|(
name|HImode
argument_list|,
name|REGNO
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Be conservative and copy outval into scratch now, 		     this should only be necessary if outval is a 		     subreg of something larger than a word.  */
comment|/* XXX Might this clobber base?  I can't see how it 		     can, since scratch is known to overlap with 		     outval.  */
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|scratch_hi
argument_list|,
name|outval
argument_list|)
argument_list|)
expr_stmt|;
name|outval
operator|=
name|scratch_hi
expr_stmt|;
block|}
block|}
comment|/* Get the base address; addsi3 knows how to handle constants 	     that require more than one insn.  */
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|base_plus
argument_list|,
name|base
argument_list|,
name|GEN_INT
argument_list|(
name|hi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|base_plus
expr_stmt|;
name|offset
operator|=
name|lo
expr_stmt|;
block|}
block|}
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|outval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|outval
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|scratch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|outval
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_lshrsi3
argument_list|(
name|scratch
argument_list|,
name|gen_rtx_SUBREG
argument_list|(
name|SImode
argument_list|,
name|outval
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
literal|8
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|base
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
argument_list|)
argument_list|,
name|gen_lowpart
argument_list|(
name|QImode
argument_list|,
name|scratch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if a type must be passed in memory. For AAPCS, small aggregates    (padded to the size of a word) should be passed in a register.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_must_pass_in_stack
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|TARGET_AAPCS_BASED
condition|)
return|return
name|must_pass_in_stack_var_size
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
else|else
return|return
name|must_pass_in_stack_var_size_or_pad
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* For use by FUNCTION_ARG_PADDING (MODE, TYPE).    Return true if an argument passed on the stack should be padded upwards,    i.e. if the least-significant byte has useful data.    For legacy APCS ABIs we use the default.  For AAPCS based ABIs small    aggregate types are placed in the lowest memory address.  */
end_comment

begin_function
name|bool
name|arm_pad_arg_upward
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_AAPCS_BASED
condition|)
return|return
name|DEFAULT_FUNCTION_ARG_PADDING
argument_list|(
name|mode
argument_list|,
name|type
argument_list|)
operator|==
name|upward
return|;
if|if
condition|(
name|type
operator|&&
name|BYTES_BIG_ENDIAN
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Similarly, for use by BLOCK_REG_PADDING (MODE, TYPE, FIRST).    For non-AAPCS, return !BYTES_BIG_ENDIAN if the least significant    byte of the register has useful data, and return the opposite if the    most significant byte does.    For AAPCS, small aggregates and small complex types are always padded    upwards.  */
end_comment

begin_function
name|bool
name|arm_pad_reg_upward
parameter_list|(
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|first
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TARGET_AAPCS_BASED
operator|&&
name|BYTES_BIG_ENDIAN
operator|&&
operator|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|<=
literal|4
condition|)
return|return
name|true
return|;
comment|/* Otherwise, use default padding.  */
return|return
operator|!
name|BYTES_BIG_ENDIAN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a symbolic form of X to the debug file, F.  */
end_comment

begin_function
specifier|static
name|void
name|arm_print_value
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST_DOUBLE
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"<0x%lx,0x%lx>"
argument_list|,
operator|(
name|long
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST_VECTOR
case|:
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|INTVAL
argument_list|(
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|CONST_STRING
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\"%s\""
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SYMBOL_REF
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"`%s'"
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|LABEL_REF
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"L%d"
argument_list|,
name|INSN_UID
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|CONST
case|:
name|arm_print_value
argument_list|(
name|f
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS
case|:
name|arm_print_value
argument_list|(
name|f
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|arm_print_value
argument_list|(
name|f
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|PC
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"pc"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"????"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines for manipulation of the constant pool.  */
end_comment

begin_comment
comment|/* Arm instructions cannot load a large constant directly into a    register; they have to come from a pc relative load.  The constant    must therefore be placed in the addressable range of the pc    relative load.  Depending on the precise pc relative load    instruction the range is somewhere between 256 bytes and 4k.  This    means that we often have to dump a constant inside a function, and    generate code to branch around it.     It is important to minimize this, since the branches will slow    things down and make the code larger.     Normally we can hide the table after an existing unconditional    branch so that there is no interruption of the flow, but in the    worst case the code looks like this:  	ldr	rn, L1 	... 	b	L2 	align 	L1:	.long value 	L2: 	...  	ldr	rn, L3 	... 	b	L4 	align 	L3:	.long value 	L4: 	...     We fix this by performing a scan after scheduling, which notices    which instructions need to have their operands fetched from the    constant table and builds the table.     The algorithm starts by building a table of all the constants that    need fixing up and all the natural barriers in the function (places    where a constant table can be dropped without breaking the flow).    For each fixup we note how far the pc-relative replacement will be    able to reach and the offset of the instruction into the function.     Having built the table we then group the fixes together to form    tables that are as large as possible (subject to addressing    constraints) and emit each table of constants after the last    barrier that is within range of all the instructions in the group.    If a group does not contain a barrier, then we forcibly create one    by inserting a jump instruction into the flow.  Once the table has    been inserted, the insns are then modified to reference the    relevant entry in the pool.     Possible enhancements to the algorithm (not implemented) are:     1) For some processors and object formats, there may be benefit in    aligning the pools to the start of cache lines; this alignment    would need to be taken into account when calculating addressability    of a pool.  */
end_comment

begin_comment
comment|/* These typedefs are located at the start of this file, so that    they can be used in the prototypes there.  This comment is to    remind readers of that fact so that the following structures    can be understood more easily.       typedef struct minipool_node    Mnode;      typedef struct minipool_fixup   Mfix;  */
end_comment

begin_struct
struct|struct
name|minipool_node
block|{
comment|/* Doubly linked chain of entries.  */
name|Mnode
modifier|*
name|next
decl_stmt|;
name|Mnode
modifier|*
name|prev
decl_stmt|;
comment|/* The maximum offset into the code that this entry can be placed.  While      pushing fixes for forward references, all entries are sorted in order      of increasing max_address.  */
name|HOST_WIDE_INT
name|max_address
decl_stmt|;
comment|/* Similarly for an entry inserted for a backwards ref.  */
name|HOST_WIDE_INT
name|min_address
decl_stmt|;
comment|/* The number of fixes referencing this entry.  This can become zero      if we "unpush" an entry.  In this case we ignore the entry when we      come to emit the code.  */
name|int
name|refcount
decl_stmt|;
comment|/* The offset from the start of the minipool.  */
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* The value in table.  */
name|rtx
name|value
decl_stmt|;
comment|/* The mode of value.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* The size of the value.  With iWMMXt enabled      sizes> 4 also imply an alignment of 8-bytes.  */
name|int
name|fix_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|minipool_fixup
block|{
name|Mfix
modifier|*
name|next
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|HOST_WIDE_INT
name|address
decl_stmt|;
name|rtx
modifier|*
name|loc
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|fix_size
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|Mnode
modifier|*
name|minipool
decl_stmt|;
name|HOST_WIDE_INT
name|forwards
decl_stmt|;
name|HOST_WIDE_INT
name|backwards
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Fixes less than a word need padding out to a word boundary.  */
end_comment

begin_define
define|#
directive|define
name|MINIPOOL_FIX_SIZE
parameter_list|(
name|mode
parameter_list|)
define|\
value|(GET_MODE_SIZE ((mode))>= 4 ? GET_MODE_SIZE ((mode)) : 4)
end_define

begin_decl_stmt
specifier|static
name|Mnode
modifier|*
name|minipool_vector_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Mnode
modifier|*
name|minipool_vector_tail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|minipool_vector_label
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|minipool_pad
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The linked list of all minipool fixes required for this function.  */
end_comment

begin_decl_stmt
name|Mfix
modifier|*
name|minipool_fix_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Mfix
modifier|*
name|minipool_fix_tail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The fix entry for the current minipool, once it has been placed.  */
end_comment

begin_decl_stmt
name|Mfix
modifier|*
name|minipool_barrier
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determines if INSN is the start of a jump table.  Returns the end    of the TABLE or NULL_RTX.  */
end_comment

begin_function
specifier|static
name|rtx
name|is_jump_table
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|table
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|table
operator|=
name|next_real_insn
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
operator|==
name|next_real_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|table
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|table
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|table
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
return|return
name|table
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|JUMP_TABLES_IN_TEXT_SECTION
end_ifndef

begin_define
define|#
directive|define
name|JUMP_TABLES_IN_TEXT_SECTION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|HOST_WIDE_INT
name|get_jump_table_size
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
comment|/* ADDR_VECs only take room if read-only data does into the text      section.  */
if|if
condition|(
name|JUMP_TABLES_IN_TEXT_SECTION
operator|||
name|readonly_data_section
operator|==
name|text_section
condition|)
block|{
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|elt
init|=
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|?
literal|1
else|:
literal|0
decl_stmt|;
return|return
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|body
argument_list|)
argument_list|)
operator|*
name|XVECLEN
argument_list|(
name|body
argument_list|,
name|elt
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Move a minipool fix MP from its current location to before MAX_MP.    If MAX_MP is NULL, then MP doesn't need moving, but the addressing    constraints may need updating.  */
end_comment

begin_function
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_forward_ref
parameter_list|(
name|Mnode
modifier|*
name|mp
parameter_list|,
name|Mnode
modifier|*
name|max_mp
parameter_list|,
name|HOST_WIDE_INT
name|max_address
parameter_list|)
block|{
comment|/* The code below assumes these are different.  */
name|gcc_assert
argument_list|(
name|mp
operator|!=
name|max_mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_mp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|max_address
operator|<
name|mp
operator|->
name|max_address
condition|)
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|max_address
operator|>
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|max_address
operator|=
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
expr_stmt|;
else|else
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
comment|/* Unlink MP from its current position.  Since max_mp is non-null,        mp->prev must be non-null.  */
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
else|else
name|minipool_vector_tail
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
comment|/* Re-insert it before MAX_MP.  */
name|mp
operator|->
name|next
operator|=
name|max_mp
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|max_mp
operator|->
name|prev
expr_stmt|;
name|max_mp
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
block|}
comment|/* Save the new entry.  */
name|max_mp
operator|=
name|mp
expr_stmt|;
comment|/* Scan over the preceding entries and adjust their addresses as      required.  */
while|while
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
operator|&&
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|>
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
condition|)
block|{
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|=
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
block|}
return|return
name|max_mp
return|;
block|}
end_function

begin_comment
comment|/* Add a constant to the minipool for a forward reference.  Returns the    node added or NULL if the constant will not fit in this pool.  */
end_comment

begin_function
specifier|static
name|Mnode
modifier|*
name|add_minipool_forward_ref
parameter_list|(
name|Mfix
modifier|*
name|fix
parameter_list|)
block|{
comment|/* If set, max_mp is the first pool_entry that has a lower      constraint than the one we are trying to add.  */
name|Mnode
modifier|*
name|max_mp
init|=
name|NULL
decl_stmt|;
name|HOST_WIDE_INT
name|max_address
init|=
name|fix
operator|->
name|address
operator|+
name|fix
operator|->
name|forwards
operator|-
name|minipool_pad
decl_stmt|;
name|Mnode
modifier|*
name|mp
decl_stmt|;
comment|/* If the minipool starts before the end of FIX->INSN then this FIX      can not be placed into the current pool.  Furthermore, adding the      new constant pool entry may cause the pool to start FIX_SIZE bytes      earlier.  */
if|if
condition|(
name|minipool_vector_head
operator|&&
operator|(
name|fix
operator|->
name|address
operator|+
name|get_attr_length
argument_list|(
name|fix
operator|->
name|insn
argument_list|)
operator|>=
name|minipool_vector_head
operator|->
name|max_address
operator|-
name|fix
operator|->
name|fix_size
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Scan the pool to see if a constant with the same value has      already been added.  While we are doing this, also note the      location where we must insert the constant if it doesn't already      exist.  */
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|&&
name|fix
operator|->
name|mode
operator|==
name|mp
operator|->
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
operator|(
name|CODE_LABEL_NUMBER
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|CODE_LABEL_NUMBER
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|fix
operator|->
name|value
argument_list|,
name|mp
operator|->
name|value
argument_list|)
condition|)
block|{
comment|/* More than one fix references this entry.  */
name|mp
operator|->
name|refcount
operator|++
expr_stmt|;
return|return
name|move_minipool_fix_forward_ref
argument_list|(
name|mp
argument_list|,
name|max_mp
argument_list|,
name|max_address
argument_list|)
return|;
block|}
comment|/* Note the insertion point if necessary.  */
if|if
condition|(
name|max_mp
operator|==
name|NULL
operator|&&
name|mp
operator|->
name|max_address
operator|>
name|max_address
condition|)
name|max_mp
operator|=
name|mp
expr_stmt|;
comment|/* If we are inserting an 8-bytes aligned quantity and 	 we have not already found an insertion point, then 	 make sure that all such 8-byte aligned quantities are 	 placed at the start of the pool.  */
if|if
condition|(
name|ARM_DOUBLEWORD_ALIGN
operator|&&
name|max_mp
operator|==
name|NULL
operator|&&
name|fix
operator|->
name|fix_size
operator|==
literal|8
operator|&&
name|mp
operator|->
name|fix_size
operator|!=
literal|8
condition|)
block|{
name|max_mp
operator|=
name|mp
expr_stmt|;
name|max_address
operator|=
name|mp
operator|->
name|max_address
expr_stmt|;
block|}
block|}
comment|/* The value is not currently in the minipool, so we need to create      a new entry for it.  If MAX_MP is NULL, the entry will be put on      the end of the list since the placement is less constrained than      any existing entry.  Otherwise, we insert the new fix before      MAX_MP and, if necessary, adjust the constraints on the other      entries.  */
name|mp
operator|=
name|XNEW
argument_list|(
name|Mnode
argument_list|)
expr_stmt|;
name|mp
operator|->
name|fix_size
operator|=
name|fix
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|->
name|mode
operator|=
name|fix
operator|->
name|mode
expr_stmt|;
name|mp
operator|->
name|value
operator|=
name|fix
operator|->
name|value
expr_stmt|;
name|mp
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
comment|/* Not yet required for a backwards ref.  */
name|mp
operator|->
name|min_address
operator|=
operator|-
literal|65536
expr_stmt|;
if|if
condition|(
name|max_mp
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|minipool_vector_tail
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|==
name|NULL
condition|)
block|{
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
name|minipool_vector_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
expr_stmt|;
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|max_address
operator|>
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|max_address
operator|=
name|max_mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|fix_size
expr_stmt|;
else|else
name|mp
operator|->
name|max_address
operator|=
name|max_address
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|max_mp
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|max_mp
operator|->
name|prev
expr_stmt|;
name|max_mp
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
block|}
comment|/* Save the new entry.  */
name|max_mp
operator|=
name|mp
expr_stmt|;
comment|/* Scan over the preceding entries and adjust their addresses as      required.  */
while|while
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
operator|&&
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|>
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
condition|)
block|{
name|mp
operator|->
name|prev
operator|->
name|max_address
operator|=
name|mp
operator|->
name|max_address
operator|-
name|mp
operator|->
name|prev
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
block|}
return|return
name|max_mp
return|;
block|}
end_function

begin_function
specifier|static
name|Mnode
modifier|*
name|move_minipool_fix_backward_ref
parameter_list|(
name|Mnode
modifier|*
name|mp
parameter_list|,
name|Mnode
modifier|*
name|min_mp
parameter_list|,
name|HOST_WIDE_INT
name|min_address
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* The code below assumes these are different.  */
name|gcc_assert
argument_list|(
name|mp
operator|!=
name|min_mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_mp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|min_address
operator|>
name|mp
operator|->
name|min_address
condition|)
name|mp
operator|->
name|min_address
operator|=
name|min_address
expr_stmt|;
block|}
else|else
block|{
comment|/* We will adjust this below if it is too loose.  */
name|mp
operator|->
name|min_address
operator|=
name|min_address
expr_stmt|;
comment|/* Unlink MP from its current position.  Since min_mp is non-null, 	 mp->next must be non-null.  */
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|prev
operator|->
name|next
operator|=
name|mp
operator|->
name|next
expr_stmt|;
else|else
name|minipool_vector_head
operator|=
name|mp
operator|->
name|next
expr_stmt|;
comment|/* Reinsert it after MIN_MP.  */
name|mp
operator|->
name|prev
operator|=
name|min_mp
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|min_mp
operator|->
name|next
expr_stmt|;
name|min_mp
operator|->
name|next
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
block|}
name|min_mp
operator|=
name|mp
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
name|mp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|refcount
operator|>
literal|0
condition|)
name|offset
operator|+=
name|mp
operator|->
name|fix_size
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|&&
name|mp
operator|->
name|next
operator|->
name|min_address
operator|<
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|next
operator|->
name|min_address
operator|=
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
expr_stmt|;
block|}
return|return
name|min_mp
return|;
block|}
end_function

begin_comment
comment|/* Add a constant to the minipool for a backward reference.  Returns the    node added or NULL if the constant will not fit in this pool.     Note that the code for insertion for a backwards reference can be    somewhat confusing because the calculated offsets for each fix do    not take into account the size of the pool (which is still under    construction.  */
end_comment

begin_function
specifier|static
name|Mnode
modifier|*
name|add_minipool_backward_ref
parameter_list|(
name|Mfix
modifier|*
name|fix
parameter_list|)
block|{
comment|/* If set, min_mp is the last pool_entry that has a lower constraint      than the one we are trying to add.  */
name|Mnode
modifier|*
name|min_mp
init|=
name|NULL
decl_stmt|;
comment|/* This can be negative, since it is only a constraint.  */
name|HOST_WIDE_INT
name|min_address
init|=
name|fix
operator|->
name|address
operator|-
name|fix
operator|->
name|backwards
decl_stmt|;
name|Mnode
modifier|*
name|mp
decl_stmt|;
comment|/* If we can't reach the current pool from this insn, or if we can't      insert this entry at the end of the pool without pushing other      fixes out of range, then we don't try.  This ensures that we      can't fail later on.  */
if|if
condition|(
name|min_address
operator|>=
name|minipool_barrier
operator|->
name|address
operator|||
operator|(
name|minipool_vector_tail
operator|->
name|min_address
operator|+
name|fix
operator|->
name|fix_size
operator|>=
name|minipool_barrier
operator|->
name|address
operator|)
condition|)
return|return
name|NULL
return|;
comment|/* Scan the pool to see if a constant with the same value has      already been added.  While we are doing this, also note the      location where we must insert the constant if it doesn't already      exist.  */
for|for
control|(
name|mp
operator|=
name|minipool_vector_tail
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|prev
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|&&
name|fix
operator|->
name|mode
operator|==
name|mp
operator|->
name|mode
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|!=
name|CODE_LABEL
operator|||
operator|(
name|CODE_LABEL_NUMBER
argument_list|(
name|fix
operator|->
name|value
argument_list|)
operator|==
name|CODE_LABEL_NUMBER
argument_list|(
name|mp
operator|->
name|value
argument_list|)
operator|)
operator|)
operator|&&
name|rtx_equal_p
argument_list|(
name|fix
operator|->
name|value
argument_list|,
name|mp
operator|->
name|value
argument_list|)
comment|/* Check that there is enough slack to move this entry to the 	     end of the table (this is conservative).  */
operator|&&
operator|(
name|mp
operator|->
name|max_address
operator|>
operator|(
name|minipool_barrier
operator|->
name|address
operator|+
name|minipool_vector_tail
operator|->
name|offset
operator|+
name|minipool_vector_tail
operator|->
name|fix_size
operator|)
operator|)
condition|)
block|{
name|mp
operator|->
name|refcount
operator|++
expr_stmt|;
return|return
name|move_minipool_fix_backward_ref
argument_list|(
name|mp
argument_list|,
name|min_mp
argument_list|,
name|min_address
argument_list|)
return|;
block|}
if|if
condition|(
name|min_mp
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|min_address
operator|+=
name|fix
operator|->
name|fix_size
expr_stmt|;
else|else
block|{
comment|/* Note the insertion point if necessary.  */
if|if
condition|(
name|mp
operator|->
name|min_address
operator|<
name|min_address
condition|)
block|{
comment|/* For now, we do not allow the insertion of 8-byte alignment 		 requiring nodes anywhere but at the start of the pool.  */
if|if
condition|(
name|ARM_DOUBLEWORD_ALIGN
operator|&&
name|fix
operator|->
name|fix_size
operator|==
literal|8
operator|&&
name|mp
operator|->
name|fix_size
operator|!=
literal|8
condition|)
return|return
name|NULL
return|;
else|else
name|min_mp
operator|=
name|mp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|max_address
operator|<
name|minipool_barrier
operator|->
name|address
operator|+
name|mp
operator|->
name|offset
operator|+
name|fix
operator|->
name|fix_size
condition|)
block|{
comment|/* Inserting before this entry would push the fix beyond 		 its maximum address (which can happen if we have 		 re-located a forwards fix); force the new fix to come 		 after it.  */
name|min_mp
operator|=
name|mp
expr_stmt|;
name|min_address
operator|=
name|mp
operator|->
name|min_address
operator|+
name|fix
operator|->
name|fix_size
expr_stmt|;
block|}
comment|/* If we are inserting an 8-bytes aligned quantity and 	     we have not already found an insertion point, then 	     make sure that all such 8-byte aligned quantities are 	     placed at the start of the pool.  */
elseif|else
if|if
condition|(
name|ARM_DOUBLEWORD_ALIGN
operator|&&
name|min_mp
operator|==
name|NULL
operator|&&
name|fix
operator|->
name|fix_size
operator|==
literal|8
operator|&&
name|mp
operator|->
name|fix_size
operator|<
literal|8
condition|)
block|{
name|min_mp
operator|=
name|mp
expr_stmt|;
name|min_address
operator|=
name|mp
operator|->
name|min_address
operator|+
name|fix
operator|->
name|fix_size
expr_stmt|;
block|}
block|}
block|}
comment|/* We need to create a new entry.  */
name|mp
operator|=
name|XNEW
argument_list|(
name|Mnode
argument_list|)
expr_stmt|;
name|mp
operator|->
name|fix_size
operator|=
name|fix
operator|->
name|fix_size
expr_stmt|;
name|mp
operator|->
name|mode
operator|=
name|fix
operator|->
name|mode
expr_stmt|;
name|mp
operator|->
name|value
operator|=
name|fix
operator|->
name|value
expr_stmt|;
name|mp
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|max_address
operator|=
name|minipool_barrier
operator|->
name|address
operator|+
literal|65536
expr_stmt|;
name|mp
operator|->
name|min_address
operator|=
name|min_address
expr_stmt|;
if|if
condition|(
name|min_mp
operator|==
name|NULL
condition|)
block|{
name|mp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|mp
operator|->
name|next
operator|=
name|minipool_vector_head
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
name|minipool_vector_label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
block|}
else|else
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
name|minipool_vector_head
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|next
operator|=
name|min_mp
operator|->
name|next
expr_stmt|;
name|mp
operator|->
name|prev
operator|=
name|min_mp
expr_stmt|;
name|min_mp
operator|->
name|next
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|mp
operator|->
name|next
operator|->
name|prev
operator|=
name|mp
expr_stmt|;
else|else
name|minipool_vector_tail
operator|=
name|mp
expr_stmt|;
block|}
comment|/* Save the new entry.  */
name|min_mp
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|prev
condition|)
name|mp
operator|=
name|mp
operator|->
name|prev
expr_stmt|;
else|else
name|mp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* Scan over the following entries and adjust their offsets.  */
while|while
condition|(
name|mp
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|next
operator|->
name|min_address
operator|<
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
condition|)
name|mp
operator|->
name|next
operator|->
name|min_address
operator|=
name|mp
operator|->
name|min_address
operator|+
name|mp
operator|->
name|fix_size
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|refcount
condition|)
name|mp
operator|->
name|next
operator|->
name|offset
operator|=
name|mp
operator|->
name|offset
operator|+
name|mp
operator|->
name|fix_size
expr_stmt|;
else|else
name|mp
operator|->
name|next
operator|->
name|offset
operator|=
name|mp
operator|->
name|offset
expr_stmt|;
name|mp
operator|=
name|mp
operator|->
name|next
expr_stmt|;
block|}
return|return
name|min_mp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|assign_minipool_offsets
parameter_list|(
name|Mfix
modifier|*
name|barrier
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|Mnode
modifier|*
name|mp
decl_stmt|;
name|minipool_barrier
operator|=
name|barrier
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
block|{
name|mp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|refcount
operator|>
literal|0
condition|)
name|offset
operator|+=
name|mp
operator|->
name|fix_size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the literal table */
end_comment

begin_function
specifier|static
name|void
name|dump_minipool
parameter_list|(
name|rtx
name|scan
parameter_list|)
block|{
name|Mnode
modifier|*
name|mp
decl_stmt|;
name|Mnode
modifier|*
name|nmp
decl_stmt|;
name|int
name|align64
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ARM_DOUBLEWORD_ALIGN
condition|)
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|next
control|)
if|if
condition|(
name|mp
operator|->
name|refcount
operator|>
literal|0
operator|&&
name|mp
operator|->
name|fix_size
operator|==
literal|8
condition|)
block|{
name|align64
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Emitting minipool after insn %u; address %ld; align %d (bytes)\n"
argument_list|,
name|INSN_UID
argument_list|(
name|scan
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|minipool_barrier
operator|->
name|address
argument_list|,
name|align64
condition|?
literal|8
else|:
literal|4
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_label_after
argument_list|(
name|gen_label_rtx
argument_list|()
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|align64
condition|?
name|gen_align_8
argument_list|()
else|:
name|gen_align_4
argument_list|()
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_label_after
argument_list|(
name|minipool_vector_label
argument_list|,
name|scan
argument_list|)
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|minipool_vector_head
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|nmp
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";;  Offset %u, min %ld, max %ld "
argument_list|,
operator|(
name|unsigned
operator|)
name|mp
operator|->
name|offset
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|mp
operator|->
name|min_address
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|mp
operator|->
name|max_address
argument_list|)
expr_stmt|;
name|arm_print_value
argument_list|(
name|dump_file
argument_list|,
name|mp
operator|->
name|value
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|dump_file
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mp
operator|->
name|fix_size
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_consttable_1
case|case
literal|1
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_1
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_consttable_2
case|case
literal|2
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_2
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_consttable_4
case|case
literal|4
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_4
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_consttable_8
case|case
literal|8
case|:
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_8
argument_list|(
name|mp
operator|->
name|value
argument_list|)
argument_list|,
name|scan
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
name|nmp
operator|=
name|mp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|minipool_vector_head
operator|=
name|minipool_vector_tail
operator|=
name|NULL
expr_stmt|;
name|scan
operator|=
name|emit_insn_after
argument_list|(
name|gen_consttable_end
argument_list|()
argument_list|,
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|emit_barrier_after
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the cost of forcibly inserting a barrier after INSN.  */
end_comment

begin_function
specifier|static
name|int
name|arm_barrier_cost
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
comment|/* Basing the location of the pool on the loop depth is preferable,      but at the moment, the basic block information seems to be      corrupt by this stage of the compilation.  */
name|int
name|base_cost
init|=
literal|50
decl_stmt|;
name|rtx
name|next
init|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|base_cost
operator|-=
literal|20
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
comment|/* It will always be better to place the table before the label, rather 	 than after it.  */
return|return
literal|50
return|;
case|case
name|INSN
case|:
case|case
name|CALL_INSN
case|:
return|return
name|base_cost
return|;
case|case
name|JUMP_INSN
case|:
return|return
name|base_cost
operator|-
literal|10
return|;
default|default:
return|return
name|base_cost
operator|+
literal|10
return|;
block|}
block|}
end_function

begin_comment
comment|/* Find the best place in the insn stream in the range    (FIX->address,MAX_ADDRESS) to forcibly insert a minipool barrier.    Create the barrier by inserting a jump and add a new fix entry for    it.  */
end_comment

begin_function
specifier|static
name|Mfix
modifier|*
name|create_fix_barrier
parameter_list|(
name|Mfix
modifier|*
name|fix
parameter_list|,
name|HOST_WIDE_INT
name|max_address
parameter_list|)
block|{
name|HOST_WIDE_INT
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|barrier
decl_stmt|;
name|rtx
name|from
init|=
name|fix
operator|->
name|insn
decl_stmt|;
comment|/* The instruction after which we will insert the jump.  */
name|rtx
name|selected
init|=
name|NULL
decl_stmt|;
name|int
name|selected_cost
decl_stmt|;
comment|/* The address at which the jump instruction will be placed.  */
name|HOST_WIDE_INT
name|selected_address
decl_stmt|;
name|Mfix
modifier|*
name|new_fix
decl_stmt|;
name|HOST_WIDE_INT
name|max_count
init|=
name|max_address
operator|-
name|fix
operator|->
name|address
decl_stmt|;
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|selected_cost
operator|=
name|arm_barrier_cost
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|selected_address
operator|=
name|fix
operator|->
name|address
expr_stmt|;
while|while
condition|(
name|from
operator|&&
name|count
operator|<
name|max_count
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
name|int
name|new_cost
decl_stmt|;
comment|/* This code shouldn't have been called if there was a natural barrier 	 within range.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|from
argument_list|)
operator|!=
name|BARRIER
argument_list|)
expr_stmt|;
comment|/* Count the length of this insn.  */
name|count
operator|+=
name|get_attr_length
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* If there is a jump table, add its length.  */
name|tmp
operator|=
name|is_jump_table
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|count
operator|+=
name|get_jump_table_size
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* Jump tables aren't in a basic block, so base the cost on 	     the dispatch insn.  If we select this location, we will 	     still put the pool after the table.  */
name|new_cost
operator|=
name|arm_barrier_cost
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|max_count
operator|&&
operator|(
operator|!
name|selected
operator|||
name|new_cost
operator|<=
name|selected_cost
operator|)
condition|)
block|{
name|selected
operator|=
name|tmp
expr_stmt|;
name|selected_cost
operator|=
name|new_cost
expr_stmt|;
name|selected_address
operator|=
name|fix
operator|->
name|address
operator|+
name|count
expr_stmt|;
block|}
comment|/* Continue after the dispatch table.  */
name|from
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|new_cost
operator|=
name|arm_barrier_cost
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|max_count
operator|&&
operator|(
operator|!
name|selected
operator|||
name|new_cost
operator|<=
name|selected_cost
operator|)
condition|)
block|{
name|selected
operator|=
name|from
expr_stmt|;
name|selected_cost
operator|=
name|new_cost
expr_stmt|;
name|selected_address
operator|=
name|fix
operator|->
name|address
operator|+
name|count
expr_stmt|;
block|}
name|from
operator|=
name|NEXT_INSN
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that we found a place to insert the jump.  */
name|gcc_assert
argument_list|(
name|selected
argument_list|)
expr_stmt|;
comment|/* Create a new JUMP_INSN that branches around a barrier.  */
name|from
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|label
argument_list|)
argument_list|,
name|selected
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|from
argument_list|)
operator|=
name|label
expr_stmt|;
name|barrier
operator|=
name|emit_barrier_after
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|emit_label_after
argument_list|(
name|label
argument_list|,
name|barrier
argument_list|)
expr_stmt|;
comment|/* Create a minipool barrier entry for the new barrier.  */
name|new_fix
operator|=
operator|(
name|Mfix
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_fix
argument_list|)
argument_list|)
expr_stmt|;
name|new_fix
operator|->
name|insn
operator|=
name|barrier
expr_stmt|;
name|new_fix
operator|->
name|address
operator|=
name|selected_address
expr_stmt|;
name|new_fix
operator|->
name|next
operator|=
name|fix
operator|->
name|next
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|new_fix
expr_stmt|;
return|return
name|new_fix
return|;
block|}
end_function

begin_comment
comment|/* Record that there is a natural barrier in the insn stream at    ADDRESS.  */
end_comment

begin_function
specifier|static
name|void
name|push_minipool_barrier
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|HOST_WIDE_INT
name|address
parameter_list|)
block|{
name|Mfix
modifier|*
name|fix
init|=
operator|(
name|Mfix
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fix
argument_list|)
argument_list|)
decl_stmt|;
name|fix
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|fix
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|fix
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|minipool_fix_head
operator|!=
name|NULL
condition|)
name|minipool_fix_tail
operator|->
name|next
operator|=
name|fix
expr_stmt|;
else|else
name|minipool_fix_head
operator|=
name|fix
expr_stmt|;
name|minipool_fix_tail
operator|=
name|fix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record INSN, which will need fixing up to load a value from the    minipool.  ADDRESS is the offset of the insn since the start of the    function; LOC is a pointer to the part of the insn which requires    fixing; VALUE is the constant that must be loaded, which is of type    MODE.  */
end_comment

begin_function
specifier|static
name|void
name|push_minipool_fix
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|HOST_WIDE_INT
name|address
parameter_list|,
name|rtx
modifier|*
name|loc
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|value
parameter_list|)
block|{
name|Mfix
modifier|*
name|fix
init|=
operator|(
name|Mfix
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fix
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
comment|/* PIC symbol references need to be converted into offsets into the      based area.  */
comment|/* XXX This shouldn't be done here.  */
if|if
condition|(
name|flag_pic
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|value
operator|=
name|aof_pic_entry
argument_list|(
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AOF_ASSEMBLER */
name|fix
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|fix
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|fix
operator|->
name|loc
operator|=
name|loc
expr_stmt|;
name|fix
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|fix
operator|->
name|fix_size
operator|=
name|MINIPOOL_FIX_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|fix
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|fix
operator|->
name|forwards
operator|=
name|get_attr_pool_range
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fix
operator|->
name|backwards
operator|=
name|get_attr_neg_pool_range
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|fix
operator|->
name|minipool
operator|=
name|NULL
expr_stmt|;
comment|/* If an insn doesn't have a range defined for it, then it isn't      expecting to be reworked by this code.  Better to stop now than      to generate duff assembly code.  */
name|gcc_assert
argument_list|(
name|fix
operator|->
name|forwards
operator|||
name|fix
operator|->
name|backwards
argument_list|)
expr_stmt|;
comment|/* If an entry requires 8-byte alignment then assume all constant pools      require 4 bytes of padding.  Trying to do this later on a per-pool      basis is awkward because existing pool entries have to be modified.  */
if|if
condition|(
name|ARM_DOUBLEWORD_ALIGN
operator|&&
name|fix
operator|->
name|fix_size
operator|==
literal|8
condition|)
name|minipool_pad
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; %smode fixup for i%d; addr %lu, range (%ld,%ld): "
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|mode
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|address
argument_list|,
operator|-
literal|1
operator|*
operator|(
name|long
operator|)
name|fix
operator|->
name|backwards
argument_list|,
operator|(
name|long
operator|)
name|fix
operator|->
name|forwards
argument_list|)
expr_stmt|;
name|arm_print_value
argument_list|(
name|dump_file
argument_list|,
name|fix
operator|->
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Add it to the chain of fixes.  */
name|fix
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|minipool_fix_head
operator|!=
name|NULL
condition|)
name|minipool_fix_tail
operator|->
name|next
operator|=
name|fix
expr_stmt|;
else|else
name|minipool_fix_head
operator|=
name|fix
expr_stmt|;
name|minipool_fix_tail
operator|=
name|fix
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the cost of synthesizing a 64-bit constant VAL inline.    Returns the number of insns needed, or 99 if we don't know how to    do it.  */
end_comment

begin_function
name|int
name|arm_const_double_inline_cost
parameter_list|(
name|rtx
name|val
parameter_list|)
block|{
name|rtx
name|lowpart
decl_stmt|,
name|highpart
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|DImode
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|8
argument_list|)
expr_stmt|;
name|lowpart
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|highpart
operator|=
name|gen_highpart_mode
argument_list|(
name|SImode
argument_list|,
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|lowpart
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|highpart
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
return|return
operator|(
name|arm_gen_constant
argument_list|(
name|SET
argument_list|,
name|SImode
argument_list|,
name|NULL_RTX
argument_list|,
name|INTVAL
argument_list|(
name|lowpart
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|+
name|arm_gen_constant
argument_list|(
name|SET
argument_list|,
name|SImode
argument_list|,
name|NULL_RTX
argument_list|,
name|INTVAL
argument_list|(
name|highpart
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if it is worthwhile to split a 64-bit constant into two    32-bit operations.  This is the case if optimizing for size, or    if we have load delay slots, or if one 32-bit part can be done with    a single data operation.  */
end_comment

begin_function
name|bool
name|arm_const_double_by_parts
parameter_list|(
name|rtx
name|val
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|rtx
name|part
decl_stmt|;
if|if
condition|(
name|optimize_size
operator|||
name|arm_ld_sched
condition|)
return|return
name|true
return|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|DImode
expr_stmt|;
name|part
operator|=
name|gen_highpart_mode
argument_list|(
name|SImode
argument_list|,
name|mode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|part
argument_list|)
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|part
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|part
operator|=
name|gen_lowpart
argument_list|(
name|SImode
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|part
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|part
argument_list|)
argument_list|)
operator|||
name|const_ok_for_arm
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|part
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Scan INSN and note any of its operands that need fixing.    If DO_PUSHES is false we do not actually push any of the fixups    needed.  The function returns TRUE if any fixups were needed/pushed.    This is used by arm_memory_load_p() which needs to know about loads    of constants that will be converted into minipool loads.  */
end_comment

begin_function
specifier|static
name|bool
name|note_invalid_constants
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|HOST_WIDE_INT
name|address
parameter_list|,
name|int
name|do_pushes
parameter_list|)
block|{
name|bool
name|result
init|=
name|false
decl_stmt|;
name|int
name|opno
decl_stmt|;
name|extract_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constrain_operands
argument_list|(
literal|1
argument_list|)
condition|)
name|fatal_insn_not_found
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog_data
operator|.
name|n_alternatives
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* Fill in recog_op_alt with information about the constraints of      this insn.  */
name|preprocess_constraints
argument_list|()
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|opno
operator|<
name|recog_data
operator|.
name|n_operands
condition|;
name|opno
operator|++
control|)
block|{
comment|/* Things we need to fix can only occur in inputs.  */
if|if
condition|(
name|recog_data
operator|.
name|operand_type
index|[
name|opno
index|]
operator|!=
name|OP_IN
condition|)
continue|continue;
comment|/* If this alternative is a memory reference, then any mention 	 of constants in this alternative is really to fool reload 	 into allowing us to accept one there.  We need to fix them up 	 now so that we output the right code.  */
if|if
condition|(
name|recog_op_alt
index|[
name|opno
index|]
index|[
name|which_alternative
index|]
operator|.
name|memory_ok
condition|)
block|{
name|rtx
name|op
init|=
name|recog_data
operator|.
name|operand
index|[
name|opno
index|]
decl_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|op
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_pushes
condition|)
name|push_minipool_fix
argument_list|(
name|insn
argument_list|,
name|address
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|opno
index|]
argument_list|,
name|recog_data
operator|.
name|operand_mode
index|[
name|opno
index|]
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|result
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|do_pushes
condition|)
block|{
name|rtx
name|cop
init|=
name|avoid_constant_pool_reference
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* Casting the address of something to a mode narrower 		     than a word can cause avoid_constant_pool_reference() 		     to return the pool reference itself.  That's no good to 		     us here.  Lets just hope that we can use the 		     constant pool value directly.  */
if|if
condition|(
name|op
operator|==
name|cop
condition|)
name|cop
operator|=
name|get_pool_constant
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|push_minipool_fix
argument_list|(
name|insn
argument_list|,
name|address
argument_list|,
name|recog_data
operator|.
name|operand_loc
index|[
name|opno
index|]
argument_list|,
name|recog_data
operator|.
name|operand_mode
index|[
name|opno
index|]
argument_list|,
name|cop
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Gcc puts the pool in the wrong place for ARM, since we can only    load addresses a limited distance around the pc.  We do some    special munging to move the constant pool values to the correct    point in the code.  */
end_comment

begin_function
specifier|static
name|void
name|arm_reorg
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|HOST_WIDE_INT
name|address
init|=
literal|0
decl_stmt|;
name|Mfix
modifier|*
name|fix
decl_stmt|;
name|minipool_fix_head
operator|=
name|minipool_fix_tail
operator|=
name|NULL
expr_stmt|;
comment|/* The first insn must always be a note, or the code below won't      scan it properly.  */
name|insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
argument_list|)
expr_stmt|;
name|minipool_pad
operator|=
literal|0
expr_stmt|;
comment|/* Scan all the insns and record the operands that will need fixing.  */
for|for
control|(
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
init|;
name|insn
condition|;
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|TARGET_CIRRUS_FIX_INVALID_INSNS
operator|&&
operator|(
name|arm_cirrus_insn_p
argument_list|(
name|insn
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|arm_memory_load_p
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|cirrus_reorg
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|push_minipool_barrier
argument_list|(
name|insn
argument_list|,
name|address
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|table
decl_stmt|;
name|note_invalid_constants
argument_list|(
name|insn
argument_list|,
name|address
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|address
operator|+=
name|get_attr_length
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If the insn is a vector jump, add the size of the table 	     and skip the table.  */
if|if
condition|(
operator|(
name|table
operator|=
name|is_jump_table
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|address
operator|+=
name|get_jump_table_size
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|insn
operator|=
name|table
expr_stmt|;
block|}
block|}
block|}
name|fix
operator|=
name|minipool_fix_head
expr_stmt|;
comment|/* Now scan the fixups and perform the required changes.  */
while|while
condition|(
name|fix
condition|)
block|{
name|Mfix
modifier|*
name|ftmp
decl_stmt|;
name|Mfix
modifier|*
name|fdel
decl_stmt|;
name|Mfix
modifier|*
name|last_added_fix
decl_stmt|;
name|Mfix
modifier|*
name|last_barrier
init|=
name|NULL
decl_stmt|;
name|Mfix
modifier|*
name|this_fix
decl_stmt|;
comment|/* Skip any further barriers before the next fix.  */
while|while
condition|(
name|fix
operator|&&
name|GET_CODE
argument_list|(
name|fix
operator|->
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|fix
operator|=
name|fix
operator|->
name|next
expr_stmt|;
comment|/* No more fixes.  */
if|if
condition|(
name|fix
operator|==
name|NULL
condition|)
break|break;
name|last_added_fix
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ftmp
operator|=
name|fix
init|;
name|ftmp
condition|;
name|ftmp
operator|=
name|ftmp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ftmp
operator|->
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
if|if
condition|(
name|ftmp
operator|->
name|address
operator|>=
name|minipool_vector_head
operator|->
name|max_address
condition|)
break|break;
name|last_barrier
operator|=
name|ftmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ftmp
operator|->
name|minipool
operator|=
name|add_minipool_forward_ref
argument_list|(
name|ftmp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|last_added_fix
operator|=
name|ftmp
expr_stmt|;
comment|/* Keep track of the last fix added.  */
block|}
comment|/* If we found a barrier, drop back to that; any fixes that we 	 could have reached but come after the barrier will now go in 	 the next mini-pool.  */
if|if
condition|(
name|last_barrier
operator|!=
name|NULL
condition|)
block|{
comment|/* Reduce the refcount for those fixes that won't go into this 	     pool after all.  */
for|for
control|(
name|fdel
operator|=
name|last_barrier
operator|->
name|next
init|;
name|fdel
operator|&&
name|fdel
operator|!=
name|ftmp
condition|;
name|fdel
operator|=
name|fdel
operator|->
name|next
control|)
block|{
name|fdel
operator|->
name|minipool
operator|->
name|refcount
operator|--
expr_stmt|;
name|fdel
operator|->
name|minipool
operator|=
name|NULL
expr_stmt|;
block|}
name|ftmp
operator|=
name|last_barrier
expr_stmt|;
block|}
else|else
block|{
comment|/* ftmp is first fix that we can't fit into this pool and 	     there no natural barriers that we could use.  Insert a 	     new barrier in the code somewhere between the previous 	     fix and this one, and arrange to jump around it.  */
name|HOST_WIDE_INT
name|max_address
decl_stmt|;
comment|/* The last item on the list of fixes must be a barrier, so 	     we can never run off the end of the list of fixes without 	     last_barrier being set.  */
name|gcc_assert
argument_list|(
name|ftmp
argument_list|)
expr_stmt|;
name|max_address
operator|=
name|minipool_vector_head
operator|->
name|max_address
expr_stmt|;
comment|/* Check that there isn't another fix that is in range that 	     we couldn't fit into this pool because the pool was 	     already too large: we need to put the pool before such an 	     instruction.  The pool itself may come just after the 	     fix because create_fix_barrier also allows space for a 	     jump instruction.  */
if|if
condition|(
name|ftmp
operator|->
name|address
operator|<
name|max_address
condition|)
name|max_address
operator|=
name|ftmp
operator|->
name|address
operator|+
literal|1
expr_stmt|;
name|last_barrier
operator|=
name|create_fix_barrier
argument_list|(
name|last_added_fix
argument_list|,
name|max_address
argument_list|)
expr_stmt|;
block|}
name|assign_minipool_offsets
argument_list|(
name|last_barrier
argument_list|)
expr_stmt|;
while|while
condition|(
name|ftmp
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|ftmp
operator|->
name|insn
argument_list|)
operator|!=
name|BARRIER
operator|&&
operator|(
operator|(
name|ftmp
operator|->
name|minipool
operator|=
name|add_minipool_backward_ref
argument_list|(
name|ftmp
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
break|break;
name|ftmp
operator|=
name|ftmp
operator|->
name|next
expr_stmt|;
block|}
comment|/* Scan over the fixes we have identified for this pool, fixing them 	 up and adding the constants to the pool itself.  */
for|for
control|(
name|this_fix
operator|=
name|fix
init|;
name|this_fix
operator|&&
name|ftmp
operator|!=
name|this_fix
condition|;
name|this_fix
operator|=
name|this_fix
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|this_fix
operator|->
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
name|rtx
name|addr
init|=
name|plus_constant
argument_list|(
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|minipool_vector_label
argument_list|)
argument_list|,
name|this_fix
operator|->
name|minipool
operator|->
name|offset
argument_list|)
decl_stmt|;
operator|*
name|this_fix
operator|->
name|loc
operator|=
name|gen_rtx_MEM
argument_list|(
name|this_fix
operator|->
name|mode
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|dump_minipool
argument_list|(
name|last_barrier
operator|->
name|insn
argument_list|)
expr_stmt|;
name|fix
operator|=
name|ftmp
expr_stmt|;
block|}
comment|/* From now on we must synthesize any constants that we can't handle      directly.  This can happen if the RTL gets split during final      instruction generation.  */
name|after_arm_reorg
operator|=
literal|1
expr_stmt|;
comment|/* Free the minipool memory.  */
name|obstack_free
argument_list|(
operator|&
name|minipool_obstack
argument_list|,
name|minipool_startobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines to output assembly language.  */
end_comment

begin_comment
comment|/* If the rtx is the correct value then return the string of the number.    In this way we can ensure that valid double constants are generated even    when cross compiling.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|fp_immediate_constant
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fp_consts_inited
condition|)
name|init_fp_table
argument_list|()
expr_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|r
argument_list|,
name|values_fp
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|strings_fp
index|[
name|i
index|]
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As for fp_immediate_constant, but value is passed directly, not in rtx.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|fp_const_from_val
parameter_list|(
name|REAL_VALUE_TYPE
modifier|*
name|r
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fp_consts_inited
condition|)
name|init_fp_table
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
operator|*
name|r
argument_list|,
name|values_fp
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|strings_fp
index|[
name|i
index|]
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the operands of a LDM/STM instruction to STREAM.    MASK is the ARM register set mask of which only bits 0-15 are important.    REG is the base register, either the frame pointer or the stack pointer,    INSTR is the possibly suffixed load or store instruction.  */
end_comment

begin_function
specifier|static
name|void
name|print_multi_reg
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|instr
parameter_list|,
name|unsigned
name|reg
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|bool
name|not_first
init|=
name|FALSE
decl_stmt|;
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
name|instr
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|", {"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|not_first
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|not_first
operator|=
name|TRUE
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a FLDMX instruction to STREAM.    BASE if the register containing the address.    REG and COUNT specify the register range.    Extra registers may be added to avoid hardware bugs.  */
end_comment

begin_function
specifier|static
name|void
name|arm_output_fldmx
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|unsigned
name|int
name|base
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Workaround ARM10 VFPr1 bug.  */
if|if
condition|(
name|count
operator|==
literal|2
operator|&&
operator|!
name|arm_arch6
condition|)
block|{
if|if
condition|(
name|reg
operator|==
literal|15
condition|)
name|reg
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"fldmfdx\t%r!, {"
argument_list|,
name|base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|reg
init|;
name|i
operator|<
name|reg
operator|+
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
name|reg
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"d%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"}\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the assembly for a store multiple.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|vfp_output_fstmx
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|char
name|pattern
index|[
literal|100
index|]
decl_stmt|;
name|int
name|p
decl_stmt|;
name|int
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|strcpy
argument_list|(
name|pattern
argument_list|,
literal|"fstmfdx\t%m0!, {%P1"
argument_list|)
expr_stmt|;
name|p
operator|=
name|strlen
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|-
name|FIRST_VFP_REGNUM
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|+=
name|sprintf
argument_list|(
operator|&
name|pattern
index|[
name|p
index|]
argument_list|,
literal|", d%d"
argument_list|,
name|base
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
operator|&
name|pattern
index|[
name|p
index|]
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|pattern
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Emit RTL to save block of VFP register pairs to the stack.  Returns the    number of bytes pushed.  */
end_comment

begin_function
specifier|static
name|int
name|vfp_emit_fstmx
parameter_list|(
name|int
name|base_reg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|rtx
name|par
decl_stmt|;
name|rtx
name|dwarf
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Workaround ARM10 VFPr1 bug.  Data corruption can occur when exactly two      register pairs are stored by a store multiple insn.  We avoid this      by pushing an extra pair.  */
if|if
condition|(
name|count
operator|==
literal|2
operator|&&
operator|!
name|arm_arch6
condition|)
block|{
if|if
condition|(
name|base_reg
operator|==
name|LAST_VFP_REGNUM
operator|-
literal|3
condition|)
name|base_reg
operator|-=
literal|2
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* ??? The frame layout is implementation defined.  We describe      standard format 1 (equivalent to a FSTMD insn and unused pad word).      We really need some way of representing the whole block so that the      unwinder can figure it out at runtime.  */
name|par
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_SEQUENCE
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|base_reg
argument_list|)
expr_stmt|;
name|base_reg
operator|+=
literal|2
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_frame_mem
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|BLKmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
argument_list|,
name|UNSPEC_PUSH_MULT
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
operator|-
operator|(
name|count
operator|*
literal|8
operator|+
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_frame_mem
argument_list|(
name|DFmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|DFmode
argument_list|,
name|base_reg
argument_list|)
expr_stmt|;
name|base_reg
operator|+=
literal|2
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_frame_mem
argument_list|(
name|DFmode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|i
operator|*
literal|8
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
name|par
operator|=
name|emit_insn
argument_list|(
name|par
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|par
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|par
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|par
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|count
operator|*
literal|8
operator|+
literal|4
return|;
block|}
end_function

begin_comment
comment|/* Output a 'call' insn.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_call
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|arm_arch5
argument_list|)
expr_stmt|;
comment|/* Patterns should call blx<reg> directly.  */
comment|/* Handle calls to lr using ip (which may be clobbered in subr anyway).  */
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|LR_REGNUM
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%0, %|lr"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|lr, %|pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_INTERWORK
operator|||
name|arm_arch4t
condition|)
name|output_asm_insn
argument_list|(
literal|"bx%?\t%0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|pc, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a 'call' insn that is a reference in memory.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_call_mem
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
if|if
condition|(
name|TARGET_INTERWORK
operator|&&
operator|!
name|arm_arch5
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%|ip, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|lr, %|pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bx%?\t%|ip"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno_use_in
argument_list|(
name|LR_REGNUM
argument_list|,
name|operands
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* LR is used in the memory address.  We load the address in the 	 first instruction.  It's safe to use IP as the target of the 	 load since the call will kill it anyway.  */
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%|ip, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_arch5
condition|)
name|output_asm_insn
argument_list|(
literal|"blx%?\t%|ip"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|lr, %|pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_arch4t
condition|)
name|output_asm_insn
argument_list|(
literal|"bx%?\t%|ip"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|pc, %|ip"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"mov%?\t%|lr, %|pc"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%|pc, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from arm registers to an fpa registers.    OPERANDS[0] is an fpa register.    OPERANDS[1] is the first registers of an arm register pair.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_long_double_fpa_from_arm
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|arm_reg0
operator|!=
name|IP_REGNUM
argument_list|)
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stm%?fd\t%|sp!, {%0, %1, %2}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldf%?e\t%0, [%|sp], #12"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from an fpa register to arm registers.    OPERANDS[0] is the first registers of an arm register pair.    OPERANDS[1] is an fpa register.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_long_double_arm_from_fpa
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|3
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|arm_reg0
operator|!=
name|IP_REGNUM
argument_list|)
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|2
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|2
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stf%?e\t%1, [%|sp, #-12]!"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldm%?fd\t%|sp!, {%0, %1, %2}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from arm registers to arm registers of a long double    OPERANDS[0] is the destination.    OPERANDS[1] is the source.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_long_double_arm_from_arm
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
comment|/* We have to be careful here because the two might overlap.  */
name|int
name|dest_start
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|src_start
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dest_start
operator|<
name|src_start
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|dest_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|src_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%0, %1"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|dest_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|src_start
operator|+
name|i
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"mov%?\t%0, %1"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from arm registers to an fpa registers.    OPERANDS[0] is an fpa register.    OPERANDS[1] is the first registers of an arm register pair.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_double_fpa_from_arm
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|arm_reg0
operator|!=
name|IP_REGNUM
argument_list|)
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stm%?fd\t%|sp!, {%0, %1}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldf%?d\t%0, [%|sp], #8"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move from an fpa register to arm registers.    OPERANDS[0] is the first registers of an arm register pair.    OPERANDS[1] is an fpa register.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_mov_double_arm_from_fpa
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|int
name|arm_reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|arm_reg0
operator|!=
name|IP_REGNUM
argument_list|)
expr_stmt|;
name|ops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|arm_reg0
argument_list|)
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|arm_reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stf%?d\t%1, [%|sp, #-8]!"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldm%?fd\t%|sp!, {%0, %1}"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a move between double words.    It must be REG<-REG, REG<-CONST_DOUBLE, REG<-CONST_INT, REG<-MEM    or MEM<-REG and all MEMs must be offsettable addresses.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_move_double
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|enum
name|rtx_code
name|code0
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|rtx
name|otherops
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|code0
operator|==
name|REG
condition|)
block|{
name|int
name|reg0
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|otherops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|reg0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|code1
operator|==
name|MEM
argument_list|)
expr_stmt|;
comment|/* Constraints should ensure this.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?ia\t%m1, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
name|gcc_assert
argument_list|(
name|TARGET_LDRD
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?d\t%0, [%m1, #8]!"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_DEC
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?db\t%m1!, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?ia\t%m1!, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|gcc_assert
argument_list|(
name|TARGET_LDRD
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?d\t%0, [%m1], #-8"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
name|otherops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_MODIFY
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|otherops
index|[
literal|0
index|]
argument_list|,
name|otherops
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* Registers overlap so split out the increment.  */
name|output_asm_insn
argument_list|(
literal|"add%?\t%1, %1, %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?d\t%0, [%1] @split"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* IWMMXT allows offsets larger than ldrd can handle, 		     fix these up with a pair of ldr.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|<=
operator|-
literal|256
operator|||
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|>=
literal|256
operator|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, [%1, %2]!"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, [%1, #4]"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"ldr%?d\t%0, [%1, %2]!"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* IWMMXT allows offsets larger than ldrd can handle, 		 fix these up with a pair of ldr.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|<=
operator|-
literal|256
operator|||
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|>=
literal|256
operator|)
condition|)
block|{
name|otherops
index|[
literal|0
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|reg0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, [%1, #4]"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, [%1], %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We only allow constant increments, so this is safe.  */
name|output_asm_insn
argument_list|(
literal|"ldr%?d\t%0, [%1], %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
name|output_asm_insn
argument_list|(
literal|"adr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldm%?ia\t%0, %M0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|arm_add_operand
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|otherops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
case|case
operator|-
literal|8
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?db\t%1, %M0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
operator|-
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?da\t%1, %M0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"ldm%?ib\t%1, %M0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
if|if
condition|(
name|TARGET_LDRD
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|>
operator|-
literal|256
operator|&&
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|<
literal|256
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|otherops
index|[
literal|0
index|]
argument_list|,
name|otherops
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* Swap base and index registers over to 			     avoid a conflict.  */
name|otherops
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If both registers conflict, it will usually 			 have been fixed by a splitter.  */
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|otherops
index|[
literal|0
index|]
argument_list|,
name|otherops
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"add%?\t%1, %1, %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?d\t%0, [%1]"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"ldr%?d\t%0, [%1, %2]"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|const_ok_for_arm
argument_list|(
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
argument_list|)
operator|)
condition|)
name|output_asm_insn
argument_list|(
literal|"sub%?\t%0, %1, #%n2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"add%?\t%0, %1, %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"add%?\t%0, %1, %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
else|else
name|output_asm_insn
argument_list|(
literal|"sub%?\t%0, %1, %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|"ldm%?ia\t%0, %M0"
return|;
block|}
else|else
block|{
name|otherops
index|[
literal|1
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Take care of overlapping base/data reg.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* Constraints should ensure this.  */
name|gcc_assert
argument_list|(
name|code0
operator|==
name|MEM
operator|&&
name|code1
operator|==
name|REG
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|IP_REGNUM
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?ia\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_INC
case|:
name|gcc_assert
argument_list|(
name|TARGET_LDRD
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"str%?d\t%1, [%m0, #8]!"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_DEC
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?db\t%m0!, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_INC
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?ia\t%m0!, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|POST_DEC
case|:
name|gcc_assert
argument_list|(
name|TARGET_LDRD
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"str%?d\t%1, [%m0], #-8"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
name|otherops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* IWMMXT allows offsets larger than ldrd can handle, 	     fix these up with a pair of ldr.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|<=
operator|-
literal|256
operator|||
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|>=
literal|256
operator|)
condition|)
block|{
name|rtx
name|reg1
decl_stmt|;
name|reg1
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_MODIFY
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, [%1, %2]!"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|0
index|]
operator|=
name|reg1
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, [%1, #4]"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|otherops
index|[
literal|0
index|]
operator|=
name|reg1
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, [%1, #4]"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, [%1], %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_MODIFY
condition|)
name|output_asm_insn
argument_list|(
literal|"str%?d\t%0, [%1, %2]!"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
else|else
name|output_asm_insn
argument_list|(
literal|"str%?d\t%0, [%1], %2"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|otherops
index|[
literal|2
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
case|case
operator|-
literal|8
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?db\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
operator|-
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?da\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
case|case
literal|4
case|:
name|output_asm_insn
argument_list|(
literal|"stm%?ib\t%m0, %M1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
block|}
if|if
condition|(
name|TARGET_LDRD
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|>
operator|-
literal|256
operator|&&
name|INTVAL
argument_list|(
name|otherops
index|[
literal|2
index|]
argument_list|)
operator|<
literal|256
operator|)
operator|)
condition|)
block|{
name|otherops
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"str%?d\t%0, [%1, %2]"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
comment|/* Fall through */
default|default:
name|otherops
index|[
literal|0
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|otherops
index|[
literal|1
index|]
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|1
operator|+
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"str%?\t%1, %0"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"str%?\t%1, %0"
argument_list|,
name|otherops
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output an ADD r, s, #n where n may be too big for one instruction.    If adding zero to one register, output nothing.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_add_immediate
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|HOST_WIDE_INT
name|n
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
operator|||
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"sub%?\t%0, %1, %2"
argument_list|,
literal|"sub%?\t%0, %0, %2"
argument_list|,
literal|2
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
else|else
name|output_multi_immediate
argument_list|(
name|operands
argument_list|,
literal|"add%?\t%0, %1, %2"
argument_list|,
literal|"add%?\t%0, %0, %2"
argument_list|,
literal|2
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a multiple immediate operation.    OPERANDS is the vector of operands referred to in the output patterns.    INSTR1 is the output pattern to use for the first constant.    INSTR2 is the output pattern to use for subsequent constants.    IMMED_OP is the index of the constant slot in OPERANDS.    N is the constant value.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|output_multi_immediate
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|,
specifier|const
name|char
modifier|*
name|instr1
parameter_list|,
specifier|const
name|char
modifier|*
name|instr2
parameter_list|,
name|int
name|immed_op
parameter_list|,
name|HOST_WIDE_INT
name|n
parameter_list|)
block|{
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
literal|32
name|n
operator|&=
literal|0xffffffff
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* Quick and easy output.  */
name|operands
index|[
name|immed_op
index|]
operator|=
name|const0_rtx
expr_stmt|;
name|output_asm_insn
argument_list|(
name|instr1
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|instr
init|=
name|instr1
decl_stmt|;
comment|/* Note that n is never zero here (which would give no output).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|n
operator|&
operator|(
literal|3
operator|<<
name|i
operator|)
condition|)
block|{
name|operands
index|[
name|immed_op
index|]
operator|=
name|GEN_INT
argument_list|(
name|n
operator|&
operator|(
literal|255
operator|<<
name|i
operator|)
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|instr
operator|=
name|instr2
expr_stmt|;
name|i
operator|+=
literal|6
expr_stmt|;
block|}
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Return the appropriate ARM instruction for the operation code.    The returned result should not be overwritten.  OP is the rtx of the    operation.  SHIFT_FIRST_ARG is TRUE if the first argument of the operator    was shifted.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|arithmetic_instr
parameter_list|(
name|rtx
name|op
parameter_list|,
name|int
name|shift_first_arg
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|PLUS
case|:
return|return
literal|"add"
return|;
case|case
name|MINUS
case|:
return|return
name|shift_first_arg
condition|?
literal|"rsb"
else|:
literal|"sub"
return|;
case|case
name|IOR
case|:
return|return
literal|"orr"
return|;
case|case
name|XOR
case|:
return|return
literal|"eor"
return|;
case|case
name|AND
case|:
return|return
literal|"and"
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Ensure valid constant shifts and return the appropriate shift mnemonic    for the operation code.  The returned result should not be overwritten.    OP is the rtx code of the shift.    On exit, *AMOUNTP will be -1 if the shift is by a register, or a constant    shift.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|shift_op
parameter_list|(
name|rtx
name|op
parameter_list|,
name|HOST_WIDE_INT
modifier|*
name|amountp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|mnem
decl_stmt|;
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|op
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
operator|*
name|amountp
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
operator|*
name|amountp
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|ASHIFT
case|:
name|mnem
operator|=
literal|"asl"
expr_stmt|;
break|break;
case|case
name|ASHIFTRT
case|:
name|mnem
operator|=
literal|"asr"
expr_stmt|;
break|break;
case|case
name|LSHIFTRT
case|:
name|mnem
operator|=
literal|"lsr"
expr_stmt|;
break|break;
case|case
name|ROTATE
case|:
name|gcc_assert
argument_list|(
operator|*
name|amountp
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|amountp
operator|=
literal|32
operator|-
operator|*
name|amountp
expr_stmt|;
comment|/* Fall through.  */
case|case
name|ROTATERT
case|:
name|mnem
operator|=
literal|"ror"
expr_stmt|;
break|break;
case|case
name|MULT
case|:
comment|/* We never have to worry about the amount being other than a 	 power of 2, since this case can never be reloaded from a reg.  */
name|gcc_assert
argument_list|(
operator|*
name|amountp
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|amountp
operator|=
name|int_log2
argument_list|(
operator|*
name|amountp
argument_list|)
expr_stmt|;
return|return
literal|"asl"
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|amountp
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* This is not 100% correct, but follows from the desire to merge 	 multiplication by a power of 2 with the recognizer for a 	 shift.>=32 is not a valid shift for "asl", so we must try and 	 output a shift that produces the correct arithmetical result. 	 Using lsr #32 is identical except for the fact that the carry bit 	 is not set correctly if we set the flags; but we never use the 	 carry bit from such an operation, so we can ignore that.  */
if|if
condition|(
name|code
operator|==
name|ROTATERT
condition|)
comment|/* Rotate is just modulo 32.  */
operator|*
name|amountp
operator|&=
literal|31
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|amountp
operator|!=
operator|(
operator|*
name|amountp
operator|&
literal|31
operator|)
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|ASHIFT
condition|)
name|mnem
operator|=
literal|"lsr"
expr_stmt|;
operator|*
name|amountp
operator|=
literal|32
expr_stmt|;
block|}
comment|/* Shifts of 0 are no-ops.  */
if|if
condition|(
operator|*
name|amountp
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|mnem
return|;
block|}
end_function

begin_comment
comment|/* Obtain the shift from the POWER of two.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|int_log2
parameter_list|(
name|HOST_WIDE_INT
name|power
parameter_list|)
block|{
name|HOST_WIDE_INT
name|shift
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|shift
operator|)
operator|&
name|power
operator|)
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
name|shift
operator|<=
literal|31
argument_list|)
expr_stmt|;
name|shift
operator|++
expr_stmt|;
block|}
return|return
name|shift
return|;
block|}
end_function

begin_comment
comment|/* Output a .ascii pseudo-op, keeping track of lengths.  This is    because /bin/as is horribly restrictive.  The judgement about    whether or not each character is 'printable' (and can be output as    is) or not (and must be printed with an octal escape) must be made    with reference to the *host* character set -- the situation is    similar to that discussed in the comments above pp_c_char in    c-pretty-print.c.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ASCII_LEN
value|51
end_define

begin_function
name|void
name|output_ascii_pseudo_op
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len_so_far
init|=
literal|0
decl_stmt|;
name|fputs
argument_list|(
literal|"\t.ascii\t\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|c
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|len_so_far
operator|>=
name|MAX_ASCII_LEN
condition|)
block|{
name|fputs
argument_list|(
literal|"\"\n\t.ascii\t\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ISPRINT
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
literal|'\"'
condition|)
block|{
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|++
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|len_so_far
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|len_so_far
operator|+=
literal|4
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"\"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the register save mask for registers 0 through 12    inclusive.  This code is used by arm_compute_save_reg_mask.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_compute_save_reg0_reg12_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|func_type
init|=
name|arm_current_func_type
argument_list|()
decl_stmt|;
name|unsigned
name|long
name|save_reg_mask
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|max_reg
decl_stmt|;
comment|/* Interrupt functions must not corrupt any registers, 	 even call clobbered ones.  If this is a leaf function 	 we can just examine the registers used by the RTL, but 	 otherwise we have to assume that whatever function is 	 called might clobber anything, and so we have to save 	 all the call-clobbered registers as well.  */
if|if
condition|(
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_FIQ
condition|)
comment|/* FIQ handlers have registers r8 - r12 banked, so 	   we only need to check r0 - r7, Normal ISRs only 	   bank r14 and r15, so we must check up to r12. 	   r13 is the stack pointer which is always preserved, 	   so we do not need to consider it here.  */
name|max_reg
operator|=
literal|7
expr_stmt|;
else|else
name|max_reg
operator|=
literal|12
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
name|max_reg
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|||
operator|(
operator|!
name|current_function_is_leaf
operator|&&
name|call_used_regs
index|[
name|reg
index|]
operator|)
condition|)
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
comment|/* Also save the pic base register if necessary.  */
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|TARGET_SINGLE_PIC_BASE
operator|&&
name|arm_pic_register
operator|!=
name|INVALID_REGNUM
operator|&&
name|current_function_uses_pic_offset_table
condition|)
name|save_reg_mask
operator||=
literal|1
operator|<<
name|PIC_OFFSET_TABLE_REGNUM
expr_stmt|;
block|}
else|else
block|{
comment|/* In the normal case we only need to save those registers 	 which are call saved and which are used by this function.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
literal|10
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
comment|/* Handle the frame pointer as a special case.  */
if|if
condition|(
operator|!
name|TARGET_APCS_FRAME
operator|&&
operator|!
name|frame_pointer_needed
operator|&&
name|regs_ever_live
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|HARD_FRAME_POINTER_REGNUM
index|]
condition|)
name|save_reg_mask
operator||=
literal|1
operator|<<
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
comment|/* If we aren't loading the PIC register, 	 don't stack it even though it may be live.  */
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|TARGET_SINGLE_PIC_BASE
operator|&&
name|arm_pic_register
operator|!=
name|INVALID_REGNUM
operator|&&
operator|(
name|regs_ever_live
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
operator|||
name|current_function_uses_pic_offset_table
operator|)
condition|)
name|save_reg_mask
operator||=
literal|1
operator|<<
name|PIC_OFFSET_TABLE_REGNUM
expr_stmt|;
block|}
comment|/* Save registers so the exception handler can modify them.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|save_reg_mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
block|}
block|}
return|return
name|save_reg_mask
return|;
block|}
end_function

begin_comment
comment|/* Compute a bit mask of which registers need to be    saved on the stack for the current function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|arm_compute_save_reg_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|save_reg_mask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|func_type
init|=
name|arm_current_func_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
comment|/* This should never really happen.  */
return|return
literal|0
return|;
comment|/* If we are creating a stack frame, then we must save the frame pointer,      IP (which will hold the old stack pointer), LR and the PC.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
name|ARM_HARD_FRAME_POINTER_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
expr_stmt|;
comment|/* Volatile functions do not return, so there      is no need to save any other registers.  */
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
return|return
name|save_reg_mask
return|;
name|save_reg_mask
operator||=
name|arm_compute_save_reg0_reg12_mask
argument_list|()
expr_stmt|;
comment|/* Decide if we need to save the link register.      Interrupt routines have their own banked link register,      so they never need to save it.      Otherwise if we do not use the link register we do not need to save      it.  If we are pushing other registers onto the stack however, we      can save an instruction in the epilogue by pushing the link register      now and then popping it back into the PC.  This incurs extra memory      accesses though, so we only do it when optimizing for size, and only      if we know that we will not need a fancy return sequence.  */
if|if
condition|(
name|regs_ever_live
index|[
name|LR_REGNUM
index|]
operator|||
operator|(
name|save_reg_mask
operator|&&
name|optimize_size
operator|&&
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_NORMAL
operator|&&
operator|!
name|current_function_calls_eh_return
operator|)
condition|)
name|save_reg_mask
operator||=
literal|1
operator|<<
name|LR_REGNUM
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
condition|)
name|save_reg_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_REALLY_IWMMXT
operator|&&
operator|(
operator|(
name|bit_count
argument_list|(
name|save_reg_mask
argument_list|)
operator|+
name|ARM_NUM_INTS
argument_list|(
name|current_function_pretend_args_size
argument_list|)
operator|)
operator|%
literal|2
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
comment|/* The total number of registers that are going to be pushed 	 onto the stack is odd.  We need to ensure that the stack 	 is 64-bit aligned before we start to save iWMMXt registers, 	 and also before we start to create locals.  (A local variable 	 might be a double or long long which we will load/store using 	 an iWMMXt instruction).  Therefore we need to push another 	 ARM register, so that the stack will be 64-bit aligned.  We 	 try to avoid using the arg registers (r0 -r3) as they might be 	 used to pass values in a tail call.  */
for|for
control|(
name|reg
operator|=
literal|4
init|;
name|reg
operator|<=
literal|12
condition|;
name|reg
operator|++
control|)
if|if
condition|(
operator|(
name|save_reg_mask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|reg
operator|<=
literal|12
condition|)
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
name|reg
operator|)
expr_stmt|;
else|else
block|{
name|cfun
operator|->
name|machine
operator|->
name|sibcall_blocked
operator|=
literal|1
expr_stmt|;
name|save_reg_mask
operator||=
operator|(
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
block|}
return|return
name|save_reg_mask
return|;
block|}
end_function

begin_comment
comment|/* Compute a bit mask of which registers need to be    saved on the stack for the current function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|thumb_compute_save_reg_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|12
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
if|if
condition|(
name|flag_pic
operator|&&
operator|!
name|TARGET_SINGLE_PIC_BASE
operator|&&
name|arm_pic_register
operator|!=
name|INVALID_REGNUM
operator|&&
name|current_function_uses_pic_offset_table
condition|)
name|mask
operator||=
literal|1
operator|<<
name|PIC_OFFSET_TABLE_REGNUM
expr_stmt|;
comment|/* See if we might need r11 for calls to _interwork_r11_call_via_rN().  */
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|&&
name|CALLER_INTERWORKING_SLOT_SIZE
operator|>
literal|0
condition|)
name|mask
operator||=
literal|1
operator|<<
name|ARM_HARD_FRAME_POINTER_REGNUM
expr_stmt|;
comment|/* LR will also be pushed if any lo regs are pushed.  */
if|if
condition|(
name|mask
operator|&
literal|0xff
operator|||
name|thumb_force_lr_save
argument_list|()
condition|)
name|mask
operator||=
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
comment|/* Make sure we have a low work register if we need one.      We will need one if we are going to push a high register,      but we are not currently intending to push a low register.  */
if|if
condition|(
operator|(
name|mask
operator|&
literal|0xff
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|mask
operator|&
literal|0x0f00
operator|)
operator|||
name|TARGET_BACKTRACE
operator|)
condition|)
block|{
comment|/* Use thumb_find_work_register to choose which register 	 we will use.  If the register is live then we will 	 have to push it.  Use LAST_LO_REGNUM as our fallback 	 choice for the register to select.  */
name|reg
operator|=
name|thumb_find_work_register
argument_list|(
literal|1
operator|<<
name|LAST_LO_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
block|}
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes required to save VFP registers.  */
end_comment

begin_function
specifier|static
name|int
name|arm_get_vfp_saved_size
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|saved
decl_stmt|;
name|saved
operator|=
literal|0
expr_stmt|;
comment|/* Space for saved VFP registers.  */
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_VFP
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|FIRST_VFP_REGNUM
init|;
name|regno
operator|<
name|LAST_VFP_REGNUM
condition|;
name|regno
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|regs_ever_live
index|[
name|regno
index|]
operator|||
name|call_used_regs
index|[
name|regno
index|]
operator|)
operator|&&
operator|(
operator|!
name|regs_ever_live
index|[
name|regno
operator|+
literal|1
index|]
operator|||
name|call_used_regs
index|[
name|regno
operator|+
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* Workaround ARM10 VFPr1 bug.  */
if|if
condition|(
name|count
operator|==
literal|2
operator|&&
operator|!
name|arm_arch6
condition|)
name|count
operator|++
expr_stmt|;
name|saved
operator|+=
name|count
operator|*
literal|8
operator|+
literal|4
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|2
operator|&&
operator|!
name|arm_arch6
condition|)
name|count
operator|++
expr_stmt|;
name|saved
operator|+=
name|count
operator|*
literal|8
operator|+
literal|4
expr_stmt|;
block|}
block|}
return|return
name|saved
return|;
block|}
end_function

begin_comment
comment|/* Generate a function exit sequence.  If REALLY_RETURN is false, then do    everything bar the final return instruction.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|output_return_instruction
parameter_list|(
name|rtx
name|operand
parameter_list|,
name|int
name|really_return
parameter_list|,
name|int
name|reverse
parameter_list|)
block|{
name|char
name|conditional
index|[
literal|10
index|]
decl_stmt|;
name|char
name|instr
index|[
literal|100
index|]
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|unsigned
name|long
name|live_regs_mask
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
operator|&&
name|TARGET_ABORT_NORETURN
condition|)
block|{
comment|/* If this function was declared non-returning, and we have 	 found a tail call, then we have to trust that the called 	 function won't return.  */
if|if
condition|(
name|really_return
condition|)
block|{
name|rtx
name|ops
index|[
literal|2
index|]
decl_stmt|;
comment|/* Otherwise, trap an attempted return by aborting.  */
name|ops
index|[
literal|0
index|]
operator|=
name|operand
expr_stmt|;
name|ops
index|[
literal|1
index|]
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|NEED_PLT_RELOC
condition|?
literal|"abort(PLT)"
else|:
literal|"abort"
argument_list|)
expr_stmt|;
name|assemble_external_libcall
argument_list|(
name|ops
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
name|reverse
condition|?
literal|"bl%D0\t%a1"
else|:
literal|"bl%d0\t%a1"
argument_list|,
name|ops
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
name|gcc_assert
argument_list|(
operator|!
name|current_function_calls_alloca
operator|||
name|really_return
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|conditional
argument_list|,
literal|"%%?%%%c0"
argument_list|,
name|reverse
condition|?
literal|'D'
else|:
literal|'d'
argument_list|)
expr_stmt|;
name|return_used_this_function
operator|=
literal|1
expr_stmt|;
name|live_regs_mask
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
if|if
condition|(
name|live_regs_mask
condition|)
block|{
specifier|const
name|char
modifier|*
name|return_reg
decl_stmt|;
comment|/* If we do not have any special requirements for function exit 	 (e.g. interworking, or ISR) then we can load the return address 	 directly into the PC.  Otherwise we must load it into LR.  */
if|if
condition|(
name|really_return
operator|&&
operator|!
name|TARGET_INTERWORK
condition|)
name|return_reg
operator|=
name|reg_names
index|[
name|PC_REGNUM
index|]
expr_stmt|;
else|else
name|return_reg
operator|=
name|reg_names
index|[
name|LR_REGNUM
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
operator|)
operator|==
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
condition|)
block|{
comment|/* There are three possible reasons for the IP register 	     being saved.  1) a stack frame was created, in which case 	     IP contains the old stack pointer, or 2) an ISR routine 	     corrupted it, or 3) it was saved to align the stack on 	     iWMMXt.  In case 1, restore IP into SP, otherwise just 	     restore IP.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|live_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
expr_stmt|;
name|live_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
expr_stmt|;
block|}
else|else
name|gcc_assert
argument_list|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
operator|||
name|TARGET_REALLY_IWMMXT
argument_list|)
expr_stmt|;
block|}
comment|/* On some ARM architectures it is faster to use LDR rather than 	 LDM to load a single register.  On other architectures, the 	 cost is the same.  In 26 bit mode, or for exception handlers, 	 we have to use LDM to load the PC so that the CPSR is also 	 restored.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|live_regs_mask
operator|==
operator|(
literal|1U
operator|<<
name|reg
operator|)
condition|)
break|break;
if|if
condition|(
name|reg
operator|<=
name|LAST_ARM_REGNUM
operator|&&
operator|(
name|reg
operator|!=
name|LR_REGNUM
operator|||
operator|!
name|really_return
operator|||
operator|!
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldr%s\t%%|%s, [%%|sp], #4"
argument_list|,
name|conditional
argument_list|,
operator|(
name|reg
operator|==
name|LR_REGNUM
operator|)
condition|?
name|return_reg
else|:
name|reg_names
index|[
name|reg
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* Generate the load multiple instruction to restore the 	     registers.  Note we can get here, even if 	     frame_pointer_needed is true, but only if sp already 	     points to the base of the saved core registers.  */
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|stack_adjust
decl_stmt|;
name|offsets
operator|=
name|arm_get_frame_offsets
argument_list|()
expr_stmt|;
name|stack_adjust
operator|=
name|offsets
operator|->
name|outgoing_args
operator|-
name|offsets
operator|->
name|saved_regs
expr_stmt|;
name|gcc_assert
argument_list|(
name|stack_adjust
operator|==
literal|0
operator|||
name|stack_adjust
operator|==
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack_adjust
operator|&&
name|arm_arch5
condition|)
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldm%sib\t%%|sp, {"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If we can't use ldmib (SA110 bug), 		     then try to pop r3 instead.  */
if|if
condition|(
name|stack_adjust
condition|)
name|live_regs_mask
operator||=
literal|1
operator|<<
literal|3
expr_stmt|;
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldm%sfd\t%%|sp, {"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"ldm%sfd\t%%|sp!, {"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
name|p
operator|=
name|instr
operator|+
name|strlen
argument_list|(
name|instr
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
name|SP_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
condition|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|reg_names
index|[
name|reg
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
literal|", "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
argument_list|,
literal|"%|"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|+
literal|2
argument_list|,
name|reg_names
index|[
name|reg
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p
operator|+=
name|l
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s%%|%s}"
argument_list|,
name|first
condition|?
literal|""
else|:
literal|", "
argument_list|,
name|return_reg
argument_list|)
expr_stmt|;
comment|/* If returning from an interrupt, restore the CPSR.  */
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
name|strcat
argument_list|(
name|p
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
operator|&
name|operand
argument_list|)
expr_stmt|;
comment|/* See if we need to generate an extra instruction to 	 perform the actual function return.  */
if|if
condition|(
name|really_return
operator|&&
name|func_type
operator|!=
name|ARM_FT_INTERWORKED
operator|&&
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* The return has already been handled 	     by loading the LR into the PC.  */
name|really_return
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|really_return
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
case|case
name|ARM_FT_ISR
case|:
case|case
name|ARM_FT_FIQ
case|:
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"sub%ss\t%%|pc, %%|lr, #4"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_INTERWORKED
case|:
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"bx%s\t%%|lr"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION
case|:
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"mov%ss\t%%|pc, %%|lr"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Use bx if it's available.  */
if|if
condition|(
name|arm_arch5
operator|||
name|arm_arch4t
condition|)
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"bx%s\t%%|lr"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|instr
argument_list|,
literal|"mov%s\t%%|pc, %%|lr"
argument_list|,
name|conditional
argument_list|)
expr_stmt|;
break|break;
block|}
name|output_asm_insn
argument_list|(
name|instr
argument_list|,
operator|&
name|operand
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Write the function name into the code section, directly preceding    the function prologue.     Code will be output similar to this:      t0 	 .ascii "arm_poke_function_name", 0 	 .align      t1 	 .word 0xff000000 + (t1 - t0)      arm_poke_function_name 	 mov     ip, sp 	 stmfd   sp!, {fp, ip, lr, pc} 	 sub     fp, ip, #4     When performing a stack backtrace, code can inspect the value    of 'pc' stored at 'fp' + 0.  If the trace function then looks    at location pc - 12 and the top 8 bits are set, then we know    that there is a function name embedded immediately preceding this    location and has length ((pc[-3])& 0xff000000).     We assume that pc is declared as a pointer to an unsigned long.     It is of no benefit to output the function name if we are assembling    a leaf function.  These function types will not contain a stack    backtrace structure, therefore it is not possible to determine the    function name.  */
end_comment

begin_function
name|void
name|arm_poke_function_name
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|long
name|alignlength
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|alignlength
operator|=
name|ROUND_UP_WORD
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ASCII
argument_list|(
name|stream
argument_list|,
name|name
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|stream
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|x
operator|=
name|GEN_INT
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0xff000000
operator|+
name|alignlength
argument_list|)
expr_stmt|;
name|assemble_aligned_integer
argument_list|(
name|UNITS_PER_WORD
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Place some comments into the assembler stream    describing the current function.  */
end_comment

begin_function
specifier|static
name|void
name|arm_output_function_prologue
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|HOST_WIDE_INT
name|frame_size
parameter_list|)
block|{
name|unsigned
name|long
name|func_type
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_ARM
condition|)
block|{
name|thumb_output_function_prologue
argument_list|(
name|f
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Sanity check.  */
name|gcc_assert
argument_list|(
operator|!
name|arm_ccfsm_state
operator|&&
operator|!
name|arm_target_insn
argument_list|)
expr_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
default|default:
case|case
name|ARM_FT_NORMAL
case|:
break|break;
case|case
name|ARM_FT_INTERWORKED
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Function supports interworking.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_ISR
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Interrupt Service Routine.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_FIQ
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Fast Interrupt Service Routine.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ ARM Exception Handler.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Naked Function: prologue and epilogue provided by programmer.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Volatile: function does not return.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_NESTED
argument_list|(
name|func_type
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ Nested: function declared inside another function.\n"
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ args = %d, pretend = %d, frame = %wd\n"
argument_list|,
name|current_function_args_size
argument_list|,
name|current_function_pretend_args_size
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ frame_needed = %d, uses_anonymous_args = %d\n"
argument_list|,
name|frame_pointer_needed
argument_list|,
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%@ link register save eliminated.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_calls_eh_return
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t@ Calls __builtin_eh_return.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
if|if
condition|(
name|flag_pic
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|return_used_this_function
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|arm_output_epilogue
parameter_list|(
name|rtx
name|sibling
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|unsigned
name|long
name|saved_regs_mask
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
comment|/* Floats_offset is the offset from the "virtual" frame.  In an APCS      frame that is $fp + 4 for a non-variadic function.  */
name|int
name|floats_offset
init|=
literal|0
decl_stmt|;
name|rtx
name|operands
index|[
literal|3
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
init|=
name|asm_out_file
decl_stmt|;
name|unsigned
name|int
name|lrm_count
init|=
literal|0
decl_stmt|;
name|int
name|really_return
init|=
operator|(
name|sibling
operator|==
name|NULL
operator|)
decl_stmt|;
name|int
name|start_reg
decl_stmt|;
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
comment|/* If we have already generated the return instruction      then it is futile to generate anything else.  */
if|if
condition|(
name|use_return_insn
argument_list|(
name|FALSE
argument_list|,
name|sibling
argument_list|)
operator|&&
name|return_used_this_function
condition|)
return|return
literal|""
return|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
comment|/* Naked functions don't have epilogues.  */
return|return
literal|""
return|;
if|if
condition|(
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
operator|&&
name|TARGET_ABORT_NORETURN
condition|)
block|{
name|rtx
name|op
decl_stmt|;
comment|/* A volatile function should never return.  Call abort.  */
name|op
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|NEED_PLT_RELOC
condition|?
literal|"abort(PLT)"
else|:
literal|"abort"
argument_list|)
expr_stmt|;
name|assemble_external_libcall
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"bl\t%a0"
argument_list|,
operator|&
name|op
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
comment|/* If we are throwing an exception, then we really must be doing a      return, so we can't tail-call.  */
name|gcc_assert
argument_list|(
operator|!
name|current_function_calls_eh_return
operator|||
name|really_return
argument_list|)
expr_stmt|;
name|offsets
operator|=
name|arm_get_frame_offsets
argument_list|()
expr_stmt|;
name|saved_regs_mask
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_IWMMXT
condition|)
name|lrm_count
operator|=
name|bit_count
argument_list|(
name|saved_regs_mask
argument_list|)
expr_stmt|;
name|floats_offset
operator|=
name|offsets
operator|->
name|saved_args
expr_stmt|;
comment|/* Compute how far away the floats will be.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|reg
operator|)
condition|)
name|floats_offset
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
comment|/* This variable is for the Virtual Frame Pointer, not VFP regs.  */
name|int
name|vfp_offset
init|=
name|offsets
operator|->
name|frame
decl_stmt|;
if|if
condition|(
name|arm_fpu_arch
operator|==
name|FPUTYPE_FPA_EMU2
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|LAST_FPA_REGNUM
init|;
name|reg
operator|>=
name|FIRST_FPA_REGNUM
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|floats_offset
operator|+=
literal|12
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tldfe\t%r, [%r, #-%d]\n"
argument_list|,
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
operator|-
name|vfp_offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|start_reg
operator|=
name|LAST_FPA_REGNUM
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|LAST_FPA_REGNUM
init|;
name|reg
operator|>=
name|FIRST_FPA_REGNUM
condition|;
name|reg
operator|--
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|floats_offset
operator|+=
literal|12
expr_stmt|;
comment|/* We can't unstack more than four registers at once.  */
if|if
condition|(
name|start_reg
operator|-
name|reg
operator|==
literal|3
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfm\t%r, 4, [%r, #-%d]\n"
argument_list|,
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
operator|-
name|vfp_offset
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfm\t%r, %d, [%r, #-%d]\n"
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
operator|-
name|vfp_offset
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Just in case the last register checked also needs unstacking.  */
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfm\t%r, %d, [%r, #-%d]\n"
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
operator|-
name|vfp_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_VFP
condition|)
block|{
name|int
name|saved_size
decl_stmt|;
comment|/* The fldmx insn does not have base+offset addressing modes, 	     so we use IP to hold the address.  */
name|saved_size
operator|=
name|arm_get_vfp_saved_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|saved_size
operator|>
literal|0
condition|)
block|{
name|floats_offset
operator|+=
name|saved_size
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsub\t%r, %r, #%d\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|FP_REGNUM
argument_list|,
name|floats_offset
operator|-
name|vfp_offset
argument_list|)
expr_stmt|;
block|}
name|start_reg
operator|=
name|FIRST_VFP_REGNUM
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|FIRST_VFP_REGNUM
init|;
name|reg
operator|<
name|LAST_VFP_REGNUM
condition|;
name|reg
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|regs_ever_live
index|[
name|reg
index|]
operator|||
name|call_used_regs
index|[
name|reg
index|]
operator|)
operator|&&
operator|(
operator|!
name|regs_ever_live
index|[
name|reg
operator|+
literal|1
index|]
operator|||
name|call_used_regs
index|[
name|reg
operator|+
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
name|arm_output_fldmx
argument_list|(
name|f
argument_list|,
name|IP_REGNUM
argument_list|,
operator|(
name|start_reg
operator|-
name|FIRST_VFP_REGNUM
operator|)
operator|/
literal|2
argument_list|,
operator|(
name|reg
operator|-
name|start_reg
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|+
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
name|arm_output_fldmx
argument_list|(
name|f
argument_list|,
name|IP_REGNUM
argument_list|,
operator|(
name|start_reg
operator|-
name|FIRST_VFP_REGNUM
operator|)
operator|/
literal|2
argument_list|,
operator|(
name|reg
operator|-
name|start_reg
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_IWMMXT
condition|)
block|{
comment|/* The frame pointer is guaranteed to be non-double-word aligned. 	     This is because it is set to (old_stack_pointer - 4) and the 	     old_stack_pointer was double word aligned.  Thus the offset to 	     the iWMMXt registers to be loaded must also be non-double-word 	     sized, so that the resultant address *is* double-word aligned. 	     We can ignore floats_offset since that was already included in 	     the live_regs_mask.  */
name|lrm_count
operator|+=
operator|(
name|lrm_count
operator|%
literal|2
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|LAST_IWMMXT_REGNUM
init|;
name|reg
operator|>=
name|FIRST_IWMMXT_REGNUM
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\twldrd\t%r, [%r, #-%d]\n"
argument_list|,
name|reg
argument_list|,
name|FP_REGNUM
argument_list|,
name|lrm_count
operator|*
literal|4
argument_list|)
expr_stmt|;
name|lrm_count
operator|+=
literal|2
expr_stmt|;
block|}
block|}
comment|/* saved_regs_mask should contain the IP, which at the time of stack 	 frame generation actually contains the old stack pointer.  So a 	 quick way to unwind the stack is just pop the IP register directly 	 into the stack pointer.  */
name|gcc_assert
argument_list|(
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
argument_list|)
expr_stmt|;
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|IP_REGNUM
operator|)
expr_stmt|;
name|saved_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
expr_stmt|;
comment|/* There are two registers left in saved_regs_mask - LR and PC.  We 	 only need to restore the LR register (the return address), but to 	 save time we can load it directly into the PC, unless we need a 	 special function exit sequence, or we are not really returning.  */
if|if
condition|(
name|really_return
operator|&&
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_NORMAL
operator|&&
operator|!
name|current_function_calls_eh_return
condition|)
comment|/* Delete the LR from the register mask, so that the LR on 	   the stack is loaded into the PC in the register mask.  */
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
else|else
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
expr_stmt|;
comment|/* We must use SP as the base register, because SP is one of the          registers being restored.  If an interrupt or page fault          happens in the ldm instruction, the SP might or might not          have been restored.  That would be bad, as then SP will no          longer indicate the safe area of stack, and we can get stack          corruption.  Using SP as the base register means that it will          be reset correctly to the original value, should an interrupt          occur.  If the stack pointer already points at the right          place, then omit the subtraction.  */
if|if
condition|(
name|offsets
operator|->
name|outgoing_args
operator|!=
operator|(
literal|1
operator|+
operator|(
name|int
operator|)
name|bit_count
argument_list|(
name|saved_regs_mask
argument_list|)
operator|)
operator|||
name|current_function_calls_alloca
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsub\t%r, %r, #%d\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|FP_REGNUM
argument_list|,
literal|4
operator|*
name|bit_count
argument_list|(
name|saved_regs_mask
argument_list|)
argument_list|)
expr_stmt|;
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\t%r"
argument_list|,
name|SP_REGNUM
argument_list|,
name|saved_regs_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
comment|/* Interrupt handlers will have pushed the 	   IP onto the stack, so restore it now.  */
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\t%r!"
argument_list|,
name|SP_REGNUM
argument_list|,
literal|1
operator|<<
name|IP_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Restore stack pointer if necessary.  */
if|if
condition|(
name|offsets
operator|->
name|outgoing_args
operator|!=
name|offsets
operator|->
name|saved_regs
condition|)
block|{
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|offsets
operator|->
name|outgoing_args
operator|-
name|offsets
operator|->
name|saved_regs
argument_list|)
expr_stmt|;
name|output_add_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arm_fpu_arch
operator|==
name|FPUTYPE_FPA_EMU2
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|FIRST_FPA_REGNUM
init|;
name|reg
operator|<=
name|LAST_FPA_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tldfe\t%r, [%r], #12\n"
argument_list|,
name|reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_reg
operator|=
name|FIRST_FPA_REGNUM
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|FIRST_FPA_REGNUM
init|;
name|reg
operator|<=
name|LAST_FPA_REGNUM
condition|;
name|reg
operator|++
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
if|if
condition|(
name|reg
operator|-
name|start_reg
operator|==
literal|3
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfmfd\t%r, 4, [%r]!\n"
argument_list|,
name|start_reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfmfd\t%r, %d, [%r]!\n"
argument_list|,
name|start_reg
argument_list|,
name|reg
operator|-
name|start_reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Just in case the last register checked also needs unstacking.  */
if|if
condition|(
name|reg
operator|!=
name|start_reg
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tlfmfd\t%r, %d, [%r]!\n"
argument_list|,
name|start_reg
argument_list|,
name|reg
operator|-
name|start_reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_VFP
condition|)
block|{
name|start_reg
operator|=
name|FIRST_VFP_REGNUM
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|FIRST_VFP_REGNUM
init|;
name|reg
operator|<
name|LAST_VFP_REGNUM
condition|;
name|reg
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|regs_ever_live
index|[
name|reg
index|]
operator|||
name|call_used_regs
index|[
name|reg
index|]
operator|)
operator|&&
operator|(
operator|!
name|regs_ever_live
index|[
name|reg
operator|+
literal|1
index|]
operator|||
name|call_used_regs
index|[
name|reg
operator|+
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
name|arm_output_fldmx
argument_list|(
name|f
argument_list|,
name|SP_REGNUM
argument_list|,
operator|(
name|start_reg
operator|-
name|FIRST_VFP_REGNUM
operator|)
operator|/
literal|2
argument_list|,
operator|(
name|reg
operator|-
name|start_reg
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|+
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
name|arm_output_fldmx
argument_list|(
name|f
argument_list|,
name|SP_REGNUM
argument_list|,
operator|(
name|start_reg
operator|-
name|FIRST_VFP_REGNUM
operator|)
operator|/
literal|2
argument_list|,
operator|(
name|reg
operator|-
name|start_reg
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_IWMMXT
condition|)
for|for
control|(
name|reg
operator|=
name|FIRST_IWMMXT_REGNUM
init|;
name|reg
operator|<=
name|LAST_IWMMXT_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\twldrd\t%r, [%r], #8\n"
argument_list|,
name|reg
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
comment|/* If we can, restore the LR into the PC.  */
if|if
condition|(
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
operator|==
name|ARM_FT_NORMAL
operator|&&
name|really_return
operator|&&
name|current_function_pretend_args_size
operator|==
literal|0
operator|&&
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|&&
operator|!
name|current_function_calls_eh_return
condition|)
block|{
name|saved_regs_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
name|saved_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
expr_stmt|;
block|}
comment|/* Load the registers off the stack.  If we only have one register 	 to load use the LDR instruction - it is faster.  */
if|if
condition|(
name|saved_regs_mask
operator|==
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tldr\t%r, [%r], #4\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|saved_regs_mask
condition|)
block|{
if|if
condition|(
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
condition|)
comment|/* Note - write back to the stack register is not enabled 	       (i.e. "ldmfd sp!...").  We know that the stack pointer is 	       in the list of registers and if we add writeback the 	       instruction becomes UNPREDICTABLE.  */
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\t%r"
argument_list|,
name|SP_REGNUM
argument_list|,
name|saved_regs_mask
argument_list|)
expr_stmt|;
else|else
name|print_multi_reg
argument_list|(
name|f
argument_list|,
literal|"ldmfd\t%r!"
argument_list|,
name|SP_REGNUM
argument_list|,
name|saved_regs_mask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_pretend_args_size
condition|)
block|{
comment|/* Unwind the pre-pushed regs.  */
name|operands
index|[
literal|0
index|]
operator|=
name|operands
index|[
literal|1
index|]
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|operands
index|[
literal|2
index|]
operator|=
name|GEN_INT
argument_list|(
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
name|output_add_immediate
argument_list|(
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We may have already restored PC directly from the stack.  */
if|if
condition|(
operator|!
name|really_return
operator|||
name|saved_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
condition|)
return|return
literal|""
return|;
comment|/* Stack adjustment for exception handler.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
name|ARM_EH_STACKADJ_REGNUM
argument_list|)
expr_stmt|;
comment|/* Generate the return instruction.  */
switch|switch
condition|(
operator|(
name|int
operator|)
name|ARM_FUNC_TYPE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
case|case
name|ARM_FT_ISR
case|:
case|case
name|ARM_FT_FIQ
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsubs\t%r, %r, #4\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_EXCEPTION
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmovs\t%r, %r\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FT_INTERWORKED
case|:
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|arm_arch5
operator|||
name|arm_arch4t
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
else|else
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|PC_REGNUM
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_output_function_epilogue
parameter_list|(
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|frame_size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
name|int
name|regno
decl_stmt|;
comment|/* Emit any call-via-reg trampolines that are needed for v4t support 	 of call_reg and call_value_reg type insns.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|LR_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
name|rtx
name|label
init|=
name|cfun
operator|->
name|machine
operator|->
name|call_via
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
name|switch_to_section
argument_list|(
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ??? Probably not safe to set this here, since it assumes that a 	 function will be emitted as assembly immediately after we generate 	 RTL for it.  This does not happen for inline functions.  */
name|return_used_this_function
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to take into account any stack-frame rounding.  */
name|offsets
operator|=
name|arm_get_frame_offsets
argument_list|()
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|use_return_insn
argument_list|(
name|FALSE
argument_list|,
name|NULL
argument_list|)
operator|||
operator|!
name|return_used_this_function
operator|||
name|offsets
operator|->
name|saved_regs
operator|==
name|offsets
operator|->
name|outgoing_args
operator|||
name|frame_pointer_needed
argument_list|)
expr_stmt|;
comment|/* Reset the ARM-specific per-function variables.  */
name|after_arm_reorg
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate and emit an insn that we will recognize as a push_multi.    Unfortunately, since this insn does not reflect very well the actual    semantics of the operation, we need to annotate the insn for the benefit    of DWARF2 frame unwind information.  */
end_comment

begin_function
specifier|static
name|rtx
name|emit_multi_reg_push
parameter_list|(
name|unsigned
name|long
name|mask
parameter_list|)
block|{
name|int
name|num_regs
init|=
literal|0
decl_stmt|;
name|int
name|num_dwarf_regs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|par
decl_stmt|;
name|rtx
name|dwarf
decl_stmt|;
name|int
name|dwarf_par_index
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|reg
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|num_regs
operator|++
expr_stmt|;
name|gcc_assert
argument_list|(
name|num_regs
operator|&&
name|num_regs
operator|<=
literal|16
argument_list|)
expr_stmt|;
comment|/* We don't record the PC in the dwarf frame information.  */
name|num_dwarf_regs
operator|=
name|num_regs
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
condition|)
name|num_dwarf_regs
operator|--
expr_stmt|;
comment|/* For the body of the insn we are going to generate an UNSPEC in      parallel with several USEs.  This allows the insn to be recognized      by the push_multi pattern in the arm.md file.  The insn looks      something like this:         (parallel [            (set (mem:BLK (pre_dec:BLK (reg:SI sp))) 	        (unspec:BLK [(reg:SI r4)] UNSPEC_PUSH_MULT))            (use (reg:SI 11 fp))            (use (reg:SI 12 ip))            (use (reg:SI 14 lr))            (use (reg:SI 15 pc))         ])       For the frame note however, we try to be more explicit and actually      show each register being stored into the stack frame, plus a (single)      decrement of the stack pointer.  We do it this way in order to be      friendly to the stack unwinding code, which only wants to see a single      stack decrement per instruction.  The RTL we generate for the note looks      something like this:        (sequence [            (set (reg:SI sp) (plus:SI (reg:SI sp) (const_int -20)))            (set (mem:SI (reg:SI sp)) (reg:SI r4))            (set (mem:SI (plus:SI (reg:SI sp) (const_int 4))) (reg:SI fp))            (set (mem:SI (plus:SI (reg:SI sp) (const_int 8))) (reg:SI ip))            (set (mem:SI (plus:SI (reg:SI sp) (const_int 12))) (reg:SI lr))         ])        This sequence is used both by the code to support stack unwinding for       exceptions handlers and the code to generate dwarf2 frame debugging.  */
name|par
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num_regs
argument_list|)
argument_list|)
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_SEQUENCE
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|num_dwarf_regs
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dwarf_par_index
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|LAST_ARM_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_frame_mem
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|BLKmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
argument_list|,
name|UNSPEC_PUSH_MULT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|PC_REGNUM
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_frame_mem
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|dwarf_par_index
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|dwarf_par_index
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|1
operator|,
name|i
operator|++
init|;
name|j
operator|<
name|num_regs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|PC_REGNUM
condition|)
block|{
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_frame_mem
argument_list|(
name|SImode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
literal|4
operator|*
name|j
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|dwarf_par_index
operator|++
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
block|}
block|}
name|par
operator|=
name|emit_insn
argument_list|(
name|par
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
operator|-
literal|4
operator|*
name|num_regs
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|REG_NOTES
argument_list|(
name|par
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|par
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|par
return|;
block|}
end_function

begin_comment
comment|/* Calculate the size of the return value that is passed in registers.  */
end_comment

begin_function
specifier|static
name|int
name|arm_size_return_regs
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|current_function_return_rtx
operator|!=
literal|0
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|current_function_return_rtx
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|emit_sfm
parameter_list|(
name|int
name|base_reg
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|rtx
name|par
decl_stmt|;
name|rtx
name|dwarf
decl_stmt|;
name|rtx
name|tmp
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|par
operator|=
name|gen_rtx_PARALLEL
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_SEQUENCE
argument_list|(
name|VOIDmode
argument_list|,
name|rtvec_alloc
argument_list|(
name|count
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|base_reg
operator|++
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_frame_mem
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|BLKmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
argument_list|,
name|gen_rtx_UNSPEC
argument_list|(
name|BLKmode
argument_list|,
name|gen_rtvec
argument_list|(
literal|1
argument_list|,
name|reg
argument_list|)
argument_list|,
name|UNSPEC_PUSH_MULT
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_frame_mem
argument_list|(
name|XFmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|base_reg
operator|++
argument_list|)
expr_stmt|;
name|XVECEXP
argument_list|(
name|par
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
operator|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_frame_mem
argument_list|(
name|XFmode
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|i
operator|*
literal|12
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
name|tmp
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
operator|-
literal|12
operator|*
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|XVECEXP
argument_list|(
name|dwarf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|par
operator|=
name|emit_insn
argument_list|(
name|par
argument_list|)
expr_stmt|;
name|REG_NOTES
argument_list|(
name|par
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|par
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|par
return|;
block|}
end_function

begin_comment
comment|/* Return true if the current function needs to save/restore LR.  */
end_comment

begin_function
specifier|static
name|bool
name|thumb_force_lr_save
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|!
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
operator|&&
operator|(
operator|!
name|leaf_function_p
argument_list|()
operator|||
name|thumb_far_jump_used_p
argument_list|()
operator|||
name|regs_ever_live
index|[
name|LR_REGNUM
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the distance from register FROM to register TO.    These can be the arg pointer (26), the soft frame pointer (25),    the stack pointer (13) or the hard frame pointer (11).    In thumb mode r7 is used as the soft frame pointer, if needed.    Typical stack layout looks like this:         old stack pointer -> |    |                              ----                             |    | \                             |    |   saved arguments for                             |    |   vararg functions 			    |    | /                               --    hard FP& arg pointer -> |    | \                             |    |   stack                             |    |   frame                             |    | /                               --                             |    | \                             |    |   call saved                             |    |   registers       soft frame pointer -> |    | /                               --                             |    | \                             |    |   local                             |    |   variables      locals base pointer -> |    | /                               --                             |    | \                             |    |   outgoing                             |    |   arguments    current stack pointer -> |    | /                               --    For a given function some or all of these stack components   may not be needed, giving rise to the possibility of   eliminating some of the registers.    The values returned by this function must reflect the behavior   of arm_expand_prologue() and arm_compute_save_reg_mask().    The sign of the number returned reflects the direction of stack   growth, so the values are positive for all eliminations except   from the soft frame pointer to the hard frame pointer.    SFP may point just inside the local variables block to ensure correct   alignment.  */
end_comment

begin_comment
comment|/* Calculate stack offsets.  These are used to calculate register elimination    offsets and in prologue/epilogue code.  */
end_comment

begin_function
specifier|static
name|arm_stack_offsets
modifier|*
name|arm_get_frame_offsets
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|int
name|leaf
decl_stmt|;
name|int
name|saved
decl_stmt|;
name|HOST_WIDE_INT
name|frame_size
decl_stmt|;
name|offsets
operator|=
operator|&
name|cfun
operator|->
name|machine
operator|->
name|stack_offsets
expr_stmt|;
comment|/* We need to know if we are a leaf function.  Unfortunately, it      is possible to be called after start_sequence has been called,      which causes get_insns to return the insns for the sequence,      not the function, which will cause leaf_function_p to return      the incorrect result.       to know about leaf functions once reload has completed, and the      frame size cannot be changed after that time, so we can safely      use the cached value.  */
if|if
condition|(
name|reload_completed
condition|)
return|return
name|offsets
return|;
comment|/* Initially this is the size of the local variables.  It will translated      into an offset once we have determined the size of preceding data.  */
name|frame_size
operator|=
name|ROUND_UP_WORD
argument_list|(
name|get_frame_size
argument_list|()
argument_list|)
expr_stmt|;
name|leaf
operator|=
name|leaf_function_p
argument_list|()
expr_stmt|;
comment|/* Space for variadic functions.  */
name|offsets
operator|->
name|saved_args
operator|=
name|current_function_pretend_args_size
expr_stmt|;
name|offsets
operator|->
name|frame
operator|=
name|offsets
operator|->
name|saved_args
operator|+
operator|(
name|frame_pointer_needed
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|TARGET_ARM
condition|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|saved
operator|=
name|bit_count
argument_list|(
name|arm_compute_save_reg_mask
argument_list|()
argument_list|)
operator|*
literal|4
expr_stmt|;
comment|/* We know that SP will be doubleword aligned on entry, and we must 	 preserve that condition at any subroutine call.  We also require the 	 soft frame pointer to be doubleword aligned.  */
if|if
condition|(
name|TARGET_REALLY_IWMMXT
condition|)
block|{
comment|/* Check for the call-saved iWMMXt registers.  */
for|for
control|(
name|regno
operator|=
name|FIRST_IWMMXT_REGNUM
init|;
name|regno
operator|<=
name|LAST_IWMMXT_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
name|saved
operator|+=
literal|8
expr_stmt|;
block|}
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* Space for saved FPA registers.  */
for|for
control|(
name|regno
operator|=
name|FIRST_FPA_REGNUM
init|;
name|regno
operator|<=
name|LAST_FPA_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
name|saved
operator|+=
literal|12
expr_stmt|;
comment|/* Space for saved VFP registers.  */
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_VFP
condition|)
name|saved
operator|+=
name|arm_get_vfp_saved_size
argument_list|()
expr_stmt|;
block|}
block|}
else|else
comment|/* TARGET_THUMB */
block|{
name|saved
operator|=
name|bit_count
argument_list|(
name|thumb_compute_save_reg_mask
argument_list|()
argument_list|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|TARGET_BACKTRACE
condition|)
name|saved
operator|+=
literal|16
expr_stmt|;
block|}
comment|/* Saved registers include the stack frame.  */
name|offsets
operator|->
name|saved_regs
operator|=
name|offsets
operator|->
name|saved_args
operator|+
name|saved
expr_stmt|;
name|offsets
operator|->
name|soft_frame
operator|=
name|offsets
operator|->
name|saved_regs
operator|+
name|CALLER_INTERWORKING_SLOT_SIZE
expr_stmt|;
comment|/* A leaf function does not need any stack alignment if it has nothing      on the stack.  */
if|if
condition|(
name|leaf
operator|&&
name|frame_size
operator|==
literal|0
condition|)
block|{
name|offsets
operator|->
name|outgoing_args
operator|=
name|offsets
operator|->
name|soft_frame
expr_stmt|;
name|offsets
operator|->
name|locals_base
operator|=
name|offsets
operator|->
name|soft_frame
expr_stmt|;
return|return
name|offsets
return|;
block|}
comment|/* Ensure SFP has the correct alignment.  */
if|if
condition|(
name|ARM_DOUBLEWORD_ALIGN
operator|&&
operator|(
name|offsets
operator|->
name|soft_frame
operator|&
literal|7
operator|)
condition|)
name|offsets
operator|->
name|soft_frame
operator|+=
literal|4
expr_stmt|;
name|offsets
operator|->
name|locals_base
operator|=
name|offsets
operator|->
name|soft_frame
operator|+
name|frame_size
expr_stmt|;
name|offsets
operator|->
name|outgoing_args
operator|=
operator|(
name|offsets
operator|->
name|locals_base
operator|+
name|current_function_outgoing_args_size
operator|)
expr_stmt|;
if|if
condition|(
name|ARM_DOUBLEWORD_ALIGN
condition|)
block|{
comment|/* Ensure SP remains doubleword aligned.  */
if|if
condition|(
name|offsets
operator|->
name|outgoing_args
operator|&
literal|7
condition|)
name|offsets
operator|->
name|outgoing_args
operator|+=
literal|4
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|(
name|offsets
operator|->
name|outgoing_args
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|offsets
return|;
block|}
end_function

begin_comment
comment|/* Calculate the relative offsets for the different stack pointers.  Positive    offsets are in the direction of stack growth.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|arm_compute_initial_elimination_offset
parameter_list|(
name|unsigned
name|int
name|from
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|)
block|{
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
name|offsets
operator|=
name|arm_get_frame_offsets
argument_list|()
expr_stmt|;
comment|/* OK, now we have enough information to compute the distances.      There must be an entry in these switch tables for each pair      of registers in ELIMINABLE_REGS, even if some of the entries      seem to be redundant or useless.  */
switch|switch
condition|(
name|from
condition|)
block|{
case|case
name|ARG_POINTER_REGNUM
case|:
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|THUMB_HARD_FRAME_POINTER_REGNUM
case|:
return|return
literal|0
return|;
case|case
name|FRAME_POINTER_REGNUM
case|:
comment|/* This is the reverse of the soft frame pointer 	     to hard frame pointer elimination below.  */
return|return
name|offsets
operator|->
name|soft_frame
operator|-
name|offsets
operator|->
name|saved_args
return|;
case|case
name|ARM_HARD_FRAME_POINTER_REGNUM
case|:
comment|/* If there is no stack frame then the hard 	     frame pointer and the arg pointer coincide.  */
if|if
condition|(
name|offsets
operator|->
name|frame
operator|==
name|offsets
operator|->
name|saved_regs
condition|)
return|return
literal|0
return|;
comment|/* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */
return|return
operator|(
name|frame_pointer_needed
operator|&&
name|cfun
operator|->
name|static_chain_decl
operator|!=
name|NULL
operator|&&
operator|!
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
operator|)
condition|?
literal|4
else|:
literal|0
return|;
case|case
name|STACK_POINTER_REGNUM
case|:
comment|/* If nothing has been pushed on the stack at all 	     then this will return -4.  This *is* correct!  */
return|return
name|offsets
operator|->
name|outgoing_args
operator|-
operator|(
name|offsets
operator|->
name|saved_args
operator|+
literal|4
operator|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|FRAME_POINTER_REGNUM
case|:
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|THUMB_HARD_FRAME_POINTER_REGNUM
case|:
return|return
literal|0
return|;
case|case
name|ARM_HARD_FRAME_POINTER_REGNUM
case|:
comment|/* The hard frame pointer points to the top entry in the 	     stack frame.  The soft frame pointer to the bottom entry 	     in the stack frame.  If there is no stack frame at all, 	     then they are identical.  */
return|return
name|offsets
operator|->
name|frame
operator|-
name|offsets
operator|->
name|soft_frame
return|;
case|case
name|STACK_POINTER_REGNUM
case|:
return|return
name|offsets
operator|->
name|outgoing_args
operator|-
name|offsets
operator|->
name|soft_frame
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|gcc_unreachable
argument_list|()
expr_stmt|;
default|default:
comment|/* You cannot eliminate from the stack pointer. 	 In theory you could eliminate from the hard frame 	 pointer to the stack pointer, but this will never 	 happen, since if a stack frame is not needed the 	 hard frame pointer will never be used.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the prologue instructions for entry into an ARM function.  */
end_comment

begin_function
name|void
name|arm_expand_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|rtx
name|amount
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|ip_rtx
decl_stmt|;
name|unsigned
name|long
name|live_regs_mask
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|int
name|fp_offset
init|=
literal|0
decl_stmt|;
name|int
name|saved_pretend_args
init|=
literal|0
decl_stmt|;
name|int
name|saved_regs
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|args_to_push
decl_stmt|;
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
comment|/* Naked functions don't have prologues.  */
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
return|return;
comment|/* Make a copy of c_f_p_a_s as we may need to modify it locally.  */
name|args_to_push
operator|=
name|current_function_pretend_args_size
expr_stmt|;
comment|/* Compute which register we will have to save onto the stack.  */
name|live_regs_mask
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
name|ip_rtx
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* Interrupt functions must not corrupt any registers. 	     Creating a frame pointer however, corrupts the IP 	     register, so we must push it first.  */
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
literal|1
operator|<<
name|IP_REGNUM
argument_list|)
expr_stmt|;
comment|/* Do not set RTX_FRAME_RELATED_P on this insn. 	     The dwarf stack unwinding code only wants to see one 	     stack decrement per function, and this is not it.  If 	     this instruction is labeled as being part of the frame 	     creation sequence then dwarf2out_frame_debug_expr will 	     die when it encounters the assignment of IP to FP 	     later on, since the use of SP here establishes SP as 	     the CFA register and not IP.  	     Anyway this instruction is not really part of the stack 	     frame creation although it is part of the prologue.  */
block|}
elseif|else
if|if
condition|(
name|IS_NESTED
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* The Static chain register is the same as the IP register 	     used as a scratch register during stack frame creation. 	     To get around this need to find somewhere to store IP 	     whilst the frame is being created.  We try the following 	     places in order:  	       1. The last argument register. 	       2. A slot on the stack above the frame.  (This only 	          works if the function is not a varargs function). 	       3. Register r3, after pushing the argument registers 	          onto the stack.  	     Note - we only need to tell the dwarf2 backend about the SP 	     adjustment in the second variant; the static chain register 	     doesn't need to be unwound, as it doesn't contain a value 	     inherited from the caller.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|insn
operator|=
name|emit_set_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|3
argument_list|)
argument_list|,
name|ip_rtx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|args_to_push
operator|==
literal|0
condition|)
block|{
name|rtx
name|dwarf
decl_stmt|;
name|insn
operator|=
name|gen_rtx_PRE_DEC
argument_list|(
name|SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_set_insn
argument_list|(
name|gen_frame_mem
argument_list|(
name|SImode
argument_list|,
name|insn
argument_list|)
argument_list|,
name|ip_rtx
argument_list|)
expr_stmt|;
name|fp_offset
operator|=
literal|4
expr_stmt|;
comment|/* Just tell the dwarf backend that we adjusted SP.  */
name|dwarf
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
operator|-
name|fp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Store the args on the stack.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
condition|)
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
operator|(
literal|0xf0
operator|>>
operator|(
name|args_to_push
operator|/
literal|4
operator|)
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|args_to_push
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|saved_pretend_args
operator|=
literal|1
expr_stmt|;
name|fp_offset
operator|=
name|args_to_push
expr_stmt|;
name|args_to_push
operator|=
literal|0
expr_stmt|;
comment|/* Now reuse r3 to preserve IP.  */
name|emit_set_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|3
argument_list|)
argument_list|,
name|ip_rtx
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|emit_set_insn
argument_list|(
name|ip_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|fp_offset
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|args_to_push
condition|)
block|{
comment|/* Push the argument registers, or reserve space for them.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
condition|)
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
operator|(
literal|0xf0
operator|>>
operator|(
name|args_to_push
operator|/
literal|4
operator|)
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|args_to_push
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this is an interrupt service routine, and the link register      is going to be pushed, and we are not creating a stack frame,      (which would involve an extra push of IP and a pop in the epilogue)      subtracting four from LR now will mean that the function return      can be done with a single instruction.  */
if|if
condition|(
operator|(
name|func_type
operator|==
name|ARM_FT_ISR
operator|||
name|func_type
operator|==
name|ARM_FT_FIQ
operator|)
operator|&&
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|frame_pointer_needed
condition|)
block|{
name|rtx
name|lr
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LR_REGNUM
argument_list|)
decl_stmt|;
name|emit_set_insn
argument_list|(
name|lr
argument_list|,
name|plus_constant
argument_list|(
name|lr
argument_list|,
operator|-
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|live_regs_mask
condition|)
block|{
name|insn
operator|=
name|emit_multi_reg_push
argument_list|(
name|live_regs_mask
argument_list|)
expr_stmt|;
name|saved_regs
operator|+=
name|bit_count
argument_list|(
name|live_regs_mask
argument_list|)
operator|*
literal|4
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_IWMMXT
condition|)
for|for
control|(
name|reg
operator|=
name|LAST_IWMMXT_REGNUM
init|;
name|reg
operator|>=
name|FIRST_IWMMXT_REGNUM
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|insn
operator|=
name|gen_rtx_PRE_DEC
argument_list|(
name|V2SImode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_frame_mem
argument_list|(
name|V2SImode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_set_insn
argument_list|(
name|insn
argument_list|,
name|gen_rtx_REG
argument_list|(
name|V2SImode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|saved_regs
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IS_VOLATILE
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
name|int
name|start_reg
decl_stmt|;
comment|/* Save any floating point call-saved registers used by this 	 function.  */
if|if
condition|(
name|arm_fpu_arch
operator|==
name|FPUTYPE_FPA_EMU2
condition|)
block|{
for|for
control|(
name|reg
operator|=
name|LAST_FPA_REGNUM
init|;
name|reg
operator|>=
name|FIRST_FPA_REGNUM
condition|;
name|reg
operator|--
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
name|insn
operator|=
name|gen_rtx_PRE_DEC
argument_list|(
name|XFmode
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_frame_mem
argument_list|(
name|XFmode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_set_insn
argument_list|(
name|insn
argument_list|,
name|gen_rtx_REG
argument_list|(
name|XFmode
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|saved_regs
operator|+=
literal|12
expr_stmt|;
block|}
block|}
else|else
block|{
name|start_reg
operator|=
name|LAST_FPA_REGNUM
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|LAST_FPA_REGNUM
init|;
name|reg
operator|>=
name|FIRST_FPA_REGNUM
condition|;
name|reg
operator|--
control|)
block|{
if|if
condition|(
name|regs_ever_live
index|[
name|reg
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|reg
index|]
condition|)
block|{
if|if
condition|(
name|start_reg
operator|-
name|reg
operator|==
literal|3
condition|)
block|{
name|insn
operator|=
name|emit_sfm
argument_list|(
name|reg
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|saved_regs
operator|+=
literal|48
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
block|{
name|insn
operator|=
name|emit_sfm
argument_list|(
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|saved_regs
operator|+=
operator|(
name|start_reg
operator|-
name|reg
operator|)
operator|*
literal|12
expr_stmt|;
block|}
name|start_reg
operator|=
name|reg
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
block|{
name|insn
operator|=
name|emit_sfm
argument_list|(
name|reg
operator|+
literal|1
argument_list|,
name|start_reg
operator|-
name|reg
argument_list|)
expr_stmt|;
name|saved_regs
operator|+=
operator|(
name|start_reg
operator|-
name|reg
operator|)
operator|*
literal|12
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_VFP
condition|)
block|{
name|start_reg
operator|=
name|FIRST_VFP_REGNUM
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|FIRST_VFP_REGNUM
init|;
name|reg
operator|<
name|LAST_VFP_REGNUM
condition|;
name|reg
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|(
operator|!
name|regs_ever_live
index|[
name|reg
index|]
operator|||
name|call_used_regs
index|[
name|reg
index|]
operator|)
operator|&&
operator|(
operator|!
name|regs_ever_live
index|[
name|reg
operator|+
literal|1
index|]
operator|||
name|call_used_regs
index|[
name|reg
operator|+
literal|1
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
name|saved_regs
operator|+=
name|vfp_emit_fstmx
argument_list|(
name|start_reg
argument_list|,
operator|(
name|reg
operator|-
name|start_reg
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|start_reg
operator|=
name|reg
operator|+
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|start_reg
operator|!=
name|reg
condition|)
name|saved_regs
operator|+=
name|vfp_emit_fstmx
argument_list|(
name|start_reg
argument_list|,
operator|(
name|reg
operator|-
name|start_reg
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
comment|/* Create the new frame pointer.  */
name|insn
operator|=
name|GEN_INT
argument_list|(
operator|-
operator|(
literal|4
operator|+
name|args_to_push
operator|+
name|fp_offset
operator|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|ip_rtx
argument_list|,
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IS_NESTED
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
comment|/* Recover the static chain register.  */
if|if
condition|(
name|regs_ever_live
index|[
literal|3
index|]
operator|==
literal|0
operator|||
name|saved_pretend_args
condition|)
name|insn
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
comment|/* if (current_function_pretend_args_size == 0) */
block|{
name|insn
operator|=
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|insn
operator|=
name|gen_frame_mem
argument_list|(
name|SImode
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
name|emit_set_insn
argument_list|(
name|ip_rtx
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Add a USE to stop propagate_one_insn() from barfing.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|ip_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|offsets
operator|=
name|arm_get_frame_offsets
argument_list|()
expr_stmt|;
if|if
condition|(
name|offsets
operator|->
name|outgoing_args
operator|!=
name|offsets
operator|->
name|saved_args
operator|+
name|saved_regs
condition|)
block|{
comment|/* This add can produce multiple insns for a large constant, so we 	 need to get tricky.  */
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|amount
operator|=
name|GEN_INT
argument_list|(
name|offsets
operator|->
name|saved_args
operator|+
name|saved_regs
operator|-
name|offsets
operator|->
name|outgoing_args
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|amount
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|last
operator|=
name|last
condition|?
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
else|:
name|get_insns
argument_list|()
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|last
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|last
operator|!=
name|insn
condition|)
do|;
comment|/* If the frame pointer is needed, emit a special barrier that 	 will prevent the scheduler from moving stores to the frame 	 before the stack adjustment.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_stack_tie
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_pic
operator|&&
name|arm_pic_register
operator|!=
name|INVALID_REGNUM
condition|)
name|arm_load_pic_register
argument_list|(
literal|0UL
argument_list|)
expr_stmt|;
comment|/* If we are profiling, make sure no instructions are scheduled before      the call to mcount.  Similarly if the user has requested no      scheduling in the prolog.  Similarly if we want non-call exceptions      using the EABI unwinder, to prevent faulting instructions from being      swapped with a stack adjustment.  */
if|if
condition|(
name|current_function_profile
operator|||
operator|!
name|TARGET_SCHED_PROLOG
operator|||
operator|(
name|ARM_EABI_UNWIND_TABLES
operator|&&
name|flag_non_call_exceptions
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If the link register is being kept alive, with the return address in it,      then make sure that it does not get reused by the ce2 pass.  */
if|if
condition|(
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If CODE is 'd', then the X is a condition operand and the instruction    should only be executed if the condition is true.    if CODE is 'D', then the X is a condition operand and the instruction    should only be executed if the condition is false: however, if the mode    of the comparison is CCFPEmode, then always execute the instruction -- we    do this because in these circumstances !GE does not necessarily imply LT;    in these cases the instruction pattern will take care to make sure that    an instruction containing %d will follow, thereby undoing the effects of    doing this instruction unconditionally.    If CODE is 'N' then X is a floating point operand that must be negated    before output.    If CODE is 'B' then output a bitwise inverted value of X (a const int).    If X is a REG and CODE is `M', output a ldm/stm style multi-reg.  */
end_comment

begin_function
name|void
name|arm_print_operand
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|'@'
case|:
name|fputs
argument_list|(
name|ASM_COMMENT_START
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'_'
case|:
name|fputs
argument_list|(
name|user_label_prefix
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'|'
case|:
name|fputs
argument_list|(
name|REGISTER_PREFIX
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'?'
case|:
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|3
operator|||
name|arm_ccfsm_state
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"predicated Thumb instruction"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|current_insn_predicate
operator|!=
name|NULL
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"predicated instruction in conditional sequence"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|arm_current_cc
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_insn_predicate
condition|)
block|{
name|enum
name|arm_cond_code
name|code
decl_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"predicated Thumb instruction"
argument_list|)
expr_stmt|;
break|break;
block|}
name|code
operator|=
name|get_arm_condition_code
argument_list|(
name|current_insn_predicate
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|code
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'N'
case|:
block|{
name|REAL_VALUE_TYPE
name|r
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|r
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|r
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|fp_const_from_val
argument_list|(
operator|&
name|r
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'B'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
decl_stmt|;
name|val
operator|=
name|ARM_SIGN_EXTEND
argument_list|(
operator|~
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|'~'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|stream
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
literal|'i'
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arithmetic_instr
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
comment|/* Truncate Cirrus shift counts.  */
case|case
literal|'s'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
return|return;
block|}
name|arm_print_operand
argument_list|(
name|stream
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'I'
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|arithmetic_instr
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'S'
case|:
block|{
name|HOST_WIDE_INT
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|shift
decl_stmt|;
if|if
condition|(
operator|!
name|shift_operator
argument_list|(
name|x
argument_list|,
name|SImode
argument_list|)
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid shift operand"
argument_list|)
expr_stmt|;
break|break;
block|}
name|shift
operator|=
name|shift_op
argument_list|(
name|x
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|", %s "
argument_list|,
name|shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|arm_print_operand
argument_list|(
name|stream
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"#"
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
comment|/* An explanation of the 'Q', 'R' and 'H' register operands:  	 In a pair of registers containing a DI or DF value the 'Q' 	 operand returns the register number of the register containing 	 the least significant part of the value.  The 'R' operand returns 	 the register number of the register containing the most 	 significant part of the value.  	 The 'H' operand returns the higher of the two register numbers. 	 On a run where WORDS_BIG_ENDIAN is true the 'H' operand is the 	 same as the 'Q' operand, since the most significant part of the 	 value is held in the lower number register.  The reverse is true 	 on systems where WORDS_BIG_ENDIAN is false.  	 The purpose of these operands is to distinguish between cases 	 where the endian-ness of the values is important (for example 	 when they are added together), and cases where the endian-ness 	 is irrelevant, but the order of register operations is important. 	 For example when loading a value from memory into a register 	 pair, the endian-ness does not matter.  Provided that the value 	 from the lower memory address is put into the lower numbered 	 register, and the value from the higher address is put into the 	 higher numbered register, the load will work regardless of whether 	 the value being loaded is big-wordian or little-wordian.  The 	 order of the two register loads can matter however, if the address 	 of the memory location is actually held in one of the registers 	 being overwritten by the load.  */
case|case
literal|'Q'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_ARM_REGNUM
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid operand for code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'R'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_ARM_REGNUM
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid operand for code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|WORDS_BIG_ENDIAN
condition|?
literal|0
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'H'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_ARM_REGNUM
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid operand for code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'m'
case|:
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|?
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"{%r-%r}"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|+
name|ARM_NUM_REGS
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'d'
case|:
comment|/* CONST_TRUE_RTX means always -- that's the default.  */
if|if
condition|(
name|x
operator|==
name|const_true_rtx
condition|)
return|return;
if|if
condition|(
operator|!
name|COMPARISON_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid operand for code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|get_arm_condition_code
argument_list|(
name|x
argument_list|)
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'D'
case|:
comment|/* CONST_TRUE_RTX means not always -- i.e. never.  We shouldn't ever 	 want to do that.  */
if|if
condition|(
name|x
operator|==
name|const_true_rtx
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"instruction never exectued"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|COMPARISON_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid operand for code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|fputs
argument_list|(
name|arm_condition_codes
index|[
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|get_arm_condition_code
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
comment|/* Cirrus registers can be accessed in a variety of ways:          single floating point (f) 	 double floating point (d) 	 32bit integer         (fx) 	 64bit integer         (dx).  */
case|case
literal|'W'
case|:
comment|/* Cirrus register in F mode.  */
case|case
literal|'X'
case|:
comment|/* Cirrus register in D mode.  */
case|case
literal|'Y'
case|:
comment|/* Cirrus register in FX mode.  */
case|case
literal|'Z'
case|:
comment|/* Cirrus register in DX mode.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CIRRUS_REGS
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"mv%s%s"
argument_list|,
name|code
operator|==
literal|'W'
condition|?
literal|"f"
else|:
name|code
operator|==
literal|'X'
condition|?
literal|"d"
else|:
name|code
operator|==
literal|'Y'
condition|?
literal|"fx"
else|:
literal|"dx"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
comment|/* Print cirrus register in the mode specified by the register's mode.  */
case|case
literal|'V'
case|:
block|{
name|int
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO_REG_CLASS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|CIRRUS_REGS
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid operand for code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"mv%s%s"
argument_list|,
name|mode
operator|==
name|DFmode
condition|?
literal|"d"
else|:
name|mode
operator|==
name|SImode
condition|?
literal|"fx"
else|:
name|mode
operator|==
name|DImode
condition|?
literal|"dx"
else|:
literal|"f"
argument_list|,
name|reg_names
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'U'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_IWMMXT_GR_REGNUM
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>
name|LAST_IWMMXT_GR_REGNUM
condition|)
comment|/* Bad value for wCG register number.  */
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid operand for code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_IWMMXT_GR_REGNUM
argument_list|)
expr_stmt|;
return|return;
comment|/* Print an iWMMXt control register name.  */
case|case
literal|'w'
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|<
literal|0
operator|||
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|16
condition|)
comment|/* Bad value for wC register number.  */
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid operand for code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
specifier|static
specifier|const
name|char
modifier|*
name|wc_reg_names
index|[
literal|16
index|]
init|=
block|{
literal|"wCID"
block|,
literal|"wCon"
block|,
literal|"wCSSF"
block|,
literal|"wCASF"
block|,
literal|"wC4"
block|,
literal|"wC5"
block|,
literal|"wC6"
block|,
literal|"wC7"
block|,
literal|"wCGR0"
block|,
literal|"wCGR1"
block|,
literal|"wCGR2"
block|,
literal|"wCGR3"
block|,
literal|"wC12"
block|,
literal|"wC13"
block|,
literal|"wC14"
block|,
literal|"wC15"
block|}
decl_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|wc_reg_names
index|[
name|INTVAL
argument_list|(
name|x
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* Print a VFP double precision register name.  */
case|case
literal|'P'
case|:
block|{
name|int
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|num
decl_stmt|;
if|if
condition|(
name|mode
operator|!=
name|DImode
operator|&&
name|mode
operator|!=
name|DFmode
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid operand for code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
operator|!
name|IS_VFP_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid operand for code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|num
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|FIRST_VFP_REGNUM
expr_stmt|;
if|if
condition|(
name|num
operator|&
literal|1
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"invalid operand for code '%c'"
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"d%d"
argument_list|,
name|num
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
name|output_operand_lossage
argument_list|(
literal|"missing operand"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%r"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|output_memory_reference_mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|output_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"#%s"
argument_list|,
name|fp_immediate_constant
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|NEG
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'#'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|stream
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
end_ifndef

begin_comment
comment|/* Target hook for assembling integer objects.  The ARM version needs to    handle word-sized values specially.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_assemble_integer
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|int
name|aligned_p
parameter_list|)
block|{
if|if
condition|(
name|size
operator|==
name|UNITS_PER_WORD
operator|&&
name|aligned_p
condition|)
block|{
name|fputs
argument_list|(
literal|"\t.word\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Mark symbols as position independent.  We only do this in the 	 .text segment, not in the .data segment.  */
if|if
condition|(
name|NEED_GOT_RELOC
operator|&&
name|flag_pic
operator|&&
name|making_const_table
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
operator|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|x
argument_list|)
operator|||
name|SYMBOL_REF_LOCAL_P
argument_list|(
name|x
argument_list|)
operator|)
condition|)
name|fputs
argument_list|(
literal|"(GOTOFF)"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|fputs
argument_list|(
literal|"(GOTOFF)"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"(GOT)"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|arm_vector_mode_supported_p
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|units
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_VECTOR
argument_list|)
expr_stmt|;
name|units
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|V2SImode
case|:
name|size
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|size
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|V8QImode
case|:
name|size
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|elt
decl_stmt|;
name|elt
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|elt
argument_list|,
name|size
argument_list|,
name|i
operator|==
literal|0
condition|?
name|BIGGEST_ALIGNMENT
else|:
name|size
operator|*
name|BITS_PER_UNIT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
return|return
name|default_assemble_integer
argument_list|(
name|x
argument_list|,
name|size
argument_list|,
name|aligned_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a function to the list of static constructors.  */
end_comment

begin_function
specifier|static
name|void
name|arm_elf_asm_constructor
parameter_list|(
name|rtx
name|symbol
parameter_list|,
name|int
name|priority
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_AAPCS_BASED
condition|)
block|{
name|default_named_section_asm_out_constructor
argument_list|(
name|symbol
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Put these in the .init_array section, using a special relocation.  */
name|switch_to_section
argument_list|(
name|ctors_section
argument_list|)
expr_stmt|;
name|assemble_align
argument_list|(
name|POINTER_SIZE
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\t.word\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"(target1)\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* A finite state machine takes care of noticing whether or not instructions    can be conditionally executed, and thus decrease execution time and code    size by deleting branch instructions.  The fsm is controlled by    final_prescan_insn, and controls the actions of ASM_OUTPUT_OPCODE.  */
end_comment

begin_comment
comment|/* The state of the fsm controlling condition codes are:    0: normal, do nothing special    1: make ASM_OUTPUT_OPCODE not output this instruction    2: make ASM_OUTPUT_OPCODE not output this instruction    3: make instructions conditional    4: make instructions conditional     State transitions (state->state by whom under condition):    0 -> 1 final_prescan_insn if the `target' is a label    0 -> 2 final_prescan_insn if the `target' is an unconditional branch    1 -> 3 ASM_OUTPUT_OPCODE after not having output the conditional branch    2 -> 4 ASM_OUTPUT_OPCODE after not having output the conditional branch    3 -> 0 (*targetm.asm_out.internal_label) if the `target' label is reached           (the target label has CODE_LABEL_NUMBER equal to arm_target_label).    4 -> 0 final_prescan_insn if the `target' unconditional branch is reached           (the target insn is arm_target_insn).     If the jump clobbers the conditions then we use states 2 and 4.     A similar thing can be done with conditional return insns.     XXX In case the `target' is an unconditional branch, this conditionalising    of the instructions always reduces code size, but not always execution    time.  But then, I want to reduce the code size to somewhere near what    /bin/cc produces.  */
end_comment

begin_comment
comment|/* Returns the index of the ARM condition code string in    `arm_condition_codes'.  COMPARISON should be an rtx like    `(eq (...) (...))'.  */
end_comment

begin_function
specifier|static
name|enum
name|arm_cond_code
name|get_arm_condition_code
parameter_list|(
name|rtx
name|comparison
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|code
decl_stmt|;
name|enum
name|rtx_code
name|comp_code
init|=
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_CC
condition|)
name|mode
operator|=
name|SELECT_CC_MODE
argument_list|(
name|comp_code
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|comparison
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|CC_DNEmode
case|:
name|code
operator|=
name|ARM_NE
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DEQmode
case|:
name|code
operator|=
name|ARM_EQ
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGEmode
case|:
name|code
operator|=
name|ARM_GE
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGTmode
case|:
name|code
operator|=
name|ARM_GT
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLEmode
case|:
name|code
operator|=
name|ARM_LE
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLTmode
case|:
name|code
operator|=
name|ARM_LT
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGEUmode
case|:
name|code
operator|=
name|ARM_CS
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DGTUmode
case|:
name|code
operator|=
name|ARM_HI
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLEUmode
case|:
name|code
operator|=
name|ARM_LS
expr_stmt|;
goto|goto
name|dominance
goto|;
case|case
name|CC_DLTUmode
case|:
name|code
operator|=
name|ARM_CC
expr_stmt|;
name|dominance
label|:
name|gcc_assert
argument_list|(
name|comp_code
operator|==
name|EQ
operator|||
name|comp_code
operator|==
name|NE
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_code
operator|==
name|EQ
condition|)
return|return
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|code
argument_list|)
return|;
return|return
name|code
return|;
case|case
name|CC_NOOVmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|GE
case|:
return|return
name|ARM_PL
return|;
case|case
name|LT
case|:
return|return
name|ARM_MI
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|CC_Zmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|CC_Nmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_MI
return|;
case|case
name|EQ
case|:
return|return
name|ARM_PL
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|CCFPEmode
case|:
case|case
name|CCFPmode
case|:
comment|/* These encodings assume that AC=1 in the FPA system control 	 byte.  This allows us to handle all cases except UNEQ and 	 LTGT.  */
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|GE
case|:
return|return
name|ARM_GE
return|;
case|case
name|GT
case|:
return|return
name|ARM_GT
return|;
case|case
name|LE
case|:
return|return
name|ARM_LS
return|;
case|case
name|LT
case|:
return|return
name|ARM_MI
return|;
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|ORDERED
case|:
return|return
name|ARM_VC
return|;
case|case
name|UNORDERED
case|:
return|return
name|ARM_VS
return|;
case|case
name|UNLT
case|:
return|return
name|ARM_LT
return|;
case|case
name|UNLE
case|:
return|return
name|ARM_LE
return|;
case|case
name|UNGT
case|:
return|return
name|ARM_HI
return|;
case|case
name|UNGE
case|:
return|return
name|ARM_PL
return|;
comment|/* UNEQ and LTGT do not have a representation.  */
case|case
name|UNEQ
case|:
comment|/* Fall through.  */
case|case
name|LTGT
case|:
comment|/* Fall through.  */
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|CC_SWPmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|GE
case|:
return|return
name|ARM_LE
return|;
case|case
name|GT
case|:
return|return
name|ARM_LT
return|;
case|case
name|LE
case|:
return|return
name|ARM_GE
return|;
case|case
name|LT
case|:
return|return
name|ARM_GT
return|;
case|case
name|GEU
case|:
return|return
name|ARM_LS
return|;
case|case
name|GTU
case|:
return|return
name|ARM_CC
return|;
case|case
name|LEU
case|:
return|return
name|ARM_CS
return|;
case|case
name|LTU
case|:
return|return
name|ARM_HI
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|CC_Cmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|LTU
case|:
return|return
name|ARM_CS
return|;
case|case
name|GEU
case|:
return|return
name|ARM_CC
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|CCmode
case|:
switch|switch
condition|(
name|comp_code
condition|)
block|{
case|case
name|NE
case|:
return|return
name|ARM_NE
return|;
case|case
name|EQ
case|:
return|return
name|ARM_EQ
return|;
case|case
name|GE
case|:
return|return
name|ARM_GE
return|;
case|case
name|GT
case|:
return|return
name|ARM_GT
return|;
case|case
name|LE
case|:
return|return
name|ARM_LE
return|;
case|case
name|LT
case|:
return|return
name|ARM_LT
return|;
case|case
name|GEU
case|:
return|return
name|ARM_CS
return|;
case|case
name|GTU
case|:
return|return
name|ARM_HI
return|;
case|case
name|LEU
case|:
return|return
name|ARM_LS
return|;
case|case
name|LTU
case|:
return|return
name|ARM_CC
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|arm_final_prescan_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
comment|/* BODY will hold the body of INSN.  */
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* This will be 1 if trying to repeat the trick, and things need to be      reversed if it appears to fail.  */
name|int
name|reverse
init|=
literal|0
decl_stmt|;
comment|/* JUMP_CLOBBERS will be one implies that the conditions if a branch is      taken are clobbered, even if the rtl suggests otherwise.  It also      means that we have to grub around within the jump expression to find      out what the conditions are when the jump isn't taken.  */
name|int
name|jump_clobbers
init|=
literal|0
decl_stmt|;
comment|/* If we start with a return insn, we only succeed if we find another one.  */
name|int
name|seeking_return
init|=
literal|0
decl_stmt|;
comment|/* START_INSN will hold the insn from where we start looking.  This is the      first insn after the following code_label if REVERSE is true.  */
name|rtx
name|start_insn
init|=
name|insn
decl_stmt|;
comment|/* If in state 4, check if the target branch is reached, in order to      change back to state 0.  */
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|insn
operator|==
name|arm_target_insn
condition|)
block|{
name|arm_target_insn
operator|=
name|NULL
expr_stmt|;
name|arm_ccfsm_state
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
comment|/* If in state 3, it is possible to repeat the trick, if this insn is an      unconditional branch to a label, and immediately following this branch      is the previous target label which is only used once, and the label this      branch jumps to is not too far off.  */
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
comment|/* XXX Isn't this always a barrier?  */
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|CODE_LABEL_NUMBER
argument_list|(
name|start_insn
argument_list|)
operator|==
name|arm_target_label
operator|&&
name|LABEL_NUSES
argument_list|(
name|start_insn
argument_list|)
operator|==
literal|1
condition|)
name|reverse
operator|=
name|TRUE
expr_stmt|;
else|else
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|start_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|start_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start_insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|CODE_LABEL_NUMBER
argument_list|(
name|start_insn
argument_list|)
operator|==
name|arm_target_label
operator|&&
name|LABEL_NUSES
argument_list|(
name|start_insn
argument_list|)
operator|==
literal|1
condition|)
block|{
name|reverse
operator|=
name|TRUE
expr_stmt|;
name|seeking_return
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return;
block|}
else|else
return|return;
block|}
name|gcc_assert
argument_list|(
operator|!
name|arm_ccfsm_state
operator|||
name|reverse
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
return|return;
comment|/* This jump might be paralleled with a clobber of the condition codes      the jump should always come first */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|body
operator|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|reverse
operator|||
operator|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|PC
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|)
condition|)
block|{
name|int
name|insns_skipped
decl_stmt|;
name|int
name|fail
init|=
name|FALSE
decl_stmt|,
name|succeed
init|=
name|FALSE
decl_stmt|;
comment|/* Flag which part of the IF_THEN_ELSE is the LABEL_REF.  */
name|int
name|then_not_else
init|=
name|TRUE
decl_stmt|;
name|rtx
name|this_insn
init|=
name|start_insn
decl_stmt|,
name|label
init|=
literal|0
decl_stmt|;
comment|/* If the jump cannot be done with one instruction, we cannot 	 conditionally execute the instruction in the inverse case.  */
if|if
condition|(
name|get_attr_conds
argument_list|(
name|insn
argument_list|)
operator|==
name|CONDS_JUMP_CLOB
condition|)
block|{
name|jump_clobbers
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Register the insn jumped to.  */
if|if
condition|(
name|reverse
condition|)
block|{
if|if
condition|(
operator|!
name|seeking_return
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|label
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|then_not_else
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
name|seeking_return
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|RETURN
condition|)
block|{
name|seeking_return
operator|=
literal|1
expr_stmt|;
name|then_not_else
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
comment|/* See how many insns this branch skips, and what kind of insns.  If all 	 insns are okay, and the label or unconditional branch to the same 	 label is not too far away, succeed.  */
for|for
control|(
name|insns_skipped
operator|=
literal|0
init|;
operator|!
name|fail
operator|&&
operator|!
name|succeed
operator|&&
name|insns_skipped
operator|++
operator|<
name|max_insns_skipped
condition|;
control|)
block|{
name|rtx
name|scanbody
decl_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|this_insn
condition|)
break|break;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
condition|)
block|{
case|case
name|CODE_LABEL
case|:
comment|/* Succeed if it is the target label, otherwise fail since 		 control falls in from somewhere else.  */
if|if
condition|(
name|this_insn
operator|==
name|label
condition|)
block|{
if|if
condition|(
name|jump_clobbers
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_ccfsm_state
operator|=
literal|1
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|BARRIER
case|:
comment|/* Succeed if the following insn is the target label. 		 Otherwise fail. 		 If return insns are used then the last insn in a function 		 will be a barrier.  */
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|&&
name|this_insn
operator|==
name|label
condition|)
block|{
if|if
condition|(
name|jump_clobbers
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_ccfsm_state
operator|=
literal|1
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CALL_INSN
case|:
comment|/* The AAPCS says that conditional calls should not be 		 used since they make interworking inefficient (the 		 linker can't transform BL<cond> into BLX).  That's 		 only a problem if the machine has BLX.  */
if|if
condition|(
name|arm_arch5
condition|)
block|{
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Succeed if the following insn is the target label, or 		 if the following two insns are a barrier and the 		 target label.  */
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|&&
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_insn
operator|&&
name|this_insn
operator|==
name|label
operator|&&
name|insns_skipped
operator|<
name|max_insns_skipped
condition|)
block|{
if|if
condition|(
name|jump_clobbers
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
block|}
else|else
name|arm_ccfsm_state
operator|=
literal|1
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
comment|/* If this is an unconditional branch to the same label, succeed. 		 If it is to another label, do nothing.  If it is conditional, 		 fail.  */
comment|/* XXX Probably, the tests for SET and the PC are 		 unnecessary.  */
name|scanbody
operator|=
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|label
operator|&&
operator|!
name|reverse
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|scanbody
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Fail if a conditional return is undesirable (e.g. on a 		 StrongARM), but still allow this if optimizing for size.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|RETURN
operator|&&
operator|!
name|use_return_insn
argument_list|(
name|TRUE
argument_list|,
name|NULL
argument_list|)
operator|&&
operator|!
name|optimize_size
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|RETURN
operator|&&
name|seeking_return
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|2
expr_stmt|;
name|succeed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
switch|switch
condition|(
name|get_attr_conds
argument_list|(
name|this_insn
argument_list|)
condition|)
block|{
case|case
name|CONDS_NOCOND
case|:
break|break;
default|default:
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
else|else
name|fail
operator|=
name|TRUE
expr_stmt|;
comment|/* Unrecognized jump (e.g. epilogue).  */
break|break;
case|case
name|INSN
case|:
comment|/* Instructions using or affecting the condition codes make it 		 fail.  */
name|scanbody
operator|=
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|SET
operator|||
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|==
name|PARALLEL
operator|)
operator|||
name|get_attr_conds
argument_list|(
name|this_insn
argument_list|)
operator|!=
name|CONDS_NOCOND
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
comment|/* A conditional cirrus instruction must be followed by 		 a non Cirrus instruction.  However, since we 		 conditionalize instructions in this function and by 		 the time we get here we can't add instructions 		 (nops), because shorten_branches() has already been 		 called, we will disable conditionalizing Cirrus 		 instructions to be safe.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|!=
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|scanbody
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|get_attr_cirrus
argument_list|(
name|this_insn
argument_list|)
operator|!=
name|CIRRUS_NOT
condition|)
name|fail
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|succeed
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|seeking_return
operator|)
operator|&&
operator|(
name|arm_ccfsm_state
operator|==
literal|1
operator|||
name|reverse
operator|)
condition|)
name|arm_target_label
operator|=
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|seeking_return
operator|||
name|arm_ccfsm_state
operator|==
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|this_insn
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_insn
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
block|{
name|this_insn
operator|=
name|next_nonnote_insn
argument_list|(
name|this_insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|this_insn
operator|||
operator|(
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
operator|!=
name|BARRIER
operator|&&
name|GET_CODE
argument_list|(
name|this_insn
argument_list|)
operator|!=
name|CODE_LABEL
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|this_insn
condition|)
block|{
comment|/* Oh, dear! we ran off the end.. give up.  */
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|arm_ccfsm_state
operator|=
literal|0
expr_stmt|;
name|arm_target_insn
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|arm_target_insn
operator|=
name|this_insn
expr_stmt|;
block|}
if|if
condition|(
name|jump_clobbers
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|reverse
argument_list|)
expr_stmt|;
name|arm_current_cc
operator|=
name|get_arm_condition_code
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|AND
condition|)
name|arm_current_cc
operator|=
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|arm_current_cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|NE
condition|)
name|arm_current_cc
operator|=
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|arm_current_cc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If REVERSE is true, ARM_CURRENT_CC needs to be inverted from 		 what it was.  */
if|if
condition|(
operator|!
name|reverse
condition|)
name|arm_current_cc
operator|=
name|get_arm_condition_code
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|body
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reverse
operator|||
name|then_not_else
condition|)
name|arm_current_cc
operator|=
name|ARM_INVERSE_CONDITION_CODE
argument_list|(
name|arm_current_cc
argument_list|)
expr_stmt|;
block|}
comment|/* Restore recog_data (getting the attributes of other insns can 	 destroy this array, but final.c assumes that it remains intact 	 across this call; since the insn has been recognized already we 	 call recog direct).  */
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns true if REGNO is a valid register    for holding a quantity of type MODE.  */
end_comment

begin_function
name|int
name|arm_hard_regno_mode_ok
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
condition|)
return|return
operator|(
name|regno
operator|==
name|CC_REGNUM
operator|||
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_VFP
operator|&&
name|regno
operator|==
name|VFPCC_REGNUM
operator|)
operator|)
return|;
if|if
condition|(
name|TARGET_THUMB
condition|)
comment|/* For the Thumb we only allow values bigger than SImode in        registers 0 - 6, so that there is always a second low        register available to hold the upper part of the value.        We probably we ought to ensure that the register is the        start of an even numbered register pair.  */
return|return
operator|(
name|ARM_NUM_REGS
argument_list|(
name|mode
argument_list|)
operator|<
literal|2
operator|)
operator|||
operator|(
name|regno
operator|<
name|LAST_LO_REGNUM
operator|)
return|;
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_MAVERICK
operator|&&
name|IS_CIRRUS_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
comment|/* We have outlawed SI values in Cirrus registers because they        reside in the lower 32 bits, but SF values reside in the        upper 32 bits.  This causes gcc all sorts of grief.  We can't        even split the registers into pairs because Cirrus SI values        get sign extended to 64bits-- aldyh.  */
return|return
operator|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|)
operator|||
operator|(
name|mode
operator|==
name|DImode
operator|)
return|;
if|if
condition|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_VFP
operator|&&
name|IS_VFP_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|SFmode
operator|||
name|mode
operator|==
name|SImode
condition|)
return|return
name|TRUE
return|;
comment|/* DFmode values are only valid in even register pairs.  */
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
return|return
operator|(
operator|(
name|regno
operator|-
name|FIRST_VFP_REGNUM
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
return|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|TARGET_REALLY_IWMMXT
condition|)
block|{
if|if
condition|(
name|IS_IWMMXT_GR_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|mode
operator|==
name|SImode
return|;
if|if
condition|(
name|IS_IWMMXT_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|VALID_IWMMXT_REG_MODE
argument_list|(
name|mode
argument_list|)
return|;
block|}
comment|/* We allow any value to be stored in the general registers.      Restrict doubleword quantities to even register pairs so that we can      use ldrd.  */
if|if
condition|(
name|regno
operator|<=
name|LAST_ARM_REGNUM
condition|)
return|return
operator|!
operator|(
name|TARGET_LDRD
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|>
literal|4
operator|&&
operator|(
name|regno
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|)
return|;
if|if
condition|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
condition|)
comment|/* We only allow integers in the fake hard registers.  */
return|return
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
return|;
comment|/* The only registers left are the FPA registers      which we only allow to hold FP values.  */
return|return
operator|(
name|TARGET_HARD_FLOAT
operator|&&
name|TARGET_FPA
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
operator|&&
name|regno
operator|>=
name|FIRST_FPA_REGNUM
operator|&&
name|regno
operator|<=
name|LAST_FPA_REGNUM
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arm_regno_class
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
name|STACK_REG
return|;
if|if
condition|(
name|regno
operator|==
name|CC_REGNUM
condition|)
return|return
name|CC_REG
return|;
if|if
condition|(
name|regno
operator|<
literal|8
condition|)
return|return
name|LO_REGS
return|;
return|return
name|HI_REGS
return|;
block|}
if|if
condition|(
name|regno
operator|<=
name|LAST_ARM_REGNUM
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|ARG_POINTER_REGNUM
condition|)
return|return
name|GENERAL_REGS
return|;
if|if
condition|(
name|regno
operator|==
name|CC_REGNUM
operator|||
name|regno
operator|==
name|VFPCC_REGNUM
condition|)
return|return
name|NO_REGS
return|;
if|if
condition|(
name|IS_CIRRUS_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|CIRRUS_REGS
return|;
if|if
condition|(
name|IS_VFP_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|VFP_REGS
return|;
if|if
condition|(
name|IS_IWMMXT_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|IWMMXT_REGS
return|;
if|if
condition|(
name|IS_IWMMXT_GR_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
name|IWMMXT_GR_REGS
return|;
return|return
name|FPA_REGS
return|;
block|}
end_function

begin_comment
comment|/* Handle a special case when computing the offset    of an argument from the frame pointer.  */
end_comment

begin_function
name|int
name|arm_debugger_arg_offset
parameter_list|(
name|int
name|value
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* We are only interested if dbxout_parms() failed to compute the offset.  */
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We can only cope with the case where the address is held in a register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
condition|)
return|return
literal|0
return|;
comment|/* If we are using the frame pointer to point at the argument, then      an offset of 0 is correct.  */
if|if
condition|(
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|HARD_FRAME_POINTER_REGNUM
condition|)
return|return
literal|0
return|;
comment|/* If we are using the stack pointer to point at the      argument, then an offset of 0 is correct.  */
if|if
condition|(
operator|(
name|TARGET_THUMB
operator|||
operator|!
name|frame_pointer_needed
operator|)
operator|&&
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|==
name|SP_REGNUM
condition|)
return|return
literal|0
return|;
comment|/* Oh dear.  The argument is pointed to by a register rather      than being held in a register, or being stored at a known      offset from the frame pointer.  Since GDB only understands      those two kinds of argument we must translate the address      held in the register into an offset from the frame pointer.      We do this by searching through the insns for the function      looking to see where this register gets its value.  If the      register is initialized from the frame pointer plus an offset      then we are in luck and we can continue, otherwise we give up.       This code is exercised by producing debugging information      for a function with arguments like this:             double func (double a, double b, int c, double d) {return d;}       Without this code the stab for parameter 'd' will be set to      an offset of 0 from the frame pointer, rather than 8.  */
comment|/* The if() statement says:       If the insn is a normal instruction      and if the insn is setting the value in a register      and if the register being set is the register holding the address of the argument      and if the address is computing by an addition      that involves adding to a register      which is the frame pointer      a constant integer       then...  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|addr
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|debug_rtx
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"unable to compute real location of stacked parameter"
argument_list|)
expr_stmt|;
name|value
operator|=
literal|8
expr_stmt|;
comment|/* XXX magic hack */
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|def_mbuiltin
parameter_list|(
name|MASK
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|CODE
parameter_list|)
define|\
value|do									\     {									\       if ((MASK)& insn_flags)						\         lang_hooks.builtin_function ((NAME), (TYPE), (CODE),		\ 				     BUILT_IN_MD, NULL, NULL_TREE);	\     }									\   while (0)
end_define

begin_struct
struct|struct
name|builtin_description
block|{
specifier|const
name|unsigned
name|int
name|mask
decl_stmt|;
specifier|const
name|enum
name|insn_code
name|icode
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|enum
name|arm_builtins
name|code
decl_stmt|;
specifier|const
name|enum
name|rtx_code
name|comparison
decl_stmt|;
specifier|const
name|unsigned
name|int
name|flag
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_2arg
index|[]
init|=
block|{
define|#
directive|define
name|IWMMXT_BUILTIN
parameter_list|(
name|code
parameter_list|,
name|string
parameter_list|,
name|builtin
parameter_list|)
define|\
value|{ FL_IWMMXT, CODE_FOR_##code, "__builtin_arm_" string, \     ARM_BUILTIN_##builtin, 0, 0 },
name|IWMMXT_BUILTIN
argument_list|(
argument|addv8qi3
argument_list|,
literal|"waddb"
argument_list|,
argument|WADDB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|addv4hi3
argument_list|,
literal|"waddh"
argument_list|,
argument|WADDH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|addv2si3
argument_list|,
literal|"waddw"
argument_list|,
argument|WADDW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|subv8qi3
argument_list|,
literal|"wsubb"
argument_list|,
argument|WSUBB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|subv4hi3
argument_list|,
literal|"wsubh"
argument_list|,
argument|WSUBH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|subv2si3
argument_list|,
literal|"wsubw"
argument_list|,
argument|WSUBW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ssaddv8qi3
argument_list|,
literal|"waddbss"
argument_list|,
argument|WADDSSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ssaddv4hi3
argument_list|,
literal|"waddhss"
argument_list|,
argument|WADDSSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ssaddv2si3
argument_list|,
literal|"waddwss"
argument_list|,
argument|WADDSSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sssubv8qi3
argument_list|,
literal|"wsubbss"
argument_list|,
argument|WSUBSSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sssubv4hi3
argument_list|,
literal|"wsubhss"
argument_list|,
argument|WSUBSSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sssubv2si3
argument_list|,
literal|"wsubwss"
argument_list|,
argument|WSUBSSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|usaddv8qi3
argument_list|,
literal|"waddbus"
argument_list|,
argument|WADDUSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|usaddv4hi3
argument_list|,
literal|"waddhus"
argument_list|,
argument|WADDUSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|usaddv2si3
argument_list|,
literal|"waddwus"
argument_list|,
argument|WADDUSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ussubv8qi3
argument_list|,
literal|"wsubbus"
argument_list|,
argument|WSUBUSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ussubv4hi3
argument_list|,
literal|"wsubhus"
argument_list|,
argument|WSUBUSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|ussubv2si3
argument_list|,
literal|"wsubwus"
argument_list|,
argument|WSUBUSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|mulv4hi3
argument_list|,
literal|"wmulul"
argument_list|,
argument|WMULUL
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|smulv4hi3_highpart
argument_list|,
literal|"wmulsm"
argument_list|,
argument|WMULSM
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|umulv4hi3_highpart
argument_list|,
literal|"wmulum"
argument_list|,
argument|WMULUM
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|eqv8qi3
argument_list|,
literal|"wcmpeqb"
argument_list|,
argument|WCMPEQB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|eqv4hi3
argument_list|,
literal|"wcmpeqh"
argument_list|,
argument|WCMPEQH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|eqv2si3
argument_list|,
literal|"wcmpeqw"
argument_list|,
argument|WCMPEQW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtuv8qi3
argument_list|,
literal|"wcmpgtub"
argument_list|,
argument|WCMPGTUB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtuv4hi3
argument_list|,
literal|"wcmpgtuh"
argument_list|,
argument|WCMPGTUH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtuv2si3
argument_list|,
literal|"wcmpgtuw"
argument_list|,
argument|WCMPGTUW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtv8qi3
argument_list|,
literal|"wcmpgtsb"
argument_list|,
argument|WCMPGTSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtv4hi3
argument_list|,
literal|"wcmpgtsh"
argument_list|,
argument|WCMPGTSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|gtv2si3
argument_list|,
literal|"wcmpgtsw"
argument_list|,
argument|WCMPGTSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|umaxv8qi3
argument_list|,
literal|"wmaxub"
argument_list|,
argument|WMAXUB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|smaxv8qi3
argument_list|,
literal|"wmaxsb"
argument_list|,
argument|WMAXSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|umaxv4hi3
argument_list|,
literal|"wmaxuh"
argument_list|,
argument|WMAXUH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|smaxv4hi3
argument_list|,
literal|"wmaxsh"
argument_list|,
argument|WMAXSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|umaxv2si3
argument_list|,
literal|"wmaxuw"
argument_list|,
argument|WMAXUW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|smaxv2si3
argument_list|,
literal|"wmaxsw"
argument_list|,
argument|WMAXSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|uminv8qi3
argument_list|,
literal|"wminub"
argument_list|,
argument|WMINUB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sminv8qi3
argument_list|,
literal|"wminsb"
argument_list|,
argument|WMINSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|uminv4hi3
argument_list|,
literal|"wminuh"
argument_list|,
argument|WMINUH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sminv4hi3
argument_list|,
literal|"wminsh"
argument_list|,
argument|WMINSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|uminv2si3
argument_list|,
literal|"wminuw"
argument_list|,
argument|WMINUW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|sminv2si3
argument_list|,
literal|"wminsw"
argument_list|,
argument|WMINSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_anddi3
argument_list|,
literal|"wand"
argument_list|,
argument|WAND
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_nanddi3
argument_list|,
literal|"wandn"
argument_list|,
argument|WANDN
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_iordi3
argument_list|,
literal|"wor"
argument_list|,
argument|WOR
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_xordi3
argument_list|,
literal|"wxor"
argument_list|,
argument|WXOR
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_uavgv8qi3
argument_list|,
literal|"wavg2b"
argument_list|,
argument|WAVG2B
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_uavgv4hi3
argument_list|,
literal|"wavg2h"
argument_list|,
argument|WAVG2H
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_uavgrndv8qi3
argument_list|,
literal|"wavg2br"
argument_list|,
argument|WAVG2BR
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_uavgrndv4hi3
argument_list|,
literal|"wavg2hr"
argument_list|,
argument|WAVG2HR
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckilb
argument_list|,
literal|"wunpckilb"
argument_list|,
argument|WUNPCKILB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckilh
argument_list|,
literal|"wunpckilh"
argument_list|,
argument|WUNPCKILH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckilw
argument_list|,
literal|"wunpckilw"
argument_list|,
argument|WUNPCKILW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckihb
argument_list|,
literal|"wunpckihb"
argument_list|,
argument|WUNPCKIHB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckihh
argument_list|,
literal|"wunpckihh"
argument_list|,
argument|WUNPCKIHH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckihw
argument_list|,
literal|"wunpckihw"
argument_list|,
argument|WUNPCKIHW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wmadds
argument_list|,
literal|"wmadds"
argument_list|,
argument|WMADDS
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wmaddu
argument_list|,
literal|"wmaddu"
argument_list|,
argument|WMADDU
argument_list|)
define|#
directive|define
name|IWMMXT_BUILTIN2
parameter_list|(
name|code
parameter_list|,
name|builtin
parameter_list|)
define|\
value|{ FL_IWMMXT, CODE_FOR_##code, NULL, ARM_BUILTIN_##builtin, 0, 0 },
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackhss
argument_list|,
argument|WPACKHSS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackwss
argument_list|,
argument|WPACKWSS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackdss
argument_list|,
argument|WPACKDSS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackhus
argument_list|,
argument|WPACKHUS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackwus
argument_list|,
argument|WPACKWUS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wpackdus
argument_list|,
argument|WPACKDUS
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashlv4hi3_di
argument_list|,
argument|WSLLH
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashlv4hi3
argument_list|,
argument|WSLLHI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashlv2si3_di
argument_list|,
argument|WSLLW
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashlv2si3
argument_list|,
argument|WSLLWI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashldi3_di
argument_list|,
argument|WSLLD
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashldi3_iwmmxt
argument_list|,
argument|WSLLDI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrv4hi3_di
argument_list|,
argument|WSRLH
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrv4hi3
argument_list|,
argument|WSRLHI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrv2si3_di
argument_list|,
argument|WSRLW
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrv2si3
argument_list|,
argument|WSRLWI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrdi3_di
argument_list|,
argument|WSRLD
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|lshrdi3_iwmmxt
argument_list|,
argument|WSRLDI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrv4hi3_di
argument_list|,
argument|WSRAH
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrv4hi3
argument_list|,
argument|WSRAHI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrv2si3_di
argument_list|,
argument|WSRAW
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrv2si3
argument_list|,
argument|WSRAWI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrdi3_di
argument_list|,
argument|WSRAD
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|ashrdi3_iwmmxt
argument_list|,
argument|WSRADI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rorv4hi3_di
argument_list|,
argument|WRORH
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rorv4hi3
argument_list|,
argument|WRORHI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rorv2si3_di
argument_list|,
argument|WRORW
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rorv2si3
argument_list|,
argument|WRORWI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rordi3_di
argument_list|,
argument|WRORD
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|rordi3
argument_list|,
argument|WRORDI
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wmacuz
argument_list|,
argument|WMACUZ
argument_list|)
name|IWMMXT_BUILTIN2
argument_list|(
argument|iwmmxt_wmacsz
argument_list|,
argument|WMACSZ
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|builtin_description
name|bdesc_1arg
index|[]
init|=
block|{
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_tmovmskb
argument_list|,
literal|"tmovmskb"
argument_list|,
argument|TMOVMSKB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_tmovmskh
argument_list|,
literal|"tmovmskh"
argument_list|,
argument|TMOVMSKH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_tmovmskw
argument_list|,
literal|"tmovmskw"
argument_list|,
argument|TMOVMSKW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_waccb
argument_list|,
literal|"waccb"
argument_list|,
argument|WACCB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wacch
argument_list|,
literal|"wacch"
argument_list|,
argument|WACCH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_waccw
argument_list|,
literal|"waccw"
argument_list|,
argument|WACCW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehub
argument_list|,
literal|"wunpckehub"
argument_list|,
argument|WUNPCKEHUB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehuh
argument_list|,
literal|"wunpckehuh"
argument_list|,
argument|WUNPCKEHUH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehuw
argument_list|,
literal|"wunpckehuw"
argument_list|,
argument|WUNPCKEHUW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehsb
argument_list|,
literal|"wunpckehsb"
argument_list|,
argument|WUNPCKEHSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehsh
argument_list|,
literal|"wunpckehsh"
argument_list|,
argument|WUNPCKEHSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckehsw
argument_list|,
literal|"wunpckehsw"
argument_list|,
argument|WUNPCKEHSW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckelub
argument_list|,
literal|"wunpckelub"
argument_list|,
argument|WUNPCKELUB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckeluh
argument_list|,
literal|"wunpckeluh"
argument_list|,
argument|WUNPCKELUH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckeluw
argument_list|,
literal|"wunpckeluw"
argument_list|,
argument|WUNPCKELUW
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckelsb
argument_list|,
literal|"wunpckelsb"
argument_list|,
argument|WUNPCKELSB
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckelsh
argument_list|,
literal|"wunpckelsh"
argument_list|,
argument|WUNPCKELSH
argument_list|)
name|IWMMXT_BUILTIN
argument_list|(
argument|iwmmxt_wunpckelsw
argument_list|,
literal|"wunpckelsw"
argument_list|,
argument|WUNPCKELSW
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up all the iWMMXt builtins.  This is    not called if TARGET_IWMMXT is zero.  */
end_comment

begin_function
specifier|static
name|void
name|arm_init_iwmmxt_builtins
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|tree
name|endlink
init|=
name|void_list_node
decl_stmt|;
name|tree
name|V2SI_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|intSI_type_node
argument_list|,
name|V2SImode
argument_list|)
decl_stmt|;
name|tree
name|V4HI_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|intHI_type_node
argument_list|,
name|V4HImode
argument_list|)
decl_stmt|;
name|tree
name|V8QI_type_node
init|=
name|build_vector_type_for_mode
argument_list|(
name|intQI_type_node
argument_list|,
name|V8QImode
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_int
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8qi_ftype_v8qi_v8qi_int
init|=
name|build_function_type
argument_list|(
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_int
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_int
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_di_di
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_int
init|=
name|build_function_type
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_int_int
init|=
name|build_function_type
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v8qi
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4hi
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v2si
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v8qi_int
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v4hi_int
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|int_ftype_v2si_int
init|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v8qi_ftype_v8qi_int_int
init|=
name|build_function_type
argument_list|(
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_int_int
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_int_int
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Miscellaneous.  */
name|tree
name|v8qi_ftype_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v2si_v2si
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v8qi_v8qi
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_di
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_di
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|void_ftype_int_int
init|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_void
init|=
name|build_function_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|endlink
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v8qi
init|=
name|build_function_type
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v4hi
init|=
name|build_function_type
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v2si
init|=
name|build_function_type
argument_list|(
name|long_long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v4hi
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v8qi
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Normal vector binops.  */
name|tree
name|v8qi_ftype_v8qi_v8qi
init|=
name|build_function_type
argument_list|(
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V8QI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v4hi_ftype_v4hi_v4hi
init|=
name|build_function_type
argument_list|(
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V4HI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|v2si_ftype_v2si_v2si
init|=
name|build_function_type
argument_list|(
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|V2SI_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|di_ftype_di_di
init|=
name|build_function_type
argument_list|(
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_long_unsigned_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Add all builtins that are more or less simple operations on two      operands.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
comment|/* Use one of the operands; the target can have a different mode for 	 mask-generating compares.  */
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|==
literal|0
condition|)
continue|continue;
name|mode
operator|=
name|insn_data
index|[
name|d
operator|->
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V8QImode
case|:
name|type
operator|=
name|v8qi_ftype_v8qi_v8qi
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|type
operator|=
name|v4hi_ftype_v4hi_v4hi
expr_stmt|;
break|break;
case|case
name|V2SImode
case|:
name|type
operator|=
name|v2si_ftype_v2si_v2si
expr_stmt|;
break|break;
case|case
name|DImode
case|:
name|type
operator|=
name|di_ftype_di_di
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|def_mbuiltin
argument_list|(
name|d
operator|->
name|mask
argument_list|,
name|d
operator|->
name|name
argument_list|,
name|type
argument_list|,
name|d
operator|->
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* Add the remaining MMX insns with somewhat more complicated types.  */
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wzero"
argument_list|,
name|di_ftype_void
argument_list|,
name|ARM_BUILTIN_WZERO
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_setwcx"
argument_list|,
name|void_ftype_int_int
argument_list|,
name|ARM_BUILTIN_SETWCX
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_getwcx"
argument_list|,
name|int_ftype_int
argument_list|,
name|ARM_BUILTIN_GETWCX
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsllh"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|ARM_BUILTIN_WSLLH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsllw"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|ARM_BUILTIN_WSLLW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wslld"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WSLLD
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsllhi"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_WSLLHI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsllwi"
argument_list|,
name|v2si_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_WSLLWI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wslldi"
argument_list|,
name|di_ftype_di_int
argument_list|,
name|ARM_BUILTIN_WSLLDI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrlh"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|ARM_BUILTIN_WSRLH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrlw"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|ARM_BUILTIN_WSRLW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrld"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WSRLD
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrlhi"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_WSRLHI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrlwi"
argument_list|,
name|v2si_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_WSRLWI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrldi"
argument_list|,
name|di_ftype_di_int
argument_list|,
name|ARM_BUILTIN_WSRLDI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrah"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|ARM_BUILTIN_WSRAH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsraw"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|ARM_BUILTIN_WSRAW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrad"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WSRAD
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrahi"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_WSRAHI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsrawi"
argument_list|,
name|v2si_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_WSRAWI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsradi"
argument_list|,
name|di_ftype_di_int
argument_list|,
name|ARM_BUILTIN_WSRADI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrorh"
argument_list|,
name|v4hi_ftype_v4hi_di
argument_list|,
name|ARM_BUILTIN_WRORH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrorw"
argument_list|,
name|v2si_ftype_v2si_di
argument_list|,
name|ARM_BUILTIN_WRORW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrord"
argument_list|,
name|di_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WRORD
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrorhi"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_WRORHI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrorwi"
argument_list|,
name|v2si_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_WRORWI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wrordi"
argument_list|,
name|di_ftype_di_int
argument_list|,
name|ARM_BUILTIN_WRORDI
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wshufh"
argument_list|,
name|v4hi_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_WSHUFH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsadb"
argument_list|,
name|v2si_ftype_v8qi_v8qi
argument_list|,
name|ARM_BUILTIN_WSADB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsadh"
argument_list|,
name|v2si_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WSADH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsadbz"
argument_list|,
name|v2si_ftype_v8qi_v8qi
argument_list|,
name|ARM_BUILTIN_WSADBZ
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wsadhz"
argument_list|,
name|v2si_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WSADHZ
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmsb"
argument_list|,
name|int_ftype_v8qi_int
argument_list|,
name|ARM_BUILTIN_TEXTRMSB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmsh"
argument_list|,
name|int_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_TEXTRMSH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmsw"
argument_list|,
name|int_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_TEXTRMSW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmub"
argument_list|,
name|int_ftype_v8qi_int
argument_list|,
name|ARM_BUILTIN_TEXTRMUB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmuh"
argument_list|,
name|int_ftype_v4hi_int
argument_list|,
name|ARM_BUILTIN_TEXTRMUH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_textrmuw"
argument_list|,
name|int_ftype_v2si_int
argument_list|,
name|ARM_BUILTIN_TEXTRMUW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tinsrb"
argument_list|,
name|v8qi_ftype_v8qi_int_int
argument_list|,
name|ARM_BUILTIN_TINSRB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tinsrh"
argument_list|,
name|v4hi_ftype_v4hi_int_int
argument_list|,
name|ARM_BUILTIN_TINSRH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tinsrw"
argument_list|,
name|v2si_ftype_v2si_int_int
argument_list|,
name|ARM_BUILTIN_TINSRW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_waccb"
argument_list|,
name|di_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_WACCB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wacch"
argument_list|,
name|di_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_WACCH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_waccw"
argument_list|,
name|di_ftype_v2si
argument_list|,
name|ARM_BUILTIN_WACCW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmovmskb"
argument_list|,
name|int_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_TMOVMSKB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmovmskh"
argument_list|,
name|int_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_TMOVMSKH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmovmskw"
argument_list|,
name|int_ftype_v2si
argument_list|,
name|ARM_BUILTIN_TMOVMSKW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackhss"
argument_list|,
name|v8qi_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WPACKHSS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackhus"
argument_list|,
name|v8qi_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WPACKHUS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackwus"
argument_list|,
name|v4hi_ftype_v2si_v2si
argument_list|,
name|ARM_BUILTIN_WPACKWUS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackwss"
argument_list|,
name|v4hi_ftype_v2si_v2si
argument_list|,
name|ARM_BUILTIN_WPACKWSS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackdus"
argument_list|,
name|v2si_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WPACKDUS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wpackdss"
argument_list|,
name|v2si_ftype_di_di
argument_list|,
name|ARM_BUILTIN_WPACKDSS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehub"
argument_list|,
name|v4hi_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_WUNPCKEHUB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehuh"
argument_list|,
name|v2si_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_WUNPCKEHUH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehuw"
argument_list|,
name|di_ftype_v2si
argument_list|,
name|ARM_BUILTIN_WUNPCKEHUW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehsb"
argument_list|,
name|v4hi_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_WUNPCKEHSB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehsh"
argument_list|,
name|v2si_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_WUNPCKEHSH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckehsw"
argument_list|,
name|di_ftype_v2si
argument_list|,
name|ARM_BUILTIN_WUNPCKEHSW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckelub"
argument_list|,
name|v4hi_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_WUNPCKELUB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckeluh"
argument_list|,
name|v2si_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_WUNPCKELUH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckeluw"
argument_list|,
name|di_ftype_v2si
argument_list|,
name|ARM_BUILTIN_WUNPCKELUW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckelsb"
argument_list|,
name|v4hi_ftype_v8qi
argument_list|,
name|ARM_BUILTIN_WUNPCKELSB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckelsh"
argument_list|,
name|v2si_ftype_v4hi
argument_list|,
name|ARM_BUILTIN_WUNPCKELSH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wunpckelsw"
argument_list|,
name|di_ftype_v2si
argument_list|,
name|ARM_BUILTIN_WUNPCKELSW
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wmacs"
argument_list|,
name|di_ftype_di_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WMACS
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wmacsz"
argument_list|,
name|di_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WMACSZ
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wmacu"
argument_list|,
name|di_ftype_di_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WMACU
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_wmacuz"
argument_list|,
name|di_ftype_v4hi_v4hi
argument_list|,
name|ARM_BUILTIN_WMACUZ
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_walign"
argument_list|,
name|v8qi_ftype_v8qi_v8qi_int
argument_list|,
name|ARM_BUILTIN_WALIGN
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmia"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIA
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmiaph"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIAPH
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmiabb"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIABB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmiabt"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIABT
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmiatb"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIATB
argument_list|)
expr_stmt|;
name|def_mbuiltin
argument_list|(
name|FL_IWMMXT
argument_list|,
literal|"__builtin_arm_tmiatt"
argument_list|,
name|di_ftype_di_int_int
argument_list|,
name|ARM_BUILTIN_TMIATT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_init_tls_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|ftype
decl_stmt|;
name|tree
name|nothrow
init|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"nothrow"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|tree
name|const_nothrow
init|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"const"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|nothrow
argument_list|)
decl_stmt|;
name|ftype
operator|=
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|builtin_function
argument_list|(
literal|"__builtin_thread_pointer"
argument_list|,
name|ftype
argument_list|,
name|ARM_BUILTIN_THREAD_POINTER
argument_list|,
name|BUILT_IN_MD
argument_list|,
name|NULL
argument_list|,
name|const_nothrow
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_init_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|arm_init_tls_builtins
argument_list|()
expr_stmt|;
if|if
condition|(
name|TARGET_REALLY_IWMMXT
condition|)
name|arm_init_iwmmxt_builtins
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Errors in the source file can cause expand_expr to return const0_rtx    where we expect a vector.  To avoid crashing, use one of the vector    clear instructions.  */
end_comment

begin_function
specifier|static
name|rtx
name|safe_vector_operand
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
name|x
operator|!=
name|const0_rtx
condition|)
return|return
name|x
return|;
name|x
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iwmmxt_clrdi
argument_list|(
name|mode
operator|==
name|DImode
condition|?
name|x
else|:
name|gen_rtx_SUBREG
argument_list|(
name|DImode
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of arm_expand_builtin to take care of binop insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|arm_expand_binop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|tree
name|arg1
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|rtx
name|op1
init|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode1
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode1
argument_list|)
condition|)
name|op1
operator|=
name|safe_vector_operand
argument_list|(
name|op1
argument_list|,
name|mode1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|mode0
operator|&&
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|==
name|mode1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of arm_expand_builtin to take care of unop insns.  */
end_comment

begin_function
specifier|static
name|rtx
name|arm_expand_unop_builtin
parameter_list|(
name|enum
name|insn_code
name|icode
parameter_list|,
name|tree
name|arglist
parameter_list|,
name|rtx
name|target
parameter_list|,
name|int
name|do_load
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
name|tree
name|arg0
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|rtx
name|op0
init|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|tmode
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
init|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|target
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_load
condition|)
name|op0
operator|=
name|gen_rtx_MEM
argument_list|(
name|mode0
argument_list|,
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode0
argument_list|)
condition|)
name|op0
operator|=
name|safe_vector_operand
argument_list|(
name|op0
argument_list|,
name|mode0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Expand an expression EXP that calls a built-in function,    with result going to TARGET if that's convenient    (and in mode MODE if that's convenient).    SUBTARGET may be used as the target for computing one of EXP's operands.    IGNORE is nonzero if the value is to be ignored.  */
end_comment

begin_function
specifier|static
name|rtx
name|arm_expand_builtin
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|rtx
name|subtarget
name|ATTRIBUTE_UNUSED
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|ignore
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
specifier|const
name|struct
name|builtin_description
modifier|*
name|d
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|arg0
decl_stmt|;
name|tree
name|arg1
decl_stmt|;
name|tree
name|arg2
decl_stmt|;
name|rtx
name|op0
decl_stmt|;
name|rtx
name|op1
decl_stmt|;
name|rtx
name|op2
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|int
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|machine_mode
name|mode0
decl_stmt|;
name|enum
name|machine_mode
name|mode1
decl_stmt|;
name|enum
name|machine_mode
name|mode2
decl_stmt|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|ARM_BUILTIN_TEXTRMSB
case|:
case|case
name|ARM_BUILTIN_TEXTRMUB
case|:
case|case
name|ARM_BUILTIN_TEXTRMSH
case|:
case|case
name|ARM_BUILTIN_TEXTRMUH
case|:
case|case
name|ARM_BUILTIN_TEXTRMSW
case|:
case|case
name|ARM_BUILTIN_TEXTRMUW
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|ARM_BUILTIN_TEXTRMSB
condition|?
name|CODE_FOR_iwmmxt_textrmsb
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TEXTRMUB
condition|?
name|CODE_FOR_iwmmxt_textrmub
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TEXTRMSH
condition|?
name|CODE_FOR_iwmmxt_textrmsh
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TEXTRMUH
condition|?
name|CODE_FOR_iwmmxt_textrmuh
else|:
name|CODE_FOR_iwmmxt_textrmw
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"selector must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ARM_BUILTIN_TINSRB
case|:
case|case
name|ARM_BUILTIN_TINSRH
case|:
case|case
name|ARM_BUILTIN_TINSRW
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|ARM_BUILTIN_TINSRB
condition|?
name|CODE_FOR_iwmmxt_tinsrb
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TINSRH
condition|?
name|CODE_FOR_iwmmxt_tinsrh
else|:
name|CODE_FOR_iwmmxt_tinsrw
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_normal
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"selector must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ARM_BUILTIN_SETWCX
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|force_reg
argument_list|(
name|SImode
argument_list|,
name|expand_normal
argument_list|(
name|arg0
argument_list|)
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iwmmxt_tmcr
argument_list|(
name|op1
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ARM_BUILTIN_GETWCX
case|:
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iwmmxt_tmrc
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ARM_BUILTIN_WSHUFH
case|:
name|icode
operator|=
name|CODE_FOR_iwmmxt_wshufh
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode1
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode2
operator|)
condition|)
block|{
comment|/* @@@ better error message */
name|error
argument_list|(
literal|"mask must be an immediate"
argument_list|)
expr_stmt|;
return|return
name|const0_rtx
return|;
block|}
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ARM_BUILTIN_WSADB
case|:
return|return
name|arm_expand_binop_builtin
argument_list|(
name|CODE_FOR_iwmmxt_wsadb
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ARM_BUILTIN_WSADH
case|:
return|return
name|arm_expand_binop_builtin
argument_list|(
name|CODE_FOR_iwmmxt_wsadh
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ARM_BUILTIN_WSADBZ
case|:
return|return
name|arm_expand_binop_builtin
argument_list|(
name|CODE_FOR_iwmmxt_wsadbz
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
case|case
name|ARM_BUILTIN_WSADHZ
case|:
return|return
name|arm_expand_binop_builtin
argument_list|(
name|CODE_FOR_iwmmxt_wsadhz
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
comment|/* Several three-argument builtins.  */
case|case
name|ARM_BUILTIN_WMACS
case|:
case|case
name|ARM_BUILTIN_WMACU
case|:
case|case
name|ARM_BUILTIN_WALIGN
case|:
case|case
name|ARM_BUILTIN_TMIA
case|:
case|case
name|ARM_BUILTIN_TMIAPH
case|:
case|case
name|ARM_BUILTIN_TMIATT
case|:
case|case
name|ARM_BUILTIN_TMIATB
case|:
case|case
name|ARM_BUILTIN_TMIABT
case|:
case|case
name|ARM_BUILTIN_TMIABB
case|:
name|icode
operator|=
operator|(
name|fcode
operator|==
name|ARM_BUILTIN_WMACS
condition|?
name|CODE_FOR_iwmmxt_wmacs
else|:
name|fcode
operator|==
name|ARM_BUILTIN_WMACU
condition|?
name|CODE_FOR_iwmmxt_wmacu
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIA
condition|?
name|CODE_FOR_iwmmxt_tmia
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIAPH
condition|?
name|CODE_FOR_iwmmxt_tmiaph
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIABB
condition|?
name|CODE_FOR_iwmmxt_tmiabb
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIABT
condition|?
name|CODE_FOR_iwmmxt_tmiabt
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIATB
condition|?
name|CODE_FOR_iwmmxt_tmiatb
else|:
name|fcode
operator|==
name|ARM_BUILTIN_TMIATT
condition|?
name|CODE_FOR_iwmmxt_tmiatt
else|:
name|CODE_FOR_iwmmxt_walign
operator|)
expr_stmt|;
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|expand_normal
argument_list|(
name|arg0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_normal
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|op2
operator|=
name|expand_normal
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|tmode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|mode
expr_stmt|;
name|mode0
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|mode
expr_stmt|;
name|mode1
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
name|mode2
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|1
index|]
operator|.
name|predicate
operator|)
operator|(
name|op0
operator|,
name|mode0
operator|)
condition|)
name|op0
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode0
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|predicate
operator|)
operator|(
name|op1
operator|,
name|mode1
operator|)
condition|)
name|op1
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode1
argument_list|,
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|3
index|]
operator|.
name|predicate
operator|)
operator|(
name|op2
operator|,
name|mode2
operator|)
condition|)
name|op2
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode2
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|||
operator|!
operator|(
operator|*
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|0
index|]
operator|.
name|predicate
operator|)
operator|(
name|target
operator|,
name|tmode
operator|)
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
name|pat
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pat
condition|)
return|return
literal|0
return|;
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ARM_BUILTIN_WZERO
case|:
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_iwmmxt_clrdi
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|target
return|;
case|case
name|ARM_BUILTIN_THREAD_POINTER
case|:
return|return
name|arm_load_tp
argument_list|(
name|target
argument_list|)
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_2arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_2arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
operator|(
specifier|const
expr|enum
name|arm_builtins
operator|)
name|fcode
condition|)
return|return
name|arm_expand_binop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|bdesc_1arg
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|bdesc_1arg
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|code
operator|==
operator|(
specifier|const
expr|enum
name|arm_builtins
operator|)
name|fcode
condition|)
return|return
name|arm_expand_unop_builtin
argument_list|(
name|d
operator|->
name|icode
argument_list|,
name|arglist
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
comment|/* @@@ Should really do something sensible here.  */
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number (counting from 0) of    the least significant set bit in MASK.  */
end_comment

begin_function
specifier|inline
specifier|static
name|int
name|number_of_first_bit_set
parameter_list|(
name|unsigned
name|mask
parameter_list|)
block|{
name|int
name|bit
decl_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
operator|)
operator|==
literal|0
condition|;
operator|++
name|bit
control|)
continue|continue;
return|return
name|bit
return|;
block|}
end_function

begin_comment
comment|/* Emit code to push or pop registers to or from the stack.  F is the    assembly file.  MASK is the registers to push or pop.  PUSH is    nonzero if we should push, and zero if we should pop.  For debugging    output, if pushing, adjust CFA_OFFSET by the amount of space added    to the stack.  REAL_REGS should have the same number of bits set as    MASK, and will be used instead (in the same order) to describe which    registers were saved - this is used to mark the save slots when we    push high registers after moving them to low registers.  */
end_comment

begin_function
specifier|static
name|void
name|thumb_pushpop
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|,
name|int
name|push
parameter_list|,
name|int
modifier|*
name|cfa_offset
parameter_list|,
name|unsigned
name|long
name|real_regs
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|int
name|lo_mask
init|=
name|mask
operator|&
literal|0xFF
decl_stmt|;
name|int
name|pushed_words
init|=
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo_mask
operator|==
literal|0
operator|&&
operator|!
name|push
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
operator|)
condition|)
block|{
comment|/* Special case.  Do not generate a POP PC statement here, do it in 	 thumb_exit() */
name|thumb_exit
argument_list|(
name|f
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ARM_EABI_UNWIND_TABLES
operator|&&
name|push
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.save\t{"
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|15
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|real_regs
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
if|if
condition|(
name|real_regs
operator|&
operator|(
operator|(
literal|1
operator|<<
name|regno
operator|)
operator|-
literal|1
operator|)
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t%s\t{"
argument_list|,
name|push
condition|?
literal|"push"
else|:
literal|"pop"
argument_list|)
expr_stmt|;
comment|/* Look at the low registers first.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
operator|,
name|lo_mask
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|lo_mask
operator|&
literal|1
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lo_mask
operator|&
operator|~
literal|1
operator|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|pushed_words
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|push
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
condition|)
block|{
comment|/* Catch pushing the LR.  */
if|if
condition|(
name|mask
operator|&
literal|0xFF
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r"
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
name|pushed_words
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|push
operator|&&
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|PC_REGNUM
operator|)
operator|)
condition|)
block|{
comment|/* Catch popping the PC.  */
if|if
condition|(
name|TARGET_INTERWORK
operator|||
name|TARGET_BACKTRACE
operator|||
name|current_function_calls_eh_return
condition|)
block|{
comment|/* The PC is never poped directly, instead 	     it is popped into r3 and then BX is used.  */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|thumb_exit
argument_list|(
name|f
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|mask
operator|&
literal|0xFF
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r"
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|push
operator|&&
name|pushed_words
operator|&&
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|int
name|pushed_mask
init|=
name|real_regs
decl_stmt|;
operator|*
name|cfa_offset
operator|+=
name|pushed_words
operator|*
literal|4
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|SP_REGNUM
argument_list|,
operator|*
name|cfa_offset
argument_list|)
expr_stmt|;
name|pushed_words
operator|=
literal|0
expr_stmt|;
name|pushed_mask
operator|=
name|real_regs
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
literal|14
condition|;
name|regno
operator|++
operator|,
name|pushed_mask
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|pushed_mask
operator|&
literal|1
condition|)
name|dwarf2out_reg_save
argument_list|(
name|l
argument_list|,
name|regno
argument_list|,
literal|4
operator|*
name|pushed_words
operator|++
operator|-
operator|*
name|cfa_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate code to return from a thumb function.    If 'reg_containing_return_addr' is -1, then the return address is    actually on the stack, at the stack pointer.  */
end_comment

begin_function
specifier|static
name|void
name|thumb_exit
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|int
name|reg_containing_return_addr
parameter_list|)
block|{
name|unsigned
name|regs_available_for_popping
decl_stmt|;
name|unsigned
name|regs_to_pop
decl_stmt|;
name|int
name|pops_needed
decl_stmt|;
name|unsigned
name|available
decl_stmt|;
name|unsigned
name|required
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|restore_a4
init|=
name|FALSE
decl_stmt|;
comment|/* Compute the registers we need to pop.  */
name|regs_to_pop
operator|=
literal|0
expr_stmt|;
name|pops_needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_containing_return_addr
operator|==
operator|-
literal|1
condition|)
block|{
name|regs_to_pop
operator||=
literal|1
operator|<<
name|LR_REGNUM
expr_stmt|;
operator|++
name|pops_needed
expr_stmt|;
block|}
if|if
condition|(
name|TARGET_BACKTRACE
condition|)
block|{
comment|/* Restore the (ARM) frame pointer and stack pointer.  */
name|regs_to_pop
operator||=
operator|(
literal|1
operator|<<
name|ARM_HARD_FRAME_POINTER_REGNUM
operator|)
operator||
operator|(
literal|1
operator|<<
name|SP_REGNUM
operator|)
expr_stmt|;
name|pops_needed
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* If there is nothing to pop then just emit the BX instruction and      return.  */
if|if
condition|(
name|pops_needed
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|current_function_calls_eh_return
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|ARM_EH_STACKADJ_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|reg_containing_return_addr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise if we are not supporting interworking and we have not created      a backtrace structure and the function was not entered in ARM mode then      just pop the return address straight into the PC.  */
elseif|else
if|if
condition|(
operator|!
name|TARGET_INTERWORK
operator|&&
operator|!
name|TARGET_BACKTRACE
operator|&&
operator|!
name|is_called_in_ARM_mode
argument_list|(
name|current_function_decl
argument_list|)
operator|&&
operator|!
name|current_function_calls_eh_return
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tpop\t{%r}\n"
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find out how many of the (return) argument registers we can corrupt.  */
name|regs_available_for_popping
operator|=
literal|0
expr_stmt|;
comment|/* If returning via __builtin_eh_return, the bottom three registers      all contain information needed for the return.  */
if|if
condition|(
name|current_function_calls_eh_return
condition|)
name|size
operator|=
literal|12
expr_stmt|;
else|else
block|{
comment|/* If we can deduce the registers used from the function's 	 return value.  This is more reliable that examining 	 regs_ever_live[] because that will be set if the register is 	 ever used in the function, not just if the register is used 	 to hold a return value.  */
if|if
condition|(
name|current_function_return_rtx
operator|!=
literal|0
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|current_function_return_rtx
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|DECL_MODE
argument_list|(
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* In a void function we can use any argument register. 	     In a function that returns a structure on the stack 	     we can use the second and third argument registers.  */
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|1
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|2
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
else|else
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|2
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
literal|4
condition|)
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|2
argument_list|)
operator|)
operator||
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<=
literal|8
condition|)
name|regs_available_for_popping
operator|=
operator|(
literal|1
operator|<<
name|ARG_REGISTER
argument_list|(
literal|3
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Match registers to be popped with registers into which we pop them.  */
for|for
control|(
name|available
operator|=
name|regs_available_for_popping
operator|,
name|required
operator|=
name|regs_to_pop
init|;
name|required
operator|!=
literal|0
operator|&&
name|available
operator|!=
literal|0
condition|;
name|available
operator|&=
operator|~
operator|(
name|available
operator|&
operator|-
name|available
operator|)
operator|,
name|required
operator|&=
operator|~
operator|(
name|required
operator|&
operator|-
name|required
operator|)
control|)
operator|--
name|pops_needed
expr_stmt|;
comment|/* If we have any popping registers left over, remove them.  */
if|if
condition|(
name|available
operator|>
literal|0
condition|)
name|regs_available_for_popping
operator|&=
operator|~
name|available
expr_stmt|;
comment|/* Otherwise if we need another popping register we can use      the fourth argument register.  */
elseif|else
if|if
condition|(
name|pops_needed
condition|)
block|{
comment|/* If we have not found any free argument registers and 	 reg a4 contains the return address, we must move it.  */
if|if
condition|(
name|regs_available_for_popping
operator|==
literal|0
operator|&&
name|reg_containing_return_addr
operator|==
name|LAST_ARG_REGNUM
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|LR_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>
literal|12
condition|)
block|{
comment|/* Register a4 is being used to hold part of the return value, 	     but we have dire need of a free, low register.  */
name|restore_a4
operator|=
name|TRUE
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reg_containing_return_addr
operator|!=
name|LAST_ARG_REGNUM
condition|)
block|{
comment|/* The fourth argument register is available.  */
name|regs_available_for_popping
operator||=
literal|1
operator|<<
name|LAST_ARG_REGNUM
expr_stmt|;
operator|--
name|pops_needed
expr_stmt|;
block|}
block|}
comment|/* Pop as many registers as we can.  */
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|regs_available_for_popping
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* Process the registers we popped.  */
if|if
condition|(
name|reg_containing_return_addr
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* The return address was popped into the lowest numbered register.  */
name|regs_to_pop
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* Remove this register for the mask of available registers, so that          the return address will not be corrupted by further pops.  */
name|regs_available_for_popping
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|reg_containing_return_addr
operator|)
expr_stmt|;
block|}
comment|/* If we popped other registers then handle them here.  */
if|if
condition|(
name|regs_available_for_popping
condition|)
block|{
name|int
name|frame_pointer
decl_stmt|;
comment|/* Work out which register currently contains the frame pointer.  */
name|frame_pointer
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* Move it into the correct place.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|,
name|frame_pointer
argument_list|)
expr_stmt|;
comment|/* (Temporarily) remove it from the mask of popped registers.  */
name|regs_available_for_popping
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|frame_pointer
operator|)
expr_stmt|;
name|regs_to_pop
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|ARM_HARD_FRAME_POINTER_REGNUM
operator|)
expr_stmt|;
if|if
condition|(
name|regs_available_for_popping
condition|)
block|{
name|int
name|stack_pointer
decl_stmt|;
comment|/* We popped the stack pointer as well, 	     find the register that contains it.  */
name|stack_pointer
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* Move it into the stack register.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|stack_pointer
argument_list|)
expr_stmt|;
comment|/* At this point we have popped all necessary registers, so 	     do not worry about restoring regs_available_for_popping 	     to its correct value:  	     assert (pops_needed == 0) 	     assert (regs_available_for_popping == (1<< frame_pointer)) 	     assert (regs_to_pop == (1<< STACK_POINTER))  */
block|}
else|else
block|{
comment|/* Since we have just move the popped value into the frame 	     pointer, the popping register is available for reuse, and 	     we know that we still have the stack pointer left to pop.  */
name|regs_available_for_popping
operator||=
operator|(
literal|1
operator|<<
name|frame_pointer
operator|)
expr_stmt|;
block|}
block|}
comment|/* If we still have registers left on the stack, but we no longer have      any registers into which we can pop them, then we must move the return      address into the link register and make available the register that      contained it.  */
if|if
condition|(
name|regs_available_for_popping
operator|==
literal|0
operator|&&
name|pops_needed
operator|>
literal|0
condition|)
block|{
name|regs_available_for_popping
operator||=
literal|1
operator|<<
name|reg_containing_return_addr
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|reg_containing_return_addr
argument_list|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|LR_REGNUM
expr_stmt|;
block|}
comment|/* If we have registers left on the stack then pop some more.      We know that at most we will want to pop FP and SP.  */
if|if
condition|(
name|pops_needed
operator|>
literal|0
condition|)
block|{
name|int
name|popped_into
decl_stmt|;
name|int
name|move_to
decl_stmt|;
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|regs_available_for_popping
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|regs_available_for_popping
argument_list|)
expr_stmt|;
comment|/* We have popped either FP or SP. 	 Move whichever one it is into the correct register.  */
name|popped_into
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
name|move_to
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_to_pop
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|move_to
argument_list|,
name|popped_into
argument_list|)
expr_stmt|;
name|regs_to_pop
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|move_to
operator|)
expr_stmt|;
operator|--
name|pops_needed
expr_stmt|;
block|}
comment|/* If we still have not popped everything then we must have only      had one register available to us and we are now popping the SP.  */
if|if
condition|(
name|pops_needed
operator|>
literal|0
condition|)
block|{
name|int
name|popped_into
decl_stmt|;
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|regs_available_for_popping
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|regs_available_for_popping
argument_list|)
expr_stmt|;
name|popped_into
operator|=
name|number_of_first_bit_set
argument_list|(
name|regs_available_for_popping
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|popped_into
argument_list|)
expr_stmt|;
comment|/* 	assert (regs_to_pop == (1<< STACK_POINTER)) 	assert (pops_needed == 1)       */
block|}
comment|/* If necessary restore the a4 register.  */
if|if
condition|(
name|restore_a4
condition|)
block|{
if|if
condition|(
name|reg_containing_return_addr
operator|!=
name|LR_REGNUM
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
name|reg_containing_return_addr
operator|=
name|LR_REGNUM
expr_stmt|;
block|}
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LAST_ARG_REGNUM
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_calls_eh_return
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|ARM_EH_STACKADJ_REGNUM
argument_list|)
expr_stmt|;
comment|/* Return to caller.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|reg_containing_return_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|thumb_final_prescan_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
name|flag_print_asm_name
condition|)
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%@ 0x%04x\n"
argument_list|,
name|INSN_ADDRESSES
argument_list|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|thumb_shiftable_const
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|val
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|mask
init|=
literal|0xff
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
comment|/* XXX */
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|mask
operator|<<
name|i
operator|)
operator|)
operator|==
name|val
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if the current function contains,    or might contain a far jump.  */
end_comment

begin_function
specifier|static
name|int
name|thumb_far_jump_used_p
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* This test is only important for leaf functions.  */
comment|/* assert (!leaf_function_p ()); */
comment|/* If we have already decided that far jumps may be used,      do not bother checking again, and always return true even if      it turns out that they are not being used.  Once we have made      the decision that far jumps are present (and that hence the link      register will be pushed onto the stack) we cannot go back on it.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|far_jump_used
condition|)
return|return
literal|1
return|;
comment|/* If this function is not being called from the prologue/epilogue      generation code then it must be being called from the      INITIAL_ELIMINATION_OFFSET macro.  */
if|if
condition|(
operator|!
operator|(
name|ARM_DOUBLEWORD_ALIGN
operator|||
name|reload_completed
operator|)
condition|)
block|{
comment|/* In this case we know that we are being asked about the elimination 	 of the arg pointer register.  If that register is not being used, 	 then there are no arguments on the stack, and we do not have to 	 worry that a far jump might force the prologue to push the link 	 register, changing the stack offsets.  In this case we can just 	 return false, since the presence of far jumps in the function will 	 not affect stack offsets.  	 If the arg pointer is live (or if it was live, but has now been 	 eliminated and so set to dead) then we do have to test to see if 	 the function might contain a far jump.  This test can lead to some 	 false negatives, since before reload is completed, then length of 	 branch instructions is not known, so gcc defaults to returning their 	 longest length, which in turn sets the far jump attribute to true.  	 A false negative will not result in bad code being generated, but it 	 will result in a needless push and pop of the link register.  We 	 hope that this does not occur too often.  	 If we need doubleword stack alignment this could affect the other 	 elimination offsets so we can't risk getting it wrong.  */
if|if
condition|(
name|regs_ever_live
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
name|cfun
operator|->
name|machine
operator|->
name|arg_pointer_live
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|cfun
operator|->
name|machine
operator|->
name|arg_pointer_live
condition|)
return|return
literal|0
return|;
block|}
comment|/* Check to see if the function contains a branch      insn with the far jump attribute set.  */
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
comment|/* Ignore tablejump patterns.  */
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_VEC
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|ADDR_DIFF_VEC
operator|&&
name|get_attr_far_jump
argument_list|(
name|insn
argument_list|)
operator|==
name|FAR_JUMP_YES
condition|)
block|{
comment|/* Record the fact that we have decided that 	     the function does use far jumps.  */
name|cfun
operator|->
name|machine
operator|->
name|far_jump_used
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if FUNC must be entered in ARM mode.  */
end_comment

begin_function
name|int
name|is_called_in_ARM_mode
parameter_list|(
name|tree
name|func
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|func
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
comment|/* Ignore the problem about functions whose address is taken.  */
if|if
condition|(
name|TARGET_CALLEE_INTERWORKING
operator|&&
name|TREE_PUBLIC
argument_list|(
name|func
argument_list|)
condition|)
return|return
name|TRUE
return|;
ifdef|#
directive|ifdef
name|ARM_PE
return|return
name|lookup_attribute
argument_list|(
literal|"interfacearm"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|func
argument_list|)
argument_list|)
operator|!=
name|NULL_TREE
return|;
else|#
directive|else
return|return
name|FALSE
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The bits which aren't usefully expanded as rtl.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|thumb_unexpanded_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|long
name|live_regs_mask
init|=
literal|0
decl_stmt|;
name|int
name|high_regs_pushed
init|=
literal|0
decl_stmt|;
name|int
name|had_to_push_lr
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|return_used_this_function
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|arm_current_func_type
argument_list|()
argument_list|)
condition|)
return|return
literal|""
return|;
name|live_regs_mask
operator|=
name|thumb_compute_save_reg_mask
argument_list|()
expr_stmt|;
name|high_regs_pushed
operator|=
name|bit_count
argument_list|(
name|live_regs_mask
operator|&
literal|0x0f00
argument_list|)
expr_stmt|;
comment|/* If we can deduce the registers used from the function's return value.      This is more reliable that examining regs_ever_live[] because that      will be set if the register is ever used in the function, not just if      the register is used to hold a return value.  */
name|size
operator|=
name|arm_size_return_regs
argument_list|()
expr_stmt|;
comment|/* The prolog may have pushed some high registers to use as      work registers.  e.g. the testsuite file:      gcc/testsuite/gcc/gcc.c-torture/execute/complex-2.c      compiles to produce: 	push	{r4, r5, r6, r7, lr} 	mov	r7, r9 	mov	r6, r8 	push	{r6, r7}      as part of the prolog.  We have to undo that pushing here.  */
if|if
condition|(
name|high_regs_pushed
condition|)
block|{
name|unsigned
name|long
name|mask
init|=
name|live_regs_mask
operator|&
literal|0xff
decl_stmt|;
name|int
name|next_hi_reg
decl_stmt|;
comment|/* The available low registers depend on the size of the value we are          returning.  */
if|if
condition|(
name|size
operator|<=
literal|12
condition|)
name|mask
operator||=
literal|1
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|8
condition|)
name|mask
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
comment|/* Oh dear!  We have no low registers into which we can pop            high registers!  */
name|internal_error
argument_list|(
literal|"no low registers available for popping high registers"
argument_list|)
expr_stmt|;
for|for
control|(
name|next_hi_reg
operator|=
literal|8
init|;
name|next_hi_reg
operator|<
literal|13
condition|;
name|next_hi_reg
operator|++
control|)
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|next_hi_reg
operator|)
condition|)
break|break;
while|while
condition|(
name|high_regs_pushed
condition|)
block|{
comment|/* Find lo register(s) into which the high register(s) can              be popped.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
name|high_regs_pushed
operator|--
expr_stmt|;
if|if
condition|(
name|high_regs_pushed
operator|==
literal|0
condition|)
break|break;
block|}
name|mask
operator|&=
operator|(
literal|2
operator|<<
name|regno
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* A noop if regno == 8 */
comment|/* Pop the values into the low register(s).  */
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* Move the value(s) into the high registers.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|next_hi_reg
argument_list|,
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|next_hi_reg
operator|++
init|;
name|next_hi_reg
operator|<
literal|13
condition|;
name|next_hi_reg
operator|++
control|)
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|next_hi_reg
operator|)
condition|)
break|break;
block|}
block|}
block|}
name|live_regs_mask
operator|&=
operator|~
literal|0x0f00
expr_stmt|;
block|}
name|had_to_push_lr
operator|=
operator|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|live_regs_mask
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|current_function_pretend_args_size
operator|==
literal|0
operator|||
name|TARGET_BACKTRACE
condition|)
block|{
comment|/* Pop the return address into the PC.  */
if|if
condition|(
name|had_to_push_lr
condition|)
name|live_regs_mask
operator||=
literal|1
operator|<<
name|PC_REGNUM
expr_stmt|;
comment|/* Either no argument registers were pushed or a backtrace 	 structure was created which includes an adjusted stack 	 pointer, so just pop everything.  */
if|if
condition|(
name|live_regs_mask
condition|)
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
name|live_regs_mask
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|live_regs_mask
argument_list|)
expr_stmt|;
comment|/* We have either just popped the return address into the 	 PC or it is was kept in LR for the entire function.  */
if|if
condition|(
operator|!
name|had_to_push_lr
condition|)
name|thumb_exit
argument_list|(
name|asm_out_file
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pop everything but the return address.  */
if|if
condition|(
name|live_regs_mask
condition|)
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
name|live_regs_mask
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|live_regs_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|had_to_push_lr
condition|)
block|{
if|if
condition|(
name|size
operator|>
literal|12
condition|)
block|{
comment|/* We have no free low regs, so save one.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
block|}
comment|/* Get the return address into a temporary register.  */
name|thumb_pushpop
argument_list|(
name|asm_out_file
argument_list|,
literal|1
operator|<<
name|LAST_ARG_REGNUM
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|1
operator|<<
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|12
condition|)
block|{
comment|/* Move the return address to lr.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LR_REGNUM
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
expr_stmt|;
comment|/* Restore the low register.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|LAST_ARG_REGNUM
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
name|regno
operator|=
name|LR_REGNUM
expr_stmt|;
block|}
else|else
name|regno
operator|=
name|LAST_ARG_REGNUM
expr_stmt|;
block|}
else|else
name|regno
operator|=
name|LR_REGNUM
expr_stmt|;
comment|/* Remove the argument registers that were pushed onto the stack.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tadd\t%r, %r, #%d\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
name|thumb_exit
argument_list|(
name|asm_out_file
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Functions to save and restore machine-specific function data.  */
end_comment

begin_function
specifier|static
name|struct
name|machine_function
modifier|*
name|arm_init_machine_status
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|machine_function
modifier|*
name|machine
decl_stmt|;
name|machine
operator|=
operator|(
name|machine_function
operator|*
operator|)
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|machine_function
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|ARM_FT_UNKNOWN
operator|!=
literal|0
name|machine
operator|->
name|func_type
operator|=
name|ARM_FT_UNKNOWN
expr_stmt|;
endif|#
directive|endif
return|return
name|machine
return|;
block|}
end_function

begin_comment
comment|/* Return an RTX indicating where the return address to the    calling function can be found.  */
end_comment

begin_function
name|rtx
name|arm_return_addr
parameter_list|(
name|int
name|count
parameter_list|,
name|rtx
name|frame
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|get_hard_reg_initial_val
argument_list|(
name|Pmode
argument_list|,
name|LR_REGNUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do anything needed before RTL is emitted for each function.  */
end_comment

begin_function
name|void
name|arm_init_expanders
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Arrange to initialize and mark the machine per-function status.  */
name|init_machine_status
operator|=
name|arm_init_machine_status
expr_stmt|;
comment|/* This is to stop the combine pass optimizing away the alignment      adjustment of va_arg.  */
comment|/* ??? It is claimed that this should not be necessary.  */
if|if
condition|(
name|cfun
condition|)
name|mark_reg_pointer
argument_list|(
name|arg_pointer_rtx
argument_list|,
name|PARM_BOUNDARY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like arm_compute_initial_elimination offset.  Simpler because there    isn't an ABI specified frame pointer for Thumb.  Instead, we set it    to point at the base of the local variables after static stack    space for a function has been allocated.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|thumb_compute_initial_elimination_offset
parameter_list|(
name|unsigned
name|int
name|from
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|)
block|{
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
name|offsets
operator|=
name|arm_get_frame_offsets
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|from
condition|)
block|{
case|case
name|ARG_POINTER_REGNUM
case|:
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|STACK_POINTER_REGNUM
case|:
return|return
name|offsets
operator|->
name|outgoing_args
operator|-
name|offsets
operator|->
name|saved_args
return|;
case|case
name|FRAME_POINTER_REGNUM
case|:
return|return
name|offsets
operator|->
name|soft_frame
operator|-
name|offsets
operator|->
name|saved_args
return|;
case|case
name|ARM_HARD_FRAME_POINTER_REGNUM
case|:
return|return
name|offsets
operator|->
name|saved_regs
operator|-
name|offsets
operator|->
name|saved_args
return|;
case|case
name|THUMB_HARD_FRAME_POINTER_REGNUM
case|:
return|return
name|offsets
operator|->
name|locals_base
operator|-
name|offsets
operator|->
name|saved_args
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|FRAME_POINTER_REGNUM
case|:
switch|switch
condition|(
name|to
condition|)
block|{
case|case
name|STACK_POINTER_REGNUM
case|:
return|return
name|offsets
operator|->
name|outgoing_args
operator|-
name|offsets
operator|->
name|soft_frame
return|;
case|case
name|ARM_HARD_FRAME_POINTER_REGNUM
case|:
return|return
name|offsets
operator|->
name|saved_regs
operator|-
name|offsets
operator|->
name|soft_frame
return|;
case|case
name|THUMB_HARD_FRAME_POINTER_REGNUM
case|:
return|return
name|offsets
operator|->
name|locals_base
operator|-
name|offsets
operator|->
name|soft_frame
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the rest of a function's prologue.  */
end_comment

begin_function
name|void
name|thumb_expand_prologue
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|dwarf
decl_stmt|;
name|HOST_WIDE_INT
name|amount
decl_stmt|;
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
name|unsigned
name|long
name|func_type
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|unsigned
name|long
name|live_regs_mask
decl_stmt|;
name|func_type
operator|=
name|arm_current_func_type
argument_list|()
expr_stmt|;
comment|/* Naked functions don't have prologues.  */
if|if
condition|(
name|IS_NAKED
argument_list|(
name|func_type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|IS_INTERRUPT
argument_list|(
name|func_type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"interrupt Service Routines cannot be coded in Thumb mode"
argument_list|)
expr_stmt|;
return|return;
block|}
name|live_regs_mask
operator|=
name|thumb_compute_save_reg_mask
argument_list|()
expr_stmt|;
comment|/* Load the pic register before setting the frame pointer,      so we can use r7 as a temporary work register.  */
if|if
condition|(
name|flag_pic
operator|&&
name|arm_pic_register
operator|!=
name|INVALID_REGNUM
condition|)
name|arm_load_pic_register
argument_list|(
name|live_regs_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|&&
name|CALLER_INTERWORKING_SLOT_SIZE
operator|>
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|)
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
name|offsets
operator|=
name|arm_get_frame_offsets
argument_list|()
expr_stmt|;
name|amount
operator|=
name|offsets
operator|->
name|outgoing_args
operator|-
name|offsets
operator|->
name|saved_regs
expr_stmt|;
if|if
condition|(
name|amount
condition|)
block|{
if|if
condition|(
name|amount
operator|<
literal|512
condition|)
block|{
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|reg
decl_stmt|;
comment|/* The stack decrement is too big for an immediate value in a single 	     insn.  In theory we could issue multiple subtracts, but after 	     three of them it becomes more space efficient to place the full 	     value in the constant pool and load into a register.  (Also the 	     ARM debugger really likes to see only one stack decrement per 	     function).  So instead we look for a scratch register into which 	     we can load the decrement, and then we subtract this from the 	     stack pointer.  Unfortunately on the thumb the only available 	     scratch registers are the argument registers, and we cannot use 	     these as they may hold arguments to the function.  Instead we 	     attempt to locate a call preserved register which is used by this 	     function.  If we can find one, then we know that it will have 	     been pushed at the start of the prologue and so we can corrupt 	     it now.  */
for|for
control|(
name|regno
operator|=
name|LAST_ARG_REGNUM
operator|+
literal|1
init|;
name|regno
operator|<=
name|LAST_LO_REGNUM
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
operator|&&
operator|!
operator|(
name|frame_pointer_needed
operator|&&
operator|(
name|regno
operator|==
name|THUMB_HARD_FRAME_POINTER_REGNUM
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|regno
operator|>
name|LAST_LO_REGNUM
condition|)
comment|/* Very unlikely.  */
block|{
name|rtx
name|spare
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|IP_REGNUM
argument_list|)
decl_stmt|;
comment|/* Choose an arbitrary, non-argument low register.  */
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LAST_LO_REGNUM
argument_list|)
expr_stmt|;
comment|/* Save it by copying it into a high, scratch register.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|spare
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add a USE to stop propagate_one_insn() from barfing.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|spare
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decrement the stack.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
operator|-
name|amount
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|dwarf
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore the low register's original value.  */
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|spare
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Emit a USE of the restored scratch register, so that flow 		 analysis will not consider the restore redundant.  The 		 register won't be used again in this function and isn't 		 restored by the epilogue.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
operator|-
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
operator|-
name|amount
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|dwarf
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|amount
operator|=
name|offsets
operator|->
name|outgoing_args
operator|-
name|offsets
operator|->
name|locals_base
expr_stmt|;
if|if
condition|(
name|amount
operator|<
literal|1024
condition|)
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|dwarf
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|hard_frame_pointer_rtx
argument_list|,
name|plus_constant
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|amount
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_FRAME_RELATED_P
argument_list|(
name|dwarf
argument_list|)
operator|=
literal|1
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|dwarf
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we are profiling, make sure no instructions are scheduled before      the call to mcount.  Similarly if the user has requested no      scheduling in the prolog.  Similarly if we want non-call exceptions      using the EABI unwinder, to prevent faulting instructions from being      swapped with a stack adjustment.  */
if|if
condition|(
name|current_function_profile
operator|||
operator|!
name|TARGET_SCHED_PROLOG
operator|||
operator|(
name|ARM_EABI_UNWIND_TABLES
operator|&&
name|flag_non_call_exceptions
operator|)
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
operator|=
operator|!
name|thumb_force_lr_save
argument_list|()
expr_stmt|;
if|if
condition|(
name|live_regs_mask
operator|&
literal|0xff
condition|)
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
operator|=
literal|0
expr_stmt|;
comment|/* If the link register is being kept alive, with the return address in it,      then make sure that it does not get reused by the ce2 pass.  */
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|lr_save_eliminated
condition|)
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|thumb_expand_epilogue
parameter_list|(
name|void
parameter_list|)
block|{
name|HOST_WIDE_INT
name|amount
decl_stmt|;
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
name|int
name|regno
decl_stmt|;
comment|/* Naked functions don't have prologues.  */
if|if
condition|(
name|IS_NAKED
argument_list|(
name|arm_current_func_type
argument_list|()
argument_list|)
condition|)
return|return;
name|offsets
operator|=
name|arm_get_frame_offsets
argument_list|()
expr_stmt|;
name|amount
operator|=
name|offsets
operator|->
name|outgoing_args
operator|-
name|offsets
operator|->
name|saved_regs
expr_stmt|;
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|hard_frame_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|amount
operator|=
name|offsets
operator|->
name|locals_base
operator|-
name|offsets
operator|->
name|saved_regs
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|amount
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|amount
condition|)
block|{
if|if
condition|(
name|amount
operator|<
literal|512
condition|)
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* r3 is always free in the epilogue.  */
name|rtx
name|reg
init|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LAST_ARG_REGNUM
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|GEN_INT
argument_list|(
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Emit a USE (stack_pointer_rtx), so that      the stack adjustment will not be deleted.  */
name|emit_insn
argument_list|(
name|gen_prologue_use
argument_list|(
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_profile
operator|||
operator|!
name|TARGET_SCHED_PROLOG
condition|)
name|emit_insn
argument_list|(
name|gen_blockage
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Emit a clobber for each insn that will be restored in the epilogue,      so that flow2 will get register lifetimes correct.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|13
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|regno
index|]
operator|&&
operator|!
name|call_used_regs
index|[
name|regno
index|]
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_CLOBBER
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regs_ever_live
index|[
name|LR_REGNUM
index|]
condition|)
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thumb_output_function_prologue
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|HOST_WIDE_INT
name|size
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|long
name|live_regs_mask
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|l_mask
decl_stmt|;
name|unsigned
name|high_regs_pushed
init|=
literal|0
decl_stmt|;
name|int
name|cfa_offset
init|=
literal|0
decl_stmt|;
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|IS_NAKED
argument_list|(
name|arm_current_func_type
argument_list|()
argument_list|)
condition|)
return|return;
if|if
condition|(
name|is_called_in_ARM_mode
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
argument_list|)
expr_stmt|;
name|name
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Generate code sequence to switch us into Thumb mode.  */
comment|/* The .code 32 directive has already been emitted by 	 ASM_DECLARE_FUNCTION_NAME.  */
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\torr\t%r, %r, #1\n"
argument_list|,
name|IP_REGNUM
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|IP_REGNUM
argument_list|)
expr_stmt|;
comment|/* Generate a label, so that the debugger will notice the 	 change in instruction sets.  This label is also used by 	 the assembler to bypass the ARM code when this function 	 is called from a Thumb encoded function elsewhere in the 	 same file.  Hence the definition of STUB_NAME here must 	 agree with the definition in gas/config/tc-arm.c.  */
define|#
directive|define
name|STUB_NAME
value|".real_start_of"
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.code\t16\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARM_PE
if|if
condition|(
name|arm_dllexport_name_p
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|arm_strip_name_encoding
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.globl %s%U%s\n"
argument_list|,
name|STUB_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.thumb_func\n"
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%s%U%s:\n"
argument_list|,
name|STUB_NAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_function_pretend_args_size
condition|)
block|{
comment|/* Output unwind directive for the stack adjustment.  */
if|if
condition|(
name|ARM_EABI_UNWIND_TABLES
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.pad #%d\n"
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
condition|)
block|{
name|int
name|num_pushes
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\tpush\t{"
argument_list|)
expr_stmt|;
name|num_pushes
operator|=
name|ARM_NUM_INTS
argument_list|(
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
name|LAST_ARG_REGNUM
operator|+
literal|1
operator|-
name|num_pushes
init|;
name|regno
operator|<=
name|LAST_ARG_REGNUM
condition|;
name|regno
operator|++
control|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"%r%s"
argument_list|,
name|regno
argument_list|,
name|regno
operator|==
name|LAST_ARG_REGNUM
condition|?
literal|""
else|:
literal|", "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsub\t%r, %r, #%d\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|,
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
comment|/* We don't need to record the stores for unwinding (would it 	 help the debugger any if we did?), but record the change in 	 the stack pointer.  */
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|cfa_offset
operator|=
name|cfa_offset
operator|+
name|current_function_pretend_args_size
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|SP_REGNUM
argument_list|,
name|cfa_offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the registers we are going to push.  */
name|live_regs_mask
operator|=
name|thumb_compute_save_reg_mask
argument_list|()
expr_stmt|;
comment|/* Extract a mask of the ones we can give to the Thumb's push instruction.  */
name|l_mask
operator|=
name|live_regs_mask
operator|&
literal|0x40ff
expr_stmt|;
comment|/* Then count how many other high registers will need to be pushed.  */
name|high_regs_pushed
operator|=
name|bit_count
argument_list|(
name|live_regs_mask
operator|&
literal|0x0f00
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BACKTRACE
condition|)
block|{
name|unsigned
name|offset
decl_stmt|;
name|unsigned
name|work_register
decl_stmt|;
comment|/* We have been asked to create a stack backtrace structure.          The code looks like this:  	 0   .align 2 	 0   func:          0     sub   SP, #16         Reserve space for 4 registers. 	 2     push  {R7}            Push low registers.          4     add   R7, SP, #20     Get the stack pointer before the push.          6     str   R7, [SP, #8]    Store the stack pointer (before reserving the space).          8     mov   R7, PC          Get hold of the start of this code plus 12.         10     str   R7, [SP, #16]   Store it.         12     mov   R7, FP          Get hold of the current frame pointer.         14     str   R7, [SP, #4]    Store it.         16     mov   R7, LR          Get hold of the current return address.         18     str   R7, [SP, #12]   Store it.         20     add   R7, SP, #16     Point at the start of the backtrace structure.         22     mov   FP, R7          Put this value into the frame pointer.  */
name|work_register
operator|=
name|thumb_find_work_register
argument_list|(
name|live_regs_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARM_EABI_UNWIND_TABLES
condition|)
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\t.pad #16\n"
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tsub\t%r, %r, #16\t%@ Create stack backtrace structure\n"
argument_list|,
name|SP_REGNUM
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf2out_do_frame
argument_list|()
condition|)
block|{
name|char
modifier|*
name|l
init|=
name|dwarf2out_cfi_label
argument_list|()
decl_stmt|;
name|cfa_offset
operator|=
name|cfa_offset
operator|+
literal|16
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|l
argument_list|,
name|SP_REGNUM
argument_list|,
name|cfa_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|l_mask
condition|)
block|{
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|l_mask
argument_list|,
literal|1
argument_list|,
operator|&
name|cfa_offset
argument_list|,
name|l_mask
argument_list|)
expr_stmt|;
name|offset
operator|=
name|bit_count
argument_list|(
name|l_mask
argument_list|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r, #%d\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|16
operator|+
name|current_function_pretend_args_size
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Make sure that the instruction fetching the PC is in the right place 	 to calculate "start of backtrace creation code + 12".  */
if|if
condition|(
name|l_mask
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|work_register
argument_list|,
name|LR_REGNUM
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tstr\t%r, [%r, #%d]\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|8
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tadd\t%r, %r, #%d\n"
argument_list|,
name|work_register
argument_list|,
name|SP_REGNUM
argument_list|,
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\t\t%@ Backtrace structure created\n"
argument_list|,
name|ARM_HARD_FRAME_POINTER_REGNUM
argument_list|,
name|work_register
argument_list|)
expr_stmt|;
block|}
comment|/* Optimization:  If we are not pushing any low registers but we are going      to push some high registers then delay our first push.  This will just      be a push of LR and we can combine it with the push of the first high      register.  */
elseif|else
if|if
condition|(
operator|(
name|l_mask
operator|&
literal|0xff
operator|)
operator|!=
literal|0
operator|||
operator|(
name|high_regs_pushed
operator|==
literal|0
operator|&&
name|l_mask
operator|)
condition|)
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|l_mask
argument_list|,
literal|1
argument_list|,
operator|&
name|cfa_offset
argument_list|,
name|l_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|high_regs_pushed
condition|)
block|{
name|unsigned
name|pushable_regs
decl_stmt|;
name|unsigned
name|next_hi_reg
decl_stmt|;
for|for
control|(
name|next_hi_reg
operator|=
literal|12
init|;
name|next_hi_reg
operator|>
name|LAST_LO_REGNUM
condition|;
name|next_hi_reg
operator|--
control|)
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|next_hi_reg
operator|)
condition|)
break|break;
name|pushable_regs
operator|=
name|l_mask
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|pushable_regs
operator|==
literal|0
condition|)
name|pushable_regs
operator|=
literal|1
operator|<<
name|thumb_find_work_register
argument_list|(
name|live_regs_mask
argument_list|)
expr_stmt|;
while|while
condition|(
name|high_regs_pushed
operator|>
literal|0
condition|)
block|{
name|unsigned
name|long
name|real_regs_mask
init|=
literal|0
decl_stmt|;
for|for
control|(
name|regno
operator|=
name|LAST_LO_REGNUM
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
block|{
if|if
condition|(
name|pushable_regs
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tmov\t%r, %r\n"
argument_list|,
name|regno
argument_list|,
name|next_hi_reg
argument_list|)
expr_stmt|;
name|high_regs_pushed
operator|--
expr_stmt|;
name|real_regs_mask
operator||=
operator|(
literal|1
operator|<<
name|next_hi_reg
operator|)
expr_stmt|;
if|if
condition|(
name|high_regs_pushed
condition|)
block|{
for|for
control|(
name|next_hi_reg
operator|--
init|;
name|next_hi_reg
operator|>
name|LAST_LO_REGNUM
condition|;
name|next_hi_reg
operator|--
control|)
if|if
condition|(
name|live_regs_mask
operator|&
operator|(
literal|1
operator|<<
name|next_hi_reg
operator|)
condition|)
break|break;
block|}
else|else
block|{
name|pushable_regs
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|regno
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If we had to find a work register and we have not yet 	     saved the LR then add it to the list of regs to push.  */
if|if
condition|(
name|l_mask
operator|==
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
condition|)
block|{
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|pushable_regs
operator||
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
argument_list|,
literal|1
argument_list|,
operator|&
name|cfa_offset
argument_list|,
name|real_regs_mask
operator||
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
argument_list|)
expr_stmt|;
name|l_mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|thumb_pushpop
argument_list|(
name|f
argument_list|,
name|pushable_regs
argument_list|,
literal|1
argument_list|,
operator|&
name|cfa_offset
argument_list|,
name|real_regs_mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handle the case of a double word load into a low register from    a computed memory address.  The computed address may involve a    register which is overwritten by the load.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|thumb_load_double_from_address
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|addr
decl_stmt|;
name|rtx
name|base
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|rtx
name|arg1
decl_stmt|;
name|rtx
name|arg2
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|==
name|MEM
argument_list|)
expr_stmt|;
comment|/* Get the memory address.  */
name|addr
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Work out how the memory address is computed.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|operands
index|[
literal|2
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST
case|:
comment|/* Compute<address> + 4 for the high order load.  */
name|operands
index|[
literal|2
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|arg1
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|arg1
argument_list|)
condition|)
name|base
operator|=
name|arg2
operator|,
name|offset
operator|=
name|arg1
expr_stmt|;
else|else
name|base
operator|=
name|arg1
operator|,
name|offset
operator|=
name|arg2
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|REG
argument_list|)
expr_stmt|;
comment|/* Catch the case of<address> =<reg> +<reg> */
if|if
condition|(
name|GET_CODE
argument_list|(
name|offset
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|reg_offset
init|=
name|REGNO
argument_list|(
name|offset
argument_list|)
decl_stmt|;
name|int
name|reg_base
init|=
name|REGNO
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|int
name|reg_dest
init|=
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* Add the base and offset registers together into the              higher destination register.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tadd\t%r, %r, %r"
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|,
name|reg_base
argument_list|,
name|reg_offset
argument_list|)
expr_stmt|;
comment|/* Load the lower destination register from the address in              the higher destination register.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tldr\t%r, [%r, #0]"
argument_list|,
name|reg_dest
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Load the higher destination register from its own address              plus 4.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tldr\t%r, [%r, #4]"
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|,
name|reg_dest
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Compute<address> + 4 for the high order load.  */
name|operands
index|[
literal|2
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* If the computed address is held in the low order register 	     then load the high order register first, otherwise always 	     load the low order register first.  */
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|)
operator|==
name|REGNO
argument_list|(
name|base
argument_list|)
condition|)
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|LABEL_REF
case|:
comment|/* With no registers to worry about we can just load the value          directly.  */
name|operands
index|[
literal|2
index|]
operator|=
name|adjust_address
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
name|SImode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%H0, %2"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|thumb_output_move_mem_multiple
parameter_list|(
name|int
name|n
parameter_list|,
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|tmp
decl_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"ldmia\t%1!, {%4, %5}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stmia\t%0!, {%4, %5}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|6
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|operands
index|[
literal|6
index|]
expr_stmt|;
name|operands
index|[
literal|6
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|REGNO
argument_list|(
name|operands
index|[
literal|4
index|]
argument_list|)
operator|>
name|REGNO
argument_list|(
name|operands
index|[
literal|5
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|operands
index|[
literal|4
index|]
expr_stmt|;
name|operands
index|[
literal|4
index|]
operator|=
name|operands
index|[
literal|5
index|]
expr_stmt|;
name|operands
index|[
literal|5
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"ldmia\t%1!, {%4, %5, %6}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"stmia\t%0!, {%4, %5, %6}"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Output a call-via instruction for thumb state.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|thumb_call_via_reg
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
modifier|*
name|labelp
decl_stmt|;
name|gcc_assert
argument_list|(
name|regno
operator|<
name|LR_REGNUM
argument_list|)
expr_stmt|;
comment|/* If we are in the normal text section we can use a single instance      per compilation unit.  If we are doing function sections, then we need      an entry per section, since we can't rely on reachability.  */
if|if
condition|(
name|in_section
operator|==
name|text_section
condition|)
block|{
name|thumb_call_reg_needed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|thumb_call_via_label
index|[
name|regno
index|]
operator|==
name|NULL
condition|)
name|thumb_call_via_label
index|[
name|regno
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|labelp
operator|=
name|thumb_call_via_label
operator|+
name|regno
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cfun
operator|->
name|machine
operator|->
name|call_via
index|[
name|regno
index|]
operator|==
name|NULL
condition|)
name|cfun
operator|->
name|machine
operator|->
name|call_via
index|[
name|regno
index|]
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|labelp
operator|=
name|cfun
operator|->
name|machine
operator|->
name|call_via
operator|+
name|regno
expr_stmt|;
block|}
name|output_asm_insn
argument_list|(
literal|"bl\t%a0"
argument_list|,
name|labelp
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Routines for generating rtl.  */
end_comment

begin_function
name|void
name|thumb_expand_movmemqi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|out
init|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|in
init|=
name|copy_to_mode_reg
argument_list|(
name|SImode
argument_list|,
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|len
init|=
name|INTVAL
argument_list|(
name|operands
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>=
literal|12
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movmem12b
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|12
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movmem8b
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|out
argument_list|,
name|in
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|SImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|reg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|in
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|SImode
argument_list|,
name|out
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
literal|2
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|HImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|reg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|in
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movhi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|HImode
argument_list|,
name|plus_constant
argument_list|(
name|out
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|rtx
name|reg
init|=
name|gen_reg_rtx
argument_list|(
name|QImode
argument_list|)
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|reg
argument_list|,
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|in
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_movqi
argument_list|(
name|gen_rtx_MEM
argument_list|(
name|QImode
argument_list|,
name|plus_constant
argument_list|(
name|out
argument_list|,
name|offset
argument_list|)
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|thumb_reload_out_hi
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|emit_insn
argument_list|(
name|gen_thumb_movhi_clobber
argument_list|(
name|operands
index|[
literal|0
index|]
argument_list|,
name|operands
index|[
literal|1
index|]
argument_list|,
name|operands
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle reading a half-word from memory during reload.  */
end_comment

begin_function
name|void
name|thumb_reload_in_hi
parameter_list|(
name|rtx
modifier|*
name|operands
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the length of a function name prefix     that starts with the character 'c'.  */
end_comment

begin_function
specifier|static
name|int
name|arm_get_strip_length
parameter_list|(
name|int
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
name|ARM_NAME_ENCODING_LENGTHS
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to a function's name with any    and all prefix encodings stripped from it.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|arm_strip_name_encoding
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|skip
decl_stmt|;
while|while
condition|(
operator|(
name|skip
operator|=
name|arm_get_strip_length
argument_list|(
operator|*
name|name
argument_list|)
operator|)
condition|)
name|name
operator|+=
name|skip
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* If there is a '*' anywhere in the name's prefix, then    emit the stripped name verbatim, otherwise prepend an    underscore if leading underscores are being used.  */
end_comment

begin_function
name|void
name|arm_asm_output_labelref
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|skip
decl_stmt|;
name|int
name|verbatim
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|skip
operator|=
name|arm_get_strip_length
argument_list|(
operator|*
name|name
argument_list|)
operator|)
condition|)
block|{
name|verbatim
operator||=
operator|(
operator|*
name|name
operator|==
literal|'*'
operator|)
expr_stmt|;
name|name
operator|+=
name|skip
expr_stmt|;
block|}
if|if
condition|(
name|verbatim
condition|)
name|fputs
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|asm_fprintf
argument_list|(
name|stream
argument_list|,
literal|"%U%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|TARGET_BPABI
condition|)
block|{
specifier|const
name|char
modifier|*
name|fpu_name
decl_stmt|;
if|if
condition|(
name|arm_select
index|[
literal|0
index|]
operator|.
name|string
condition|)
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.cpu %s\n"
argument_list|,
name|arm_select
index|[
literal|0
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arm_select
index|[
literal|1
index|]
operator|.
name|string
condition|)
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.arch %s\n"
argument_list|,
name|arm_select
index|[
literal|1
index|]
operator|.
name|string
argument_list|)
expr_stmt|;
else|else
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.cpu %s\n"
argument_list|,
name|all_cores
index|[
name|arm_default_cpu
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_SOFT_FLOAT
condition|)
block|{
if|if
condition|(
name|TARGET_VFP
condition|)
name|fpu_name
operator|=
literal|"softvfp"
expr_stmt|;
else|else
name|fpu_name
operator|=
literal|"softfpa"
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|arm_fpu_arch
condition|)
block|{
case|case
name|FPUTYPE_FPA
case|:
name|fpu_name
operator|=
literal|"fpa"
expr_stmt|;
break|break;
case|case
name|FPUTYPE_FPA_EMU2
case|:
name|fpu_name
operator|=
literal|"fpe2"
expr_stmt|;
break|break;
case|case
name|FPUTYPE_FPA_EMU3
case|:
name|fpu_name
operator|=
literal|"fpe3"
expr_stmt|;
break|break;
case|case
name|FPUTYPE_MAVERICK
case|:
name|fpu_name
operator|=
literal|"maverick"
expr_stmt|;
break|break;
case|case
name|FPUTYPE_VFP
case|:
if|if
condition|(
name|TARGET_HARD_FLOAT
condition|)
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 27, 3\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_HARD_FLOAT_ABI
condition|)
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 28, 1\n"
argument_list|)
expr_stmt|;
name|fpu_name
operator|=
literal|"vfp"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.fpu %s\n"
argument_list|,
name|fpu_name
argument_list|)
expr_stmt|;
comment|/* Some of these attributes only apply when the corresponding features          are used.  However we don't have any easy way of figuring this out. 	 Conservatively record the setting that would have been used.  */
comment|/* Tag_ABI_PCS_wchar_t.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 18, %d\n"
argument_list|,
operator|(
name|int
operator|)
name|WCHAR_TYPE_SIZE
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
comment|/* Tag_ABI_FP_rounding.  */
if|if
condition|(
name|flag_rounding_math
condition|)
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 19, 1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_unsafe_math_optimizations
condition|)
block|{
comment|/* Tag_ABI_FP_denomal.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 20, 1\n"
argument_list|)
expr_stmt|;
comment|/* Tag_ABI_FP_exceptions.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 21, 1\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Tag_ABI_FP_user_exceptions.  */
if|if
condition|(
name|flag_signaling_nans
condition|)
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 22, 1\n"
argument_list|)
expr_stmt|;
comment|/* Tag_ABI_FP_number_model.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 23, %d\n"
argument_list|,
name|flag_finite_math_only
condition|?
literal|1
else|:
literal|3
argument_list|)
expr_stmt|;
comment|/* Tag_ABI_align8_needed.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 24, 1\n"
argument_list|)
expr_stmt|;
comment|/* Tag_ABI_align8_preserved.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 25, 1\n"
argument_list|)
expr_stmt|;
comment|/* Tag_ABI_enum_size.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 26, %d\n"
argument_list|,
name|flag_short_enums
condition|?
literal|1
else|:
literal|2
argument_list|)
expr_stmt|;
comment|/* Tag_ABI_optimization_goals.  */
if|if
condition|(
name|optimize_size
condition|)
name|val
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|optimize
operator|>=
literal|2
condition|)
name|val
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|optimize
condition|)
name|val
operator|=
literal|1
expr_stmt|;
else|else
name|val
operator|=
literal|6
expr_stmt|;
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.eabi_attribute 30, %d\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|default_file_start
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_file_end
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
operator|!
name|thumb_call_reg_needed
condition|)
return|return;
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.code 16\n"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|LR_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
name|rtx
name|label
init|=
name|thumb_call_via_label
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|label
operator|!=
literal|0
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tbx\t%r\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|rtx
name|aof_pic_label
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AOF_ASSEMBLER
end_ifdef

begin_comment
comment|/* Special functions only needed when producing AOF syntax assembler.  */
end_comment

begin_struct
struct|struct
name|pic_chain
block|{
name|struct
name|pic_chain
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pic_chain
modifier|*
name|aof_pic_chain
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|rtx
name|aof_pic_entry
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|pic_chain
modifier|*
modifier|*
name|chainp
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|aof_pic_label
operator|==
name|NULL_RTX
condition|)
block|{
name|aof_pic_label
operator|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
literal|"x$adcons"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|chainp
operator|=
operator|&
name|aof_pic_chain
init|;
operator|*
name|chainp
condition|;
name|offset
operator|+=
literal|4
operator|,
name|chainp
operator|=
operator|&
operator|(
operator|*
name|chainp
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|(
operator|*
name|chainp
operator|)
operator|->
name|symname
operator|==
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|plus_constant
argument_list|(
name|aof_pic_label
argument_list|,
name|offset
argument_list|)
return|;
operator|*
name|chainp
operator|=
operator|(
expr|struct
name|pic_chain
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pic_chain
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|chainp
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|chainp
operator|)
operator|->
name|symname
operator|=
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|plus_constant
argument_list|(
name|aof_pic_label
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|aof_dump_pic_table
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|pic_chain
modifier|*
name|chain
decl_stmt|;
if|if
condition|(
name|aof_pic_chain
operator|==
name|NULL
condition|)
return|return;
name|asm_fprintf
argument_list|(
name|f
argument_list|,
literal|"\tAREA |%r$$adcons|, BASED %r\n"
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"|x$adcons|\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
for|for
control|(
name|chain
operator|=
name|aof_pic_chain
init|;
name|chain
condition|;
name|chain
operator|=
name|chain
operator|->
name|next
control|)
block|{
name|fputs
argument_list|(
literal|"\tDCD\t"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|f
argument_list|,
name|chain
operator|->
name|symname
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|arm_text_section_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A get_unnamed_section callback for switching to the text section.  */
end_comment

begin_function
specifier|static
name|void
name|aof_output_text_section_asm_op
parameter_list|(
specifier|const
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tAREA |C$$code%d|, CODE, READONLY"
argument_list|,
name|arm_text_section_count
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|", PIC, REENTRANT"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|arm_data_section_count
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A get_unnamed_section callback for switching to the data section.  */
end_comment

begin_function
specifier|static
name|void
name|aof_output_data_section_asm_op
parameter_list|(
specifier|const
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tAREA |C$$data%d|, DATA\n"
argument_list|,
name|arm_data_section_count
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_ASM_INIT_SECTIONS.     AOF Assembler syntax is a nightmare when it comes to areas, since once    we change from one area to another, we can't go back again.  Instead,    we must create a new area with the same attributes and add the new output    to that.  Unfortunately, there is nothing we can do here to guarantee that    two areas with the same attributes will be linked adjacently in the    resulting executable, so we have to be careful not to do pc-relative    addressing across such boundaries.  */
end_comment

begin_function
specifier|static
name|void
name|aof_asm_init_sections
parameter_list|(
name|void
parameter_list|)
block|{
name|text_section
operator|=
name|get_unnamed_section
argument_list|(
name|SECTION_CODE
argument_list|,
name|aof_output_text_section_asm_op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|data_section
operator|=
name|get_unnamed_section
argument_list|(
name|SECTION_WRITE
argument_list|,
name|aof_output_data_section_asm_op
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|readonly_data_section
operator|=
name|text_section
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zero_init_section
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|zero_init_count
init|=
literal|1
decl_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\tAREA |C$$zidata%d|,NOINIT\n"
argument_list|,
name|zero_init_count
operator|++
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The AOF assembler is religiously strict about declarations of    imported and exported symbols, so that it is impossible to declare    a function as imported near the beginning of the file, and then to    export it later on.  It is, however, possible to delay the decision    until all the functions in the file have been compiled.  To get    around this, we maintain a list of the imports and exports, and    delete from it any that are subsequently defined.  At the end of    compilation we spit the remainder of the list out before the END    directive.  */
end_comment

begin_struct
struct|struct
name|import
block|{
name|struct
name|import
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|import
modifier|*
name|imports_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|aof_add_import
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|import
modifier|*
name|new
decl_stmt|;
for|for
control|(
name|new
operator|=
name|imports_list
init|;
name|new
condition|;
name|new
operator|=
name|new
operator|->
name|next
control|)
if|if
condition|(
name|new
operator|->
name|name
operator|==
name|name
condition|)
return|return;
name|new
operator|=
operator|(
expr|struct
name|import
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|import
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|imports_list
expr_stmt|;
name|imports_list
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aof_delete_import
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|import
modifier|*
modifier|*
name|old
decl_stmt|;
for|for
control|(
name|old
operator|=
operator|&
name|imports_list
init|;
operator|*
name|old
condition|;
name|old
operator|=
operator|&
operator|(
operator|*
name|old
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|old
operator|)
operator|->
name|name
operator|==
name|name
condition|)
block|{
operator|*
name|old
operator|=
operator|(
operator|*
name|old
operator|)
operator|->
name|next
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_decl_stmt
name|int
name|arm_main_function
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|aof_dump_imports
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{
comment|/* The AOF assembler needs this to cause the startup code to be extracted      from the library.  Brining in __main causes the whole thing to work      automagically.  */
if|if
condition|(
name|arm_main_function
condition|)
block|{
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tIMPORT __main\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tDCD __main\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* Now dump the remaining imports.  */
while|while
condition|(
name|imports_list
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\tIMPORT\t"
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|f
argument_list|,
name|imports_list
operator|->
name|name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|imports_list
operator|=
name|imports_list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aof_globalize_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|default_globalize_label
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"main"
argument_list|)
condition|)
name|arm_main_function
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aof_file_start
parameter_list|(
name|void
parameter_list|)
block|{
name|fputs
argument_list|(
literal|"__r0\tRN\t0\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__a1\tRN\t0\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__a2\tRN\t1\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__a3\tRN\t2\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__a4\tRN\t3\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v1\tRN\t4\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v2\tRN\t5\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v3\tRN\t6\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v4\tRN\t7\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v5\tRN\t8\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__v6\tRN\t9\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__sl\tRN\t10\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__fp\tRN\t11\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__ip\tRN\t12\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__sp\tRN\t13\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__lr\tRN\t14\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__pc\tRN\t15\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f0\tFN\t0\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f1\tFN\t1\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f2\tFN\t2\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f3\tFN\t3\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f4\tFN\t4\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f5\tFN\t5\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f6\tFN\t6\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"__f7\tFN\t7\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|aof_file_end
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|flag_pic
condition|)
name|aof_dump_pic_table
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|arm_file_end
argument_list|()
expr_stmt|;
name|aof_dump_imports
argument_list|(
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tEND\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AOF_ASSEMBLER */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARM_PE
end_ifndef

begin_comment
comment|/* Symbols in the text segment can be accessed without indirecting via the    constant pool; it may take an extra binary operation, but this is still    faster than indirecting via memory.  Don't do this when not optimizing,    since we won't be calculating al of the offsets necessary to do this    simplification.  */
end_comment

begin_function
specifier|static
name|void
name|arm_encode_section_info
parameter_list|(
name|tree
name|decl
parameter_list|,
name|rtx
name|rtl
parameter_list|,
name|int
name|first
parameter_list|)
block|{
comment|/* This doesn't work with AOF syntax, since the string table may be in      a different AREA.  */
ifndef|#
directive|ifndef
name|AOF_ASSEMBLER
if|if
condition|(
name|optimize
operator|>
literal|0
operator|&&
name|TREE_CONSTANT
argument_list|(
name|decl
argument_list|)
condition|)
name|SYMBOL_REF_FLAG
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* If we are referencing a function that is weak then encode a long call      flag in the function name, otherwise if the function is static or      or known to be defined in this file then encode a short call flag.  */
if|if
condition|(
name|first
operator|&&
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_WEAK
argument_list|(
name|decl
argument_list|)
condition|)
name|arm_encode_call_attribute
argument_list|(
name|decl
argument_list|,
name|LONG_CALL_FLAG_CHAR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|arm_encode_call_attribute
argument_list|(
name|decl
argument_list|,
name|SHORT_CALL_FLAG_CHAR
argument_list|)
expr_stmt|;
block|}
name|default_encode_section_info
argument_list|(
name|decl
argument_list|,
name|rtl
argument_list|,
name|first
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !ARM_PE */
end_comment

begin_function
specifier|static
name|void
name|arm_internal_label
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|unsigned
name|long
name|labelno
parameter_list|)
block|{
if|if
condition|(
name|arm_ccfsm_state
operator|==
literal|3
operator|&&
operator|(
name|unsigned
operator|)
name|arm_target_label
operator|==
name|labelno
operator|&&
operator|!
name|strcmp
argument_list|(
name|prefix
argument_list|,
literal|"L"
argument_list|)
condition|)
block|{
name|arm_ccfsm_state
operator|=
literal|0
expr_stmt|;
name|arm_target_insn
operator|=
name|NULL
expr_stmt|;
block|}
name|default_internal_label
argument_list|(
name|stream
argument_list|,
name|prefix
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output code to add DELTA to the first argument, and then jump    to FUNCTION.  Used for C++ multiple inheritance.  */
end_comment

begin_function
specifier|static
name|void
name|arm_output_mi_thunk
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|tree
name|thunk
name|ATTRIBUTE_UNUSED
parameter_list|,
name|HOST_WIDE_INT
name|delta
parameter_list|,
name|HOST_WIDE_INT
name|vcall_offset
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|function
parameter_list|)
block|{
specifier|static
name|int
name|thunk_label
init|=
literal|0
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|char
name|labelpc
index|[
literal|256
index|]
decl_stmt|;
name|int
name|mi_delta
init|=
name|delta
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|mi_op
init|=
name|mi_delta
operator|<
literal|0
condition|?
literal|"sub"
else|:
literal|"add"
decl_stmt|;
name|int
name|shift
init|=
literal|0
decl_stmt|;
name|int
name|this_regno
init|=
operator|(
name|aggregate_value_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|,
name|function
argument_list|)
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|mi_delta
operator|<
literal|0
condition|)
name|mi_delta
operator|=
operator|-
name|mi_delta
expr_stmt|;
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
name|int
name|labelno
init|=
name|thunk_label
operator|++
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LTHUMBFUNC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tldr\tr12, "
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
block|{
comment|/* If we are generating PIC, the ldr instruction below loads 	     "(target - 7) - .LTHUNKPCn" into r12.  The pc reads as 	     the address of the add + 8, so we have:  	     r12 = (target - 7) - .LTHUNKPCn + (.LTHUNKPCn + 8) 	         = target + 1.  	     Note that we have "+ 1" because some versions of GNU ld 	     don't set the low bit of the result for R_ARM_REL32 	     relocations against thumb function symbols.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|labelpc
argument_list|,
literal|"LTHUNKPC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|labelpc
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\tadd\tr12, pc, r12\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|mi_delta
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|mi_delta
operator|&
operator|(
literal|3
operator|<<
name|shift
operator|)
operator|)
operator|==
literal|0
condition|)
name|shift
operator|+=
literal|2
expr_stmt|;
else|else
block|{
name|asm_fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s\t%r, %r, #%d\n"
argument_list|,
name|mi_op
argument_list|,
name|this_regno
argument_list|,
name|this_regno
argument_list|,
name|mi_delta
operator|&
operator|(
literal|0xff
operator|<<
name|shift
operator|)
argument_list|)
expr_stmt|;
name|mi_delta
operator|&=
operator|~
operator|(
literal|0xff
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TARGET_THUMB
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\tbx\tr12\n"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|file
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|":\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pic
condition|)
block|{
comment|/* Output ".word .LTHUNKn-7-.LTHUNKPCn".  */
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tem
operator|=
name|gen_rtx_PLUS
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|tem
argument_list|,
name|GEN_INT
argument_list|(
operator|-
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|tem
operator|=
name|gen_rtx_MINUS
argument_list|(
name|GET_MODE
argument_list|(
name|tem
argument_list|)
argument_list|,
name|tem
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|ggc_strdup
argument_list|(
name|labelpc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assemble_integer
argument_list|(
name|tem
argument_list|,
literal|4
argument_list|,
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Output ".word .LTHUNKn".  */
name|assemble_integer
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|4
argument_list|,
name|BITS_PER_WORD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|"\tb\t"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|file
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|function
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NEED_PLT_RELOC
condition|)
name|fputs
argument_list|(
literal|"(PLT)"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|arm_emit_vector_const
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|pattern
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_VECTOR
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|V2SImode
case|:
name|pattern
operator|=
literal|"%08x"
expr_stmt|;
break|break;
case|case
name|V4HImode
case|:
name|pattern
operator|=
literal|"%04x"
expr_stmt|;
break|break;
case|case
name|V8QImode
case|:
name|pattern
operator|=
literal|"%02x"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
init|;
name|i
operator|--
condition|;
control|)
block|{
name|rtx
name|element
decl_stmt|;
name|element
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
name|pattern
argument_list|,
name|INTVAL
argument_list|(
name|element
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|arm_output_load_gr
parameter_list|(
name|rtx
modifier|*
name|operands
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|;
name|rtx
name|offset
decl_stmt|;
name|rtx
name|wcgr
decl_stmt|;
name|rtx
name|sum
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|sum
operator|=
name|XEXP
argument_list|(
name|operands
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|reg
operator|=
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|offset
operator|=
name|XEXP
argument_list|(
name|sum
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|<
literal|1024
operator|)
operator|&&
operator|(
name|INTVAL
argument_list|(
name|offset
argument_list|)
operator|>
operator|-
literal|1024
operator|)
operator|)
condition|)
return|return
literal|"wldrw%?\t%0, %1"
return|;
comment|/* Fix up an out-of-range load of a GR register.  */
name|output_asm_insn
argument_list|(
literal|"str%?\t%0, [sp, #-4]!\t@ Start of GR load expansion"
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
name|wcgr
operator|=
name|operands
index|[
literal|0
index|]
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|reg
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|operands
index|[
literal|0
index|]
operator|=
name|wcgr
expr_stmt|;
name|operands
index|[
literal|1
index|]
operator|=
name|reg
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"tmcr%?\t%0, %1"
argument_list|,
name|operands
argument_list|)
expr_stmt|;
name|output_asm_insn
argument_list|(
literal|"ldr%?\t%0, [sp], #4\t@ End of GR load expansion"
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_comment
comment|/* Worker function for TARGET_SETUP_INCOMING_VARARGS.     On the ARM, PRETEND_SIZE is set in order to have the prologue push the last    named arg and all anonymous args onto the stack.    XXX I know the prologue shouldn't be pushing registers, but it is faster    that way.  */
end_comment

begin_function
specifier|static
name|void
name|arm_setup_incoming_varargs
parameter_list|(
name|CUMULATIVE_ARGS
modifier|*
name|cum
parameter_list|,
name|enum
name|machine_mode
name|mode
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|type
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
modifier|*
name|pretend_size
parameter_list|,
name|int
name|second_time
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|cfun
operator|->
name|machine
operator|->
name|uses_anonymous_args
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cum
operator|->
name|nregs
operator|<
name|NUM_ARG_REGS
condition|)
operator|*
name|pretend_size
operator|=
operator|(
name|NUM_ARG_REGS
operator|-
name|cum
operator|->
name|nregs
operator|)
operator|*
name|UNITS_PER_WORD
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the CONSUMER instruction (a store) does not need    PRODUCER's value to calculate the address.  */
end_comment

begin_function
name|int
name|arm_no_early_store_addr_dep
parameter_list|(
name|rtx
name|producer
parameter_list|,
name|rtx
name|consumer
parameter_list|)
block|{
name|rtx
name|value
init|=
name|PATTERN
argument_list|(
name|producer
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|PATTERN
argument_list|(
name|consumer
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|value
operator|=
name|COND_EXEC_CODE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARALLEL
condition|)
name|value
operator|=
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|addr
operator|=
name|COND_EXEC_CODE
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PARALLEL
condition|)
name|addr
operator|=
name|XVECEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|value
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the CONSUMER instruction (an ALU op) does not    have an early register shift value or amount dependency on the    result of PRODUCER.  */
end_comment

begin_function
name|int
name|arm_no_early_alu_shift_dep
parameter_list|(
name|rtx
name|producer
parameter_list|,
name|rtx
name|consumer
parameter_list|)
block|{
name|rtx
name|value
init|=
name|PATTERN
argument_list|(
name|producer
argument_list|)
decl_stmt|;
name|rtx
name|op
init|=
name|PATTERN
argument_list|(
name|consumer
argument_list|)
decl_stmt|;
name|rtx
name|early_op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|value
operator|=
name|COND_EXEC_CODE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARALLEL
condition|)
name|value
operator|=
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|op
operator|=
name|COND_EXEC_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PARALLEL
condition|)
name|op
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|early_op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is either an actual independent shift, or a shift applied to      the first operand of another operation.  We want the whole shift      operation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|early_op
argument_list|)
operator|==
name|REG
condition|)
name|early_op
operator|=
name|op
expr_stmt|;
return|return
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|value
argument_list|,
name|early_op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the CONSUMER instruction (an ALU op) does not    have an early register shift value dependency on the result of    PRODUCER.  */
end_comment

begin_function
name|int
name|arm_no_early_alu_shift_value_dep
parameter_list|(
name|rtx
name|producer
parameter_list|,
name|rtx
name|consumer
parameter_list|)
block|{
name|rtx
name|value
init|=
name|PATTERN
argument_list|(
name|producer
argument_list|)
decl_stmt|;
name|rtx
name|op
init|=
name|PATTERN
argument_list|(
name|consumer
argument_list|)
decl_stmt|;
name|rtx
name|early_op
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|value
operator|=
name|COND_EXEC_CODE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARALLEL
condition|)
name|value
operator|=
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|op
operator|=
name|COND_EXEC_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PARALLEL
condition|)
name|op
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|early_op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is either an actual independent shift, or a shift applied to      the first operand of another operation.  We want the value being      shifted, in either case.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|early_op
argument_list|)
operator|!=
name|REG
condition|)
name|early_op
operator|=
name|XEXP
argument_list|(
name|early_op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|value
argument_list|,
name|early_op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the CONSUMER (a mul or mac op) does not    have an early register mult dependency on the result of    PRODUCER.  */
end_comment

begin_function
name|int
name|arm_no_early_mul_dep
parameter_list|(
name|rtx
name|producer
parameter_list|,
name|rtx
name|consumer
parameter_list|)
block|{
name|rtx
name|value
init|=
name|PATTERN
argument_list|(
name|producer
argument_list|)
decl_stmt|;
name|rtx
name|op
init|=
name|PATTERN
argument_list|(
name|consumer
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|value
operator|=
name|COND_EXEC_CODE
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PARALLEL
condition|)
name|value
operator|=
name|XVECEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
name|XEXP
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|op
operator|=
name|COND_EXEC_CODE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PARALLEL
condition|)
name|op
operator|=
name|XVECEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op
operator|=
name|XEXP
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|GET_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|PLUS
operator|&&
operator|!
name|reg_overlap_mentioned_p
argument_list|(
name|value
argument_list|,
name|XEXP
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* We can't rely on the caller doing the proper promotion when    using APCS or ATPCS.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_promote_prototypes
parameter_list|(
name|tree
name|t
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
return|return
operator|!
name|TARGET_AAPCS_BASED
return|;
block|}
end_function

begin_comment
comment|/* AAPCS based ABIs use short enums by default.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_default_short_enums
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TARGET_AAPCS_BASED
operator|&&
name|arm_abi
operator|!=
name|ARM_ABI_AAPCS_LINUX
return|;
block|}
end_function

begin_comment
comment|/* AAPCS requires that anonymous bitfields affect structure alignment.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_align_anon_bitfield
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TARGET_AAPCS_BASED
return|;
block|}
end_function

begin_comment
comment|/* The generic C++ ABI says 64-bit (long long).  The EABI says 32-bit.  */
end_comment

begin_function
specifier|static
name|tree
name|arm_cxx_guard_type
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TARGET_AAPCS_BASED
condition|?
name|integer_type_node
else|:
name|long_long_integer_type_node
return|;
block|}
end_function

begin_comment
comment|/* The EABI says test the least significant bit of a guard variable.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_cxx_guard_mask_bit
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TARGET_AAPCS_BASED
return|;
block|}
end_function

begin_comment
comment|/* The EABI specifies that all array cookies are 8 bytes long.  */
end_comment

begin_function
specifier|static
name|tree
name|arm_get_cookie_size
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|TARGET_AAPCS_BASED
condition|)
return|return
name|default_cxx_get_cookie_size
argument_list|(
name|type
argument_list|)
return|;
name|size
operator|=
name|build_int_cst
argument_list|(
name|sizetype
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* The EABI says that array cookies should also contain the element size.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_cookie_has_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TARGET_AAPCS_BASED
return|;
block|}
end_function

begin_comment
comment|/* The EABI says constructors and destructors should return a pointer to    the object constructed/destroyed.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_cxx_cdtor_returns_this
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TARGET_AAPCS_BASED
return|;
block|}
end_function

begin_comment
comment|/* The EABI says that an inline function may never be the key    method.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_cxx_key_method_may_be_inline
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|!
name|TARGET_AAPCS_BASED
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_cxx_determine_class_data_visibility
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|TARGET_AAPCS_BASED
condition|)
return|return;
comment|/* In general, \S 3.2.5.5 of the ARM EABI requires that class data      is exported.  However, on systems without dynamic vague linkage,      \S 3.2.5.6 says that COMDAT class data has hidden linkage.  */
if|if
condition|(
operator|!
name|TARGET_ARM_DYNAMIC_VAGUE_LINKAGE_P
operator|&&
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|VISIBILITY_HIDDEN
expr_stmt|;
else|else
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arm_cxx_class_data_always_comdat
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* \S 3.2.5.4 of the ARM C++ ABI says that class data only have      vague linkage if the class has no key function.  */
return|return
operator|!
name|TARGET_AAPCS_BASED
return|;
block|}
end_function

begin_comment
comment|/* The EABI says __aeabi_atexit should be used to register static    destructors.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_cxx_use_aeabi_atexit
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|TARGET_AAPCS_BASED
return|;
block|}
end_function

begin_function
name|void
name|arm_set_return_address
parameter_list|(
name|rtx
name|source
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
name|HOST_WIDE_INT
name|delta
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|unsigned
name|long
name|saved_regs
decl_stmt|;
name|saved_regs
operator|=
name|arm_compute_save_reg_mask
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|saved_regs
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
operator|)
operator|==
literal|0
condition|)
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|frame_pointer_needed
condition|)
name|addr
operator|=
name|plus_constant
argument_list|(
name|hard_frame_pointer_rtx
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* LR will be the first saved register.  */
name|offsets
operator|=
name|arm_get_frame_offsets
argument_list|()
expr_stmt|;
name|delta
operator|=
name|offsets
operator|->
name|outgoing_args
operator|-
operator|(
name|offsets
operator|->
name|frame
operator|+
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>=
literal|4096
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|scratch
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|GEN_INT
argument_list|(
name|delta
operator|&
operator|~
literal|4095
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|scratch
expr_stmt|;
name|delta
operator|&=
literal|4095
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|stack_pointer_rtx
expr_stmt|;
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|gen_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|thumb_set_return_address
parameter_list|(
name|rtx
name|source
parameter_list|,
name|rtx
name|scratch
parameter_list|)
block|{
name|arm_stack_offsets
modifier|*
name|offsets
decl_stmt|;
name|HOST_WIDE_INT
name|delta
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|mask
operator|=
name|thumb_compute_save_reg_mask
argument_list|()
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|LR_REGNUM
operator|)
condition|)
block|{
name|offsets
operator|=
name|arm_get_frame_offsets
argument_list|()
expr_stmt|;
comment|/* Find the saved regs.  */
if|if
condition|(
name|frame_pointer_needed
condition|)
block|{
name|delta
operator|=
name|offsets
operator|->
name|soft_frame
operator|-
name|offsets
operator|->
name|saved_args
expr_stmt|;
name|reg
operator|=
name|THUMB_HARD_FRAME_POINTER_REGNUM
expr_stmt|;
block|}
else|else
block|{
name|delta
operator|=
name|offsets
operator|->
name|outgoing_args
operator|-
name|offsets
operator|->
name|saved_args
expr_stmt|;
name|reg
operator|=
name|SP_REGNUM
expr_stmt|;
block|}
comment|/* Allow for the stack frame.  */
if|if
condition|(
name|TARGET_BACKTRACE
condition|)
name|delta
operator|-=
literal|16
expr_stmt|;
comment|/* The link register is always the first saved register.  */
name|delta
operator|-=
literal|4
expr_stmt|;
comment|/* Construct the address.  */
name|addr
operator|=
name|gen_rtx_REG
argument_list|(
name|SImode
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg
operator|!=
name|SP_REGNUM
operator|&&
name|delta
operator|>=
literal|128
operator|)
operator|||
name|delta
operator|>=
literal|1024
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_movsi
argument_list|(
name|scratch
argument_list|,
name|GEN_INT
argument_list|(
name|delta
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_addsi3
argument_list|(
name|scratch
argument_list|,
name|scratch
argument_list|,
name|stack_pointer_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|scratch
expr_stmt|;
block|}
else|else
name|addr
operator|=
name|plus_constant
argument_list|(
name|addr
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|gen_frame_mem
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
else|else
name|emit_move_insn
argument_list|(
name|gen_rtx_REG
argument_list|(
name|Pmode
argument_list|,
name|LR_REGNUM
argument_list|)
argument_list|,
name|source
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implements target hook vector_mode_supported_p.  */
end_comment

begin_function
name|bool
name|arm_vector_mode_supported_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mode
operator|==
name|V2SImode
operator|)
operator|||
operator|(
name|mode
operator|==
name|V4HImode
operator|)
operator|||
operator|(
name|mode
operator|==
name|V8QImode
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Implement TARGET_SHIFT_TRUNCATION_MASK.  SImode shifts use normal    ARM insns and therefore guarantee that the shift count is modulo 256.    DImode shifts (those implemented by lib1funcs.asm or by optabs.c)    guarantee no particular behavior for out-of-range counts.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|arm_shift_truncation_mask
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
return|return
name|mode
operator|==
name|SImode
condition|?
literal|255
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Map internal gcc register numbers to DWARF2 register numbers.  */
end_comment

begin_function
name|unsigned
name|int
name|arm_dbx_register_number
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|<
literal|16
condition|)
return|return
name|regno
return|;
comment|/* TODO: Legacy targets output FPA regs as registers 16-23 for backwards      compatibility.  The EABI defines them as registers 96-103.  */
if|if
condition|(
name|IS_FPA_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
operator|(
name|TARGET_AAPCS_BASED
condition|?
literal|96
else|:
literal|16
operator|)
operator|+
name|regno
operator|-
name|FIRST_FPA_REGNUM
return|;
if|if
condition|(
name|IS_VFP_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|64
operator|+
name|regno
operator|-
name|FIRST_VFP_REGNUM
return|;
if|if
condition|(
name|IS_IWMMXT_GR_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|104
operator|+
name|regno
operator|-
name|FIRST_IWMMXT_GR_REGNUM
return|;
if|if
condition|(
name|IS_IWMMXT_REGNUM
argument_list|(
name|regno
argument_list|)
condition|)
return|return
literal|112
operator|+
name|regno
operator|-
name|FIRST_IWMMXT_REGNUM
return|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TARGET_UNWIND_INFO
end_ifdef

begin_comment
comment|/* Emit unwind directives for a store-multiple instruction.  This should    only ever be generated by the function prologue code, so we expect it    to have a particular form.  */
end_comment

begin_function
specifier|static
name|void
name|arm_unwind_emit_stm
parameter_list|(
name|FILE
modifier|*
name|asm_out_file
parameter_list|,
name|rtx
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|HOST_WIDE_INT
name|nregs
decl_stmt|;
name|int
name|reg_size
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|unsigned
name|lastreg
decl_stmt|;
name|rtx
name|e
decl_stmt|;
comment|/* First insn will adjust the stack pointer.  */
name|e
operator|=
name|XVECEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|e
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SP_REGNUM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|PLUS
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|nregs
operator|=
name|XVECLEN
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
expr_stmt|;
name|reg
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|<
literal|16
condition|)
block|{
comment|/* The function prologue may also push pc, but not annotate it as it is 	 never restored.  We turn this into a stack pointer adjustment.  */
if|if
condition|(
name|nregs
operator|*
literal|4
operator|==
name|offset
operator|-
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.pad #4\n"
argument_list|)
expr_stmt|;
name|offset
operator|-=
literal|4
expr_stmt|;
block|}
name|reg_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_VFP_REGNUM
argument_list|(
name|reg
argument_list|)
condition|)
block|{
comment|/* FPA register saves use an additional word.  */
name|offset
operator|-=
literal|4
expr_stmt|;
name|reg_size
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg
operator|>=
name|FIRST_FPA_REGNUM
operator|&&
name|reg
operator|<=
name|LAST_FPA_REGNUM
condition|)
block|{
comment|/* FPA registers are done differently.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save %r, %wd\n"
argument_list|,
name|reg
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
comment|/* Unknown register type.  */
name|abort
argument_list|()
expr_stmt|;
comment|/* If the stack increment doesn't match the size of the saved registers,      something has gone horribly wrong.  */
if|if
condition|(
name|offset
operator|!=
name|nregs
operator|*
name|reg_size
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save {"
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|lastreg
operator|=
literal|0
expr_stmt|;
comment|/* The remaining insns will describe the stores.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nregs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Expect (set (mem<addr>) (reg)).          Where<addr> is (reg:SP) or (plus (reg:SP) (const_int)).  */
name|e
operator|=
name|XVECEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|e
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|<
name|lastreg
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
comment|/* We can't use %r for vfp because we need to use the 	 double precision register names.  */
if|if
condition|(
name|IS_VFP_REGNUM
argument_list|(
name|reg
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"d%d"
argument_list|,
operator|(
name|reg
operator|-
name|FIRST_VFP_REGNUM
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
else|else
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%r"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Check that the addresses are consecutive.  */
name|e
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|e
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|offset
operator|+=
name|reg_size
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SP_REGNUM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
name|offset
operator|!=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|e
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|!=
literal|1
operator|||
name|GET_CODE
argument_list|(
name|e
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|e
argument_list|)
operator|!=
name|SP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Emit unwind directives for a SET.  */
end_comment

begin_function
specifier|static
name|void
name|arm_unwind_emit_set
parameter_list|(
name|FILE
modifier|*
name|asm_out_file
parameter_list|,
name|rtx
name|p
parameter_list|)
block|{
name|rtx
name|e0
decl_stmt|;
name|rtx
name|e1
decl_stmt|;
name|e0
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|e1
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|e0
argument_list|)
condition|)
block|{
case|case
name|MEM
case|:
comment|/* Pushing a single register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|e0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|e0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SP_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.save "
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VFP_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|e1
argument_list|)
argument_list|)
condition|)
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"{d%d}\n"
argument_list|,
operator|(
name|REGNO
argument_list|(
name|e1
argument_list|)
operator|-
name|FIRST_VFP_REGNUM
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
else|else
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"{%r}\n"
argument_list|,
name|REGNO
argument_list|(
name|e1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|e0
argument_list|)
operator|==
name|SP_REGNUM
condition|)
block|{
comment|/* A stack increment.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|e1
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SP_REGNUM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.pad #%wd\n"
argument_list|,
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REGNO
argument_list|(
name|e0
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
condition|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|e1
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.setfp %r, %r, #%wd\n"
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|,
name|reg
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|e1
argument_list|)
operator|==
name|REG
condition|)
block|{
name|reg
operator|=
name|REGNO
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.setfp %r, %r\n"
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|e1
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|e1
argument_list|)
operator|==
name|SP_REGNUM
condition|)
block|{
comment|/* Move from sp to reg.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.movsp %r\n"
argument_list|,
name|REGNO
argument_list|(
name|e0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|e1
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SP_REGNUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Set reg to offset from sp.  */
name|asm_fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.movsp %r, #%d\n"
argument_list|,
name|REGNO
argument_list|(
name|e0
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|e1
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit unwind directives for the given insn.  */
end_comment

begin_function
specifier|static
name|void
name|arm_unwind_emit
parameter_list|(
name|FILE
modifier|*
name|asm_out_file
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
operator|!
name|ARM_EABI_UNWIND_TABLES
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|||
operator|!
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
name|pat
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|pat
operator|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
name|arm_unwind_emit_set
argument_list|(
name|asm_out_file
argument_list|,
name|pat
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQUENCE
case|:
comment|/* Store multiple.  */
name|arm_unwind_emit_stm
argument_list|(
name|asm_out_file
argument_list|,
name|pat
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a reference from a function exception table to the type_info    object X.  The EABI specifies that the symbol should be relocated by    an R_ARM_TARGET2 relocation.  */
end_comment

begin_function
specifier|static
name|bool
name|arm_output_ttype
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|fputs
argument_list|(
literal|"\t.word\t"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Use special relocations for symbol references.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|fputs
argument_list|(
literal|"(TARGET2)"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_UNWIND_INFO */
end_comment

begin_comment
comment|/* Output unwind directives for the start/end of a function.  */
end_comment

begin_function
name|void
name|arm_output_fn_unwind
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|bool
name|prologue
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ARM_EABI_UNWIND_TABLES
condition|)
return|return;
if|if
condition|(
name|prologue
condition|)
name|fputs
argument_list|(
literal|"\t.fnstart\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"\t.fnend\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arm_emit_tls_decoration
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|tls_reloc
name|reloc
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|val
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reloc
operator|=
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|fp
argument_list|,
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|TLS_GD32
case|:
name|fputs
argument_list|(
literal|"(tlsgd)"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_LDM32
case|:
name|fputs
argument_list|(
literal|"(tlsldm)"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_LDO32
case|:
name|fputs
argument_list|(
literal|"(tlsldo)"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_IE32
case|:
name|fputs
argument_list|(
literal|"(gottpoff)"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TLS_LE32
case|:
name|fputs
argument_list|(
literal|"(tpoff)"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|reloc
condition|)
block|{
case|case
name|TLS_GD32
case|:
case|case
name|TLS_LDM32
case|:
case|case
name|TLS_IE32
case|:
name|fputs
argument_list|(
literal|" + (. - "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|fp
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" - "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|output_addr_const
argument_list|(
name|fp
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|')'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bool
name|arm_output_addr_const_extra
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_TLS
condition|)
return|return
name|arm_emit_tls_decoration
argument_list|(
name|fp
argument_list|,
name|x
argument_list|)
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|UNSPEC
operator|&&
name|XINT
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|==
name|UNSPEC_PIC_LABEL
condition|)
block|{
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|int
name|labelno
init|=
name|INTVAL
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LPIC"
argument_list|,
name|labelno
argument_list|)
expr_stmt|;
name|assemble_name_raw
argument_list|(
name|fp
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_VECTOR
condition|)
return|return
name|arm_emit_vector_const
argument_list|(
name|fp
argument_list|,
name|x
argument_list|)
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-arm.h"
end_include

end_unit

