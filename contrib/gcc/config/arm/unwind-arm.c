begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ARM EABI compliant unwinding routines.    Copyright (C) 2004, 2005 Free Software Foundation, Inc.    Contributed by Paul Brook     This file is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     In addition to the permissions in the GNU General Public License, the    Free Software Foundation gives you unlimited permission to link the    compiled version of this file into combinations with other programs,    and to distribute those combinations without any restriction coming    from the use of this file.  (The General Public License restrictions    do apply in other respects; for example, they cover modification of    the file, and distribution when not linked into a combine    executable.)     This file is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street, Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_define
define|#
directive|define
name|__ARM_STATIC_INLINE
end_define

begin_include
include|#
directive|include
file|"unwind.h"
end_include

begin_comment
comment|/* We add a prototype for abort here to avoid creating a dependency on    target headers.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|abort
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Definitions for C++ runtime support routines.  We make these weak    declarations to avoid pulling in libsupc++ unnecessarily.  */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|char
name|bool
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|_ZSt9type_info
name|type_info
typedef|;
end_typedef

begin_comment
comment|/* This names C++ type_info type */
end_comment

begin_decl_stmt
name|void
name|__attribute__
argument_list|(
operator|(
name|weak
operator|)
argument_list|)
name|__cxa_call_unexpected
argument_list|(
name|_Unwind_Control_Block
operator|*
name|ucbp
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|__attribute__
argument_list|(
operator|(
name|weak
operator|)
argument_list|)
name|__cxa_begin_cleanup
argument_list|(
name|_Unwind_Control_Block
operator|*
name|ucbp
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|__attribute__
argument_list|(
operator|(
name|weak
operator|)
argument_list|)
name|__cxa_type_match
argument_list|(
name|_Unwind_Control_Block
operator|*
name|ucbp
argument_list|,
specifier|const
name|type_info
operator|*
name|rttip
argument_list|,
name|void
operator|*
operator|*
name|matched_object
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|_Unwind_Ptr
name|__attribute__
argument_list|(
operator|(
name|weak
operator|)
argument_list|)
name|__gnu_Unwind_Find_exidx
argument_list|(
name|_Unwind_Ptr
argument_list|,
name|int
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Misc constants.  */
end_comment

begin_define
define|#
directive|define
name|R_IP
value|12
end_define

begin_define
define|#
directive|define
name|R_SP
value|13
end_define

begin_define
define|#
directive|define
name|R_LR
value|14
end_define

begin_define
define|#
directive|define
name|R_PC
value|15
end_define

begin_define
define|#
directive|define
name|EXIDX_CANTUNWIND
value|1
end_define

begin_define
define|#
directive|define
name|uint32_highbit
value|(((_uw) 1)<< 31)
end_define

begin_define
define|#
directive|define
name|UCB_FORCED_STOP_FN
parameter_list|(
name|ucbp
parameter_list|)
value|((ucbp)->unwinder_cache.reserved1)
end_define

begin_define
define|#
directive|define
name|UCB_PR_ADDR
parameter_list|(
name|ucbp
parameter_list|)
value|((ucbp)->unwinder_cache.reserved2)
end_define

begin_define
define|#
directive|define
name|UCB_SAVED_CALLSITE_ADDR
parameter_list|(
name|ucbp
parameter_list|)
value|((ucbp)->unwinder_cache.reserved3)
end_define

begin_define
define|#
directive|define
name|UCB_FORCED_STOP_ARG
parameter_list|(
name|ucbp
parameter_list|)
value|((ucbp)->unwinder_cache.reserved4)
end_define

begin_struct
struct|struct
name|core_regs
block|{
name|_uw
name|r
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We use normal integer types here to avoid the compiler generating    coprocessor instructions.  */
end_comment

begin_struct
struct|struct
name|vfp_regs
block|{
name|_uw64
name|d
index|[
literal|16
index|]
decl_stmt|;
name|_uw
name|pad
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fpa_reg
block|{
name|_uw
name|w
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fpa_regs
block|{
name|struct
name|fpa_reg
name|f
index|[
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Unwind descriptors.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|_uw16
name|length
decl_stmt|;
name|_uw16
name|offset
decl_stmt|;
block|}
name|EHT16
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|_uw
name|length
decl_stmt|;
name|_uw
name|offset
decl_stmt|;
block|}
name|EHT32
typedef|;
end_typedef

begin_comment
comment|/* The ABI specifies that the unwind routines may only use core registers,    except when actually manipulating coprocessor state.  This allows    us to write one implementation that works on all platforms by    demand-saving coprocessor registers.     During unwinding we hold the coprocessor state in the actual hardware    registers and allocate demand-save areas for use during phase1    unwinding.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* The first fields must be the same as a phase2_vrs.  */
name|_uw
name|demand_save_flags
decl_stmt|;
name|struct
name|core_regs
name|core
decl_stmt|;
name|_uw
name|prev_sp
decl_stmt|;
comment|/* Only valid during forced unwinding.  */
name|struct
name|vfp_regs
name|vfp
decl_stmt|;
name|struct
name|fpa_regs
name|fpa
decl_stmt|;
block|}
name|phase1_vrs
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DEMAND_SAVE_VFP
value|1
end_define

begin_comment
comment|/* This must match the structure created by the assembly wrappers.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|_uw
name|demand_save_flags
decl_stmt|;
name|struct
name|core_regs
name|core
decl_stmt|;
block|}
name|phase2_vrs
typedef|;
end_typedef

begin_comment
comment|/* An exception index table entry.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|__EIT_entry
block|{
name|_uw
name|fnoffset
decl_stmt|;
name|_uw
name|content
decl_stmt|;
block|}
name|__EIT_entry
typedef|;
end_typedef

begin_comment
comment|/* Assembly helper functions.  */
end_comment

begin_comment
comment|/* Restore core register state.  Never returns.  */
end_comment

begin_decl_stmt
name|void
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
name|restore_core_regs
argument_list|(
expr|struct
name|core_regs
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Coprocessor register state manipulation functions.  */
end_comment

begin_function_decl
name|void
name|__gnu_Unwind_Save_VFP
parameter_list|(
name|struct
name|vfp_regs
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__gnu_Unwind_Restore_VFP
parameter_list|(
name|struct
name|vfp_regs
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Restore coprocessor state after phase1 unwinding.  */
end_comment

begin_function
specifier|static
name|void
name|restore_non_core_regs
parameter_list|(
name|phase1_vrs
modifier|*
name|vrs
parameter_list|)
block|{
if|if
condition|(
operator|(
name|vrs
operator|->
name|demand_save_flags
operator|&
name|DEMAND_SAVE_VFP
operator|)
operator|==
literal|0
condition|)
name|__gnu_Unwind_Restore_VFP
argument_list|(
operator|&
name|vrs
operator|->
name|vfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A better way to do this would probably be to compare the absolute address    with a segment relative relocation of the same symbol.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|__text_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|__data_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The exception index table location.  */
end_comment

begin_decl_stmt
specifier|extern
name|__EIT_entry
name|__exidx_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|__EIT_entry
name|__exidx_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ABI defined personality routines.  */
end_comment

begin_function_decl
specifier|extern
name|_Unwind_Reason_Code
name|__aeabi_unwind_cpp_pr0
parameter_list|(
name|_Unwind_State
parameter_list|,
name|_Unwind_Control_Block
modifier|*
parameter_list|,
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// __attribute__((weak));
end_comment

begin_function_decl
specifier|extern
name|_Unwind_Reason_Code
name|__aeabi_unwind_cpp_pr1
parameter_list|(
name|_Unwind_State
parameter_list|,
name|_Unwind_Control_Block
modifier|*
parameter_list|,
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(weak
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|extern
name|_Unwind_Reason_Code
name|__aeabi_unwind_cpp_pr2
parameter_list|(
name|_Unwind_State
parameter_list|,
name|_Unwind_Control_Block
modifier|*
parameter_list|,
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|__attribute__
parameter_list|(
function_decl|(weak
end_function_decl

begin_empty_stmt
unit|))
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* ABI defined routine to store a virtual register to memory.  */
end_comment

begin_function
name|_Unwind_VRS_Result
name|_Unwind_VRS_Get
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_VRS_RegClass
name|regclass
parameter_list|,
name|_uw
name|regno
parameter_list|,
name|_Unwind_VRS_DataRepresentation
name|representation
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|phase1_vrs
modifier|*
name|vrs
init|=
operator|(
name|phase1_vrs
operator|*
operator|)
name|context
decl_stmt|;
switch|switch
condition|(
name|regclass
condition|)
block|{
case|case
name|_UVRSC_CORE
case|:
if|if
condition|(
name|representation
operator|!=
name|_UVRSD_UINT32
operator|||
name|regno
operator|>
literal|15
condition|)
return|return
name|_UVRSR_FAILED
return|;
operator|*
operator|(
name|_uw
operator|*
operator|)
name|valuep
operator|=
name|vrs
operator|->
name|core
operator|.
name|r
index|[
name|regno
index|]
expr_stmt|;
return|return
name|_UVRSR_OK
return|;
case|case
name|_UVRSC_VFP
case|:
case|case
name|_UVRSC_FPA
case|:
case|case
name|_UVRSC_WMMXD
case|:
case|case
name|_UVRSC_WMMXC
case|:
return|return
name|_UVRSR_NOT_IMPLEMENTED
return|;
default|default:
return|return
name|_UVRSR_FAILED
return|;
block|}
block|}
end_function

begin_comment
comment|/* ABI defined function to load a virtual register from memory.  */
end_comment

begin_function
name|_Unwind_VRS_Result
name|_Unwind_VRS_Set
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_VRS_RegClass
name|regclass
parameter_list|,
name|_uw
name|regno
parameter_list|,
name|_Unwind_VRS_DataRepresentation
name|representation
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|phase1_vrs
modifier|*
name|vrs
init|=
operator|(
name|phase1_vrs
operator|*
operator|)
name|context
decl_stmt|;
switch|switch
condition|(
name|regclass
condition|)
block|{
case|case
name|_UVRSC_CORE
case|:
if|if
condition|(
name|representation
operator|!=
name|_UVRSD_UINT32
operator|||
name|regno
operator|>
literal|15
condition|)
return|return
name|_UVRSR_FAILED
return|;
name|vrs
operator|->
name|core
operator|.
name|r
index|[
name|regno
index|]
operator|=
operator|*
operator|(
name|_uw
operator|*
operator|)
name|valuep
expr_stmt|;
return|return
name|_UVRSR_OK
return|;
case|case
name|_UVRSC_VFP
case|:
case|case
name|_UVRSC_FPA
case|:
case|case
name|_UVRSC_WMMXD
case|:
case|case
name|_UVRSC_WMMXC
case|:
return|return
name|_UVRSR_NOT_IMPLEMENTED
return|;
default|default:
return|return
name|_UVRSR_FAILED
return|;
block|}
block|}
end_function

begin_comment
comment|/* ABI defined function to pop registers off the stack.  */
end_comment

begin_function
name|_Unwind_VRS_Result
name|_Unwind_VRS_Pop
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_VRS_RegClass
name|regclass
parameter_list|,
name|_uw
name|discriminator
parameter_list|,
name|_Unwind_VRS_DataRepresentation
name|representation
parameter_list|)
block|{
name|phase1_vrs
modifier|*
name|vrs
init|=
operator|(
name|phase1_vrs
operator|*
operator|)
name|context
decl_stmt|;
switch|switch
condition|(
name|regclass
condition|)
block|{
case|case
name|_UVRSC_CORE
case|:
block|{
name|_uw
modifier|*
name|ptr
decl_stmt|;
name|_uw
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|representation
operator|!=
name|_UVRSD_UINT32
condition|)
return|return
name|_UVRSR_FAILED
return|;
name|mask
operator|=
name|discriminator
operator|&
literal|0xffff
expr_stmt|;
name|ptr
operator|=
operator|(
name|_uw
operator|*
operator|)
name|vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_SP
index|]
expr_stmt|;
comment|/* Pop the requested registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|vrs
operator|->
name|core
operator|.
name|r
index|[
name|i
index|]
operator|=
operator|*
operator|(
name|ptr
operator|++
operator|)
expr_stmt|;
block|}
comment|/* Writeback the stack pointer value if it wasn't restored.  */
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|R_SP
operator|)
operator|)
operator|==
literal|0
condition|)
name|vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_SP
index|]
operator|=
operator|(
name|_uw
operator|)
name|ptr
expr_stmt|;
block|}
return|return
name|_UVRSR_OK
return|;
case|case
name|_UVRSC_VFP
case|:
block|{
name|_uw
name|start
init|=
name|discriminator
operator|>>
literal|16
decl_stmt|;
name|_uw
name|count
init|=
name|discriminator
operator|&
literal|0xffff
decl_stmt|;
name|struct
name|vfp_regs
name|tmp
decl_stmt|;
name|_uw
modifier|*
name|sp
decl_stmt|;
name|_uw
modifier|*
name|dest
decl_stmt|;
if|if
condition|(
operator|(
name|representation
operator|!=
name|_UVRSD_VFPX
operator|&&
name|representation
operator|!=
name|_UVRSD_DOUBLE
operator|)
operator|||
name|start
operator|+
name|count
operator|>
literal|16
condition|)
return|return
name|_UVRSR_FAILED
return|;
if|if
condition|(
name|vrs
operator|->
name|demand_save_flags
operator|&
name|DEMAND_SAVE_VFP
condition|)
block|{
comment|/* Demand-save resisters for stage1.  */
name|vrs
operator|->
name|demand_save_flags
operator|&=
operator|~
name|DEMAND_SAVE_VFP
expr_stmt|;
name|__gnu_Unwind_Save_VFP
argument_list|(
operator|&
name|vrs
operator|->
name|vfp
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the registers from the stack.  Do this by saving the 	   current VFP registers to a memory area, moving the in-memory 	   values into that area, and restoring from the whole area. 	   For _UVRSD_VFPX we assume FSTMX standard format 1.  */
name|__gnu_Unwind_Save_VFP
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* The stack address is only guaranteed to be word aligned, so 	   we can't use doubleword copies.  */
name|sp
operator|=
operator|(
name|_uw
operator|*
operator|)
name|vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_SP
index|]
expr_stmt|;
name|dest
operator|=
operator|(
name|_uw
operator|*
operator|)
operator|&
name|tmp
operator|.
name|d
index|[
name|start
index|]
expr_stmt|;
name|count
operator|*=
literal|2
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
operator|*
operator|(
name|dest
operator|++
operator|)
operator|=
operator|*
operator|(
name|sp
operator|++
operator|)
expr_stmt|;
comment|/* Skip the pad word */
if|if
condition|(
name|representation
operator|==
name|_UVRSD_VFPX
condition|)
name|sp
operator|++
expr_stmt|;
comment|/* Set the new stack pointer.  */
name|vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_SP
index|]
operator|=
operator|(
name|_uw
operator|)
name|sp
expr_stmt|;
comment|/* Reload the registers.  */
name|__gnu_Unwind_Restore_VFP
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|_UVRSR_OK
return|;
case|case
name|_UVRSC_FPA
case|:
case|case
name|_UVRSC_WMMXD
case|:
case|case
name|_UVRSC_WMMXC
case|:
return|return
name|_UVRSR_NOT_IMPLEMENTED
return|;
default|default:
return|return
name|_UVRSR_FAILED
return|;
block|}
block|}
end_function

begin_comment
comment|/* Core unwinding functions.  */
end_comment

begin_comment
comment|/* Calculate the address encoded by a 31-bit self-relative offset at address    P.  */
end_comment

begin_function
specifier|static
specifier|inline
name|_uw
name|selfrel_offset31
parameter_list|(
specifier|const
name|_uw
modifier|*
name|p
parameter_list|)
block|{
name|_uw
name|offset
decl_stmt|;
name|offset
operator|=
operator|*
name|p
expr_stmt|;
comment|/* Sign extend to 32 bits.  */
if|if
condition|(
name|offset
operator|&
operator|(
literal|1
operator|<<
literal|30
operator|)
condition|)
name|offset
operator||=
literal|1u
operator|<<
literal|31
expr_stmt|;
else|else
name|offset
operator|&=
operator|~
operator|(
literal|1u
operator|<<
literal|31
operator|)
expr_stmt|;
return|return
name|offset
operator|+
operator|(
name|_uw
operator|)
name|p
return|;
block|}
end_function

begin_comment
comment|/* Perform a binary search for RETURN_ADDRESS in TABLE.  The table contains    NREC entries.  */
end_comment

begin_function
specifier|static
specifier|const
name|__EIT_entry
modifier|*
name|search_EIT_table
parameter_list|(
specifier|const
name|__EIT_entry
modifier|*
name|table
parameter_list|,
name|int
name|nrec
parameter_list|,
name|_uw
name|return_address
parameter_list|)
block|{
name|_uw
name|next_fn
decl_stmt|;
name|_uw
name|this_fn
decl_stmt|;
name|int
name|n
decl_stmt|,
name|left
decl_stmt|,
name|right
decl_stmt|;
if|if
condition|(
name|nrec
operator|==
literal|0
condition|)
return|return
operator|(
name|__EIT_entry
operator|*
operator|)
literal|0
return|;
name|left
operator|=
literal|0
expr_stmt|;
name|right
operator|=
name|nrec
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|n
operator|=
operator|(
name|left
operator|+
name|right
operator|)
operator|/
literal|2
expr_stmt|;
name|this_fn
operator|=
name|selfrel_offset31
argument_list|(
operator|&
name|table
index|[
name|n
index|]
operator|.
name|fnoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|nrec
operator|-
literal|1
condition|)
name|next_fn
operator|=
name|selfrel_offset31
argument_list|(
operator|&
name|table
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|fnoffset
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|next_fn
operator|=
operator|(
name|_uw
operator|)
literal|0
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|return_address
operator|<
name|this_fn
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|left
condition|)
return|return
operator|(
name|__EIT_entry
operator|*
operator|)
literal|0
return|;
name|right
operator|=
name|n
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|return_address
operator|<=
name|next_fn
condition|)
return|return
operator|&
name|table
index|[
name|n
index|]
return|;
else|else
name|left
operator|=
name|n
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the exception index table eintry for the given address.    Fill in the relevant fields of the UCB.    Returns _URC_FAILURE if an error occurred, _URC_OK on success.  */
end_comment

begin_function
specifier|static
name|_Unwind_Reason_Code
name|get_eit_entry
parameter_list|(
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|,
name|_uw
name|return_address
parameter_list|)
block|{
specifier|const
name|__EIT_entry
modifier|*
name|eitp
decl_stmt|;
name|int
name|nrec
decl_stmt|;
comment|/* The return address is the address of the instruction following the      call instruction (plus one in thumb mode).  If this was the last      instruction in the function the address will lie in the following      function.  Subtract 2 from the address so that it points within the call      instruction itself.  */
name|return_address
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|__gnu_Unwind_Find_exidx
condition|)
block|{
name|eitp
operator|=
operator|(
specifier|const
name|__EIT_entry
operator|*
operator|)
name|__gnu_Unwind_Find_exidx
argument_list|(
name|return_address
argument_list|,
operator|&
name|nrec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eitp
condition|)
block|{
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|_URC_FAILURE
return|;
block|}
block|}
else|else
block|{
name|eitp
operator|=
operator|&
name|__exidx_start
expr_stmt|;
name|nrec
operator|=
operator|&
name|__exidx_end
operator|-
operator|&
name|__exidx_start
expr_stmt|;
block|}
name|eitp
operator|=
name|search_EIT_table
argument_list|(
name|eitp
argument_list|,
name|nrec
argument_list|,
name|return_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eitp
condition|)
block|{
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|_URC_FAILURE
return|;
block|}
name|ucbp
operator|->
name|pr_cache
operator|.
name|fnstart
operator|=
name|selfrel_offset31
argument_list|(
operator|&
name|eitp
operator|->
name|fnoffset
argument_list|)
expr_stmt|;
comment|/* Can this frame be unwound at all?  */
if|if
condition|(
name|eitp
operator|->
name|content
operator|==
name|EXIDX_CANTUNWIND
condition|)
block|{
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|_URC_END_OF_STACK
return|;
block|}
comment|/* Obtain the address of the "real" __EHT_Header word.  */
if|if
condition|(
name|eitp
operator|->
name|content
operator|&
name|uint32_highbit
condition|)
block|{
comment|/* It is immediate data.  */
name|ucbp
operator|->
name|pr_cache
operator|.
name|ehtp
operator|=
operator|(
name|_Unwind_EHT_Header
operator|*
operator|)
operator|&
name|eitp
operator|->
name|content
expr_stmt|;
name|ucbp
operator|->
name|pr_cache
operator|.
name|additional
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* The low 31 bits of the content field are a self-relative 	 offset to an _Unwind_EHT_Entry structure.  */
name|ucbp
operator|->
name|pr_cache
operator|.
name|ehtp
operator|=
operator|(
name|_Unwind_EHT_Header
operator|*
operator|)
name|selfrel_offset31
argument_list|(
operator|&
name|eitp
operator|->
name|content
argument_list|)
expr_stmt|;
name|ucbp
operator|->
name|pr_cache
operator|.
name|additional
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Discover the personality routine address.  */
if|if
condition|(
operator|*
name|ucbp
operator|->
name|pr_cache
operator|.
name|ehtp
operator|&
operator|(
literal|1u
operator|<<
literal|31
operator|)
condition|)
block|{
comment|/* One of the predefined standard routines.  */
name|_uw
name|idx
init|=
operator|(
operator|*
operator|(
name|_uw
operator|*
operator|)
name|ucbp
operator|->
name|pr_cache
operator|.
name|ehtp
operator|>>
literal|24
operator|)
operator|&
literal|0xf
decl_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|=
operator|(
name|_uw
operator|)
operator|&
name|__aeabi_unwind_cpp_pr0
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|==
literal|1
condition|)
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|=
operator|(
name|_uw
operator|)
operator|&
name|__aeabi_unwind_cpp_pr1
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|==
literal|2
condition|)
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|=
operator|(
name|_uw
operator|)
operator|&
name|__aeabi_unwind_cpp_pr2
expr_stmt|;
else|else
block|{
comment|/* Failed */
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|_URC_FAILURE
return|;
block|}
block|}
else|else
block|{
comment|/* Execute region offset to PR */
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|=
name|selfrel_offset31
argument_list|(
name|ucbp
operator|->
name|pr_cache
operator|.
name|ehtp
argument_list|)
expr_stmt|;
block|}
return|return
name|_URC_OK
return|;
block|}
end_function

begin_comment
comment|/* Perform phase2 unwinding.  VRS is the initial virtual register state.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
name|unwind_phase2
argument_list|(
name|_Unwind_Control_Block
operator|*
name|ucbp
argument_list|,
name|phase2_vrs
operator|*
name|vrs
argument_list|)
block|{
name|_Unwind_Reason_Code
name|pr_result
decl_stmt|;
do|do
block|{
comment|/* Find the entry for this routine.  */
if|if
condition|(
name|get_eit_entry
argument_list|(
name|ucbp
argument_list|,
name|vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_PC
index|]
argument_list|)
operator|!=
name|_URC_OK
condition|)
name|abort
argument_list|()
expr_stmt|;
name|UCB_SAVED_CALLSITE_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|=
name|vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_PC
index|]
expr_stmt|;
comment|/* Call the pr to decide what to do.  */
name|pr_result
operator|=
operator|(
operator|(
name|personality_routine
operator|)
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|)
operator|(
name|_US_UNWIND_FRAME_STARTING
operator|,
name|ucbp
operator|,
operator|(
name|_Unwind_Context
operator|*
operator|)
name|vrs
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|pr_result
operator|==
name|_URC_CONTINUE_UNWIND
condition|)
do|;
if|if
condition|(
name|pr_result
operator|!=
name|_URC_INSTALL_CONTEXT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|restore_core_regs
argument_list|(
operator|&
name|vrs
operator|->
name|core
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Perform phase2 forced unwinding.  */
end_comment

begin_function
specifier|static
name|_Unwind_Reason_Code
name|unwind_phase2_forced
parameter_list|(
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|,
name|phase2_vrs
modifier|*
name|entry_vrs
parameter_list|,
name|int
name|resuming
parameter_list|)
block|{
name|_Unwind_Stop_Fn
name|stop_fn
init|=
operator|(
name|_Unwind_Stop_Fn
operator|)
name|UCB_FORCED_STOP_FN
argument_list|(
name|ucbp
argument_list|)
decl_stmt|;
name|void
modifier|*
name|stop_arg
init|=
operator|(
name|void
operator|*
operator|)
name|UCB_FORCED_STOP_ARG
argument_list|(
name|ucbp
argument_list|)
decl_stmt|;
name|_Unwind_Reason_Code
name|pr_result
init|=
literal|0
decl_stmt|;
comment|/* We use phase1_vrs here even though we do not demand save, for the      prev_sp field.  */
name|phase1_vrs
name|saved_vrs
decl_stmt|,
name|next_vrs
decl_stmt|;
comment|/* Save the core registers.  */
name|saved_vrs
operator|.
name|core
operator|=
name|entry_vrs
operator|->
name|core
expr_stmt|;
comment|/* We don't need to demand-save the non-core registers, because we      unwind in a single pass.  */
name|saved_vrs
operator|.
name|demand_save_flags
operator|=
literal|0
expr_stmt|;
comment|/* Unwind until we reach a propagation barrier.  */
do|do
block|{
name|_Unwind_State
name|action
decl_stmt|;
name|_Unwind_Reason_Code
name|entry_code
decl_stmt|;
name|_Unwind_Reason_Code
name|stop_code
decl_stmt|;
comment|/* Find the entry for this routine.  */
name|entry_code
operator|=
name|get_eit_entry
argument_list|(
name|ucbp
argument_list|,
name|saved_vrs
operator|.
name|core
operator|.
name|r
index|[
name|R_PC
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|resuming
condition|)
block|{
name|action
operator|=
name|_US_UNWIND_FRAME_RESUME
operator||
name|_US_FORCE_UNWIND
expr_stmt|;
name|resuming
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|action
operator|=
name|_US_UNWIND_FRAME_STARTING
operator||
name|_US_FORCE_UNWIND
expr_stmt|;
if|if
condition|(
name|entry_code
operator|==
name|_URC_OK
condition|)
block|{
name|UCB_SAVED_CALLSITE_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|=
name|saved_vrs
operator|.
name|core
operator|.
name|r
index|[
name|R_PC
index|]
expr_stmt|;
name|next_vrs
operator|=
name|saved_vrs
expr_stmt|;
comment|/* Call the pr to decide what to do.  */
name|pr_result
operator|=
operator|(
operator|(
name|personality_routine
operator|)
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|)
operator|(
name|action
operator|,
name|ucbp
operator|,
operator|(
name|void
operator|*
operator|)
operator|&
name|next_vrs
operator|)
expr_stmt|;
name|saved_vrs
operator|.
name|prev_sp
operator|=
name|next_vrs
operator|.
name|core
operator|.
name|r
index|[
name|R_SP
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Treat any failure as the end of unwinding, to cope more 	     gracefully with missing EH information.  Mixed EH and 	     non-EH within one object will usually result in failure, 	     because the .ARM.exidx tables do not indicate the end 	     of the code to which they apply; but mixed EH and non-EH 	     shared objects should return an unwind failure at the 	     entry of a non-EH shared object.  */
name|action
operator||=
name|_US_END_OF_STACK
expr_stmt|;
name|saved_vrs
operator|.
name|prev_sp
operator|=
name|saved_vrs
operator|.
name|core
operator|.
name|r
index|[
name|R_SP
index|]
expr_stmt|;
block|}
name|stop_code
operator|=
name|stop_fn
argument_list|(
literal|1
argument_list|,
name|action
argument_list|,
name|ucbp
operator|->
name|exception_class
argument_list|,
name|ucbp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|saved_vrs
argument_list|,
name|stop_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_code
operator|!=
name|_URC_NO_REASON
condition|)
return|return
name|_URC_FAILURE
return|;
if|if
condition|(
name|entry_code
operator|!=
name|_URC_OK
condition|)
return|return
name|entry_code
return|;
name|saved_vrs
operator|=
name|next_vrs
expr_stmt|;
block|}
do|while
condition|(
name|pr_result
operator|==
name|_URC_CONTINUE_UNWIND
condition|)
do|;
if|if
condition|(
name|pr_result
operator|!=
name|_URC_INSTALL_CONTEXT
condition|)
block|{
comment|/* Some sort of failure has occurred in the pr and probably the 	 pr returned _URC_FAILURE.  */
return|return
name|_URC_FAILURE
return|;
block|}
name|restore_core_regs
argument_list|(
operator|&
name|saved_vrs
operator|.
name|core
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a very limited implementation of _Unwind_GetCFA.  It returns    the stack pointer as it is about to be unwound, and is only valid    while calling the stop function during forced unwinding.  If the    current personality routine result is going to run a cleanup, this    will not be the CFA; but when the frame is really unwound, it will    be.  */
end_comment

begin_function
name|_Unwind_Word
name|_Unwind_GetCFA
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
operator|(
name|phase1_vrs
operator|*
operator|)
name|context
operator|)
operator|->
name|prev_sp
return|;
block|}
end_function

begin_comment
comment|/* Perform phase1 unwinding.  UCBP is the exception being thrown, and    entry_VRS is the register state on entry to _Unwind_RaiseException.  */
end_comment

begin_function_decl
name|_Unwind_Reason_Code
name|__gnu_Unwind_RaiseException
parameter_list|(
name|_Unwind_Control_Block
modifier|*
parameter_list|,
name|phase2_vrs
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|_Unwind_Reason_Code
name|__gnu_Unwind_RaiseException
parameter_list|(
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|,
name|phase2_vrs
modifier|*
name|entry_vrs
parameter_list|)
block|{
name|phase1_vrs
name|saved_vrs
decl_stmt|;
name|_Unwind_Reason_Code
name|pr_result
decl_stmt|;
comment|/* Set the pc to the call site.  */
name|entry_vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_PC
index|]
operator|=
name|entry_vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_LR
index|]
expr_stmt|;
comment|/* Save the core registers.  */
name|saved_vrs
operator|.
name|core
operator|=
name|entry_vrs
operator|->
name|core
expr_stmt|;
comment|/* Set demand-save flags.  */
name|saved_vrs
operator|.
name|demand_save_flags
operator|=
operator|~
operator|(
name|_uw
operator|)
literal|0
expr_stmt|;
comment|/* Unwind until we reach a propagation barrier.  */
do|do
block|{
comment|/* Find the entry for this routine.  */
if|if
condition|(
name|get_eit_entry
argument_list|(
name|ucbp
argument_list|,
name|saved_vrs
operator|.
name|core
operator|.
name|r
index|[
name|R_PC
index|]
argument_list|)
operator|!=
name|_URC_OK
condition|)
return|return
name|_URC_FAILURE
return|;
comment|/* Call the pr to decide what to do.  */
name|pr_result
operator|=
operator|(
operator|(
name|personality_routine
operator|)
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|)
operator|(
name|_US_VIRTUAL_UNWIND_FRAME
operator|,
name|ucbp
operator|,
operator|(
name|void
operator|*
operator|)
operator|&
name|saved_vrs
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|pr_result
operator|==
name|_URC_CONTINUE_UNWIND
condition|)
do|;
comment|/* We've unwound as far as we want to go, so restore the original      register state.  */
name|restore_non_core_regs
argument_list|(
operator|&
name|saved_vrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr_result
operator|!=
name|_URC_HANDLER_FOUND
condition|)
block|{
comment|/* Some sort of failure has occurred in the pr and probably the 	 pr returned _URC_FAILURE.  */
return|return
name|_URC_FAILURE
return|;
block|}
name|unwind_phase2
argument_list|(
name|ucbp
argument_list|,
name|entry_vrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume unwinding after a cleanup has been run.  UCBP is the exception    being thrown and ENTRY_VRS is the register state on entry to    _Unwind_Resume.  */
end_comment

begin_function_decl
name|_Unwind_Reason_Code
name|__gnu_Unwind_ForcedUnwind
parameter_list|(
name|_Unwind_Control_Block
modifier|*
parameter_list|,
name|_Unwind_Stop_Fn
parameter_list|,
name|void
modifier|*
parameter_list|,
name|phase2_vrs
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|_Unwind_Reason_Code
name|__gnu_Unwind_ForcedUnwind
parameter_list|(
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|,
name|_Unwind_Stop_Fn
name|stop_fn
parameter_list|,
name|void
modifier|*
name|stop_arg
parameter_list|,
name|phase2_vrs
modifier|*
name|entry_vrs
parameter_list|)
block|{
name|UCB_FORCED_STOP_FN
argument_list|(
name|ucbp
argument_list|)
operator|=
operator|(
name|_uw
operator|)
name|stop_fn
expr_stmt|;
name|UCB_FORCED_STOP_ARG
argument_list|(
name|ucbp
argument_list|)
operator|=
operator|(
name|_uw
operator|)
name|stop_arg
expr_stmt|;
comment|/* Set the pc to the call site.  */
name|entry_vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_PC
index|]
operator|=
name|entry_vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_LR
index|]
expr_stmt|;
return|return
name|unwind_phase2_forced
argument_list|(
name|ucbp
argument_list|,
name|entry_vrs
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function_decl
name|_Unwind_Reason_Code
name|__gnu_Unwind_Resume
parameter_list|(
name|_Unwind_Control_Block
modifier|*
parameter_list|,
name|phase2_vrs
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|_Unwind_Reason_Code
name|__gnu_Unwind_Resume
parameter_list|(
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|,
name|phase2_vrs
modifier|*
name|entry_vrs
parameter_list|)
block|{
name|_Unwind_Reason_Code
name|pr_result
decl_stmt|;
comment|/* Recover the saved address.  */
name|entry_vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_PC
index|]
operator|=
name|UCB_SAVED_CALLSITE_ADDR
argument_list|(
name|ucbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|UCB_FORCED_STOP_FN
argument_list|(
name|ucbp
argument_list|)
condition|)
block|{
name|unwind_phase2_forced
argument_list|(
name|ucbp
argument_list|,
name|entry_vrs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We can't return failure at this point.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Call the cached PR.  */
name|pr_result
operator|=
operator|(
operator|(
name|personality_routine
operator|)
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|)
operator|(
name|_US_UNWIND_FRAME_RESUME
operator|,
name|ucbp
operator|,
operator|(
name|_Unwind_Context
operator|*
operator|)
name|entry_vrs
operator|)
expr_stmt|;
switch|switch
condition|(
name|pr_result
condition|)
block|{
case|case
name|_URC_INSTALL_CONTEXT
case|:
comment|/* Upload the registers to enter the landing pad.  */
name|restore_core_regs
argument_list|(
operator|&
name|entry_vrs
operator|->
name|core
argument_list|)
expr_stmt|;
case|case
name|_URC_CONTINUE_UNWIND
case|:
comment|/* Continue unwinding the next frame.  */
name|unwind_phase2
argument_list|(
name|ucbp
argument_list|,
name|entry_vrs
argument_list|)
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
name|_Unwind_Reason_Code
name|__gnu_Unwind_Resume_or_Rethrow
parameter_list|(
name|_Unwind_Control_Block
modifier|*
parameter_list|,
name|phase2_vrs
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|_Unwind_Reason_Code
name|__gnu_Unwind_Resume_or_Rethrow
parameter_list|(
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|,
name|phase2_vrs
modifier|*
name|entry_vrs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|UCB_FORCED_STOP_FN
argument_list|(
name|ucbp
argument_list|)
condition|)
return|return
name|__gnu_Unwind_RaiseException
argument_list|(
name|ucbp
argument_list|,
name|entry_vrs
argument_list|)
return|;
comment|/* Set the pc to the call site.  */
name|entry_vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_PC
index|]
operator|=
name|entry_vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_LR
index|]
expr_stmt|;
comment|/* Continue unwinding the next frame.  */
return|return
name|unwind_phase2_forced
argument_list|(
name|ucbp
argument_list|,
name|entry_vrs
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clean up an exception object when unwinding is complete.  */
end_comment

begin_decl_stmt
name|void
name|_Unwind_Complete
argument_list|(
name|_Unwind_Control_Block
operator|*
name|ucbp
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{ }
end_decl_stmt

begin_comment
comment|/* Get the _Unwind_Control_Block from an _Unwind_Context.  */
end_comment

begin_function
specifier|static
specifier|inline
name|_Unwind_Control_Block
modifier|*
name|unwind_UCB_from_context
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
operator|(
name|_Unwind_Control_Block
operator|*
operator|)
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|R_IP
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free an exception.  */
end_comment

begin_function
name|void
name|_Unwind_DeleteException
parameter_list|(
name|_Unwind_Exception
modifier|*
name|exc
parameter_list|)
block|{
if|if
condition|(
name|exc
operator|->
name|exception_cleanup
condition|)
call|(
modifier|*
name|exc
operator|->
name|exception_cleanup
call|)
argument_list|(
name|_URC_FOREIGN_EXCEPTION_CAUGHT
argument_list|,
name|exc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform stack backtrace through unwind data.  */
end_comment

begin_function_decl
name|_Unwind_Reason_Code
name|__gnu_Unwind_Backtrace
parameter_list|(
name|_Unwind_Trace_Fn
name|trace
parameter_list|,
name|void
modifier|*
name|trace_argument
parameter_list|,
name|phase2_vrs
modifier|*
name|entry_vrs
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|_Unwind_Reason_Code
name|__gnu_Unwind_Backtrace
parameter_list|(
name|_Unwind_Trace_Fn
name|trace
parameter_list|,
name|void
modifier|*
name|trace_argument
parameter_list|,
name|phase2_vrs
modifier|*
name|entry_vrs
parameter_list|)
block|{
name|phase1_vrs
name|saved_vrs
decl_stmt|;
name|_Unwind_Reason_Code
name|code
decl_stmt|;
name|_Unwind_Control_Block
name|ucb
decl_stmt|;
name|_Unwind_Control_Block
modifier|*
name|ucbp
init|=
operator|&
name|ucb
decl_stmt|;
comment|/* Set the pc to the call site.  */
name|entry_vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_PC
index|]
operator|=
name|entry_vrs
operator|->
name|core
operator|.
name|r
index|[
name|R_LR
index|]
expr_stmt|;
comment|/* Save the core registers.  */
name|saved_vrs
operator|.
name|core
operator|=
name|entry_vrs
operator|->
name|core
expr_stmt|;
comment|/* Set demand-save flags.  */
name|saved_vrs
operator|.
name|demand_save_flags
operator|=
operator|~
operator|(
name|_uw
operator|)
literal|0
expr_stmt|;
do|do
block|{
comment|/* Find the entry for this routine.  */
if|if
condition|(
name|get_eit_entry
argument_list|(
name|ucbp
argument_list|,
name|saved_vrs
operator|.
name|core
operator|.
name|r
index|[
name|R_PC
index|]
argument_list|)
operator|!=
name|_URC_OK
condition|)
block|{
name|code
operator|=
name|_URC_FAILURE
expr_stmt|;
break|break;
block|}
comment|/* The dwarf unwinder assumes the context structure holds things 	 like the function and LSDA pointers.  The ARM implementation 	 caches these in the exception header (UCB).  To avoid 	 rewriting everything we make the virtual IP register point at 	 the UCB.  */
name|_Unwind_SetGR
argument_list|(
operator|(
name|_Unwind_Context
operator|*
operator|)
operator|&
name|saved_vrs
argument_list|,
literal|12
argument_list|,
operator|(
name|_Unwind_Ptr
operator|)
name|ucbp
argument_list|)
expr_stmt|;
comment|/* Call trace function.  */
if|if
condition|(
call|(
modifier|*
name|trace
call|)
argument_list|(
operator|(
name|_Unwind_Context
operator|*
operator|)
operator|&
name|saved_vrs
argument_list|,
name|trace_argument
argument_list|)
operator|!=
name|_URC_NO_REASON
condition|)
block|{
name|code
operator|=
name|_URC_FAILURE
expr_stmt|;
break|break;
block|}
comment|/* Call the pr to decide what to do.  */
name|code
operator|=
operator|(
operator|(
name|personality_routine
operator|)
name|UCB_PR_ADDR
argument_list|(
name|ucbp
argument_list|)
operator|)
operator|(
name|_US_VIRTUAL_UNWIND_FRAME
operator||
name|_US_FORCE_UNWIND
operator|,
name|ucbp
operator|,
operator|(
name|void
operator|*
operator|)
operator|&
name|saved_vrs
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|code
operator|!=
name|_URC_END_OF_STACK
operator|&&
name|code
operator|!=
name|_URC_FAILURE
condition|)
do|;
name|finish
label|:
name|restore_non_core_regs
argument_list|(
operator|&
name|saved_vrs
argument_list|)
expr_stmt|;
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/* Common implementation for ARM ABI defined personality routines.    ID is the index of the personality routine, other arguments are as defined    by __aeabi_unwind_cpp_pr{0,1,2}.  */
end_comment

begin_function
specifier|static
name|_Unwind_Reason_Code
name|__gnu_unwind_pr_common
parameter_list|(
name|_Unwind_State
name|state
parameter_list|,
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|,
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|__gnu_unwind_state
name|uws
decl_stmt|;
name|_uw
modifier|*
name|data
decl_stmt|;
name|_uw
name|offset
decl_stmt|;
name|_uw
name|len
decl_stmt|;
name|_uw
name|rtti_count
decl_stmt|;
name|int
name|phase2_call_unexpected_after_unwind
init|=
literal|0
decl_stmt|;
name|int
name|in_range
init|=
literal|0
decl_stmt|;
name|int
name|forced_unwind
init|=
name|state
operator|&
name|_US_FORCE_UNWIND
decl_stmt|;
name|state
operator|&=
name|_US_ACTION_MASK
expr_stmt|;
name|data
operator|=
operator|(
name|_uw
operator|*
operator|)
name|ucbp
operator|->
name|pr_cache
operator|.
name|ehtp
expr_stmt|;
name|uws
operator|.
name|data
operator|=
operator|*
operator|(
name|data
operator|++
operator|)
expr_stmt|;
name|uws
operator|.
name|next
operator|=
name|data
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
name|uws
operator|.
name|data
operator|<<=
literal|8
expr_stmt|;
name|uws
operator|.
name|words_left
operator|=
literal|0
expr_stmt|;
name|uws
operator|.
name|bytes_left
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|uws
operator|.
name|words_left
operator|=
operator|(
name|uws
operator|.
name|data
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|uws
operator|.
name|data
operator|<<=
literal|16
expr_stmt|;
name|uws
operator|.
name|bytes_left
operator|=
literal|2
expr_stmt|;
name|data
operator|+=
name|uws
operator|.
name|words_left
expr_stmt|;
block|}
comment|/* Restore the saved pointer.  */
if|if
condition|(
name|state
operator|==
name|_US_UNWIND_FRAME_RESUME
condition|)
name|data
operator|=
operator|(
name|_uw
operator|*
operator|)
name|ucbp
operator|->
name|cleanup_cache
operator|.
name|bitpattern
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ucbp
operator|->
name|pr_cache
operator|.
name|additional
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Process descriptors.  */
while|while
condition|(
operator|*
name|data
condition|)
block|{
name|_uw
name|addr
decl_stmt|;
name|_uw
name|fnstart
decl_stmt|;
if|if
condition|(
name|id
operator|==
literal|2
condition|)
block|{
name|len
operator|=
operator|(
operator|(
name|EHT32
operator|*
operator|)
name|data
operator|)
operator|->
name|length
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
name|EHT32
operator|*
operator|)
name|data
operator|)
operator|->
name|offset
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
operator|(
operator|(
name|EHT16
operator|*
operator|)
name|data
operator|)
operator|->
name|length
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
name|EHT16
operator|*
operator|)
name|data
operator|)
operator|->
name|offset
expr_stmt|;
name|data
operator|++
expr_stmt|;
block|}
name|fnstart
operator|=
name|ucbp
operator|->
name|pr_cache
operator|.
name|fnstart
operator|+
operator|(
name|offset
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|addr
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|R_PC
argument_list|)
expr_stmt|;
name|in_range
operator|=
operator|(
name|fnstart
operator|<=
name|addr
operator|&&
name|addr
operator|<
name|fnstart
operator|+
operator|(
name|len
operator|&
operator|~
literal|1
operator|)
operator|)
expr_stmt|;
switch|switch
condition|(
operator|(
operator|(
name|offset
operator|&
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|len
operator|&
literal|1
operator|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* Cleanup.  */
if|if
condition|(
name|state
operator|!=
name|_US_VIRTUAL_UNWIND_FRAME
operator|&&
name|in_range
condition|)
block|{
comment|/* Cleanup in range, and we are running cleanups.  */
name|_uw
name|lp
decl_stmt|;
comment|/* Landing pad address is 31-bit pc-relative offset.  */
name|lp
operator|=
name|selfrel_offset31
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
comment|/* Save the exception data pointer.  */
name|ucbp
operator|->
name|cleanup_cache
operator|.
name|bitpattern
index|[
literal|0
index|]
operator|=
operator|(
name|_uw
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|__cxa_begin_cleanup
argument_list|(
name|ucbp
argument_list|)
condition|)
return|return
name|_URC_FAILURE
return|;
comment|/* Setup the VRS to enter the landing pad.  */
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
name|R_PC
argument_list|,
name|lp
argument_list|)
expr_stmt|;
return|return
name|_URC_INSTALL_CONTEXT
return|;
block|}
comment|/* Cleanup not in range, or we are in stage 1.  */
name|data
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Catch handler.  */
if|if
condition|(
name|state
operator|==
name|_US_VIRTUAL_UNWIND_FRAME
condition|)
block|{
if|if
condition|(
name|in_range
condition|)
block|{
comment|/* Check for a barrier.  */
name|_uw
name|rtti
decl_stmt|;
name|void
modifier|*
name|matched
decl_stmt|;
comment|/* Check for no-throw areas.  */
if|if
condition|(
name|data
index|[
literal|1
index|]
operator|==
operator|(
name|_uw
operator|)
operator|-
literal|2
condition|)
return|return
name|_URC_FAILURE
return|;
comment|/* The thrown object immediately follows the ECB.  */
name|matched
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ucbp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|data
index|[
literal|1
index|]
operator|!=
operator|(
name|_uw
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Match a catch specification.  */
name|rtti
operator|=
name|_Unwind_decode_target2
argument_list|(
operator|(
name|_uw
operator|)
operator|&
name|data
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|__cxa_type_match
argument_list|(
name|ucbp
argument_list|,
operator|(
name|type_info
operator|*
operator|)
name|rtti
argument_list|,
operator|&
name|matched
argument_list|)
condition|)
name|matched
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|matched
condition|)
block|{
name|ucbp
operator|->
name|barrier_cache
operator|.
name|sp
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|R_SP
argument_list|)
expr_stmt|;
name|ucbp
operator|->
name|barrier_cache
operator|.
name|bitpattern
index|[
literal|0
index|]
operator|=
operator|(
name|_uw
operator|)
name|matched
expr_stmt|;
name|ucbp
operator|->
name|barrier_cache
operator|.
name|bitpattern
index|[
literal|1
index|]
operator|=
operator|(
name|_uw
operator|)
name|data
expr_stmt|;
return|return
name|_URC_HANDLER_FOUND
return|;
block|}
block|}
comment|/* Handler out of range, or not matched.  */
block|}
elseif|else
if|if
condition|(
name|ucbp
operator|->
name|barrier_cache
operator|.
name|sp
operator|==
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|R_SP
argument_list|)
operator|&&
name|ucbp
operator|->
name|barrier_cache
operator|.
name|bitpattern
index|[
literal|1
index|]
operator|==
operator|(
name|_uw
operator|)
name|data
condition|)
block|{
comment|/* Matched a previous propagation barrier.  */
name|_uw
name|lp
decl_stmt|;
comment|/* Setup for entry to the handler.  */
name|lp
operator|=
name|selfrel_offset31
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
name|R_PC
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
operator|(
name|_uw
operator|)
name|ucbp
argument_list|)
expr_stmt|;
return|return
name|_URC_INSTALL_CONTEXT
return|;
block|}
comment|/* Catch handler not matched.  Advance to the next descriptor.  */
name|data
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rtti_count
operator|=
name|data
index|[
literal|0
index|]
operator|&
literal|0x7fffffff
expr_stmt|;
comment|/* Exception specification.  */
if|if
condition|(
name|state
operator|==
name|_US_VIRTUAL_UNWIND_FRAME
condition|)
block|{
if|if
condition|(
name|in_range
operator|&&
operator|(
operator|!
name|forced_unwind
operator|||
operator|!
name|rtti_count
operator|)
condition|)
block|{
comment|/* Match against the exception specification.  */
name|_uw
name|i
decl_stmt|;
name|_uw
name|rtti
decl_stmt|;
name|void
modifier|*
name|matched
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rtti_count
condition|;
name|i
operator|++
control|)
block|{
name|matched
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ucbp
operator|+
literal|1
operator|)
expr_stmt|;
name|rtti
operator|=
name|_Unwind_decode_target2
argument_list|(
operator|(
name|_uw
operator|)
operator|&
name|data
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cxa_type_match
argument_list|(
name|ucbp
argument_list|,
operator|(
name|type_info
operator|*
operator|)
name|rtti
argument_list|,
operator|&
name|matched
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|rtti_count
condition|)
block|{
comment|/* Exception does not match the spec.  */
name|ucbp
operator|->
name|barrier_cache
operator|.
name|sp
operator|=
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|R_SP
argument_list|)
expr_stmt|;
name|ucbp
operator|->
name|barrier_cache
operator|.
name|bitpattern
index|[
literal|0
index|]
operator|=
operator|(
name|_uw
operator|)
name|matched
expr_stmt|;
name|ucbp
operator|->
name|barrier_cache
operator|.
name|bitpattern
index|[
literal|1
index|]
operator|=
operator|(
name|_uw
operator|)
name|data
expr_stmt|;
return|return
name|_URC_HANDLER_FOUND
return|;
block|}
block|}
comment|/* Handler out of range, or exception is permitted.  */
block|}
elseif|else
if|if
condition|(
name|ucbp
operator|->
name|barrier_cache
operator|.
name|sp
operator|==
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|R_SP
argument_list|)
operator|&&
name|ucbp
operator|->
name|barrier_cache
operator|.
name|bitpattern
index|[
literal|1
index|]
operator|==
operator|(
name|_uw
operator|)
name|data
condition|)
block|{
comment|/* Matched a previous propagation barrier.  */
name|_uw
name|lp
decl_stmt|;
comment|/* Record the RTTI list for __cxa_call_unexpected.  */
name|ucbp
operator|->
name|barrier_cache
operator|.
name|bitpattern
index|[
literal|1
index|]
operator|=
name|rtti_count
expr_stmt|;
name|ucbp
operator|->
name|barrier_cache
operator|.
name|bitpattern
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ucbp
operator|->
name|barrier_cache
operator|.
name|bitpattern
index|[
literal|3
index|]
operator|=
literal|4
expr_stmt|;
name|ucbp
operator|->
name|barrier_cache
operator|.
name|bitpattern
index|[
literal|4
index|]
operator|=
operator|(
name|_uw
operator|)
operator|&
name|data
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|&
name|uint32_highbit
condition|)
name|phase2_call_unexpected_after_unwind
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|data
operator|+=
name|rtti_count
operator|+
literal|1
expr_stmt|;
comment|/* Setup for entry to the handler.  */
name|lp
operator|=
name|selfrel_offset31
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
name|R_PC
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
operator|(
name|_uw
operator|)
name|ucbp
argument_list|)
expr_stmt|;
return|return
name|_URC_INSTALL_CONTEXT
return|;
block|}
block|}
if|if
condition|(
name|data
index|[
literal|0
index|]
operator|&
name|uint32_highbit
condition|)
name|data
operator|++
expr_stmt|;
name|data
operator|+=
name|rtti_count
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* Should never happen.  */
return|return
name|_URC_FAILURE
return|;
block|}
comment|/* Finished processing this descriptor.  */
block|}
block|}
if|if
condition|(
name|__gnu_unwind_execute
argument_list|(
name|context
argument_list|,
operator|&
name|uws
argument_list|)
operator|!=
name|_URC_OK
condition|)
return|return
name|_URC_FAILURE
return|;
if|if
condition|(
name|phase2_call_unexpected_after_unwind
condition|)
block|{
comment|/* Enter __cxa_unexpected as if called from the call site.  */
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
name|R_LR
argument_list|,
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
name|R_PC
argument_list|)
argument_list|)
expr_stmt|;
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
name|R_PC
argument_list|,
operator|(
name|_uw
operator|)
operator|&
name|__cxa_call_unexpected
argument_list|)
expr_stmt|;
return|return
name|_URC_INSTALL_CONTEXT
return|;
block|}
return|return
name|_URC_CONTINUE_UNWIND
return|;
block|}
end_function

begin_comment
comment|/* ABI defined personality routine entry points.  */
end_comment

begin_function
name|_Unwind_Reason_Code
name|__aeabi_unwind_cpp_pr0
parameter_list|(
name|_Unwind_State
name|state
parameter_list|,
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|,
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|__gnu_unwind_pr_common
argument_list|(
name|state
argument_list|,
name|ucbp
argument_list|,
name|context
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|_Unwind_Reason_Code
name|__aeabi_unwind_cpp_pr1
parameter_list|(
name|_Unwind_State
name|state
parameter_list|,
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|,
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|__gnu_unwind_pr_common
argument_list|(
name|state
argument_list|,
name|ucbp
argument_list|,
name|context
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|_Unwind_Reason_Code
name|__aeabi_unwind_cpp_pr2
parameter_list|(
name|_Unwind_State
name|state
parameter_list|,
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|,
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|__gnu_unwind_pr_common
argument_list|(
name|state
argument_list|,
name|ucbp
argument_list|,
name|context
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* These two should never be used.  */
end_comment

begin_decl_stmt
name|_Unwind_Ptr
name|_Unwind_GetDataRelBase
argument_list|(
name|_Unwind_Context
operator|*
name|context
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|_Unwind_Ptr
name|_Unwind_GetTextRelBase
argument_list|(
name|_Unwind_Context
operator|*
name|context
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/* FreeBSD expects these to be functions */
end_comment

begin_function
name|_Unwind_Ptr
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|)
block|{
return|return
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
literal|15
argument_list|)
operator|&
operator|~
operator|(
name|_Unwind_Word
operator|)
literal|1
return|;
block|}
end_function

begin_function
name|_Unwind_Ptr
name|_Unwind_GetIPInfo
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
modifier|*
name|ip_before_insn
parameter_list|)
block|{
operator|*
name|ip_before_insn
operator|=
literal|0
expr_stmt|;
return|return
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
literal|15
argument_list|)
operator|&
operator|~
operator|(
name|_Unwind_Word
operator|)
literal|1
return|;
block|}
end_function

begin_function
name|void
name|_Unwind_SetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|_Unwind_Ptr
name|val
parameter_list|)
block|{
name|_Unwind_SetGR
argument_list|(
name|context
argument_list|,
literal|15
argument_list|,
name|val
operator||
operator|(
name|_Unwind_GetGR
argument_list|(
name|context
argument_list|,
literal|15
argument_list|)
operator|&
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

