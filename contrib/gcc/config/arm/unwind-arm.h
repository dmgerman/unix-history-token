begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Header file for the ARM EABI unwinder    Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.    Contributed by Paul Brook     This file is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     In addition to the permissions in the GNU General Public License, the    Free Software Foundation gives you unlimited permission to link the    compiled version of this file into combinations with other programs,    and to distribute those combinations without any restriction coming    from the use of this file.  (The General Public License restrictions    do apply in other respects; for example, they cover modification of    the file, and distribution when not linked into a combine    executable.)     This file is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; see the file COPYING.  If not, write to    the Free Software Foundation, 51 Franklin Street, Fifth Floor,    Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Language-independent unwinder header public defines.  This contains both    ABI defined objects, and GNU support routines.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNWIND_ARM_H
end_ifndef

begin_define
define|#
directive|define
name|UNWIND_ARM_H
end_define

begin_define
define|#
directive|define
name|__ARM_EABI_UNWINDER__
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
typedef|typedef
name|unsigned
name|_Unwind_Word
name|__attribute__
typedef|((
name|__mode__
typedef|(
name|__word__
typedef|)));
typedef|typedef
name|signed
name|_Unwind_Sword
name|__attribute__
typedef|((
name|__mode__
typedef|(
name|__word__
typedef|)));
typedef|typedef
name|unsigned
name|_Unwind_Ptr
name|__attribute__
typedef|((
name|__mode__
typedef|(
name|__pointer__
typedef|)));
typedef|typedef
name|unsigned
name|_Unwind_Internal_Ptr
name|__attribute__
typedef|((
name|__mode__
typedef|(
name|__pointer__
typedef|)));
typedef|typedef
name|_Unwind_Word
name|_uw
typedef|;
typedef|typedef
name|unsigned
name|_uw64
name|__attribute__
typedef|((
name|mode
typedef|(
name|__DI__
typedef|)));
typedef|typedef
name|unsigned
name|_uw16
name|__attribute__
typedef|((
name|mode
typedef|(
name|__HI__
typedef|)));
typedef|typedef
name|unsigned
name|_uw8
name|__attribute__
typedef|((
name|mode
typedef|(
name|__QI__
typedef|)));
typedef|typedef
enum|enum
block|{
name|_URC_OK
init|=
literal|0
block|,
comment|/* operation completed successfully */
name|_URC_FOREIGN_EXCEPTION_CAUGHT
init|=
literal|1
block|,
name|_URC_END_OF_STACK
init|=
literal|5
block|,
name|_URC_HANDLER_FOUND
init|=
literal|6
block|,
name|_URC_INSTALL_CONTEXT
init|=
literal|7
block|,
name|_URC_CONTINUE_UNWIND
init|=
literal|8
block|,
name|_URC_FAILURE
init|=
literal|9
comment|/* unspecified failure of some kind */
block|}
name|_Unwind_Reason_Code
typedef|;
typedef|typedef
enum|enum
block|{
name|_US_VIRTUAL_UNWIND_FRAME
init|=
literal|0
block|,
name|_US_UNWIND_FRAME_STARTING
init|=
literal|1
block|,
name|_US_UNWIND_FRAME_RESUME
init|=
literal|2
block|,
name|_US_ACTION_MASK
init|=
literal|3
block|,
name|_US_FORCE_UNWIND
init|=
literal|8
block|,
name|_US_END_OF_STACK
init|=
literal|16
block|}
name|_Unwind_State
typedef|;
comment|/* Provided only for for compatibility with existing code.  */
typedef|typedef
name|int
name|_Unwind_Action
typedef|;
define|#
directive|define
name|_UA_SEARCH_PHASE
value|1
define|#
directive|define
name|_UA_CLEANUP_PHASE
value|2
define|#
directive|define
name|_UA_HANDLER_FRAME
value|4
define|#
directive|define
name|_UA_FORCE_UNWIND
value|8
define|#
directive|define
name|_UA_END_OF_STACK
value|16
define|#
directive|define
name|_URC_NO_REASON
value|_URC_OK
typedef|typedef
name|struct
name|_Unwind_Control_Block
name|_Unwind_Control_Block
typedef|;
typedef|typedef
name|struct
name|_Unwind_Context
name|_Unwind_Context
typedef|;
typedef|typedef
name|_uw
name|_Unwind_EHT_Header
typedef|;
comment|/* UCB: */
struct|struct
name|_Unwind_Control_Block
block|{
name|unsigned
name|exception_class
name|__attribute__
argument_list|(
operator|(
name|__mode__
argument_list|(
name|__DI__
argument_list|)
operator|)
argument_list|)
decl_stmt|;
name|void
function_decl|(
modifier|*
name|exception_cleanup
function_decl|)
parameter_list|(
name|_Unwind_Reason_Code
parameter_list|,
name|_Unwind_Control_Block
modifier|*
parameter_list|)
function_decl|;
comment|/* Unwinder cache, private fields for the unwinder's use */
struct|struct
block|{
name|_uw
name|reserved1
decl_stmt|;
comment|/* Forced unwind stop fn, 0 if not forced */
name|_uw
name|reserved2
decl_stmt|;
comment|/* Personality routine address */
name|_uw
name|reserved3
decl_stmt|;
comment|/* Saved callsite address */
name|_uw
name|reserved4
decl_stmt|;
comment|/* Forced unwind stop arg */
name|_uw
name|reserved5
decl_stmt|;
block|}
name|unwinder_cache
struct|;
comment|/* Propagation barrier cache (valid after phase 1): */
struct|struct
block|{
name|_uw
name|sp
decl_stmt|;
name|_uw
name|bitpattern
index|[
literal|5
index|]
decl_stmt|;
block|}
name|barrier_cache
struct|;
comment|/* Cleanup cache (preserved over cleanup): */
struct|struct
block|{
name|_uw
name|bitpattern
index|[
literal|4
index|]
decl_stmt|;
block|}
name|cleanup_cache
struct|;
comment|/* Pr cache (for pr's benefit): */
struct|struct
block|{
name|_uw
name|fnstart
decl_stmt|;
comment|/* function start address */
name|_Unwind_EHT_Header
modifier|*
name|ehtp
decl_stmt|;
comment|/* pointer to EHT entry header word */
name|_uw
name|additional
decl_stmt|;
comment|/* additional data */
name|_uw
name|reserved1
decl_stmt|;
block|}
name|pr_cache
struct|;
name|long
name|long
name|int
range|:
literal|0
decl_stmt|;
comment|/* Force alignment to 8-byte boundary */
block|}
struct|;
comment|/* Virtual Register Set*/
typedef|typedef
enum|enum
block|{
name|_UVRSC_CORE
init|=
literal|0
block|,
comment|/* integer register */
name|_UVRSC_VFP
init|=
literal|1
block|,
comment|/* vfp */
name|_UVRSC_FPA
init|=
literal|2
block|,
comment|/* fpa */
name|_UVRSC_WMMXD
init|=
literal|3
block|,
comment|/* Intel WMMX data register */
name|_UVRSC_WMMXC
init|=
literal|4
comment|/* Intel WMMX control register */
block|}
name|_Unwind_VRS_RegClass
typedef|;
typedef|typedef
enum|enum
block|{
name|_UVRSD_UINT32
init|=
literal|0
block|,
name|_UVRSD_VFPX
init|=
literal|1
block|,
name|_UVRSD_FPAX
init|=
literal|2
block|,
name|_UVRSD_UINT64
init|=
literal|3
block|,
name|_UVRSD_FLOAT
init|=
literal|4
block|,
name|_UVRSD_DOUBLE
init|=
literal|5
block|}
name|_Unwind_VRS_DataRepresentation
typedef|;
typedef|typedef
enum|enum
block|{
name|_UVRSR_OK
init|=
literal|0
block|,
name|_UVRSR_NOT_IMPLEMENTED
init|=
literal|1
block|,
name|_UVRSR_FAILED
init|=
literal|2
block|}
name|_Unwind_VRS_Result
typedef|;
comment|/* Frame unwinding state.  */
typedef|typedef
struct|struct
block|{
comment|/* The current word (bytes packed msb first).  */
name|_uw
name|data
decl_stmt|;
comment|/* Pointer to the next word of data.  */
name|_uw
modifier|*
name|next
decl_stmt|;
comment|/* The number of bytes left in this word.  */
name|_uw8
name|bytes_left
decl_stmt|;
comment|/* The number of words pointed to by ptr.  */
name|_uw8
name|words_left
decl_stmt|;
block|}
name|__gnu_unwind_state
typedef|;
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|personality_routine
function_decl|)
parameter_list|(
name|_Unwind_State
parameter_list|,
name|_Unwind_Control_Block
modifier|*
parameter_list|,
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_VRS_Result
name|_Unwind_VRS_Set
parameter_list|(
name|_Unwind_Context
modifier|*
parameter_list|,
name|_Unwind_VRS_RegClass
parameter_list|,
name|_uw
parameter_list|,
name|_Unwind_VRS_DataRepresentation
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_VRS_Result
name|_Unwind_VRS_Get
parameter_list|(
name|_Unwind_Context
modifier|*
parameter_list|,
name|_Unwind_VRS_RegClass
parameter_list|,
name|_uw
parameter_list|,
name|_Unwind_VRS_DataRepresentation
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_VRS_Result
name|_Unwind_VRS_Pop
parameter_list|(
name|_Unwind_Context
modifier|*
parameter_list|,
name|_Unwind_VRS_RegClass
parameter_list|,
name|_uw
parameter_list|,
name|_Unwind_VRS_DataRepresentation
parameter_list|)
function_decl|;
comment|/* Support functions for the PR.  */
define|#
directive|define
name|_Unwind_Exception
value|_Unwind_Control_Block
typedef|typedef
name|unsigned
name|_Unwind_Exception_Class
name|__attribute__
typedef|((
name|__mode__
typedef|(
name|__DI__
typedef|)));
name|void
modifier|*
name|_Unwind_GetLanguageSpecificData
parameter_list|(
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Ptr
name|_Unwind_GetRegionStart
parameter_list|(
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
comment|/* These two should never be used.  */
name|_Unwind_Ptr
name|_Unwind_GetDataRelBase
parameter_list|(
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Ptr
name|_Unwind_GetTextRelBase
parameter_list|(
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
comment|/* Interface functions: */
name|_Unwind_Reason_Code
name|_Unwind_RaiseException
parameter_list|(
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|)
function_decl|;
name|void
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
name|_Unwind_Resume
argument_list|(
name|_Unwind_Control_Block
operator|*
name|ucbp
argument_list|)
decl_stmt|;
name|_Unwind_Reason_Code
name|_Unwind_Resume_or_Rethrow
parameter_list|(
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|)
function_decl|;
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|_Unwind_Stop_Fn
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|_Unwind_Action
parameter_list|,
name|_Unwind_Exception_Class
parameter_list|,
name|_Unwind_Control_Block
modifier|*
parameter_list|,
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Reason_Code
name|_Unwind_ForcedUnwind
parameter_list|(
name|_Unwind_Control_Block
modifier|*
parameter_list|,
name|_Unwind_Stop_Fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* @@@ Use unwind data to perform a stack backtrace.  The trace callback      is called for every stack frame in the call chain, but no cleanup      actions are performed.  */
typedef|typedef
name|_Unwind_Reason_Code
function_decl|(
modifier|*
name|_Unwind_Trace_Fn
function_decl|)
parameter_list|(
name|_Unwind_Context
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Reason_Code
name|_Unwind_Backtrace
parameter_list|(
name|_Unwind_Trace_Fn
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Word
name|_Unwind_GetCFA
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
name|void
name|_Unwind_Complete
parameter_list|(
name|_Unwind_Control_Block
modifier|*
name|ucbp
parameter_list|)
function_decl|;
name|void
name|_Unwind_DeleteException
parameter_list|(
name|_Unwind_Exception
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Reason_Code
name|__gnu_unwind_frame
parameter_list|(
name|_Unwind_Control_Block
modifier|*
parameter_list|,
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Reason_Code
name|__gnu_unwind_execute
parameter_list|(
name|_Unwind_Context
modifier|*
parameter_list|,
name|__gnu_unwind_state
modifier|*
parameter_list|)
function_decl|;
comment|/* Decode an R_ARM_TARGET2 relocation.  */
specifier|static
specifier|inline
name|_Unwind_Word
name|_Unwind_decode_target2
parameter_list|(
name|_Unwind_Word
name|ptr
parameter_list|)
block|{
name|_Unwind_Word
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|*
operator|(
name|_Unwind_Word
operator|*
operator|)
name|ptr
expr_stmt|;
comment|/* Zero values are always NULL.  */
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* Pc-relative indirect.  */
name|tmp
operator|+=
name|ptr
expr_stmt|;
name|tmp
operator|=
operator|*
operator|(
name|_Unwind_Word
operator|*
operator|)
name|tmp
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__symbian__
argument_list|)
comment|/* Absolute pointer.  Nothing more to do.  */
else|#
directive|else
comment|/* Pc-relative pointer.  */
name|tmp
operator|+=
name|ptr
expr_stmt|;
endif|#
directive|endif
return|return
name|tmp
return|;
block|}
specifier|static
specifier|inline
name|_Unwind_Word
name|_Unwind_GetGR
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|_uw
name|val
decl_stmt|;
name|_Unwind_VRS_Get
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|regno
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
ifndef|#
directive|ifndef
name|__FreeBSD__
comment|/* Return the address of the instruction, not the actual IP value.  */
define|#
directive|define
name|_Unwind_GetIP
parameter_list|(
name|context
parameter_list|)
define|\
value|(_Unwind_GetGR (context, 15)& ~(_Unwind_Word)1)
define|#
directive|define
name|_Unwind_GetIPInfo
parameter_list|(
name|context
parameter_list|,
name|ip_before_insn
parameter_list|)
define|\
value|(*ip_before_insn = 0, _Unwind_GetGR (context, 15)& ~(_Unwind_Word)1)
else|#
directive|else
name|_Unwind_Ptr
name|_Unwind_GetIP
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|)
function_decl|;
name|_Unwind_Ptr
name|_Unwind_GetIPInfo
parameter_list|(
name|struct
name|_Unwind_Context
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
specifier|static
specifier|inline
name|void
name|_Unwind_SetGR
parameter_list|(
name|_Unwind_Context
modifier|*
name|context
parameter_list|,
name|int
name|regno
parameter_list|,
name|_Unwind_Word
name|val
parameter_list|)
block|{
name|_Unwind_VRS_Set
argument_list|(
name|context
argument_list|,
name|_UVRSC_CORE
argument_list|,
name|regno
argument_list|,
name|_UVRSD_UINT32
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* The dwarf unwinder doesn't understand arm/thumb state.  We assume the      landing pad uses the same instruction set as the call site.  */
define|#
directive|define
name|_Unwind_SetIP
parameter_list|(
name|context
parameter_list|,
name|val
parameter_list|)
define|\
value|_Unwind_SetGR (context, 15, val | (_Unwind_GetGR (context, 15)& 1))
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_comment
comment|/* extern "C" */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined UNWIND_ARM_H */
end_comment

end_unit

