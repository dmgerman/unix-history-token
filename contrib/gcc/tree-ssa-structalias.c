begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tree based points-to analysis    Copyright (C) 2005, 2006 Free Software Foundation, Inc.    Contributed by Daniel Berlin<dberlin@dberlin.org>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-structalias.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_comment
comment|/* The idea behind this analyzer is to generate set constraints from the    program, then solve the resulting constraints in order to generate the    points-to sets.      Set constraints are a way of modeling program analysis problems that    involve sets.  They consist of an inclusion constraint language,    describing the variables (each variable is a set) and operations that    are involved on the variables, and a set of rules that derive facts    from these operations.  To solve a system of set constraints, you derive    all possible facts under the rules, which gives you the correct sets    as a consequence.     See  "Efficient Field-sensitive pointer analysis for C" by "David    J. Pearce and Paul H. J. Kelly and Chris Hankin, at    http://citeseer.ist.psu.edu/pearce04efficient.html     Also see "Ultra-fast Aliasing Analysis using CLA: A Million Lines    of C Code in a Second" by ""Nevin Heintze and Olivier Tardieu" at    http://citeseer.ist.psu.edu/heintze01ultrafast.html      There are three types of constraint expressions, DEREF, ADDRESSOF, and    SCALAR.  Each constraint expression consists of a constraint type,    a variable, and an offset.          SCALAR is a constraint expression type used to represent x, whether    it appears on the LHS or the RHS of a statement.    DEREF is a constraint expression type used to represent *x, whether    it appears on the LHS or the RHS of a statement.     ADDRESSOF is a constraint expression used to represent&x, whether    it appears on the LHS or the RHS of a statement.        Each pointer variable in the program is assigned an integer id, and    each field of a structure variable is assigned an integer id as well.        Structure variables are linked to their list of fields through a "next    field" in each variable that points to the next field in offset    order.      Each variable for a structure field has      1. "size", that tells the size in bits of that field.    2. "fullsize, that tells the size in bits of the entire structure.    3. "offset", that tells the offset in bits from the beginning of the    structure to this field.     Thus,     struct f    {      int a;      int b;    } foo;    int *bar;     looks like     foo.a -> id 1, size 32, offset 0, fullsize 64, next foo.b    foo.b -> id 2, size 32, offset 32, fullsize 64, next NULL    bar -> id 3, size 32, offset 0, fullsize 32, next NULL        In order to solve the system of set constraints, the following is   done:    1. Each constraint variable x has a solution set associated with it,   Sol(x).      2. Constraints are separated into direct, copy, and complex.   Direct constraints are ADDRESSOF constraints that require no extra   processing, such as P =&Q   Copy constraints are those of the form P = Q.   Complex constraints are all the constraints involving dereferences.      3. All direct constraints of the form P =&Q are processed, such   that Q is added to Sol(P)     4. All complex constraints for a given constraint variable are stored in a   linked list attached to that variable's node.      5. A directed graph is built out of the copy constraints. Each   constraint variable is a node in the graph, and an edge from    Q to P is added for each copy constraint of the form P = Q      6. The graph is then walked, and solution sets are   propagated along the copy edges, such that an edge from Q to P   causes Sol(P)<- Sol(P) union Sol(Q).      7.  As we visit each node, all complex constraints associated with   that node are processed by adding appropriate copy edges to the graph, or the   appropriate variables to the solution set.      8. The process of walking the graph is iterated until no solution   sets change.    Prior to walking the graph in steps 6 and 7, We perform static   cycle elimination on the constraint graph, as well    as off-line variable substitution.      TODO: Adding offsets to pointer-to-structures can be handled (IE not punted   on and turned into anything), but isn't.  You can just see what offset   inside the pointed-to struct it's going to access.      TODO: Constant bounded arrays can be handled as if they were structs of the   same number of elements.     TODO: Modeling heap and incoming pointers becomes much better if we   add fields to them as we discover them, which we could do.    TODO: We could handle unions, but to be honest, it's probably not   worth the pain or slowdown.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"tree_map_marked_p"
argument|), param_is (struct tree_map))
argument_list|)
name|htab_t
name|heapvar_for_stmt
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* One variable to represent all non-local accesses.  */
end_comment

begin_decl_stmt
name|tree
name|nonlocal_all
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|use_field_sensitive
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_ipa_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|predbitmap_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|ptabitmap_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|iteration_obstack
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|int
name|create_variable_info_for
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_constraint_graph
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|constraint_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|EXECUTE_IF_IN_NONNULL_BITMAP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
define|\
value|if (a)						\     EXECUTE_IF_SET_IN_BITMAP (a, b, c, d)
end_define

begin_struct
specifier|static
struct|struct
name|constraint_stats
block|{
name|unsigned
name|int
name|total_vars
decl_stmt|;
name|unsigned
name|int
name|collapsed_vars
decl_stmt|;
name|unsigned
name|int
name|unified_vars_static
decl_stmt|;
name|unsigned
name|int
name|unified_vars_dynamic
decl_stmt|;
name|unsigned
name|int
name|iterations
decl_stmt|;
name|unsigned
name|int
name|num_edges
decl_stmt|;
block|}
name|stats
struct|;
end_struct

begin_struct
struct|struct
name|variable_info
block|{
comment|/* ID of this variable  */
name|unsigned
name|int
name|id
decl_stmt|;
comment|/* Name of this variable */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Tree that this variable is associated with.  */
name|tree
name|decl
decl_stmt|;
comment|/* Offset of this variable, in bits, from the base variable  */
name|unsigned
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* Size of the variable, in bits.  */
name|unsigned
name|HOST_WIDE_INT
name|size
decl_stmt|;
comment|/* Full size of the base variable, in bits.  */
name|unsigned
name|HOST_WIDE_INT
name|fullsize
decl_stmt|;
comment|/* A link to the variable for the next field in this structure.  */
name|struct
name|variable_info
modifier|*
name|next
decl_stmt|;
comment|/* Node in the graph that represents the constraints and points-to      solution for the variable.  */
name|unsigned
name|int
name|node
decl_stmt|;
comment|/* True if the address of this variable is taken.  Needed for      variable substitution.  */
name|unsigned
name|int
name|address_taken
range|:
literal|1
decl_stmt|;
comment|/* True if this variable is the target of a dereference.  Needed for      variable substitution.  */
name|unsigned
name|int
name|indirect_target
range|:
literal|1
decl_stmt|;
comment|/* True if the variable is directly the target of a dereference.      This is used to track which variables are *actually* dereferenced      so we can prune their points to listed. This is equivalent to the      indirect_target flag when no merging of variables happens.  */
name|unsigned
name|int
name|directly_dereferenced
range|:
literal|1
decl_stmt|;
comment|/* True if this is a variable created by the constraint analysis, such as      heap variables and constraints we had to break up.  */
name|unsigned
name|int
name|is_artificial_var
range|:
literal|1
decl_stmt|;
comment|/* True if this is a special variable whose solution set should not be      changed.  */
name|unsigned
name|int
name|is_special_var
range|:
literal|1
decl_stmt|;
comment|/* True for variables whose size is not known or variable.  */
name|unsigned
name|int
name|is_unknown_size_var
range|:
literal|1
decl_stmt|;
comment|/* True for variables that have unions somewhere in them.  */
name|unsigned
name|int
name|has_union
range|:
literal|1
decl_stmt|;
comment|/* True if this is a heap variable.  */
name|unsigned
name|int
name|is_heap_var
range|:
literal|1
decl_stmt|;
comment|/* Points-to set for this variable.  */
name|bitmap
name|solution
decl_stmt|;
comment|/* Variable ids represented by this node.  */
name|bitmap
name|variables
decl_stmt|;
comment|/* Vector of complex constraints for this node.  Complex      constraints are those involving dereferences.  */
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
name|complex
expr_stmt|;
comment|/* Variable id this was collapsed to due to type unsafety.      This should be unused completely after build_constraint_graph, or      something is broken.  */
name|struct
name|variable_info
modifier|*
name|collapsed_to
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|variable_info
modifier|*
name|varinfo_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|varinfo_t
name|first_vi_for_offset
parameter_list|(
name|varinfo_t
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pool of variable info structures.  */
end_comment

begin_decl_stmt
specifier|static
name|alloc_pool
name|variable_info_pool
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|varinfo_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Table of variable info structures for constraint variables.  Indexed directly    by variable info id.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|)
operator|*
name|varmap
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return the varmap element N */
end_comment

begin_function
specifier|static
specifier|inline
name|varinfo_t
name|get_varinfo
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
return|return
name|VEC_index
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the varmap element N, following the collapsed_to link.  */
end_comment

begin_function
specifier|static
specifier|inline
name|varinfo_t
name|get_varinfo_fc
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|varinfo_t
name|v
init|=
name|VEC_index
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|collapsed_to
condition|)
return|return
name|v
operator|->
name|collapsed_to
return|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Variable that represents the unknown pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|varinfo_t
name|var_anything
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|anything_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|anything_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable that represents the NULL pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|varinfo_t
name|var_nothing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|nothing_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|nothing_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable that represents read only memory.  */
end_comment

begin_decl_stmt
specifier|static
name|varinfo_t
name|var_readonly
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|readonly_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|readonly_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable that represents integers.  This is used for when people do things    like&0->a.b.  */
end_comment

begin_decl_stmt
specifier|static
name|varinfo_t
name|var_integer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|integer_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|integer_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable that represents escaped variables.  This is used to give    incoming pointer variables a better set than ANYTHING.  */
end_comment

begin_decl_stmt
specifier|static
name|varinfo_t
name|var_escaped_vars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|escaped_vars_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|escaped_vars_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable that represents non-local variables before we expand it to    one for each type.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|nonlocal_vars_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lookup a heap var for FROM, and return it if we find one.  */
end_comment

begin_function
specifier|static
name|tree
name|heapvar_lookup
parameter_list|(
name|tree
name|from
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|in
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|=
name|htab_find_with_hash
argument_list|(
name|heapvar_for_stmt
argument_list|,
operator|&
name|in
argument_list|,
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
name|h
operator|->
name|to
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Insert a mapping FROM->TO in the heap var for statement    hashtable.  */
end_comment

begin_function
specifier|static
name|void
name|heapvar_insert
parameter_list|(
name|tree
name|from
parameter_list|,
name|tree
name|to
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|h
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_map
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hash
operator|=
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|h
operator|->
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|to
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|heapvar_for_stmt
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|tree_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a new variable info structure consisting for a variable    named NAME, and using constraint graph node NODE.  */
end_comment

begin_function
specifier|static
name|varinfo_t
name|new_var_info
parameter_list|(
name|tree
name|t
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|node
parameter_list|)
block|{
name|varinfo_t
name|ret
init|=
name|pool_alloc
argument_list|(
name|variable_info_pool
argument_list|)
decl_stmt|;
name|ret
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|ret
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|ret
operator|->
name|decl
operator|=
name|t
expr_stmt|;
name|ret
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|ret
operator|->
name|address_taken
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|indirect_target
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|directly_dereferenced
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|is_artificial_var
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|is_heap_var
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|is_special_var
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|is_unknown_size_var
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|has_union
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|solution
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ptabitmap_obstack
argument_list|)
expr_stmt|;
name|ret
operator|->
name|variables
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ptabitmap_obstack
argument_list|)
expr_stmt|;
name|ret
operator|->
name|complex
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|collapsed_to
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|SCALAR
block|,
name|DEREF
block|,
name|ADDRESSOF
block|}
name|constraint_expr_type
typedef|;
end_typedef

begin_comment
comment|/* An expression that appears in a constraint.  */
end_comment

begin_struct
struct|struct
name|constraint_expr
block|{
comment|/* Constraint type.  */
name|constraint_expr_type
name|type
decl_stmt|;
comment|/* Variable we are referring to in the constraint.  */
name|unsigned
name|int
name|var
decl_stmt|;
comment|/* Offset, in bits, of this constraint from the beginning of      variables it ends up referring to.       IOW, in a deref constraint, we would deref, get the result set,      then add OFFSET to each member.   */
name|unsigned
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|constraint_expr
name|ce_s
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_O
argument_list|(
name|ce_s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_O
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|get_constraint_for
argument_list|(
name|tree
argument_list|,
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_deref
argument_list|(
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our set constraints are made up of two constraint expressions, one    LHS, and one RHS.       As described in the introduction, our set constraints each represent an    operation between set valued variables. */
end_comment

begin_struct
struct|struct
name|constraint
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|rhs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of constraints that we use to build the constraint graph from.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
name|constraints
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|constraint_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An edge in the weighted constraint graph.   The edges are weighted,    with a bit set in weights meaning their is an edge with that    weight.     We don't keep the src in the edge, because we always know what it    is. */
end_comment

begin_struct
struct|struct
name|constraint_edge
block|{
name|unsigned
name|int
name|dest
decl_stmt|;
name|bitmap
name|weights
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|constraint_edge
modifier|*
name|constraint_edge_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|alloc_pool
name|constraint_edge_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a new constraint edge from SRC to DEST.  */
end_comment

begin_function
specifier|static
name|constraint_edge_t
name|new_constraint_edge
parameter_list|(
name|unsigned
name|int
name|dest
parameter_list|)
block|{
name|constraint_edge_t
name|ret
init|=
name|pool_alloc
argument_list|(
name|constraint_edge_pool
argument_list|)
decl_stmt|;
name|ret
operator|->
name|dest
operator|=
name|dest
expr_stmt|;
name|ret
operator|->
name|weights
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|constraint_edge_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The constraint graph is represented internally in two different    ways.  The overwhelming majority of edges in the constraint graph    are zero weigh edges, and thus, using a vector of contrainst_edge_t    is a waste of time and memory, since they have no weights.  We    simply use a bitmap to store the preds and succs for each node.    The weighted edges are stored as a set of adjacency vectors, one    per variable. succs[x] is the vector of successors for variable x,    and preds[x] is the vector of predecessors for variable x.  IOW,    all edges are "forward" edges, which is not like our CFG.  So    remember that preds[x]->src == x, and succs[x]->src == x.  */
end_comment

begin_struct
struct|struct
name|constraint_graph
block|{
name|bitmap
modifier|*
name|zero_weight_succs
decl_stmt|;
name|bitmap
modifier|*
name|zero_weight_preds
decl_stmt|;
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|succs
expr_stmt|;
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|preds
expr_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|constraint_graph
modifier|*
name|constraint_graph_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|constraint_graph_t
name|graph
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|graph_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new constraint consisting of LHS and RHS expressions.  */
end_comment

begin_function
specifier|static
name|constraint_t
name|new_constraint
parameter_list|(
specifier|const
name|struct
name|constraint_expr
name|lhs
parameter_list|,
specifier|const
name|struct
name|constraint_expr
name|rhs
parameter_list|)
block|{
name|constraint_t
name|ret
init|=
name|pool_alloc
argument_list|(
name|constraint_pool
argument_list|)
decl_stmt|;
name|ret
operator|->
name|lhs
operator|=
name|lhs
expr_stmt|;
name|ret
operator|->
name|rhs
operator|=
name|rhs
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Print out constraint C to FILE.  */
end_comment

begin_function
name|void
name|dump_constraint
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|constraint_t
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|lhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|lhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|get_varinfo_fc
argument_list|(
name|c
operator|->
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|lhs
operator|.
name|offset
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" + "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|c
operator|->
name|lhs
operator|.
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|get_varinfo_fc
argument_list|(
name|c
operator|->
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rhs
operator|.
name|offset
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" + "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|c
operator|->
name|rhs
operator|.
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out constraint C to stderr.  */
end_comment

begin_function
name|void
name|debug_constraint
parameter_list|(
name|constraint_t
name|c
parameter_list|)
block|{
name|dump_constraint
argument_list|(
name|stderr
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out all constraints to FILE */
end_comment

begin_function
name|void
name|dump_constraints
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
name|constraints
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
name|dump_constraint
argument_list|(
name|file
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out all constraints to stderr.  */
end_comment

begin_function
name|void
name|debug_constraints
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_constraints
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SOLVER FUNCTIONS      The solver is a simple worklist solver, that works on the following    algorithm:        sbitmap changed_nodes = all ones;    changed_count = number of nodes;    For each node that was already collapsed:        changed_count--;     while (changed_count> 0)    {      compute topological ordering for constraint graph         find and collapse cycles in the constraint graph (updating      changed if necessary)            for each node (n) in the graph in topological order:        changed_count--;         Process each complex constraint associated with the node,        updating changed if necessary.         For each outgoing edge from n, propagate the solution from n to        the destination of the edge, updating changed as necessary.     }  */
end_comment

begin_comment
comment|/* Return true if two constraint expressions A and B are equal.  */
end_comment

begin_function
specifier|static
name|bool
name|constraint_expr_equal
parameter_list|(
name|struct
name|constraint_expr
name|a
parameter_list|,
name|struct
name|constraint_expr
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|type
operator|==
name|b
operator|.
name|type
operator|&&
name|a
operator|.
name|var
operator|==
name|b
operator|.
name|var
operator|&&
name|a
operator|.
name|offset
operator|==
name|b
operator|.
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return true if constraint expression A is less than constraint expression    B.  This is just arbitrary, but consistent, in order to give them an    ordering.  */
end_comment

begin_function
specifier|static
name|bool
name|constraint_expr_less
parameter_list|(
name|struct
name|constraint_expr
name|a
parameter_list|,
name|struct
name|constraint_expr
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|type
operator|==
name|b
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|a
operator|.
name|var
operator|==
name|b
operator|.
name|var
condition|)
return|return
name|a
operator|.
name|offset
operator|<
name|b
operator|.
name|offset
return|;
else|else
return|return
name|a
operator|.
name|var
operator|<
name|b
operator|.
name|var
return|;
block|}
else|else
return|return
name|a
operator|.
name|type
operator|<
name|b
operator|.
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return true if constraint A is less than constraint B.  This is just    arbitrary, but consistent, in order to give them an ordering.  */
end_comment

begin_function
specifier|static
name|bool
name|constraint_less
parameter_list|(
specifier|const
name|constraint_t
name|a
parameter_list|,
specifier|const
name|constraint_t
name|b
parameter_list|)
block|{
if|if
condition|(
name|constraint_expr_less
argument_list|(
name|a
operator|->
name|lhs
argument_list|,
name|b
operator|->
name|lhs
argument_list|)
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|constraint_expr_less
argument_list|(
name|b
operator|->
name|lhs
argument_list|,
name|a
operator|->
name|lhs
argument_list|)
condition|)
return|return
name|false
return|;
else|else
return|return
name|constraint_expr_less
argument_list|(
name|a
operator|->
name|rhs
argument_list|,
name|b
operator|->
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if two constraints A and B are equal.  */
end_comment

begin_function
specifier|static
name|bool
name|constraint_equal
parameter_list|(
name|struct
name|constraint
name|a
parameter_list|,
name|struct
name|constraint
name|b
parameter_list|)
block|{
return|return
name|constraint_expr_equal
argument_list|(
name|a
operator|.
name|lhs
argument_list|,
name|b
operator|.
name|lhs
argument_list|)
operator|&&
name|constraint_expr_equal
argument_list|(
name|a
operator|.
name|rhs
argument_list|,
name|b
operator|.
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find a constraint LOOKFOR in the sorted constraint vector VEC */
end_comment

begin_decl_stmt
specifier|static
name|constraint_t
name|constraint_vec_find
argument_list|(
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
name|vec
argument_list|,
expr|struct
name|constraint
name|lookfor
argument_list|)
block|{
name|unsigned
name|int
name|place
decl_stmt|;
name|constraint_t
name|found
decl_stmt|;
if|if
condition|(
name|vec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|place
operator|=
name|VEC_lower_bound
argument_list|(
name|constraint_t
argument_list|,
name|vec
argument_list|,
operator|&
name|lookfor
argument_list|,
name|constraint_less
argument_list|)
expr_stmt|;
if|if
condition|(
name|place
operator|>=
name|VEC_length
argument_list|(
name|constraint_t
argument_list|,
name|vec
argument_list|)
condition|)
return|return
name|NULL
return|;
name|found
operator|=
name|VEC_index
argument_list|(
name|constraint_t
argument_list|,
name|vec
argument_list|,
name|place
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constraint_equal
argument_list|(
operator|*
name|found
argument_list|,
name|lookfor
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|found
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Union two constraint vectors, TO and FROM.  Put the result in TO.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|constraint_set_union
argument_list|(
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|to
argument_list|,
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|from
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
operator|*
name|from
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|constraint_vec_find
argument_list|(
operator|*
name|to
argument_list|,
operator|*
name|c
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|int
name|place
init|=
name|VEC_lower_bound
argument_list|(
name|constraint_t
argument_list|,
operator|*
name|to
argument_list|,
name|c
argument_list|,
name|constraint_less
argument_list|)
decl_stmt|;
name|VEC_safe_insert
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
operator|*
name|to
argument_list|,
name|place
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Take a solution set SET, add OFFSET to each member of the set, and    overwrite SET with the result when done.  */
end_comment

begin_function
specifier|static
name|void
name|solution_set_add
parameter_list|(
name|bitmap
name|set
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|bitmap
name|result
init|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|set
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
comment|/* If this is a properly sized variable, only add offset if it's 	 less than end.  Otherwise, it is globbed to a single 	 variable.  */
if|if
condition|(
operator|(
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|offset
operator|+
name|offset
operator|)
operator|<
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|fullsize
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
init|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|offset
operator|+
name|offset
decl_stmt|;
name|varinfo_t
name|v
init|=
name|first_vi_for_offset
argument_list|(
name|get_varinfo
argument_list|(
name|i
argument_list|)
argument_list|,
name|fieldoffset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
name|bitmap_set_bit
argument_list|(
name|result
argument_list|,
name|v
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|is_artificial_var
operator|||
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|has_union
operator|||
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|is_unknown_size_var
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|result
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|bitmap_copy
argument_list|(
name|set
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Union solution sets TO and FROM, and add INC to each member of FROM in the    process.  */
end_comment

begin_function
specifier|static
name|bool
name|set_union_with_increment
parameter_list|(
name|bitmap
name|to
parameter_list|,
name|bitmap
name|from
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|inc
parameter_list|)
block|{
if|if
condition|(
name|inc
operator|==
literal|0
condition|)
return|return
name|bitmap_ior_into
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
return|;
else|else
block|{
name|bitmap
name|tmp
decl_stmt|;
name|bool
name|res
decl_stmt|;
name|tmp
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|tmp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|solution_set_add
argument_list|(
name|tmp
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|res
operator|=
name|bitmap_ior_into
argument_list|(
name|to
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
end_function

begin_comment
comment|/* Insert constraint C into the list of complex constraints for VAR.  */
end_comment

begin_function
specifier|static
name|void
name|insert_into_complex
parameter_list|(
name|unsigned
name|int
name|var
parameter_list|,
name|constraint_t
name|c
parameter_list|)
block|{
name|varinfo_t
name|vi
init|=
name|get_varinfo
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|place
init|=
name|VEC_lower_bound
argument_list|(
name|constraint_t
argument_list|,
name|vi
operator|->
name|complex
argument_list|,
name|c
argument_list|,
name|constraint_less
argument_list|)
decl_stmt|;
name|VEC_safe_insert
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|vi
operator|->
name|complex
argument_list|,
name|place
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare two constraint edges A and B, return true if they are equal.  */
end_comment

begin_function
specifier|static
name|bool
name|constraint_edge_equal
parameter_list|(
name|struct
name|constraint_edge
name|a
parameter_list|,
name|struct
name|constraint_edge
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|dest
operator|==
name|b
operator|.
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Compare two constraint edges, return true if A is less than B */
end_comment

begin_function
specifier|static
name|bool
name|constraint_edge_less
parameter_list|(
specifier|const
name|constraint_edge_t
name|a
parameter_list|,
specifier|const
name|constraint_edge_t
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|dest
operator|<
name|b
operator|->
name|dest
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Find the constraint edge that matches LOOKFOR, in VEC.    Return the edge, if found, NULL otherwise.  */
end_comment

begin_decl_stmt
specifier|static
name|constraint_edge_t
name|constraint_edge_vec_find
argument_list|(
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|vec
argument_list|,
expr|struct
name|constraint_edge
name|lookfor
argument_list|)
block|{
name|unsigned
name|int
name|place
decl_stmt|;
name|constraint_edge_t
name|edge
init|=
name|NULL
decl_stmt|;
name|place
operator|=
name|VEC_lower_bound
argument_list|(
name|constraint_edge_t
argument_list|,
name|vec
argument_list|,
operator|&
name|lookfor
argument_list|,
name|constraint_edge_less
argument_list|)
expr_stmt|;
if|if
condition|(
name|place
operator|>=
name|VEC_length
argument_list|(
name|constraint_edge_t
argument_list|,
name|vec
argument_list|)
condition|)
return|return
name|NULL
return|;
name|edge
operator|=
name|VEC_index
argument_list|(
name|constraint_edge_t
argument_list|,
name|vec
argument_list|,
name|place
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constraint_edge_equal
argument_list|(
operator|*
name|edge
argument_list|,
name|lookfor
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|edge
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Condense two variable nodes into a single variable node, by moving    all associated info from SRC to TO.  */
end_comment

begin_function
specifier|static
name|void
name|condense_varmap_nodes
parameter_list|(
name|unsigned
name|int
name|to
parameter_list|,
name|unsigned
name|int
name|src
parameter_list|)
block|{
name|varinfo_t
name|tovi
init|=
name|get_varinfo
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|varinfo_t
name|srcvi
init|=
name|get_varinfo
argument_list|(
name|src
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* the src node, and all its variables, are now the to node.  */
name|srcvi
operator|->
name|node
operator|=
name|to
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|srcvi->variables
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|node
operator|=
name|to
expr_stmt|;
comment|/* Merge the src node variables and the to node variables.  */
name|bitmap_set_bit
argument_list|(
name|tovi
operator|->
name|variables
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|tovi
operator|->
name|variables
argument_list|,
name|srcvi
operator|->
name|variables
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|srcvi
operator|->
name|variables
argument_list|)
expr_stmt|;
comment|/* Move all complex constraints from src node into to node  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
name|srcvi
operator|->
name|complex
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* In complex constraints for node src, we may have either 	 a = *src, and *src = a.  */
if|if
condition|(
name|c
operator|->
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|c
operator|->
name|rhs
operator|.
name|var
operator|=
name|to
expr_stmt|;
else|else
name|c
operator|->
name|lhs
operator|.
name|var
operator|=
name|to
expr_stmt|;
block|}
name|constraint_set_union
argument_list|(
operator|&
name|tovi
operator|->
name|complex
argument_list|,
operator|&
name|srcvi
operator|->
name|complex
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|srcvi
operator|->
name|complex
argument_list|)
expr_stmt|;
name|srcvi
operator|->
name|complex
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Erase an edge from SRC to SRC from GRAPH.  This routine only    handles self-edges (e.g. an edge from a to a).  */
end_comment

begin_function
specifier|static
name|void
name|erase_graph_self_edge
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|src
parameter_list|)
block|{
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|predvec
operator|=
name|graph
operator|->
name|preds
index|[
name|src
index|]
expr_stmt|;
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|succvec
operator|=
name|graph
operator|->
name|succs
index|[
name|src
index|]
expr_stmt|;
name|struct
name|constraint_edge
name|edge
decl_stmt|;
name|unsigned
name|int
name|place
decl_stmt|;
name|edge
operator|.
name|dest
operator|=
name|src
expr_stmt|;
comment|/* Remove from the successors.  */
name|place
operator|=
name|VEC_lower_bound
argument_list|(
name|constraint_edge_t
argument_list|,
name|succvec
argument_list|,
operator|&
name|edge
argument_list|,
name|constraint_edge_less
argument_list|)
expr_stmt|;
comment|/* Make sure we found the edge.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
name|constraint_edge_t
name|tmp
init|=
name|VEC_index
argument_list|(
name|constraint_edge_t
argument_list|,
name|succvec
argument_list|,
name|place
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|constraint_edge_equal
argument_list|(
operator|*
name|tmp
argument_list|,
name|edge
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|VEC_ordered_remove
argument_list|(
name|constraint_edge_t
argument_list|,
name|succvec
argument_list|,
name|place
argument_list|)
expr_stmt|;
comment|/* Remove from the predecessors.  */
name|place
operator|=
name|VEC_lower_bound
argument_list|(
name|constraint_edge_t
argument_list|,
name|predvec
argument_list|,
operator|&
name|edge
argument_list|,
name|constraint_edge_less
argument_list|)
expr_stmt|;
comment|/* Make sure we found the edge.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
name|constraint_edge_t
name|tmp
init|=
name|VEC_index
argument_list|(
name|constraint_edge_t
argument_list|,
name|predvec
argument_list|,
name|place
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|constraint_edge_equal
argument_list|(
operator|*
name|tmp
argument_list|,
name|edge
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|VEC_ordered_remove
argument_list|(
name|constraint_edge_t
argument_list|,
name|predvec
argument_list|,
name|place
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove edges involving NODE from GRAPH.  */
end_comment

begin_function
specifier|static
name|void
name|clear_edges_for_node
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|node
parameter_list|)
block|{
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|succvec
operator|=
name|graph
operator|->
name|succs
index|[
name|node
index|]
expr_stmt|;
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|predvec
operator|=
name|graph
operator|->
name|preds
index|[
name|node
index|]
expr_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|constraint_edge_t
name|c
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Walk the successors, erase the associated preds.  */
name|EXECUTE_IF_IN_NONNULL_BITMAP
argument_list|(
argument|graph->zero_weight_succs[node]
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
if|if
condition|(
name|j
operator|!=
name|node
condition|)
name|bitmap_clear_bit
argument_list|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|j
index|]
argument_list|,
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_edge_t
argument_list|,
name|succvec
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|c
operator|->
name|dest
operator|!=
name|node
condition|)
block|{
name|unsigned
name|int
name|place
decl_stmt|;
name|struct
name|constraint_edge
name|lookfor
decl_stmt|;
name|constraint_edge_t
name|result
decl_stmt|;
name|lookfor
operator|.
name|dest
operator|=
name|node
expr_stmt|;
name|place
operator|=
name|VEC_lower_bound
argument_list|(
name|constraint_edge_t
argument_list|,
name|graph
operator|->
name|preds
index|[
name|c
operator|->
name|dest
index|]
argument_list|,
operator|&
name|lookfor
argument_list|,
name|constraint_edge_less
argument_list|)
expr_stmt|;
name|result
operator|=
name|VEC_ordered_remove
argument_list|(
name|constraint_edge_t
argument_list|,
name|graph
operator|->
name|preds
index|[
name|c
operator|->
name|dest
index|]
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|constraint_edge_pool
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* Walk the preds, erase the associated succs.  */
name|EXECUTE_IF_IN_NONNULL_BITMAP
argument_list|(
argument|graph->zero_weight_preds[node]
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
if|if
condition|(
name|j
operator|!=
name|node
condition|)
name|bitmap_clear_bit
argument_list|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|j
index|]
argument_list|,
name|node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_edge_t
argument_list|,
name|predvec
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|c
operator|->
name|dest
operator|!=
name|node
condition|)
block|{
name|unsigned
name|int
name|place
decl_stmt|;
name|struct
name|constraint_edge
name|lookfor
decl_stmt|;
name|constraint_edge_t
name|result
decl_stmt|;
name|lookfor
operator|.
name|dest
operator|=
name|node
expr_stmt|;
name|place
operator|=
name|VEC_lower_bound
argument_list|(
name|constraint_edge_t
argument_list|,
name|graph
operator|->
name|succs
index|[
name|c
operator|->
name|dest
index|]
argument_list|,
operator|&
name|lookfor
argument_list|,
name|constraint_edge_less
argument_list|)
expr_stmt|;
name|result
operator|=
name|VEC_ordered_remove
argument_list|(
name|constraint_edge_t
argument_list|,
name|graph
operator|->
name|succs
index|[
name|c
operator|->
name|dest
index|]
argument_list|,
name|place
argument_list|)
expr_stmt|;
name|pool_free
argument_list|(
name|constraint_edge_pool
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|node
index|]
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|node
index|]
argument_list|)
expr_stmt|;
name|graph
operator|->
name|zero_weight_preds
index|[
name|node
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|node
index|]
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|node
index|]
argument_list|)
expr_stmt|;
name|graph
operator|->
name|zero_weight_succs
index|[
name|node
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|,
name|graph
operator|->
name|preds
index|[
name|node
index|]
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|,
name|graph
operator|->
name|succs
index|[
name|node
index|]
argument_list|)
expr_stmt|;
name|graph
operator|->
name|preds
index|[
name|node
index|]
operator|=
name|NULL
expr_stmt|;
name|graph
operator|->
name|succs
index|[
name|node
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|bool
name|edge_added
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add edge (src, dest) to the graph.  */
end_comment

begin_function
specifier|static
name|bool
name|add_graph_edge
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|src
parameter_list|,
name|unsigned
name|int
name|dest
parameter_list|)
block|{
name|unsigned
name|int
name|place
decl_stmt|;
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|vec
expr_stmt|;
name|struct
name|constraint_edge
name|newe
decl_stmt|;
name|newe
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
name|vec
operator|=
name|graph
operator|->
name|preds
index|[
name|src
index|]
expr_stmt|;
name|place
operator|=
name|VEC_lower_bound
argument_list|(
name|constraint_edge_t
argument_list|,
name|vec
argument_list|,
operator|&
name|newe
argument_list|,
name|constraint_edge_less
argument_list|)
expr_stmt|;
if|if
condition|(
name|place
operator|==
name|VEC_length
argument_list|(
name|constraint_edge_t
argument_list|,
name|vec
argument_list|)
operator|||
name|VEC_index
argument_list|(
name|constraint_edge_t
argument_list|,
name|vec
argument_list|,
name|place
argument_list|)
operator|->
name|dest
operator|!=
name|dest
condition|)
block|{
name|constraint_edge_t
name|edge
init|=
name|new_constraint_edge
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|VEC_safe_insert
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|,
name|graph
operator|->
name|preds
index|[
name|src
index|]
argument_list|,
name|place
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|edge
operator|=
name|new_constraint_edge
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|place
operator|=
name|VEC_lower_bound
argument_list|(
name|constraint_edge_t
argument_list|,
name|graph
operator|->
name|succs
index|[
name|dest
index|]
argument_list|,
name|edge
argument_list|,
name|constraint_edge_less
argument_list|)
expr_stmt|;
name|VEC_safe_insert
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|,
name|graph
operator|->
name|succs
index|[
name|dest
index|]
argument_list|,
name|place
argument_list|,
name|edge
argument_list|)
expr_stmt|;
name|edge_added
operator|=
name|true
expr_stmt|;
name|stats
operator|.
name|num_edges
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the bitmap representing the weights of edge (SRC, DEST).  */
end_comment

begin_function
specifier|static
name|bitmap
modifier|*
name|get_graph_weights
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|src
parameter_list|,
name|unsigned
name|int
name|dest
parameter_list|)
block|{
name|constraint_edge_t
name|edge
decl_stmt|;
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|vec
expr_stmt|;
name|struct
name|constraint_edge
name|lookfor
decl_stmt|;
name|lookfor
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
name|vec
operator|=
name|graph
operator|->
name|preds
index|[
name|src
index|]
expr_stmt|;
name|edge
operator|=
name|constraint_edge_vec_find
argument_list|(
name|vec
argument_list|,
name|lookfor
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|edge
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|&
name|edge
operator|->
name|weights
return|;
block|}
end_function

begin_comment
comment|/* Allocate graph weight bitmap for the edges associated with SRC and    DEST in GRAPH.  Both the pred and the succ edges share a single    bitmap, so we need to set both edges to that bitmap.  */
end_comment

begin_function
specifier|static
name|bitmap
name|allocate_graph_weights
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|src
parameter_list|,
name|unsigned
name|int
name|dest
parameter_list|)
block|{
name|bitmap
name|result
decl_stmt|;
name|constraint_edge_t
name|edge
decl_stmt|;
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|vec
expr_stmt|;
name|struct
name|constraint_edge
name|lookfor
decl_stmt|;
name|result
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ptabitmap_obstack
argument_list|)
expr_stmt|;
comment|/* Set the pred weight.  */
name|lookfor
operator|.
name|dest
operator|=
name|dest
expr_stmt|;
name|vec
operator|=
name|graph
operator|->
name|preds
index|[
name|src
index|]
expr_stmt|;
name|edge
operator|=
name|constraint_edge_vec_find
argument_list|(
name|vec
argument_list|,
name|lookfor
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|edge
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|edge
operator|->
name|weights
operator|=
name|result
expr_stmt|;
comment|/* Set the succ weight.  */
name|lookfor
operator|.
name|dest
operator|=
name|src
expr_stmt|;
name|vec
operator|=
name|graph
operator|->
name|succs
index|[
name|dest
index|]
expr_stmt|;
name|edge
operator|=
name|constraint_edge_vec_find
argument_list|(
name|vec
argument_list|,
name|lookfor
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|edge
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|edge
operator|->
name|weights
operator|=
name|result
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Merge GRAPH nodes FROM and TO into node TO.  */
end_comment

begin_function
specifier|static
name|void
name|merge_graph_nodes
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|)
block|{
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|succvec
operator|=
name|graph
operator|->
name|succs
index|[
name|from
index|]
expr_stmt|;
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|predvec
operator|=
name|graph
operator|->
name|preds
index|[
name|from
index|]
expr_stmt|;
name|int
name|i
decl_stmt|;
name|constraint_edge_t
name|c
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* Merge all the zero weighted predecessor edges.  */
if|if
condition|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|from
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|graph
operator|->
name|zero_weight_preds
index|[
name|to
index|]
condition|)
name|graph
operator|->
name|zero_weight_preds
index|[
name|to
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|predbitmap_obstack
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|graph->zero_weight_preds[from]
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
name|j
operator|!=
name|to
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|j
index|]
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|j
index|]
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
name|bitmap_ior_into
argument_list|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|to
index|]
argument_list|,
name|graph
operator|->
name|zero_weight_preds
index|[
name|from
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Merge all the zero weighted successor edges.  */
if|if
condition|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|from
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|graph
operator|->
name|zero_weight_succs
index|[
name|to
index|]
condition|)
name|graph
operator|->
name|zero_weight_succs
index|[
name|to
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ptabitmap_obstack
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|graph->zero_weight_succs[from]
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|bitmap_clear_bit
argument_list|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|j
index|]
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|j
index|]
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
name|bitmap_ior_into
argument_list|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|to
index|]
argument_list|,
name|graph
operator|->
name|zero_weight_succs
index|[
name|from
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Merge all the nonzero weighted predecessor edges.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_edge_t
argument_list|,
name|predvec
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|d
init|=
name|c
operator|->
name|dest
decl_stmt|;
name|bitmap
name|temp
decl_stmt|;
name|bitmap
modifier|*
name|weights
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|dest
operator|==
name|from
condition|)
name|d
operator|=
name|to
expr_stmt|;
name|add_graph_edge
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|*
operator|(
name|get_graph_weights
argument_list|(
name|graph
argument_list|,
name|from
argument_list|,
name|c
operator|->
name|dest
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|weights
operator|=
name|get_graph_weights
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|weights
condition|)
operator|*
name|weights
operator|=
name|allocate_graph_weights
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
operator|*
name|weights
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Merge all the nonzero weighted successor edges.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_edge_t
argument_list|,
name|succvec
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|d
init|=
name|c
operator|->
name|dest
decl_stmt|;
name|bitmap
name|temp
decl_stmt|;
name|bitmap
modifier|*
name|weights
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|dest
operator|==
name|from
condition|)
name|d
operator|=
name|to
expr_stmt|;
name|add_graph_edge
argument_list|(
name|graph
argument_list|,
name|d
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|*
operator|(
name|get_graph_weights
argument_list|(
name|graph
argument_list|,
name|c
operator|->
name|dest
argument_list|,
name|from
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|weights
operator|=
name|get_graph_weights
argument_list|(
name|graph
argument_list|,
name|d
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|weights
condition|)
operator|*
name|weights
operator|=
name|allocate_graph_weights
argument_list|(
name|graph
argument_list|,
name|d
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
operator|*
name|weights
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
name|clear_edges_for_node
argument_list|(
name|graph
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a graph edge to GRAPH, going from TO to FROM, with WEIGHT, if    it doesn't exist in the graph already.    Return false if the edge already existed, true otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|int_add_graph_edge
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|weight
parameter_list|)
block|{
if|if
condition|(
name|to
operator|==
name|from
operator|&&
name|weight
operator|==
literal|0
condition|)
block|{
return|return
name|false
return|;
block|}
else|else
block|{
name|bool
name|r
init|=
name|false
decl_stmt|;
if|if
condition|(
name|weight
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|graph
operator|->
name|zero_weight_preds
index|[
name|to
index|]
condition|)
name|graph
operator|->
name|zero_weight_preds
index|[
name|to
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|predbitmap_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|graph
operator|->
name|zero_weight_succs
index|[
name|from
index|]
condition|)
name|graph
operator|->
name|zero_weight_succs
index|[
name|from
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|ptabitmap_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|from
index|]
argument_list|,
name|to
argument_list|)
condition|)
block|{
name|edge_added
operator|=
name|true
expr_stmt|;
name|r
operator|=
name|true
expr_stmt|;
name|stats
operator|.
name|num_edges
operator|++
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|to
index|]
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|from
index|]
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bitmap
modifier|*
name|weights
decl_stmt|;
name|r
operator|=
name|add_graph_edge
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|weights
operator|=
name|get_graph_weights
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|weights
condition|)
block|{
name|r
operator|=
name|true
expr_stmt|;
operator|*
name|weights
operator|=
name|allocate_graph_weights
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
operator|*
name|weights
argument_list|,
name|weight
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator||=
operator|!
name|bitmap_bit_p
argument_list|(
operator|*
name|weights
argument_list|,
name|weight
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
operator|*
name|weights
argument_list|,
name|weight
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|r
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if {DEST.SRC} is an existing graph edge in GRAPH.  */
end_comment

begin_function
specifier|static
name|bool
name|valid_graph_edge
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|src
parameter_list|,
name|unsigned
name|int
name|dest
parameter_list|)
block|{
name|struct
name|constraint_edge
name|lookfor
decl_stmt|;
name|lookfor
operator|.
name|dest
operator|=
name|src
expr_stmt|;
return|return
operator|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|dest
index|]
operator|&&
name|bitmap_bit_p
argument_list|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|dest
index|]
argument_list|,
name|src
argument_list|)
operator|)
operator|||
name|constraint_edge_vec_find
argument_list|(
name|graph
operator|->
name|succs
index|[
name|dest
index|]
argument_list|,
name|lookfor
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return true if {DEST, SRC} is an existing weighted graph edge (IE has    a weight other than 0) in GRAPH.  */
end_comment

begin_function
specifier|static
name|bool
name|valid_weighted_graph_edge
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|src
parameter_list|,
name|unsigned
name|int
name|dest
parameter_list|)
block|{
name|struct
name|constraint_edge
name|lookfor
decl_stmt|;
name|lookfor
operator|.
name|dest
operator|=
name|src
expr_stmt|;
return|return
name|graph
operator|->
name|preds
index|[
name|src
index|]
operator|&&
name|constraint_edge_vec_find
argument_list|(
name|graph
operator|->
name|succs
index|[
name|dest
index|]
argument_list|,
name|lookfor
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Build the constraint graph.  */
end_comment

begin_function
specifier|static
name|void
name|build_constraint_graph
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
name|graph
operator|=
name|XNEW
argument_list|(
expr|struct
name|constraint_graph
argument_list|)
expr_stmt|;
name|graph_size
operator|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
operator|+
literal|1
expr_stmt|;
name|graph
operator|->
name|succs
operator|=
name|XCNEWVEC
argument_list|(
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
argument_list|,
name|graph_size
argument_list|)
expr_stmt|;
name|graph
operator|->
name|preds
operator|=
name|XCNEWVEC
argument_list|(
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
argument_list|,
name|graph_size
argument_list|)
expr_stmt|;
name|graph
operator|->
name|zero_weight_succs
operator|=
name|XCNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|graph_size
argument_list|)
expr_stmt|;
name|graph
operator|->
name|zero_weight_preds
operator|=
name|XCNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|graph_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
name|constraints
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|constraint_expr
name|lhs
init|=
name|c
operator|->
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|rhs
init|=
name|c
operator|->
name|rhs
decl_stmt|;
name|unsigned
name|int
name|lhsvar
init|=
name|get_varinfo_fc
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|id
decl_stmt|;
name|unsigned
name|int
name|rhsvar
init|=
name|get_varinfo_fc
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|id
decl_stmt|;
if|if
condition|(
name|lhs
operator|.
name|type
operator|==
name|DEREF
condition|)
block|{
comment|/* *x = y or *x =&y (complex) */
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
operator|||
name|rhsvar
operator|>
name|anything_id
condition|)
name|insert_into_complex
argument_list|(
name|lhsvar
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
block|{
comment|/* !special var= *y */
if|if
condition|(
operator|!
operator|(
name|get_varinfo
argument_list|(
name|lhsvar
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
name|insert_into_complex
argument_list|(
name|rhsvar
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
block|{
comment|/* x =&y */
name|bitmap_set_bit
argument_list|(
name|get_varinfo
argument_list|(
name|lhsvar
argument_list|)
operator|->
name|solution
argument_list|,
name|rhsvar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lhsvar
operator|>
name|anything_id
condition|)
block|{
comment|/* Ignore 0 weighted self edges, as they can't possibly contribute 	     anything */
if|if
condition|(
name|lhsvar
operator|!=
name|rhsvar
operator|||
name|rhs
operator|.
name|offset
operator|!=
literal|0
operator|||
name|lhs
operator|.
name|offset
operator|!=
literal|0
condition|)
block|{
comment|/* x = y (simple) */
name|int_add_graph_edge
argument_list|(
name|graph
argument_list|,
name|lhs
operator|.
name|var
argument_list|,
name|rhs
operator|.
name|var
argument_list|,
name|rhs
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Changed variables on the last iteration.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|changed_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
name|changed
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEF_VEC_I
argument_list|(
name|unsigned
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_I
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Strongly Connected Component visitation info.  */
end_comment

begin_struct
struct|struct
name|scc_info
block|{
name|sbitmap
name|visited
decl_stmt|;
name|sbitmap
name|in_component
decl_stmt|;
name|int
name|current_index
decl_stmt|;
name|unsigned
name|int
modifier|*
name|visited_index
decl_stmt|;
name|VEC
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|)
operator|*
name|scc_stack
expr_stmt|;
name|VEC
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|)
operator|*
name|unification_queue
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Recursive routine to find strongly connected components in GRAPH.    SI is the SCC info to store the information in, and N is the id of current    graph node we are processing.        This is Tarjan's strongly connected component finding algorithm, as    modified by Nuutila to keep only non-root nodes on the stack.      The algorithm can be found in "On finding the strongly connected    connected components in a directed graph" by Esko Nuutila and Eljas    Soisalon-Soininen, in Information Processing Letters volume 49,    number 1, pages 9-14.  */
end_comment

begin_function
specifier|static
name|void
name|scc_visit
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|struct
name|scc_info
modifier|*
name|si
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|gcc_assert
argument_list|(
name|get_varinfo
argument_list|(
name|n
argument_list|)
operator|->
name|node
operator|==
name|n
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|si
operator|->
name|visited
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|si
operator|->
name|in_component
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|si
operator|->
name|visited_index
index|[
name|n
index|]
operator|=
name|si
operator|->
name|current_index
operator|++
expr_stmt|;
comment|/* Visit all the successors.  */
name|EXECUTE_IF_IN_NONNULL_BITMAP
argument_list|(
argument|graph->zero_weight_succs[n]
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|int
name|w
init|=
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|si
operator|->
name|visited
argument_list|,
name|w
argument_list|)
condition|)
name|scc_visit
argument_list|(
name|graph
argument_list|,
name|si
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|si
operator|->
name|in_component
argument_list|,
name|w
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|t
init|=
name|get_varinfo
argument_list|(
name|w
argument_list|)
operator|->
name|node
decl_stmt|;
name|unsigned
name|int
name|nnode
init|=
name|get_varinfo
argument_list|(
name|n
argument_list|)
operator|->
name|node
decl_stmt|;
if|if
condition|(
name|si
operator|->
name|visited_index
index|[
name|t
index|]
operator|<
name|si
operator|->
name|visited_index
index|[
name|nnode
index|]
condition|)
name|get_varinfo
argument_list|(
name|n
argument_list|)
operator|->
name|node
operator|=
name|t
expr_stmt|;
block|}
block|}
comment|/* See if any components have been identified.  */
if|if
condition|(
name|get_varinfo
argument_list|(
name|n
argument_list|)
operator|->
name|node
operator|==
name|n
condition|)
block|{
name|unsigned
name|int
name|t
init|=
name|si
operator|->
name|visited_index
index|[
name|n
index|]
decl_stmt|;
name|SET_BIT
argument_list|(
name|si
operator|->
name|in_component
argument_list|,
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
operator|!=
literal|0
operator|&&
name|t
operator|<
name|si
operator|->
name|visited_index
index|[
name|VEC_last
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
index|]
condition|)
block|{
name|unsigned
name|int
name|w
init|=
name|VEC_pop
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
decl_stmt|;
name|get_varinfo
argument_list|(
name|w
argument_list|)
operator|->
name|node
operator|=
name|n
expr_stmt|;
name|SET_BIT
argument_list|(
name|si
operator|->
name|in_component
argument_list|,
name|w
argument_list|)
expr_stmt|;
comment|/* Mark this node for collapsing.  */
name|VEC_safe_push
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|si
operator|->
name|unification_queue
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|VEC_safe_push
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Collapse two variables into one variable.  */
end_comment

begin_function
specifier|static
name|void
name|collapse_nodes
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|)
block|{
name|bitmap
name|tosol
decl_stmt|,
name|fromsol
decl_stmt|;
name|condense_varmap_nodes
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|tosol
operator|=
name|get_varinfo
argument_list|(
name|to
argument_list|)
operator|->
name|solution
expr_stmt|;
name|fromsol
operator|=
name|get_varinfo
argument_list|(
name|from
argument_list|)
operator|->
name|solution
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|tosol
argument_list|,
name|fromsol
argument_list|)
expr_stmt|;
name|merge_graph_nodes
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_graph_edge
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|to
index|]
condition|)
block|{
name|bitmap_clear_bit
argument_list|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|to
index|]
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|to
index|]
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid_weighted_graph_edge
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|to
argument_list|)
condition|)
block|{
name|bitmap
name|weights
init|=
operator|*
operator|(
name|get_graph_weights
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|to
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|weights
operator|||
name|bitmap_empty_p
argument_list|(
name|weights
argument_list|)
condition|)
name|erase_graph_self_edge
argument_list|(
name|graph
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
name|BITMAP_FREE
argument_list|(
name|fromsol
argument_list|)
expr_stmt|;
name|get_varinfo
argument_list|(
name|to
argument_list|)
operator|->
name|address_taken
operator||=
name|get_varinfo
argument_list|(
name|from
argument_list|)
operator|->
name|address_taken
expr_stmt|;
name|get_varinfo
argument_list|(
name|to
argument_list|)
operator|->
name|indirect_target
operator||=
name|get_varinfo
argument_list|(
name|from
argument_list|)
operator|->
name|indirect_target
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unify nodes in GRAPH that we have found to be part of a cycle.    SI is the Strongly Connected Components information structure that tells us    what components to unify.    UPDATE_CHANGED should be set to true if the changed sbitmap and changed    count should be updated to reflect the unification.  */
end_comment

begin_function
specifier|static
name|void
name|process_unification_queue
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|struct
name|scc_info
modifier|*
name|si
parameter_list|,
name|bool
name|update_changed
parameter_list|)
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|;
name|bitmap
name|tmp
init|=
name|BITMAP_ALLOC
argument_list|(
name|update_changed
condition|?
operator|&
name|iteration_obstack
else|:
name|NULL
argument_list|)
decl_stmt|;
name|bitmap_clear
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* We proceed as follows:       For each component in the queue (components are delineated by      when current_queue_element->node != next_queue_element->node):          rep = representative node for component          For each node (tounify) to be unified in the component,            merge the solution for tounify into tmp bitmap             clear solution for tounify             merge edges from tounify into rep  	   merge complex constraints from tounify into rep  	   update changed count to note that tounify will never change 	   again  	Merge tmp into solution for rep, marking rep changed if this 	changed rep's solution. 	 	Delete any 0 weighted self-edges we now have for rep.  */
while|while
condition|(
name|i
operator|!=
name|VEC_length
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|unification_queue
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|tounify
init|=
name|VEC_index
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|unification_queue
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|n
init|=
name|get_varinfo
argument_list|(
name|tounify
argument_list|)
operator|->
name|node
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unifying %s to %s\n"
argument_list|,
name|get_varinfo
argument_list|(
name|tounify
argument_list|)
operator|->
name|name
argument_list|,
name|get_varinfo
argument_list|(
name|n
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_changed
condition|)
name|stats
operator|.
name|unified_vars_dynamic
operator|++
expr_stmt|;
else|else
name|stats
operator|.
name|unified_vars_static
operator|++
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|tmp
argument_list|,
name|get_varinfo
argument_list|(
name|tounify
argument_list|)
operator|->
name|solution
argument_list|)
expr_stmt|;
name|merge_graph_nodes
argument_list|(
name|graph
argument_list|,
name|n
argument_list|,
name|tounify
argument_list|)
expr_stmt|;
name|condense_varmap_nodes
argument_list|(
name|n
argument_list|,
name|tounify
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_changed
operator|&&
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|tounify
argument_list|)
condition|)
block|{
name|RESET_BIT
argument_list|(
name|changed
argument_list|,
name|tounify
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|n
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|changed_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|changed_count
operator|--
expr_stmt|;
block|}
block|}
name|bitmap_clear
argument_list|(
name|get_varinfo
argument_list|(
name|tounify
argument_list|)
operator|->
name|solution
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
comment|/* If we've either finished processing the entire queue, or 	 finished processing all nodes for component n, update the solution for 	 n.  */
if|if
condition|(
name|i
operator|==
name|VEC_length
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|unification_queue
argument_list|)
operator|||
name|get_varinfo
argument_list|(
name|VEC_index
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|unification_queue
argument_list|,
name|i
argument_list|)
argument_list|)
operator|->
name|node
operator|!=
name|n
condition|)
block|{
comment|/* If the solution changes because of the merging, we need to mark 	     the variable as changed.  */
if|if
condition|(
name|bitmap_ior_into
argument_list|(
name|get_varinfo
argument_list|(
name|n
argument_list|)
operator|->
name|solution
argument_list|,
name|tmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|update_changed
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
name|bitmap_clear
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_graph_edge
argument_list|(
name|graph
argument_list|,
name|n
argument_list|,
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|n
index|]
condition|)
block|{
if|if
condition|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|n
index|]
condition|)
name|bitmap_clear_bit
argument_list|(
name|graph
operator|->
name|zero_weight_preds
index|[
name|n
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|n
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid_weighted_graph_edge
argument_list|(
name|graph
argument_list|,
name|n
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|bitmap
name|weights
init|=
operator|*
operator|(
name|get_graph_weights
argument_list|(
name|graph
argument_list|,
name|n
argument_list|,
name|n
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|weights
operator|||
name|bitmap_empty_p
argument_list|(
name|weights
argument_list|)
condition|)
name|erase_graph_self_edge
argument_list|(
name|graph
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Information needed to compute the topological ordering of a graph.  */
end_comment

begin_struct
struct|struct
name|topo_info
block|{
comment|/* sbitmap of visited nodes.  */
name|sbitmap
name|visited
decl_stmt|;
comment|/* Array that stores the topological order of the graph, *in      reverse*.  */
name|VEC
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|)
operator|*
name|topo_order
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Initialize and return a topological info structure.  */
end_comment

begin_function
specifier|static
name|struct
name|topo_info
modifier|*
name|init_topo_info
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|size
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|struct
name|topo_info
modifier|*
name|ti
init|=
name|XNEW
argument_list|(
expr|struct
name|topo_info
argument_list|)
decl_stmt|;
name|ti
operator|->
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|ti
operator|->
name|visited
argument_list|)
expr_stmt|;
name|ti
operator|->
name|topo_order
operator|=
name|VEC_alloc
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ti
return|;
block|}
end_function

begin_comment
comment|/* Free the topological sort info pointed to by TI.  */
end_comment

begin_function
specifier|static
name|void
name|free_topo_info
parameter_list|(
name|struct
name|topo_info
modifier|*
name|ti
parameter_list|)
block|{
name|sbitmap_free
argument_list|(
name|ti
operator|->
name|visited
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|ti
operator|->
name|topo_order
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Visit the graph in topological order, and store the order in the    topo_info structure.  */
end_comment

begin_function
specifier|static
name|void
name|topo_visit
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|struct
name|topo_info
modifier|*
name|ti
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|succs
operator|=
name|graph
operator|->
name|succs
index|[
name|n
index|]
expr_stmt|;
name|bitmap
name|temp
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|constraint_edge_t
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|SET_BIT
argument_list|(
name|ti
operator|->
name|visited
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|constraint_edge_t
argument_list|,
name|succs
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|temp
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph
operator|->
name|zero_weight_succs
index|[
name|n
index|]
condition|)
name|bitmap_ior_into
argument_list|(
name|temp
argument_list|,
name|graph
operator|->
name|zero_weight_succs
index|[
name|n
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_edge_t
argument_list|,
name|succs
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
name|bitmap_set_bit
argument_list|(
name|temp
argument_list|,
name|c
operator|->
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|graph
operator|->
name|zero_weight_succs
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|temp
condition|)
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|temp
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|ti
operator|->
name|visited
argument_list|,
name|j
argument_list|)
condition|)
name|topo_visit
argument_list|(
name|graph
argument_list|,
name|ti
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|VEC_safe_push
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|ti
operator|->
name|topo_order
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if variable N + OFFSET is a legal field of N.  */
end_comment

begin_function
specifier|static
name|bool
name|type_safe
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|offset
parameter_list|)
block|{
name|varinfo_t
name|ninfo
init|=
name|get_varinfo
argument_list|(
name|n
argument_list|)
decl_stmt|;
comment|/* For things we've globbed to single variables, any offset into the      variable acts like the entire variable, so that it becomes offset      0.  */
if|if
condition|(
name|ninfo
operator|->
name|is_special_var
operator|||
name|ninfo
operator|->
name|is_artificial_var
operator|||
name|ninfo
operator|->
name|is_unknown_size_var
condition|)
block|{
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
operator|(
name|get_varinfo
argument_list|(
name|n
argument_list|)
operator|->
name|offset
operator|+
operator|*
name|offset
operator|)
operator|<
name|get_varinfo
argument_list|(
name|n
argument_list|)
operator|->
name|fullsize
return|;
block|}
end_function

begin_comment
comment|/* Process a constraint C that represents *x =&y.  */
end_comment

begin_function
specifier|static
name|void
name|do_da_constraint
parameter_list|(
name|constraint_graph_t
name|graph
name|ATTRIBUTE_UNUSED
parameter_list|,
name|constraint_t
name|c
parameter_list|,
name|bitmap
name|delta
parameter_list|)
block|{
name|unsigned
name|int
name|rhs
init|=
name|c
operator|->
name|rhs
operator|.
name|var
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* For each member j of Delta (Sol(x)), add x to Sol(j)  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|delta
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|offset
init|=
name|c
operator|->
name|lhs
operator|.
name|offset
decl_stmt|;
if|if
condition|(
name|type_safe
argument_list|(
name|j
argument_list|,
operator|&
name|offset
argument_list|)
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
block|{
comment|/* *x != NULL&& *x != ANYTHING*/
name|varinfo_t
name|v
decl_stmt|;
name|unsigned
name|int
name|t
decl_stmt|;
name|bitmap
name|sol
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
init|=
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|offset
operator|+
name|offset
decl_stmt|;
name|v
operator|=
name|first_vi_for_offset
argument_list|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
argument_list|,
name|fieldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
name|t
operator|=
name|v
operator|->
name|node
expr_stmt|;
name|sol
operator|=
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|sol
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|sol
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
literal|0
operator|&&
name|dump_file
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Untypesafe usage in do_da_constraint.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a constraint C that represents x = *y, using DELTA as the    starting solution.  */
end_comment

begin_function
specifier|static
name|void
name|do_sd_constraint
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|constraint_t
name|c
parameter_list|,
name|bitmap
name|delta
parameter_list|)
block|{
name|unsigned
name|int
name|lhs
init|=
name|get_varinfo
argument_list|(
name|c
operator|->
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|node
decl_stmt|;
name|bool
name|flag
init|=
name|false
decl_stmt|;
name|bitmap
name|sol
init|=
name|get_varinfo
argument_list|(
name|lhs
argument_list|)
operator|->
name|solution
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|delta
argument_list|,
name|anything_id
argument_list|)
condition|)
block|{
name|flag
operator|=
operator|!
name|bitmap_bit_p
argument_list|(
name|sol
argument_list|,
name|anything_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|bitmap_set_bit
argument_list|(
name|sol
argument_list|,
name|anything_id
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* For each variable j in delta (Sol(y)), add          an edge in the graph from j to x, and union Sol(j) into Sol(x).  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|delta
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|roffset
init|=
name|c
operator|->
name|rhs
operator|.
name|offset
decl_stmt|;
if|if
condition|(
name|type_safe
argument_list|(
name|j
argument_list|,
operator|&
name|roffset
argument_list|)
condition|)
block|{
name|varinfo_t
name|v
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
init|=
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|offset
operator|+
name|roffset
decl_stmt|;
name|unsigned
name|int
name|t
decl_stmt|;
name|v
operator|=
name|first_vi_for_offset
argument_list|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
argument_list|,
name|fieldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
name|t
operator|=
name|v
operator|->
name|node
expr_stmt|;
comment|/* Adding edges from the special vars is pointless. 	     They don't have sets that can change.  */
if|if
condition|(
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|is_special_var
condition|)
name|flag
operator||=
name|bitmap_ior_into
argument_list|(
name|sol
argument_list|,
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|int_add_graph_edge
argument_list|(
name|graph
argument_list|,
name|lhs
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
condition|)
name|flag
operator||=
name|bitmap_ior_into
argument_list|(
name|sol
argument_list|,
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|&&
name|dump_file
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Untypesafe usage in do_sd_constraint\n"
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* If the LHS solution changed, mark the var as changed.  */
if|if
condition|(
name|flag
condition|)
block|{
name|get_varinfo
argument_list|(
name|lhs
argument_list|)
operator|->
name|solution
operator|=
name|sol
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|lhs
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process a constraint C that represents *x = y.  */
end_comment

begin_function
specifier|static
name|void
name|do_ds_constraint
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|constraint_t
name|c
parameter_list|,
name|bitmap
name|delta
parameter_list|)
block|{
name|unsigned
name|int
name|rhs
init|=
name|get_varinfo
argument_list|(
name|c
operator|->
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|node
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|roff
init|=
name|c
operator|->
name|rhs
operator|.
name|offset
decl_stmt|;
name|bitmap
name|sol
init|=
name|get_varinfo
argument_list|(
name|rhs
argument_list|)
operator|->
name|solution
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|sol
argument_list|,
name|anything_id
argument_list|)
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|delta
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|varinfo_t
name|jvi
init|=
name|get_varinfo
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|t
decl_stmt|;
name|unsigned
name|int
name|loff
init|=
name|c
operator|->
name|lhs
operator|.
name|offset
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
init|=
name|jvi
operator|->
name|offset
operator|+
name|loff
decl_stmt|;
name|varinfo_t
name|v
decl_stmt|;
name|v
operator|=
name|first_vi_for_offset
argument_list|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
argument_list|,
name|fieldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
name|t
operator|=
name|v
operator|->
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
argument_list|,
name|anything_id
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
argument_list|,
name|anything_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
comment|/* For each member j of delta (Sol(x)), add an edge from y to j and      union Sol(y) into Sol(j) */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|delta
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|loff
init|=
name|c
operator|->
name|lhs
operator|.
name|offset
decl_stmt|;
if|if
condition|(
name|type_safe
argument_list|(
name|j
argument_list|,
operator|&
name|loff
argument_list|)
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
block|{
name|varinfo_t
name|v
decl_stmt|;
name|unsigned
name|int
name|t
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
init|=
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|offset
operator|+
name|loff
decl_stmt|;
name|v
operator|=
name|first_vi_for_offset
argument_list|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
argument_list|,
name|fieldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
name|t
operator|=
name|v
operator|->
name|node
expr_stmt|;
if|if
condition|(
name|int_add_graph_edge
argument_list|(
name|graph
argument_list|,
name|t
argument_list|,
name|rhs
argument_list|,
name|roff
argument_list|)
condition|)
block|{
name|bitmap
name|tmp
init|=
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
decl_stmt|;
if|if
condition|(
name|set_union_with_increment
argument_list|(
name|tmp
argument_list|,
name|sol
argument_list|,
name|roff
argument_list|)
condition|)
block|{
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|rhs
condition|)
name|sol
operator|=
name|get_varinfo
argument_list|(
name|rhs
argument_list|)
operator|->
name|solution
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
literal|0
operator|&&
name|dump_file
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Untypesafe usage in do_ds_constraint\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a non-simple (simple meaning requires no iteration), non-copy    constraint (IE *x =&y, x = *y, and *x = y).  */
end_comment

begin_function
specifier|static
name|void
name|do_complex_constraint
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|constraint_t
name|c
parameter_list|,
name|bitmap
name|delta
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|lhs
operator|.
name|type
operator|==
name|DEREF
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
block|{
comment|/* *x =&y */
name|do_da_constraint
argument_list|(
name|graph
argument_list|,
name|c
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* *x = y */
name|do_ds_constraint
argument_list|(
name|graph
argument_list|,
name|c
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* x = *y */
if|if
condition|(
operator|!
operator|(
name|get_varinfo
argument_list|(
name|c
operator|->
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
name|do_sd_constraint
argument_list|(
name|graph
argument_list|,
name|c
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize and return a new SCC info structure.  */
end_comment

begin_function
specifier|static
name|struct
name|scc_info
modifier|*
name|init_scc_info
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|scc_info
modifier|*
name|si
init|=
name|XNEW
argument_list|(
expr|struct
name|scc_info
argument_list|)
decl_stmt|;
name|size_t
name|size
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|si
operator|->
name|current_index
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|si
operator|->
name|visited
argument_list|)
expr_stmt|;
name|si
operator|->
name|in_component
operator|=
name|sbitmap_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|si
operator|->
name|in_component
argument_list|)
expr_stmt|;
name|si
operator|->
name|visited_index
operator|=
name|XCNEWVEC
argument_list|(
argument|unsigned int
argument_list|,
argument|size +
literal|1
argument_list|)
expr_stmt|;
name|si
operator|->
name|scc_stack
operator|=
name|VEC_alloc
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|si
operator|->
name|unification_queue
operator|=
name|VEC_alloc
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|si
return|;
block|}
end_function

begin_comment
comment|/* Free an SCC info structure pointed to by SI */
end_comment

begin_function
specifier|static
name|void
name|free_scc_info
parameter_list|(
name|struct
name|scc_info
modifier|*
name|si
parameter_list|)
block|{
name|sbitmap_free
argument_list|(
name|si
operator|->
name|visited
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|si
operator|->
name|in_component
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|si
operator|->
name|visited_index
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|si
operator|->
name|unification_queue
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find cycles in GRAPH that occur, using strongly connected components, and    collapse the cycles into a single representative node.  if UPDATE_CHANGED    is true, then update the changed sbitmap to note those nodes whose    solutions have changed as a result of collapsing.  */
end_comment

begin_function
specifier|static
name|void
name|find_and_collapse_graph_cycles
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|bool
name|update_changed
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|size
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|struct
name|scc_info
modifier|*
name|si
init|=
name|init_scc_info
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|size
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|si
operator|->
name|visited
argument_list|,
name|i
argument_list|)
operator|&&
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|node
operator|==
name|i
condition|)
name|scc_visit
argument_list|(
name|graph
argument_list|,
name|si
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|process_unification_queue
argument_list|(
name|graph
argument_list|,
name|si
argument_list|,
name|update_changed
argument_list|)
expr_stmt|;
name|free_scc_info
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute a topological ordering for GRAPH, and store the result in the    topo_info structure TI.  */
end_comment

begin_function
specifier|static
name|void
name|compute_topo_order
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|struct
name|topo_info
modifier|*
name|ti
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|size
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|size
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|ti
operator|->
name|visited
argument_list|,
name|i
argument_list|)
operator|&&
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|node
operator|==
name|i
condition|)
name|topo_visit
argument_list|(
name|graph
argument_list|,
name|ti
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if bitmap B is empty, or a bitmap other than bit 0 is set. */
end_comment

begin_function
specifier|static
name|bool
name|bitmap_other_than_zero_bit_set
parameter_list|(
name|bitmap
name|b
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
name|bitmap_empty_p
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|false
return|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|b
argument_list|,
literal|1
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Perform offline variable substitution.        This is a linear time way of identifying variables that must have    equivalent points-to sets, including those caused by static cycles,    and single entry subgraphs, in the constraint graph.     The technique is described in "Off-line variable substitution for    scaling points-to analysis" by Atanas Rountev and Satish Chandra,    in "ACM SIGPLAN Notices" volume 35, number 5, pages 47-56.  */
end_comment

begin_function
specifier|static
name|void
name|perform_var_substitution
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|)
block|{
name|struct
name|topo_info
modifier|*
name|ti
init|=
name|init_topo_info
argument_list|()
decl_stmt|;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
expr_stmt|;
comment|/* Compute the topological ordering of the graph, then visit each      node in topological order.  */
name|compute_topo_order
argument_list|(
name|graph
argument_list|,
name|ti
argument_list|)
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|unsigned
argument_list|,
name|ti
operator|->
name|topo_order
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
init|=
name|VEC_pop
argument_list|(
name|unsigned
argument_list|,
name|ti
operator|->
name|topo_order
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|pred
decl_stmt|;
name|varinfo_t
name|vi
init|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bool
name|okay_to_elim
init|=
name|false
decl_stmt|;
name|unsigned
name|int
name|root
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|predvec
operator|=
name|graph
operator|->
name|preds
index|[
name|i
index|]
expr_stmt|;
name|constraint_edge_t
name|ce
init|=
name|NULL
decl_stmt|;
name|bitmap
name|tmp
decl_stmt|;
name|unsigned
name|int
name|k
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* We can't eliminate things whose address is taken, or which is 	 the target of a dereference.  */
if|if
condition|(
name|vi
operator|->
name|address_taken
operator|||
name|vi
operator|->
name|indirect_target
condition|)
continue|continue;
comment|/* See if all predecessors of I are ripe for elimination */
name|EXECUTE_IF_IN_NONNULL_BITMAP
argument_list|(
argument|graph->zero_weight_preds[i]
argument_list|,
literal|0
argument_list|,
argument|k
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|int
name|w
decl_stmt|;
name|w
operator|=
name|get_varinfo
argument_list|(
name|k
argument_list|)
operator|->
name|node
expr_stmt|;
comment|/* We can't eliminate the node if one of the predecessors is 	       part of a different strongly connected component.  */
if|if
condition|(
operator|!
name|okay_to_elim
condition|)
block|{
name|root
operator|=
name|w
expr_stmt|;
name|okay_to_elim
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|!=
name|root
condition|)
block|{
name|okay_to_elim
operator|=
name|false
expr_stmt|;
break|break;
block|}
comment|/* Theorem 4 in Rountev and Chandra: If i is a direct node, 	       then Solution(i) is a subset of Solution (w), where w is a 	       predecessor in the graph.   	       Corollary: If all predecessors of i have the same 	       points-to set, then i has that same points-to set as 	       those predecessors.  */
name|tmp
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_and_compl
argument_list|(
name|tmp
argument_list|,
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|solution
argument_list|,
name|get_varinfo
argument_list|(
name|w
argument_list|)
operator|->
name|solution
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|okay_to_elim
operator|=
name|false
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|okay_to_elim
condition|)
for|for
control|(
name|pred
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_edge_t
argument_list|,
name|predvec
argument_list|,
name|pred
argument_list|,
name|ce
argument_list|)
condition|;
name|pred
operator|++
control|)
block|{
name|bitmap
name|weight
decl_stmt|;
name|unsigned
name|int
name|w
decl_stmt|;
name|weight
operator|=
operator|*
operator|(
name|get_graph_weights
argument_list|(
name|graph
argument_list|,
name|i
argument_list|,
name|ce
operator|->
name|dest
argument_list|)
operator|)
expr_stmt|;
comment|/* We can't eliminate variables that have nonzero weighted 	       edges between them.  */
if|if
condition|(
name|weight
operator|&&
name|bitmap_other_than_zero_bit_set
argument_list|(
name|weight
argument_list|)
condition|)
block|{
name|okay_to_elim
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|w
operator|=
name|get_varinfo
argument_list|(
name|ce
operator|->
name|dest
argument_list|)
operator|->
name|node
expr_stmt|;
comment|/* We can't eliminate the node if one of the predecessors is 	       part of a different strongly connected component.  */
if|if
condition|(
operator|!
name|okay_to_elim
condition|)
block|{
name|root
operator|=
name|w
expr_stmt|;
name|okay_to_elim
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|w
operator|!=
name|root
condition|)
block|{
name|okay_to_elim
operator|=
name|false
expr_stmt|;
break|break;
block|}
comment|/* Theorem 4 in Rountev and Chandra: If i is a direct node, 	       then Solution(i) is a subset of Solution (w), where w is a 	       predecessor in the graph.   	       Corollary: If all predecessors of i have the same 	       points-to set, then i has that same points-to set as 	       those predecessors.  */
name|tmp
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_and_compl
argument_list|(
name|tmp
argument_list|,
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|solution
argument_list|,
name|get_varinfo
argument_list|(
name|w
argument_list|)
operator|->
name|solution
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|okay_to_elim
operator|=
name|false
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* See if the root is different than the original node.  	 If so, we've found an equivalence.  */
if|if
condition|(
name|root
operator|!=
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|node
operator|&&
name|okay_to_elim
condition|)
block|{
comment|/* Found an equivalence */
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|node
operator|=
name|root
expr_stmt|;
name|collapse_nodes
argument_list|(
name|graph
argument_list|,
name|root
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Collapsing %s into %s\n"
argument_list|,
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|name
argument_list|,
name|get_varinfo
argument_list|(
name|root
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|stats
operator|.
name|collapsed_vars
operator|++
expr_stmt|;
block|}
block|}
name|bitmap_obstack_release
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
expr_stmt|;
name|free_topo_info
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Solve the constraint graph GRAPH using our worklist solver.    This is based on the PW* family of solvers from the "Efficient Field    Sensitive Pointer Analysis for C" paper.    It works by iterating over all the graph nodes, processing the complex    constraints and propagating the copy constraints, until everything stops    changed.  This corresponds to steps 6-8 in the solving list given above.  */
end_comment

begin_function
specifier|static
name|void
name|solve_graph
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|)
block|{
name|unsigned
name|int
name|size
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|changed_count
operator|=
name|size
expr_stmt|;
name|changed
operator|=
name|sbitmap_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|changed
argument_list|)
expr_stmt|;
comment|/* The already collapsed/unreachable nodes will never change, so we      need to  account for them in changed_count.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|node
operator|!=
name|i
condition|)
name|changed_count
operator|--
expr_stmt|;
while|while
condition|(
name|changed_count
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|topo_info
modifier|*
name|ti
init|=
name|init_topo_info
argument_list|()
decl_stmt|;
name|stats
operator|.
name|iterations
operator|++
expr_stmt|;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|edge_added
condition|)
block|{
comment|/* We already did cycle elimination once, when we did 	     variable substitution, so we don't need it again for the 	     first iteration.  */
if|if
condition|(
name|stats
operator|.
name|iterations
operator|>
literal|1
condition|)
name|find_and_collapse_graph_cycles
argument_list|(
name|graph
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|edge_added
operator|=
name|false
expr_stmt|;
block|}
name|compute_topo_order
argument_list|(
name|graph
argument_list|,
name|ti
argument_list|)
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|unsigned
argument_list|,
name|ti
operator|->
name|topo_order
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|VEC_pop
argument_list|(
name|unsigned
argument_list|,
name|ti
operator|->
name|topo_order
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|node
operator|==
name|i
argument_list|)
expr_stmt|;
comment|/* If the node has changed, we need to process the 	     complex constraints and outgoing edges again.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
name|constraint_edge_t
name|e
init|=
name|NULL
decl_stmt|;
name|bitmap
name|solution
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
name|complex
operator|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|complex
expr_stmt|;
name|VEC
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|)
operator|*
name|succs
expr_stmt|;
name|bool
name|solution_empty
decl_stmt|;
name|RESET_BIT
argument_list|(
name|changed
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|changed_count
operator|--
expr_stmt|;
name|solution
operator|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|solution
expr_stmt|;
name|solution_empty
operator|=
name|bitmap_empty_p
argument_list|(
name|solution
argument_list|)
expr_stmt|;
comment|/* Process the complex constraints */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
name|complex
argument_list|,
name|j
argument_list|,
name|c
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
comment|/* The only complex constraint that can change our 		     solution to non-empty, given an empty solution, 		     is a constraint where the lhs side is receiving 		     some set from elsewhere.  */
if|if
condition|(
operator|!
name|solution_empty
operator|||
name|c
operator|->
name|lhs
operator|.
name|type
operator|!=
name|DEREF
condition|)
name|do_complex_constraint
argument_list|(
name|graph
argument_list|,
name|c
argument_list|,
name|solution
argument_list|)
expr_stmt|;
block|}
name|solution_empty
operator|=
name|bitmap_empty_p
argument_list|(
name|solution
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|solution_empty
condition|)
block|{
comment|/* Propagate solution to all successors.  */
name|succs
operator|=
name|graph
operator|->
name|succs
index|[
name|i
index|]
expr_stmt|;
name|EXECUTE_IF_IN_NONNULL_BITMAP
argument_list|(
argument|graph->zero_weight_succs[i]
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|bitmap
name|tmp
init|=
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|solution
decl_stmt|;
name|bool
name|flag
init|=
name|false
decl_stmt|;
name|flag
operator|=
name|set_union_with_increment
argument_list|(
name|tmp
argument_list|,
name|solution
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|solution
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_edge_t
argument_list|,
name|succs
argument_list|,
name|j
argument_list|,
name|e
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|bitmap
name|tmp
init|=
name|get_varinfo
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|solution
decl_stmt|;
name|bool
name|flag
init|=
name|false
decl_stmt|;
name|unsigned
name|int
name|k
decl_stmt|;
name|bitmap
name|weights
init|=
name|e
operator|->
name|weights
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|gcc_assert
argument_list|(
name|weights
operator|&&
operator|!
name|bitmap_empty_p
argument_list|(
name|weights
argument_list|)
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|weights
argument_list|,
literal|0
argument_list|,
argument|k
argument_list|,
argument|bi
argument_list|)
name|flag
operator||=
name|set_union_with_increment
argument_list|(
name|tmp
argument_list|,
name|solution
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|get_varinfo
argument_list|(
name|e
operator|->
name|dest
argument_list|)
operator|->
name|solution
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|e
operator|->
name|dest
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|e
operator|->
name|dest
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|free_topo_info
argument_list|(
name|ti
argument_list|)
expr_stmt|;
name|bitmap_obstack_release
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
expr_stmt|;
block|}
name|sbitmap_free
argument_list|(
name|changed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CONSTRAINT AND VARIABLE GENERATION FUNCTIONS */
end_comment

begin_comment
comment|/* Map from trees to variable ids.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|id_for_tree
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|tree_id
block|{
name|tree
name|t
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
block|}
typedef|*
name|tree_id_t
typedef|;
end_typedef

begin_comment
comment|/* Hash a tree id structure.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|tree_id_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|tree_id_t
name|ta
init|=
operator|(
name|tree_id_t
operator|)
name|p
decl_stmt|;
return|return
name|htab_hash_pointer
argument_list|(
name|ta
operator|->
name|t
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the tree in P1 and the tree in P2 are the same.  */
end_comment

begin_function
specifier|static
name|int
name|tree_id_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|tree_id_t
name|ta1
init|=
operator|(
name|tree_id_t
operator|)
name|p1
decl_stmt|;
specifier|const
name|tree_id_t
name|ta2
init|=
operator|(
name|tree_id_t
operator|)
name|p2
decl_stmt|;
return|return
name|ta1
operator|->
name|t
operator|==
name|ta2
operator|->
name|t
return|;
block|}
end_function

begin_comment
comment|/* Insert ID as the variable id for tree T in the hashtable.  */
end_comment

begin_function
specifier|static
name|void
name|insert_id_for_tree
parameter_list|(
name|tree
name|t
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|tree_id
name|finder
decl_stmt|;
name|tree_id_t
name|new_pair
decl_stmt|;
name|finder
operator|.
name|t
operator|=
name|t
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|id_for_tree
argument_list|,
operator|&
name|finder
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|slot
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|new_pair
operator|=
name|XNEW
argument_list|(
expr|struct
name|tree_id
argument_list|)
expr_stmt|;
name|new_pair
operator|->
name|t
operator|=
name|t
expr_stmt|;
name|new_pair
operator|->
name|id
operator|=
name|id
expr_stmt|;
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|new_pair
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the variable id for tree T in ID_FOR_TREE.  If T does not    exist in the hash table, return false, otherwise, return true and    set *ID to the id we found.  */
end_comment

begin_function
specifier|static
name|bool
name|lookup_id_for_tree
parameter_list|(
name|tree
name|t
parameter_list|,
name|unsigned
name|int
modifier|*
name|id
parameter_list|)
block|{
name|tree_id_t
name|pair
decl_stmt|;
name|struct
name|tree_id
name|finder
decl_stmt|;
name|finder
operator|.
name|t
operator|=
name|t
expr_stmt|;
name|pair
operator|=
name|htab_find
argument_list|(
name|id_for_tree
argument_list|,
operator|&
name|finder
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|==
name|NULL
condition|)
return|return
name|false
return|;
operator|*
name|id
operator|=
name|pair
operator|->
name|id
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Return a printable name for DECL  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|alias_get_name
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|res
init|=
name|get_name
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|num_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
return|return
name|res
return|;
name|res
operator|=
literal|"NULL"
expr_stmt|;
if|if
condition|(
operator|!
name|dump_file
condition|)
return|return
name|res
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|num_printed
operator|=
name|asprintf
argument_list|(
operator|&
name|temp
argument_list|,
literal|"%s_%u"
argument_list|,
name|alias_get_name
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|num_printed
operator|=
name|asprintf
argument_list|(
operator|&
name|temp
argument_list|,
literal|"D.%u"
argument_list|,
name|DECL_UID
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_printed
operator|>
literal|0
condition|)
block|{
name|res
operator|=
name|ggc_strdup
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Find the variable id for tree T in the hashtable.    If T doesn't exist in the hash table, create an entry for it.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get_id_for_tree
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree_id_t
name|pair
decl_stmt|;
name|struct
name|tree_id
name|finder
decl_stmt|;
name|finder
operator|.
name|t
operator|=
name|t
expr_stmt|;
name|pair
operator|=
name|htab_find
argument_list|(
name|id_for_tree
argument_list|,
operator|&
name|finder
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|==
name|NULL
condition|)
return|return
name|create_variable_info_for
argument_list|(
name|t
argument_list|,
name|alias_get_name
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
return|return
name|pair
operator|->
name|id
return|;
block|}
end_function

begin_comment
comment|/* Get a constraint expression from an SSA_VAR_P node.  */
end_comment

begin_function
specifier|static
name|struct
name|constraint_expr
name|get_constraint_exp_from_ssa_var
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|struct
name|constraint_expr
name|cexpr
decl_stmt|;
name|gcc_assert
argument_list|(
name|SSA_VAR_P
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For parameters, get at the points-to set for the actual parm      decl.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|default_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|t
condition|)
return|return
name|get_constraint_exp_from_ssa_var
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
name|cexpr
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|cexpr
operator|.
name|var
operator|=
name|get_id_for_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* If we determine the result is "anything", and we know this is readonly,      say it points to readonly memory instead.  */
if|if
condition|(
name|cexpr
operator|.
name|var
operator|==
name|anything_id
operator|&&
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cexpr
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|cexpr
operator|.
name|var
operator|=
name|readonly_id
expr_stmt|;
block|}
name|cexpr
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|cexpr
return|;
block|}
end_function

begin_comment
comment|/* Process a completed constraint T, and add it to the constraint    list.  */
end_comment

begin_function
specifier|static
name|void
name|process_constraint
parameter_list|(
name|constraint_t
name|t
parameter_list|)
block|{
name|struct
name|constraint_expr
name|rhs
init|=
name|t
operator|->
name|rhs
decl_stmt|;
name|struct
name|constraint_expr
name|lhs
init|=
name|t
operator|->
name|lhs
decl_stmt|;
name|gcc_assert
argument_list|(
name|rhs
operator|.
name|var
operator|<
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|lhs
operator|.
name|var
operator|<
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|directly_dereferenced
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|directly_dereferenced
operator|=
name|true
expr_stmt|;
comment|/* ANYTHING == ANYTHING is pointless.  */
if|if
condition|(
name|lhs
operator|.
name|var
operator|==
name|anything_id
operator|&&
name|rhs
operator|.
name|var
operator|==
name|anything_id
condition|)
return|return;
comment|/* If we have&ANYTHING = something, convert to SOMETHING =&ANYTHING) */
elseif|else
if|if
condition|(
name|lhs
operator|.
name|var
operator|==
name|anything_id
operator|&&
name|lhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
block|{
name|rhs
operator|=
name|t
operator|->
name|lhs
expr_stmt|;
name|t
operator|->
name|lhs
operator|=
name|t
operator|->
name|rhs
expr_stmt|;
name|t
operator|->
name|rhs
operator|=
name|rhs
expr_stmt|;
name|process_constraint
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* This can happen in our IR with things like n->a = *p */
elseif|else
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|lhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|rhs
operator|.
name|var
operator|!=
name|anything_id
condition|)
block|{
comment|/* Split into tmp = *rhs, *lhs = tmp */
name|tree
name|rhsdecl
init|=
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|decl
decl_stmt|;
name|tree
name|pointertype
init|=
name|TREE_TYPE
argument_list|(
name|rhsdecl
argument_list|)
decl_stmt|;
name|tree
name|pointedtotype
init|=
name|TREE_TYPE
argument_list|(
name|pointertype
argument_list|)
decl_stmt|;
name|tree
name|tmpvar
init|=
name|create_tmp_var_raw
argument_list|(
name|pointedtotype
argument_list|,
literal|"doubledereftmp"
argument_list|)
decl_stmt|;
name|struct
name|constraint_expr
name|tmplhs
init|=
name|get_constraint_exp_from_ssa_var
argument_list|(
name|tmpvar
argument_list|)
decl_stmt|;
comment|/* If this is an aggregate of known size, we should have passed 	 this off to do_structure_copy, and it should have broken it 	 up.  */
name|gcc_assert
argument_list|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|pointedtotype
argument_list|)
operator|||
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|is_unknown_size_var
argument_list|)
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|tmplhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|tmplhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
block|{
name|varinfo_t
name|vi
decl_stmt|;
name|gcc_assert
argument_list|(
name|rhs
operator|.
name|offset
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* No need to mark address taken simply because of escaped vars 	 constraints.  */
if|if
condition|(
name|lhs
operator|.
name|var
operator|!=
name|escaped_vars_id
condition|)
for|for
control|(
name|vi
operator|=
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
init|;
name|vi
operator|!=
name|NULL
condition|;
name|vi
operator|=
name|vi
operator|->
name|next
control|)
name|vi
operator|->
name|address_taken
operator|=
name|true
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|constraints
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lhs
operator|.
name|type
operator|!=
name|DEREF
operator|&&
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|indirect_target
operator|=
name|true
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|constraints
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if T is a variable of a type that could contain    pointers.  */
end_comment

begin_function
specifier|static
name|bool
name|could_have_pointers
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the position, in bits, of FIELD_DECL from the beginning of its    structure.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|bitpos_of_field
parameter_list|(
specifier|const
name|tree
name|fdecl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|fdecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|fdecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|fdecl
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
literal|8
operator|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|fdecl
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if an access to [ACCESSPOS, ACCESSSIZE]    overlaps with a field at [FIELDPOS, FIELDSIZE] */
end_comment

begin_function
specifier|static
name|bool
name|offset_overlaps_with_access
parameter_list|(
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|fieldpos
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|fieldsize
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|accesspos
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|accesssize
parameter_list|)
block|{
if|if
condition|(
name|fieldpos
operator|==
name|accesspos
operator|&&
name|fieldsize
operator|==
name|accesssize
condition|)
return|return
name|true
return|;
if|if
condition|(
name|accesspos
operator|>=
name|fieldpos
operator|&&
name|accesspos
operator|<
operator|(
name|fieldpos
operator|+
name|fieldsize
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|accesspos
operator|<
name|fieldpos
operator|&&
operator|(
name|accesspos
operator|+
name|accesssize
operator|>
name|fieldpos
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Given a COMPONENT_REF T, return the constraint_expr for it.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|get_constraint_for_component_ref
argument_list|(
name|tree
name|t
argument_list|,
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|results
argument_list|)
block|{
name|tree
name|orig_t
init|=
name|t
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
init|=
operator|-
literal|1
decl_stmt|;
name|HOST_WIDE_INT
name|bitmaxsize
init|=
operator|-
literal|1
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|tree
name|forzero
decl_stmt|;
name|struct
name|constraint_expr
modifier|*
name|result
decl_stmt|;
name|unsigned
name|int
name|beforelength
init|=
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
decl_stmt|;
comment|/* Some people like to do cute things like take the address of&0->a.b */
name|forzero
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|!
name|SSA_VAR_P
argument_list|(
name|forzero
argument_list|)
operator|&&
operator|!
name|CONSTANT_CLASS_P
argument_list|(
name|forzero
argument_list|)
condition|)
name|forzero
operator|=
name|TREE_OPERAND
argument_list|(
name|forzero
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|forzero
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|forzero
argument_list|)
condition|)
block|{
name|struct
name|constraint_expr
name|temp
decl_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|integer_id
expr_stmt|;
name|temp
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|get_ref_base_and_extent
argument_list|(
name|t
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitmaxsize
argument_list|)
expr_stmt|;
comment|/* String constants's are readonly, so there is nothing to really do      here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return;
name|get_constraint_for
argument_list|(
name|t
argument_list|,
name|results
argument_list|)
expr_stmt|;
name|result
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
expr_stmt|;
name|result
operator|->
name|offset
operator|=
name|bitpos
expr_stmt|;
name|gcc_assert
argument_list|(
name|beforelength
operator|+
literal|1
operator|==
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This can also happen due to weird offsetof type macros.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ADDR_EXPR
operator|&&
name|result
operator|->
name|type
operator|==
name|ADDRESSOF
condition|)
name|result
operator|->
name|type
operator|=
name|SCALAR
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|type
operator|==
name|SCALAR
condition|)
block|{
comment|/* In languages like C, you can access one past the end of an 	 array.  You aren't allowed to dereference it, so we can 	 ignore this constraint. When we handle pointer subtraction, 	 we may have to do something cute here.  */
if|if
condition|(
name|result
operator|->
name|offset
operator|<
name|get_varinfo
argument_list|(
name|result
operator|->
name|var
argument_list|)
operator|->
name|fullsize
operator|&&
name|bitmaxsize
operator|!=
literal|0
condition|)
block|{
comment|/* It's also not true that the constraint will actually start at the 	     right offset, it may start in some padding.  We only care about 	     setting the constraint to the first actual field it touches, so 	     walk to find it.  */
name|varinfo_t
name|curr
decl_stmt|;
for|for
control|(
name|curr
operator|=
name|get_varinfo
argument_list|(
name|result
operator|->
name|var
argument_list|)
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|offset_overlaps_with_access
argument_list|(
name|curr
operator|->
name|offset
argument_list|,
name|curr
operator|->
name|size
argument_list|,
name|result
operator|->
name|offset
argument_list|,
name|bitmaxsize
argument_list|)
condition|)
block|{
name|result
operator|->
name|var
operator|=
name|curr
operator|->
name|id
expr_stmt|;
break|break;
block|}
block|}
comment|/* assert that we found *some* field there. The user couldn't be 	     accessing *only* padding.  */
comment|/* Still the user could access one past the end of an array 	     embedded in a struct resulting in accessing *only* padding.  */
name|gcc_assert
argument_list|(
name|curr
operator|||
name|ref_contains_array_ref
argument_list|(
name|orig_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitmaxsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Access to zero-sized part of variable,"
literal|"ignoring\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Access to past the end of variable, ignoring\n"
argument_list|)
expr_stmt|;
name|result
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Dereference the constraint expression CONS, and return the result.    DEREF (ADDRESSOF) = SCALAR    DEREF (SCALAR) = DEREF    DEREF (DEREF) = (temp = DEREF1; result = DEREF(temp))    This is needed so that we can handle dereferencing DEREF constraints.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_deref
argument_list|(
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|constraints
argument_list|)
block|{
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
operator|*
name|constraints
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SCALAR
condition|)
name|c
operator|->
name|type
operator|=
name|DEREF
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|ADDRESSOF
condition|)
name|c
operator|->
name|type
operator|=
name|SCALAR
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|DEREF
condition|)
block|{
name|tree
name|tmpvar
init|=
name|create_tmp_var_raw
argument_list|(
name|ptr_type_node
argument_list|,
literal|"dereftmp"
argument_list|)
decl_stmt|;
name|struct
name|constraint_expr
name|tmplhs
init|=
name|get_constraint_exp_from_ssa_var
argument_list|(
name|tmpvar
argument_list|)
decl_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|tmplhs
argument_list|,
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|var
operator|=
name|tmplhs
operator|.
name|var
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Create a nonlocal variable of TYPE to represent nonlocals we can    alias.  */
end_comment

begin_function
specifier|static
name|tree
name|create_nonlocal_var
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|nonlocal
init|=
name|create_tmp_var_raw
argument_list|(
name|type
argument_list|,
literal|"NONLOCAL"
argument_list|)
decl_stmt|;
if|if
condition|(
name|referenced_vars
condition|)
name|add_referenced_var
argument_list|(
name|nonlocal
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|nonlocal
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|nonlocal
return|;
block|}
end_function

begin_comment
comment|/* Given a tree T, return the constraint expression for it.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|get_constraint_for
argument_list|(
name|tree
name|t
argument_list|,
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|results
argument_list|)
block|{
name|struct
name|constraint_expr
name|temp
decl_stmt|;
comment|/* x = integer is all glommed to a single variable, which doesn't      point to anything by itself.  That is, of course, unless it is an      integer constant being treated as a pointer, in which case, we      will return that this is really the addressof anything.  This      happens below, since it will fall into the default case. The only      case we know something about an integer treated like a pointer is      when it is the NULL pointer, and then we just say it points to      NULL.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|temp
operator|.
name|var
operator|=
name|integer_id
expr_stmt|;
name|temp
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|temp
operator|.
name|var
operator|=
name|nothing_id
expr_stmt|;
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_expression
case|:
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
block|{
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|tree
name|exp
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|pttype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|get_constraint_for
argument_list|(
name|exp
argument_list|,
name|results
argument_list|)
expr_stmt|;
comment|/* Make sure we capture constraints to all elements 		 of an array.  */
if|if
condition|(
operator|(
name|handled_component_p
argument_list|(
name|exp
argument_list|)
operator|&&
name|ref_contains_array_ref
argument_list|(
name|exp
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|struct
name|constraint_expr
modifier|*
name|origrhs
decl_stmt|;
name|varinfo_t
name|origvar
decl_stmt|;
name|struct
name|constraint_expr
name|tmp
decl_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|origrhs
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|*
name|origrhs
expr_stmt|;
name|VEC_pop
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
expr_stmt|;
name|origvar
operator|=
name|get_varinfo
argument_list|(
name|origrhs
operator|->
name|var
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|origvar
condition|;
name|origvar
operator|=
name|origvar
operator|->
name|next
control|)
block|{
name|tmp
operator|.
name|var
operator|=
name|origvar
operator|->
name|id
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|AGGREGATE_TYPE_P
argument_list|(
name|pttype
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|pttype
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|struct
name|constraint_expr
modifier|*
name|origrhs
decl_stmt|;
name|varinfo_t
name|origvar
decl_stmt|;
name|struct
name|constraint_expr
name|tmp
decl_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|origrhs
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|*
name|origrhs
expr_stmt|;
name|VEC_pop
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
expr_stmt|;
name|origvar
operator|=
name|get_varinfo
argument_list|(
name|origrhs
operator|->
name|var
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|origvar
condition|;
name|origvar
operator|=
name|origvar
operator|->
name|next
control|)
block|{
name|tmp
operator|.
name|var
operator|=
name|origvar
operator|->
name|id
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|DEREF
condition|)
name|c
operator|->
name|type
operator|=
name|SCALAR
expr_stmt|;
else|else
name|c
operator|->
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
block|}
return|return;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* XXX: In interprocedural mode, if we didn't have the 	       body, we would need to do *each pointer argument =&ANYTHING added.  */
if|if
condition|(
name|call_expr_flags
argument_list|(
name|t
argument_list|)
operator|&
operator|(
name|ECF_MALLOC
operator||
name|ECF_MAY_BE_ALLOCA
operator|)
condition|)
block|{
name|varinfo_t
name|vi
decl_stmt|;
name|tree
name|heapvar
init|=
name|heapvar_lookup
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|heapvar
operator|==
name|NULL
condition|)
block|{
name|heapvar
operator|=
name|create_tmp_var_raw
argument_list|(
name|ptr_type_node
argument_list|,
literal|"HEAP"
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|heapvar
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|referenced_vars
condition|)
name|add_referenced_var
argument_list|(
name|heapvar
argument_list|)
expr_stmt|;
name|heapvar_insert
argument_list|(
name|t
argument_list|,
name|heapvar
argument_list|)
expr_stmt|;
block|}
name|temp
operator|.
name|var
operator|=
name|create_variable_info_for
argument_list|(
name|heapvar
argument_list|,
name|alias_get_name
argument_list|(
name|heapvar
argument_list|)
argument_list|)
expr_stmt|;
name|vi
operator|=
name|get_varinfo
argument_list|(
name|temp
operator|.
name|var
argument_list|)
expr_stmt|;
name|vi
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|vi
operator|->
name|is_heap_var
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|temp
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|temp
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
block|{
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
case|case
name|tcc_reference
case|:
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
block|{
name|get_constraint_for
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|results
argument_list|)
expr_stmt|;
name|do_deref
argument_list|(
name|results
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|COMPONENT_REF
case|:
name|get_constraint_for_component_ref
argument_list|(
name|t
argument_list|,
name|results
argument_list|)
expr_stmt|;
return|return;
default|default:
block|{
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
case|case
name|tcc_unary
case|:
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Cast from non-pointer to pointers are bad news for us. 		 Anything else, we see through */
if|if
condition|(
operator|!
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|get_constraint_for
argument_list|(
name|op
argument_list|,
name|results
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHRU  */
block|}
default|default:
block|{
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
case|case
name|tcc_exceptional
case|:
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|PHI_NODE
case|:
block|{
name|get_constraint_for
argument_list|(
name|PHI_RESULT
argument_list|(
name|t
argument_list|)
argument_list|,
name|results
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SSA_NAME
case|:
block|{
name|struct
name|constraint_expr
name|temp
decl_stmt|;
name|temp
operator|=
name|get_constraint_exp_from_ssa_var
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
block|{
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
case|case
name|tcc_declaration
case|:
block|{
name|struct
name|constraint_expr
name|temp
decl_stmt|;
name|temp
operator|=
name|get_constraint_exp_from_ssa_var
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
block|{
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Handle the structure copy case where we have a simple structure copy    between LHS and RHS that is of SIZE (in bits)        For each field of the lhs variable (lhsfield)      For each field of the rhs variable at lhsfield.offset (rhsfield)        add the constraint lhsfield = rhsfield     If we fail due to some kind of type unsafety or other thing we    can't handle, return false.  We expect the caller to collapse the    variable in that case.  */
end_comment

begin_function
specifier|static
name|bool
name|do_simple_structure_copy
parameter_list|(
specifier|const
name|struct
name|constraint_expr
name|lhs
parameter_list|,
specifier|const
name|struct
name|constraint_expr
name|rhs
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|varinfo_t
name|p
init|=
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|pstart
decl_stmt|,
name|last
decl_stmt|;
name|pstart
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|last
operator|=
name|p
operator|->
name|offset
operator|+
name|size
expr_stmt|;
for|for
control|(
init|;
name|p
operator|&&
name|p
operator|->
name|offset
operator|<
name|last
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|varinfo_t
name|q
decl_stmt|;
name|struct
name|constraint_expr
name|templhs
init|=
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|temprhs
init|=
name|rhs
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
decl_stmt|;
name|templhs
operator|.
name|var
operator|=
name|p
operator|->
name|id
expr_stmt|;
name|q
operator|=
name|get_varinfo
argument_list|(
name|temprhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|fieldoffset
operator|=
name|p
operator|->
name|offset
operator|-
name|pstart
expr_stmt|;
name|q
operator|=
name|first_vi_for_offset
argument_list|(
name|q
argument_list|,
name|q
operator|->
name|offset
operator|+
name|fieldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
return|return
name|false
return|;
name|temprhs
operator|.
name|var
operator|=
name|q
operator|->
name|id
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|templhs
argument_list|,
name|temprhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle the structure copy case where we have a  structure copy between a    aggregate on the LHS and a dereference of a pointer on the RHS    that is of SIZE (in bits)        For each field of the lhs variable (lhsfield)        rhs.offset = lhsfield->offset        add the constraint lhsfield = rhs */
end_comment

begin_function
specifier|static
name|void
name|do_rhs_deref_structure_copy
parameter_list|(
specifier|const
name|struct
name|constraint_expr
name|lhs
parameter_list|,
specifier|const
name|struct
name|constraint_expr
name|rhs
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|varinfo_t
name|p
init|=
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|pstart
decl_stmt|,
name|last
decl_stmt|;
name|pstart
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|last
operator|=
name|p
operator|->
name|offset
operator|+
name|size
expr_stmt|;
for|for
control|(
init|;
name|p
operator|&&
name|p
operator|->
name|offset
operator|<
name|last
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|varinfo_t
name|q
decl_stmt|;
name|struct
name|constraint_expr
name|templhs
init|=
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|temprhs
init|=
name|rhs
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
decl_stmt|;
if|if
condition|(
name|templhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
name|templhs
operator|.
name|var
operator|=
name|p
operator|->
name|id
expr_stmt|;
else|else
name|templhs
operator|.
name|offset
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|q
operator|=
name|get_varinfo
argument_list|(
name|temprhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|fieldoffset
operator|=
name|p
operator|->
name|offset
operator|-
name|pstart
expr_stmt|;
name|temprhs
operator|.
name|offset
operator|+=
name|fieldoffset
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|templhs
argument_list|,
name|temprhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the structure copy case where we have a structure copy    between a aggregate on the RHS and a dereference of a pointer on    the LHS that is of SIZE (in bits)      For each field of the rhs variable (rhsfield)        lhs.offset = rhsfield->offset        add the constraint lhs = rhsfield */
end_comment

begin_function
specifier|static
name|void
name|do_lhs_deref_structure_copy
parameter_list|(
specifier|const
name|struct
name|constraint_expr
name|lhs
parameter_list|,
specifier|const
name|struct
name|constraint_expr
name|rhs
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|varinfo_t
name|p
init|=
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|pstart
decl_stmt|,
name|last
decl_stmt|;
name|pstart
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|last
operator|=
name|p
operator|->
name|offset
operator|+
name|size
expr_stmt|;
for|for
control|(
init|;
name|p
operator|&&
name|p
operator|->
name|offset
operator|<
name|last
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|varinfo_t
name|q
decl_stmt|;
name|struct
name|constraint_expr
name|templhs
init|=
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|temprhs
init|=
name|rhs
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
decl_stmt|;
if|if
condition|(
name|temprhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
name|temprhs
operator|.
name|var
operator|=
name|p
operator|->
name|id
expr_stmt|;
else|else
name|temprhs
operator|.
name|offset
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|q
operator|=
name|get_varinfo
argument_list|(
name|templhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|fieldoffset
operator|=
name|p
operator|->
name|offset
operator|-
name|pstart
expr_stmt|;
name|templhs
operator|.
name|offset
operator|+=
name|fieldoffset
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|templhs
argument_list|,
name|temprhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sometimes, frontends like to give us bad type information.  This    function will collapse all the fields from VAR to the end of VAR,    into VAR, so that we treat those fields as a single variable.     We return the variable they were collapsed into.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|collapse_rest_of_var
parameter_list|(
name|unsigned
name|int
name|var
parameter_list|)
block|{
name|varinfo_t
name|currvar
init|=
name|get_varinfo
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|varinfo_t
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|currvar
operator|->
name|next
init|;
name|field
condition|;
name|field
operator|=
name|field
operator|->
name|next
control|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Type safety: Collapsing var %s into %s\n"
argument_list|,
name|field
operator|->
name|name
argument_list|,
name|currvar
operator|->
name|name
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|field
operator|->
name|collapsed_to
argument_list|)
expr_stmt|;
name|field
operator|->
name|collapsed_to
operator|=
name|currvar
expr_stmt|;
block|}
name|currvar
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|currvar
operator|->
name|size
operator|=
name|currvar
operator|->
name|fullsize
operator|-
name|currvar
operator|->
name|offset
expr_stmt|;
return|return
name|currvar
operator|->
name|id
return|;
block|}
end_function

begin_comment
comment|/* Handle aggregate copies by expanding into copies of the respective    fields of the structures.  */
end_comment

begin_function
specifier|static
name|void
name|do_structure_copy
parameter_list|(
name|tree
name|lhsop
parameter_list|,
name|tree
name|rhsop
parameter_list|)
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|,
name|rhs
decl_stmt|,
name|tmp
decl_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|lhsc
operator|=
name|NULL
operator|,
operator|*
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|varinfo_t
name|p
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lhssize
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|rhssize
decl_stmt|;
name|get_constraint_for
argument_list|(
name|lhsop
argument_list|,
operator|&
name|lhsc
argument_list|)
expr_stmt|;
name|get_constraint_for
argument_list|(
name|rhsop
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|lhs
operator|=
operator|*
operator|(
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|)
operator|)
expr_stmt|;
name|rhs
operator|=
operator|*
operator|(
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|lhsc
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
comment|/* If we have special var = x, swap it around.  */
if|if
condition|(
name|lhs
operator|.
name|var
operator|<=
name|integer_id
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
block|{
name|tmp
operator|=
name|lhs
expr_stmt|;
name|lhs
operator|=
name|rhs
expr_stmt|;
name|rhs
operator|=
name|tmp
expr_stmt|;
block|}
comment|/*  This is fairly conservative for the RHS == ADDRESSOF case, in that it's       possible it's something we could handle.  However, most cases falling       into this are dealing with transparent unions, which are slightly       weird. */
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
block|{
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
block|}
comment|/* If the RHS is a special var, or an addressof, set all the LHS fields to      that special var.  */
if|if
condition|(
name|rhs
operator|.
name|var
operator|<=
name|integer_id
condition|)
block|{
for|for
control|(
name|p
operator|=
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|constraint_expr
name|templhs
init|=
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|temprhs
init|=
name|rhs
decl_stmt|;
if|if
condition|(
name|templhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
name|templhs
operator|.
name|var
operator|=
name|p
operator|->
name|id
expr_stmt|;
else|else
name|templhs
operator|.
name|offset
operator|+=
name|p
operator|->
name|offset
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|templhs
argument_list|,
name|temprhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|rhstype
init|=
name|TREE_TYPE
argument_list|(
name|rhsop
argument_list|)
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhsop
argument_list|)
decl_stmt|;
name|tree
name|rhstypesize
decl_stmt|;
name|tree
name|lhstypesize
decl_stmt|;
name|lhstypesize
operator|=
name|DECL_P
argument_list|(
name|lhsop
argument_list|)
condition|?
name|DECL_SIZE
argument_list|(
name|lhsop
argument_list|)
else|:
name|TYPE_SIZE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
name|rhstypesize
operator|=
name|DECL_P
argument_list|(
name|rhsop
argument_list|)
condition|?
name|DECL_SIZE
argument_list|(
name|rhsop
argument_list|)
else|:
name|TYPE_SIZE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
comment|/* If we have a variably sized types on the rhs or lhs, and a deref 	 constraint, add the constraint, lhsconstraint =&ANYTHING. 	 This is conservatively correct because either the lhs is an unknown 	 sized var (if the constraint is SCALAR), or the lhs is a DEREF 	 constraint, and every variable it can point to must be unknown sized 	 anyway, so we don't need to worry about fields at all.  */
if|if
condition|(
operator|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|TREE_CODE
argument_list|(
name|rhstypesize
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|||
operator|(
name|lhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|TREE_CODE
argument_list|(
name|lhstypesize
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
block|{
name|rhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The size only really matters insofar as we don't set more or less of 	 the variable.  If we hit an unknown size var, the size should be the 	 whole darn thing.  */
if|if
condition|(
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|is_unknown_size_var
condition|)
name|rhssize
operator|=
operator|~
literal|0
expr_stmt|;
else|else
name|rhssize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|rhstypesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|is_unknown_size_var
condition|)
name|lhssize
operator|=
operator|~
literal|0
expr_stmt|;
else|else
name|lhssize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|lhstypesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|SCALAR
operator|&&
name|lhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
block|{
if|if
condition|(
operator|!
name|do_simple_structure_copy
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|MIN
argument_list|(
name|lhssize
argument_list|,
name|rhssize
argument_list|)
argument_list|)
condition|)
block|{
name|lhs
operator|.
name|var
operator|=
name|collapse_rest_of_var
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|collapse_rest_of_var
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lhs
operator|.
name|type
operator|!=
name|DEREF
operator|&&
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|do_rhs_deref_structure_copy
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|MIN
argument_list|(
name|lhssize
argument_list|,
name|rhssize
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|rhs
operator|.
name|type
operator|!=
name|DEREF
condition|)
name|do_lhs_deref_structure_copy
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|MIN
argument_list|(
name|lhssize
argument_list|,
name|rhssize
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|pointedtotype
init|=
name|lhstype
decl_stmt|;
name|tree
name|tmpvar
decl_stmt|;
name|gcc_assert
argument_list|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|lhs
operator|.
name|type
operator|==
name|DEREF
argument_list|)
expr_stmt|;
name|tmpvar
operator|=
name|create_tmp_var_raw
argument_list|(
name|pointedtotype
argument_list|,
literal|"structcopydereftmp"
argument_list|)
expr_stmt|;
name|do_structure_copy
argument_list|(
name|tmpvar
argument_list|,
name|rhsop
argument_list|)
expr_stmt|;
name|do_structure_copy
argument_list|(
name|lhsop
argument_list|,
name|tmpvar
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Update related alias information kept in AI.  This is used when    building name tags, alias sets and deciding grouping heuristics.    STMT is the statement to process.  This function also updates    ADDRESSABLE_VARS.  */
end_comment

begin_function
specifier|static
name|void
name|update_alias_info
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|bitmap
name|addr_taken
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|enum
name|escape_type
name|stmt_escape_type
init|=
name|is_escape_site
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|op
decl_stmt|;
if|if
condition|(
name|stmt_escape_type
operator|==
name|ESCAPE_TO_CALL
operator|||
name|stmt_escape_type
operator|==
name|ESCAPE_TO_PURE_CONST
condition|)
block|{
name|ai
operator|->
name|num_calls_found
operator|++
expr_stmt|;
if|if
condition|(
name|stmt_escape_type
operator|==
name|ESCAPE_TO_PURE_CONST
condition|)
name|ai
operator|->
name|num_pure_const_calls_found
operator|++
expr_stmt|;
block|}
comment|/* Mark all the variables whose address are taken by the statement.  */
name|addr_taken
operator|=
name|addresses_taken
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_taken
condition|)
block|{
name|bitmap_ior_into
argument_list|(
name|addressable_vars
argument_list|,
name|addr_taken
argument_list|)
expr_stmt|;
comment|/* If STMT is an escape point, all the addresses taken by it are 	 call-clobbered.  */
if|if
condition|(
name|stmt_escape_type
operator|!=
name|NO_ESCAPE
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|addr_taken
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|rvar
init|=
name|referenced_var
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|unmodifiable_var_p
argument_list|(
name|rvar
argument_list|)
condition|)
name|mark_call_clobbered
argument_list|(
name|rvar
argument_list|,
name|stmt_escape_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Process each operand use.  If an operand may be aliased, keep      track of how many times it's being used.  For pointers, determine      whether they are dereferenced by the statement, or whether their      value escapes, etc.  */
name|FOR_EACH_PHI_OR_STMT_USE
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|tree
name|op
decl_stmt|,
name|var
decl_stmt|;
name|var_ann_t
name|v_ann
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
decl_stmt|;
name|bool
name|is_store
decl_stmt|,
name|is_potential_deref
decl_stmt|;
name|unsigned
name|num_uses
decl_stmt|,
name|num_derefs
decl_stmt|;
name|op
operator|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
comment|/* If STMT is a PHI node, OP may be an ADDR_EXPR.  If so, add it 	 to the set of addressable variables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
argument_list|)
expr_stmt|;
comment|/* PHI nodes don't have annotations for pinning the set 	     of addresses taken, so we collect them here.  	     FIXME, should we allow PHI nodes to have annotations 	     so that they can be treated like regular statements? 	     Currently, they are treated as second-class 	     statements.  */
name|add_to_addressable_set
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addressable_vars
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ignore constants.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SSA_NAME
condition|)
continue|continue;
name|var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|v_ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* The base variable of an ssa name must be a GIMPLE register, and thus 	 it cannot be aliased.  */
name|gcc_assert
argument_list|(
operator|!
name|may_be_aliased
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are only interested in pointers.  */
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
continue|continue;
name|pi
operator|=
name|get_ptr_info
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Add OP to AI->PROCESSED_PTRS, if it's not there already.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|ai
operator|->
name|ssa_names_visited
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|ai
operator|->
name|ssa_names_visited
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|ai
operator|->
name|processed_ptrs
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* If STMT is a PHI node, then it will not have pointer 	 dereferences and it will not be an escape point.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
continue|continue;
comment|/* Determine whether OP is a dereferenced pointer, and if STMT 	 is an escape point, whether OP escapes.  */
name|count_uses_and_derefs
argument_list|(
name|op
argument_list|,
name|stmt
argument_list|,
operator|&
name|num_uses
argument_list|,
operator|&
name|num_derefs
argument_list|,
operator|&
name|is_store
argument_list|)
expr_stmt|;
comment|/* Handle a corner case involving address expressions of the 	 form '&PTR->FLD'.  The problem with these expressions is that 	 they do not represent a dereference of PTR.  However, if some 	 other transformation propagates them into an INDIRECT_REF 	 expression, we end up with '*(&PTR->FLD)' which is folded 	 into 'PTR->FLD'.  	 So, if the original code had no other dereferences of PTR, 	 the aliaser will not create memory tags for it, and when&PTR->FLD gets propagated to INDIRECT_REF expressions, the 	 memory operations will receive no V_MAY_DEF/VUSE operands.  	 One solution would be to have count_uses_and_derefs consider&PTR->FLD a dereference of PTR.  But that is wrong, since it 	 is not really a dereference but an offset calculation.  	 What we do here is to recognize these special ADDR_EXPR 	 nodes.  Since these expressions are never GIMPLE values (they 	 are not GIMPLE invariants), they can only appear on the RHS 	 of an assignment and their base address is always an 	 INDIRECT_REF expression.  */
name|is_potential_deref
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|!
name|is_gimple_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If the RHS if of the form&PTR->FLD and PTR == OP, then 	     this represents a potential dereference of PTR.  */
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|base
init|=
name|get_base_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|==
name|op
condition|)
name|is_potential_deref
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|num_derefs
operator|>
literal|0
operator|||
name|is_potential_deref
condition|)
block|{
comment|/* Mark OP as dereferenced.  In a subsequent pass, 	     dereferenced pointers that point to a set of 	     variables will be assigned a name tag to alias 	     all the variables OP points to.  */
name|pi
operator|->
name|is_dereferenced
operator|=
literal|1
expr_stmt|;
comment|/* Keep track of how many time we've dereferenced each 	     pointer.  */
name|NUM_REFERENCES_INC
argument_list|(
name|v_ann
argument_list|)
expr_stmt|;
comment|/* If this is a store operation, mark OP as being 	     dereferenced to store, otherwise mark it as being 	     dereferenced to load.  */
if|if
condition|(
name|is_store
condition|)
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_store
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_load
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stmt_escape_type
operator|!=
name|NO_ESCAPE
operator|&&
name|num_derefs
operator|<
name|num_uses
condition|)
block|{
comment|/* If STMT is an escape point and STMT contains at 	     least one direct use of OP, then the value of OP 	     escapes and so the pointed-to variables need to 	     be marked call-clobbered.  */
name|pi
operator|->
name|value_escapes_p
operator|=
literal|1
expr_stmt|;
name|pi
operator|->
name|escape_mask
operator||=
name|stmt_escape_type
expr_stmt|;
comment|/* If the statement makes a function call, assume 	     that pointer OP will be dereferenced in a store 	     operation inside the called function.  */
if|if
condition|(
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
operator|||
name|stmt_escape_type
operator|==
name|ESCAPE_STORED_IN_GLOBAL
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_store
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|is_dereferenced
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
return|return;
comment|/* Update reference counter for definitions to any      potentially aliased variable.  This is used in the alias      grouping heuristics.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
block|{
name|tree
name|var
init|=
name|SSA_NAME_VAR
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|written_vars
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_be_aliased
argument_list|(
name|var
argument_list|)
condition|)
name|NUM_REFERENCES_INC
argument_list|(
name|ann
argument_list|)
expr_stmt|;
block|}
comment|/* Mark variables in V_MAY_DEF operands as being written to.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_DEFS
argument_list|)
block|{
name|tree
name|var
init|=
name|DECL_P
argument_list|(
name|op
argument_list|)
condition|?
name|op
else|:
name|SSA_NAME_VAR
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|written_vars
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle pointer arithmetic EXPR when creating aliasing constraints.    Expressions of the type PTR + CST can be handled in two ways:     1- If the constraint for PTR is ADDRESSOF for a non-structure       variable, then we can use it directly because adding or       subtracting a constant may not alter the original ADDRESSOF       constraint (i.e., pointer arithmetic may not legally go outside       an object's boundaries).     2- If the constraint for PTR is ADDRESSOF for a structure variable,       then if CST is a compile-time constant that can be used as an       offset, we can determine which sub-variable will be pointed-to       by the expression.     Return true if the expression is handled.  For any other kind of    expression, return false so that each operand can be added as a    separate constraint by the caller.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|handle_ptr_arith
argument_list|(
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|lhsc
argument_list|,
name|tree
name|expr
argument_list|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|j
init|=
literal|0
decl_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|temp
operator|=
name|NULL
expr_stmt|;
name|unsigned
name|int
name|rhsoffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|MINUS_EXPR
condition|)
return|return
name|false
return|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_constraint_for
argument_list|(
name|op0
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|rhsoffset
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
block|}
else|else
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|temp
argument_list|,
name|j
argument_list|,
name|c2
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|ADDRESSOF
operator|&&
name|rhsoffset
operator|!=
literal|0
condition|)
block|{
name|varinfo_t
name|temp
init|=
name|get_varinfo
argument_list|(
name|c2
operator|->
name|var
argument_list|)
decl_stmt|;
comment|/* An access one after the end of an array is valid, 	       so simply punt on accesses we cannot resolve.  */
name|temp
operator|=
name|first_vi_for_offset
argument_list|(
name|temp
argument_list|,
name|rhsoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
continue|continue;
name|c2
operator|->
name|var
operator|=
name|temp
operator|->
name|id
expr_stmt|;
name|c2
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|c2
operator|->
name|offset
operator|=
name|rhsoffset
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|c2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Walk statement T setting up aliasing constraints according to the    references found in T.  This function is the main part of the    constraint builder.  AI points to auxiliary alias information used    when building alias sets and computing alias grouping heuristics.  */
end_comment

begin_function
specifier|static
name|void
name|find_func_aliases
parameter_list|(
name|tree
name|origt
parameter_list|)
block|{
name|tree
name|t
init|=
name|origt
decl_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|lhsc
operator|=
name|NULL
expr_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now build constraints expressions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|PHI_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only care about pointers and structures containing 	 pointers.  */
if|if
condition|(
name|could_have_pointers
argument_list|(
name|PHI_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* For a phi node, assign all the arguments to 	     the result.  */
name|get_constraint_for
argument_list|(
name|PHI_RESULT
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|lhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|rhstype
decl_stmt|;
name|tree
name|strippedrhs
init|=
name|PHI_ARG_DEF
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|strippedrhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|strippedrhs
argument_list|)
expr_stmt|;
name|get_constraint_for
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|,
name|j
argument_list|,
name|c
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|constraint_expr
modifier|*
name|c2
decl_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|>
literal|0
condition|)
block|{
name|c2
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|c2
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* In IPA mode, we need to generate constraints to pass call      arguments through their calls.   There are two case, either a      modify_expr when we are returning a value, or just a plain      call_expr when we are not.   */
elseif|else
if|if
condition|(
name|in_ipa_mode
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|!
operator|(
name|call_expr_flags
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|ECF_MALLOC
operator||
name|ECF_MAY_BE_ALLOCA
operator|)
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|!
operator|(
name|call_expr_flags
argument_list|(
name|t
argument_list|)
operator|&
operator|(
name|ECF_MALLOC
operator||
name|ECF_MAY_BE_ALLOCA
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|lhsop
decl_stmt|;
name|tree
name|rhsop
decl_stmt|;
name|unsigned
name|int
name|varid
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|varinfo_t
name|fi
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|lhsop
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhsop
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lhsop
operator|=
name|NULL
expr_stmt|;
name|rhsop
operator|=
name|t
expr_stmt|;
block|}
name|decl
operator|=
name|get_callee_fndecl
argument_list|(
name|rhsop
argument_list|)
expr_stmt|;
comment|/* If we can directly resolve the function being called, do so. 	 Otherwise, it must be some sort of indirect expression that 	 we should still be able to handle.  */
if|if
condition|(
name|decl
condition|)
block|{
name|varid
operator|=
name|get_id_for_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|rhsop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|varid
operator|=
name|get_id_for_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Assign all the passed arguments to the appropriate incoming 	 parameters of the function.  */
name|fi
operator|=
name|get_varinfo
argument_list|(
name|varid
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|rhsop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|arglist
condition|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|struct
name|constraint_expr
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
modifier|*
name|rhsp
decl_stmt|;
name|get_constraint_for
argument_list|(
name|arg
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|lhs
operator|.
name|type
operator|=
name|DEREF
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|fi
operator|->
name|id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|first_vi_for_offset
argument_list|(
name|fi
argument_list|,
name|i
argument_list|)
operator|->
name|id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rhsp
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
operator|*
name|rhsp
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* If we are returning a value, assign it to the result.  */
if|if
condition|(
name|lhsop
condition|)
block|{
name|struct
name|constraint_expr
name|rhs
decl_stmt|;
name|struct
name|constraint_expr
modifier|*
name|lhsp
decl_stmt|;
name|unsigned
name|int
name|j
init|=
literal|0
decl_stmt|;
name|get_constraint_for
argument_list|(
name|lhsop
argument_list|,
operator|&
name|lhsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|rhs
operator|.
name|type
operator|=
name|DEREF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|fi
operator|->
name|id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|rhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|first_vi_for_offset
argument_list|(
name|fi
argument_list|,
name|i
argument_list|)
operator|->
name|id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|,
name|j
argument_list|,
name|lhsp
argument_list|)
condition|;
name|j
operator|++
control|)
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
operator|*
name|lhsp
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, just a regular assignment statement.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|lhsop
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhsop
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhsop
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhsop
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhsop
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhsop
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|do_structure_copy
argument_list|(
name|lhsop
argument_list|,
name|rhsop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Only care about operations with pointers, structures 	     containing pointers, dereferences, and call expressions.  */
if|if
condition|(
name|could_have_pointers
argument_list|(
name|lhsop
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|rhsop
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|get_constraint_for
argument_list|(
name|lhsop
argument_list|,
operator|&
name|lhsc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|rhsop
argument_list|)
argument_list|)
condition|)
block|{
comment|/* RHS that consist of unary operations, 		     exceptional types, or bare decls/constants, get 		     handled directly by get_constraint_for.  */
case|case
name|tcc_reference
case|:
case|case
name|tcc_declaration
case|:
case|case
name|tcc_constant
case|:
case|case
name|tcc_exceptional
case|:
case|case
name|tcc_expression
case|:
case|case
name|tcc_unary
case|:
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|get_constraint_for
argument_list|(
name|rhsop
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|,
name|j
argument_list|,
name|c
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|constraint_expr
modifier|*
name|c2
decl_stmt|;
name|unsigned
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|k
argument_list|,
name|c2
argument_list|)
condition|;
name|k
operator|++
control|)
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|c2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|tcc_binary
case|:
block|{
comment|/* For pointer arithmetic of the form 			   PTR + CST, we can simply use PTR's 			   constraint because pointer arithmetic is 			   not allowed to go out of bounds.  */
if|if
condition|(
name|handle_ptr_arith
argument_list|(
name|lhsc
argument_list|,
name|rhsop
argument_list|)
condition|)
break|break;
block|}
comment|/* FALLTHRU  */
comment|/* Otherwise, walk each operand.  Notice that we 		     can't use the operand interface because we need 		     to process expressions other than simple operands 		     (e.g. INDIRECT_REF, ADDR_EXPR, CALL_EXPR).  */
default|default:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|rhsop
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|rhsop
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|get_constraint_for
argument_list|(
name|op
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|,
name|j
argument_list|,
name|c
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|constraint_expr
modifier|*
name|c2
decl_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|>
literal|0
condition|)
block|{
name|c2
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|c2
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* After promoting variables and computing aliasing we will      need to re-scan most statements.  FIXME: Try to minimize the      number of statements re-scanned.  It's not really necessary to      re-scan *all* statements.  */
name|mark_stmt_modified
argument_list|(
name|origt
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|lhsc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the first varinfo in the same variable as START that overlaps with    OFFSET.    Effectively, walk the chain of fields for the variable START to find the    first field that overlaps with OFFSET.    Return NULL if we can't find one.  */
end_comment

begin_function
specifier|static
name|varinfo_t
name|first_vi_for_offset
parameter_list|(
name|varinfo_t
name|start
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|varinfo_t
name|curr
init|=
name|start
decl_stmt|;
while|while
condition|(
name|curr
condition|)
block|{
comment|/* We may not find a variable in the field list with the actual 	 offset when when we have glommed a structure to a variable. 	 In that case, however, offset should still be within the size 	 of the variable. */
if|if
condition|(
name|offset
operator|>=
name|curr
operator|->
name|offset
operator|&&
name|offset
operator|<
operator|(
name|curr
operator|->
name|offset
operator|+
name|curr
operator|->
name|size
operator|)
condition|)
return|return
name|curr
return|;
name|curr
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Insert the varinfo FIELD into the field list for BASE, at the front    of the list.  */
end_comment

begin_function
specifier|static
name|void
name|insert_into_field_list
parameter_list|(
name|varinfo_t
name|base
parameter_list|,
name|varinfo_t
name|field
parameter_list|)
block|{
name|varinfo_t
name|prev
init|=
name|base
decl_stmt|;
name|varinfo_t
name|curr
init|=
name|base
operator|->
name|next
decl_stmt|;
name|field
operator|->
name|next
operator|=
name|curr
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|field
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the varinfo FIELD into the field list for BASE, ordered by    offset.  */
end_comment

begin_function
specifier|static
name|void
name|insert_into_field_list_sorted
parameter_list|(
name|varinfo_t
name|base
parameter_list|,
name|varinfo_t
name|field
parameter_list|)
block|{
name|varinfo_t
name|prev
init|=
name|base
decl_stmt|;
name|varinfo_t
name|curr
init|=
name|base
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|curr
operator|==
name|NULL
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|field
expr_stmt|;
name|field
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|curr
condition|)
block|{
if|if
condition|(
name|field
operator|->
name|offset
operator|<=
name|curr
operator|->
name|offset
condition|)
break|break;
name|prev
operator|=
name|curr
expr_stmt|;
name|curr
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
name|field
operator|->
name|next
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|field
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* qsort comparison function for two fieldoff's PA and PB */
end_comment

begin_function
specifier|static
name|int
name|fieldoff_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|pa
parameter_list|,
specifier|const
name|void
modifier|*
name|pb
parameter_list|)
block|{
specifier|const
name|fieldoff_s
modifier|*
name|foa
init|=
operator|(
specifier|const
name|fieldoff_s
operator|*
operator|)
name|pa
decl_stmt|;
specifier|const
name|fieldoff_s
modifier|*
name|fob
init|=
operator|(
specifier|const
name|fieldoff_s
operator|*
operator|)
name|pb
decl_stmt|;
name|HOST_WIDE_INT
name|foasize
decl_stmt|,
name|fobsize
decl_stmt|;
if|if
condition|(
name|foa
operator|->
name|offset
operator|!=
name|fob
operator|->
name|offset
condition|)
return|return
name|foa
operator|->
name|offset
operator|-
name|fob
operator|->
name|offset
return|;
name|foasize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|foa
operator|->
name|size
argument_list|)
expr_stmt|;
name|fobsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fob
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|foasize
operator|-
name|fobsize
return|;
block|}
end_function

begin_comment
comment|/* Sort a fieldstack according to the field offset and sizes.  */
end_comment

begin_decl_stmt
name|void
name|sort_fieldstack
argument_list|(
name|VEC
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|)
operator|*
name|fieldstack
argument_list|)
block|{
name|qsort
argument_list|(
name|VEC_address
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|fieldoff_s
argument_list|)
argument_list|,
name|fieldoff_compare
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Given a TYPE, and a vector of field offsets FIELDSTACK, push all the fields    of TYPE onto fieldstack, recording their offsets along the way.    OFFSET is used to keep track of the offset in this entire structure, rather    than just the immediately containing structure.  Returns the number    of fields pushed.    HAS_UNION is set to true if we find a union type as a field of    TYPE.  */
end_comment

begin_decl_stmt
name|int
name|push_fields_onto_fieldstack
argument_list|(
name|tree
name|type
argument_list|,
name|VEC
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|fieldstack
argument_list|,
name|HOST_WIDE_INT
name|offset
argument_list|,
name|bool
operator|*
name|has_union
argument_list|)
block|{
name|tree
name|field
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|fieldoff_s
modifier|*
name|real_part
decl_stmt|,
modifier|*
name|img_part
decl_stmt|;
name|real_part
operator|=
name|VEC_safe_push
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
operator|*
name|fieldstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|real_part
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|real_part
operator|->
name|size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|real_part
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|real_part
operator|->
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
name|img_part
operator|=
name|VEC_safe_push
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
operator|*
name|fieldstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|img_part
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|img_part
operator|->
name|size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|img_part
operator|->
name|offset
operator|=
name|offset
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|img_part
operator|->
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|sz
init|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|elsz
init|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|nr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sz
operator|||
operator|!
name|host_integerp
argument_list|(
name|sz
argument_list|,
literal|1
argument_list|)
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|sz
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|elsz
operator|||
operator|!
name|host_integerp
argument_list|(
name|elsz
argument_list|,
literal|1
argument_list|)
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|elsz
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|nr
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|sz
argument_list|)
operator|/
name|TREE_INT_CST_LOW
argument_list|(
name|elsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|>
name|SALIAS_MAX_ARRAY_ELEMENTS
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|push
init|=
name|false
decl_stmt|;
name|int
name|pushed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|has_union
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
operator|*
name|has_union
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
comment|/* var_can_have_subvars */
name|push
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|pushed
operator|=
name|push_fields_onto_fieldstack
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|fieldstack
argument_list|,
name|offset
operator|+
name|i
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|elsz
argument_list|)
argument_list|,
name|has_union
argument_list|)
operator|)
condition|)
comment|/* Empty structures may have actual size, like in C++. So 	       see if we didn't push any subfields and the size is 	       nonzero, push the field onto the stack */
name|push
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|push
condition|)
block|{
name|fieldoff_s
modifier|*
name|pair
decl_stmt|;
name|pair
operator|=
name|VEC_safe_push
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
operator|*
name|fieldstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pair
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|pair
operator|->
name|size
operator|=
name|elsz
expr_stmt|;
name|pair
operator|->
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
name|pair
operator|->
name|offset
operator|=
name|offset
operator|+
name|i
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|elsz
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
name|count
operator|+=
name|pushed
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|bool
name|push
init|=
name|false
decl_stmt|;
name|int
name|pushed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|has_union
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
operator|*
name|has_union
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|var_can_have_subvars
argument_list|(
name|field
argument_list|)
condition|)
name|push
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|pushed
operator|=
name|push_fields_onto_fieldstack
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|fieldstack
argument_list|,
name|offset
operator|+
name|bitpos_of_field
argument_list|(
name|field
argument_list|)
argument_list|,
name|has_union
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
comment|/* Empty structures may have actual size, like in C++. So 	     see if we didn't push any subfields and the size is 	     nonzero, push the field onto the stack */
name|push
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|push
condition|)
block|{
name|fieldoff_s
modifier|*
name|pair
decl_stmt|;
name|pair
operator|=
name|VEC_safe_push
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
operator|*
name|fieldstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pair
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|pair
operator|->
name|size
operator|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|pair
operator|->
name|decl
operator|=
name|field
expr_stmt|;
name|pair
operator|->
name|offset
operator|=
name|offset
operator|+
name|bitpos_of_field
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
name|count
operator|+=
name|pushed
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Create a constraint from ESCAPED_VARS variable to VI.  */
end_comment

begin_function
specifier|static
name|void
name|make_constraint_from_escaped
parameter_list|(
name|varinfo_t
name|vi
parameter_list|)
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|lhs
operator|.
name|var
operator|=
name|vi
operator|->
name|id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a constraint to the ESCAPED_VARS variable from constraint    expression RHS. */
end_comment

begin_function
specifier|static
name|void
name|make_constraint_to_escaped
parameter_list|(
name|struct
name|constraint_expr
name|rhs
parameter_list|)
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|;
name|lhs
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count the number of arguments DECL has, and set IS_VARARGS to true    if it is a varargs function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|count_num_arguments
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
modifier|*
name|is_varargs
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|void_type_node
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|t
condition|)
operator|*
name|is_varargs
operator|=
name|true
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Creation function node for DECL, using NAME, and return the index    of the variable we've created for the function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|create_function_info_for
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|index
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|varinfo_t
name|vi
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bool
name|is_varargs
init|=
name|false
decl_stmt|;
comment|/* Create the variable info.  */
name|vi
operator|=
name|new_var_info
argument_list|(
name|decl
argument_list|,
name|index
argument_list|,
name|name
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|vi
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|vi
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|vi
operator|->
name|has_union
operator|=
literal|0
expr_stmt|;
name|vi
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|vi
operator|->
name|fullsize
operator|=
name|count_num_arguments
argument_list|(
name|decl
argument_list|,
operator|&
name|is_varargs
argument_list|)
operator|+
literal|1
expr_stmt|;
name|insert_id_for_tree
argument_list|(
name|vi
operator|->
name|decl
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|stats
operator|.
name|total_vars
operator|++
expr_stmt|;
comment|/* If it's varargs, we don't know how many arguments it has, so we      can't do much.   */
if|if
condition|(
name|is_varargs
condition|)
block|{
name|vi
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|vi
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|vi
operator|->
name|is_unknown_size_var
operator|=
name|true
expr_stmt|;
return|return
name|index
return|;
block|}
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Set up variables for each argument.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|vi
operator|->
name|fullsize
condition|;
name|i
operator|++
control|)
block|{
name|varinfo_t
name|argvi
decl_stmt|;
specifier|const
name|char
modifier|*
name|newname
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|unsigned
name|int
name|newindex
decl_stmt|;
name|tree
name|argdecl
init|=
name|decl
decl_stmt|;
if|if
condition|(
name|arg
condition|)
name|argdecl
operator|=
name|arg
expr_stmt|;
name|newindex
operator|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|tempname
argument_list|,
literal|"%s.arg%d"
argument_list|,
name|name
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newname
operator|=
name|ggc_strdup
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|argvi
operator|=
name|new_var_info
argument_list|(
name|argdecl
argument_list|,
name|newindex
argument_list|,
name|newname
argument_list|,
name|newindex
argument_list|)
expr_stmt|;
name|argvi
operator|->
name|decl
operator|=
name|argdecl
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|argvi
argument_list|)
expr_stmt|;
name|argvi
operator|->
name|offset
operator|=
name|i
expr_stmt|;
name|argvi
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|argvi
operator|->
name|fullsize
operator|=
name|vi
operator|->
name|fullsize
expr_stmt|;
name|argvi
operator|->
name|has_union
operator|=
name|false
expr_stmt|;
name|insert_into_field_list_sorted
argument_list|(
name|vi
argument_list|,
name|argvi
argument_list|)
expr_stmt|;
name|stats
operator|.
name|total_vars
operator|++
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|insert_id_for_tree
argument_list|(
name|arg
argument_list|,
name|newindex
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create a variable for the return var.  */
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
operator|||
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|varinfo_t
name|resultvi
decl_stmt|;
specifier|const
name|char
modifier|*
name|newname
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|unsigned
name|int
name|newindex
decl_stmt|;
name|tree
name|resultdecl
init|=
name|decl
decl_stmt|;
name|vi
operator|->
name|fullsize
operator|++
expr_stmt|;
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
condition|)
name|resultdecl
operator|=
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|newindex
operator|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|tempname
argument_list|,
literal|"%s.result"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|newname
operator|=
name|ggc_strdup
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|resultvi
operator|=
name|new_var_info
argument_list|(
name|resultdecl
argument_list|,
name|newindex
argument_list|,
name|newname
argument_list|,
name|newindex
argument_list|)
expr_stmt|;
name|resultvi
operator|->
name|decl
operator|=
name|resultdecl
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|resultvi
argument_list|)
expr_stmt|;
name|resultvi
operator|->
name|offset
operator|=
name|i
expr_stmt|;
name|resultvi
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|resultvi
operator|->
name|fullsize
operator|=
name|vi
operator|->
name|fullsize
expr_stmt|;
name|resultvi
operator|->
name|has_union
operator|=
name|false
expr_stmt|;
name|insert_into_field_list_sorted
argument_list|(
name|vi
argument_list|,
name|resultvi
argument_list|)
expr_stmt|;
name|stats
operator|.
name|total_vars
operator|++
expr_stmt|;
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
condition|)
name|insert_id_for_tree
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|newindex
argument_list|)
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Return true if FIELDSTACK contains fields that overlap.     FIELDSTACK is assumed to be sorted by offset.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|check_for_overlaps
argument_list|(
name|VEC
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|)
operator|*
name|fieldstack
argument_list|)
block|{
name|fieldoff_s
modifier|*
name|fo
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|lastoffset
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|,
name|i
argument_list|,
name|fo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fo
operator|->
name|offset
operator|==
name|lastoffset
condition|)
return|return
name|true
return|;
name|lastoffset
operator|=
name|fo
operator|->
name|offset
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* This function is called through walk_tree to walk global    initializers looking for constraints we need to add to the    constraint list.  */
end_comment

begin_function
specifier|static
name|tree
name|find_global_initializers
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|viv
parameter_list|)
block|{
name|varinfo_t
name|vi
init|=
operator|(
name|varinfo_t
operator|)
name|viv
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Dereferences and addressofs are the only important things 	 here, and i don't even remember if dereferences are legal 	 here in initializers.  */
case|case
name|INDIRECT_REF
case|:
case|case
name|ADDR_EXPR
case|:
block|{
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|get_constraint_for
argument_list|(
name|t
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|;
name|lhs
operator|.
name|var
operator|=
name|vi
operator|->
name|id
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_DECL
case|:
comment|/* We might not have walked this because we skip 	 DECL_EXTERNALs during the initial scan.  */
if|if
condition|(
name|referenced_vars
condition|)
block|{
name|get_var_ann
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|referenced_var_check_and_insert
argument_list|(
name|t
argument_list|)
condition|)
name|mark_sym_for_renaming
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Create a varinfo structure for NAME and DECL, and add it to VARMAP.    This will also create any varinfo structures necessary for fields    of DECL.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|create_variable_info_for
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|index
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|varinfo_t
name|vi
decl_stmt|;
name|tree
name|decltype
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|declsize
init|=
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|?
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
else|:
name|TYPE_SIZE
argument_list|(
name|decltype
argument_list|)
decl_stmt|;
name|bool
name|notokay
init|=
name|false
decl_stmt|;
name|bool
name|hasunion
decl_stmt|;
name|bool
name|is_global
init|=
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|?
name|is_global_var
argument_list|(
name|decl
argument_list|)
else|:
name|false
decl_stmt|;
name|VEC
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|)
operator|*
name|fieldstack
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|in_ipa_mode
condition|)
return|return
name|create_function_info_for
argument_list|(
name|decl
argument_list|,
name|name
argument_list|)
return|;
name|hasunion
operator|=
name|TREE_CODE
argument_list|(
name|decltype
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|decltype
argument_list|)
operator|==
name|QUAL_UNION_TYPE
expr_stmt|;
if|if
condition|(
name|var_can_have_subvars
argument_list|(
name|decl
argument_list|)
operator|&&
name|use_field_sensitive
operator|&&
operator|!
name|hasunion
condition|)
block|{
name|push_fields_onto_fieldstack
argument_list|(
name|decltype
argument_list|,
operator|&
name|fieldstack
argument_list|,
literal|0
argument_list|,
operator|&
name|hasunion
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasunion
condition|)
block|{
name|VEC_free
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
name|fieldstack
argument_list|)
expr_stmt|;
name|notokay
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* If the variable doesn't have subvars, we may end up needing to      sort the field list and create fake variables for all the      fields.  */
name|vi
operator|=
name|new_var_info
argument_list|(
name|decl
argument_list|,
name|index
argument_list|,
name|name
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|vi
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|vi
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|vi
operator|->
name|has_union
operator|=
name|hasunion
expr_stmt|;
if|if
condition|(
operator|!
name|declsize
operator|||
name|TREE_CODE
argument_list|(
name|declsize
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|decltype
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|decltype
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
block|{
name|vi
operator|->
name|is_unknown_size_var
operator|=
name|true
expr_stmt|;
name|vi
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|vi
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|vi
operator|->
name|fullsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|declsize
argument_list|)
expr_stmt|;
name|vi
operator|->
name|size
operator|=
name|vi
operator|->
name|fullsize
expr_stmt|;
block|}
name|insert_id_for_tree
argument_list|(
name|vi
operator|->
name|decl
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|vi
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_global
operator|&&
operator|(
operator|!
name|flag_whole_program
operator|||
operator|!
name|in_ipa_mode
operator|)
condition|)
block|{
name|make_constraint_from_escaped
argument_list|(
name|vi
argument_list|)
expr_stmt|;
comment|/* If the variable can't be aliased, there is no point in 	 putting it in the set of nonlocal vars.  */
if|if
condition|(
name|may_be_aliased
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
condition|)
block|{
name|struct
name|constraint_expr
name|rhs
decl_stmt|;
name|rhs
operator|.
name|var
operator|=
name|index
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|make_constraint_to_escaped
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|find_global_initializers
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vi
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|.
name|total_vars
operator|++
expr_stmt|;
if|if
condition|(
name|use_field_sensitive
operator|&&
operator|!
name|notokay
operator|&&
operator|!
name|vi
operator|->
name|is_unknown_size_var
operator|&&
name|var_can_have_subvars
argument_list|(
name|decl
argument_list|)
operator|&&
name|VEC_length
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
operator|<=
name|MAX_FIELDS_FOR_FIELD_SENSITIVE
condition|)
block|{
name|unsigned
name|int
name|newindex
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|fieldoff_s
modifier|*
name|fo
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|notokay
operator|&&
name|VEC_iterate
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|,
name|i
argument_list|,
name|fo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|fo
operator|->
name|size
operator|||
name|TREE_CODE
argument_list|(
name|fo
operator|->
name|size
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|fo
operator|->
name|offset
operator|<
literal|0
condition|)
block|{
name|notokay
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* We can't sort them if we have a field with a variable sized type, 	 which will make notokay = true.  In that case, we are going to return 	 without creating varinfos for the fields anyway, so sorting them is a 	 waste to boot.  */
if|if
condition|(
operator|!
name|notokay
condition|)
block|{
name|sort_fieldstack
argument_list|(
name|fieldstack
argument_list|)
expr_stmt|;
comment|/* Due to some C++ FE issues, like PR 22488, we might end up 	     what appear to be overlapping fields even though they, 	     in reality, do not overlap.  Until the C++ FE is fixed, 	     we will simply disable field-sensitivity for these cases.  */
name|notokay
operator|=
name|check_for_overlaps
argument_list|(
name|fieldstack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VEC_length
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
operator|!=
literal|0
condition|)
name|fo
operator|=
name|VEC_index
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fo
operator|==
name|NULL
operator|||
name|notokay
condition|)
block|{
name|vi
operator|->
name|is_unknown_size_var
operator|=
literal|1
expr_stmt|;
name|vi
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|vi
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|VEC_free
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
name|fieldstack
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
name|vi
operator|->
name|size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fo
operator|->
name|size
argument_list|)
expr_stmt|;
name|vi
operator|->
name|offset
operator|=
name|fo
operator|->
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VEC_length
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
operator|&&
name|VEC_iterate
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|,
name|i
argument_list|,
name|fo
argument_list|)
condition|;
name|i
operator|--
control|)
block|{
name|varinfo_t
name|newvi
decl_stmt|;
specifier|const
name|char
modifier|*
name|newname
init|=
literal|"NULL"
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|newindex
operator|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
if|if
condition|(
name|fo
operator|->
name|decl
condition|)
name|asprintf
argument_list|(
operator|&
name|tempname
argument_list|,
literal|"%s.%s"
argument_list|,
name|vi
operator|->
name|name
argument_list|,
name|alias_get_name
argument_list|(
name|fo
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|asprintf
argument_list|(
operator|&
name|tempname
argument_list|,
literal|"%s."
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|vi
operator|->
name|name
argument_list|,
name|fo
operator|->
name|offset
argument_list|)
expr_stmt|;
name|newname
operator|=
name|ggc_strdup
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
block|}
name|newvi
operator|=
name|new_var_info
argument_list|(
name|decl
argument_list|,
name|newindex
argument_list|,
name|newname
argument_list|,
name|newindex
argument_list|)
expr_stmt|;
name|newvi
operator|->
name|offset
operator|=
name|fo
operator|->
name|offset
expr_stmt|;
name|newvi
operator|->
name|size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fo
operator|->
name|size
argument_list|)
expr_stmt|;
name|newvi
operator|->
name|fullsize
operator|=
name|vi
operator|->
name|fullsize
expr_stmt|;
name|insert_into_field_list
argument_list|(
name|vi
argument_list|,
name|newvi
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|newvi
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_global
operator|&&
operator|(
operator|!
name|flag_whole_program
operator|||
operator|!
name|in_ipa_mode
operator|)
condition|)
block|{
comment|/* If the variable can't be aliased, there is no point in 		 putting it in the set of nonlocal vars.  */
if|if
condition|(
name|may_be_aliased
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
condition|)
block|{
name|struct
name|constraint_expr
name|rhs
decl_stmt|;
name|rhs
operator|.
name|var
operator|=
name|newindex
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|make_constraint_to_escaped
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
name|make_constraint_from_escaped
argument_list|(
name|newvi
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|total_vars
operator|++
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
name|fieldstack
argument_list|)
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Print out the points-to solution for VAR to FILE.  */
end_comment

begin_function
name|void
name|dump_solution_for_var
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|var
parameter_list|)
block|{
name|varinfo_t
name|vi
init|=
name|get_varinfo
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s = { "
argument_list|,
name|vi
operator|->
name|name
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|get_varinfo (vi->node)->solution
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s "
argument_list|,
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the points-to solution for VAR to stdout.  */
end_comment

begin_function
name|void
name|debug_solution_for_var
parameter_list|(
name|unsigned
name|int
name|var
parameter_list|)
block|{
name|dump_solution_for_var
argument_list|(
name|stdout
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create varinfo structures for all of the variables in the    function for intraprocedural mode.  */
end_comment

begin_function
specifier|static
name|void
name|intra_create_variable_infos
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|struct
name|constraint_expr
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|varinfo_t
name|nonlocal_vi
decl_stmt|;
comment|/* For each incoming pointer argument arg, ARG = ESCAPED_VARS or a      dummy variable if flag_argument_noalias> 2. */
for|for
control|(
name|t
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|varinfo_t
name|p
decl_stmt|;
name|unsigned
name|int
name|arg_id
decl_stmt|;
if|if
condition|(
operator|!
name|could_have_pointers
argument_list|(
name|t
argument_list|)
condition|)
continue|continue;
name|arg_id
operator|=
name|get_id_for_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* With flag_argument_noalias greater than two means that the incoming          argument cannot alias anything except for itself so create a HEAP          variable.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|flag_argument_noalias
operator|>
literal|2
condition|)
block|{
name|varinfo_t
name|vi
decl_stmt|;
name|tree
name|heapvar
init|=
name|heapvar_lookup
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|id
decl_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|get_id_for_tree
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|heapvar
operator|==
name|NULL_TREE
condition|)
block|{
name|heapvar
operator|=
name|create_tmp_var_raw
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|"PARM_NOALIAS"
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|heapvar
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|referenced_vars
condition|)
name|add_referenced_var
argument_list|(
name|heapvar
argument_list|)
expr_stmt|;
name|heapvar_insert
argument_list|(
name|t
argument_list|,
name|heapvar
argument_list|)
expr_stmt|;
block|}
name|id
operator|=
name|get_id_for_tree
argument_list|(
name|heapvar
argument_list|)
expr_stmt|;
name|vi
operator|=
name|get_varinfo
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|vi
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|vi
operator|->
name|is_heap_var
operator|=
literal|1
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|id
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|constraint_expr
name|temp
init|=
name|lhs
decl_stmt|;
name|temp
operator|.
name|var
operator|=
name|p
operator|->
name|id
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|temp
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|get_varinfo
argument_list|(
name|arg_id
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|make_constraint_from_escaped
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|nonlocal_all
condition|)
name|nonlocal_all
operator|=
name|create_nonlocal_var
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Create variable info for the nonlocal var if it does not      exist.  */
name|nonlocal_vars_id
operator|=
name|create_variable_info_for
argument_list|(
name|nonlocal_all
argument_list|,
name|get_name
argument_list|(
name|nonlocal_all
argument_list|)
argument_list|)
expr_stmt|;
name|nonlocal_vi
operator|=
name|get_varinfo
argument_list|(
name|nonlocal_vars_id
argument_list|)
expr_stmt|;
name|nonlocal_vi
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|nonlocal_vi
operator|->
name|is_heap_var
operator|=
literal|1
expr_stmt|;
name|nonlocal_vi
operator|->
name|is_unknown_size_var
operator|=
literal|1
expr_stmt|;
name|nonlocal_vi
operator|->
name|directly_dereferenced
operator|=
name|true
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|nonlocal_vars_id
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set bits in INTO corresponding to the variable uids in solution set    FROM, which came from variable PTR.    For variables that are actually dereferenced, we also use type    based alias analysis to prune the points-to sets.  */
end_comment

begin_function
specifier|static
name|void
name|set_uids_in_ptset
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|bitmap
name|into
parameter_list|,
name|bitmap
name|from
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|subvar_t
name|sv
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ptr_alias_set
init|=
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|from
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|varinfo_t
name|vi
init|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|var_alias_set
decl_stmt|;
comment|/* The only artificial variables that are allowed in a may-alias 	 set are heap variables.  */
if|if
condition|(
name|vi
operator|->
name|is_artificial_var
operator|&&
operator|!
name|vi
operator|->
name|is_heap_var
condition|)
continue|continue;
if|if
condition|(
name|vi
operator|->
name|has_union
operator|&&
name|get_subvars_for_var
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Variables containing unions may need to be converted to 	     their SFT's, because SFT's can have unions and we cannot.  */
for|for
control|(
name|sv
operator|=
name|get_subvars_for_var
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
init|;
name|sv
condition|;
name|sv
operator|=
name|sv
operator|->
name|next
control|)
name|bitmap_set_bit
argument_list|(
name|into
argument_list|,
name|DECL_UID
argument_list|(
name|sv
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|var_can_have_subvars
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|&&
name|get_subvars_for_var
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
condition|)
block|{
comment|/* If VI->DECL is an aggregate for which we created 		 SFTs, add the SFT corresponding to VI->OFFSET.  */
name|tree
name|sft
init|=
name|get_subvar_at
argument_list|(
name|vi
operator|->
name|decl
argument_list|,
name|vi
operator|->
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|sft
condition|)
block|{
name|var_alias_set
operator|=
name|get_alias_set
argument_list|(
name|sft
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vi
operator|->
name|directly_dereferenced
operator|||
name|alias_sets_conflict_p
argument_list|(
name|ptr_alias_set
argument_list|,
name|var_alias_set
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|into
argument_list|,
name|DECL_UID
argument_list|(
name|sft
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise, just add VI->DECL to the alias set. 		 Don't type prune artificial vars.  */
if|if
condition|(
name|vi
operator|->
name|is_artificial_var
condition|)
name|bitmap_set_bit
argument_list|(
name|into
argument_list|,
name|DECL_UID
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|var_alias_set
operator|=
name|get_alias_set
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vi
operator|->
name|directly_dereferenced
operator|||
name|alias_sets_conflict_p
argument_list|(
name|ptr_alias_set
argument_list|,
name|var_alias_set
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|into
argument_list|,
name|DECL_UID
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|bool
name|have_alias_info
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a pointer variable P, fill in its points-to set, or return    false if we can't.  */
end_comment

begin_function
name|bool
name|find_what_p_points_to
parameter_list|(
name|tree
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|id
init|=
literal|0
decl_stmt|;
name|tree
name|lookup_p
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|have_alias_info
condition|)
return|return
name|false
return|;
comment|/* For parameters, get at the points-to set for the actual parm      decl.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|default_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|p
condition|)
name|lookup_p
operator|=
name|SSA_NAME_VAR
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_id_for_tree
argument_list|(
name|lookup_p
argument_list|,
operator|&
name|id
argument_list|)
condition|)
block|{
name|varinfo_t
name|vi
init|=
name|get_varinfo
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|vi
operator|->
name|is_artificial_var
condition|)
return|return
name|false
return|;
comment|/* See if this is a field or a structure.  */
if|if
condition|(
name|vi
operator|->
name|size
operator|!=
name|vi
operator|->
name|fullsize
condition|)
block|{
comment|/* Nothing currently asks about structure fields directly, 	     but when they do, we need code here to hand back the 	     points-to set.  */
if|if
condition|(
operator|!
name|var_can_have_subvars
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|||
name|get_subvars_for_var
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|get_ptr_info
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* This variable may have been collapsed, let's get the real 	     variable.  */
name|vi
operator|=
name|get_varinfo
argument_list|(
name|vi
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* Translate artificial variables into SSA_NAME_PTR_INFO 	     attributes.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|vi->solution
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|varinfo_t
name|vi
init|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|vi
operator|->
name|is_artificial_var
condition|)
block|{
comment|/* FIXME.  READONLY should be handled better so that 		     flow insensitive aliasing can disregard writable 		     aliases.  */
if|if
condition|(
name|vi
operator|->
name|id
operator|==
name|nothing_id
condition|)
name|pi
operator|->
name|pt_null
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|vi
operator|->
name|id
operator|==
name|anything_id
condition|)
name|pi
operator|->
name|pt_anything
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|vi
operator|->
name|id
operator|==
name|readonly_id
condition|)
name|pi
operator|->
name|pt_anything
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|vi
operator|->
name|id
operator|==
name|integer_id
condition|)
name|pi
operator|->
name|pt_anything
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|vi
operator|->
name|is_heap_var
condition|)
name|pi
operator|->
name|pt_global_mem
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pi
operator|->
name|pt_anything
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|pi
operator|->
name|pt_vars
condition|)
name|pi
operator|->
name|pt_vars
operator|=
name|BITMAP_GGC_ALLOC
argument_list|()
expr_stmt|;
name|set_uids_in_ptset
argument_list|(
name|vi
operator|->
name|decl
argument_list|,
name|pi
operator|->
name|pt_vars
argument_list|,
name|vi
operator|->
name|solution
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_empty_p
argument_list|(
name|pi
operator|->
name|pt_vars
argument_list|)
condition|)
name|pi
operator|->
name|pt_vars
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Dump points-to information to OUTFILE.  */
end_comment

begin_function
name|void
name|dump_sa_points_to_info
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\nPoints-to sets\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_flags
operator|&
name|TDF_STATS
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Stats:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Total vars:               %d\n"
argument_list|,
name|stats
operator|.
name|total_vars
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Statically unified vars:  %d\n"
argument_list|,
name|stats
operator|.
name|unified_vars_static
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Collapsed vars:           %d\n"
argument_list|,
name|stats
operator|.
name|collapsed_vars
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Dynamically unified vars: %d\n"
argument_list|,
name|stats
operator|.
name|unified_vars_dynamic
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Iterations:               %d\n"
argument_list|,
name|stats
operator|.
name|iterations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Number of edges:          %d\n"
argument_list|,
name|stats
operator|.
name|num_edges
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
condition|;
name|i
operator|++
control|)
name|dump_solution_for_var
argument_list|(
name|outfile
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debug points-to information to stderr.  */
end_comment

begin_function
name|void
name|debug_sa_points_to_info
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_sa_points_to_info
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the always-existing constraint variables for NULL    ANYTHING, READONLY, and INTEGER */
end_comment

begin_function
specifier|static
name|void
name|init_base_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
comment|/* Create the NULL variable, used to represent that a variable points      to NULL.  */
name|nothing_tree
operator|=
name|create_tmp_var_raw
argument_list|(
name|void_type_node
argument_list|,
literal|"NULL"
argument_list|)
expr_stmt|;
name|var_nothing
operator|=
name|new_var_info
argument_list|(
name|nothing_tree
argument_list|,
literal|0
argument_list|,
literal|"NULL"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insert_id_for_tree
argument_list|(
name|nothing_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|var_nothing
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|var_nothing
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|var_nothing
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|var_nothing
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|var_nothing
operator|->
name|is_special_var
operator|=
literal|1
expr_stmt|;
name|nothing_id
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|var_nothing
argument_list|)
expr_stmt|;
comment|/* Create the ANYTHING variable, used to represent that a variable      points to some unknown piece of memory.  */
name|anything_tree
operator|=
name|create_tmp_var_raw
argument_list|(
name|void_type_node
argument_list|,
literal|"ANYTHING"
argument_list|)
expr_stmt|;
name|var_anything
operator|=
name|new_var_info
argument_list|(
name|anything_tree
argument_list|,
literal|1
argument_list|,
literal|"ANYTHING"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|insert_id_for_tree
argument_list|(
name|anything_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|var_anything
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|var_anything
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|var_anything
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|var_anything
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|var_anything
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|var_anything
operator|->
name|is_special_var
operator|=
literal|1
expr_stmt|;
name|anything_id
operator|=
literal|1
expr_stmt|;
comment|/* Anything points to anything.  This makes deref constraints just      work in the presence of linked list and other p = *p type loops,       by saying that *ANYTHING = ANYTHING. */
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|var_anything
argument_list|)
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|var_anything
operator|->
name|address_taken
operator|=
name|true
expr_stmt|;
comment|/* This specifically does not use process_constraint because      process_constraint ignores all anything = anything constraints, since all      but this one are redundant.  */
name|VEC_safe_push
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|constraints
argument_list|,
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the READONLY variable, used to represent that a variable      points to readonly memory.  */
name|readonly_tree
operator|=
name|create_tmp_var_raw
argument_list|(
name|void_type_node
argument_list|,
literal|"READONLY"
argument_list|)
expr_stmt|;
name|var_readonly
operator|=
name|new_var_info
argument_list|(
name|readonly_tree
argument_list|,
literal|2
argument_list|,
literal|"READONLY"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|var_readonly
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|var_readonly
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|var_readonly
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|var_readonly
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|var_readonly
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|var_readonly
operator|->
name|is_special_var
operator|=
literal|1
expr_stmt|;
name|insert_id_for_tree
argument_list|(
name|readonly_tree
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|readonly_id
operator|=
literal|2
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|var_readonly
argument_list|)
expr_stmt|;
comment|/* readonly memory points to anything, in order to make deref      easier.  In reality, it points to anything the particular      readonly variable can point to, but we don't track this      separately. */
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|readonly_id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the INTEGER variable, used to represent that a variable points      to an INTEGER.  */
name|integer_tree
operator|=
name|create_tmp_var_raw
argument_list|(
name|void_type_node
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|var_integer
operator|=
name|new_var_info
argument_list|(
name|integer_tree
argument_list|,
literal|3
argument_list|,
literal|"INTEGER"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|insert_id_for_tree
argument_list|(
name|integer_tree
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|var_integer
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|var_integer
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|var_integer
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|var_integer
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|var_integer
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|var_integer
operator|->
name|is_special_var
operator|=
literal|1
expr_stmt|;
name|integer_id
operator|=
literal|3
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|var_integer
argument_list|)
expr_stmt|;
comment|/* INTEGER = ANYTHING, because we don't know where a dereference of      a random integer will point to.  */
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|integer_id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the ESCAPED_VARS variable used to represent variables that      escape this function.  */
name|escaped_vars_tree
operator|=
name|create_tmp_var_raw
argument_list|(
name|void_type_node
argument_list|,
literal|"ESCAPED_VARS"
argument_list|)
expr_stmt|;
name|var_escaped_vars
operator|=
name|new_var_info
argument_list|(
name|escaped_vars_tree
argument_list|,
literal|4
argument_list|,
literal|"ESCAPED_VARS"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|insert_id_for_tree
argument_list|(
name|escaped_vars_tree
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|var_escaped_vars
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|var_escaped_vars
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|var_escaped_vars
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|var_escaped_vars
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|var_escaped_vars
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|escaped_vars_id
operator|=
literal|4
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|var_escaped_vars
argument_list|)
expr_stmt|;
comment|/* ESCAPED_VARS = *ESCAPED_VARS */
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|DEREF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize things necessary to perform PTA */
end_comment

begin_function
specifier|static
name|void
name|init_alias_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|ptabitmap_obstack
argument_list|)
expr_stmt|;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|predbitmap_obstack
argument_list|)
expr_stmt|;
name|constraint_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Constraint pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|constraint
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|variable_info_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Variable info pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|variable_info
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|constraint_edge_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Constraint edges"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|constraint_edge
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|constraints
operator|=
name|VEC_alloc
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|varmap
operator|=
name|VEC_alloc
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|id_for_tree
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|tree_id_hash
argument_list|,
name|tree_id_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|init_base_vars
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a statement STMT, generate necessary constraints to    escaped_vars for the escaping variables.  */
end_comment

begin_function
specifier|static
name|void
name|find_escape_constraints
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|enum
name|escape_type
name|stmt_escape_type
init|=
name|is_escape_site
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|stmt_escape_type
operator|==
name|NO_ESCAPE
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
block|{
comment|/* Returns are either bare, with an embedded MODIFY_EXPR, or 	 just a plain old expression.  */
if|if
condition|(
operator|!
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get_constraint_for
argument_list|(
name|rhs
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
name|make_constraint_to_escaped
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|ASM_EXPR
condition|)
block|{
comment|/* Whatever the inputs of the ASM are, escape.  */
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|get_constraint_for
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
name|make_constraint_to_escaped
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|CALL_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|)
condition|)
block|{
comment|/* Calls cause all of the arguments passed in to escape.  */
name|tree
name|arg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|get_constraint_for
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
name|make_constraint_to_escaped
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|stmt_escape_type
operator|==
name|ESCAPE_BAD_CAST
operator|||
name|stmt_escape_type
operator|==
name|ESCAPE_STORED_IN_GLOBAL
operator|||
name|stmt_escape_type
operator|==
name|ESCAPE_UNKNOWN
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Look through casts for the real escaping variable.      Constants don't really escape, so ignore them.      Otherwise, whatever escapes must be on our RHS.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
name|get_constraint_for
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|rhs
argument_list|)
condition|)
return|return;
else|else
block|{
name|get_constraint_for
argument_list|(
name|rhs
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
name|make_constraint_to_escaped
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create points-to sets for the current function.  See the comments    at the start of the file for an algorithmic overview.  */
end_comment

begin_function
name|void
name|compute_points_to_sets
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_TREE_PTA
argument_list|)
expr_stmt|;
name|init_alias_vars
argument_list|()
expr_stmt|;
name|intra_create_variable_infos
argument_list|()
expr_stmt|;
comment|/* Now walk all statements and derive aliases.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|TREE_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
block|{
name|find_func_aliases
argument_list|(
name|phi
argument_list|)
expr_stmt|;
comment|/* Update various related attributes like escaped 		 addresses, pointer dereferences for loads and stores. 		 This is used when creating name tags and alias 		 sets.  */
name|update_alias_info
argument_list|(
name|phi
argument_list|,
name|ai
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|find_func_aliases
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|find_escape_constraints
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* Update various related attributes like escaped 	     addresses, pointer dereferences for loads and stores. 	     This is used when creating name tags and alias 	     sets.  */
name|update_alias_info
argument_list|(
name|stmt
argument_list|,
name|ai
argument_list|)
expr_stmt|;
block|}
block|}
name|build_constraint_graph
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Points-to analysis\n\nConstraints:\n\n"
argument_list|)
expr_stmt|;
name|dump_constraints
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nCollapsing static cycles and doing variable "
literal|"substitution:\n"
argument_list|)
expr_stmt|;
name|find_and_collapse_graph_cycles
argument_list|(
name|graph
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|perform_var_substitution
argument_list|(
name|graph
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nSolving graph:\n"
argument_list|)
expr_stmt|;
name|solve_graph
argument_list|(
name|graph
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|dump_sa_points_to_info
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|have_alias_info
operator|=
name|true
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_TREE_PTA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete created points-to sets.  */
end_comment

begin_function
name|void
name|delete_points_to_sets
parameter_list|(
name|void
parameter_list|)
block|{
name|varinfo_t
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|htab_delete
argument_list|(
name|id_for_tree
argument_list|)
expr_stmt|;
name|bitmap_obstack_release
argument_list|(
operator|&
name|ptabitmap_obstack
argument_list|)
expr_stmt|;
name|bitmap_obstack_release
argument_list|(
operator|&
name|predbitmap_obstack
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|constraints
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|,
name|i
argument_list|,
name|v
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Nonlocal vars may add more varinfos.  */
if|if
condition|(
name|i
operator|>=
name|graph_size
condition|)
break|break;
name|VEC_free
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|,
name|graph
operator|->
name|succs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|constraint_edge_t
argument_list|,
name|heap
argument_list|,
name|graph
operator|->
name|preds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|v
operator|->
name|complex
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|graph
operator|->
name|zero_weight_preds
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|zero_weight_succs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|succs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|preds
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|variable_info_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|constraint_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|constraint_edge_pool
argument_list|)
expr_stmt|;
name|have_alias_info
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if we should execute IPA PTA.  */
end_comment

begin_function
specifier|static
name|bool
name|gate_ipa_pta
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|flag_unit_at_a_time
operator|!=
literal|0
operator|&&
name|flag_ipa_pta
comment|/* Don't bother doing anything if the program has errors.  */
operator|&&
operator|!
operator|(
name|errorcount
operator|||
name|sorrycount
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Execute the driver for IPA PTA.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ipa_pta_execute
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
decl_stmt|;
name|in_ipa_mode
operator|=
literal|1
expr_stmt|;
name|init_alias_heapvars
argument_list|()
expr_stmt|;
name|init_alias_vars
argument_list|()
expr_stmt|;
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|node
operator|->
name|analyzed
operator|||
name|cgraph_is_master_clone
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|varid
decl_stmt|;
name|varid
operator|=
name|create_function_info_for
argument_list|(
name|node
operator|->
name|decl
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|local
operator|.
name|externally_visible
condition|)
block|{
name|varinfo_t
name|fi
init|=
name|get_varinfo
argument_list|(
name|varid
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|next
control|)
name|make_constraint_from_escaped
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|node
operator|=
name|cgraph_nodes
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
if|if
condition|(
name|node
operator|->
name|analyzed
operator|&&
name|cgraph_is_master_clone
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|struct
name|function
modifier|*
name|cfun
init|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|node
operator|->
name|decl
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tree
name|old_func_decl
init|=
name|current_function_decl
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Generating constraints for %s\n"
argument_list|,
name|cgraph_node_name
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|push_cfun
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|node
operator|->
name|decl
expr_stmt|;
name|FOR_EACH_BB_FN
argument_list|(
argument|bb
argument_list|,
argument|cfun
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|TREE_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
block|{
name|find_func_aliases
argument_list|(
name|phi
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|find_func_aliases
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
block|}
block|}
name|current_function_decl
operator|=
name|old_func_decl
expr_stmt|;
name|pop_cfun
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Make point to anything.  */
block|}
block|}
name|build_constraint_graph
argument_list|()
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Points-to analysis\n\nConstraints:\n\n"
argument_list|)
expr_stmt|;
name|dump_constraints
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nCollapsing static cycles and doing variable "
literal|"substitution:\n"
argument_list|)
expr_stmt|;
name|find_and_collapse_graph_cycles
argument_list|(
name|graph
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|perform_var_substitution
argument_list|(
name|graph
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nSolving graph:\n"
argument_list|)
expr_stmt|;
name|solve_graph
argument_list|(
name|graph
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|dump_sa_points_to_info
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|in_ipa_mode
operator|=
literal|0
expr_stmt|;
name|delete_alias_heapvars
argument_list|()
expr_stmt|;
name|delete_points_to_sets
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_ipa_pta
init|=
block|{
literal|"pta"
block|,
comment|/* name */
name|gate_ipa_pta
block|,
comment|/* gate */
name|ipa_pta_execute
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_IPA_PTA
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the heapvar for statement mapping.  */
end_comment

begin_function
name|void
name|init_alias_heapvars
parameter_list|(
name|void
parameter_list|)
block|{
name|heapvar_for_stmt
operator|=
name|htab_create_ggc
argument_list|(
literal|11
argument_list|,
name|tree_map_hash
argument_list|,
name|tree_map_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nonlocal_all
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|delete_alias_heapvars
parameter_list|(
name|void
parameter_list|)
block|{
name|nonlocal_all
operator|=
name|NULL_TREE
expr_stmt|;
name|htab_delete
argument_list|(
name|heapvar_for_stmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-tree-ssa-structalias.h"
end_include

end_unit

