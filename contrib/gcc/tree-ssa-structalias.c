begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tree based points-to analysis    Copyright (C) 2005, 2006 Free Software Foundation, Inc.    Contributed by Daniel Berlin<dberlin@dberlin.org>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"alloc-pool.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-structalias.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_comment
comment|/* The idea behind this analyzer is to generate set constraints from the    program, then solve the resulting constraints in order to generate the    points-to sets.     Set constraints are a way of modeling program analysis problems that    involve sets.  They consist of an inclusion constraint language,    describing the variables (each variable is a set) and operations that    are involved on the variables, and a set of rules that derive facts    from these operations.  To solve a system of set constraints, you derive    all possible facts under the rules, which gives you the correct sets    as a consequence.     See  "Efficient Field-sensitive pointer analysis for C" by "David    J. Pearce and Paul H. J. Kelly and Chris Hankin, at    http://citeseer.ist.psu.edu/pearce04efficient.html     Also see "Ultra-fast Aliasing Analysis using CLA: A Million Lines    of C Code in a Second" by ""Nevin Heintze and Olivier Tardieu" at    http://citeseer.ist.psu.edu/heintze01ultrafast.html     There are three types of real constraint expressions, DEREF,    ADDRESSOF, and SCALAR.  Each constraint expression consists    of a constraint type, a variable, and an offset.     SCALAR is a constraint expression type used to represent x, whether    it appears on the LHS or the RHS of a statement.    DEREF is a constraint expression type used to represent *x, whether    it appears on the LHS or the RHS of a statement.    ADDRESSOF is a constraint expression used to represent&x, whether    it appears on the LHS or the RHS of a statement.     Each pointer variable in the program is assigned an integer id, and    each field of a structure variable is assigned an integer id as well.     Structure variables are linked to their list of fields through a "next    field" in each variable that points to the next field in offset    order.    Each variable for a structure field has     1. "size", that tells the size in bits of that field.    2. "fullsize, that tells the size in bits of the entire structure.    3. "offset", that tells the offset in bits from the beginning of the    structure to this field.     Thus,    struct f    {      int a;      int b;    } foo;    int *bar;     looks like     foo.a -> id 1, size 32, offset 0, fullsize 64, next foo.b    foo.b -> id 2, size 32, offset 32, fullsize 64, next NULL    bar -> id 3, size 32, offset 0, fullsize 32, next NULL     In order to solve the system of set constraints, the following is   done:    1. Each constraint variable x has a solution set associated with it,   Sol(x).    2. Constraints are separated into direct, copy, and complex.   Direct constraints are ADDRESSOF constraints that require no extra   processing, such as P =&Q   Copy constraints are those of the form P = Q.   Complex constraints are all the constraints involving dereferences   and offsets (including offsetted copies).    3. All direct constraints of the form P =&Q are processed, such   that Q is added to Sol(P)    4. All complex constraints for a given constraint variable are stored in a   linked list attached to that variable's node.    5. A directed graph is built out of the copy constraints. Each   constraint variable is a node in the graph, and an edge from   Q to P is added for each copy constraint of the form P = Q    6. The graph is then walked, and solution sets are   propagated along the copy edges, such that an edge from Q to P   causes Sol(P)<- Sol(P) union Sol(Q).    7.  As we visit each node, all complex constraints associated with   that node are processed by adding appropriate copy edges to the graph, or the   appropriate variables to the solution set.    8. The process of walking the graph is iterated until no solution   sets change.    Prior to walking the graph in steps 6 and 7, We perform static   cycle elimination on the constraint graph, as well   as off-line variable substitution.    TODO: Adding offsets to pointer-to-structures can be handled (IE not punted   on and turned into anything), but isn't.  You can just see what offset   inside the pointed-to struct it's going to access.    TODO: Constant bounded arrays can be handled as if they were structs of the   same number of elements.    TODO: Modeling heap and incoming pointers becomes much better if we   add fields to them as we discover them, which we could do.    TODO: We could handle unions, but to be honest, it's probably not   worth the pain or slowdown.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(if_marked (
literal|"tree_map_marked_p"
argument|), param_is (struct tree_map))
argument_list|)
name|htab_t
name|heapvar_for_stmt
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* One variable to represent all non-local accesses.  */
end_comment

begin_decl_stmt
name|tree
name|nonlocal_all
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|use_field_sensitive
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_ipa_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for predecessor bitmaps. */
end_comment

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|predbitmap_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for points-to sets.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|pta_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for oldsolution members of variables. */
end_comment

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|oldpta_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for per-solver-iteration bitmaps.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap_obstack
name|iteration_obstack
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|int
name|create_variable_info_for
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|struct
name|constraint_graph
modifier|*
name|constraint_graph_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|unify_nodes
parameter_list|(
name|constraint_graph_t
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|constraint_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|EXECUTE_IF_IN_NONNULL_BITMAP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
define|\
value|if (a)						\     EXECUTE_IF_SET_IN_BITMAP (a, b, c, d)
end_define

begin_struct
specifier|static
struct|struct
name|constraint_stats
block|{
name|unsigned
name|int
name|total_vars
decl_stmt|;
name|unsigned
name|int
name|nonpointer_vars
decl_stmt|;
name|unsigned
name|int
name|unified_vars_static
decl_stmt|;
name|unsigned
name|int
name|unified_vars_dynamic
decl_stmt|;
name|unsigned
name|int
name|iterations
decl_stmt|;
name|unsigned
name|int
name|num_edges
decl_stmt|;
name|unsigned
name|int
name|num_implicit_edges
decl_stmt|;
name|unsigned
name|int
name|points_to_sets_created
decl_stmt|;
block|}
name|stats
struct|;
end_struct

begin_struct
struct|struct
name|variable_info
block|{
comment|/* ID of this variable  */
name|unsigned
name|int
name|id
decl_stmt|;
comment|/* Name of this variable */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Tree that this variable is associated with.  */
name|tree
name|decl
decl_stmt|;
comment|/* Offset of this variable, in bits, from the base variable  */
name|unsigned
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* Size of the variable, in bits.  */
name|unsigned
name|HOST_WIDE_INT
name|size
decl_stmt|;
comment|/* Full size of the base variable, in bits.  */
name|unsigned
name|HOST_WIDE_INT
name|fullsize
decl_stmt|;
comment|/* A link to the variable for the next field in this structure.  */
name|struct
name|variable_info
modifier|*
name|next
decl_stmt|;
comment|/* True if the variable is directly the target of a dereference.      This is used to track which variables are *actually* dereferenced      so we can prune their points to listed. */
name|unsigned
name|int
name|directly_dereferenced
range|:
literal|1
decl_stmt|;
comment|/* True if this is a variable created by the constraint analysis, such as      heap variables and constraints we had to break up.  */
name|unsigned
name|int
name|is_artificial_var
range|:
literal|1
decl_stmt|;
comment|/* True if this is a special variable whose solution set should not be      changed.  */
name|unsigned
name|int
name|is_special_var
range|:
literal|1
decl_stmt|;
comment|/* True for variables whose size is not known or variable.  */
name|unsigned
name|int
name|is_unknown_size_var
range|:
literal|1
decl_stmt|;
comment|/* True for variables that have unions somewhere in them.  */
name|unsigned
name|int
name|has_union
range|:
literal|1
decl_stmt|;
comment|/* True if this is a heap variable.  */
name|unsigned
name|int
name|is_heap_var
range|:
literal|1
decl_stmt|;
comment|/* Points-to set for this variable.  */
name|bitmap
name|solution
decl_stmt|;
comment|/* Old points-to set for this variable.  */
name|bitmap
name|oldsolution
decl_stmt|;
comment|/* Variable ids represented by this node.  */
name|bitmap
name|variables
decl_stmt|;
comment|/* Variable id this was collapsed to due to type unsafety.  This      should be unused completely after build_succ_graph, or something      is broken.  */
name|struct
name|variable_info
modifier|*
name|collapsed_to
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|variable_info
modifier|*
name|varinfo_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|varinfo_t
name|first_vi_for_offset
parameter_list|(
name|varinfo_t
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pool of variable info structures.  */
end_comment

begin_decl_stmt
specifier|static
name|alloc_pool
name|variable_info_pool
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEF_VEC_P
argument_list|(
name|varinfo_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_P
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Table of variable info structures for constraint variables.    Indexed directly by variable info id.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|)
operator|*
name|varmap
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return the varmap element N */
end_comment

begin_function
specifier|static
specifier|inline
name|varinfo_t
name|get_varinfo
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
return|return
name|VEC_index
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|,
name|n
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the varmap element N, following the collapsed_to link.  */
end_comment

begin_function
specifier|static
specifier|inline
name|varinfo_t
name|get_varinfo_fc
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|varinfo_t
name|v
init|=
name|VEC_index
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|,
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|collapsed_to
condition|)
return|return
name|v
operator|->
name|collapsed_to
return|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Variable that represents the unknown pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|varinfo_t
name|var_anything
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|anything_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|anything_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable that represents the NULL pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|varinfo_t
name|var_nothing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|nothing_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|nothing_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable that represents read only memory.  */
end_comment

begin_decl_stmt
specifier|static
name|varinfo_t
name|var_readonly
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|readonly_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|readonly_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable that represents integers.  This is used for when people do things    like&0->a.b.  */
end_comment

begin_decl_stmt
specifier|static
name|varinfo_t
name|var_integer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|integer_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|integer_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable that represents escaped variables.  This is used to give    incoming pointer variables a better set than ANYTHING.  */
end_comment

begin_decl_stmt
specifier|static
name|varinfo_t
name|var_escaped_vars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|escaped_vars_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|escaped_vars_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable that represents non-local variables before we expand it to    one for each type.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|nonlocal_vars_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lookup a heap var for FROM, and return it if we find one.  */
end_comment

begin_function
specifier|static
name|tree
name|heapvar_lookup
parameter_list|(
name|tree
name|from
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|,
name|in
decl_stmt|;
name|in
operator|.
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|=
name|htab_find_with_hash
argument_list|(
name|heapvar_for_stmt
argument_list|,
operator|&
name|in
argument_list|,
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
name|h
operator|->
name|to
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Insert a mapping FROM->TO in the heap var for statement    hashtable.  */
end_comment

begin_function
specifier|static
name|void
name|heapvar_insert
parameter_list|(
name|tree
name|from
parameter_list|,
name|tree
name|to
parameter_list|)
block|{
name|struct
name|tree_map
modifier|*
name|h
decl_stmt|;
name|void
modifier|*
modifier|*
name|loc
decl_stmt|;
name|h
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_map
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|hash
operator|=
name|htab_hash_pointer
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|h
operator|->
name|from
operator|=
name|from
expr_stmt|;
name|h
operator|->
name|to
operator|=
name|to
expr_stmt|;
name|loc
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|heapvar_for_stmt
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|hash
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|tree_map
operator|*
operator|*
operator|)
name|loc
operator|=
name|h
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a new variable info structure consisting for a variable    named NAME, and using constraint graph node NODE.  */
end_comment

begin_function
specifier|static
name|varinfo_t
name|new_var_info
parameter_list|(
name|tree
name|t
parameter_list|,
name|unsigned
name|int
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|varinfo_t
name|ret
init|=
name|pool_alloc
argument_list|(
name|variable_info_pool
argument_list|)
decl_stmt|;
name|ret
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|ret
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|ret
operator|->
name|decl
operator|=
name|t
expr_stmt|;
name|ret
operator|->
name|directly_dereferenced
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|is_artificial_var
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|is_heap_var
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|is_special_var
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|is_unknown_size_var
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|has_union
operator|=
name|false
expr_stmt|;
name|ret
operator|->
name|solution
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|pta_obstack
argument_list|)
expr_stmt|;
name|ret
operator|->
name|oldsolution
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|oldpta_obstack
argument_list|)
expr_stmt|;
name|ret
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ret
operator|->
name|collapsed_to
operator|=
name|NULL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|SCALAR
block|,
name|DEREF
block|,
name|ADDRESSOF
block|}
name|constraint_expr_type
typedef|;
end_typedef

begin_comment
comment|/* An expression that appears in a constraint.  */
end_comment

begin_struct
struct|struct
name|constraint_expr
block|{
comment|/* Constraint type.  */
name|constraint_expr_type
name|type
decl_stmt|;
comment|/* Variable we are referring to in the constraint.  */
name|unsigned
name|int
name|var
decl_stmt|;
comment|/* Offset, in bits, of this constraint from the beginning of      variables it ends up referring to.       IOW, in a deref constraint, we would deref, get the result set,      then add OFFSET to each member.   */
name|unsigned
name|HOST_WIDE_INT
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|constraint_expr
name|ce_s
typedef|;
end_typedef

begin_expr_stmt
name|DEF_VEC_O
argument_list|(
name|ce_s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_O
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|get_constraint_for
argument_list|(
name|tree
argument_list|,
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_deref
argument_list|(
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our set constraints are made up of two constraint expressions, one    LHS, and one RHS.     As described in the introduction, our set constraints each represent an    operation between set valued variables. */
end_comment

begin_struct
struct|struct
name|constraint
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|rhs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of constraints that we use to build the constraint graph from.  */
end_comment

begin_expr_stmt
specifier|static
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
name|constraints
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|alloc_pool
name|constraint_pool
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEF_VEC_I
argument_list|(
name|int
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_I
argument_list|(
name|int
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The constraint graph is represented as an array of bitmaps    containing successor nodes.  */
end_comment

begin_struct
struct|struct
name|constraint_graph
block|{
comment|/* Size of this graph, which may be different than the number of      nodes in the variable map.  */
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* Explicit successors of each node. */
name|bitmap
modifier|*
name|succs
decl_stmt|;
comment|/* Implicit predecessors of each node (Used for variable      substitution). */
name|bitmap
modifier|*
name|implicit_preds
decl_stmt|;
comment|/* Explicit predecessors of each node (Used for variable substitution).  */
name|bitmap
modifier|*
name|preds
decl_stmt|;
comment|/* Indirect cycle representatives, or -1 if the node has no indirect      cycles.  */
name|int
modifier|*
name|indirect_cycles
decl_stmt|;
comment|/* Representative node for a node.  rep[a] == a unless the node has      been unified. */
name|unsigned
name|int
modifier|*
name|rep
decl_stmt|;
comment|/* Equivalence class representative for a node.  This is used for      variable substitution.  */
name|int
modifier|*
name|eq_rep
decl_stmt|;
comment|/* Label for each node, used during variable substitution.  */
name|unsigned
name|int
modifier|*
name|label
decl_stmt|;
comment|/* Bitmap of nodes where the bit is set if the node is a direct      node.  Used for variable substitution.  */
name|sbitmap
name|direct_nodes
decl_stmt|;
comment|/* Vector of complex constraints for each graph node.  Complex      constraints are those involving dereferences or offsets that are      not 0.  */
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|complex
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|constraint_graph_t
name|graph
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During variable substitution and the offline version of indirect    cycle finding, we create nodes to represent dereferences and    address taken constraints.  These represent where these start and    end.  */
end_comment

begin_define
define|#
directive|define
name|FIRST_REF_NODE
value|(VEC_length (varinfo_t, varmap))
end_define

begin_define
define|#
directive|define
name|LAST_REF_NODE
value|(FIRST_REF_NODE + (FIRST_REF_NODE - 1))
end_define

begin_define
define|#
directive|define
name|FIRST_ADDR_NODE
value|(LAST_REF_NODE + 1)
end_define

begin_comment
comment|/* Return the representative node for NODE, if NODE has been unioned    with another NODE.    This function performs path compression along the way to finding    the representative.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|find
parameter_list|(
name|unsigned
name|int
name|node
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|node
operator|<
name|graph
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph
operator|->
name|rep
index|[
name|node
index|]
operator|!=
name|node
condition|)
return|return
name|graph
operator|->
name|rep
index|[
name|node
index|]
operator|=
name|find
argument_list|(
name|graph
operator|->
name|rep
index|[
name|node
index|]
argument_list|)
return|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Union the TO and FROM nodes to the TO nodes.    Note that at some point in the future, we may want to do    union-by-rank, in which case we are going to have to return the    node we unified to.  */
end_comment

begin_function
specifier|static
name|bool
name|unite
parameter_list|(
name|unsigned
name|int
name|to
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|to
operator|<
name|graph
operator|->
name|size
operator|&&
name|from
operator|<
name|graph
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|!=
name|from
operator|&&
name|graph
operator|->
name|rep
index|[
name|from
index|]
operator|!=
name|to
condition|)
block|{
name|graph
operator|->
name|rep
index|[
name|from
index|]
operator|=
name|to
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Create a new constraint consisting of LHS and RHS expressions.  */
end_comment

begin_function
specifier|static
name|constraint_t
name|new_constraint
parameter_list|(
specifier|const
name|struct
name|constraint_expr
name|lhs
parameter_list|,
specifier|const
name|struct
name|constraint_expr
name|rhs
parameter_list|)
block|{
name|constraint_t
name|ret
init|=
name|pool_alloc
argument_list|(
name|constraint_pool
argument_list|)
decl_stmt|;
name|ret
operator|->
name|lhs
operator|=
name|lhs
expr_stmt|;
name|ret
operator|->
name|rhs
operator|=
name|rhs
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Print out constraint C to FILE.  */
end_comment

begin_function
name|void
name|dump_constraint
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|constraint_t
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|lhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|lhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|get_varinfo_fc
argument_list|(
name|c
operator|->
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|lhs
operator|.
name|offset
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" + "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|c
operator|->
name|lhs
operator|.
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|get_varinfo_fc
argument_list|(
name|c
operator|->
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rhs
operator|.
name|offset
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" + "
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|c
operator|->
name|rhs
operator|.
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out constraint C to stderr.  */
end_comment

begin_function
name|void
name|debug_constraint
parameter_list|(
name|constraint_t
name|c
parameter_list|)
block|{
name|dump_constraint
argument_list|(
name|stderr
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out all constraints to FILE */
end_comment

begin_function
name|void
name|dump_constraints
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
name|constraints
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
name|dump_constraint
argument_list|(
name|file
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out all constraints to stderr.  */
end_comment

begin_function
name|void
name|debug_constraints
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_constraints
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* SOLVER FUNCTIONS     The solver is a simple worklist solver, that works on the following    algorithm:     sbitmap changed_nodes = all zeroes;    changed_count = 0;    For each node that is not already collapsed:        changed_count++;        set bit in changed nodes     while (changed_count> 0)    {      compute topological ordering for constraint graph       find and collapse cycles in the constraint graph (updating      changed if necessary)       for each node (n) in the graph in topological order:        changed_count--;         Process each complex constraint associated with the node,        updating changed if necessary.         For each outgoing edge from n, propagate the solution from n to        the destination of the edge, updating changed as necessary.     }  */
end_comment

begin_comment
comment|/* Return true if two constraint expressions A and B are equal.  */
end_comment

begin_function
specifier|static
name|bool
name|constraint_expr_equal
parameter_list|(
name|struct
name|constraint_expr
name|a
parameter_list|,
name|struct
name|constraint_expr
name|b
parameter_list|)
block|{
return|return
name|a
operator|.
name|type
operator|==
name|b
operator|.
name|type
operator|&&
name|a
operator|.
name|var
operator|==
name|b
operator|.
name|var
operator|&&
name|a
operator|.
name|offset
operator|==
name|b
operator|.
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Return true if constraint expression A is less than constraint expression    B.  This is just arbitrary, but consistent, in order to give them an    ordering.  */
end_comment

begin_function
specifier|static
name|bool
name|constraint_expr_less
parameter_list|(
name|struct
name|constraint_expr
name|a
parameter_list|,
name|struct
name|constraint_expr
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|type
operator|==
name|b
operator|.
name|type
condition|)
block|{
if|if
condition|(
name|a
operator|.
name|var
operator|==
name|b
operator|.
name|var
condition|)
return|return
name|a
operator|.
name|offset
operator|<
name|b
operator|.
name|offset
return|;
else|else
return|return
name|a
operator|.
name|var
operator|<
name|b
operator|.
name|var
return|;
block|}
else|else
return|return
name|a
operator|.
name|type
operator|<
name|b
operator|.
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return true if constraint A is less than constraint B.  This is just    arbitrary, but consistent, in order to give them an ordering.  */
end_comment

begin_function
specifier|static
name|bool
name|constraint_less
parameter_list|(
specifier|const
name|constraint_t
name|a
parameter_list|,
specifier|const
name|constraint_t
name|b
parameter_list|)
block|{
if|if
condition|(
name|constraint_expr_less
argument_list|(
name|a
operator|->
name|lhs
argument_list|,
name|b
operator|->
name|lhs
argument_list|)
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|constraint_expr_less
argument_list|(
name|b
operator|->
name|lhs
argument_list|,
name|a
operator|->
name|lhs
argument_list|)
condition|)
return|return
name|false
return|;
else|else
return|return
name|constraint_expr_less
argument_list|(
name|a
operator|->
name|rhs
argument_list|,
name|b
operator|->
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if two constraints A and B are equal.  */
end_comment

begin_function
specifier|static
name|bool
name|constraint_equal
parameter_list|(
name|struct
name|constraint
name|a
parameter_list|,
name|struct
name|constraint
name|b
parameter_list|)
block|{
return|return
name|constraint_expr_equal
argument_list|(
name|a
operator|.
name|lhs
argument_list|,
name|b
operator|.
name|lhs
argument_list|)
operator|&&
name|constraint_expr_equal
argument_list|(
name|a
operator|.
name|rhs
argument_list|,
name|b
operator|.
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find a constraint LOOKFOR in the sorted constraint vector VEC */
end_comment

begin_decl_stmt
specifier|static
name|constraint_t
name|constraint_vec_find
argument_list|(
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
name|vec
argument_list|,
expr|struct
name|constraint
name|lookfor
argument_list|)
block|{
name|unsigned
name|int
name|place
decl_stmt|;
name|constraint_t
name|found
decl_stmt|;
if|if
condition|(
name|vec
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|place
operator|=
name|VEC_lower_bound
argument_list|(
name|constraint_t
argument_list|,
name|vec
argument_list|,
operator|&
name|lookfor
argument_list|,
name|constraint_less
argument_list|)
expr_stmt|;
if|if
condition|(
name|place
operator|>=
name|VEC_length
argument_list|(
name|constraint_t
argument_list|,
name|vec
argument_list|)
condition|)
return|return
name|NULL
return|;
name|found
operator|=
name|VEC_index
argument_list|(
name|constraint_t
argument_list|,
name|vec
argument_list|,
name|place
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|constraint_equal
argument_list|(
operator|*
name|found
argument_list|,
name|lookfor
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|found
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Union two constraint vectors, TO and FROM.  Put the result in TO.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|constraint_set_union
argument_list|(
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|to
argument_list|,
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|from
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
operator|*
name|from
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|constraint_vec_find
argument_list|(
operator|*
name|to
argument_list|,
operator|*
name|c
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|int
name|place
init|=
name|VEC_lower_bound
argument_list|(
name|constraint_t
argument_list|,
operator|*
name|to
argument_list|,
name|c
argument_list|,
name|constraint_less
argument_list|)
decl_stmt|;
name|VEC_safe_insert
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
operator|*
name|to
argument_list|,
name|place
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Take a solution set SET, add OFFSET to each member of the set, and    overwrite SET with the result when done.  */
end_comment

begin_function
specifier|static
name|void
name|solution_set_add
parameter_list|(
name|bitmap
name|set
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|bitmap
name|result
init|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|min
init|=
operator|-
literal|1
decl_stmt|,
name|max
init|=
literal|0
decl_stmt|;
comment|/* Compute set of vars we can reach from set + offset.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|set
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|is_artificial_var
operator|||
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|has_union
operator|||
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|is_unknown_size_var
condition|)
continue|continue;
if|if
condition|(
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|offset
operator|+
name|offset
operator|<
name|min
condition|)
name|min
operator|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|offset
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|offset
operator|+
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|size
operator|+
name|offset
operator|>
name|max
condition|)
block|{
name|max
operator|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|offset
operator|+
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|size
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|max
operator|>
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|fullsize
condition|)
name|max
operator|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|fullsize
expr_stmt|;
block|}
block|}
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|set
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
comment|/* If this is a properly sized variable, only add offset if it's 	 less than end.  Otherwise, it is globbed to a single 	 variable.  */
if|if
condition|(
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|offset
operator|+
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|size
operator|-
literal|1
operator|>=
name|min
operator|&&
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|offset
operator|<
name|max
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|result
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|is_artificial_var
operator|||
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|has_union
operator|||
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|is_unknown_size_var
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|result
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|bitmap_copy
argument_list|(
name|set
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Union solution sets TO and FROM, and add INC to each member of FROM in the    process.  */
end_comment

begin_function
specifier|static
name|bool
name|set_union_with_increment
parameter_list|(
name|bitmap
name|to
parameter_list|,
name|bitmap
name|from
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|inc
parameter_list|)
block|{
if|if
condition|(
name|inc
operator|==
literal|0
condition|)
return|return
name|bitmap_ior_into
argument_list|(
name|to
argument_list|,
name|from
argument_list|)
return|;
else|else
block|{
name|bitmap
name|tmp
decl_stmt|;
name|bool
name|res
decl_stmt|;
name|tmp
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
expr_stmt|;
name|bitmap_copy
argument_list|(
name|tmp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|solution_set_add
argument_list|(
name|tmp
argument_list|,
name|inc
argument_list|)
expr_stmt|;
name|res
operator|=
name|bitmap_ior_into
argument_list|(
name|to
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
end_function

begin_comment
comment|/* Insert constraint C into the list of complex constraints for graph    node VAR.  */
end_comment

begin_function
specifier|static
name|void
name|insert_into_complex
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|var
parameter_list|,
name|constraint_t
name|c
parameter_list|)
block|{
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
name|complex
operator|=
name|graph
operator|->
name|complex
index|[
name|var
index|]
expr_stmt|;
name|unsigned
name|int
name|place
init|=
name|VEC_lower_bound
argument_list|(
name|constraint_t
argument_list|,
name|complex
argument_list|,
name|c
argument_list|,
name|constraint_less
argument_list|)
decl_stmt|;
comment|/* Only insert constraints that do not already exist.  */
if|if
condition|(
name|place
operator|>=
name|VEC_length
argument_list|(
name|constraint_t
argument_list|,
name|complex
argument_list|)
operator|||
operator|!
name|constraint_equal
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|VEC_index
argument_list|(
name|constraint_t
argument_list|,
name|complex
argument_list|,
name|place
argument_list|)
argument_list|)
condition|)
name|VEC_safe_insert
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|graph
operator|->
name|complex
index|[
name|var
index|]
argument_list|,
name|place
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Condense two variable nodes into a single variable node, by moving    all associated info from SRC to TO.  */
end_comment

begin_function
specifier|static
name|void
name|merge_node_constraints
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
name|gcc_assert
argument_list|(
name|find
argument_list|(
name|from
argument_list|)
operator|==
name|to
argument_list|)
expr_stmt|;
comment|/* Move all complex constraints from src node into to node  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
name|graph
operator|->
name|complex
index|[
name|from
index|]
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* In complex constraints for node src, we may have either 	 a = *src, and *src = a, or an offseted constraint which are 	 always added to the rhs node's constraints.  */
if|if
condition|(
name|c
operator|->
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|c
operator|->
name|rhs
operator|.
name|var
operator|=
name|to
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|lhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|c
operator|->
name|lhs
operator|.
name|var
operator|=
name|to
expr_stmt|;
else|else
name|c
operator|->
name|rhs
operator|.
name|var
operator|=
name|to
expr_stmt|;
block|}
name|constraint_set_union
argument_list|(
operator|&
name|graph
operator|->
name|complex
index|[
name|to
index|]
argument_list|,
operator|&
name|graph
operator|->
name|complex
index|[
name|from
index|]
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|graph
operator|->
name|complex
index|[
name|from
index|]
argument_list|)
expr_stmt|;
name|graph
operator|->
name|complex
index|[
name|from
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove edges involving NODE from GRAPH.  */
end_comment

begin_function
specifier|static
name|void
name|clear_edges_for_node
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|node
parameter_list|)
block|{
if|if
condition|(
name|graph
operator|->
name|succs
index|[
name|node
index|]
condition|)
name|BITMAP_FREE
argument_list|(
name|graph
operator|->
name|succs
index|[
name|node
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Merge GRAPH nodes FROM and TO into node TO.  */
end_comment

begin_function
specifier|static
name|void
name|merge_graph_nodes
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|)
block|{
if|if
condition|(
name|graph
operator|->
name|indirect_cycles
index|[
name|from
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If we have indirect cycles with the from node, and we have 	 none on the to node, the to node has indirect cycles from the 	 from node now that they are unified. 	 If indirect cycles exist on both, unify the nodes that they 	 are in a cycle with, since we know they are in a cycle with 	 each other.  */
if|if
condition|(
name|graph
operator|->
name|indirect_cycles
index|[
name|to
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|graph
operator|->
name|indirect_cycles
index|[
name|to
index|]
operator|=
name|graph
operator|->
name|indirect_cycles
index|[
name|from
index|]
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|tonode
init|=
name|find
argument_list|(
name|graph
operator|->
name|indirect_cycles
index|[
name|to
index|]
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|fromnode
init|=
name|find
argument_list|(
name|graph
operator|->
name|indirect_cycles
index|[
name|from
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|unite
argument_list|(
name|tonode
argument_list|,
name|fromnode
argument_list|)
condition|)
name|unify_nodes
argument_list|(
name|graph
argument_list|,
name|tonode
argument_list|,
name|fromnode
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Merge all the successor edges.  */
if|if
condition|(
name|graph
operator|->
name|succs
index|[
name|from
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|graph
operator|->
name|succs
index|[
name|to
index|]
condition|)
name|graph
operator|->
name|succs
index|[
name|to
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|pta_obstack
argument_list|)
expr_stmt|;
name|bitmap_ior_into
argument_list|(
name|graph
operator|->
name|succs
index|[
name|to
index|]
argument_list|,
name|graph
operator|->
name|succs
index|[
name|from
index|]
argument_list|)
expr_stmt|;
block|}
name|clear_edges_for_node
argument_list|(
name|graph
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an indirect graph edge to GRAPH, going from TO to FROM if    it doesn't exist in the graph already.  */
end_comment

begin_function
specifier|static
name|void
name|add_implicit_graph_edge
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|)
block|{
if|if
condition|(
name|to
operator|==
name|from
condition|)
return|return;
if|if
condition|(
operator|!
name|graph
operator|->
name|implicit_preds
index|[
name|to
index|]
condition|)
name|graph
operator|->
name|implicit_preds
index|[
name|to
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|predbitmap_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|graph
operator|->
name|implicit_preds
index|[
name|to
index|]
argument_list|,
name|from
argument_list|)
condition|)
block|{
name|stats
operator|.
name|num_implicit_edges
operator|++
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|graph
operator|->
name|implicit_preds
index|[
name|to
index|]
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a predecessor graph edge to GRAPH, going from TO to FROM if    it doesn't exist in the graph already.    Return false if the edge already existed, true otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|add_pred_graph_edge
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|)
block|{
if|if
condition|(
operator|!
name|graph
operator|->
name|preds
index|[
name|to
index|]
condition|)
name|graph
operator|->
name|preds
index|[
name|to
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|predbitmap_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|graph
operator|->
name|preds
index|[
name|to
index|]
argument_list|,
name|from
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|graph
operator|->
name|preds
index|[
name|to
index|]
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a graph edge to GRAPH, going from FROM to TO if    it doesn't exist in the graph already.    Return false if the edge already existed, true otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|add_graph_edge
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|)
block|{
if|if
condition|(
name|to
operator|==
name|from
condition|)
block|{
return|return
name|false
return|;
block|}
else|else
block|{
name|bool
name|r
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|graph
operator|->
name|succs
index|[
name|from
index|]
condition|)
name|graph
operator|->
name|succs
index|[
name|from
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|pta_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|graph
operator|->
name|succs
index|[
name|from
index|]
argument_list|,
name|to
argument_list|)
condition|)
block|{
name|r
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|to
operator|<
name|FIRST_REF_NODE
operator|&&
name|from
operator|<
name|FIRST_REF_NODE
condition|)
name|stats
operator|.
name|num_edges
operator|++
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|graph
operator|->
name|succs
index|[
name|from
index|]
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if {DEST.SRC} is an existing graph edge in GRAPH.  */
end_comment

begin_function
specifier|static
name|bool
name|valid_graph_edge
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|src
parameter_list|,
name|unsigned
name|int
name|dest
parameter_list|)
block|{
return|return
operator|(
name|graph
operator|->
name|succs
index|[
name|dest
index|]
operator|&&
name|bitmap_bit_p
argument_list|(
name|graph
operator|->
name|succs
index|[
name|dest
index|]
argument_list|,
name|src
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Build the constraint graph, adding only predecessor edges right now.  */
end_comment

begin_function
specifier|static
name|void
name|build_pred_graph
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|graph
operator|=
name|XNEW
argument_list|(
expr|struct
name|constraint_graph
argument_list|)
expr_stmt|;
name|graph
operator|->
name|size
operator|=
operator|(
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
operator|)
operator|*
literal|3
expr_stmt|;
name|graph
operator|->
name|succs
operator|=
name|XCNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|graph
operator|->
name|size
argument_list|)
expr_stmt|;
name|graph
operator|->
name|implicit_preds
operator|=
name|XCNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|graph
operator|->
name|size
argument_list|)
expr_stmt|;
name|graph
operator|->
name|preds
operator|=
name|XCNEWVEC
argument_list|(
name|bitmap
argument_list|,
name|graph
operator|->
name|size
argument_list|)
expr_stmt|;
name|graph
operator|->
name|indirect_cycles
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|->
name|label
operator|=
name|XCNEWVEC
argument_list|(
argument|unsigned int
argument_list|,
argument|graph->size
argument_list|)
expr_stmt|;
name|graph
operator|->
name|rep
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned int
argument_list|,
argument|graph->size
argument_list|)
expr_stmt|;
name|graph
operator|->
name|eq_rep
operator|=
name|XNEWVEC
argument_list|(
name|int
argument_list|,
name|graph
operator|->
name|size
argument_list|)
expr_stmt|;
name|graph
operator|->
name|complex
operator|=
name|XCNEWVEC
argument_list|(
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
argument_list|,
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
argument_list|)
expr_stmt|;
name|graph
operator|->
name|direct_nodes
operator|=
name|sbitmap_alloc
argument_list|(
name|graph
operator|->
name|size
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|FIRST_REF_NODE
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|is_special_var
condition|)
name|SET_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|graph
operator|->
name|size
condition|;
name|j
operator|++
control|)
block|{
name|graph
operator|->
name|rep
index|[
name|j
index|]
operator|=
name|j
expr_stmt|;
name|graph
operator|->
name|eq_rep
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
condition|;
name|j
operator|++
control|)
name|graph
operator|->
name|indirect_cycles
index|[
name|j
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
name|constraints
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|constraint_expr
name|lhs
init|=
name|c
operator|->
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|rhs
init|=
name|c
operator|->
name|rhs
decl_stmt|;
name|unsigned
name|int
name|lhsvar
init|=
name|get_varinfo_fc
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|id
decl_stmt|;
name|unsigned
name|int
name|rhsvar
init|=
name|get_varinfo_fc
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|id
decl_stmt|;
if|if
condition|(
name|lhs
operator|.
name|type
operator|==
name|DEREF
condition|)
block|{
comment|/* *x = y.  */
if|if
condition|(
name|rhs
operator|.
name|offset
operator|==
literal|0
operator|&&
name|lhs
operator|.
name|offset
operator|==
literal|0
operator|&&
name|rhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
name|add_pred_graph_edge
argument_list|(
name|graph
argument_list|,
name|FIRST_REF_NODE
operator|+
name|lhsvar
argument_list|,
name|rhsvar
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
name|RESET_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|rhsvar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
block|{
comment|/* x = *y */
if|if
condition|(
name|rhs
operator|.
name|offset
operator|==
literal|0
operator|&&
name|lhs
operator|.
name|offset
operator|==
literal|0
operator|&&
name|lhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
name|add_pred_graph_edge
argument_list|(
name|graph
argument_list|,
name|lhsvar
argument_list|,
name|FIRST_REF_NODE
operator|+
name|rhsvar
argument_list|)
expr_stmt|;
else|else
name|RESET_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|lhsvar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
block|{
comment|/* x =&y */
name|add_pred_graph_edge
argument_list|(
name|graph
argument_list|,
name|lhsvar
argument_list|,
name|FIRST_ADDR_NODE
operator|+
name|rhsvar
argument_list|)
expr_stmt|;
comment|/* Implicitly, *x = y */
name|add_implicit_graph_edge
argument_list|(
name|graph
argument_list|,
name|FIRST_REF_NODE
operator|+
name|lhsvar
argument_list|,
name|rhsvar
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|rhsvar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lhsvar
operator|>
name|anything_id
operator|&&
name|lhsvar
operator|!=
name|rhsvar
operator|&&
name|lhs
operator|.
name|offset
operator|==
literal|0
operator|&&
name|rhs
operator|.
name|offset
operator|==
literal|0
condition|)
block|{
comment|/* x = y */
name|add_pred_graph_edge
argument_list|(
name|graph
argument_list|,
name|lhsvar
argument_list|,
name|rhsvar
argument_list|)
expr_stmt|;
comment|/* Implicitly, *x = *y */
name|add_implicit_graph_edge
argument_list|(
name|graph
argument_list|,
name|FIRST_REF_NODE
operator|+
name|lhsvar
argument_list|,
name|FIRST_REF_NODE
operator|+
name|rhsvar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lhs
operator|.
name|offset
operator|!=
literal|0
operator|||
name|rhs
operator|.
name|offset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rhs
operator|.
name|offset
operator|!=
literal|0
condition|)
name|RESET_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|lhs
operator|.
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|.
name|offset
operator|!=
literal|0
condition|)
name|RESET_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|rhs
operator|.
name|var
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Build the constraint graph, adding successor edges.  */
end_comment

begin_function
specifier|static
name|void
name|build_succ_graph
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
name|constraints
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|rhs
decl_stmt|;
name|unsigned
name|int
name|lhsvar
decl_stmt|;
name|unsigned
name|int
name|rhsvar
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
continue|continue;
name|lhs
operator|=
name|c
operator|->
name|lhs
expr_stmt|;
name|rhs
operator|=
name|c
operator|->
name|rhs
expr_stmt|;
name|lhsvar
operator|=
name|find
argument_list|(
name|get_varinfo_fc
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|id
argument_list|)
expr_stmt|;
name|rhsvar
operator|=
name|find
argument_list|(
name|get_varinfo_fc
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|.
name|type
operator|==
name|DEREF
condition|)
block|{
if|if
condition|(
name|rhs
operator|.
name|offset
operator|==
literal|0
operator|&&
name|lhs
operator|.
name|offset
operator|==
literal|0
operator|&&
name|rhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
name|add_graph_edge
argument_list|(
name|graph
argument_list|,
name|FIRST_REF_NODE
operator|+
name|lhsvar
argument_list|,
name|rhsvar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
block|{
if|if
condition|(
name|rhs
operator|.
name|offset
operator|==
literal|0
operator|&&
name|lhs
operator|.
name|offset
operator|==
literal|0
operator|&&
name|lhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
name|add_graph_edge
argument_list|(
name|graph
argument_list|,
name|lhsvar
argument_list|,
name|FIRST_REF_NODE
operator|+
name|rhsvar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
block|{
comment|/* x =&y */
name|gcc_assert
argument_list|(
name|find
argument_list|(
name|get_varinfo_fc
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|id
argument_list|)
operator|==
name|get_varinfo_fc
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|id
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|get_varinfo
argument_list|(
name|lhsvar
argument_list|)
operator|->
name|solution
argument_list|,
name|rhsvar
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lhsvar
operator|>
name|anything_id
operator|&&
name|lhsvar
operator|!=
name|rhsvar
operator|&&
name|lhs
operator|.
name|offset
operator|==
literal|0
operator|&&
name|rhs
operator|.
name|offset
operator|==
literal|0
condition|)
block|{
name|add_graph_edge
argument_list|(
name|graph
argument_list|,
name|lhsvar
argument_list|,
name|rhsvar
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Changed variables on the last iteration.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|changed_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
name|changed
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEF_VEC_I
argument_list|(
name|unsigned
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_I
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Strongly Connected Component visitation info.  */
end_comment

begin_struct
struct|struct
name|scc_info
block|{
name|sbitmap
name|visited
decl_stmt|;
name|sbitmap
name|roots
decl_stmt|;
name|unsigned
name|int
modifier|*
name|dfs
decl_stmt|;
name|unsigned
name|int
modifier|*
name|node_mapping
decl_stmt|;
name|int
name|current_index
decl_stmt|;
name|VEC
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|)
operator|*
name|scc_stack
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Recursive routine to find strongly connected components in GRAPH.    SI is the SCC info to store the information in, and N is the id of current    graph node we are processing.     This is Tarjan's strongly connected component finding algorithm, as    modified by Nuutila to keep only non-root nodes on the stack.    The algorithm can be found in "On finding the strongly connected    connected components in a directed graph" by Esko Nuutila and Eljas    Soisalon-Soininen, in Information Processing Letters volume 49,    number 1, pages 9-14.  */
end_comment

begin_function
specifier|static
name|void
name|scc_visit
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|struct
name|scc_info
modifier|*
name|si
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|my_dfs
decl_stmt|;
name|SET_BIT
argument_list|(
name|si
operator|->
name|visited
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|si
operator|->
name|dfs
index|[
name|n
index|]
operator|=
name|si
operator|->
name|current_index
operator|++
expr_stmt|;
name|my_dfs
operator|=
name|si
operator|->
name|dfs
index|[
name|n
index|]
expr_stmt|;
comment|/* Visit all the successors.  */
name|EXECUTE_IF_IN_NONNULL_BITMAP
argument_list|(
argument|graph->succs[n]
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|int
name|w
decl_stmt|;
if|if
condition|(
name|i
operator|>
name|LAST_REF_NODE
condition|)
break|break;
name|w
operator|=
name|find
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|si
operator|->
name|roots
argument_list|,
name|w
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|si
operator|->
name|visited
argument_list|,
name|w
argument_list|)
condition|)
name|scc_visit
argument_list|(
name|graph
argument_list|,
name|si
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|{
name|unsigned
name|int
name|t
init|=
name|find
argument_list|(
name|w
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|nnode
init|=
name|find
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|nnode
operator|==
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|dfs
index|[
name|t
index|]
operator|<
name|si
operator|->
name|dfs
index|[
name|nnode
index|]
condition|)
name|si
operator|->
name|dfs
index|[
name|n
index|]
operator|=
name|si
operator|->
name|dfs
index|[
name|t
index|]
expr_stmt|;
block|}
block|}
comment|/* See if any components have been identified.  */
if|if
condition|(
name|si
operator|->
name|dfs
index|[
name|n
index|]
operator|==
name|my_dfs
condition|)
block|{
if|if
condition|(
name|VEC_length
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
operator|>
literal|0
operator|&&
name|si
operator|->
name|dfs
index|[
name|VEC_last
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
index|]
operator|>=
name|my_dfs
condition|)
block|{
name|bitmap
name|scc
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|bool
name|have_ref_node
init|=
name|n
operator|>=
name|FIRST_REF_NODE
decl_stmt|;
name|unsigned
name|int
name|lowest_node
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|scc
argument_list|,
name|n
argument_list|)
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
operator|!=
literal|0
operator|&&
name|si
operator|->
name|dfs
index|[
name|VEC_last
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
index|]
operator|>=
name|my_dfs
condition|)
block|{
name|unsigned
name|int
name|w
init|=
name|VEC_pop
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|scc
argument_list|,
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|>=
name|FIRST_REF_NODE
condition|)
name|have_ref_node
operator|=
name|true
expr_stmt|;
block|}
name|lowest_node
operator|=
name|bitmap_first_set_bit
argument_list|(
name|scc
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|lowest_node
operator|<
name|FIRST_REF_NODE
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|scc
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
name|i
operator|<
name|FIRST_REF_NODE
condition|)
block|{
comment|/* Mark this node for collapsing.  */
if|if
condition|(
name|unite
argument_list|(
name|lowest_node
argument_list|,
name|i
argument_list|)
condition|)
name|unify_nodes
argument_list|(
name|graph
argument_list|,
name|lowest_node
argument_list|,
name|i
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unite
argument_list|(
name|lowest_node
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|graph
operator|->
name|indirect_cycles
index|[
name|i
operator|-
name|FIRST_REF_NODE
index|]
operator|=
name|lowest_node
expr_stmt|;
block|}
block|}
block|}
name|SET_BIT
argument_list|(
name|si
operator|->
name|roots
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
name|VEC_safe_push
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unify node FROM into node TO, updating the changed count if    necessary when UPDATE_CHANGED is true.  */
end_comment

begin_function
specifier|static
name|void
name|unify_nodes
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|to
parameter_list|,
name|unsigned
name|int
name|from
parameter_list|,
name|bool
name|update_changed
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|to
operator|!=
name|from
operator|&&
name|find
argument_list|(
name|to
argument_list|)
operator|==
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Unifying %s to %s\n"
argument_list|,
name|get_varinfo
argument_list|(
name|from
argument_list|)
operator|->
name|name
argument_list|,
name|get_varinfo
argument_list|(
name|to
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_changed
condition|)
name|stats
operator|.
name|unified_vars_dynamic
operator|++
expr_stmt|;
else|else
name|stats
operator|.
name|unified_vars_static
operator|++
expr_stmt|;
name|merge_graph_nodes
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|merge_node_constraints
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_changed
operator|&&
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|from
argument_list|)
condition|)
block|{
name|RESET_BIT
argument_list|(
name|changed
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|to
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|to
argument_list|)
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|changed_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|changed_count
operator|--
expr_stmt|;
block|}
block|}
comment|/* If the solution changes because of the merging, we need to mark      the variable as changed.  */
if|if
condition|(
name|bitmap_ior_into
argument_list|(
name|get_varinfo
argument_list|(
name|to
argument_list|)
operator|->
name|solution
argument_list|,
name|get_varinfo
argument_list|(
name|from
argument_list|)
operator|->
name|solution
argument_list|)
condition|)
block|{
if|if
condition|(
name|update_changed
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|to
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
name|BITMAP_FREE
argument_list|(
name|get_varinfo
argument_list|(
name|from
argument_list|)
operator|->
name|solution
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|get_varinfo
argument_list|(
name|from
argument_list|)
operator|->
name|oldsolution
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|.
name|iterations
operator|>
literal|0
condition|)
block|{
name|BITMAP_FREE
argument_list|(
name|get_varinfo
argument_list|(
name|to
argument_list|)
operator|->
name|oldsolution
argument_list|)
expr_stmt|;
name|get_varinfo
argument_list|(
name|to
argument_list|)
operator|->
name|oldsolution
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|oldpta_obstack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid_graph_edge
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|to
argument_list|)
condition|)
block|{
if|if
condition|(
name|graph
operator|->
name|succs
index|[
name|to
index|]
condition|)
name|bitmap_clear_bit
argument_list|(
name|graph
operator|->
name|succs
index|[
name|to
index|]
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Information needed to compute the topological ordering of a graph.  */
end_comment

begin_struct
struct|struct
name|topo_info
block|{
comment|/* sbitmap of visited nodes.  */
name|sbitmap
name|visited
decl_stmt|;
comment|/* Array that stores the topological order of the graph, *in      reverse*.  */
name|VEC
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|)
operator|*
name|topo_order
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Initialize and return a topological info structure.  */
end_comment

begin_function
specifier|static
name|struct
name|topo_info
modifier|*
name|init_topo_info
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|size
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|struct
name|topo_info
modifier|*
name|ti
init|=
name|XNEW
argument_list|(
expr|struct
name|topo_info
argument_list|)
decl_stmt|;
name|ti
operator|->
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|ti
operator|->
name|visited
argument_list|)
expr_stmt|;
name|ti
operator|->
name|topo_order
operator|=
name|VEC_alloc
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ti
return|;
block|}
end_function

begin_comment
comment|/* Free the topological sort info pointed to by TI.  */
end_comment

begin_function
specifier|static
name|void
name|free_topo_info
parameter_list|(
name|struct
name|topo_info
modifier|*
name|ti
parameter_list|)
block|{
name|sbitmap_free
argument_list|(
name|ti
operator|->
name|visited
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|ti
operator|->
name|topo_order
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Visit the graph in topological order, and store the order in the    topo_info structure.  */
end_comment

begin_function
specifier|static
name|void
name|topo_visit
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|struct
name|topo_info
modifier|*
name|ti
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|SET_BIT
argument_list|(
name|ti
operator|->
name|visited
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph
operator|->
name|succs
index|[
name|n
index|]
condition|)
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|graph->succs[n]
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|ti
operator|->
name|visited
argument_list|,
name|j
argument_list|)
condition|)
name|topo_visit
argument_list|(
name|graph
argument_list|,
name|ti
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|VEC_safe_push
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|ti
operator|->
name|topo_order
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if variable N + OFFSET is a legal field of N.  */
end_comment

begin_function
specifier|static
name|bool
name|type_safe
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|offset
parameter_list|)
block|{
name|varinfo_t
name|ninfo
init|=
name|get_varinfo
argument_list|(
name|n
argument_list|)
decl_stmt|;
comment|/* For things we've globbed to single variables, any offset into the      variable acts like the entire variable, so that it becomes offset      0.  */
if|if
condition|(
name|ninfo
operator|->
name|is_special_var
operator|||
name|ninfo
operator|->
name|is_artificial_var
operator|||
name|ninfo
operator|->
name|is_unknown_size_var
condition|)
block|{
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
operator|(
name|get_varinfo
argument_list|(
name|n
argument_list|)
operator|->
name|offset
operator|+
operator|*
name|offset
operator|)
operator|<
name|get_varinfo
argument_list|(
name|n
argument_list|)
operator|->
name|fullsize
return|;
block|}
end_function

begin_comment
comment|/* Process a constraint C that represents *x =&y.  */
end_comment

begin_function
specifier|static
name|void
name|do_da_constraint
parameter_list|(
name|constraint_graph_t
name|graph
name|ATTRIBUTE_UNUSED
parameter_list|,
name|constraint_t
name|c
parameter_list|,
name|bitmap
name|delta
parameter_list|)
block|{
name|unsigned
name|int
name|rhs
init|=
name|c
operator|->
name|rhs
operator|.
name|var
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* For each member j of Delta (Sol(x)), add x to Sol(j)  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|delta
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|offset
init|=
name|c
operator|->
name|lhs
operator|.
name|offset
decl_stmt|;
if|if
condition|(
name|type_safe
argument_list|(
name|j
argument_list|,
operator|&
name|offset
argument_list|)
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
block|{
comment|/* *x != NULL&& *x != ANYTHING*/
name|varinfo_t
name|v
decl_stmt|;
name|unsigned
name|int
name|t
decl_stmt|;
name|bitmap
name|sol
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
init|=
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|offset
operator|+
name|offset
decl_stmt|;
name|v
operator|=
name|first_vi_for_offset
argument_list|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
argument_list|,
name|fieldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
name|t
operator|=
name|find
argument_list|(
name|v
operator|->
name|id
argument_list|)
expr_stmt|;
name|sol
operator|=
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|sol
argument_list|,
name|rhs
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|sol
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
literal|0
operator|&&
name|dump_file
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Untypesafe usage in do_da_constraint.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a constraint C that represents x = *y, using DELTA as the    starting solution.  */
end_comment

begin_function
specifier|static
name|void
name|do_sd_constraint
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|constraint_t
name|c
parameter_list|,
name|bitmap
name|delta
parameter_list|)
block|{
name|unsigned
name|int
name|lhs
init|=
name|find
argument_list|(
name|c
operator|->
name|lhs
operator|.
name|var
argument_list|)
decl_stmt|;
name|bool
name|flag
init|=
name|false
decl_stmt|;
name|bitmap
name|sol
init|=
name|get_varinfo
argument_list|(
name|lhs
argument_list|)
operator|->
name|solution
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|delta
argument_list|,
name|anything_id
argument_list|)
condition|)
block|{
name|flag
operator|=
operator|!
name|bitmap_bit_p
argument_list|(
name|sol
argument_list|,
name|anything_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|bitmap_set_bit
argument_list|(
name|sol
argument_list|,
name|anything_id
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* For each variable j in delta (Sol(y)), add      an edge in the graph from j to x, and union Sol(j) into Sol(x).  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|delta
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|roffset
init|=
name|c
operator|->
name|rhs
operator|.
name|offset
decl_stmt|;
if|if
condition|(
name|type_safe
argument_list|(
name|j
argument_list|,
operator|&
name|roffset
argument_list|)
condition|)
block|{
name|varinfo_t
name|v
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
init|=
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|offset
operator|+
name|roffset
decl_stmt|;
name|unsigned
name|int
name|t
decl_stmt|;
name|v
operator|=
name|first_vi_for_offset
argument_list|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
argument_list|,
name|fieldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
name|t
operator|=
name|find
argument_list|(
name|v
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* Adding edges from the special vars is pointless. 	     They don't have sets that can change.  */
if|if
condition|(
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|is_special_var
condition|)
name|flag
operator||=
name|bitmap_ior_into
argument_list|(
name|sol
argument_list|,
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|add_graph_edge
argument_list|(
name|graph
argument_list|,
name|lhs
argument_list|,
name|t
argument_list|)
condition|)
name|flag
operator||=
name|bitmap_ior_into
argument_list|(
name|sol
argument_list|,
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|&&
name|dump_file
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Untypesafe usage in do_sd_constraint\n"
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* If the LHS solution changed, mark the var as changed.  */
if|if
condition|(
name|flag
condition|)
block|{
name|get_varinfo
argument_list|(
name|lhs
argument_list|)
operator|->
name|solution
operator|=
name|sol
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|lhs
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process a constraint C that represents *x = y.  */
end_comment

begin_function
specifier|static
name|void
name|do_ds_constraint
parameter_list|(
name|constraint_t
name|c
parameter_list|,
name|bitmap
name|delta
parameter_list|)
block|{
name|unsigned
name|int
name|rhs
init|=
name|find
argument_list|(
name|c
operator|->
name|rhs
operator|.
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|roff
init|=
name|c
operator|->
name|rhs
operator|.
name|offset
decl_stmt|;
name|bitmap
name|sol
init|=
name|get_varinfo
argument_list|(
name|rhs
argument_list|)
operator|->
name|solution
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|sol
argument_list|,
name|anything_id
argument_list|)
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|delta
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|varinfo_t
name|jvi
init|=
name|get_varinfo
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|t
decl_stmt|;
name|unsigned
name|int
name|loff
init|=
name|c
operator|->
name|lhs
operator|.
name|offset
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
init|=
name|jvi
operator|->
name|offset
operator|+
name|loff
decl_stmt|;
name|varinfo_t
name|v
decl_stmt|;
name|v
operator|=
name|first_vi_for_offset
argument_list|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
argument_list|,
name|fieldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
name|t
operator|=
name|find
argument_list|(
name|v
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
argument_list|,
name|anything_id
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
argument_list|,
name|anything_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
comment|/* For each member j of delta (Sol(x)), add an edge from y to j and      union Sol(y) into Sol(j) */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|delta
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|loff
init|=
name|c
operator|->
name|lhs
operator|.
name|offset
decl_stmt|;
if|if
condition|(
name|type_safe
argument_list|(
name|j
argument_list|,
operator|&
name|loff
argument_list|)
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
block|{
name|varinfo_t
name|v
decl_stmt|;
name|unsigned
name|int
name|t
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
init|=
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|offset
operator|+
name|loff
decl_stmt|;
name|bitmap
name|tmp
decl_stmt|;
name|v
operator|=
name|first_vi_for_offset
argument_list|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
argument_list|,
name|fieldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
continue|continue;
name|t
operator|=
name|find
argument_list|(
name|v
operator|->
name|id
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
expr_stmt|;
if|if
condition|(
name|set_union_with_increment
argument_list|(
name|tmp
argument_list|,
name|sol
argument_list|,
name|roff
argument_list|)
condition|)
block|{
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|rhs
condition|)
name|sol
operator|=
name|get_varinfo
argument_list|(
name|rhs
argument_list|)
operator|->
name|solution
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
literal|0
operator|&&
name|dump_file
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|j
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Untypesafe usage in do_ds_constraint\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a non-simple (simple meaning requires no iteration),    constraint (IE *x =&y, x = *y, *x = y, and x = y with offsets involved).  */
end_comment

begin_function
specifier|static
name|void
name|do_complex_constraint
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|constraint_t
name|c
parameter_list|,
name|bitmap
name|delta
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|lhs
operator|.
name|type
operator|==
name|DEREF
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
block|{
comment|/* *x =&y */
name|do_da_constraint
argument_list|(
name|graph
argument_list|,
name|c
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* *x = y */
name|do_ds_constraint
argument_list|(
name|c
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
block|{
comment|/* x = *y */
if|if
condition|(
operator|!
operator|(
name|get_varinfo
argument_list|(
name|c
operator|->
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
name|do_sd_constraint
argument_list|(
name|graph
argument_list|,
name|c
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bitmap
name|tmp
decl_stmt|;
name|bitmap
name|solution
decl_stmt|;
name|bool
name|flag
init|=
name|false
decl_stmt|;
name|unsigned
name|int
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|c
operator|->
name|rhs
operator|.
name|type
operator|==
name|SCALAR
operator|&&
name|c
operator|->
name|lhs
operator|.
name|type
operator|==
name|SCALAR
argument_list|)
expr_stmt|;
name|t
operator|=
name|find
argument_list|(
name|c
operator|->
name|rhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|solution
operator|=
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
expr_stmt|;
name|t
operator|=
name|find
argument_list|(
name|c
operator|->
name|lhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
expr_stmt|;
name|flag
operator|=
name|set_union_with_increment
argument_list|(
name|tmp
argument_list|,
name|solution
argument_list|,
name|c
operator|->
name|rhs
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|get_varinfo
argument_list|(
name|t
argument_list|)
operator|->
name|solution
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Initialize and return a new SCC info structure.  */
end_comment

begin_function
specifier|static
name|struct
name|scc_info
modifier|*
name|init_scc_info
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|scc_info
modifier|*
name|si
init|=
name|XNEW
argument_list|(
expr|struct
name|scc_info
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|si
operator|->
name|current_index
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|visited
operator|=
name|sbitmap_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|si
operator|->
name|visited
argument_list|)
expr_stmt|;
name|si
operator|->
name|roots
operator|=
name|sbitmap_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|si
operator|->
name|roots
argument_list|)
expr_stmt|;
name|si
operator|->
name|node_mapping
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned int
argument_list|,
argument|size
argument_list|)
expr_stmt|;
name|si
operator|->
name|dfs
operator|=
name|XCNEWVEC
argument_list|(
argument|unsigned int
argument_list|,
argument|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|si
operator|->
name|node_mapping
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|si
operator|->
name|scc_stack
operator|=
name|VEC_alloc
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|si
return|;
block|}
end_function

begin_comment
comment|/* Free an SCC info structure pointed to by SI */
end_comment

begin_function
specifier|static
name|void
name|free_scc_info
parameter_list|(
name|struct
name|scc_info
modifier|*
name|si
parameter_list|)
block|{
name|sbitmap_free
argument_list|(
name|si
operator|->
name|visited
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|si
operator|->
name|roots
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|si
operator|->
name|node_mapping
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|si
operator|->
name|dfs
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find indirect cycles in GRAPH that occur, using strongly connected    components, and note them in the indirect cycles map.     This technique comes from Ben Hardekopf and Calvin Lin,    "It Pays to be Lazy: Fast and Accurate Pointer Analysis for Millions of    Lines of Code", submitted to PLDI 2007.  */
end_comment

begin_function
specifier|static
name|void
name|find_indirect_cycles
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|size
init|=
name|graph
operator|->
name|size
decl_stmt|;
name|struct
name|scc_info
modifier|*
name|si
init|=
name|init_scc_info
argument_list|(
name|size
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MIN
argument_list|(
name|LAST_REF_NODE
argument_list|,
name|size
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|si
operator|->
name|visited
argument_list|,
name|i
argument_list|)
operator|&&
name|find
argument_list|(
name|i
argument_list|)
operator|==
name|i
condition|)
name|scc_visit
argument_list|(
name|graph
argument_list|,
name|si
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|free_scc_info
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute a topological ordering for GRAPH, and store the result in the    topo_info structure TI.  */
end_comment

begin_function
specifier|static
name|void
name|compute_topo_order
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|struct
name|topo_info
modifier|*
name|ti
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|size
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|size
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|ti
operator|->
name|visited
argument_list|,
name|i
argument_list|)
operator|&&
name|find
argument_list|(
name|i
argument_list|)
operator|==
name|i
condition|)
name|topo_visit
argument_list|(
name|graph
argument_list|,
name|ti
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform offline variable substitution.     This is a linear time way of identifying variables that must have    equivalent points-to sets, including those caused by static cycles,    and single entry subgraphs, in the constraint graph.     The technique is described in "Off-line variable substitution for    scaling points-to analysis" by Atanas Rountev and Satish Chandra,    in "ACM SIGPLAN Notices" volume 35, number 5, pages 47-56.     There is an optimal way to do this involving hash based value    numbering, once the technique is published i will implement it    here.       The general method of finding equivalence classes is as follows:    Add fake nodes (REF nodes) and edges for *a = b and a = *b constraints.    Add fake nodes (ADDRESS nodes) and edges for a =&b constraints.    Initialize all non-REF/ADDRESS nodes to be direct nodes    For each SCC in the predecessor graph:       for each member (x) of the SCC          if x is not a direct node: 	   set rootnode(SCC) to be not a direct node 	 collapse node x into rootnode(SCC).       if rootnode(SCC) is not a direct node:         label rootnode(SCC) with a new equivalence class       else:         if all labeled predecessors of rootnode(SCC) have the same 	label: 	  label rootnode(SCC) with this label 	else: 	  label rootnode(SCC) with a new equivalence class     All direct nodes with the same equivalence class can be replaced    with a single representative node.    All unlabeled nodes (label == 0) are not pointers and all edges    involving them can be eliminated.    We perform these optimizations during move_complex_constraints. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|equivalence_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Recursive routine to find strongly connected components in GRAPH,    and label it's nodes with equivalence classes.    This is used during variable substitution to find cycles involving    the regular or implicit predecessors, and label them as equivalent.    The SCC finding algorithm used is the same as that for scc_visit.  */
end_comment

begin_function
specifier|static
name|void
name|label_visit
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|struct
name|scc_info
modifier|*
name|si
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|my_dfs
decl_stmt|;
name|gcc_assert
argument_list|(
name|si
operator|->
name|node_mapping
index|[
name|n
index|]
operator|==
name|n
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|si
operator|->
name|visited
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|si
operator|->
name|dfs
index|[
name|n
index|]
operator|=
name|si
operator|->
name|current_index
operator|++
expr_stmt|;
name|my_dfs
operator|=
name|si
operator|->
name|dfs
index|[
name|n
index|]
expr_stmt|;
comment|/* Visit all the successors.  */
name|EXECUTE_IF_IN_NONNULL_BITMAP
argument_list|(
argument|graph->preds[n]
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|int
name|w
init|=
name|si
operator|->
name|node_mapping
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|si
operator|->
name|roots
argument_list|,
name|w
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|si
operator|->
name|visited
argument_list|,
name|w
argument_list|)
condition|)
name|label_visit
argument_list|(
name|graph
argument_list|,
name|si
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|{
name|unsigned
name|int
name|t
init|=
name|si
operator|->
name|node_mapping
index|[
name|w
index|]
decl_stmt|;
name|unsigned
name|int
name|nnode
init|=
name|si
operator|->
name|node_mapping
index|[
name|n
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|nnode
operator|==
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|dfs
index|[
name|t
index|]
operator|<
name|si
operator|->
name|dfs
index|[
name|nnode
index|]
condition|)
name|si
operator|->
name|dfs
index|[
name|n
index|]
operator|=
name|si
operator|->
name|dfs
index|[
name|t
index|]
expr_stmt|;
block|}
block|}
comment|/* Visit all the implicit predecessors.  */
name|EXECUTE_IF_IN_NONNULL_BITMAP
argument_list|(
argument|graph->implicit_preds[n]
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|int
name|w
init|=
name|si
operator|->
name|node_mapping
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|si
operator|->
name|roots
argument_list|,
name|w
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|si
operator|->
name|visited
argument_list|,
name|w
argument_list|)
condition|)
name|label_visit
argument_list|(
name|graph
argument_list|,
name|si
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|{
name|unsigned
name|int
name|t
init|=
name|si
operator|->
name|node_mapping
index|[
name|w
index|]
decl_stmt|;
name|unsigned
name|int
name|nnode
init|=
name|si
operator|->
name|node_mapping
index|[
name|n
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|nnode
operator|==
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|dfs
index|[
name|t
index|]
operator|<
name|si
operator|->
name|dfs
index|[
name|nnode
index|]
condition|)
name|si
operator|->
name|dfs
index|[
name|n
index|]
operator|=
name|si
operator|->
name|dfs
index|[
name|t
index|]
expr_stmt|;
block|}
block|}
comment|/* See if any components have been identified.  */
if|if
condition|(
name|si
operator|->
name|dfs
index|[
name|n
index|]
operator|==
name|my_dfs
condition|)
block|{
while|while
condition|(
name|VEC_length
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
operator|!=
literal|0
operator|&&
name|si
operator|->
name|dfs
index|[
name|VEC_last
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
index|]
operator|>=
name|my_dfs
condition|)
block|{
name|unsigned
name|int
name|w
init|=
name|VEC_pop
argument_list|(
name|unsigned
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|)
decl_stmt|;
name|si
operator|->
name|node_mapping
index|[
name|w
index|]
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|w
argument_list|)
condition|)
name|RESET_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|SET_BIT
argument_list|(
name|si
operator|->
name|roots
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|graph
operator|->
name|label
index|[
name|n
index|]
operator|=
name|equivalence_class
operator|++
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|firstlabel
init|=
operator|~
literal|0
decl_stmt|;
name|EXECUTE_IF_IN_NONNULL_BITMAP
argument_list|(
argument|graph->preds[n]
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|unsigned
name|int
name|j
init|=
name|si
operator|->
name|node_mapping
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|j
operator|==
name|n
operator|||
name|graph
operator|->
name|label
index|[
name|j
index|]
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|firstlabel
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|~
literal|0
condition|)
block|{
name|firstlabel
operator|=
name|graph
operator|->
name|label
index|[
name|j
index|]
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|graph
operator|->
name|label
index|[
name|j
index|]
operator|!=
name|firstlabel
condition|)
name|size
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|graph
operator|->
name|label
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|==
literal|1
condition|)
name|graph
operator|->
name|label
index|[
name|n
index|]
operator|=
name|firstlabel
expr_stmt|;
else|else
name|graph
operator|->
name|label
index|[
name|n
index|]
operator|=
name|equivalence_class
operator|++
expr_stmt|;
block|}
block|}
else|else
name|VEC_safe_push
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|si
operator|->
name|scc_stack
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform offline variable substitution, discovering equivalence    classes, and eliminating non-pointer variables.  */
end_comment

begin_function
specifier|static
name|struct
name|scc_info
modifier|*
name|perform_var_substitution
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|size
init|=
name|graph
operator|->
name|size
decl_stmt|;
name|struct
name|scc_info
modifier|*
name|si
init|=
name|init_scc_info
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
expr_stmt|;
name|equivalence_class
operator|=
literal|0
expr_stmt|;
comment|/* We only need to visit the non-address nodes for labeling      purposes, as the address nodes will never have any predecessors,      because&x never appears on the LHS of a constraint.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LAST_REF_NODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|si
operator|->
name|visited
argument_list|,
name|si
operator|->
name|node_mapping
index|[
name|i
index|]
argument_list|)
condition|)
name|label_visit
argument_list|(
name|graph
argument_list|,
name|si
argument_list|,
name|si
operator|->
name|node_mapping
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_REF_NODE
condition|;
name|i
operator|++
control|)
block|{
name|bool
name|direct_node
init|=
name|TEST_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Equivalence class for %s node id %d:%s is %d\n"
argument_list|,
name|direct_node
condition|?
literal|"Direct node"
else|:
literal|"Indirect node"
argument_list|,
name|i
argument_list|,
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|name
argument_list|,
name|graph
operator|->
name|label
index|[
name|si
operator|->
name|node_mapping
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Quickly eliminate our non-pointer variables.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_REF_NODE
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|node
init|=
name|si
operator|->
name|node_mapping
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|graph
operator|->
name|label
index|[
name|node
index|]
operator|==
literal|0
operator|&&
name|TEST_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s is a non-pointer variable, eliminating edges.\n"
argument_list|,
name|get_varinfo
argument_list|(
name|node
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|stats
operator|.
name|nonpointer_vars
operator|++
expr_stmt|;
name|clear_edges_for_node
argument_list|(
name|graph
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|si
return|;
block|}
end_function

begin_comment
comment|/* Free information that was only necessary for variable    substitution.  */
end_comment

begin_function
specifier|static
name|void
name|free_var_substitution_info
parameter_list|(
name|struct
name|scc_info
modifier|*
name|si
parameter_list|)
block|{
name|free_scc_info
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|label
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|eq_rep
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|)
expr_stmt|;
name|bitmap_obstack_release
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an existing node that is equivalent to NODE, which has    equivalence class LABEL, if one exists.  Return NODE otherwise.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|find_equivalent_node
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|unsigned
name|int
name|node
parameter_list|,
name|unsigned
name|int
name|label
parameter_list|)
block|{
comment|/* If the address version of this variable is unused, we can      substitute it for anything else with the same label.      Otherwise, we know the pointers are equivalent, but not the      locations.  */
if|if
condition|(
name|graph
operator|->
name|label
index|[
name|FIRST_ADDR_NODE
operator|+
name|node
index|]
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
name|label
operator|<
name|graph
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|graph
operator|->
name|eq_rep
index|[
name|label
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Unify the two variables since we know they are equivalent.  */
if|if
condition|(
name|unite
argument_list|(
name|graph
operator|->
name|eq_rep
index|[
name|label
index|]
argument_list|,
name|node
argument_list|)
condition|)
name|unify_nodes
argument_list|(
name|graph
argument_list|,
name|graph
operator|->
name|eq_rep
index|[
name|label
index|]
argument_list|,
name|node
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
name|graph
operator|->
name|eq_rep
index|[
name|label
index|]
return|;
block|}
else|else
block|{
name|graph
operator|->
name|eq_rep
index|[
name|label
index|]
operator|=
name|node
expr_stmt|;
block|}
block|}
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Move complex constraints to the appropriate nodes, and collapse    variables we've discovered are equivalent during variable    substitution.  SI is the SCC_INFO that is the result of    perform_variable_substitution.  */
end_comment

begin_function
specifier|static
name|void
name|move_complex_constraints
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|,
name|struct
name|scc_info
modifier|*
name|si
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|graph
operator|->
name|size
condition|;
name|j
operator|++
control|)
name|gcc_assert
argument_list|(
name|find
argument_list|(
name|j
argument_list|)
operator|==
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
name|constraints
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|constraint_expr
name|lhs
init|=
name|c
operator|->
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|rhs
init|=
name|c
operator|->
name|rhs
decl_stmt|;
name|unsigned
name|int
name|lhsvar
init|=
name|find
argument_list|(
name|get_varinfo_fc
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|id
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|rhsvar
init|=
name|find
argument_list|(
name|get_varinfo_fc
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|id
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|lhsnode
decl_stmt|,
name|rhsnode
decl_stmt|;
name|unsigned
name|int
name|lhslabel
decl_stmt|,
name|rhslabel
decl_stmt|;
name|lhsnode
operator|=
name|si
operator|->
name|node_mapping
index|[
name|lhsvar
index|]
expr_stmt|;
name|rhsnode
operator|=
name|si
operator|->
name|node_mapping
index|[
name|rhsvar
index|]
expr_stmt|;
name|lhslabel
operator|=
name|graph
operator|->
name|label
index|[
name|lhsnode
index|]
expr_stmt|;
name|rhslabel
operator|=
name|graph
operator|->
name|label
index|[
name|rhsnode
index|]
expr_stmt|;
comment|/* See if it is really a non-pointer variable, and if so, ignore 	 the constraint.  */
if|if
condition|(
name|lhslabel
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|lhsnode
argument_list|)
condition|)
name|lhslabel
operator|=
name|graph
operator|->
name|label
index|[
name|lhsnode
index|]
operator|=
name|equivalence_class
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s is a non-pointer variable,"
literal|"ignoring constraint:"
argument_list|,
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|dump_constraint
argument_list|(
name|dump_file
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|VEC_replace
argument_list|(
name|constraint_t
argument_list|,
name|constraints
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|rhslabel
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|graph
operator|->
name|direct_nodes
argument_list|,
name|rhsnode
argument_list|)
condition|)
name|rhslabel
operator|=
name|graph
operator|->
name|label
index|[
name|rhsnode
index|]
operator|=
name|equivalence_class
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%s is a non-pointer variable,"
literal|"ignoring constraint:"
argument_list|,
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|dump_constraint
argument_list|(
name|dump_file
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|VEC_replace
argument_list|(
name|constraint_t
argument_list|,
name|constraints
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|lhsvar
operator|=
name|find_equivalent_node
argument_list|(
name|graph
argument_list|,
name|lhsvar
argument_list|,
name|lhslabel
argument_list|)
expr_stmt|;
name|rhsvar
operator|=
name|find_equivalent_node
argument_list|(
name|graph
argument_list|,
name|rhsvar
argument_list|,
name|rhslabel
argument_list|)
expr_stmt|;
name|c
operator|->
name|lhs
operator|.
name|var
operator|=
name|lhsvar
expr_stmt|;
name|c
operator|->
name|rhs
operator|.
name|var
operator|=
name|rhsvar
expr_stmt|;
if|if
condition|(
name|lhs
operator|.
name|type
operator|==
name|DEREF
condition|)
block|{
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
operator|||
name|rhsvar
operator|>
name|anything_id
condition|)
name|insert_into_complex
argument_list|(
name|graph
argument_list|,
name|lhsvar
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|get_varinfo
argument_list|(
name|lhsvar
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
name|insert_into_complex
argument_list|(
name|graph
argument_list|,
name|rhsvar
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rhs
operator|.
name|type
operator|!=
name|ADDRESSOF
operator|&&
name|lhsvar
operator|>
name|anything_id
operator|&&
operator|(
name|lhs
operator|.
name|offset
operator|!=
literal|0
operator|||
name|rhs
operator|.
name|offset
operator|!=
literal|0
operator|)
condition|)
block|{
name|insert_into_complex
argument_list|(
name|graph
argument_list|,
name|rhsvar
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Eliminate indirect cycles involving NODE.  Return true if NODE was    part of an SCC, false otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|eliminate_indirect_cycles
parameter_list|(
name|unsigned
name|int
name|node
parameter_list|)
block|{
if|if
condition|(
name|graph
operator|->
name|indirect_cycles
index|[
name|node
index|]
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|bitmap_empty_p
argument_list|(
name|get_varinfo
argument_list|(
name|node
argument_list|)
operator|->
name|solution
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|VEC
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|)
operator|*
name|queue
operator|=
name|NULL
expr_stmt|;
name|int
name|queuepos
decl_stmt|;
name|unsigned
name|int
name|to
init|=
name|find
argument_list|(
name|graph
operator|->
name|indirect_cycles
index|[
name|node
index|]
argument_list|)
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* We can't touch the solution set and call unify_nodes 	 at the same time, because unify_nodes is going to do 	 bitmap unions into it. */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|get_varinfo (node)->solution
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
if|if
condition|(
name|find
argument_list|(
name|i
argument_list|)
operator|==
name|i
operator|&&
name|i
operator|!=
name|to
condition|)
block|{
if|if
condition|(
name|unite
argument_list|(
name|to
argument_list|,
name|i
argument_list|)
condition|)
name|VEC_safe_push
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|queue
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|queuepos
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|unsigned
argument_list|,
name|queue
argument_list|,
name|queuepos
argument_list|,
name|i
argument_list|)
condition|;
name|queuepos
operator|++
control|)
block|{
name|unify_nodes
argument_list|(
name|graph
argument_list|,
name|to
argument_list|,
name|i
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|unsigned
argument_list|,
name|heap
argument_list|,
name|queue
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Solve the constraint graph GRAPH using our worklist solver.    This is based on the PW* family of solvers from the "Efficient Field    Sensitive Pointer Analysis for C" paper.    It works by iterating over all the graph nodes, processing the complex    constraints and propagating the copy constraints, until everything stops    changed.  This corresponds to steps 6-8 in the solving list given above.  */
end_comment

begin_function
specifier|static
name|void
name|solve_graph
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|)
block|{
name|unsigned
name|int
name|size
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap
name|pts
decl_stmt|;
name|changed_count
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
name|sbitmap_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|changed
argument_list|)
expr_stmt|;
comment|/* Mark all initial non-collapsed nodes as changed.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|varinfo_t
name|ivi
init|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|find
argument_list|(
name|i
argument_list|)
operator|==
name|i
operator|&&
operator|!
name|bitmap_empty_p
argument_list|(
name|ivi
operator|->
name|solution
argument_list|)
operator|&&
operator|(
operator|(
name|graph
operator|->
name|succs
index|[
name|i
index|]
operator|&&
operator|!
name|bitmap_empty_p
argument_list|(
name|graph
operator|->
name|succs
index|[
name|i
index|]
argument_list|)
operator|)
operator|||
name|VEC_length
argument_list|(
name|constraint_t
argument_list|,
name|graph
operator|->
name|complex
index|[
name|i
index|]
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
comment|/* Allocate a bitmap to be used to store the changed bits.  */
name|pts
operator|=
name|BITMAP_ALLOC
argument_list|(
operator|&
name|pta_obstack
argument_list|)
expr_stmt|;
while|while
condition|(
name|changed_count
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|topo_info
modifier|*
name|ti
init|=
name|init_topo_info
argument_list|()
decl_stmt|;
name|stats
operator|.
name|iterations
operator|++
expr_stmt|;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
expr_stmt|;
name|compute_topo_order
argument_list|(
name|graph
argument_list|,
name|ti
argument_list|)
expr_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|unsigned
argument_list|,
name|ti
operator|->
name|topo_order
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|VEC_pop
argument_list|(
name|unsigned
argument_list|,
name|ti
operator|->
name|topo_order
argument_list|)
expr_stmt|;
comment|/* If this variable is not a representative, skip it.  */
if|if
condition|(
name|find
argument_list|(
name|i
argument_list|)
operator|!=
name|i
condition|)
continue|continue;
comment|/* In certain indirect cycle cases, we may merge this 	     variable to another.  */
if|if
condition|(
name|eliminate_indirect_cycles
argument_list|(
name|i
argument_list|)
operator|&&
name|find
argument_list|(
name|i
argument_list|)
operator|!=
name|i
condition|)
continue|continue;
comment|/* If the node has changed, we need to process the 	     complex constraints and outgoing edges again.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|constraint_t
name|c
decl_stmt|;
name|bitmap
name|solution
decl_stmt|;
name|VEC
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|)
operator|*
name|complex
operator|=
name|graph
operator|->
name|complex
index|[
name|i
index|]
expr_stmt|;
name|bool
name|solution_empty
decl_stmt|;
name|RESET_BIT
argument_list|(
name|changed
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|changed_count
operator|--
expr_stmt|;
comment|/* Compute the changed set of solution bits.  */
name|bitmap_and_compl
argument_list|(
name|pts
argument_list|,
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|solution
argument_list|,
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|oldsolution
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_empty_p
argument_list|(
name|pts
argument_list|)
condition|)
continue|continue;
name|bitmap_ior_into
argument_list|(
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|oldsolution
argument_list|,
name|pts
argument_list|)
expr_stmt|;
name|solution
operator|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|solution
expr_stmt|;
name|solution_empty
operator|=
name|bitmap_empty_p
argument_list|(
name|solution
argument_list|)
expr_stmt|;
comment|/* Process the complex constraints */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constraint_t
argument_list|,
name|complex
argument_list|,
name|j
argument_list|,
name|c
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
comment|/* The only complex constraint that can change our 		     solution to non-empty, given an empty solution, 		     is a constraint where the lhs side is receiving 		     some set from elsewhere.  */
if|if
condition|(
operator|!
name|solution_empty
operator|||
name|c
operator|->
name|lhs
operator|.
name|type
operator|!=
name|DEREF
condition|)
name|do_complex_constraint
argument_list|(
name|graph
argument_list|,
name|c
argument_list|,
name|pts
argument_list|)
expr_stmt|;
block|}
name|solution_empty
operator|=
name|bitmap_empty_p
argument_list|(
name|solution
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|solution_empty
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
comment|/* Propagate solution to all successors.  */
name|EXECUTE_IF_IN_NONNULL_BITMAP
argument_list|(
argument|graph->succs[i]
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
block|{
name|bitmap
name|tmp
decl_stmt|;
name|bool
name|flag
decl_stmt|;
name|unsigned
name|int
name|to
init|=
name|find
argument_list|(
name|j
argument_list|)
decl_stmt|;
name|tmp
operator|=
name|get_varinfo
argument_list|(
name|to
argument_list|)
operator|->
name|solution
expr_stmt|;
name|flag
operator|=
name|false
expr_stmt|;
comment|/* Don't try to propagate to ourselves.  */
if|if
condition|(
name|to
operator|==
name|i
condition|)
continue|continue;
name|flag
operator|=
name|set_union_with_increment
argument_list|(
name|tmp
argument_list|,
name|pts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|get_varinfo
argument_list|(
name|to
argument_list|)
operator|->
name|solution
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|changed
argument_list|,
name|to
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|changed
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|changed_count
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
name|free_topo_info
argument_list|(
name|ti
argument_list|)
expr_stmt|;
name|bitmap_obstack_release
argument_list|(
operator|&
name|iteration_obstack
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|pts
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|changed
argument_list|)
expr_stmt|;
name|bitmap_obstack_release
argument_list|(
operator|&
name|oldpta_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map from trees to variable infos.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pointer_map_t
modifier|*
name|vi_for_tree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insert ID as the variable id for tree T in the vi_for_tree map.  */
end_comment

begin_function
specifier|static
name|void
name|insert_vi_for_tree
parameter_list|(
name|tree
name|t
parameter_list|,
name|varinfo_t
name|vi
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
init|=
name|pointer_map_insert
argument_list|(
name|vi_for_tree
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|vi
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|slot
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|vi
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the variable info for tree T in VI_FOR_TREE.  If T does not    exist in the map, return NULL, otherwise, return the varinfo we found.  */
end_comment

begin_function
specifier|static
name|varinfo_t
name|lookup_vi_for_tree
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
init|=
name|pointer_map_contains
argument_list|(
name|vi_for_tree
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|varinfo_t
operator|)
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Return a printable name for DECL  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|alias_get_name
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|res
init|=
name|get_name
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|num_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
return|return
name|res
return|;
name|res
operator|=
literal|"NULL"
expr_stmt|;
if|if
condition|(
operator|!
name|dump_file
condition|)
return|return
name|res
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|num_printed
operator|=
name|asprintf
argument_list|(
operator|&
name|temp
argument_list|,
literal|"%s_%u"
argument_list|,
name|alias_get_name
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|num_printed
operator|=
name|asprintf
argument_list|(
operator|&
name|temp
argument_list|,
literal|"D.%u"
argument_list|,
name|DECL_UID
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_printed
operator|>
literal|0
condition|)
block|{
name|res
operator|=
name|ggc_strdup
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Find the variable id for tree T in the map.    If T doesn't exist in the map, create an entry for it and return it.  */
end_comment

begin_function
specifier|static
name|varinfo_t
name|get_vi_for_tree
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
init|=
name|pointer_map_contains
argument_list|(
name|vi_for_tree
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
condition|)
return|return
name|get_varinfo
argument_list|(
name|create_variable_info_for
argument_list|(
name|t
argument_list|,
name|alias_get_name
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
operator|(
name|varinfo_t
operator|)
operator|*
name|slot
return|;
block|}
end_function

begin_comment
comment|/* Get a constraint expression from an SSA_VAR_P node.  */
end_comment

begin_function
specifier|static
name|struct
name|constraint_expr
name|get_constraint_exp_from_ssa_var
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|struct
name|constraint_expr
name|cexpr
decl_stmt|;
name|gcc_assert
argument_list|(
name|SSA_VAR_P
argument_list|(
name|t
argument_list|)
operator|||
name|DECL_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For parameters, get at the points-to set for the actual parm      decl.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|default_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|t
condition|)
return|return
name|get_constraint_exp_from_ssa_var
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
name|cexpr
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|cexpr
operator|.
name|var
operator|=
name|get_vi_for_tree
argument_list|(
name|t
argument_list|)
operator|->
name|id
expr_stmt|;
comment|/* If we determine the result is "anything", and we know this is readonly,      say it points to readonly memory instead.  */
if|if
condition|(
name|cexpr
operator|.
name|var
operator|==
name|anything_id
operator|&&
name|TREE_READONLY
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|cexpr
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|cexpr
operator|.
name|var
operator|=
name|readonly_id
expr_stmt|;
block|}
name|cexpr
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
return|return
name|cexpr
return|;
block|}
end_function

begin_comment
comment|/* Process a completed constraint T, and add it to the constraint    list.  */
end_comment

begin_function
specifier|static
name|void
name|process_constraint
parameter_list|(
name|constraint_t
name|t
parameter_list|)
block|{
name|struct
name|constraint_expr
name|rhs
init|=
name|t
operator|->
name|rhs
decl_stmt|;
name|struct
name|constraint_expr
name|lhs
init|=
name|t
operator|->
name|lhs
decl_stmt|;
name|gcc_assert
argument_list|(
name|rhs
operator|.
name|var
operator|<
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|lhs
operator|.
name|var
operator|<
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|directly_dereferenced
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|directly_dereferenced
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|use_field_sensitive
condition|)
block|{
name|t
operator|->
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* ANYTHING == ANYTHING is pointless.  */
if|if
condition|(
name|lhs
operator|.
name|var
operator|==
name|anything_id
operator|&&
name|rhs
operator|.
name|var
operator|==
name|anything_id
condition|)
return|return;
comment|/* If we have&ANYTHING = something, convert to SOMETHING =&ANYTHING) */
elseif|else
if|if
condition|(
name|lhs
operator|.
name|var
operator|==
name|anything_id
operator|&&
name|lhs
operator|.
name|type
operator|==
name|ADDRESSOF
condition|)
block|{
name|rhs
operator|=
name|t
operator|->
name|lhs
expr_stmt|;
name|t
operator|->
name|lhs
operator|=
name|t
operator|->
name|rhs
expr_stmt|;
name|t
operator|->
name|rhs
operator|=
name|rhs
expr_stmt|;
name|process_constraint
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* This can happen in our IR with things like n->a = *p */
elseif|else
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|lhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|rhs
operator|.
name|var
operator|!=
name|anything_id
condition|)
block|{
comment|/* Split into tmp = *rhs, *lhs = tmp */
name|tree
name|rhsdecl
init|=
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|decl
decl_stmt|;
name|tree
name|pointertype
init|=
name|TREE_TYPE
argument_list|(
name|rhsdecl
argument_list|)
decl_stmt|;
name|tree
name|pointedtotype
init|=
name|TREE_TYPE
argument_list|(
name|pointertype
argument_list|)
decl_stmt|;
name|tree
name|tmpvar
init|=
name|create_tmp_var_raw
argument_list|(
name|pointedtotype
argument_list|,
literal|"doubledereftmp"
argument_list|)
decl_stmt|;
name|struct
name|constraint_expr
name|tmplhs
init|=
name|get_constraint_exp_from_ssa_var
argument_list|(
name|tmpvar
argument_list|)
decl_stmt|;
comment|/* If this is an aggregate of known size, we should have passed 	 this off to do_structure_copy, and it should have broken it 	 up.  */
name|gcc_assert
argument_list|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|pointedtotype
argument_list|)
operator|||
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|is_unknown_size_var
argument_list|)
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|tmplhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|tmplhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|rhs
operator|.
name|type
operator|!=
name|ADDRESSOF
operator|||
name|rhs
operator|.
name|offset
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|constraints
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if T is a variable of a type that could contain    pointers.  */
end_comment

begin_function
specifier|static
name|bool
name|could_have_pointers
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return the position, in bits, of FIELD_DECL from the beginning of its    structure.  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|bitpos_of_field
parameter_list|(
specifier|const
name|tree
name|fdecl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|fdecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|fdecl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_OFFSET
argument_list|(
name|fdecl
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|*
literal|8
operator|)
operator|+
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|fdecl
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if an access to [ACCESSPOS, ACCESSSIZE]    overlaps with a field at [FIELDPOS, FIELDSIZE] */
end_comment

begin_function
specifier|static
name|bool
name|offset_overlaps_with_access
parameter_list|(
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|fieldpos
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|fieldsize
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|accesspos
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|accesssize
parameter_list|)
block|{
if|if
condition|(
name|fieldpos
operator|==
name|accesspos
operator|&&
name|fieldsize
operator|==
name|accesssize
condition|)
return|return
name|true
return|;
if|if
condition|(
name|accesspos
operator|>=
name|fieldpos
operator|&&
name|accesspos
operator|<
operator|(
name|fieldpos
operator|+
name|fieldsize
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|accesspos
operator|<
name|fieldpos
operator|&&
operator|(
name|accesspos
operator|+
name|accesssize
operator|>
name|fieldpos
operator|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Given a COMPONENT_REF T, return the constraint_expr for it.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|get_constraint_for_component_ref
argument_list|(
name|tree
name|t
argument_list|,
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|results
argument_list|)
block|{
name|tree
name|orig_t
init|=
name|t
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
init|=
operator|-
literal|1
decl_stmt|;
name|HOST_WIDE_INT
name|bitmaxsize
init|=
operator|-
literal|1
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos
decl_stmt|;
name|tree
name|forzero
decl_stmt|;
name|struct
name|constraint_expr
modifier|*
name|result
decl_stmt|;
name|unsigned
name|int
name|beforelength
init|=
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
decl_stmt|;
comment|/* Some people like to do cute things like take the address of&0->a.b */
name|forzero
operator|=
name|t
expr_stmt|;
while|while
condition|(
operator|!
name|SSA_VAR_P
argument_list|(
name|forzero
argument_list|)
operator|&&
operator|!
name|CONSTANT_CLASS_P
argument_list|(
name|forzero
argument_list|)
condition|)
name|forzero
operator|=
name|TREE_OPERAND
argument_list|(
name|forzero
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|forzero
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|forzero
argument_list|)
condition|)
block|{
name|struct
name|constraint_expr
name|temp
decl_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|integer_id
expr_stmt|;
name|temp
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|get_ref_base_and_extent
argument_list|(
name|t
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitmaxsize
argument_list|)
expr_stmt|;
comment|/* String constants are readonly, so there is nothing to really do      here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STRING_CST
condition|)
return|return;
name|get_constraint_for
argument_list|(
name|t
argument_list|,
name|results
argument_list|)
expr_stmt|;
name|result
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
expr_stmt|;
name|result
operator|->
name|offset
operator|=
name|bitpos
expr_stmt|;
name|gcc_assert
argument_list|(
name|beforelength
operator|+
literal|1
operator|==
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This can also happen due to weird offsetof type macros.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ADDR_EXPR
operator|&&
name|result
operator|->
name|type
operator|==
name|ADDRESSOF
condition|)
name|result
operator|->
name|type
operator|=
name|SCALAR
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|type
operator|==
name|SCALAR
condition|)
block|{
comment|/* In languages like C, you can access one past the end of an 	 array.  You aren't allowed to dereference it, so we can 	 ignore this constraint. When we handle pointer subtraction, 	 we may have to do something cute here.  */
if|if
condition|(
name|result
operator|->
name|offset
operator|<
name|get_varinfo
argument_list|(
name|result
operator|->
name|var
argument_list|)
operator|->
name|fullsize
operator|&&
name|bitmaxsize
operator|!=
literal|0
condition|)
block|{
comment|/* It's also not true that the constraint will actually start at the 	     right offset, it may start in some padding.  We only care about 	     setting the constraint to the first actual field it touches, so 	     walk to find it.  */
name|varinfo_t
name|curr
decl_stmt|;
for|for
control|(
name|curr
operator|=
name|get_varinfo
argument_list|(
name|result
operator|->
name|var
argument_list|)
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|offset_overlaps_with_access
argument_list|(
name|curr
operator|->
name|offset
argument_list|,
name|curr
operator|->
name|size
argument_list|,
name|result
operator|->
name|offset
argument_list|,
name|bitmaxsize
argument_list|)
condition|)
block|{
name|result
operator|->
name|var
operator|=
name|curr
operator|->
name|id
expr_stmt|;
break|break;
block|}
block|}
comment|/* assert that we found *some* field there. The user couldn't be 	     accessing *only* padding.  */
comment|/* Still the user could access one past the end of an array 	     embedded in a struct resulting in accessing *only* padding.  */
name|gcc_assert
argument_list|(
name|curr
operator|||
name|ref_contains_array_ref
argument_list|(
name|orig_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bitmaxsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Access to zero-sized part of variable,"
literal|"ignoring\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Access to past the end of variable, ignoring\n"
argument_list|)
expr_stmt|;
name|result
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Dereference the constraint expression CONS, and return the result.    DEREF (ADDRESSOF) = SCALAR    DEREF (SCALAR) = DEREF    DEREF (DEREF) = (temp = DEREF1; result = DEREF(temp))    This is needed so that we can handle dereferencing DEREF constraints.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_deref
argument_list|(
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|constraints
argument_list|)
block|{
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
operator|*
name|constraints
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|SCALAR
condition|)
name|c
operator|->
name|type
operator|=
name|DEREF
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|ADDRESSOF
condition|)
name|c
operator|->
name|type
operator|=
name|SCALAR
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|DEREF
condition|)
block|{
name|tree
name|tmpvar
init|=
name|create_tmp_var_raw
argument_list|(
name|ptr_type_node
argument_list|,
literal|"dereftmp"
argument_list|)
decl_stmt|;
name|struct
name|constraint_expr
name|tmplhs
init|=
name|get_constraint_exp_from_ssa_var
argument_list|(
name|tmpvar
argument_list|)
decl_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|tmplhs
argument_list|,
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|var
operator|=
name|tmplhs
operator|.
name|var
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Create a nonlocal variable of TYPE to represent nonlocals we can    alias.  */
end_comment

begin_function
specifier|static
name|tree
name|create_nonlocal_var
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|nonlocal
init|=
name|create_tmp_var_raw
argument_list|(
name|type
argument_list|,
literal|"NONLOCAL"
argument_list|)
decl_stmt|;
if|if
condition|(
name|referenced_vars
condition|)
name|add_referenced_var
argument_list|(
name|nonlocal
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|nonlocal
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|nonlocal
return|;
block|}
end_function

begin_comment
comment|/* Given a tree T, return the constraint expression for it.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|get_constraint_for
argument_list|(
name|tree
name|t
argument_list|,
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|results
argument_list|)
block|{
name|struct
name|constraint_expr
name|temp
decl_stmt|;
comment|/* x = integer is all glommed to a single variable, which doesn't      point to anything by itself.  That is, of course, unless it is an      integer constant being treated as a pointer, in which case, we      will return that this is really the addressof anything.  This      happens below, since it will fall into the default case. The only      case we know something about an integer treated like a pointer is      when it is the NULL pointer, and then we just say it points to      NULL.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|temp
operator|.
name|var
operator|=
name|integer_id
expr_stmt|;
name|temp
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|integer_zerop
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|temp
operator|.
name|var
operator|=
name|nothing_id
expr_stmt|;
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_expression
case|:
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
block|{
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|tree
name|exp
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|pttype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|get_constraint_for
argument_list|(
name|exp
argument_list|,
name|results
argument_list|)
expr_stmt|;
comment|/* Make sure we capture constraints to all elements 		 of an array.  */
if|if
condition|(
operator|(
name|handled_component_p
argument_list|(
name|exp
argument_list|)
operator|&&
name|ref_contains_array_ref
argument_list|(
name|exp
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|struct
name|constraint_expr
modifier|*
name|origrhs
decl_stmt|;
name|varinfo_t
name|origvar
decl_stmt|;
name|struct
name|constraint_expr
name|tmp
decl_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|origrhs
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|*
name|origrhs
expr_stmt|;
name|VEC_pop
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
expr_stmt|;
name|origvar
operator|=
name|get_varinfo
argument_list|(
name|origrhs
operator|->
name|var
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|origvar
condition|;
name|origvar
operator|=
name|origvar
operator|->
name|next
control|)
block|{
name|tmp
operator|.
name|var
operator|=
name|origvar
operator|->
name|id
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|AGGREGATE_TYPE_P
argument_list|(
name|pttype
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|pttype
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|struct
name|constraint_expr
modifier|*
name|origrhs
decl_stmt|;
name|varinfo_t
name|origvar
decl_stmt|;
name|struct
name|constraint_expr
name|tmp
decl_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|origrhs
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|*
name|origrhs
expr_stmt|;
name|VEC_pop
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|)
expr_stmt|;
name|origvar
operator|=
name|get_varinfo
argument_list|(
name|origrhs
operator|->
name|var
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|origvar
condition|;
name|origvar
operator|=
name|origvar
operator|->
name|next
control|)
block|{
name|tmp
operator|.
name|var
operator|=
name|origvar
operator|->
name|id
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
operator|*
name|results
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|DEREF
condition|)
name|c
operator|->
name|type
operator|=
name|SCALAR
expr_stmt|;
else|else
name|c
operator|->
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
block|}
return|return;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* XXX: In interprocedural mode, if we didn't have the 	       body, we would need to do *each pointer argument =&ANYTHING added.  */
if|if
condition|(
name|call_expr_flags
argument_list|(
name|t
argument_list|)
operator|&
operator|(
name|ECF_MALLOC
operator||
name|ECF_MAY_BE_ALLOCA
operator|)
condition|)
block|{
name|varinfo_t
name|vi
decl_stmt|;
name|tree
name|heapvar
init|=
name|heapvar_lookup
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|heapvar
operator|==
name|NULL
condition|)
block|{
name|heapvar
operator|=
name|create_tmp_var_raw
argument_list|(
name|ptr_type_node
argument_list|,
literal|"HEAP"
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|heapvar
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|referenced_vars
condition|)
name|add_referenced_var
argument_list|(
name|heapvar
argument_list|)
expr_stmt|;
name|heapvar_insert
argument_list|(
name|t
argument_list|,
name|heapvar
argument_list|)
expr_stmt|;
block|}
name|temp
operator|.
name|var
operator|=
name|create_variable_info_for
argument_list|(
name|heapvar
argument_list|,
name|alias_get_name
argument_list|(
name|heapvar
argument_list|)
argument_list|)
expr_stmt|;
name|vi
operator|=
name|get_varinfo
argument_list|(
name|temp
operator|.
name|var
argument_list|)
expr_stmt|;
name|vi
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|vi
operator|->
name|is_heap_var
operator|=
literal|1
expr_stmt|;
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|temp
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|temp
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
block|{
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
case|case
name|tcc_reference
case|:
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
block|{
name|get_constraint_for
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|,
name|results
argument_list|)
expr_stmt|;
name|do_deref
argument_list|(
name|results
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|COMPONENT_REF
case|:
name|get_constraint_for_component_ref
argument_list|(
name|t
argument_list|,
name|results
argument_list|)
expr_stmt|;
return|return;
default|default:
block|{
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
case|case
name|tcc_unary
case|:
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Cast from non-pointer to pointers are bad news for us. 		 Anything else, we see through */
if|if
condition|(
operator|!
operator|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|get_constraint_for
argument_list|(
name|op
argument_list|,
name|results
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHRU  */
block|}
default|default:
block|{
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
case|case
name|tcc_exceptional
case|:
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|PHI_NODE
case|:
block|{
name|get_constraint_for
argument_list|(
name|PHI_RESULT
argument_list|(
name|t
argument_list|)
argument_list|,
name|results
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|SSA_NAME
case|:
block|{
name|struct
name|constraint_expr
name|temp
decl_stmt|;
name|temp
operator|=
name|get_constraint_exp_from_ssa_var
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
default|default:
block|{
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
case|case
name|tcc_declaration
case|:
block|{
name|struct
name|constraint_expr
name|temp
decl_stmt|;
name|temp
operator|=
name|get_constraint_exp_from_ssa_var
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
block|{
name|temp
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|temp
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
operator|*
name|results
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Handle the structure copy case where we have a simple structure copy    between LHS and RHS that is of SIZE (in bits)     For each field of the lhs variable (lhsfield)      For each field of the rhs variable at lhsfield.offset (rhsfield)        add the constraint lhsfield = rhsfield     If we fail due to some kind of type unsafety or other thing we    can't handle, return false.  We expect the caller to collapse the    variable in that case.  */
end_comment

begin_function
specifier|static
name|bool
name|do_simple_structure_copy
parameter_list|(
specifier|const
name|struct
name|constraint_expr
name|lhs
parameter_list|,
specifier|const
name|struct
name|constraint_expr
name|rhs
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|varinfo_t
name|p
init|=
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|pstart
decl_stmt|,
name|last
decl_stmt|;
name|pstart
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|last
operator|=
name|p
operator|->
name|offset
operator|+
name|size
expr_stmt|;
for|for
control|(
init|;
name|p
operator|&&
name|p
operator|->
name|offset
operator|<
name|last
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|varinfo_t
name|q
decl_stmt|;
name|struct
name|constraint_expr
name|templhs
init|=
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|temprhs
init|=
name|rhs
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
decl_stmt|;
name|templhs
operator|.
name|var
operator|=
name|p
operator|->
name|id
expr_stmt|;
name|q
operator|=
name|get_varinfo
argument_list|(
name|temprhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|fieldoffset
operator|=
name|p
operator|->
name|offset
operator|-
name|pstart
expr_stmt|;
name|q
operator|=
name|first_vi_for_offset
argument_list|(
name|q
argument_list|,
name|q
operator|->
name|offset
operator|+
name|fieldoffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
condition|)
return|return
name|false
return|;
name|temprhs
operator|.
name|var
operator|=
name|q
operator|->
name|id
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|templhs
argument_list|,
name|temprhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle the structure copy case where we have a  structure copy between a    aggregate on the LHS and a dereference of a pointer on the RHS    that is of SIZE (in bits)     For each field of the lhs variable (lhsfield)        rhs.offset = lhsfield->offset        add the constraint lhsfield = rhs */
end_comment

begin_function
specifier|static
name|void
name|do_rhs_deref_structure_copy
parameter_list|(
specifier|const
name|struct
name|constraint_expr
name|lhs
parameter_list|,
specifier|const
name|struct
name|constraint_expr
name|rhs
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|varinfo_t
name|p
init|=
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|pstart
decl_stmt|,
name|last
decl_stmt|;
name|pstart
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|last
operator|=
name|p
operator|->
name|offset
operator|+
name|size
expr_stmt|;
for|for
control|(
init|;
name|p
operator|&&
name|p
operator|->
name|offset
operator|<
name|last
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|varinfo_t
name|q
decl_stmt|;
name|struct
name|constraint_expr
name|templhs
init|=
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|temprhs
init|=
name|rhs
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
decl_stmt|;
if|if
condition|(
name|templhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
name|templhs
operator|.
name|var
operator|=
name|p
operator|->
name|id
expr_stmt|;
else|else
name|templhs
operator|.
name|offset
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|q
operator|=
name|get_varinfo
argument_list|(
name|temprhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|fieldoffset
operator|=
name|p
operator|->
name|offset
operator|-
name|pstart
expr_stmt|;
name|temprhs
operator|.
name|offset
operator|+=
name|fieldoffset
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|templhs
argument_list|,
name|temprhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle the structure copy case where we have a structure copy    between a aggregate on the RHS and a dereference of a pointer on    the LHS that is of SIZE (in bits)     For each field of the rhs variable (rhsfield)        lhs.offset = rhsfield->offset        add the constraint lhs = rhsfield */
end_comment

begin_function
specifier|static
name|void
name|do_lhs_deref_structure_copy
parameter_list|(
specifier|const
name|struct
name|constraint_expr
name|lhs
parameter_list|,
specifier|const
name|struct
name|constraint_expr
name|rhs
parameter_list|,
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|varinfo_t
name|p
init|=
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|pstart
decl_stmt|,
name|last
decl_stmt|;
name|pstart
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|last
operator|=
name|p
operator|->
name|offset
operator|+
name|size
expr_stmt|;
for|for
control|(
init|;
name|p
operator|&&
name|p
operator|->
name|offset
operator|<
name|last
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|varinfo_t
name|q
decl_stmt|;
name|struct
name|constraint_expr
name|templhs
init|=
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|temprhs
init|=
name|rhs
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|fieldoffset
decl_stmt|;
if|if
condition|(
name|temprhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
name|temprhs
operator|.
name|var
operator|=
name|p
operator|->
name|id
expr_stmt|;
else|else
name|temprhs
operator|.
name|offset
operator|=
name|p
operator|->
name|offset
expr_stmt|;
name|q
operator|=
name|get_varinfo
argument_list|(
name|templhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|fieldoffset
operator|=
name|p
operator|->
name|offset
operator|-
name|pstart
expr_stmt|;
name|templhs
operator|.
name|offset
operator|+=
name|fieldoffset
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|templhs
argument_list|,
name|temprhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sometimes, frontends like to give us bad type information.  This    function will collapse all the fields from VAR to the end of VAR,    into VAR, so that we treat those fields as a single variable.    We return the variable they were collapsed into.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|collapse_rest_of_var
parameter_list|(
name|unsigned
name|int
name|var
parameter_list|)
block|{
name|varinfo_t
name|currvar
init|=
name|get_varinfo
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|varinfo_t
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|currvar
operator|->
name|next
init|;
name|field
condition|;
name|field
operator|=
name|field
operator|->
name|next
control|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Type safety: Collapsing var %s into %s\n"
argument_list|,
name|field
operator|->
name|name
argument_list|,
name|currvar
operator|->
name|name
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|field
operator|->
name|collapsed_to
argument_list|)
expr_stmt|;
name|field
operator|->
name|collapsed_to
operator|=
name|currvar
expr_stmt|;
block|}
name|currvar
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|currvar
operator|->
name|size
operator|=
name|currvar
operator|->
name|fullsize
operator|-
name|currvar
operator|->
name|offset
expr_stmt|;
return|return
name|currvar
operator|->
name|id
return|;
block|}
end_function

begin_comment
comment|/* Handle aggregate copies by expanding into copies of the respective    fields of the structures.  */
end_comment

begin_function
specifier|static
name|void
name|do_structure_copy
parameter_list|(
name|tree
name|lhsop
parameter_list|,
name|tree
name|rhsop
parameter_list|)
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|,
name|rhs
decl_stmt|,
name|tmp
decl_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|lhsc
operator|=
name|NULL
operator|,
operator|*
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|varinfo_t
name|p
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|lhssize
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|rhssize
decl_stmt|;
name|get_constraint_for
argument_list|(
name|lhsop
argument_list|,
operator|&
name|lhsc
argument_list|)
expr_stmt|;
name|get_constraint_for
argument_list|(
name|rhsop
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|lhs
operator|=
operator|*
operator|(
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|)
operator|)
expr_stmt|;
name|rhs
operator|=
operator|*
operator|(
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|lhsc
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
comment|/* If we have special var = x, swap it around.  */
if|if
condition|(
name|lhs
operator|.
name|var
operator|<=
name|integer_id
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
block|{
name|tmp
operator|=
name|lhs
expr_stmt|;
name|lhs
operator|=
name|rhs
expr_stmt|;
name|rhs
operator|=
name|tmp
expr_stmt|;
block|}
comment|/*  This is fairly conservative for the RHS == ADDRESSOF case, in that it's       possible it's something we could handle.  However, most cases falling       into this are dealing with transparent unions, which are slightly       weird. */
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|ADDRESSOF
operator|&&
operator|!
operator|(
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|is_special_var
operator|)
condition|)
block|{
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
block|}
comment|/* If the RHS is a special var, or an addressof, set all the LHS fields to      that special var.  */
if|if
condition|(
name|rhs
operator|.
name|var
operator|<=
name|integer_id
condition|)
block|{
for|for
control|(
name|p
operator|=
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|constraint_expr
name|templhs
init|=
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
name|temprhs
init|=
name|rhs
decl_stmt|;
if|if
condition|(
name|templhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
name|templhs
operator|.
name|var
operator|=
name|p
operator|->
name|id
expr_stmt|;
else|else
name|templhs
operator|.
name|offset
operator|+=
name|p
operator|->
name|offset
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|templhs
argument_list|,
name|temprhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|tree
name|rhstype
init|=
name|TREE_TYPE
argument_list|(
name|rhsop
argument_list|)
decl_stmt|;
name|tree
name|lhstype
init|=
name|TREE_TYPE
argument_list|(
name|lhsop
argument_list|)
decl_stmt|;
name|tree
name|rhstypesize
decl_stmt|;
name|tree
name|lhstypesize
decl_stmt|;
name|lhstypesize
operator|=
name|DECL_P
argument_list|(
name|lhsop
argument_list|)
condition|?
name|DECL_SIZE
argument_list|(
name|lhsop
argument_list|)
else|:
name|TYPE_SIZE
argument_list|(
name|lhstype
argument_list|)
expr_stmt|;
name|rhstypesize
operator|=
name|DECL_P
argument_list|(
name|rhsop
argument_list|)
condition|?
name|DECL_SIZE
argument_list|(
name|rhsop
argument_list|)
else|:
name|TYPE_SIZE
argument_list|(
name|rhstype
argument_list|)
expr_stmt|;
comment|/* If we have a variably sized types on the rhs or lhs, and a deref 	 constraint, add the constraint, lhsconstraint =&ANYTHING. 	 This is conservatively correct because either the lhs is an unknown 	 sized var (if the constraint is SCALAR), or the lhs is a DEREF 	 constraint, and every variable it can point to must be unknown sized 	 anyway, so we don't need to worry about fields at all.  */
if|if
condition|(
operator|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|TREE_CODE
argument_list|(
name|rhstypesize
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
operator|||
operator|(
name|lhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|TREE_CODE
argument_list|(
name|lhstypesize
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
block|{
name|rhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The size only really matters insofar as we don't set more or less of 	 the variable.  If we hit an unknown size var, the size should be the 	 whole darn thing.  */
if|if
condition|(
name|get_varinfo
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
operator|->
name|is_unknown_size_var
condition|)
name|rhssize
operator|=
operator|~
literal|0
expr_stmt|;
else|else
name|rhssize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|rhstypesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
operator|->
name|is_unknown_size_var
condition|)
name|lhssize
operator|=
operator|~
literal|0
expr_stmt|;
else|else
name|lhssize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|lhstypesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs
operator|.
name|type
operator|==
name|SCALAR
operator|&&
name|lhs
operator|.
name|type
operator|==
name|SCALAR
condition|)
block|{
if|if
condition|(
operator|!
name|do_simple_structure_copy
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|MIN
argument_list|(
name|lhssize
argument_list|,
name|rhssize
argument_list|)
argument_list|)
condition|)
block|{
name|lhs
operator|.
name|var
operator|=
name|collapse_rest_of_var
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|collapse_rest_of_var
argument_list|(
name|rhs
operator|.
name|var
argument_list|)
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lhs
operator|.
name|type
operator|!=
name|DEREF
operator|&&
name|rhs
operator|.
name|type
operator|==
name|DEREF
condition|)
name|do_rhs_deref_structure_copy
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|MIN
argument_list|(
name|lhssize
argument_list|,
name|rhssize
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|rhs
operator|.
name|type
operator|!=
name|DEREF
condition|)
name|do_lhs_deref_structure_copy
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|,
name|MIN
argument_list|(
name|lhssize
argument_list|,
name|rhssize
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|pointedtotype
init|=
name|lhstype
decl_stmt|;
name|tree
name|tmpvar
decl_stmt|;
name|gcc_assert
argument_list|(
name|rhs
operator|.
name|type
operator|==
name|DEREF
operator|&&
name|lhs
operator|.
name|type
operator|==
name|DEREF
argument_list|)
expr_stmt|;
name|tmpvar
operator|=
name|create_tmp_var_raw
argument_list|(
name|pointedtotype
argument_list|,
literal|"structcopydereftmp"
argument_list|)
expr_stmt|;
name|do_structure_copy
argument_list|(
name|tmpvar
argument_list|,
name|rhsop
argument_list|)
expr_stmt|;
name|do_structure_copy
argument_list|(
name|lhsop
argument_list|,
name|tmpvar
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Update related alias information kept in AI.  This is used when    building name tags, alias sets and deciding grouping heuristics.    STMT is the statement to process.  This function also updates    ADDRESSABLE_VARS.  */
end_comment

begin_function
specifier|static
name|void
name|update_alias_info
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|bitmap
name|addr_taken
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|enum
name|escape_type
name|stmt_escape_type
init|=
name|is_escape_site
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|op
decl_stmt|;
if|if
condition|(
name|stmt_escape_type
operator|==
name|ESCAPE_TO_CALL
operator|||
name|stmt_escape_type
operator|==
name|ESCAPE_TO_PURE_CONST
condition|)
block|{
name|ai
operator|->
name|num_calls_found
operator|++
expr_stmt|;
if|if
condition|(
name|stmt_escape_type
operator|==
name|ESCAPE_TO_PURE_CONST
condition|)
name|ai
operator|->
name|num_pure_const_calls_found
operator|++
expr_stmt|;
block|}
comment|/* Mark all the variables whose address are taken by the statement.  */
name|addr_taken
operator|=
name|addresses_taken
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_taken
condition|)
block|{
name|bitmap_ior_into
argument_list|(
name|addressable_vars
argument_list|,
name|addr_taken
argument_list|)
expr_stmt|;
comment|/* If STMT is an escape point, all the addresses taken by it are 	 call-clobbered.  */
if|if
condition|(
name|stmt_escape_type
operator|!=
name|NO_ESCAPE
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|addr_taken
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|tree
name|rvar
init|=
name|referenced_var
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|unmodifiable_var_p
argument_list|(
name|rvar
argument_list|)
condition|)
name|mark_call_clobbered
argument_list|(
name|rvar
argument_list|,
name|stmt_escape_type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Process each operand use.  If an operand may be aliased, keep      track of how many times it's being used.  For pointers, determine      whether they are dereferenced by the statement, or whether their      value escapes, etc.  */
name|FOR_EACH_PHI_OR_STMT_USE
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_USE
argument_list|)
block|{
name|tree
name|op
decl_stmt|,
name|var
decl_stmt|;
name|var_ann_t
name|v_ann
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
decl_stmt|;
name|bool
name|is_store
decl_stmt|,
name|is_potential_deref
decl_stmt|;
name|unsigned
name|num_uses
decl_stmt|,
name|num_derefs
decl_stmt|;
name|op
operator|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
comment|/* If STMT is a PHI node, OP may be an ADDR_EXPR.  If so, add it 	 to the set of addressable variables.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
argument_list|)
expr_stmt|;
comment|/* PHI nodes don't have annotations for pinning the set 	     of addresses taken, so we collect them here.  	     FIXME, should we allow PHI nodes to have annotations 	     so that they can be treated like regular statements? 	     Currently, they are treated as second-class 	     statements.  */
name|add_to_addressable_set
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|addressable_vars
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Ignore constants.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|SSA_NAME
condition|)
continue|continue;
name|var
operator|=
name|SSA_NAME_VAR
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|v_ann
operator|=
name|var_ann
argument_list|(
name|var
argument_list|)
expr_stmt|;
comment|/* The base variable of an ssa name must be a GIMPLE register, and thus 	 it cannot be aliased.  */
name|gcc_assert
argument_list|(
operator|!
name|may_be_aliased
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are only interested in pointers.  */
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
continue|continue;
name|pi
operator|=
name|get_ptr_info
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* Add OP to AI->PROCESSED_PTRS, if it's not there already.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|ai
operator|->
name|ssa_names_visited
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|ai
operator|->
name|ssa_names_visited
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|ai
operator|->
name|processed_ptrs
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* If STMT is a PHI node, then it will not have pointer 	 dereferences and it will not be an escape point.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
continue|continue;
comment|/* Determine whether OP is a dereferenced pointer, and if STMT 	 is an escape point, whether OP escapes.  */
name|count_uses_and_derefs
argument_list|(
name|op
argument_list|,
name|stmt
argument_list|,
operator|&
name|num_uses
argument_list|,
operator|&
name|num_derefs
argument_list|,
operator|&
name|is_store
argument_list|)
expr_stmt|;
comment|/* Handle a corner case involving address expressions of the 	 form '&PTR->FLD'.  The problem with these expressions is that 	 they do not represent a dereference of PTR.  However, if some 	 other transformation propagates them into an INDIRECT_REF 	 expression, we end up with '*(&PTR->FLD)' which is folded 	 into 'PTR->FLD'.  	 So, if the original code had no other dereferences of PTR, 	 the aliaser will not create memory tags for it, and when&PTR->FLD gets propagated to INDIRECT_REF expressions, the 	 memory operations will receive no V_MAY_DEF/VUSE operands.  	 One solution would be to have count_uses_and_derefs consider&PTR->FLD a dereference of PTR.  But that is wrong, since it 	 is not really a dereference but an offset calculation.  	 What we do here is to recognize these special ADDR_EXPR 	 nodes.  Since these expressions are never GIMPLE values (they 	 are not GIMPLE invariants), they can only appear on the RHS 	 of an assignment and their base address is always an 	 INDIRECT_REF expression.  */
name|is_potential_deref
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|!
name|is_gimple_val
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If the RHS if of the form&PTR->FLD and PTR == OP, then 	     this represents a potential dereference of PTR.  */
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|base
init|=
name|get_base_address
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|==
name|op
condition|)
name|is_potential_deref
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|num_derefs
operator|>
literal|0
operator|||
name|is_potential_deref
condition|)
block|{
comment|/* Mark OP as dereferenced.  In a subsequent pass, 	     dereferenced pointers that point to a set of 	     variables will be assigned a name tag to alias 	     all the variables OP points to.  */
name|pi
operator|->
name|is_dereferenced
operator|=
literal|1
expr_stmt|;
comment|/* Keep track of how many time we've dereferenced each 	     pointer.  */
name|NUM_REFERENCES_INC
argument_list|(
name|v_ann
argument_list|)
expr_stmt|;
comment|/* If this is a store operation, mark OP as being 	     dereferenced to store, otherwise mark it as being 	     dereferenced to load.  */
if|if
condition|(
name|is_store
condition|)
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_store
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_load
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stmt_escape_type
operator|!=
name|NO_ESCAPE
operator|&&
name|num_derefs
operator|<
name|num_uses
condition|)
block|{
comment|/* If STMT is an escape point and STMT contains at 	     least one direct use of OP, then the value of OP 	     escapes and so the pointed-to variables need to 	     be marked call-clobbered.  */
name|pi
operator|->
name|value_escapes_p
operator|=
literal|1
expr_stmt|;
name|pi
operator|->
name|escape_mask
operator||=
name|stmt_escape_type
expr_stmt|;
comment|/* If the statement makes a function call, assume 	     that pointer OP will be dereferenced in a store 	     operation inside the called function.  */
if|if
condition|(
name|get_call_expr_in
argument_list|(
name|stmt
argument_list|)
operator|||
name|stmt_escape_type
operator|==
name|ESCAPE_STORED_IN_GLOBAL
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|dereferenced_ptrs_store
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|is_dereferenced
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|PHI_NODE
condition|)
return|return;
comment|/* Update reference counter for definitions to any      potentially aliased variable.  This is used in the alias      grouping heuristics.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_DEF
argument_list|)
block|{
name|tree
name|var
init|=
name|SSA_NAME_VAR
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|var_ann_t
name|ann
init|=
name|var_ann
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|written_vars
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_be_aliased
argument_list|(
name|var
argument_list|)
condition|)
name|NUM_REFERENCES_INC
argument_list|(
name|ann
argument_list|)
expr_stmt|;
block|}
comment|/* Mark variables in V_MAY_DEF operands as being written to.  */
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|op
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VIRTUAL_DEFS
argument_list|)
block|{
name|tree
name|var
init|=
name|DECL_P
argument_list|(
name|op
argument_list|)
condition|?
name|op
else|:
name|SSA_NAME_VAR
argument_list|(
name|op
argument_list|)
decl_stmt|;
name|bitmap_set_bit
argument_list|(
name|ai
operator|->
name|written_vars
argument_list|,
name|DECL_UID
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle pointer arithmetic EXPR when creating aliasing constraints.    Expressions of the type PTR + CST can be handled in two ways:     1- If the constraint for PTR is ADDRESSOF for a non-structure       variable, then we can use it directly because adding or       subtracting a constant may not alter the original ADDRESSOF       constraint (i.e., pointer arithmetic may not legally go outside       an object's boundaries).     2- If the constraint for PTR is ADDRESSOF for a structure variable,       then if CST is a compile-time constant that can be used as an       offset, we can determine which sub-variable will be pointed-to       by the expression.     Return true if the expression is handled.  For any other kind of    expression, return false so that each operand can be added as a    separate constraint by the caller.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|handle_ptr_arith
argument_list|(
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|lhsc
argument_list|,
name|tree
name|expr
argument_list|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|j
init|=
literal|0
decl_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|temp
operator|=
name|NULL
expr_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|rhsoffset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|PLUS_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|MINUS_EXPR
condition|)
return|return
name|false
return|;
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_constraint_for
argument_list|(
name|op0
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|*
name|BITS_PER_UNIT
operator|)
operator|/
name|BITS_PER_UNIT
operator|!=
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
condition|)
return|return
name|false
return|;
name|rhsoffset
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|op1
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
block|}
else|else
return|return
name|false
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|temp
argument_list|,
name|j
argument_list|,
name|c2
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|ADDRESSOF
operator|&&
name|rhsoffset
operator|!=
literal|0
condition|)
block|{
name|varinfo_t
name|temp
init|=
name|get_varinfo
argument_list|(
name|c2
operator|->
name|var
argument_list|)
decl_stmt|;
comment|/* An access one after the end of an array is valid, 	       so simply punt on accesses we cannot resolve.  */
name|temp
operator|=
name|first_vi_for_offset
argument_list|(
name|temp
argument_list|,
name|rhsoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
continue|continue;
name|c2
operator|->
name|var
operator|=
name|temp
operator|->
name|id
expr_stmt|;
name|c2
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|c2
operator|->
name|offset
operator|=
name|rhsoffset
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|c2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Walk statement T setting up aliasing constraints according to the    references found in T.  This function is the main part of the    constraint builder.  AI points to auxiliary alias information used    when building alias sets and computing alias grouping heuristics.  */
end_comment

begin_function
specifier|static
name|void
name|find_func_aliases
parameter_list|(
name|tree
name|origt
parameter_list|)
block|{
name|tree
name|t
init|=
name|origt
decl_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|lhsc
operator|=
name|NULL
expr_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RETURN_EXPR
operator|&&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now build constraints expressions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PHI_NODE
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|PHI_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only care about pointers and structures containing 	 pointers.  */
if|if
condition|(
name|could_have_pointers
argument_list|(
name|PHI_RESULT
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* For a phi node, assign all the arguments to 	     the result.  */
name|get_constraint_for
argument_list|(
name|PHI_RESULT
argument_list|(
name|t
argument_list|)
argument_list|,
operator|&
name|lhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|rhstype
decl_stmt|;
name|tree
name|strippedrhs
init|=
name|PHI_ARG_DEF
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|strippedrhs
argument_list|)
expr_stmt|;
name|rhstype
operator|=
name|TREE_TYPE
argument_list|(
name|strippedrhs
argument_list|)
expr_stmt|;
name|get_constraint_for
argument_list|(
name|PHI_ARG_DEF
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|,
name|j
argument_list|,
name|c
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|constraint_expr
modifier|*
name|c2
decl_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|>
literal|0
condition|)
block|{
name|c2
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|c2
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* In IPA mode, we need to generate constraints to pass call      arguments through their calls.   There are two case, either a      modify_expr when we are returning a value, or just a plain      call_expr when we are not.   */
elseif|else
if|if
condition|(
name|in_ipa_mode
operator|&&
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|!
operator|(
name|call_expr_flags
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&
operator|(
name|ECF_MALLOC
operator||
name|ECF_MAY_BE_ALLOCA
operator|)
operator|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|!
operator|(
name|call_expr_flags
argument_list|(
name|t
argument_list|)
operator|&
operator|(
name|ECF_MALLOC
operator||
name|ECF_MAY_BE_ALLOCA
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|tree
name|lhsop
decl_stmt|;
name|tree
name|rhsop
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|varinfo_t
name|fi
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|lhsop
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhsop
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lhsop
operator|=
name|NULL
expr_stmt|;
name|rhsop
operator|=
name|t
expr_stmt|;
block|}
name|decl
operator|=
name|get_callee_fndecl
argument_list|(
name|rhsop
argument_list|)
expr_stmt|;
comment|/* If we can directly resolve the function being called, do so. 	 Otherwise, it must be some sort of indirect expression that 	 we should still be able to handle.  */
if|if
condition|(
name|decl
condition|)
block|{
name|fi
operator|=
name|get_vi_for_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|rhsop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fi
operator|=
name|get_vi_for_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Assign all the passed arguments to the appropriate incoming 	 parameters of the function.  */
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|rhsop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|arglist
condition|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
control|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
decl_stmt|;
name|struct
name|constraint_expr
name|lhs
decl_stmt|;
name|struct
name|constraint_expr
modifier|*
name|rhsp
decl_stmt|;
name|get_constraint_for
argument_list|(
name|arg
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|lhs
operator|.
name|type
operator|=
name|DEREF
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|fi
operator|->
name|id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|first_vi_for_offset
argument_list|(
name|fi
argument_list|,
name|i
argument_list|)
operator|->
name|id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rhsp
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
operator|*
name|rhsp
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
comment|/* If we are returning a value, assign it to the result.  */
if|if
condition|(
name|lhsop
condition|)
block|{
name|struct
name|constraint_expr
name|rhs
decl_stmt|;
name|struct
name|constraint_expr
modifier|*
name|lhsp
decl_stmt|;
name|unsigned
name|int
name|j
init|=
literal|0
decl_stmt|;
name|get_constraint_for
argument_list|(
name|lhsop
argument_list|,
operator|&
name|lhsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|rhs
operator|.
name|type
operator|=
name|DEREF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|fi
operator|->
name|id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|rhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|first_vi_for_offset
argument_list|(
name|fi
argument_list|,
name|i
argument_list|)
operator|->
name|id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|,
name|j
argument_list|,
name|lhsp
argument_list|)
condition|;
name|j
operator|++
control|)
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
operator|*
name|lhsp
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, just a regular assignment statement.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
block|{
name|tree
name|lhsop
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhsop
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhsop
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhsop
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|)
operator|&&
operator|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhsop
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhsop
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|)
condition|)
block|{
name|do_structure_copy
argument_list|(
name|lhsop
argument_list|,
name|rhsop
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Only care about operations with pointers, structures 	     containing pointers, dereferences, and call expressions.  */
if|if
condition|(
name|could_have_pointers
argument_list|(
name|lhsop
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|rhsop
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|get_constraint_for
argument_list|(
name|lhsop
argument_list|,
operator|&
name|lhsc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|rhsop
argument_list|)
argument_list|)
condition|)
block|{
comment|/* RHS that consist of unary operations, 		     exceptional types, or bare decls/constants, get 		     handled directly by get_constraint_for.  */
case|case
name|tcc_reference
case|:
case|case
name|tcc_declaration
case|:
case|case
name|tcc_constant
case|:
case|case
name|tcc_exceptional
case|:
case|case
name|tcc_expression
case|:
case|case
name|tcc_unary
case|:
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|get_constraint_for
argument_list|(
name|rhsop
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|,
name|j
argument_list|,
name|c
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|constraint_expr
modifier|*
name|c2
decl_stmt|;
name|unsigned
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|k
argument_list|,
name|c2
argument_list|)
condition|;
name|k
operator|++
control|)
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|c2
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|tcc_binary
case|:
block|{
comment|/* For pointer arithmetic of the form 			   PTR + CST, we can simply use PTR's 			   constraint because pointer arithmetic is 			   not allowed to go out of bounds.  */
if|if
condition|(
name|handle_ptr_arith
argument_list|(
name|lhsc
argument_list|,
name|rhsop
argument_list|)
condition|)
break|break;
block|}
comment|/* FALLTHRU  */
comment|/* Otherwise, walk each operand.  Notice that we 		     can't use the operand interface because we need 		     to process expressions other than simple operands 		     (e.g. INDIRECT_REF, ADDR_EXPR, CALL_EXPR).  */
default|default:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|rhsop
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|rhsop
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|get_constraint_for
argument_list|(
name|op
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|lhsc
argument_list|,
name|j
argument_list|,
name|c
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|constraint_expr
modifier|*
name|c2
decl_stmt|;
while|while
condition|(
name|VEC_length
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
operator|>
literal|0
condition|)
block|{
name|c2
operator|=
name|VEC_last
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
operator|*
name|c
argument_list|,
operator|*
name|c2
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_pop
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* After promoting variables and computing aliasing we will      need to re-scan most statements.  FIXME: Try to minimize the      number of statements re-scanned.  It's not really necessary to      re-scan *all* statements.  */
name|mark_stmt_modified
argument_list|(
name|origt
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|lhsc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the first varinfo in the same variable as START that overlaps with    OFFSET.    Effectively, walk the chain of fields for the variable START to find the    first field that overlaps with OFFSET.    Return NULL if we can't find one.  */
end_comment

begin_function
specifier|static
name|varinfo_t
name|first_vi_for_offset
parameter_list|(
name|varinfo_t
name|start
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|varinfo_t
name|curr
init|=
name|start
decl_stmt|;
while|while
condition|(
name|curr
condition|)
block|{
comment|/* We may not find a variable in the field list with the actual 	 offset when when we have glommed a structure to a variable. 	 In that case, however, offset should still be within the size 	 of the variable. */
if|if
condition|(
name|offset
operator|>=
name|curr
operator|->
name|offset
operator|&&
name|offset
operator|<
operator|(
name|curr
operator|->
name|offset
operator|+
name|curr
operator|->
name|size
operator|)
condition|)
return|return
name|curr
return|;
name|curr
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Insert the varinfo FIELD into the field list for BASE, at the front    of the list.  */
end_comment

begin_function
specifier|static
name|void
name|insert_into_field_list
parameter_list|(
name|varinfo_t
name|base
parameter_list|,
name|varinfo_t
name|field
parameter_list|)
block|{
name|varinfo_t
name|prev
init|=
name|base
decl_stmt|;
name|varinfo_t
name|curr
init|=
name|base
operator|->
name|next
decl_stmt|;
name|field
operator|->
name|next
operator|=
name|curr
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|field
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the varinfo FIELD into the field list for BASE, ordered by    offset.  */
end_comment

begin_function
specifier|static
name|void
name|insert_into_field_list_sorted
parameter_list|(
name|varinfo_t
name|base
parameter_list|,
name|varinfo_t
name|field
parameter_list|)
block|{
name|varinfo_t
name|prev
init|=
name|base
decl_stmt|;
name|varinfo_t
name|curr
init|=
name|base
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|curr
operator|==
name|NULL
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|field
expr_stmt|;
name|field
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|curr
condition|)
block|{
if|if
condition|(
name|field
operator|->
name|offset
operator|<=
name|curr
operator|->
name|offset
condition|)
break|break;
name|prev
operator|=
name|curr
expr_stmt|;
name|curr
operator|=
name|curr
operator|->
name|next
expr_stmt|;
block|}
name|field
operator|->
name|next
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|field
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* qsort comparison function for two fieldoff's PA and PB */
end_comment

begin_function
specifier|static
name|int
name|fieldoff_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|pa
parameter_list|,
specifier|const
name|void
modifier|*
name|pb
parameter_list|)
block|{
specifier|const
name|fieldoff_s
modifier|*
name|foa
init|=
operator|(
specifier|const
name|fieldoff_s
operator|*
operator|)
name|pa
decl_stmt|;
specifier|const
name|fieldoff_s
modifier|*
name|fob
init|=
operator|(
specifier|const
name|fieldoff_s
operator|*
operator|)
name|pb
decl_stmt|;
name|HOST_WIDE_INT
name|foasize
decl_stmt|,
name|fobsize
decl_stmt|;
if|if
condition|(
name|foa
operator|->
name|offset
operator|!=
name|fob
operator|->
name|offset
condition|)
return|return
name|foa
operator|->
name|offset
operator|-
name|fob
operator|->
name|offset
return|;
name|foasize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|foa
operator|->
name|size
argument_list|)
expr_stmt|;
name|fobsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fob
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|foasize
operator|-
name|fobsize
return|;
block|}
end_function

begin_comment
comment|/* Sort a fieldstack according to the field offset and sizes.  */
end_comment

begin_decl_stmt
name|void
name|sort_fieldstack
argument_list|(
name|VEC
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|)
operator|*
name|fieldstack
argument_list|)
block|{
name|qsort
argument_list|(
name|VEC_address
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|fieldoff_s
argument_list|)
argument_list|,
name|fieldoff_compare
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Given a TYPE, and a vector of field offsets FIELDSTACK, push all the fields    of TYPE onto fieldstack, recording their offsets along the way.    OFFSET is used to keep track of the offset in this entire structure, rather    than just the immediately containing structure.  Returns the number    of fields pushed.    HAS_UNION is set to true if we find a union type as a field of    TYPE.  */
end_comment

begin_decl_stmt
name|int
name|push_fields_onto_fieldstack
argument_list|(
name|tree
name|type
argument_list|,
name|VEC
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|fieldstack
argument_list|,
name|HOST_WIDE_INT
name|offset
argument_list|,
name|bool
operator|*
name|has_union
argument_list|)
block|{
name|tree
name|field
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|minoffset
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|fieldoff_s
modifier|*
name|real_part
decl_stmt|,
modifier|*
name|img_part
decl_stmt|;
name|real_part
operator|=
name|VEC_safe_push
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
operator|*
name|fieldstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|real_part
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|real_part
operator|->
name|size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|real_part
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|real_part
operator|->
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
name|img_part
operator|=
name|VEC_safe_push
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
operator|*
name|fieldstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|img_part
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|img_part
operator|->
name|size
operator|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|img_part
operator|->
name|offset
operator|=
name|offset
operator|+
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|img_part
operator|->
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
return|return
literal|2
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|sz
init|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|elsz
init|=
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|nr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sz
operator|||
operator|!
name|host_integerp
argument_list|(
name|sz
argument_list|,
literal|1
argument_list|)
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|sz
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|elsz
operator|||
operator|!
name|host_integerp
argument_list|(
name|elsz
argument_list|,
literal|1
argument_list|)
operator|||
name|TREE_INT_CST_LOW
argument_list|(
name|elsz
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|nr
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|sz
argument_list|)
operator|/
name|TREE_INT_CST_LOW
argument_list|(
name|elsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|>
name|SALIAS_MAX_ARRAY_ELEMENTS
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|push
init|=
name|false
decl_stmt|;
name|int
name|pushed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|has_union
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
operator|*
name|has_union
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
comment|/* var_can_have_subvars */
name|push
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|pushed
operator|=
name|push_fields_onto_fieldstack
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|fieldstack
argument_list|,
name|offset
operator|+
name|i
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|elsz
argument_list|)
argument_list|,
name|has_union
argument_list|)
operator|)
condition|)
comment|/* Empty structures may have actual size, like in C++. So 	       see if we didn't push any subfields and the size is 	       nonzero, push the field onto the stack */
name|push
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|push
condition|)
block|{
name|fieldoff_s
modifier|*
name|pair
decl_stmt|;
name|pair
operator|=
name|VEC_safe_push
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
operator|*
name|fieldstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pair
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|pair
operator|->
name|size
operator|=
name|elsz
expr_stmt|;
name|pair
operator|->
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
name|pair
operator|->
name|offset
operator|=
name|offset
operator|+
name|i
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|elsz
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
name|count
operator|+=
name|pushed
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|bool
name|push
init|=
name|false
decl_stmt|;
name|int
name|pushed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|has_union
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
condition|)
operator|*
name|has_union
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|var_can_have_subvars
argument_list|(
name|field
argument_list|)
condition|)
name|push
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|pushed
operator|=
name|push_fields_onto_fieldstack
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|fieldstack
argument_list|,
name|offset
operator|+
name|bitpos_of_field
argument_list|(
name|field
argument_list|)
argument_list|,
name|has_union
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
comment|/* Empty structures may have actual size, like in C++. So 	     see if we didn't push any subfields and the size is 	     nonzero, push the field onto the stack */
name|push
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|push
condition|)
block|{
name|fieldoff_s
modifier|*
name|pair
decl_stmt|;
name|pair
operator|=
name|VEC_safe_push
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
operator|*
name|fieldstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pair
operator|->
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|pair
operator|->
name|size
operator|=
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|pair
operator|->
name|decl
operator|=
name|field
expr_stmt|;
name|pair
operator|->
name|offset
operator|=
name|offset
operator|+
name|bitpos_of_field
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
name|count
operator|+=
name|pushed
expr_stmt|;
if|if
condition|(
name|bitpos_of_field
argument_list|(
name|field
argument_list|)
operator|<
name|minoffset
condition|)
name|minoffset
operator|=
name|bitpos_of_field
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
comment|/* We need to create a fake subvar for empty bases.  But _only_ for non-empty      classes.  */
if|if
condition|(
name|minoffset
operator|!=
literal|0
operator|&&
name|count
operator|!=
literal|0
condition|)
block|{
name|fieldoff_s
modifier|*
name|pair
decl_stmt|;
name|pair
operator|=
name|VEC_safe_push
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
operator|*
name|fieldstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pair
operator|->
name|type
operator|=
name|void_type_node
expr_stmt|;
name|pair
operator|->
name|size
operator|=
name|build_int_cst
argument_list|(
name|size_type_node
argument_list|,
name|minoffset
argument_list|)
expr_stmt|;
name|pair
operator|->
name|decl
operator|=
name|NULL
expr_stmt|;
name|pair
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_decl_stmt

begin_comment
comment|/* Create a constraint from ESCAPED_VARS variable to VI.  */
end_comment

begin_function
specifier|static
name|void
name|make_constraint_from_escaped
parameter_list|(
name|varinfo_t
name|vi
parameter_list|)
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|lhs
operator|.
name|var
operator|=
name|vi
operator|->
name|id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a constraint to the ESCAPED_VARS variable from constraint    expression RHS. */
end_comment

begin_function
specifier|static
name|void
name|make_constraint_to_escaped
parameter_list|(
name|struct
name|constraint_expr
name|rhs
parameter_list|)
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|;
name|lhs
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count the number of arguments DECL has, and set IS_VARARGS to true    if it is a varargs function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|count_num_arguments
parameter_list|(
name|tree
name|decl
parameter_list|,
name|bool
modifier|*
name|is_varargs
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|==
name|void_type_node
condition|)
break|break;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|t
condition|)
operator|*
name|is_varargs
operator|=
name|true
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Creation function node for DECL, using NAME, and return the index    of the variable we've created for the function.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|create_function_info_for
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|index
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|varinfo_t
name|vi
decl_stmt|;
name|tree
name|arg
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bool
name|is_varargs
init|=
name|false
decl_stmt|;
comment|/* Create the variable info.  */
name|vi
operator|=
name|new_var_info
argument_list|(
name|decl
argument_list|,
name|index
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|vi
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|vi
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|vi
operator|->
name|has_union
operator|=
literal|0
expr_stmt|;
name|vi
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|vi
operator|->
name|fullsize
operator|=
name|count_num_arguments
argument_list|(
name|decl
argument_list|,
operator|&
name|is_varargs
argument_list|)
operator|+
literal|1
expr_stmt|;
name|insert_vi_for_tree
argument_list|(
name|vi
operator|->
name|decl
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|stats
operator|.
name|total_vars
operator|++
expr_stmt|;
comment|/* If it's varargs, we don't know how many arguments it has, so we      can't do much.   */
if|if
condition|(
name|is_varargs
condition|)
block|{
name|vi
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|vi
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|vi
operator|->
name|is_unknown_size_var
operator|=
name|true
expr_stmt|;
return|return
name|index
return|;
block|}
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Set up variables for each argument.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|vi
operator|->
name|fullsize
condition|;
name|i
operator|++
control|)
block|{
name|varinfo_t
name|argvi
decl_stmt|;
specifier|const
name|char
modifier|*
name|newname
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|unsigned
name|int
name|newindex
decl_stmt|;
name|tree
name|argdecl
init|=
name|decl
decl_stmt|;
if|if
condition|(
name|arg
condition|)
name|argdecl
operator|=
name|arg
expr_stmt|;
name|newindex
operator|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|tempname
argument_list|,
literal|"%s.arg%d"
argument_list|,
name|name
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newname
operator|=
name|ggc_strdup
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|argvi
operator|=
name|new_var_info
argument_list|(
name|argdecl
argument_list|,
name|newindex
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|argvi
operator|->
name|decl
operator|=
name|argdecl
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|argvi
argument_list|)
expr_stmt|;
name|argvi
operator|->
name|offset
operator|=
name|i
expr_stmt|;
name|argvi
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|argvi
operator|->
name|fullsize
operator|=
name|vi
operator|->
name|fullsize
expr_stmt|;
name|argvi
operator|->
name|has_union
operator|=
name|false
expr_stmt|;
name|insert_into_field_list_sorted
argument_list|(
name|vi
argument_list|,
name|argvi
argument_list|)
expr_stmt|;
name|stats
operator|.
name|total_vars
operator|++
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
name|insert_vi_for_tree
argument_list|(
name|arg
argument_list|,
name|argvi
argument_list|)
expr_stmt|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create a variable for the return var.  */
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
operator|||
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|varinfo_t
name|resultvi
decl_stmt|;
specifier|const
name|char
modifier|*
name|newname
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|unsigned
name|int
name|newindex
decl_stmt|;
name|tree
name|resultdecl
init|=
name|decl
decl_stmt|;
name|vi
operator|->
name|fullsize
operator|++
expr_stmt|;
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
condition|)
name|resultdecl
operator|=
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|newindex
operator|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|tempname
argument_list|,
literal|"%s.result"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|newname
operator|=
name|ggc_strdup
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|resultvi
operator|=
name|new_var_info
argument_list|(
name|resultdecl
argument_list|,
name|newindex
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|resultvi
operator|->
name|decl
operator|=
name|resultdecl
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|resultvi
argument_list|)
expr_stmt|;
name|resultvi
operator|->
name|offset
operator|=
name|i
expr_stmt|;
name|resultvi
operator|->
name|size
operator|=
literal|1
expr_stmt|;
name|resultvi
operator|->
name|fullsize
operator|=
name|vi
operator|->
name|fullsize
expr_stmt|;
name|resultvi
operator|->
name|has_union
operator|=
name|false
expr_stmt|;
name|insert_into_field_list_sorted
argument_list|(
name|vi
argument_list|,
name|resultvi
argument_list|)
expr_stmt|;
name|stats
operator|.
name|total_vars
operator|++
expr_stmt|;
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
condition|)
name|insert_vi_for_tree
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|resultvi
argument_list|)
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Return true if FIELDSTACK contains fields that overlap.    FIELDSTACK is assumed to be sorted by offset.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|check_for_overlaps
argument_list|(
name|VEC
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|)
operator|*
name|fieldstack
argument_list|)
block|{
name|fieldoff_s
modifier|*
name|fo
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|HOST_WIDE_INT
name|lastoffset
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|,
name|i
argument_list|,
name|fo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fo
operator|->
name|offset
operator|==
name|lastoffset
condition|)
return|return
name|true
return|;
name|lastoffset
operator|=
name|fo
operator|->
name|offset
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/* This function is called through walk_tree to walk global    initializers looking for constraints we need to add to the    constraint list.  */
end_comment

begin_function
specifier|static
name|tree
name|find_global_initializers
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|viv
parameter_list|)
block|{
name|varinfo_t
name|vi
init|=
operator|(
name|varinfo_t
operator|)
name|viv
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* Dereferences and addressofs are the only important things 	 here, and i don't even remember if dereferences are legal 	 here in initializers.  */
case|case
name|INDIRECT_REF
case|:
case|case
name|ADDR_EXPR
case|:
block|{
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|get_constraint_for
argument_list|(
name|t
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|;
name|lhs
operator|.
name|var
operator|=
name|vi
operator|->
name|id
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
operator|*
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_DECL
case|:
comment|/* We might not have walked this because we skip 	 DECL_EXTERNALs during the initial scan.  */
if|if
condition|(
name|referenced_vars
condition|)
block|{
name|get_var_ann
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|referenced_var_check_and_insert
argument_list|(
name|t
argument_list|)
condition|)
name|mark_sym_for_renaming
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Create a varinfo structure for NAME and DECL, and add it to VARMAP.    This will also create any varinfo structures necessary for fields    of DECL.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|create_variable_info_for
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|int
name|index
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|varinfo_t
name|vi
decl_stmt|;
name|tree
name|decltype
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|declsize
init|=
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|?
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
else|:
name|TYPE_SIZE
argument_list|(
name|decltype
argument_list|)
decl_stmt|;
name|bool
name|notokay
init|=
name|false
decl_stmt|;
name|bool
name|hasunion
decl_stmt|;
name|bool
name|is_global
init|=
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|?
name|is_global_var
argument_list|(
name|decl
argument_list|)
else|:
name|false
decl_stmt|;
name|VEC
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|)
operator|*
name|fieldstack
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|in_ipa_mode
condition|)
return|return
name|create_function_info_for
argument_list|(
name|decl
argument_list|,
name|name
argument_list|)
return|;
name|hasunion
operator|=
name|TREE_CODE
argument_list|(
name|decltype
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|decltype
argument_list|)
operator|==
name|QUAL_UNION_TYPE
expr_stmt|;
if|if
condition|(
name|var_can_have_subvars
argument_list|(
name|decl
argument_list|)
operator|&&
name|use_field_sensitive
operator|&&
operator|!
name|hasunion
condition|)
block|{
name|push_fields_onto_fieldstack
argument_list|(
name|decltype
argument_list|,
operator|&
name|fieldstack
argument_list|,
literal|0
argument_list|,
operator|&
name|hasunion
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasunion
condition|)
block|{
name|VEC_free
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
name|fieldstack
argument_list|)
expr_stmt|;
name|notokay
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* If the variable doesn't have subvars, we may end up needing to      sort the field list and create fake variables for all the      fields.  */
name|vi
operator|=
name|new_var_info
argument_list|(
name|decl
argument_list|,
name|index
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|vi
operator|->
name|decl
operator|=
name|decl
expr_stmt|;
name|vi
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|vi
operator|->
name|has_union
operator|=
name|hasunion
expr_stmt|;
if|if
condition|(
operator|!
name|declsize
operator|||
name|TREE_CODE
argument_list|(
name|declsize
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|decltype
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|decltype
argument_list|)
operator|==
name|QUAL_UNION_TYPE
condition|)
block|{
name|vi
operator|->
name|is_unknown_size_var
operator|=
name|true
expr_stmt|;
name|vi
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|vi
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|vi
operator|->
name|fullsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|declsize
argument_list|)
expr_stmt|;
name|vi
operator|->
name|size
operator|=
name|vi
operator|->
name|fullsize
expr_stmt|;
block|}
name|insert_vi_for_tree
argument_list|(
name|vi
operator|->
name|decl
argument_list|,
name|vi
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|vi
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_global
operator|&&
operator|(
operator|!
name|flag_whole_program
operator|||
operator|!
name|in_ipa_mode
operator|)
condition|)
block|{
name|make_constraint_from_escaped
argument_list|(
name|vi
argument_list|)
expr_stmt|;
comment|/* If the variable can't be aliased, there is no point in 	 putting it in the set of nonlocal vars.  */
if|if
condition|(
name|may_be_aliased
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
condition|)
block|{
name|struct
name|constraint_expr
name|rhs
decl_stmt|;
name|rhs
operator|.
name|var
operator|=
name|index
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|make_constraint_to_escaped
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|walk_tree_without_duplicates
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|find_global_initializers
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vi
argument_list|)
expr_stmt|;
block|}
block|}
name|stats
operator|.
name|total_vars
operator|++
expr_stmt|;
if|if
condition|(
name|use_field_sensitive
operator|&&
operator|!
name|notokay
operator|&&
operator|!
name|vi
operator|->
name|is_unknown_size_var
operator|&&
name|var_can_have_subvars
argument_list|(
name|decl
argument_list|)
operator|&&
name|VEC_length
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
operator|<=
name|MAX_FIELDS_FOR_FIELD_SENSITIVE
condition|)
block|{
name|unsigned
name|int
name|newindex
init|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
decl_stmt|;
name|fieldoff_s
modifier|*
name|fo
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|notokay
operator|&&
name|VEC_iterate
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|,
name|i
argument_list|,
name|fo
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|fo
operator|->
name|size
operator|||
name|TREE_CODE
argument_list|(
name|fo
operator|->
name|size
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|fo
operator|->
name|offset
operator|<
literal|0
condition|)
block|{
name|notokay
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* We can't sort them if we have a field with a variable sized type, 	 which will make notokay = true.  In that case, we are going to return 	 without creating varinfos for the fields anyway, so sorting them is a 	 waste to boot.  */
if|if
condition|(
operator|!
name|notokay
condition|)
block|{
name|sort_fieldstack
argument_list|(
name|fieldstack
argument_list|)
expr_stmt|;
comment|/* Due to some C++ FE issues, like PR 22488, we might end up 	     what appear to be overlapping fields even though they, 	     in reality, do not overlap.  Until the C++ FE is fixed, 	     we will simply disable field-sensitivity for these cases.  */
name|notokay
operator|=
name|check_for_overlaps
argument_list|(
name|fieldstack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|VEC_length
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
operator|!=
literal|0
condition|)
name|fo
operator|=
name|VEC_index
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fo
operator|==
name|NULL
operator|||
name|notokay
condition|)
block|{
name|vi
operator|->
name|is_unknown_size_var
operator|=
literal|1
expr_stmt|;
name|vi
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|vi
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|VEC_free
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
name|fieldstack
argument_list|)
expr_stmt|;
return|return
name|index
return|;
block|}
name|vi
operator|->
name|size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fo
operator|->
name|size
argument_list|)
expr_stmt|;
name|vi
operator|->
name|offset
operator|=
name|fo
operator|->
name|offset
expr_stmt|;
for|for
control|(
name|i
operator|=
name|VEC_length
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
operator|&&
name|VEC_iterate
argument_list|(
name|fieldoff_s
argument_list|,
name|fieldstack
argument_list|,
name|i
argument_list|,
name|fo
argument_list|)
condition|;
name|i
operator|--
control|)
block|{
name|varinfo_t
name|newvi
decl_stmt|;
specifier|const
name|char
modifier|*
name|newname
init|=
literal|"NULL"
decl_stmt|;
name|char
modifier|*
name|tempname
decl_stmt|;
name|newindex
operator|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
if|if
condition|(
name|fo
operator|->
name|decl
condition|)
name|asprintf
argument_list|(
operator|&
name|tempname
argument_list|,
literal|"%s.%s"
argument_list|,
name|vi
operator|->
name|name
argument_list|,
name|alias_get_name
argument_list|(
name|fo
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|asprintf
argument_list|(
operator|&
name|tempname
argument_list|,
literal|"%s."
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|vi
operator|->
name|name
argument_list|,
name|fo
operator|->
name|offset
argument_list|)
expr_stmt|;
name|newname
operator|=
name|ggc_strdup
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
block|}
name|newvi
operator|=
name|new_var_info
argument_list|(
name|decl
argument_list|,
name|newindex
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|newvi
operator|->
name|offset
operator|=
name|fo
operator|->
name|offset
expr_stmt|;
name|newvi
operator|->
name|size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|fo
operator|->
name|size
argument_list|)
expr_stmt|;
name|newvi
operator|->
name|fullsize
operator|=
name|vi
operator|->
name|fullsize
expr_stmt|;
name|insert_into_field_list
argument_list|(
name|vi
argument_list|,
name|newvi
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|newvi
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_global
operator|&&
operator|(
operator|!
name|flag_whole_program
operator|||
operator|!
name|in_ipa_mode
operator|)
condition|)
block|{
comment|/* If the variable can't be aliased, there is no point in 		 putting it in the set of nonlocal vars.  */
if|if
condition|(
name|may_be_aliased
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
condition|)
block|{
name|struct
name|constraint_expr
name|rhs
decl_stmt|;
name|rhs
operator|.
name|var
operator|=
name|newindex
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|make_constraint_to_escaped
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
block|}
name|make_constraint_from_escaped
argument_list|(
name|newvi
argument_list|)
expr_stmt|;
block|}
name|stats
operator|.
name|total_vars
operator|++
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|fieldoff_s
argument_list|,
name|heap
argument_list|,
name|fieldstack
argument_list|)
expr_stmt|;
block|}
return|return
name|index
return|;
block|}
end_function

begin_comment
comment|/* Print out the points-to solution for VAR to FILE.  */
end_comment

begin_function
name|void
name|dump_solution_for_var
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|var
parameter_list|)
block|{
name|varinfo_t
name|vi
init|=
name|get_varinfo
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
if|if
condition|(
name|find
argument_list|(
name|var
argument_list|)
operator|!=
name|var
condition|)
block|{
name|varinfo_t
name|vipt
init|=
name|get_varinfo
argument_list|(
name|find
argument_list|(
name|var
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s = same as %s\n"
argument_list|,
name|vi
operator|->
name|name
argument_list|,
name|vipt
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s = { "
argument_list|,
name|vi
operator|->
name|name
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|vi->solution
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s "
argument_list|,
name|get_varinfo
argument_list|(
name|i
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the points-to solution for VAR to stdout.  */
end_comment

begin_function
name|void
name|debug_solution_for_var
parameter_list|(
name|unsigned
name|int
name|var
parameter_list|)
block|{
name|dump_solution_for_var
argument_list|(
name|stdout
argument_list|,
name|var
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create varinfo structures for all of the variables in the    function for intraprocedural mode.  */
end_comment

begin_function
specifier|static
name|void
name|intra_create_variable_infos
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|struct
name|constraint_expr
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|varinfo_t
name|nonlocal_vi
decl_stmt|;
comment|/* For each incoming pointer argument arg, ARG = ESCAPED_VARS or a      dummy variable if flag_argument_noalias> 2. */
for|for
control|(
name|t
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|varinfo_t
name|p
decl_stmt|;
name|unsigned
name|int
name|arg_id
decl_stmt|;
if|if
condition|(
operator|!
name|could_have_pointers
argument_list|(
name|t
argument_list|)
condition|)
continue|continue;
name|arg_id
operator|=
name|get_vi_for_tree
argument_list|(
name|t
argument_list|)
operator|->
name|id
expr_stmt|;
comment|/* With flag_argument_noalias greater than two means that the incoming          argument cannot alias anything except for itself so create a HEAP          variable.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
name|flag_argument_noalias
operator|>
literal|2
condition|)
block|{
name|varinfo_t
name|vi
decl_stmt|;
name|tree
name|heapvar
init|=
name|heapvar_lookup
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|get_vi_for_tree
argument_list|(
name|t
argument_list|)
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|heapvar
operator|==
name|NULL_TREE
condition|)
block|{
name|heapvar
operator|=
name|create_tmp_var_raw
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|,
literal|"PARM_NOALIAS"
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|heapvar
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|referenced_vars
condition|)
name|add_referenced_var
argument_list|(
name|heapvar
argument_list|)
expr_stmt|;
name|heapvar_insert
argument_list|(
name|t
argument_list|,
name|heapvar
argument_list|)
expr_stmt|;
block|}
name|vi
operator|=
name|get_vi_for_tree
argument_list|(
name|heapvar
argument_list|)
expr_stmt|;
name|vi
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|vi
operator|->
name|is_heap_var
operator|=
literal|1
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|vi
operator|->
name|id
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|get_varinfo
argument_list|(
name|lhs
operator|.
name|var
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|struct
name|constraint_expr
name|temp
init|=
name|lhs
decl_stmt|;
name|temp
operator|.
name|var
operator|=
name|p
operator|->
name|id
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|temp
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|get_varinfo
argument_list|(
name|arg_id
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
name|make_constraint_from_escaped
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|nonlocal_all
condition|)
name|nonlocal_all
operator|=
name|create_nonlocal_var
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Create variable info for the nonlocal var if it does not      exist.  */
name|nonlocal_vars_id
operator|=
name|create_variable_info_for
argument_list|(
name|nonlocal_all
argument_list|,
name|get_name
argument_list|(
name|nonlocal_all
argument_list|)
argument_list|)
expr_stmt|;
name|nonlocal_vi
operator|=
name|get_varinfo
argument_list|(
name|nonlocal_vars_id
argument_list|)
expr_stmt|;
name|nonlocal_vi
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|nonlocal_vi
operator|->
name|is_heap_var
operator|=
literal|1
expr_stmt|;
name|nonlocal_vi
operator|->
name|is_unknown_size_var
operator|=
literal|1
expr_stmt|;
name|nonlocal_vi
operator|->
name|directly_dereferenced
operator|=
name|true
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|nonlocal_vars_id
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Structure used to put solution bitmaps in a hashtable so they can    be shared among variables with the same points-to set.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|shared_bitmap_info
block|{
name|bitmap
name|pt_vars
decl_stmt|;
name|hashval_t
name|hashcode
decl_stmt|;
block|}
typedef|*
name|shared_bitmap_info_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|htab_t
name|shared_bitmap_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash function for a shared_bitmap_info_t */
end_comment

begin_function
specifier|static
name|hashval_t
name|shared_bitmap_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|shared_bitmap_info_t
name|bi
init|=
operator|(
name|shared_bitmap_info_t
operator|)
name|p
decl_stmt|;
return|return
name|bi
operator|->
name|hashcode
return|;
block|}
end_function

begin_comment
comment|/* Equality function for two shared_bitmap_info_t's. */
end_comment

begin_function
specifier|static
name|int
name|shared_bitmap_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|shared_bitmap_info_t
name|sbi1
init|=
operator|(
name|shared_bitmap_info_t
operator|)
name|p1
decl_stmt|;
specifier|const
name|shared_bitmap_info_t
name|sbi2
init|=
operator|(
name|shared_bitmap_info_t
operator|)
name|p2
decl_stmt|;
return|return
name|bitmap_equal_p
argument_list|(
name|sbi1
operator|->
name|pt_vars
argument_list|,
name|sbi2
operator|->
name|pt_vars
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup a bitmap in the shared bitmap hashtable, and return an already    existing instance if there is one, NULL otherwise.  */
end_comment

begin_function
specifier|static
name|bitmap
name|shared_bitmap_lookup
parameter_list|(
name|bitmap
name|pt_vars
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|shared_bitmap_info
name|sbi
decl_stmt|;
name|sbi
operator|.
name|pt_vars
operator|=
name|pt_vars
expr_stmt|;
name|sbi
operator|.
name|hashcode
operator|=
name|bitmap_hash
argument_list|(
name|pt_vars
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|shared_bitmap_table
argument_list|,
operator|&
name|sbi
argument_list|,
name|sbi
operator|.
name|hashcode
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slot
condition|)
return|return
name|NULL
return|;
else|else
return|return
operator|(
operator|(
name|shared_bitmap_info_t
operator|)
operator|*
name|slot
operator|)
operator|->
name|pt_vars
return|;
block|}
end_function

begin_comment
comment|/* Add a bitmap to the shared bitmap hashtable.  */
end_comment

begin_function
specifier|static
name|void
name|shared_bitmap_add
parameter_list|(
name|bitmap
name|pt_vars
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|shared_bitmap_info_t
name|sbi
init|=
name|XNEW
argument_list|(
expr|struct
name|shared_bitmap_info
argument_list|)
decl_stmt|;
name|sbi
operator|->
name|pt_vars
operator|=
name|pt_vars
expr_stmt|;
name|sbi
operator|->
name|hashcode
operator|=
name|bitmap_hash
argument_list|(
name|pt_vars
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|shared_bitmap_table
argument_list|,
name|sbi
argument_list|,
name|sbi
operator|->
name|hashcode
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
operator|*
name|slot
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|sbi
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set bits in INTO corresponding to the variable uids in solution set    FROM, which came from variable PTR.    For variables that are actually dereferenced, we also use type    based alias analysis to prune the points-to sets.  */
end_comment

begin_function
specifier|static
name|void
name|set_uids_in_ptset
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|bitmap
name|into
parameter_list|,
name|bitmap
name|from
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|subvar_t
name|sv
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ptr_alias_set
init|=
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|from
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|varinfo_t
name|vi
init|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|var_alias_set
decl_stmt|;
comment|/* The only artificial variables that are allowed in a may-alias 	 set are heap variables.  */
if|if
condition|(
name|vi
operator|->
name|is_artificial_var
operator|&&
operator|!
name|vi
operator|->
name|is_heap_var
condition|)
continue|continue;
if|if
condition|(
name|vi
operator|->
name|has_union
operator|&&
name|get_subvars_for_var
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Variables containing unions may need to be converted to 	     their SFT's, because SFT's can have unions and we cannot.  */
for|for
control|(
name|sv
operator|=
name|get_subvars_for_var
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
init|;
name|sv
condition|;
name|sv
operator|=
name|sv
operator|->
name|next
control|)
name|bitmap_set_bit
argument_list|(
name|into
argument_list|,
name|DECL_UID
argument_list|(
name|sv
operator|->
name|var
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|==
name|RESULT_DECL
condition|)
block|{
if|if
condition|(
name|var_can_have_subvars
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|&&
name|get_subvars_for_var
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
condition|)
block|{
comment|/* If VI->DECL is an aggregate for which we created 		 SFTs, add the SFT corresponding to VI->OFFSET.  */
name|tree
name|sft
init|=
name|get_subvar_at
argument_list|(
name|vi
operator|->
name|decl
argument_list|,
name|vi
operator|->
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|sft
condition|)
block|{
name|var_alias_set
operator|=
name|get_alias_set
argument_list|(
name|sft
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vi
operator|->
name|directly_dereferenced
operator|||
name|alias_sets_conflict_p
argument_list|(
name|ptr_alias_set
argument_list|,
name|var_alias_set
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|into
argument_list|,
name|DECL_UID
argument_list|(
name|sft
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise, just add VI->DECL to the alias set. 		 Don't type prune artificial vars.  */
if|if
condition|(
name|vi
operator|->
name|is_artificial_var
condition|)
name|bitmap_set_bit
argument_list|(
name|into
argument_list|,
name|DECL_UID
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|var_alias_set
operator|=
name|get_alias_set
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vi
operator|->
name|directly_dereferenced
operator|||
name|alias_sets_conflict_p
argument_list|(
name|ptr_alias_set
argument_list|,
name|var_alias_set
argument_list|)
condition|)
name|bitmap_set_bit
argument_list|(
name|into
argument_list|,
name|DECL_UID
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|bool
name|have_alias_info
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a pointer variable P, fill in its points-to set, or return    false if we can't.  */
end_comment

begin_function
name|bool
name|find_what_p_points_to
parameter_list|(
name|tree
name|p
parameter_list|)
block|{
name|tree
name|lookup_p
init|=
name|p
decl_stmt|;
name|varinfo_t
name|vi
decl_stmt|;
if|if
condition|(
operator|!
name|have_alias_info
condition|)
return|return
name|false
return|;
comment|/* For parameters, get at the points-to set for the actual parm      decl.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|p
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|TREE_CODE
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|default_def
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|p
condition|)
name|lookup_p
operator|=
name|SSA_NAME_VAR
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vi
operator|=
name|lookup_vi_for_tree
argument_list|(
name|lookup_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|vi
condition|)
block|{
if|if
condition|(
name|vi
operator|->
name|is_artificial_var
condition|)
return|return
name|false
return|;
comment|/* See if this is a field or a structure.  */
if|if
condition|(
name|vi
operator|->
name|size
operator|!=
name|vi
operator|->
name|fullsize
condition|)
block|{
comment|/* Nothing currently asks about structure fields directly, 	     but when they do, we need code here to hand back the 	     points-to set.  */
if|if
condition|(
operator|!
name|var_can_have_subvars
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|||
name|get_subvars_for_var
argument_list|(
name|vi
operator|->
name|decl
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|get_ptr_info
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|bitmap
name|finished_solution
decl_stmt|;
name|bitmap
name|result
decl_stmt|;
comment|/* This variable may have been collapsed, let's get the real 	     variable.  */
name|vi
operator|=
name|get_varinfo
argument_list|(
name|find
argument_list|(
name|vi
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Translate artificial variables into SSA_NAME_PTR_INFO 	     attributes.  */
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|vi->solution
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|varinfo_t
name|vi
init|=
name|get_varinfo
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|vi
operator|->
name|is_artificial_var
condition|)
block|{
comment|/* FIXME.  READONLY should be handled better so that 		     flow insensitive aliasing can disregard writable 		     aliases.  */
if|if
condition|(
name|vi
operator|->
name|id
operator|==
name|nothing_id
condition|)
name|pi
operator|->
name|pt_null
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|vi
operator|->
name|id
operator|==
name|anything_id
condition|)
name|pi
operator|->
name|pt_anything
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|vi
operator|->
name|id
operator|==
name|readonly_id
condition|)
name|pi
operator|->
name|pt_anything
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|vi
operator|->
name|id
operator|==
name|integer_id
condition|)
name|pi
operator|->
name|pt_anything
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|vi
operator|->
name|is_heap_var
condition|)
name|pi
operator|->
name|pt_global_mem
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pi
operator|->
name|pt_anything
condition|)
return|return
name|false
return|;
name|finished_solution
operator|=
name|BITMAP_GGC_ALLOC
argument_list|()
expr_stmt|;
name|set_uids_in_ptset
argument_list|(
name|vi
operator|->
name|decl
argument_list|,
name|finished_solution
argument_list|,
name|vi
operator|->
name|solution
argument_list|)
expr_stmt|;
name|result
operator|=
name|shared_bitmap_lookup
argument_list|(
name|finished_solution
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|shared_bitmap_add
argument_list|(
name|finished_solution
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pt_vars
operator|=
name|finished_solution
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|pt_vars
operator|=
name|result
expr_stmt|;
name|bitmap_clear
argument_list|(
name|finished_solution
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitmap_empty_p
argument_list|(
name|pi
operator|->
name|pt_vars
argument_list|)
condition|)
name|pi
operator|->
name|pt_vars
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Dump points-to information to OUTFILE.  */
end_comment

begin_function
name|void
name|dump_sa_points_to_info
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\nPoints-to sets\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_flags
operator|&
name|TDF_STATS
condition|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Stats:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Total vars:               %d\n"
argument_list|,
name|stats
operator|.
name|total_vars
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Non-pointer vars:          %d\n"
argument_list|,
name|stats
operator|.
name|nonpointer_vars
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Statically unified vars:  %d\n"
argument_list|,
name|stats
operator|.
name|unified_vars_static
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Dynamically unified vars: %d\n"
argument_list|,
name|stats
operator|.
name|unified_vars_dynamic
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Iterations:               %d\n"
argument_list|,
name|stats
operator|.
name|iterations
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Number of edges:          %d\n"
argument_list|,
name|stats
operator|.
name|num_edges
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"Number of implicit edges: %d\n"
argument_list|,
name|stats
operator|.
name|num_implicit_edges
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
condition|;
name|i
operator|++
control|)
name|dump_solution_for_var
argument_list|(
name|outfile
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Debug points-to information to stderr.  */
end_comment

begin_function
name|void
name|debug_sa_points_to_info
parameter_list|(
name|void
parameter_list|)
block|{
name|dump_sa_points_to_info
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the always-existing constraint variables for NULL    ANYTHING, READONLY, and INTEGER */
end_comment

begin_function
specifier|static
name|void
name|init_base_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|constraint_expr
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
comment|/* Create the NULL variable, used to represent that a variable points      to NULL.  */
name|nothing_tree
operator|=
name|create_tmp_var_raw
argument_list|(
name|void_type_node
argument_list|,
literal|"NULL"
argument_list|)
expr_stmt|;
name|var_nothing
operator|=
name|new_var_info
argument_list|(
name|nothing_tree
argument_list|,
literal|0
argument_list|,
literal|"NULL"
argument_list|)
expr_stmt|;
name|insert_vi_for_tree
argument_list|(
name|nothing_tree
argument_list|,
name|var_nothing
argument_list|)
expr_stmt|;
name|var_nothing
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|var_nothing
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|var_nothing
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|var_nothing
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|var_nothing
operator|->
name|is_special_var
operator|=
literal|1
expr_stmt|;
name|nothing_id
operator|=
literal|0
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|var_nothing
argument_list|)
expr_stmt|;
comment|/* Create the ANYTHING variable, used to represent that a variable      points to some unknown piece of memory.  */
name|anything_tree
operator|=
name|create_tmp_var_raw
argument_list|(
name|void_type_node
argument_list|,
literal|"ANYTHING"
argument_list|)
expr_stmt|;
name|var_anything
operator|=
name|new_var_info
argument_list|(
name|anything_tree
argument_list|,
literal|1
argument_list|,
literal|"ANYTHING"
argument_list|)
expr_stmt|;
name|insert_vi_for_tree
argument_list|(
name|anything_tree
argument_list|,
name|var_anything
argument_list|)
expr_stmt|;
name|var_anything
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|var_anything
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|var_anything
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|var_anything
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|var_anything
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|var_anything
operator|->
name|is_special_var
operator|=
literal|1
expr_stmt|;
name|anything_id
operator|=
literal|1
expr_stmt|;
comment|/* Anything points to anything.  This makes deref constraints just      work in the presence of linked list and other p = *p type loops,       by saying that *ANYTHING = ANYTHING. */
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|var_anything
argument_list|)
expr_stmt|;
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* This specifically does not use process_constraint because      process_constraint ignores all anything = anything constraints, since all      but this one are redundant.  */
name|VEC_safe_push
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|constraints
argument_list|,
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the READONLY variable, used to represent that a variable      points to readonly memory.  */
name|readonly_tree
operator|=
name|create_tmp_var_raw
argument_list|(
name|void_type_node
argument_list|,
literal|"READONLY"
argument_list|)
expr_stmt|;
name|var_readonly
operator|=
name|new_var_info
argument_list|(
name|readonly_tree
argument_list|,
literal|2
argument_list|,
literal|"READONLY"
argument_list|)
expr_stmt|;
name|var_readonly
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|var_readonly
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|var_readonly
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|var_readonly
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|var_readonly
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|var_readonly
operator|->
name|is_special_var
operator|=
literal|1
expr_stmt|;
name|insert_vi_for_tree
argument_list|(
name|readonly_tree
argument_list|,
name|var_readonly
argument_list|)
expr_stmt|;
name|readonly_id
operator|=
literal|2
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|var_readonly
argument_list|)
expr_stmt|;
comment|/* readonly memory points to anything, in order to make deref      easier.  In reality, it points to anything the particular      readonly variable can point to, but we don't track this      separately. */
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|readonly_id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the INTEGER variable, used to represent that a variable points      to an INTEGER.  */
name|integer_tree
operator|=
name|create_tmp_var_raw
argument_list|(
name|void_type_node
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|var_integer
operator|=
name|new_var_info
argument_list|(
name|integer_tree
argument_list|,
literal|3
argument_list|,
literal|"INTEGER"
argument_list|)
expr_stmt|;
name|insert_vi_for_tree
argument_list|(
name|integer_tree
argument_list|,
name|var_integer
argument_list|)
expr_stmt|;
name|var_integer
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|var_integer
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|var_integer
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|var_integer
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|var_integer
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|var_integer
operator|->
name|is_special_var
operator|=
literal|1
expr_stmt|;
name|integer_id
operator|=
literal|3
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|var_integer
argument_list|)
expr_stmt|;
comment|/* INTEGER = ANYTHING, because we don't know where a dereference of      a random integer will point to.  */
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|integer_id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|ADDRESSOF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|anything_id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the ESCAPED_VARS variable used to represent variables that      escape this function.  */
name|escaped_vars_tree
operator|=
name|create_tmp_var_raw
argument_list|(
name|void_type_node
argument_list|,
literal|"ESCAPED_VARS"
argument_list|)
expr_stmt|;
name|var_escaped_vars
operator|=
name|new_var_info
argument_list|(
name|escaped_vars_tree
argument_list|,
literal|4
argument_list|,
literal|"ESCAPED_VARS"
argument_list|)
expr_stmt|;
name|insert_vi_for_tree
argument_list|(
name|escaped_vars_tree
argument_list|,
name|var_escaped_vars
argument_list|)
expr_stmt|;
name|var_escaped_vars
operator|->
name|is_artificial_var
operator|=
literal|1
expr_stmt|;
name|var_escaped_vars
operator|->
name|size
operator|=
operator|~
literal|0
expr_stmt|;
name|var_escaped_vars
operator|->
name|fullsize
operator|=
operator|~
literal|0
expr_stmt|;
name|var_escaped_vars
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|var_escaped_vars
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|escaped_vars_id
operator|=
literal|4
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|,
name|var_escaped_vars
argument_list|)
expr_stmt|;
comment|/* ESCAPED_VARS = *ESCAPED_VARS */
name|lhs
operator|.
name|type
operator|=
name|SCALAR
expr_stmt|;
name|lhs
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|lhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|rhs
operator|.
name|type
operator|=
name|DEREF
expr_stmt|;
name|rhs
operator|.
name|var
operator|=
name|escaped_vars_id
expr_stmt|;
name|rhs
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|process_constraint
argument_list|(
name|new_constraint
argument_list|(
name|lhs
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize things necessary to perform PTA */
end_comment

begin_function
specifier|static
name|void
name|init_alias_vars
parameter_list|(
name|void
parameter_list|)
block|{
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|pta_obstack
argument_list|)
expr_stmt|;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|oldpta_obstack
argument_list|)
expr_stmt|;
name|bitmap_obstack_initialize
argument_list|(
operator|&
name|predbitmap_obstack
argument_list|)
expr_stmt|;
name|constraint_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Constraint pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|constraint
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|variable_info_pool
operator|=
name|create_alloc_pool
argument_list|(
literal|"Variable info pool"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|variable_info
argument_list|)
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|constraints
operator|=
name|VEC_alloc
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|varmap
operator|=
name|VEC_alloc
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|vi_for_tree
operator|=
name|pointer_map_create
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|shared_bitmap_table
operator|=
name|htab_create
argument_list|(
literal|511
argument_list|,
name|shared_bitmap_hash
argument_list|,
name|shared_bitmap_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|init_base_vars
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a statement STMT, generate necessary constraints to    escaped_vars for the escaping variables.  */
end_comment

begin_function
specifier|static
name|void
name|find_escape_constraints
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|enum
name|escape_type
name|stmt_escape_type
init|=
name|is_escape_site
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|rhs
decl_stmt|;
name|VEC
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|)
operator|*
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|struct
name|constraint_expr
modifier|*
name|c
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|stmt_escape_type
operator|==
name|NO_ESCAPE
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|RETURN_EXPR
condition|)
block|{
comment|/* Returns are either bare, with an embedded MODIFY_EXPR, or 	 just a plain old expression.  */
if|if
condition|(
operator|!
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get_constraint_for
argument_list|(
name|rhs
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
name|make_constraint_to_escaped
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|ASM_EXPR
condition|)
block|{
comment|/* Whatever the inputs of the ASM are, escape.  */
name|tree
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|ASM_INPUTS
argument_list|(
name|stmt
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|get_constraint_for
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
name|make_constraint_to_escaped
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|CALL_EXPR
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CALL_EXPR
operator|)
condition|)
block|{
comment|/* Calls cause all of the arguments passed in to escape.  */
name|tree
name|arg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|arg
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
init|;
name|arg
condition|;
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
control|)
block|{
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|rhsc
operator|=
name|NULL
expr_stmt|;
name|get_constraint_for
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg
argument_list|)
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
name|make_constraint_to_escaped
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|stmt_escape_type
operator|==
name|ESCAPE_BAD_CAST
operator|||
name|stmt_escape_type
operator|==
name|ESCAPE_STORED_IN_GLOBAL
operator|||
name|stmt_escape_type
operator|==
name|ESCAPE_UNKNOWN
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Look through casts for the real escaping variable.      Constants don't really escape, so ignore them.      Otherwise, whatever escapes must be on our RHS.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
block|{
name|get_constraint_for
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_CLASS_P
argument_list|(
name|rhs
argument_list|)
condition|)
return|return;
else|else
block|{
name|get_constraint_for
argument_list|(
name|rhs
argument_list|,
operator|&
name|rhsc
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|ce_s
argument_list|,
name|rhsc
argument_list|,
name|i
argument_list|,
name|c
argument_list|)
condition|;
name|i
operator|++
control|)
name|make_constraint_to_escaped
argument_list|(
operator|*
name|c
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|ce_s
argument_list|,
name|heap
argument_list|,
name|rhsc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the REF and ADDRESS edges from GRAPH, as well as all the    predecessor edges.  */
end_comment

begin_function
specifier|static
name|void
name|remove_preds_and_fake_succs
parameter_list|(
name|constraint_graph_t
name|graph
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Clear the implicit ref and address nodes from the successor      lists.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_REF_NODE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|graph
operator|->
name|succs
index|[
name|i
index|]
condition|)
name|bitmap_clear_range
argument_list|(
name|graph
operator|->
name|succs
index|[
name|i
index|]
argument_list|,
name|FIRST_REF_NODE
argument_list|,
name|FIRST_REF_NODE
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Free the successor list for the non-ref nodes.  */
for|for
control|(
name|i
operator|=
name|FIRST_REF_NODE
init|;
name|i
operator|<
name|graph
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|graph
operator|->
name|succs
index|[
name|i
index|]
condition|)
name|BITMAP_FREE
argument_list|(
name|graph
operator|->
name|succs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Now reallocate the size of the successor list as, and blow away      the predecessor bitmaps.  */
name|graph
operator|->
name|size
operator|=
name|VEC_length
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|)
expr_stmt|;
name|graph
operator|->
name|succs
operator|=
name|xrealloc
argument_list|(
name|graph
operator|->
name|succs
argument_list|,
name|graph
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|bitmap
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|implicit_preds
argument_list|)
expr_stmt|;
name|graph
operator|->
name|implicit_preds
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|preds
argument_list|)
expr_stmt|;
name|graph
operator|->
name|preds
operator|=
name|NULL
expr_stmt|;
name|bitmap_obstack_release
argument_list|(
operator|&
name|predbitmap_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create points-to sets for the current function.  See the comments    at the start of the file for an algorithmic overview.  */
end_comment

begin_function
name|void
name|compute_points_to_sets
parameter_list|(
name|struct
name|alias_info
modifier|*
name|ai
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|struct
name|scc_info
modifier|*
name|si
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_TREE_PTA
argument_list|)
expr_stmt|;
name|init_alias_vars
argument_list|()
expr_stmt|;
name|init_alias_heapvars
argument_list|()
expr_stmt|;
name|intra_create_variable_infos
argument_list|()
expr_stmt|;
comment|/* Now walk all statements and derive aliases.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|TREE_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
block|{
name|find_func_aliases
argument_list|(
name|phi
argument_list|)
expr_stmt|;
comment|/* Update various related attributes like escaped 		 addresses, pointer dereferences for loads and stores. 		 This is used when creating name tags and alias 		 sets.  */
name|update_alias_info
argument_list|(
name|phi
argument_list|,
name|ai
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
decl_stmt|;
name|find_func_aliases
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|find_escape_constraints
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
comment|/* Update various related attributes like escaped 	     addresses, pointer dereferences for loads and stores. 	     This is used when creating name tags and alias 	     sets.  */
name|update_alias_info
argument_list|(
name|stmt
argument_list|,
name|ai
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Points-to analysis\n\nConstraints:\n\n"
argument_list|)
expr_stmt|;
name|dump_constraints
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nCollapsing static cycles and doing variable "
literal|"substitution:\n"
argument_list|)
expr_stmt|;
name|build_pred_graph
argument_list|()
expr_stmt|;
name|si
operator|=
name|perform_var_substitution
argument_list|(
name|graph
argument_list|)
expr_stmt|;
name|move_complex_constraints
argument_list|(
name|graph
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|free_var_substitution_info
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|build_succ_graph
argument_list|()
expr_stmt|;
name|find_indirect_cycles
argument_list|(
name|graph
argument_list|)
expr_stmt|;
comment|/* Implicit nodes and predecessors are no longer necessary at this      point. */
name|remove_preds_and_fake_succs
argument_list|(
name|graph
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\nSolving graph:\n"
argument_list|)
expr_stmt|;
name|solve_graph
argument_list|(
name|graph
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|dump_sa_points_to_info
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
name|have_alias_info
operator|=
name|true
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_TREE_PTA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete created points-to sets.  */
end_comment

begin_function
name|void
name|delete_points_to_sets
parameter_list|(
name|void
parameter_list|)
block|{
name|varinfo_t
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|htab_delete
argument_list|(
name|shared_bitmap_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Points to sets created:%d\n"
argument_list|,
name|stats
operator|.
name|points_to_sets_created
argument_list|)
expr_stmt|;
name|pointer_map_destroy
argument_list|(
name|vi_for_tree
argument_list|)
expr_stmt|;
name|bitmap_obstack_release
argument_list|(
operator|&
name|pta_obstack
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|constraints
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|varinfo_t
argument_list|,
name|varmap
argument_list|,
name|i
argument_list|,
name|v
argument_list|)
condition|;
name|i
operator|++
control|)
name|VEC_free
argument_list|(
name|constraint_t
argument_list|,
name|heap
argument_list|,
name|graph
operator|->
name|complex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|complex
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|rep
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|succs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
operator|->
name|indirect_cycles
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|graph
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|varinfo_t
argument_list|,
name|heap
argument_list|,
name|varmap
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|variable_info_pool
argument_list|)
expr_stmt|;
name|free_alloc_pool
argument_list|(
name|constraint_pool
argument_list|)
expr_stmt|;
name|have_alias_info
operator|=
name|false
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if we should execute IPA PTA.  */
end_comment

begin_function
specifier|static
name|bool
name|gate_ipa_pta
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|flag_unit_at_a_time
operator|!=
literal|0
operator|&&
name|flag_ipa_pta
comment|/* Don't bother doing anything if the program has errors.  */
operator|&&
operator|!
operator|(
name|errorcount
operator|||
name|sorrycount
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Execute the driver for IPA PTA.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ipa_pta_execute
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct cgraph_node *node;   in_ipa_mode = 1;   init_alias_heapvars ();   init_alias_vars ();       for (node = cgraph_nodes; node; node = node->next)     {       if (!node->analyzed || cgraph_is_master_clone (node)) 	{ 	  unsigned int varid; 	   	  varid = create_function_info_for (node->decl,  					    cgraph_node_name (node)); 	  if (node->local.externally_visible) 	    { 	      varinfo_t fi = get_varinfo (varid); 	      for (; fi; fi = fi->next) 		make_constraint_from_escaped (fi); 	    } 	}     }   for (node = cgraph_nodes; node; node = node->next)     {       if (node->analyzed&& cgraph_is_master_clone (node)) 	{ 	  struct function *cfun = DECL_STRUCT_FUNCTION (node->decl); 	  basic_block bb; 	  tree old_func_decl = current_function_decl; 	  if (dump_file) 	    fprintf (dump_file,  		     "Generating constraints for %s\n",  		     cgraph_node_name (node));  	  push_cfun (cfun); 	  current_function_decl = node->decl;  	  FOR_EACH_BB_FN (bb, cfun) 	    { 	      block_stmt_iterator bsi;  	      tree phi; 	       	      for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi)) 		{ 		  if (is_gimple_reg (PHI_RESULT (phi))) 		    { 		      find_func_aliases (phi); 		    } 		} 	       	      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi)) 		{ 		  tree stmt = bsi_stmt (bsi); 		  find_func_aliases (stmt); 		} 	    }	 	  current_function_decl = old_func_decl; 	  pop_cfun ();	   	}       else 	{
comment|/* Make point to anything.  */
block|}     }    build_constraint_graph ();    if (dump_file)     {       fprintf (dump_file, "Points-to analysis\n\nConstraints:\n\n");       dump_constraints (dump_file);     }      if (dump_file)     fprintf (dump_file,  	     "\nCollapsing static cycles and doing variable " 	     "substitution:\n");          find_and_collapse_graph_cycles (graph, false);   perform_var_substitution (graph);          if (dump_file)     fprintf (dump_file, "\nSolving graph:\n");          solve_graph (graph);      if (dump_file)     dump_sa_points_to_info (dump_file);   in_ipa_mode = 0;   delete_alias_heapvars ();   delete_points_to_sets ();
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_ipa_pta
init|=
block|{
literal|"pta"
block|,
comment|/* name */
name|gate_ipa_pta
block|,
comment|/* gate */
name|ipa_pta_execute
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_IPA_PTA
block|,
comment|/* tv_id */
literal|0
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
literal|0
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the heapvar for statement mapping.  */
end_comment

begin_function
name|void
name|init_alias_heapvars
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|heapvar_for_stmt
condition|)
name|heapvar_for_stmt
operator|=
name|htab_create_ggc
argument_list|(
literal|11
argument_list|,
name|tree_map_hash
argument_list|,
name|tree_map_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nonlocal_all
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|delete_alias_heapvars
parameter_list|(
name|void
parameter_list|)
block|{
name|nonlocal_all
operator|=
name|NULL_TREE
expr_stmt|;
name|htab_delete
argument_list|(
name|heapvar_for_stmt
argument_list|)
expr_stmt|;
name|heapvar_for_stmt
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-tree-ssa-structalias.h"
end_include

end_unit

