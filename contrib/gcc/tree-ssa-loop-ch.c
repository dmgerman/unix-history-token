begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Loop header copying on trees.    Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.     This file is part of GCC.     GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.     GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.     You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_comment
comment|/* Duplicates headers of loops if they are small enough, so that the statements    in the loop body are always executed when the loop is entered.  This    increases effectiveness of code motion optimizations, and reduces the need    for loop preconditioning.  */
end_comment

begin_comment
comment|/* Check whether we should duplicate HEADER of LOOP.  At most *LIMIT    instructions should be duplicated, limit is decreased by the actual    amount.  */
end_comment

begin_function
specifier|static
name|bool
name|should_duplicate_loop_header_p
parameter_list|(
name|basic_block
name|header
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
modifier|*
name|limit
parameter_list|)
block|{
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|tree
name|last
decl_stmt|;
comment|/* Do not copy one block more than once (we do not really want to do      loop peeling here).  */
if|if
condition|(
name|header
operator|->
name|aux
condition|)
return|return
name|false
return|;
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|header
operator|->
name|succs
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|single_succ_p
argument_list|(
name|header
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|EDGE_SUCC
argument_list|(
name|header
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
argument_list|)
operator|&&
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|EDGE_SUCC
argument_list|(
name|header
argument_list|,
literal|1
argument_list|)
operator|->
name|dest
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* If this is not the original loop header, we want it to have just      one predecessor in order to match the&& pattern.  */
if|if
condition|(
name|header
operator|!=
name|loop
operator|->
name|header
operator|&&
operator|!
name|single_pred_p
argument_list|(
name|header
argument_list|)
condition|)
return|return
name|false
return|;
name|last
operator|=
name|last_stmt
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
name|false
return|;
comment|/* Approximately copy the conditions that used to be used in jump.c --      at most 20 insns and no calls.  */
for|for
control|(
name|bsi
operator|=
name|bsi_start
argument_list|(
name|header
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|bsi
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|bsi
argument_list|)
control|)
block|{
name|last
operator|=
name|bsi_stmt
argument_list|(
name|bsi
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
continue|continue;
if|if
condition|(
name|get_call_expr_in
argument_list|(
name|last
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|limit
operator|-=
name|estimate_num_insns
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|limit
operator|<
literal|0
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Checks whether LOOP is a do-while style loop.  */
end_comment

begin_function
specifier|static
name|bool
name|do_while_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|last_stmt
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
decl_stmt|;
comment|/* If the latch of the loop is not empty, it is not a do-while loop.  */
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|LABEL_EXPR
condition|)
return|return
name|false
return|;
comment|/* If the header contains just a condition, it is not a do-while loop.  */
name|stmt
operator|=
name|last_and_only_stmt
argument_list|(
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
operator|&&
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* For all loops, copy the condition at the end of the loop body in front    of the loop.  This is beneficial since it increases efficiency of    code motion optimizations.  It also saves one jump on entry to the loop.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|copy_loop_headers
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|loops
modifier|*
name|loops
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|basic_block
name|header
decl_stmt|;
name|edge
name|exit
decl_stmt|,
name|entry
decl_stmt|;
name|basic_block
modifier|*
name|bbs
decl_stmt|,
modifier|*
name|copied_bbs
decl_stmt|;
name|unsigned
name|n_bbs
decl_stmt|;
name|unsigned
name|bbs_size
decl_stmt|;
name|loops
operator|=
name|loop_optimizer_init
argument_list|(
name|LOOPS_HAVE_PREHEADERS
operator||
name|LOOPS_HAVE_SIMPLE_LATCHES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loops
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_loop_structure
argument_list|(
name|loops
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bbs
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|copied_bbs
operator|=
name|XNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|bbs_size
operator|=
name|n_basic_blocks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
comment|/* Copy at most 20 insns.  */
name|int
name|limit
init|=
literal|20
decl_stmt|;
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|header
operator|=
name|loop
operator|->
name|header
expr_stmt|;
comment|/* If the loop is already a do-while style one (either because it was 	 written as such, or because jump threading transformed it into one), 	 we might be in fact peeling the first iteration of the loop.  This 	 in general is not a good idea.  */
if|if
condition|(
name|do_while_loop_p
argument_list|(
name|loop
argument_list|)
condition|)
continue|continue;
comment|/* Iterate the header copying up to limit; this takes care of the cases 	 like while (a&& b) {...}, where we want to have both of the conditions 	 copied.  TODO -- handle while (a || b) - like cases, by not requiring 	 the header to have just a single successor and copying up to 	 postdominator.  */
name|exit
operator|=
name|NULL
expr_stmt|;
name|n_bbs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|should_duplicate_loop_header_p
argument_list|(
name|header
argument_list|,
name|loop
argument_list|,
operator|&
name|limit
argument_list|)
condition|)
block|{
comment|/* Find a successor of header that is inside a loop; i.e. the new 	     header after the condition is copied.  */
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|EDGE_SUCC
argument_list|(
name|header
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
argument_list|)
condition|)
name|exit
operator|=
name|EDGE_SUCC
argument_list|(
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|exit
operator|=
name|EDGE_SUCC
argument_list|(
name|header
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bbs
index|[
name|n_bbs
operator|++
index|]
operator|=
name|header
expr_stmt|;
name|gcc_assert
argument_list|(
name|bbs_size
operator|>
name|n_bbs
argument_list|)
expr_stmt|;
name|header
operator|=
name|exit
operator|->
name|dest
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exit
condition|)
continue|continue;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Duplicating header of the loop %d up to edge %d->%d.\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|,
name|exit
operator|->
name|src
operator|->
name|index
argument_list|,
name|exit
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
comment|/* Ensure that the header will have just the latch as a predecessor 	 inside the loop.  */
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|exit
operator|->
name|dest
argument_list|)
condition|)
name|exit
operator|=
name|single_pred_edge
argument_list|(
name|loop_split_edge_with
argument_list|(
name|exit
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_duplicate_sese_region
argument_list|(
name|entry
argument_list|,
name|exit
argument_list|,
name|bbs
argument_list|,
name|n_bbs
argument_list|,
name|copied_bbs
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Duplication failed.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the loop has the form "for (i = j; i< j + 10; i++)" then 	 this copying can introduce a case where we rely on undefined 	 signed overflow to eliminate the preheader condition, because 	 we assume that "j< j + 10" is true.  We don't want to warn 	 about that case for -Wstrict-overflow, because in general we 	 don't warn about overflow involving loops.  Prevent the 	 warning by setting TREE_NO_WARNING.  */
if|if
condition|(
name|warn_strict_overflow
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bbs
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|last
decl_stmt|;
name|last
operator|=
name|last_stmt
argument_list|(
name|copied_bbs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|COND_EXPR
condition|)
name|TREE_NO_WARNING
argument_list|(
name|last
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Ensure that the latch and the preheader is simple (we know that they 	 are not now, since there was the loop exit condition.  */
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|loop_split_edge_with
argument_list|(
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|bbs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copied_bbs
argument_list|)
expr_stmt|;
name|loop_optimizer_finalize
argument_list|(
name|loops
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|gate_ch
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|flag_tree_ch
operator|!=
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_ch
init|=
block|{
literal|"ch"
block|,
comment|/* name */
name|gate_ch
block|,
comment|/* gate */
name|copy_loop_headers
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
name|TV_TREE_CH
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_cleanup_cfg
operator||
name|TODO_dump_func
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

