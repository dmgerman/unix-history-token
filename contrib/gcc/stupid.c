begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dummy data flow analysis for GNU compiler in nonoptimizing mode.    Copyright (C) 1987, 91, 94-96, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file performs stupid register allocation, which is used    when cc1 gets the -noreg switch (which is when cc does not get -O).     Stupid register allocation goes in place of the flow_analysis,    local_alloc and global_alloc passes.  combine_instructions cannot    be done with stupid allocation because the data flow info that it needs    is not computed here.     In stupid allocation, the only user-defined variables that can    go in registers are those declared "register".  They are assumed    to have a life span equal to their scope.  Other user variables    are given stack slots in the rtl-generation pass and are not    represented as pseudo regs.  A compiler-generated temporary    is assumed to live from its first mention to its last mention.     Since each pseudo-reg's life span is just an interval, it can be    represented as a pair of numbers, each of which identifies an insn by    its position in the function (number of insns before it).  The first    thing done for stupid allocation is to compute such a number for each    insn.  It is called the suid.  Then the life-interval of each    pseudo reg is computed.  Then the pseudo regs are ordered by priority    and assigned hard regs in priority order.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Vector mapping INSN_UIDs to suids.    The suids are like uids but increase monotonically always.    We use them to see whether a subroutine call came    between a variable's birth and its death.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_suid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the suid of an insn.  */
end_comment

begin_define
define|#
directive|define
name|INSN_SUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_suid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Record the suid of the last CALL_INSN    so we can tell whether a pseudo reg crosses any calls.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_call_suid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the suid of the last NOTE_INSN_SETJMP    so we can tell whether a pseudo reg crosses any setjmp.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_setjmp_suid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is suid of insn where life span of pseudo reg N ends.    Element is  0 if register N has not been seen yet on backward scan.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_where_dead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Likewise, but point to the insn_chain structure of the insn at which    the reg dies.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|insn_chain
modifier|*
modifier|*
name|reg_where_dead_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is suid of insn where life span of pseudo reg N begins.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_where_born_exact
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is 1 if the birth of pseudo reg N is due to a CLOBBER,     0 otherwise.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_where_born_clobber
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the suid of the insn where the register is born, or the suid    of the insn before if the birth is due to a CLOBBER.  */
end_comment

begin_define
define|#
directive|define
name|REG_WHERE_BORN
parameter_list|(
name|N
parameter_list|)
define|\
value|(reg_where_born_exact[(N)] - reg_where_born_clobber[(N)])
end_define

begin_comment
comment|/* Numbers of pseudo-regs to be allocated, highest priority first.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_order
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by reg number (hard or pseudo), nonzero if register is live    at the current point in the instruction stream.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regs_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by reg number, nonzero if reg was used in a SUBREG that changes    its size.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regs_change_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by reg number, nonzero if reg crosses a setjmp.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regs_crosses_setjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by insn's suid, the set of hard regs live after that insn.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
modifier|*
name|after_insn_hard_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record that hard reg REGNO is live after insn INSN.  */
end_comment

begin_define
define|#
directive|define
name|MARK_LIVE_AFTER
parameter_list|(
name|INSN
parameter_list|,
name|REGNO
parameter_list|)
define|\
value|SET_HARD_REG_BIT (after_insn_hard_regs[INSN_SUID (INSN)], (REGNO))
end_define

begin_decl_stmt
specifier|static
name|int
name|stupid_reg_compare
name|PROTO
argument_list|(
operator|(
specifier|const
name|GENERIC_PTR
operator|,
specifier|const
name|GENERIC_PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stupid_find_reg
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|reg_class
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|stupid_mark_refs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|insn_chain
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_clobbered_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* For communication between stupid_life_analysis and find_clobbered_regs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|insn_chain
modifier|*
name|current_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function, called via note_stores, marks any hard registers that are    clobbered in an insn as being live in the live_after and live_before fields    of the appropriate insn_chain structure.  */
end_comment

begin_function
specifier|static
name|void
name|find_clobbered_regs
parameter_list|(
name|reg
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|setter
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|nregs
decl_stmt|;
if|if
condition|(
name|setter
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|!=
name|CLOBBER
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
if|if
condition|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nregs
operator|--
operator|>
literal|0
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|current_chain
operator|->
name|live_after
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|current_chain
operator|->
name|live_before
argument_list|,
name|regno
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stupid life analysis is for the case where only variables declared    `register' go in registers.  For this case, we mark all    pseudo-registers that belong to register variables as    dying in the last instruction of the function, and all other    pseudo registers as dying in the last place they are referenced.    Hard registers are marked as dying in the last reference before    the end or before each store into them.  */
end_comment

begin_function
name|void
name|stupid_life_analysis
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|last
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|max_uid
decl_stmt|,
name|max_suid
decl_stmt|;
name|current_function_has_computed_jump
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|regs_ever_live
argument_list|,
sizeof|sizeof
name|regs_ever_live
argument_list|)
expr_stmt|;
name|regs_live
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
argument_list|)
expr_stmt|;
comment|/* First find the last real insn, and count the number of insns,      and assign insns their suids.  */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|i
condition|)
name|i
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|max_uid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|uid_suid
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute the mapping from uids to suids.      Suids are numbers assigned to insns, like uids,      except that suids increase monotonically through the code.  */
name|last
operator|=
literal|0
expr_stmt|;
comment|/* In case of empty function body */
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|last
operator|=
name|insn
expr_stmt|;
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
operator|=
operator|++
name|i
expr_stmt|;
block|}
name|last_call_suid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|last_setjmp_suid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|max_suid
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|max_regno
operator|=
name|nregs
expr_stmt|;
comment|/* Allocate tables to record info about regs.  */
name|reg_where_dead
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_where_dead
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_where_born_exact
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_where_born_exact
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_where_born_clobber
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_where_born_clobber
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_where_dead_chain
operator|=
operator|(
expr|struct
name|insn_chain
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|insn_chain
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_where_dead_chain
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|insn_chain
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|reg_order
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_order
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|regs_change_size
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regs_change_size
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|regs_crosses_setjmp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|regs_crosses_setjmp
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate the reg_renumber array */
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
name|reg_renumber
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|after_insn_hard_regs
operator|=
operator|(
name|HARD_REG_SET
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_suid
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|after_insn_hard_regs
argument_list|,
name|max_suid
operator|*
sizeof|sizeof
argument_list|(
name|HARD_REG_SET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate and zero out many data structures      that will record the data from lifetime analysis.  */
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|allocate_bb_life_data
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|REG_N_DEATHS
argument_list|(
name|i
argument_list|)
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|regs_live
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
comment|/* Find where each pseudo register is born and dies,      by scanning all insns from the end to the start      and noting all mentions of the registers.       Also find where each hard register is live      and record that info in after_insn_hard_regs.      regs_live[I] is 1 if hard reg I is live      at the current point in the scan.            Build reload_insn_chain while we're walking the insns.  */
name|reload_insn_chain
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|last
init|;
name|insn
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
specifier|register
name|HARD_REG_SET
modifier|*
name|p
init|=
name|after_insn_hard_regs
operator|+
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
comment|/* Copy the info in regs_live into the element of after_insn_hard_regs 	 for the current position in the rtl code.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_live
index|[
name|i
index|]
condition|)
name|SET_HARD_REG_BIT
argument_list|(
operator|*
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
name|chain
operator|=
name|new_insn_chain
argument_list|()
expr_stmt|;
if|if
condition|(
name|reload_insn_chain
condition|)
name|reload_insn_chain
operator|->
name|prev
operator|=
name|chain
expr_stmt|;
name|chain
operator|->
name|next
operator|=
name|reload_insn_chain
expr_stmt|;
name|chain
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
name|reload_insn_chain
operator|=
name|chain
expr_stmt|;
name|chain
operator|->
name|block
operator|=
literal|0
expr_stmt|;
name|chain
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_live
index|[
name|i
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|chain
operator|->
name|live_before
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Update which hard regs are currently live 	 and also the birth and death suids of pseudo regs 	 based on the pattern of this insn.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|stupid_mark_refs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
name|last_setjmp_suid
operator|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Mark all call-clobbered regs as dead after each call insn so that 	 a pseudo whose life span includes this insn will not go in one of 	 them.  If the function contains a non-local goto, mark all hard 	 registers dead (except for stack related bits).  	 Then mark those regs as all dead for the continuing scan 	 of the insns before the call.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|last_call_suid
operator|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_has_nonlocal_label
condition|)
block|{
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|after_insn_hard_regs
index|[
name|last_call_suid
index|]
argument_list|,
name|fixed_reg_set
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
name|regs_live
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|IOR_HARD_REG_SET
argument_list|(
name|after_insn_hard_regs
index|[
name|last_call_suid
index|]
argument_list|,
name|call_used_reg_set
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
name|regs_live
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* It is important that this be done after processing the insn's 	     pattern because we want the function result register to still 	     be live if it's also used to pass arguments.  */
name|stupid_mark_refs
argument_list|(
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_live
index|[
name|i
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|chain
operator|->
name|live_after
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The regs_live array doesn't say anything about hard registers 	     clobbered by this insn.  So we need an extra pass over the 	     pattern.  */
name|current_chain
operator|=
name|chain
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|find_clobbered_regs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|current_function_has_computed_jump
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now decide the order in which to allocate the pseudo registers.  */
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|reg_order
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|qsort
argument_list|(
operator|&
name|reg_order
index|[
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
index|]
argument_list|,
name|max_regno
operator|-
name|LAST_VIRTUAL_REGISTER
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|stupid_reg_compare
argument_list|)
expr_stmt|;
comment|/* Now, in that order, try to find hard registers for those pseudo regs.  */
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|r
init|=
name|reg_order
index|[
name|i
index|]
decl_stmt|;
comment|/* Some regnos disappear from the rtl.  Ignore them to avoid crash.  	 Also don't allocate registers that cross a setjmp, or live across 	 a call if this function receives a nonlocal goto. 	 Also ignore registers we didn't see during the scan.  */
if|if
condition|(
name|regno_reg_rtx
index|[
name|r
index|]
operator|==
literal|0
operator|||
name|regs_crosses_setjmp
index|[
name|r
index|]
operator|||
operator|(
name|reg_where_born_exact
index|[
name|r
index|]
operator|==
literal|0
operator|&&
name|reg_where_dead
index|[
name|r
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|r
argument_list|)
operator|>
literal|0
operator|&&
name|current_function_has_nonlocal_label
operator|)
condition|)
continue|continue;
comment|/* Now find the best hard-register class for this pseudo register */
if|if
condition|(
name|N_REG_CLASSES
operator|>
literal|1
condition|)
name|reg_renumber
index|[
name|r
index|]
operator|=
name|stupid_find_reg
argument_list|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|r
argument_list|)
argument_list|,
name|reg_preferred_class
argument_list|(
name|r
argument_list|)
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|r
argument_list|)
argument_list|,
name|REG_WHERE_BORN
argument_list|(
name|r
argument_list|)
argument_list|,
name|reg_where_dead
index|[
name|r
index|]
argument_list|,
name|regs_change_size
index|[
name|r
index|]
argument_list|)
expr_stmt|;
comment|/* If no reg available in that class, try alternate class.  */
if|if
condition|(
name|reg_renumber
index|[
name|r
index|]
operator|==
operator|-
literal|1
operator|&&
name|reg_alternate_class
argument_list|(
name|r
argument_list|)
operator|!=
name|NO_REGS
condition|)
name|reg_renumber
index|[
name|r
index|]
operator|=
name|stupid_find_reg
argument_list|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|r
argument_list|)
argument_list|,
name|reg_alternate_class
argument_list|(
name|r
argument_list|)
argument_list|,
name|PSEUDO_REGNO_MODE
argument_list|(
name|r
argument_list|)
argument_list|,
name|REG_WHERE_BORN
argument_list|(
name|r
argument_list|)
argument_list|,
name|reg_where_dead
index|[
name|r
index|]
argument_list|,
name|regs_change_size
index|[
name|r
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Fill in the pseudo reg life information into the insn chain.  */
for|for
control|(
name|i
operator|=
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|regno
operator|=
name|reg_renumber
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
continue|continue;
name|chain
operator|=
name|reg_where_dead_chain
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|reg_where_dead
index|[
name|i
index|]
operator|>
name|INSN_SUID
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|chain
operator|->
name|live_after
argument_list|,
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|INSN_SUID
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
operator|>
name|reg_where_born_exact
index|[
name|i
index|]
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|chain
operator|->
name|live_before
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|chain
operator|=
name|chain
operator|->
name|prev
expr_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
break|break;
name|SET_REGNO_REG_SET
argument_list|(
name|chain
operator|->
name|live_after
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INSN_SUID
argument_list|(
name|chain
operator|->
name|insn
argument_list|)
operator|==
name|reg_where_born_exact
index|[
name|i
index|]
operator|&&
name|reg_where_born_clobber
index|[
name|i
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|chain
operator|->
name|live_before
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
name|dump_flow_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|regs_live
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uid_suid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_where_dead
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_where_born_exact
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_where_born_clobber
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_where_dead_chain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_order
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|regs_change_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|regs_crosses_setjmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|after_insn_hard_regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Comparison function for qsort.    Returns -1 (1) if register *R1P is higher priority than *R2P.  */
end_comment

begin_function
specifier|static
name|int
name|stupid_reg_compare
parameter_list|(
name|r1p
parameter_list|,
name|r2p
parameter_list|)
specifier|const
name|GENERIC_PTR
name|r1p
decl_stmt|;
specifier|const
name|GENERIC_PTR
name|r2p
decl_stmt|;
block|{
specifier|register
name|int
name|r1
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|r1p
decl_stmt|,
name|r2
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|r2p
decl_stmt|;
specifier|register
name|int
name|len1
init|=
name|reg_where_dead
index|[
name|r1
index|]
operator|-
name|REG_WHERE_BORN
argument_list|(
name|r1
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len2
init|=
name|reg_where_dead
index|[
name|r2
index|]
operator|-
name|REG_WHERE_BORN
argument_list|(
name|r2
argument_list|)
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|tem
operator|=
name|len2
operator|-
name|len1
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
name|tem
operator|=
name|REG_N_REFS
argument_list|(
name|r1
argument_list|)
operator|-
name|REG_N_REFS
argument_list|(
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
name|tem
return|;
comment|/* If regs are equally good, sort by regno,      so that the results of qsort leave nothing to chance.  */
return|return
name|r1
operator|-
name|r2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find a block of SIZE words of hard registers in reg_class CLASS    that can hold a value of machine-mode MODE      (but actually we test only the first of the block for holding MODE)    currently free from after insn whose suid is BORN_INSN    through the insn whose suid is DEAD_INSN,    and return the number of the first of them.    Return -1 if such a block cannot be found.     If CALL_PRESERVED is nonzero, insist on registers preserved    over subroutine calls, and return -1 if cannot find such.     If CHANGES_SIZE is nonzero, it means this register was used as the    operand of a SUBREG that changes its size.  */
end_comment

begin_function
specifier|static
name|int
name|stupid_find_reg
parameter_list|(
name|call_preserved
parameter_list|,
name|class
parameter_list|,
name|mode
parameter_list|,
name|born_insn
parameter_list|,
name|dead_insn
parameter_list|,
name|changes_size
parameter_list|)
name|int
name|call_preserved
decl_stmt|;
name|enum
name|reg_class
name|class
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|born_insn
decl_stmt|,
name|dead_insn
decl_stmt|;
name|int
name|changes_size
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|ins
decl_stmt|;
ifdef|#
directive|ifdef
name|HARD_REG_SET
specifier|register
comment|/* Declare them register if they are scalars.  */
endif|#
directive|endif
name|HARD_REG_SET
name|used
decl_stmt|,
name|this_reg
decl_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
endif|#
directive|endif
comment|/* If this register's life is more than 5,000 insns, we probably      can't allocate it, so don't waste the time trying.  This avoids      quadratic behavior on programs that have regularly-occurring      SAVE_EXPRs.  */
if|if
condition|(
name|dead_insn
operator|>
name|born_insn
operator|+
literal|5000
condition|)
return|return
operator|-
literal|1
return|;
name|COPY_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|call_preserved
condition|?
name|call_used_reg_set
else|:
name|fixed_reg_set
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
name|eliminables
operator|/
sizeof|sizeof
name|eliminables
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
name|SET_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|SET_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|ins
operator|=
name|born_insn
init|;
name|ins
operator|<
name|dead_insn
condition|;
name|ins
operator|++
control|)
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|after_insn_hard_regs
index|[
name|ins
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_REGS
if|if
condition|(
name|current_function_has_computed_jump
condition|)
for|for
control|(
name|i
operator|=
name|FIRST_STACK_REG
init|;
name|i
operator|<=
name|LAST_STACK_REG
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IOR_COMPL_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CLASS_CANNOT_CHANGE_SIZE
if|if
condition|(
name|changes_size
condition|)
name|IOR_HARD_REG_SET
argument_list|(
name|used
argument_list|,
name|reg_class_contents
index|[
operator|(
name|int
operator|)
name|CLASS_CANNOT_CHANGE_SIZE
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|REG_ALLOC_ORDER
name|int
name|regno
init|=
name|reg_alloc_order
index|[
name|i
index|]
decl_stmt|;
else|#
directive|else
name|int
name|regno
init|=
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* If a register has screwy overlap problems, 	 don't use it at all if not optimizing. 	 Actually this is only for the 387 stack register, 	 and it's because subsequent code won't work.  */
ifdef|#
directive|ifdef
name|OVERLAPPING_REGNO_P
if|if
condition|(
name|OVERLAPPING_REGNO_P
argument_list|(
name|regno
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|regno
argument_list|)
operator|&&
name|HARD_REGNO_MODE_OK
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|size1
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|size1
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|used
argument_list|,
name|regno
operator|+
name|j
argument_list|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|size1
condition|)
block|{
name|CLEAR_HARD_REG_SET
argument_list|(
name|this_reg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|this_reg
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|ins
operator|=
name|born_insn
init|;
name|ins
operator|<
name|dead_insn
condition|;
name|ins
operator|++
control|)
block|{
name|IOR_HARD_REG_SET
argument_list|(
name|after_insn_hard_regs
index|[
name|ins
index|]
argument_list|,
name|this_reg
argument_list|)
expr_stmt|;
block|}
return|return
name|regno
return|;
block|}
ifndef|#
directive|ifndef
name|REG_ALLOC_ORDER
name|i
operator|+=
name|j
expr_stmt|;
comment|/* Skip starting points we know will lose */
endif|#
directive|endif
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Walk X, noting all assignments and references to registers    and recording what they imply about life spans.    INSN is the current insn, supplied so we can find its suid.  */
end_comment

begin_function
specifier|static
name|void
name|stupid_mark_refs
parameter_list|(
name|x
parameter_list|,
name|chain
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|struct
name|insn_chain
modifier|*
name|chain
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|,
name|i
decl_stmt|;
name|rtx
name|insn
init|=
name|chain
operator|->
name|insn
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
block|{
if|if
condition|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
operator|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Register is being assigned.  */
comment|/* If setting a SUBREG, we treat the entire reg as being set.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|SUBREG
condition|)
name|regno
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|regno
operator|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For hard regs, update the where-live info.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
specifier|register
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|regs_ever_live
index|[
name|regno
operator|+
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|regs_live
index|[
name|regno
operator|+
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* The following line is for unused outputs; 		     they do get stored even though never used again.  */
name|MARK_LIVE_AFTER
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
comment|/* When a hard reg is clobbered, mark it in use 		     just before this insn, so it is live all through.  */
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|&&
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
operator|>
literal|0
condition|)
name|SET_HARD_REG_BIT
argument_list|(
name|after_insn_hard_regs
index|[
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
operator|-
literal|1
index|]
argument_list|,
name|regno
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For pseudo regs, record where born, where dead, number of 	     times used, and whether live across a call.  */
else|else
block|{
comment|/* Update the life-interval bounds of this pseudo reg.  */
comment|/* When a pseudo-reg is CLOBBERed, it is born just before 		 the clobbering insn.  When setting, just after.  */
name|int
name|where_born
init|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
operator|-
operator|(
name|code
operator|==
name|CLOBBER
operator|)
decl_stmt|;
name|reg_where_born_exact
index|[
name|regno
index|]
operator|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|reg_where_born_clobber
index|[
name|regno
index|]
operator|=
operator|(
name|code
operator|==
name|CLOBBER
operator|)
expr_stmt|;
if|if
condition|(
name|reg_where_dead_chain
index|[
name|regno
index|]
operator|==
literal|0
condition|)
name|reg_where_dead_chain
index|[
name|regno
index|]
operator|=
name|chain
expr_stmt|;
comment|/* The reg must live at least one insn even 		 in it is never again used--because it has to go 		 in SOME hard reg.  Mark it as dying after the current 		 insn so that it will conflict with any other outputs of 		 this insn.  */
if|if
condition|(
name|reg_where_dead
index|[
name|regno
index|]
operator|<
name|where_born
operator|+
literal|2
condition|)
block|{
name|reg_where_dead
index|[
name|regno
index|]
operator|=
name|where_born
operator|+
literal|2
expr_stmt|;
name|regs_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Count the refs of this reg.  */
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|last_call_suid
operator|<
name|reg_where_dead
index|[
name|regno
index|]
condition|)
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|last_setjmp_suid
operator|<
name|reg_where_dead
index|[
name|regno
index|]
condition|)
name|regs_crosses_setjmp
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
comment|/* If this register is clobbered or it is only used in 		 this insn and is only set, mark it unused.  We have 		 to do this even when not optimizing so that MD patterns 		 which count on this behavior (e.g., it not causing an 		 output reload on an insn setting CC) will operate 		 correctly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|code
operator|==
name|CLOBBER
operator|||
operator|(
name|REGNO_FIRST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|&&
name|REGNO_LAST_UID
argument_list|(
name|regno
argument_list|)
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record references from the value being set, 	 or from addresses in the place being set if that's not a reg. 	 If setting a SUBREG, we treat the entire reg as *used*.  */
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|stupid_mark_refs
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|stupid_mark_refs
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|INTEGRAL_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|regs_change_size
index|[
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Register value being used, not set.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Hard reg: mark it live for continuing scan of previous insns.  */
specifier|register
name|int
name|j
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|regs_ever_live
index|[
name|regno
operator|+
name|j
index|]
operator|=
literal|1
expr_stmt|;
name|regs_live
index|[
name|regno
operator|+
name|j
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Pseudo reg: record first use, last use and number of uses.  */
name|reg_where_born_exact
index|[
name|regno
index|]
operator|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|reg_where_born_clobber
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
if|if
condition|(
name|regs_live
index|[
name|regno
index|]
operator|==
literal|0
condition|)
block|{
name|regs_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
name|reg_where_dead
index|[
name|regno
index|]
operator|=
name|INSN_SUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|reg_where_dead_chain
index|[
name|regno
index|]
operator|=
name|chain
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/* Recursive scan of all other rtx's.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|stupid_mark_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|stupid_mark_refs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

