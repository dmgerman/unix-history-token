begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read and manage MIPS symbol tables from object modules.    Copyright (C) 1991, 1994, 1995 Free Software Foundation, Inc.    Contributed by hartzell@boulder.colorado.edu,    Rewritten by meissner@osf.org.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|index
end_ifdef

begin_undef
undef|#
directive|undef
name|index
end_undef

begin_undef
undef|#
directive|undef
name|rindex
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CROSS_COMPILE
end_ifndef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"mips/a.out.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CROSS_COMPILE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIPS_IS_STAB
end_ifndef

begin_comment
comment|/* Macros for mips-tfile.c to encapsulate stabs in ECOFF, and for    and mips-tdump.c to print them out.  This is used on the Alpha,    which does not include mips.h.     These must match the corresponding definitions in gdb/mipsread.c.    Unfortunately, gcc and gdb do not currently share any directories. */
end_comment

begin_define
define|#
directive|define
name|CODE_MASK
value|0x8F300
end_define

begin_define
define|#
directive|define
name|MIPS_IS_STAB
parameter_list|(
name|sym
parameter_list|)
value|(((sym)->index& 0xFFF00) == CODE_MASK)
end_define

begin_define
define|#
directive|define
name|MIPS_MARK_STAB
parameter_list|(
name|code
parameter_list|)
value|((code)+CODE_MASK)
end_define

begin_define
define|#
directive|define
name|MIPS_UNMARK_STAB
parameter_list|(
name|code
parameter_list|)
value|((code)-CODE_MASK)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_typedef
typedef|typedef
name|void
modifier|*
name|PTR_T
typedef|;
end_typedef

begin_typedef
typedef|typedef
specifier|const
name|void
modifier|*
name|CPTR_T
typedef|;
end_typedef

begin_define
define|#
directive|define
name|__proto
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_STDIO_H_
argument_list|)
operator|||
name|defined
argument_list|(
name|__STDIO_H__
argument_list|)
end_if

begin_comment
comment|/* Ultrix 4.0, SGI */
end_comment

begin_typedef
typedef|typedef
name|void
modifier|*
name|PTR_T
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|void
modifier|*
name|CPTR_T
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|char
modifier|*
name|PTR_T
typedef|;
end_typedef

begin_comment
comment|/* Ultrix 3.1 */
end_comment

begin_typedef
typedef|typedef
name|char
modifier|*
name|CPTR_T
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|__proto
parameter_list|(
name|x
parameter_list|)
value|()
end_define

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|uchar
value|unsigned char
end_define

begin_define
define|#
directive|define
name|ushort
value|unsigned short
end_define

begin_define
define|#
directive|define
name|uint
value|unsigned int
end_define

begin_define
define|#
directive|define
name|ulong
value|unsigned long
end_define

begin_comment
comment|/* Do to size_t being defined in sys/types.h and different    in stddef.h, we have to do this by hand.....  Note, these    types are correct for MIPS based systems, and may not be    correct for other systems.  */
end_comment

begin_define
define|#
directive|define
name|size_t
value|uint
end_define

begin_define
define|#
directive|define
name|ptrdiff_t
value|int
end_define

begin_escape
end_escape

begin_comment
comment|/* Redefinition of of storage classes as an enumeration for better    debugging.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|stStaParam
end_ifndef

begin_define
define|#
directive|define
name|stStaParam
value|16
end_define

begin_comment
comment|/* Fortran static parameters */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|btVoid
end_ifndef

begin_define
define|#
directive|define
name|btVoid
value|26
end_define

begin_comment
comment|/* void basic type */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
name|sc
block|{
name|sc_Nil
init|=
name|scNil
block|,
comment|/* no storage class */
name|sc_Text
init|=
name|scText
block|,
comment|/* text symbol */
name|sc_Data
init|=
name|scData
block|,
comment|/* initialized data symbol */
name|sc_Bss
init|=
name|scBss
block|,
comment|/* un-initialized data symbol */
name|sc_Register
init|=
name|scRegister
block|,
comment|/* value of symbol is register number */
name|sc_Abs
init|=
name|scAbs
block|,
comment|/* value of symbol is absolute */
name|sc_Undefined
init|=
name|scUndefined
block|,
comment|/* who knows? */
name|sc_CdbLocal
init|=
name|scCdbLocal
block|,
comment|/* variable's value is IN se->va.?? */
name|sc_Bits
init|=
name|scBits
block|,
comment|/* this is a bit field */
name|sc_CdbSystem
init|=
name|scCdbSystem
block|,
comment|/* var's value is IN CDB's address space */
name|sc_RegImage
init|=
name|scRegImage
block|,
comment|/* register value saved on stack */
name|sc_Info
init|=
name|scInfo
block|,
comment|/* symbol contains debugger information */
name|sc_UserStruct
init|=
name|scUserStruct
block|,
comment|/* addr in struct user for current process */
name|sc_SData
init|=
name|scSData
block|,
comment|/* load time only small data */
name|sc_SBss
init|=
name|scSBss
block|,
comment|/* load time only small common */
name|sc_RData
init|=
name|scRData
block|,
comment|/* load time only read only data */
name|sc_Var
init|=
name|scVar
block|,
comment|/* Var parameter (fortran,pascal) */
name|sc_Common
init|=
name|scCommon
block|,
comment|/* common variable */
name|sc_SCommon
init|=
name|scSCommon
block|,
comment|/* small common */
name|sc_VarRegister
init|=
name|scVarRegister
block|,
comment|/* Var parameter in a register */
name|sc_Variant
init|=
name|scVariant
block|,
comment|/* Variant record */
name|sc_SUndefined
init|=
name|scSUndefined
block|,
comment|/* small undefined(external) data */
name|sc_Init
init|=
name|scInit
block|,
comment|/* .init section symbol */
name|sc_Max
init|=
name|scMax
comment|/* Max storage class+1 */
block|}
name|sc_t
typedef|;
end_typedef

begin_comment
comment|/* Redefinition of symbol type.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|st
block|{
name|st_Nil
init|=
name|stNil
block|,
comment|/* Nuthin' special */
name|st_Global
init|=
name|stGlobal
block|,
comment|/* external symbol */
name|st_Static
init|=
name|stStatic
block|,
comment|/* static */
name|st_Param
init|=
name|stParam
block|,
comment|/* procedure argument */
name|st_Local
init|=
name|stLocal
block|,
comment|/* local variable */
name|st_Label
init|=
name|stLabel
block|,
comment|/* label */
name|st_Proc
init|=
name|stProc
block|,
comment|/*     "      "	 Procedure */
name|st_Block
init|=
name|stBlock
block|,
comment|/* beginning of block */
name|st_End
init|=
name|stEnd
block|,
comment|/* end (of anything) */
name|st_Member
init|=
name|stMember
block|,
comment|/* member (of anything	- struct/union/enum */
name|st_Typedef
init|=
name|stTypedef
block|,
comment|/* type definition */
name|st_File
init|=
name|stFile
block|,
comment|/* file name */
name|st_RegReloc
init|=
name|stRegReloc
block|,
comment|/* register relocation */
name|st_Forward
init|=
name|stForward
block|,
comment|/* forwarding address */
name|st_StaticProc
init|=
name|stStaticProc
block|,
comment|/* load time only static procs */
name|st_StaParam
init|=
name|stStaParam
block|,
comment|/* Fortran static parameters */
name|st_Constant
init|=
name|stConstant
block|,
comment|/* const */
ifdef|#
directive|ifdef
name|stStruct
name|st_Struct
init|=
name|stStruct
block|,
comment|/* struct */
name|st_Union
init|=
name|stUnion
block|,
comment|/* union */
name|st_Enum
init|=
name|stEnum
block|,
comment|/* enum */
endif|#
directive|endif
name|st_Str
init|=
name|stStr
block|,
comment|/* string */
name|st_Number
init|=
name|stNumber
block|,
comment|/* pure number (ie. 4 NOR 2+2) */
name|st_Expr
init|=
name|stExpr
block|,
comment|/* 2+2 vs. 4 */
name|st_Type
init|=
name|stType
block|,
comment|/* post-coercion SER */
name|st_Max
init|=
name|stMax
comment|/* max type+1 */
block|}
name|st_t
typedef|;
end_typedef

begin_comment
comment|/* Redefinition of type qualifiers.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|tq
block|{
name|tq_Nil
init|=
name|tqNil
block|,
comment|/* bt is what you see */
name|tq_Ptr
init|=
name|tqPtr
block|,
comment|/* pointer */
name|tq_Proc
init|=
name|tqProc
block|,
comment|/* procedure */
name|tq_Array
init|=
name|tqArray
block|,
comment|/* duh */
name|tq_Far
init|=
name|tqFar
block|,
comment|/* longer addressing - 8086/8 land */
name|tq_Vol
init|=
name|tqVol
block|,
comment|/* volatile */
name|tq_Max
init|=
name|tqMax
comment|/* Max type qualifier+1 */
block|}
name|tq_t
typedef|;
end_typedef

begin_comment
comment|/* Redefinition of basic types.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|bt
block|{
name|bt_Nil
init|=
name|btNil
block|,
comment|/* undefined */
name|bt_Adr
init|=
name|btAdr
block|,
comment|/* address - integer same size as pointer */
name|bt_Char
init|=
name|btChar
block|,
comment|/* character */
name|bt_UChar
init|=
name|btUChar
block|,
comment|/* unsigned character */
name|bt_Short
init|=
name|btShort
block|,
comment|/* short */
name|bt_UShort
init|=
name|btUShort
block|,
comment|/* unsigned short */
name|bt_Int
init|=
name|btInt
block|,
comment|/* int */
name|bt_UInt
init|=
name|btUInt
block|,
comment|/* unsigned int */
name|bt_Long
init|=
name|btLong
block|,
comment|/* long */
name|bt_ULong
init|=
name|btULong
block|,
comment|/* unsigned long */
name|bt_Float
init|=
name|btFloat
block|,
comment|/* float (real) */
name|bt_Double
init|=
name|btDouble
block|,
comment|/* Double (real) */
name|bt_Struct
init|=
name|btStruct
block|,
comment|/* Structure (Record) */
name|bt_Union
init|=
name|btUnion
block|,
comment|/* Union (variant) */
name|bt_Enum
init|=
name|btEnum
block|,
comment|/* Enumerated */
name|bt_Typedef
init|=
name|btTypedef
block|,
comment|/* defined via a typedef, isymRef points */
name|bt_Range
init|=
name|btRange
block|,
comment|/* subrange of int */
name|bt_Set
init|=
name|btSet
block|,
comment|/* pascal sets */
name|bt_Complex
init|=
name|btComplex
block|,
comment|/* fortran complex */
name|bt_DComplex
init|=
name|btDComplex
block|,
comment|/* fortran double complex */
name|bt_Indirect
init|=
name|btIndirect
block|,
comment|/* forward or unnamed typedef */
name|bt_FixedDec
init|=
name|btFixedDec
block|,
comment|/* Fixed Decimal */
name|bt_FloatDec
init|=
name|btFloatDec
block|,
comment|/* Float Decimal */
name|bt_String
init|=
name|btString
block|,
comment|/* Varying Length Character String */
name|bt_Bit
init|=
name|btBit
block|,
comment|/* Aligned Bit String */
name|bt_Picture
init|=
name|btPicture
block|,
comment|/* Picture */
name|bt_Void
init|=
name|btVoid
block|,
comment|/* void */
name|bt_Max
init|=
name|btMax
comment|/* Max basic type+1 */
block|}
name|bt_t
typedef|;
end_typedef

begin_comment
comment|/* Redefinition of the language codes.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|lang
block|{
name|lang_C
init|=
name|langC
block|,
name|lang_Pascal
init|=
name|langPascal
block|,
name|lang_Fortran
init|=
name|langFortran
block|,
name|lang_Assembler
init|=
name|langAssembler
block|,
name|lang_Machine
init|=
name|langMachine
block|,
name|lang_Nil
init|=
name|langNil
block|,
name|lang_Ada
init|=
name|langAda
block|,
name|lang_Pl1
init|=
name|langPl1
block|,
name|lang_Cobol
init|=
name|langCobol
block|}
name|lang_t
typedef|;
end_typedef

begin_comment
comment|/* Redefinition of the debug level codes.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|glevel
block|{
name|glevel_0
init|=
name|GLEVEL_0
block|,
name|glevel_1
init|=
name|GLEVEL_1
block|,
name|glevel_2
init|=
name|GLEVEL_2
block|,
name|glevel_3
init|=
name|GLEVEL_3
block|}
name|glevel_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* Keep track of the active scopes.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|scope
block|{
name|struct
name|scope
modifier|*
name|prev
decl_stmt|;
comment|/* previous scope */
name|ulong
name|open_sym
decl_stmt|;
comment|/* symbol opening scope */
name|sc_t
name|sc
decl_stmt|;
comment|/* storage class */
name|st_t
name|st
decl_stmt|;
comment|/* symbol type */
block|}
name|scope_t
typedef|;
end_typedef

begin_decl_stmt
name|struct
name|filehdr
name|global_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a.out header */
end_comment

begin_decl_stmt
name|int
name|errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of errors */
end_comment

begin_decl_stmt
name|int
name|want_aux
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print aux table */
end_comment

begin_decl_stmt
name|int
name|want_line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print line numbers */
end_comment

begin_decl_stmt
name|int
name|want_rfd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print relative file desc's */
end_comment

begin_decl_stmt
name|int
name|want_scope
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print scopes for every symbol */
end_comment

begin_decl_stmt
name|int
name|tfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no global header file */
end_comment

begin_decl_stmt
name|int
name|tfile_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor of .T file */
end_comment

begin_decl_stmt
name|off_t
name|tfile_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current offset in .T file */
end_comment

begin_decl_stmt
name|scope_t
modifier|*
name|cur_scope
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of active scopes */
end_comment

begin_decl_stmt
name|scope_t
modifier|*
name|free_scope
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of freed scopes */
end_comment

begin_decl_stmt
name|HDRR
name|sym_hdr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbolic header */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local strings */
end_comment

begin_decl_stmt
name|char
modifier|*
name|e_strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* external strings */
end_comment

begin_decl_stmt
name|SYMR
modifier|*
name|l_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local symbols */
end_comment

begin_decl_stmt
name|EXTR
modifier|*
name|e_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* external symbols */
end_comment

begin_decl_stmt
name|LINER
modifier|*
name|lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line numbers */
end_comment

begin_decl_stmt
name|DNR
modifier|*
name|dense_nums
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dense numbers */
end_comment

begin_decl_stmt
name|OPTR
modifier|*
name|opt_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* optimization symbols */
end_comment

begin_decl_stmt
name|AUXU
modifier|*
name|aux_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Auxiliary symbols */
end_comment

begin_decl_stmt
name|char
modifier|*
name|aux_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* map of which aux syms are used */
end_comment

begin_decl_stmt
name|FDR
modifier|*
name|file_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file tables */
end_comment

begin_decl_stmt
name|ulong
modifier|*
name|rfile_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* relative file tables */
end_comment

begin_decl_stmt
name|PDR
modifier|*
name|proc_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* procedure tables */
end_comment

begin_comment
comment|/* Forward reference for functions.  */
end_comment

begin_decl_stmt
name|PTR_T
name|read_seek
name|__proto
argument_list|(
operator|(
name|PTR_T
operator|,
name|size_t
operator|,
name|off_t
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|read_tfile
name|__proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_global_hdr
name|__proto
argument_list|(
operator|(
expr|struct
name|filehdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_sym_hdr
name|__proto
argument_list|(
operator|(
name|HDRR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_file_desc
name|__proto
argument_list|(
operator|(
name|FDR
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_symbol
name|__proto
argument_list|(
operator|(
name|SYMR
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|AUXU
operator|*
operator|,
name|int
operator|,
name|FDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print_aux
name|__proto
argument_list|(
operator|(
name|AUXU
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|emit_aggregate
name|__proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|AUXU
operator|,
name|AUXU
operator|,
specifier|const
name|char
operator|*
operator|,
name|FDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|st_to_string
name|__proto
argument_list|(
operator|(
name|st_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sc_to_string
name|__proto
argument_list|(
operator|(
name|sc_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|glevel_to_string
name|__proto
argument_list|(
operator|(
name|glevel_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|lang_to_string
name|__proto
argument_list|(
operator|(
name|lang_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|type_to_string
name|__proto
argument_list|(
operator|(
name|AUXU
operator|*
operator|,
name|int
operator|,
name|FDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__alpha
end_ifndef

begin_decl_stmt
specifier|extern
name|PTR_T
name|malloc
name|__proto
argument_list|(
operator|(
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PTR_T
name|calloc
name|__proto
argument_list|(
operator|(
name|size_t
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|PTR_T
name|realloc
name|__proto
argument_list|(
operator|(
name|PTR_T
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|free
name|__proto
argument_list|(
operator|(
name|PTR_T
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|opterr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a table of debugging stab-codes and corresponding names.  */
end_comment

begin_define
define|#
directive|define
name|__define_stab
parameter_list|(
name|NAME
parameter_list|,
name|CODE
parameter_list|,
name|STRING
parameter_list|)
value|{(int)CODE, STRING},
end_define

begin_struct
struct|struct
block|{
name|short
name|code
decl_stmt|;
name|char
name|string
index|[
literal|10
index|]
decl_stmt|;
block|}
name|stab_names
index|[]
init|=
block|{
include|#
directive|include
file|"stab.def"
undef|#
directive|undef
name|__define_stab
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Read some bytes at a specified location, and return a pointer.  */
end_comment

begin_function
name|PTR_T
name|read_seek
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|,
name|offset
parameter_list|,
name|context
parameter_list|)
name|PTR_T
name|ptr
decl_stmt|;
comment|/* pointer to buffer or NULL */
name|size_t
name|size
decl_stmt|;
comment|/* # bytes to read */
name|off_t
name|offset
decl_stmt|;
comment|/* offset to read at */
specifier|const
name|char
modifier|*
name|context
decl_stmt|;
comment|/* context for error message */
block|{
name|long
name|read_size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
comment|/* nothing to read */
return|return
name|ptr
return|;
if|if
condition|(
operator|(
name|ptr
operator|==
operator|(
name|PTR_T
operator|)
literal|0
operator|&&
operator|(
name|ptr
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
operator|(
name|PTR_T
operator|)
literal|0
operator|)
operator|||
operator|(
name|tfile_offset
operator|!=
name|offset
operator|&&
name|lseek
argument_list|(
name|tfile_fd
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|read_size
operator|=
name|read
argument_list|(
name|tfile_fd
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read_size
operator|!=
name|size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read %ld bytes, expected %ld bytes\n"
argument_list|,
name|context
argument_list|,
name|read_size
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tfile_offset
operator|=
name|offset
operator|+
name|size
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert language code to string format.  */
end_comment

begin_function
name|char
modifier|*
name|lang_to_string
parameter_list|(
name|lang
parameter_list|)
name|lang_t
name|lang
decl_stmt|;
block|{
switch|switch
condition|(
name|lang
condition|)
block|{
case|case
name|langC
case|:
return|return
literal|"C"
return|;
case|case
name|langPascal
case|:
return|return
literal|"Pascal"
return|;
case|case
name|langFortran
case|:
return|return
literal|"Fortran"
return|;
case|case
name|langAssembler
case|:
return|return
literal|"Assembler"
return|;
case|case
name|langMachine
case|:
return|return
literal|"Machine"
return|;
case|case
name|langNil
case|:
return|return
literal|"Nil"
return|;
case|case
name|langAda
case|:
return|return
literal|"Ada"
return|;
case|case
name|langPl1
case|:
return|return
literal|"Pl1"
return|;
case|case
name|langCobol
case|:
return|return
literal|"Cobol"
return|;
block|}
return|return
literal|"Unknown language"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert storage class to string.  */
end_comment

begin_function
name|char
modifier|*
name|sc_to_string
parameter_list|(
name|storage_class
parameter_list|)
name|sc_t
name|storage_class
decl_stmt|;
block|{
switch|switch
condition|(
name|storage_class
condition|)
block|{
case|case
name|sc_Nil
case|:
return|return
literal|"Nil"
return|;
case|case
name|sc_Text
case|:
return|return
literal|"Text"
return|;
case|case
name|sc_Data
case|:
return|return
literal|"Data"
return|;
case|case
name|sc_Bss
case|:
return|return
literal|"Bss"
return|;
case|case
name|sc_Register
case|:
return|return
literal|"Register"
return|;
case|case
name|sc_Abs
case|:
return|return
literal|"Abs"
return|;
case|case
name|sc_Undefined
case|:
return|return
literal|"Undefined"
return|;
case|case
name|sc_CdbLocal
case|:
return|return
literal|"CdbLocal"
return|;
case|case
name|sc_Bits
case|:
return|return
literal|"Bits"
return|;
case|case
name|sc_CdbSystem
case|:
return|return
literal|"CdbSystem"
return|;
case|case
name|sc_RegImage
case|:
return|return
literal|"RegImage"
return|;
case|case
name|sc_Info
case|:
return|return
literal|"Info"
return|;
case|case
name|sc_UserStruct
case|:
return|return
literal|"UserStruct"
return|;
case|case
name|sc_SData
case|:
return|return
literal|"SData"
return|;
case|case
name|sc_SBss
case|:
return|return
literal|"SBss"
return|;
case|case
name|sc_RData
case|:
return|return
literal|"RData"
return|;
case|case
name|sc_Var
case|:
return|return
literal|"Var"
return|;
case|case
name|sc_Common
case|:
return|return
literal|"Common"
return|;
case|case
name|sc_SCommon
case|:
return|return
literal|"SCommon"
return|;
case|case
name|sc_VarRegister
case|:
return|return
literal|"VarRegister"
return|;
case|case
name|sc_Variant
case|:
return|return
literal|"Variant"
return|;
case|case
name|sc_SUndefined
case|:
return|return
literal|"SUndefined"
return|;
case|case
name|sc_Init
case|:
return|return
literal|"Init"
return|;
case|case
name|sc_Max
case|:
return|return
literal|"Max"
return|;
block|}
return|return
literal|"???"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert symbol type to string.  */
end_comment

begin_function
name|char
modifier|*
name|st_to_string
parameter_list|(
name|symbol_type
parameter_list|)
name|st_t
name|symbol_type
decl_stmt|;
block|{
switch|switch
condition|(
name|symbol_type
condition|)
block|{
case|case
name|st_Nil
case|:
return|return
literal|"Nil"
return|;
case|case
name|st_Global
case|:
return|return
literal|"Global"
return|;
case|case
name|st_Static
case|:
return|return
literal|"Static"
return|;
case|case
name|st_Param
case|:
return|return
literal|"Param"
return|;
case|case
name|st_Local
case|:
return|return
literal|"Local"
return|;
case|case
name|st_Label
case|:
return|return
literal|"Label"
return|;
case|case
name|st_Proc
case|:
return|return
literal|"Proc"
return|;
case|case
name|st_Block
case|:
return|return
literal|"Block"
return|;
case|case
name|st_End
case|:
return|return
literal|"End"
return|;
case|case
name|st_Member
case|:
return|return
literal|"Member"
return|;
case|case
name|st_Typedef
case|:
return|return
literal|"Typedef"
return|;
case|case
name|st_File
case|:
return|return
literal|"File"
return|;
case|case
name|st_RegReloc
case|:
return|return
literal|"RegReloc"
return|;
case|case
name|st_Forward
case|:
return|return
literal|"Forward"
return|;
case|case
name|st_StaticProc
case|:
return|return
literal|"StaticProc"
return|;
case|case
name|st_Constant
case|:
return|return
literal|"Constant"
return|;
case|case
name|st_StaParam
case|:
return|return
literal|"StaticParam"
return|;
ifdef|#
directive|ifdef
name|stStruct
case|case
name|st_Struct
case|:
return|return
literal|"Struct"
return|;
case|case
name|st_Union
case|:
return|return
literal|"Union"
return|;
case|case
name|st_Enum
case|:
return|return
literal|"Enum"
return|;
endif|#
directive|endif
case|case
name|st_Str
case|:
return|return
literal|"String"
return|;
case|case
name|st_Number
case|:
return|return
literal|"Number"
return|;
case|case
name|st_Expr
case|:
return|return
literal|"Expr"
return|;
case|case
name|st_Type
case|:
return|return
literal|"Type"
return|;
case|case
name|st_Max
case|:
return|return
literal|"Max"
return|;
block|}
return|return
literal|"???"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert debug level to string.  */
end_comment

begin_function
name|char
modifier|*
name|glevel_to_string
parameter_list|(
name|g_level
parameter_list|)
name|glevel_t
name|g_level
decl_stmt|;
block|{
switch|switch
condition|(
name|g_level
condition|)
block|{
case|case
name|GLEVEL_0
case|:
return|return
literal|"G0"
return|;
case|case
name|GLEVEL_1
case|:
return|return
literal|"G1"
return|;
case|case
name|GLEVEL_2
case|:
return|return
literal|"G2"
return|;
case|case
name|GLEVEL_3
case|:
return|return
literal|"G3"
return|;
block|}
return|return
literal|"??"
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert the type information to string format.  */
end_comment

begin_function
name|char
modifier|*
name|type_to_string
parameter_list|(
name|aux_ptr
parameter_list|,
name|index
parameter_list|,
name|fdp
parameter_list|)
name|AUXU
modifier|*
name|aux_ptr
decl_stmt|;
name|int
name|index
decl_stmt|;
name|FDR
modifier|*
name|fdp
decl_stmt|;
block|{
name|AUXU
name|u
decl_stmt|;
struct|struct
name|qual
block|{
name|tq_t
name|type
decl_stmt|;
name|int
name|low_bound
decl_stmt|;
name|int
name|high_bound
decl_stmt|;
name|int
name|stride
decl_stmt|;
block|}
name|qualifiers
index|[
literal|7
index|]
struct|;
name|bt_t
name|basic_type
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buffer1
index|[
literal|1024
index|]
decl_stmt|;
specifier|static
name|char
name|buffer2
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|buffer1
decl_stmt|;
name|char
modifier|*
name|p2
init|=
name|buffer2
decl_stmt|;
name|char
modifier|*
name|used_ptr
init|=
name|aux_used
operator|+
operator|(
name|aux_ptr
operator|-
name|aux_symbols
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|qualifiers
index|[
name|i
index|]
operator|.
name|low_bound
operator|=
literal|0
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|high_bound
operator|=
literal|0
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|stride
operator|=
literal|0
expr_stmt|;
block|}
name|used_ptr
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
name|u
operator|=
name|aux_ptr
index|[
name|index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|u
operator|.
name|isym
operator|==
operator|-
literal|1
condition|)
return|return
literal|"-1 (no type)"
return|;
name|basic_type
operator|=
operator|(
name|bt_t
operator|)
name|u
operator|.
name|ti
operator|.
name|bt
expr_stmt|;
name|qualifiers
index|[
literal|0
index|]
operator|.
name|type
operator|=
operator|(
name|tq_t
operator|)
name|u
operator|.
name|ti
operator|.
name|tq0
expr_stmt|;
name|qualifiers
index|[
literal|1
index|]
operator|.
name|type
operator|=
operator|(
name|tq_t
operator|)
name|u
operator|.
name|ti
operator|.
name|tq1
expr_stmt|;
name|qualifiers
index|[
literal|2
index|]
operator|.
name|type
operator|=
operator|(
name|tq_t
operator|)
name|u
operator|.
name|ti
operator|.
name|tq2
expr_stmt|;
name|qualifiers
index|[
literal|3
index|]
operator|.
name|type
operator|=
operator|(
name|tq_t
operator|)
name|u
operator|.
name|ti
operator|.
name|tq3
expr_stmt|;
name|qualifiers
index|[
literal|4
index|]
operator|.
name|type
operator|=
operator|(
name|tq_t
operator|)
name|u
operator|.
name|ti
operator|.
name|tq4
expr_stmt|;
name|qualifiers
index|[
literal|5
index|]
operator|.
name|type
operator|=
operator|(
name|tq_t
operator|)
name|u
operator|.
name|ti
operator|.
name|tq5
expr_stmt|;
name|qualifiers
index|[
literal|6
index|]
operator|.
name|type
operator|=
name|tq_Nil
expr_stmt|;
comment|/*    * Go get the basic type.    */
switch|switch
condition|(
name|basic_type
condition|)
block|{
case|case
name|bt_Nil
case|:
comment|/* undefined */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"nil"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Adr
case|:
comment|/* address - integer same size as pointer */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Char
case|:
comment|/* character */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"char"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_UChar
case|:
comment|/* unsigned character */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned char"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Short
case|:
comment|/* short */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_UShort
case|:
comment|/* unsigned short */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned short"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Int
case|:
comment|/* int */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_UInt
case|:
comment|/* unsigned int */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned int"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Long
case|:
comment|/* long */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_ULong
case|:
comment|/* unsigned long */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"unsigned long"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Float
case|:
comment|/* float (real) */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"float"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Double
case|:
comment|/* Double (real) */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"double"
argument_list|)
expr_stmt|;
break|break;
comment|/* Structures add 1-2 aux words: 	 1st word is [ST_RFDESCAPE, offset] pointer to struct def; 	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */
case|case
name|bt_Struct
case|:
comment|/* Structure (Record) */
name|emit_aggregate
argument_list|(
name|p1
argument_list|,
name|aux_ptr
index|[
name|index
index|]
argument_list|,
name|aux_ptr
index|[
name|index
operator|+
literal|1
index|]
argument_list|,
literal|"struct"
argument_list|,
name|fdp
argument_list|)
expr_stmt|;
name|used_ptr
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|aux_ptr
index|[
name|index
index|]
operator|.
name|rndx
operator|.
name|rfd
operator|==
name|ST_RFDESCAPE
condition|)
name|used_ptr
index|[
operator|++
name|index
index|]
operator|=
literal|1
expr_stmt|;
name|index
operator|++
expr_stmt|;
comment|/* skip aux words */
break|break;
comment|/* Unions add 1-2 aux words: 	 1st word is [ST_RFDESCAPE, offset] pointer to union def; 	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */
case|case
name|bt_Union
case|:
comment|/* Union */
name|emit_aggregate
argument_list|(
name|p1
argument_list|,
name|aux_ptr
index|[
name|index
index|]
argument_list|,
name|aux_ptr
index|[
name|index
operator|+
literal|1
index|]
argument_list|,
literal|"union"
argument_list|,
name|fdp
argument_list|)
expr_stmt|;
name|used_ptr
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|aux_ptr
index|[
name|index
index|]
operator|.
name|rndx
operator|.
name|rfd
operator|==
name|ST_RFDESCAPE
condition|)
name|used_ptr
index|[
operator|++
name|index
index|]
operator|=
literal|1
expr_stmt|;
name|index
operator|++
expr_stmt|;
comment|/* skip aux words */
break|break;
comment|/* Enumerations add 1-2 aux words: 	 1st word is [ST_RFDESCAPE, offset] pointer to enum def; 	 2nd word is file index if 1st word rfd is ST_RFDESCAPE.  */
case|case
name|bt_Enum
case|:
comment|/* Enumeration */
name|emit_aggregate
argument_list|(
name|p1
argument_list|,
name|aux_ptr
index|[
name|index
index|]
argument_list|,
name|aux_ptr
index|[
name|index
operator|+
literal|1
index|]
argument_list|,
literal|"enum"
argument_list|,
name|fdp
argument_list|)
expr_stmt|;
name|used_ptr
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|aux_ptr
index|[
name|index
index|]
operator|.
name|rndx
operator|.
name|rfd
operator|==
name|ST_RFDESCAPE
condition|)
name|used_ptr
index|[
operator|++
name|index
index|]
operator|=
literal|1
expr_stmt|;
name|index
operator|++
expr_stmt|;
comment|/* skip aux words */
break|break;
case|case
name|bt_Typedef
case|:
comment|/* defined via a typedef, isymRef points */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Range
case|:
comment|/* subrange of int */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"subrange"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Set
case|:
comment|/* pascal sets */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"set"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Complex
case|:
comment|/* fortran complex */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"complex"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_DComplex
case|:
comment|/* fortran double complex */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"double complex"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Indirect
case|:
comment|/* forward or unnamed typedef */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"forward/unnamed typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_FixedDec
case|:
comment|/* Fixed Decimal */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"fixed decimal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_FloatDec
case|:
comment|/* Float Decimal */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"float decimal"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_String
case|:
comment|/* Varying Length Character String */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"string"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Bit
case|:
comment|/* Aligned Bit String */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"bit"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Picture
case|:
comment|/* Picture */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"picture"
argument_list|)
expr_stmt|;
break|break;
case|case
name|bt_Void
case|:
comment|/* Void */
name|strcpy
argument_list|(
name|p1
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|p1
argument_list|,
literal|"Unknown basic type %d"
argument_list|,
operator|(
name|int
operator|)
name|basic_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|p1
operator|+=
name|strlen
argument_list|(
name|buffer1
argument_list|)
expr_stmt|;
comment|/*    * If this is a bitfield, get the bitsize.    */
if|if
condition|(
name|u
operator|.
name|ti
operator|.
name|fBitfield
condition|)
block|{
name|int
name|bitsize
decl_stmt|;
name|used_ptr
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
name|bitsize
operator|=
name|aux_ptr
index|[
name|index
operator|++
index|]
operator|.
name|width
expr_stmt|;
name|sprintf
argument_list|(
name|p1
argument_list|,
literal|" : %d"
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
name|p1
operator|+=
name|strlen
argument_list|(
name|buffer1
argument_list|)
expr_stmt|;
block|}
comment|/*    * Deal with any qualifiers.    */
if|if
condition|(
name|qualifiers
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|tq_Nil
condition|)
block|{
comment|/*        * Snarf up any array bounds in the correct order.  Arrays        * store 5 successive words in the aux. table:        *	word 0	RNDXR to type of the bounds (ie, int)        *	word 1	Current file descriptor index        *	word 2	low bound        *	word 3	high bound (or -1 if [])        *	word 4	stride size in bits        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qualifiers
index|[
name|i
index|]
operator|.
name|type
operator|==
name|tq_Array
condition|)
block|{
name|qualifiers
index|[
name|i
index|]
operator|.
name|low_bound
operator|=
name|aux_ptr
index|[
name|index
operator|+
literal|2
index|]
operator|.
name|dnLow
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|high_bound
operator|=
name|aux_ptr
index|[
name|index
operator|+
literal|3
index|]
operator|.
name|dnHigh
expr_stmt|;
name|qualifiers
index|[
name|i
index|]
operator|.
name|stride
operator|=
name|aux_ptr
index|[
name|index
operator|+
literal|4
index|]
operator|.
name|width
expr_stmt|;
name|used_ptr
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
name|used_ptr
index|[
name|index
operator|+
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|used_ptr
index|[
name|index
operator|+
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|used_ptr
index|[
name|index
operator|+
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|used_ptr
index|[
name|index
operator|+
literal|4
index|]
operator|=
literal|1
expr_stmt|;
name|index
operator|+=
literal|5
expr_stmt|;
block|}
block|}
comment|/*        * Now print out the qualifiers.        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|qualifiers
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|tq_Nil
case|:
case|case
name|tq_Max
case|:
break|break;
case|case
name|tq_Ptr
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"ptr to "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"ptr to "
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|tq_Vol
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"volatile "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"volatile "
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|tq_Far
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"far "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"far "
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|tq_Proc
case|:
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"func. ret. "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"func. ret. "
argument_list|)
expr_stmt|;
break|break;
case|case
name|tq_Array
case|:
block|{
name|int
name|first_array
init|=
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Print array bounds reversed (ie, in the order the C 		   programmer writes them).  C is such a fun language.... */
while|while
condition|(
name|i
operator|<
literal|5
operator|&&
name|qualifiers
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|type
operator|==
name|tq_Array
condition|)
name|i
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>=
name|first_array
condition|;
name|j
operator|--
control|)
block|{
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"array ["
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"array ["
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|low_bound
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|p2
argument_list|,
literal|"%ld:%ld {%ld bits}"
argument_list|,
operator|(
name|long
operator|)
name|qualifiers
index|[
name|j
index|]
operator|.
name|low_bound
argument_list|,
operator|(
name|long
operator|)
name|qualifiers
index|[
name|j
index|]
operator|.
name|high_bound
argument_list|,
operator|(
name|long
operator|)
name|qualifiers
index|[
name|j
index|]
operator|.
name|stride
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|high_bound
operator|!=
operator|-
literal|1
condition|)
name|sprintf
argument_list|(
name|p2
argument_list|,
literal|"%ld {%ld bits}"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|high_bound
operator|+
literal|1
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|stride
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|p2
argument_list|,
literal|" {%ld bits}"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|qualifiers
index|[
name|j
index|]
operator|.
name|stride
argument_list|)
argument_list|)
expr_stmt|;
name|p2
operator|+=
name|strlen
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p2
argument_list|,
literal|"] of "
argument_list|)
expr_stmt|;
name|p2
operator|+=
sizeof|sizeof
argument_list|(
literal|"] of "
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
name|strcpy
argument_list|(
name|p2
argument_list|,
name|buffer1
argument_list|)
expr_stmt|;
return|return
name|buffer2
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out the global file header for object files.  */
end_comment

begin_function
name|void
name|print_global_hdr
parameter_list|(
name|ptr
parameter_list|)
name|struct
name|filehdr
modifier|*
name|ptr
decl_stmt|;
block|{
name|char
modifier|*
name|time
init|=
name|ctime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|ptr
operator|->
name|f_timdat
argument_list|)
decl_stmt|;
name|ushort
name|flags
init|=
name|ptr
operator|->
name|f_flags
decl_stmt|;
name|printf
argument_list|(
literal|"Global file header:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s 0x%x\n"
argument_list|,
literal|24
argument_list|,
literal|"magic number"
argument_list|,
operator|(
name|ushort
operator|)
name|ptr
operator|->
name|f_magic
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %d\n"
argument_list|,
literal|24
argument_list|,
literal|"# sections"
argument_list|,
operator|(
name|int
operator|)
name|ptr
operator|->
name|f_nscns
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %ld, %s"
argument_list|,
literal|24
argument_list|,
literal|"timestamp"
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|f_timdat
argument_list|,
name|time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %ld\n"
argument_list|,
literal|24
argument_list|,
literal|"symbolic header offset"
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|f_symptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %ld\n"
argument_list|,
literal|24
argument_list|,
literal|"symbolic header size"
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|f_nsyms
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %ld\n"
argument_list|,
literal|24
argument_list|,
literal|"optional header"
argument_list|,
operator|(
name|long
operator|)
name|ptr
operator|->
name|f_opthdr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s 0x%x"
argument_list|,
literal|24
argument_list|,
literal|"flags"
argument_list|,
operator|(
name|ushort
operator|)
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_RELFLG
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", F_RELFLG"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_EXEC
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", F_EXEC"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_LNNO
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", F_LNNO"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_LSYMS
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", F_LSYMS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_MINMAL
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", F_MINMAL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_UPDATE
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", F_UPDATE"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_SWABD
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", F_SWABD"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_AR16WR
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", F_AR16WR"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_AR32WR
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", F_AR32WR"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_AR32W
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", F_AR32W"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|F_PATCH
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", F_PATCH/F_NODF"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out the symbolic header.  */
end_comment

begin_function
name|void
name|print_sym_hdr
parameter_list|(
name|sym_ptr
parameter_list|)
name|HDRR
modifier|*
name|sym_ptr
decl_stmt|;
block|{
name|int
name|width
init|=
literal|20
decl_stmt|;
name|printf
argument_list|(
literal|"Symbolic header, magic number = 0x%04x, vstamp = %d.%d:\n\n"
argument_list|,
name|sym_ptr
operator|->
name|magic
operator|&
literal|0xffff
argument_list|,
operator|(
name|sym_ptr
operator|->
name|vstamp
operator|&
literal|0xffff
operator|)
operator|>>
literal|8
argument_list|,
name|sym_ptr
operator|->
name|vstamp
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11s %11s %11s\n"
argument_list|,
name|width
argument_list|,
literal|"Info"
argument_list|,
literal|"Offset"
argument_list|,
literal|"Number"
argument_list|,
literal|"Bytes"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11s %11s %11s\n"
argument_list|,
name|width
argument_list|,
literal|"===="
argument_list|,
literal|"======"
argument_list|,
literal|"======"
argument_list|,
literal|"=====\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11ld %11ld %11ld [%d]\n"
argument_list|,
name|width
argument_list|,
literal|"Line numbers"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbLineOffset
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbLine
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbLine
argument_list|,
operator|(
name|int
operator|)
name|sym_ptr
operator|->
name|ilineMax
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11ld %11ld %11ld\n"
argument_list|,
name|width
argument_list|,
literal|"Dense numbers"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbDnOffset
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|idnMax
argument_list|,
call|(
name|long
call|)
argument_list|(
name|sym_ptr
operator|->
name|idnMax
operator|*
sizeof|sizeof
argument_list|(
name|DNR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11ld %11ld %11ld\n"
argument_list|,
name|width
argument_list|,
literal|"Procedures Tables"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbPdOffset
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|ipdMax
argument_list|,
call|(
name|long
call|)
argument_list|(
name|sym_ptr
operator|->
name|ipdMax
operator|*
sizeof|sizeof
argument_list|(
name|PDR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11ld %11ld %11ld\n"
argument_list|,
name|width
argument_list|,
literal|"Local Symbols"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbSymOffset
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|isymMax
argument_list|,
call|(
name|long
call|)
argument_list|(
name|sym_ptr
operator|->
name|isymMax
operator|*
sizeof|sizeof
argument_list|(
name|SYMR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11ld %11ld %11ld\n"
argument_list|,
name|width
argument_list|,
literal|"Optimization Symbols"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbOptOffset
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|ioptMax
argument_list|,
call|(
name|long
call|)
argument_list|(
name|sym_ptr
operator|->
name|ioptMax
operator|*
sizeof|sizeof
argument_list|(
name|OPTR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11ld %11ld %11ld\n"
argument_list|,
name|width
argument_list|,
literal|"Auxiliary Symbols"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbAuxOffset
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|iauxMax
argument_list|,
call|(
name|long
call|)
argument_list|(
name|sym_ptr
operator|->
name|iauxMax
operator|*
sizeof|sizeof
argument_list|(
name|AUXU
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11ld %11ld %11ld\n"
argument_list|,
name|width
argument_list|,
literal|"Local Strings"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbSsOffset
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|issMax
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|issMax
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11ld %11ld %11ld\n"
argument_list|,
name|width
argument_list|,
literal|"External Strings"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbSsExtOffset
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|issExtMax
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|issExtMax
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11ld %11ld %11ld\n"
argument_list|,
name|width
argument_list|,
literal|"File Tables"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbFdOffset
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|ifdMax
argument_list|,
call|(
name|long
call|)
argument_list|(
name|sym_ptr
operator|->
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11ld %11ld %11ld\n"
argument_list|,
name|width
argument_list|,
literal|"Relative Files"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbRfdOffset
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|crfd
argument_list|,
call|(
name|long
call|)
argument_list|(
name|sym_ptr
operator|->
name|crfd
operator|*
sizeof|sizeof
argument_list|(
name|ulong
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11ld %11ld %11ld\n"
argument_list|,
name|width
argument_list|,
literal|"External Symbols"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|cbExtOffset
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|iextMax
argument_list|,
call|(
name|long
call|)
argument_list|(
name|sym_ptr
operator|->
name|iextMax
operator|*
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out a symbol.  */
end_comment

begin_function
name|void
name|print_symbol
parameter_list|(
name|sym_ptr
parameter_list|,
name|number
parameter_list|,
name|strbase
parameter_list|,
name|aux_base
parameter_list|,
name|ifd
parameter_list|,
name|fdp
parameter_list|)
name|SYMR
modifier|*
name|sym_ptr
decl_stmt|;
name|int
name|number
decl_stmt|;
name|char
modifier|*
name|strbase
decl_stmt|;
name|AUXU
modifier|*
name|aux_base
decl_stmt|;
name|int
name|ifd
decl_stmt|;
name|FDR
modifier|*
name|fdp
decl_stmt|;
block|{
name|sc_t
name|storage_class
init|=
operator|(
name|sc_t
operator|)
name|sym_ptr
operator|->
name|sc
decl_stmt|;
name|st_t
name|symbol_type
init|=
operator|(
name|st_t
operator|)
name|sym_ptr
operator|->
name|st
decl_stmt|;
name|ulong
name|index
init|=
name|sym_ptr
operator|->
name|index
decl_stmt|;
name|char
modifier|*
name|used_ptr
init|=
name|aux_used
operator|+
operator|(
name|aux_base
operator|-
name|aux_symbols
operator|)
decl_stmt|;
name|scope_t
modifier|*
name|scope_ptr
decl_stmt|;
name|printf
argument_list|(
literal|"\n    Symbol# %d: \"%s\"\n"
argument_list|,
name|number
argument_list|,
name|sym_ptr
operator|->
name|iss
operator|+
name|strbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux_base
operator|!=
operator|(
name|AUXU
operator|*
operator|)
literal|0
operator|&&
name|index
operator|!=
name|indexNil
condition|)
switch|switch
condition|(
name|symbol_type
condition|)
block|{
case|case
name|st_Nil
case|:
case|case
name|st_Label
case|:
break|break;
case|case
name|st_File
case|:
case|case
name|st_Block
case|:
name|printf
argument_list|(
literal|"      End+1 symbol: %ld\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_scope
condition|)
block|{
if|if
condition|(
name|free_scope
operator|==
operator|(
name|scope_t
operator|*
operator|)
literal|0
condition|)
name|scope_ptr
operator|=
operator|(
name|scope_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scope_t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|scope_ptr
operator|=
name|free_scope
expr_stmt|;
name|free_scope
operator|=
name|scope_ptr
operator|->
name|prev
expr_stmt|;
block|}
name|scope_ptr
operator|->
name|open_sym
operator|=
name|number
expr_stmt|;
name|scope_ptr
operator|->
name|st
operator|=
name|symbol_type
expr_stmt|;
name|scope_ptr
operator|->
name|sc
operator|=
name|storage_class
expr_stmt|;
name|scope_ptr
operator|->
name|prev
operator|=
name|cur_scope
expr_stmt|;
name|cur_scope
operator|=
name|scope_ptr
expr_stmt|;
block|}
break|break;
case|case
name|st_End
case|:
if|if
condition|(
name|storage_class
operator|==
name|sc_Text
operator|||
name|storage_class
operator|==
name|sc_Info
condition|)
name|printf
argument_list|(
literal|"      First symbol: %ld\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|else
block|{
name|used_ptr
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"      First symbol: %ld\n"
argument_list|,
name|aux_base
index|[
name|index
index|]
operator|.
name|isym
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|want_scope
condition|)
block|{
if|if
condition|(
name|cur_scope
operator|==
operator|(
name|scope_t
operator|*
operator|)
literal|0
condition|)
name|printf
argument_list|(
literal|"      Can't pop end scope\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|scope_ptr
operator|=
name|cur_scope
expr_stmt|;
name|cur_scope
operator|=
name|scope_ptr
operator|->
name|prev
expr_stmt|;
name|scope_ptr
operator|->
name|prev
operator|=
name|free_scope
expr_stmt|;
name|free_scope
operator|=
name|scope_ptr
expr_stmt|;
block|}
block|}
break|break;
case|case
name|st_Proc
case|:
case|case
name|st_StaticProc
case|:
if|if
condition|(
name|MIPS_IS_STAB
argument_list|(
name|sym_ptr
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|ifd
operator|==
operator|-
literal|1
condition|)
comment|/* local symbol */
block|{
name|used_ptr
index|[
name|index
index|]
operator|=
name|used_ptr
index|[
name|index
operator|+
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"      End+1 symbol: %-7ld   Type:  %s\n"
argument_list|,
name|aux_base
index|[
name|index
index|]
operator|.
name|isym
argument_list|,
name|type_to_string
argument_list|(
name|aux_base
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|fdp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* global symbol */
name|printf
argument_list|(
literal|"      Local symbol: %ld\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_scope
condition|)
block|{
if|if
condition|(
name|free_scope
operator|==
operator|(
name|scope_t
operator|*
operator|)
literal|0
condition|)
name|scope_ptr
operator|=
operator|(
name|scope_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scope_t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|scope_ptr
operator|=
name|free_scope
expr_stmt|;
name|free_scope
operator|=
name|scope_ptr
operator|->
name|prev
expr_stmt|;
block|}
name|scope_ptr
operator|->
name|open_sym
operator|=
name|number
expr_stmt|;
name|scope_ptr
operator|->
name|st
operator|=
name|symbol_type
expr_stmt|;
name|scope_ptr
operator|->
name|sc
operator|=
name|storage_class
expr_stmt|;
name|scope_ptr
operator|->
name|prev
operator|=
name|cur_scope
expr_stmt|;
name|cur_scope
operator|=
name|scope_ptr
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|stStruct
case|case
name|st_Struct
case|:
case|case
name|st_Union
case|:
case|case
name|st_Enum
case|:
name|printf
argument_list|(
literal|"      End+1 symbol: %lu\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
operator|!
name|MIPS_IS_STAB
argument_list|(
name|sym_ptr
argument_list|)
condition|)
block|{
name|used_ptr
index|[
name|index
index|]
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"      Type: %s\n"
argument_list|,
name|type_to_string
argument_list|(
name|aux_base
argument_list|,
name|index
argument_list|,
name|fdp
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|want_scope
condition|)
block|{
name|printf
argument_list|(
literal|"      Scopes:  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_scope
operator|==
operator|(
name|scope_t
operator|*
operator|)
literal|0
condition|)
name|printf
argument_list|(
literal|" none\n"
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|scope_ptr
operator|=
name|cur_scope
init|;
name|scope_ptr
operator|!=
operator|(
name|scope_t
operator|*
operator|)
literal|0
condition|;
name|scope_ptr
operator|=
name|scope_ptr
operator|->
name|prev
control|)
block|{
name|char
modifier|*
name|class
decl_stmt|;
if|if
condition|(
name|scope_ptr
operator|->
name|st
operator|==
name|st_Proc
operator|||
name|scope_ptr
operator|->
name|st
operator|==
name|st_StaticProc
condition|)
name|class
operator|=
literal|"func."
expr_stmt|;
elseif|else
if|if
condition|(
name|scope_ptr
operator|->
name|st
operator|==
name|st_File
condition|)
name|class
operator|=
literal|"file"
expr_stmt|;
elseif|else
if|if
condition|(
name|scope_ptr
operator|->
name|st
operator|==
name|st_Block
operator|&&
name|scope_ptr
operator|->
name|sc
operator|==
name|sc_Text
condition|)
name|class
operator|=
literal|"block"
expr_stmt|;
elseif|else
if|if
condition|(
name|scope_ptr
operator|->
name|st
operator|==
name|st_Block
operator|&&
name|scope_ptr
operator|->
name|sc
operator|==
name|sc_Info
condition|)
name|class
operator|=
literal|"type"
expr_stmt|;
else|else
name|class
operator|=
literal|"???"
expr_stmt|;
name|printf
argument_list|(
literal|" %ld [%s]"
argument_list|,
name|scope_ptr
operator|->
name|open_sym
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"      Value: %-13ld    "
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifd
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"String index: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|iss
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"String index: %-11ld Ifd: %d\n"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|iss
argument_list|,
name|ifd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Symbol type: %-11sStorage class: %-11s"
argument_list|,
name|st_to_string
argument_list|(
name|symbol_type
argument_list|)
argument_list|,
name|sc_to_string
argument_list|(
name|storage_class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MIPS_IS_STAB
argument_list|(
name|sym_ptr
argument_list|)
condition|)
block|{
specifier|register
name|int
name|i
init|=
sizeof|sizeof
argument_list|(
name|stab_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|stab_names
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|char
modifier|*
name|stab_name
init|=
literal|"stab"
decl_stmt|;
name|short
name|code
init|=
name|MIPS_UNMARK_STAB
argument_list|(
name|sym_ptr
operator|->
name|index
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
if|if
condition|(
name|stab_names
index|[
name|i
index|]
operator|.
name|code
operator|==
name|code
condition|)
block|{
name|stab_name
operator|=
name|stab_names
index|[
name|i
index|]
operator|.
name|string
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"Index: 0x%lx (%s)\n"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|index
argument_list|,
name|stab_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_ptr
operator|->
name|st
operator|==
name|stLabel
operator|&&
name|sym_ptr
operator|->
name|index
operator|!=
name|indexNil
condition|)
name|printf
argument_list|(
literal|"Index: %ld (line#)\n"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Index: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|sym_ptr
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out a word from the aux. table in various formats.  */
end_comment

begin_function
name|void
name|print_aux
parameter_list|(
name|u
parameter_list|,
name|auxi
parameter_list|,
name|used
parameter_list|)
name|AUXU
name|u
decl_stmt|;
name|int
name|auxi
decl_stmt|;
name|int
name|used
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\t%s#%-5d %11ld, [%4ld/%7ld], [%2d %1d:%1d %1x:%1x:%1x:%1x:%1x:%1x]\n"
argument_list|,
operator|(
name|used
operator|)
condition|?
literal|"  "
else|:
literal|"* "
argument_list|,
name|auxi
argument_list|,
operator|(
name|long
operator|)
name|u
operator|.
name|isym
argument_list|,
operator|(
name|long
operator|)
name|u
operator|.
name|rndx
operator|.
name|rfd
argument_list|,
operator|(
name|long
operator|)
name|u
operator|.
name|rndx
operator|.
name|index
argument_list|,
name|u
operator|.
name|ti
operator|.
name|bt
argument_list|,
name|u
operator|.
name|ti
operator|.
name|fBitfield
argument_list|,
name|u
operator|.
name|ti
operator|.
name|continued
argument_list|,
name|u
operator|.
name|ti
operator|.
name|tq0
argument_list|,
name|u
operator|.
name|ti
operator|.
name|tq1
argument_list|,
name|u
operator|.
name|ti
operator|.
name|tq2
argument_list|,
name|u
operator|.
name|ti
operator|.
name|tq3
argument_list|,
name|u
operator|.
name|ti
operator|.
name|tq4
argument_list|,
name|u
operator|.
name|ti
operator|.
name|tq5
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write aggregate information to a string.  */
end_comment

begin_function
name|void
name|emit_aggregate
parameter_list|(
name|string
parameter_list|,
name|u
parameter_list|,
name|u2
parameter_list|,
name|which
parameter_list|,
name|fdp
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|AUXU
name|u
decl_stmt|;
name|AUXU
name|u2
decl_stmt|;
specifier|const
name|char
modifier|*
name|which
decl_stmt|;
name|FDR
modifier|*
name|fdp
decl_stmt|;
block|{
name|unsigned
name|int
name|ifd
init|=
name|u
operator|.
name|rndx
operator|.
name|rfd
decl_stmt|;
name|unsigned
name|int
name|index
init|=
name|u
operator|.
name|rndx
operator|.
name|index
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|ifd
operator|==
name|ST_RFDESCAPE
condition|)
name|ifd
operator|=
name|u2
operator|.
name|isym
expr_stmt|;
comment|/* An ifd of -1 is an opaque type.  An escaped index of 0 is a      struct return type of a procedure compiled without -g.  */
if|if
condition|(
name|ifd
operator|==
literal|0xffffffff
operator|||
operator|(
name|u
operator|.
name|rndx
operator|.
name|rfd
operator|==
name|ST_RFDESCAPE
operator|&&
name|index
operator|==
literal|0
operator|)
condition|)
name|name
operator|=
literal|"<undefined>"
expr_stmt|;
elseif|else
if|if
condition|(
name|index
operator|==
name|indexNil
condition|)
name|name
operator|=
literal|"<no name>"
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fdp
operator|==
literal|0
operator|||
name|sym_hdr
operator|.
name|crfd
operator|==
literal|0
condition|)
name|fdp
operator|=
operator|&
name|file_desc
index|[
name|ifd
index|]
expr_stmt|;
else|else
name|fdp
operator|=
operator|&
name|file_desc
index|[
name|rfile_desc
index|[
name|fdp
operator|->
name|rfdBase
operator|+
name|ifd
index|]
index|]
expr_stmt|;
name|name
operator|=
operator|&
name|l_strings
index|[
name|fdp
operator|->
name|issBase
operator|+
name|l_symbols
index|[
name|index
operator|+
name|fdp
operator|->
name|isymBase
index|]
operator|.
name|iss
index|]
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|string
argument_list|,
literal|"%s %s { ifd = %u, index = %u }"
argument_list|,
name|which
argument_list|,
name|name
argument_list|,
name|ifd
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print out information about a file descriptor, and the symbols,    procedures, and line numbers within it.  */
end_comment

begin_function
name|void
name|print_file_desc
parameter_list|(
name|fdp
parameter_list|,
name|number
parameter_list|)
name|FDR
modifier|*
name|fdp
decl_stmt|;
name|int
name|number
decl_stmt|;
block|{
name|char
modifier|*
name|str_base
decl_stmt|;
name|AUXU
modifier|*
name|aux_base
decl_stmt|;
name|int
name|symi
decl_stmt|,
name|pdi
decl_stmt|;
name|int
name|width
init|=
literal|20
decl_stmt|;
name|char
modifier|*
name|used_base
decl_stmt|;
name|str_base
operator|=
name|l_strings
operator|+
name|fdp
operator|->
name|issBase
expr_stmt|;
name|aux_base
operator|=
name|aux_symbols
operator|+
name|fdp
operator|->
name|iauxBase
expr_stmt|;
name|used_base
operator|=
name|aux_used
operator|+
operator|(
name|aux_base
operator|-
name|aux_symbols
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nFile #%d, \"%s\"\n\n"
argument_list|,
name|number
argument_list|,
name|str_base
operator|+
name|fdp
operator|->
name|rss
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Name index  = %-10ld Readin      = %s\n"
argument_list|,
operator|(
name|long
operator|)
name|fdp
operator|->
name|rss
argument_list|,
operator|(
name|fdp
operator|->
name|fReadin
operator|)
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Merge       = %-10s Endian      = %s\n"
argument_list|,
operator|(
name|fdp
operator|->
name|fMerge
operator|)
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|,
operator|(
name|fdp
operator|->
name|fBigendian
operator|)
condition|?
literal|"BIG"
else|:
literal|"LITTLE"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Debug level = %-10s Language    = %s\n"
argument_list|,
name|glevel_to_string
argument_list|(
name|fdp
operator|->
name|glevel
argument_list|)
argument_list|,
name|lang_to_string
argument_list|(
operator|(
name|lang_t
operator|)
name|fdp
operator|->
name|lang
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Adr         = 0x%08lx\n\n"
argument_list|,
operator|(
name|long
operator|)
name|fdp
operator|->
name|adr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11s %11s %11s %11s\n"
argument_list|,
name|width
argument_list|,
literal|"Info"
argument_list|,
literal|"Start"
argument_list|,
literal|"Number"
argument_list|,
literal|"Size"
argument_list|,
literal|"Offset"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11s %11s %11s %11s\n"
argument_list|,
name|width
argument_list|,
literal|"===="
argument_list|,
literal|"====="
argument_list|,
literal|"======"
argument_list|,
literal|"===="
argument_list|,
literal|"======"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11lu %11lu %11lu %11lu\n"
argument_list|,
name|width
argument_list|,
literal|"Local strings"
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|issBase
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|cbSs
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|cbSs
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|issBase
operator|+
name|sym_hdr
operator|.
name|cbSsOffset
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11lu %11lu %11lu %11lu\n"
argument_list|,
name|width
argument_list|,
literal|"Local symbols"
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|isymBase
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|csym
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|csym
operator|*
sizeof|sizeof
argument_list|(
name|SYMR
argument_list|)
argument_list|)
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|isymBase
operator|*
sizeof|sizeof
argument_list|(
name|SYMR
argument_list|)
operator|+
name|sym_hdr
operator|.
name|cbSymOffset
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11lu %11lu %11lu %11lu\n"
argument_list|,
name|width
argument_list|,
literal|"Line numbers"
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|cbLineOffset
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|cline
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|cbLine
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|cbLineOffset
operator|+
name|sym_hdr
operator|.
name|cbLineOffset
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11lu %11lu %11lu %11lu\n"
argument_list|,
name|width
argument_list|,
literal|"Optimization symbols"
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|ioptBase
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|copt
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|copt
operator|*
sizeof|sizeof
argument_list|(
name|OPTR
argument_list|)
argument_list|)
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|ioptBase
operator|*
sizeof|sizeof
argument_list|(
name|OPTR
argument_list|)
operator|+
name|sym_hdr
operator|.
name|cbOptOffset
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11lu %11lu %11lu %11lu\n"
argument_list|,
name|width
argument_list|,
literal|"Procedures"
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|ipdFirst
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|cpd
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|cpd
operator|*
sizeof|sizeof
argument_list|(
name|PDR
argument_list|)
argument_list|)
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|ipdFirst
operator|*
sizeof|sizeof
argument_list|(
name|PDR
argument_list|)
operator|+
name|sym_hdr
operator|.
name|cbPdOffset
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11lu %11lu %11lu %11lu\n"
argument_list|,
name|width
argument_list|,
literal|"Auxiliary symbols"
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|iauxBase
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|caux
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|caux
operator|*
sizeof|sizeof
argument_list|(
name|AUXU
argument_list|)
argument_list|)
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|iauxBase
operator|*
sizeof|sizeof
argument_list|(
name|AUXU
argument_list|)
operator|+
name|sym_hdr
operator|.
name|cbAuxOffset
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    %-*s %11lu %11lu %11lu %11lu\n"
argument_list|,
name|width
argument_list|,
literal|"Relative Files"
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|rfdBase
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|crfd
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|crfd
operator|*
sizeof|sizeof
argument_list|(
name|ulong
argument_list|)
argument_list|)
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|rfdBase
operator|*
sizeof|sizeof
argument_list|(
name|ulong
argument_list|)
operator|+
name|sym_hdr
operator|.
name|cbRfdOffset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_scope
operator|&&
name|cur_scope
operator|!=
operator|(
name|scope_t
operator|*
operator|)
literal|0
condition|)
name|printf
argument_list|(
literal|"\n    Warning scope does not start at 0!\n"
argument_list|)
expr_stmt|;
comment|/*     * print the info about the symbol table.    */
name|printf
argument_list|(
literal|"\n    There are %lu local symbols, starting at %lu\n"
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|csym
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|isymBase
operator|+
name|sym_hdr
operator|.
name|cbSymOffset
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|symi
operator|=
name|fdp
operator|->
name|isymBase
init|;
name|symi
operator|<
operator|(
name|fdp
operator|->
name|csym
operator|+
name|fdp
operator|->
name|isymBase
operator|)
condition|;
name|symi
operator|++
control|)
name|print_symbol
argument_list|(
operator|&
name|l_symbols
index|[
name|symi
index|]
argument_list|,
name|symi
operator|-
name|fdp
operator|->
name|isymBase
argument_list|,
name|str_base
argument_list|,
name|aux_base
argument_list|,
operator|-
literal|1
argument_list|,
name|fdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_scope
operator|&&
name|cur_scope
operator|!=
operator|(
name|scope_t
operator|*
operator|)
literal|0
condition|)
name|printf
argument_list|(
literal|"\n    Warning scope does not end at 0!\n"
argument_list|)
expr_stmt|;
comment|/*    * print the aux. table if desired.    */
if|if
condition|(
name|want_aux
operator|&&
name|fdp
operator|->
name|caux
operator|!=
literal|0
condition|)
block|{
name|int
name|auxi
decl_stmt|;
name|printf
argument_list|(
literal|"\n    There are %lu auxiliary table entries, starting at %lu.\n\n"
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|caux
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|iauxBase
operator|+
name|sym_hdr
operator|.
name|cbAuxOffset
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|auxi
operator|=
name|fdp
operator|->
name|iauxBase
init|;
name|auxi
operator|<
operator|(
name|fdp
operator|->
name|caux
operator|+
name|fdp
operator|->
name|iauxBase
operator|)
condition|;
name|auxi
operator|++
control|)
name|print_aux
argument_list|(
name|aux_base
index|[
name|auxi
index|]
argument_list|,
name|auxi
argument_list|,
name|used_base
index|[
name|auxi
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*    * print the relative file descriptors.    */
if|if
condition|(
name|want_rfd
operator|&&
name|fdp
operator|->
name|crfd
operator|!=
literal|0
condition|)
block|{
name|ulong
modifier|*
name|rfd_ptr
decl_stmt|,
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\n    There are %lu relative file descriptors, starting at %lu.\n"
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|crfd
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|rfdBase
argument_list|)
expr_stmt|;
name|rfd_ptr
operator|=
name|rfile_desc
operator|+
name|fdp
operator|->
name|rfdBase
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fdp
operator|->
name|crfd
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\t#%-5ld %11ld, 0x%08lx\n"
argument_list|,
name|i
argument_list|,
operator|*
name|rfd_ptr
argument_list|,
operator|*
name|rfd_ptr
argument_list|)
expr_stmt|;
name|rfd_ptr
operator|++
expr_stmt|;
block|}
block|}
comment|/*     * do the procedure descriptors.    */
name|printf
argument_list|(
literal|"\n    There are %lu procedure descriptor entries, "
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|cpd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"starting at %lu.\n"
argument_list|,
operator|(
name|ulong
operator|)
name|fdp
operator|->
name|ipdFirst
argument_list|)
expr_stmt|;
for|for
control|(
name|pdi
operator|=
name|fdp
operator|->
name|ipdFirst
init|;
name|pdi
operator|<
operator|(
name|fdp
operator|->
name|cpd
operator|+
name|fdp
operator|->
name|ipdFirst
operator|)
condition|;
name|pdi
operator|++
control|)
block|{
name|PDR
modifier|*
name|proc_ptr
init|=
operator|&
name|proc_desc
index|[
name|pdi
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"\n\tProcedure descriptor %d:\n"
argument_list|,
operator|(
name|pdi
operator|-
name|fdp
operator|->
name|ipdFirst
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t    Name index   = %-11ld Name          = \"%s\"\n"
argument_list|,
operator|(
name|long
operator|)
name|l_symbols
index|[
name|proc_ptr
operator|->
name|isym
operator|+
name|fdp
operator|->
name|isymBase
index|]
operator|.
name|iss
argument_list|,
name|l_symbols
index|[
name|proc_ptr
operator|->
name|isym
operator|+
name|fdp
operator|->
name|isymBase
index|]
operator|.
name|iss
operator|+
name|str_base
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t    .mask 0x%08lx,%-9ld .fmask 0x%08lx,%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|proc_ptr
operator|->
name|regmask
argument_list|,
operator|(
name|long
operator|)
name|proc_ptr
operator|->
name|regoffset
argument_list|,
operator|(
name|long
operator|)
name|proc_ptr
operator|->
name|fregmask
argument_list|,
operator|(
name|long
operator|)
name|proc_ptr
operator|->
name|fregoffset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t    .frame $%d,%ld,$%d\n"
argument_list|,
operator|(
name|int
operator|)
name|proc_ptr
operator|->
name|framereg
argument_list|,
operator|(
name|long
operator|)
name|proc_ptr
operator|->
name|frameoffset
argument_list|,
operator|(
name|int
operator|)
name|proc_ptr
operator|->
name|pcreg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t    Opt. start   = %-11ld Symbols start = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|proc_ptr
operator|->
name|iopt
argument_list|,
operator|(
name|long
operator|)
name|proc_ptr
operator|->
name|isym
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t    First line # = %-11ld Last line #   = %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|proc_ptr
operator|->
name|lnLow
argument_list|,
operator|(
name|long
operator|)
name|proc_ptr
operator|->
name|lnHigh
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t    Line Offset  = %-11ld Address       = 0x%08lx\n"
argument_list|,
operator|(
name|long
operator|)
name|proc_ptr
operator|->
name|cbLineOffset
argument_list|,
operator|(
name|long
operator|)
name|proc_ptr
operator|->
name|adr
argument_list|)
expr_stmt|;
comment|/*        * print the line number entries.        */
if|if
condition|(
name|want_line
operator|&&
name|fdp
operator|->
name|cline
operator|!=
literal|0
condition|)
block|{
name|int
name|delta
decl_stmt|,
name|count
decl_stmt|;
name|long
name|cur_line
init|=
name|proc_ptr
operator|->
name|lnLow
decl_stmt|;
name|uchar
modifier|*
name|line_ptr
init|=
operator|(
operator|(
operator|(
name|uchar
operator|*
operator|)
name|lines
operator|)
operator|+
name|proc_ptr
operator|->
name|cbLineOffset
operator|+
name|fdp
operator|->
name|cbLineOffset
operator|)
decl_stmt|;
name|uchar
modifier|*
name|line_end
decl_stmt|;
if|if
condition|(
name|pdi
operator|==
name|fdp
operator|->
name|cpd
operator|+
name|fdp
operator|->
name|ipdFirst
operator|-
literal|1
condition|)
comment|/* last procedure */
name|line_end
operator|=
operator|(
operator|(
name|uchar
operator|*
operator|)
name|lines
operator|)
operator|+
name|fdp
operator|->
name|cbLine
operator|+
name|fdp
operator|->
name|cbLineOffset
expr_stmt|;
else|else
comment|/* not last proc. */
name|line_end
operator|=
operator|(
operator|(
operator|(
name|uchar
operator|*
operator|)
name|lines
operator|)
operator|+
name|proc_desc
index|[
name|pdi
operator|+
literal|1
index|]
operator|.
name|cbLineOffset
operator|+
name|fdp
operator|->
name|cbLineOffset
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tThere are %lu bytes holding line numbers, starting at %lu.\n"
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|line_end
operator|-
name|line_ptr
argument_list|)
argument_list|,
call|(
name|ulong
call|)
argument_list|(
name|fdp
operator|->
name|ilineBase
operator|+
name|sym_hdr
operator|.
name|cbLineOffset
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|line_ptr
operator|<
name|line_end
condition|)
block|{
comment|/* sign extend nibble */
name|delta
operator|=
operator|(
operator|(
operator|*
name|line_ptr
operator|>>
literal|4
operator|)
operator|^
literal|0x8
operator|)
operator|-
literal|0x8
expr_stmt|;
name|count
operator|=
operator|(
operator|*
name|line_ptr
operator|&
literal|0xf
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
operator|-
literal|8
condition|)
name|line_ptr
operator|++
expr_stmt|;
else|else
block|{
name|delta
operator|=
operator|(
operator|(
operator|(
name|line_ptr
index|[
literal|1
index|]
operator|)
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|line_ptr
index|[
literal|2
index|]
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|delta
operator|=
operator|(
name|delta
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
name|line_ptr
operator|+=
literal|3
expr_stmt|;
block|}
name|cur_line
operator|+=
name|delta
expr_stmt|;
name|printf
argument_list|(
literal|"\t    Line %11ld,   delta %5d,   count %2d\n"
argument_list|,
name|cur_line
argument_list|,
name|delta
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in the portions of the .T file that we will print out.  */
end_comment

begin_decl_stmt
name|void
name|read_tfile
name|__proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
name|short
name|magic
decl_stmt|;
name|off_t
name|sym_hdr_offset
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
operator|&
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|magic
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|"Magic number"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tfile
condition|)
block|{
comment|/* Print out the global header, since this is not a T-file.  */
operator|(
name|void
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
operator|&
name|global_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|global_hdr
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|"Global file header"
argument_list|)
expr_stmt|;
name|print_global_hdr
argument_list|(
operator|&
name|global_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|global_hdr
operator|.
name|f_symptr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No symbolic header, Goodbye!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sym_hdr_offset
operator|=
name|global_hdr
operator|.
name|f_symptr
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
operator|&
name|sym_hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|sym_hdr
argument_list|)
argument_list|,
name|sym_hdr_offset
argument_list|,
literal|"Symbolic header"
argument_list|)
expr_stmt|;
name|print_sym_hdr
argument_list|(
operator|&
name|sym_hdr
argument_list|)
expr_stmt|;
name|lines
operator|=
operator|(
name|LINER
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
literal|0
argument_list|,
name|sym_hdr
operator|.
name|cbLine
argument_list|,
name|sym_hdr
operator|.
name|cbLineOffset
argument_list|,
literal|"Line numbers"
argument_list|)
expr_stmt|;
name|dense_nums
operator|=
operator|(
name|DNR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
literal|0
argument_list|,
name|sym_hdr
operator|.
name|idnMax
operator|*
sizeof|sizeof
argument_list|(
name|DNR
argument_list|)
argument_list|,
name|sym_hdr
operator|.
name|cbDnOffset
argument_list|,
literal|"Dense numbers"
argument_list|)
expr_stmt|;
name|proc_desc
operator|=
operator|(
name|PDR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
literal|0
argument_list|,
name|sym_hdr
operator|.
name|ipdMax
operator|*
sizeof|sizeof
argument_list|(
name|PDR
argument_list|)
argument_list|,
name|sym_hdr
operator|.
name|cbPdOffset
argument_list|,
literal|"Procedure tables"
argument_list|)
expr_stmt|;
name|l_symbols
operator|=
operator|(
name|SYMR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
literal|0
argument_list|,
name|sym_hdr
operator|.
name|isymMax
operator|*
sizeof|sizeof
argument_list|(
name|SYMR
argument_list|)
argument_list|,
name|sym_hdr
operator|.
name|cbSymOffset
argument_list|,
literal|"Local symbols"
argument_list|)
expr_stmt|;
name|opt_symbols
operator|=
operator|(
name|OPTR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
literal|0
argument_list|,
name|sym_hdr
operator|.
name|ioptMax
operator|*
sizeof|sizeof
argument_list|(
name|OPTR
argument_list|)
argument_list|,
name|sym_hdr
operator|.
name|cbOptOffset
argument_list|,
literal|"Optimization symbols"
argument_list|)
expr_stmt|;
name|aux_symbols
operator|=
operator|(
name|AUXU
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
literal|0
argument_list|,
name|sym_hdr
operator|.
name|iauxMax
operator|*
sizeof|sizeof
argument_list|(
name|AUXU
argument_list|)
argument_list|,
name|sym_hdr
operator|.
name|cbAuxOffset
argument_list|,
literal|"Auxiliary symbols"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_hdr
operator|.
name|iauxMax
operator|>
literal|0
condition|)
block|{
name|aux_used
operator|=
name|calloc
argument_list|(
name|sym_hdr
operator|.
name|iauxMax
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux_used
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"calloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|l_strings
operator|=
operator|(
name|char
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
literal|0
argument_list|,
name|sym_hdr
operator|.
name|issMax
argument_list|,
name|sym_hdr
operator|.
name|cbSsOffset
argument_list|,
literal|"Local string table"
argument_list|)
expr_stmt|;
name|e_strings
operator|=
operator|(
name|char
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
literal|0
argument_list|,
name|sym_hdr
operator|.
name|issExtMax
argument_list|,
name|sym_hdr
operator|.
name|cbSsExtOffset
argument_list|,
literal|"External string table"
argument_list|)
expr_stmt|;
name|file_desc
operator|=
operator|(
name|FDR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
literal|0
argument_list|,
name|sym_hdr
operator|.
name|ifdMax
operator|*
sizeof|sizeof
argument_list|(
name|FDR
argument_list|)
argument_list|,
name|sym_hdr
operator|.
name|cbFdOffset
argument_list|,
literal|"File tables"
argument_list|)
expr_stmt|;
name|rfile_desc
operator|=
operator|(
name|ulong
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
literal|0
argument_list|,
name|sym_hdr
operator|.
name|crfd
operator|*
sizeof|sizeof
argument_list|(
name|ulong
argument_list|)
argument_list|,
name|sym_hdr
operator|.
name|cbRfdOffset
argument_list|,
literal|"Relative file tables"
argument_list|)
expr_stmt|;
name|e_symbols
operator|=
operator|(
name|EXTR
operator|*
operator|)
name|read_seek
argument_list|(
operator|(
name|PTR_T
operator|)
literal|0
argument_list|,
name|sym_hdr
operator|.
name|iextMax
operator|*
sizeof|sizeof
argument_list|(
name|EXTR
argument_list|)
argument_list|,
name|sym_hdr
operator|.
name|cbExtOffset
argument_list|,
literal|"External symbols"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|opt
decl_stmt|;
comment|/*    * Process arguments    */
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"alrst"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
default|default:
name|errors
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|want_aux
operator|++
expr_stmt|;
break|break;
comment|/* print aux table */
case|case
literal|'l'
case|:
name|want_line
operator|++
expr_stmt|;
break|break;
comment|/* print line numbers */
case|case
literal|'r'
case|:
name|want_rfd
operator|++
expr_stmt|;
break|break;
comment|/* print relative fd's */
case|case
literal|'s'
case|:
name|want_scope
operator|++
expr_stmt|;
break|break;
comment|/* print scope info */
case|case
literal|'t'
case|:
name|tfile
operator|++
expr_stmt|;
break|break;
comment|/* this is a tfile (without header), and not a .o */
block|}
if|if
condition|(
name|errors
operator|||
name|optind
operator|!=
name|argc
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Calling Sequence:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s [-alrst]<object-or-T-file>\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"switches:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-a Print out auxiliary table.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-l Print out line numbers.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-r Print out relative file descriptors.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-s Print out the current scopes for an item.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-t Assume there is no global header (ie, a T-file).\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*    * Open and process the input file.    */
name|tfile_fd
operator|=
name|open
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfile_fd
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|read_tfile
argument_list|()
expr_stmt|;
comment|/*    * Print any global aux words if any.    */
if|if
condition|(
name|want_aux
condition|)
block|{
name|long
name|last_aux_in_use
decl_stmt|;
if|if
condition|(
name|sym_hdr
operator|.
name|ifdMax
operator|!=
literal|0
operator|&&
name|file_desc
index|[
literal|0
index|]
operator|.
name|iauxBase
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nGlobal auxiliary entries before first file:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|file_desc
index|[
literal|0
index|]
operator|.
name|iauxBase
condition|;
name|i
operator|++
control|)
name|print_aux
argument_list|(
name|aux_symbols
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|aux_used
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym_hdr
operator|.
name|ifdMax
operator|==
literal|0
condition|)
name|last_aux_in_use
operator|=
literal|0
expr_stmt|;
else|else
name|last_aux_in_use
operator|=
name|file_desc
index|[
name|sym_hdr
operator|.
name|ifdMax
operator|-
literal|1
index|]
operator|.
name|iauxBase
operator|+
name|file_desc
index|[
name|sym_hdr
operator|.
name|ifdMax
operator|-
literal|1
index|]
operator|.
name|caux
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|last_aux_in_use
operator|<
name|sym_hdr
operator|.
name|iauxMax
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"\nGlobal auxiliary entries after last file:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|last_aux_in_use
init|;
name|i
operator|<
name|sym_hdr
operator|.
name|iauxMax
condition|;
name|i
operator|++
control|)
name|print_aux
argument_list|(
name|aux_symbols
index|[
name|i
index|]
argument_list|,
name|i
operator|-
name|last_aux_in_use
argument_list|,
name|aux_used
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * Print the information for each file.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sym_hdr
operator|.
name|ifdMax
condition|;
name|i
operator|++
control|)
name|print_file_desc
argument_list|(
operator|&
name|file_desc
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*     * Print the external symbols.    */
name|want_scope
operator|=
literal|0
expr_stmt|;
comment|/* scope info is meaning for extern symbols */
name|printf
argument_list|(
literal|"\nThere are %lu external symbols, starting at %lu\n"
argument_list|,
operator|(
name|ulong
operator|)
name|sym_hdr
operator|.
name|iextMax
argument_list|,
operator|(
name|ulong
operator|)
name|sym_hdr
operator|.
name|cbExtOffset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sym_hdr
operator|.
name|iextMax
condition|;
name|i
operator|++
control|)
name|print_symbol
argument_list|(
operator|&
name|e_symbols
index|[
name|i
index|]
operator|.
name|asym
argument_list|,
name|i
argument_list|,
name|e_strings
argument_list|,
name|aux_symbols
operator|+
name|file_desc
index|[
name|e_symbols
index|[
name|i
index|]
operator|.
name|ifd
index|]
operator|.
name|iauxBase
argument_list|,
name|e_symbols
index|[
name|i
index|]
operator|.
name|ifd
argument_list|,
operator|&
name|file_desc
index|[
name|e_symbols
index|[
name|i
index|]
operator|.
name|ifd
index|]
argument_list|)
expr_stmt|;
comment|/*    * Print unused aux symbols now.    */
if|if
condition|(
name|want_aux
condition|)
block|{
name|int
name|first_time
init|=
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sym_hdr
operator|.
name|iauxMax
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|aux_used
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|first_time
condition|)
block|{
name|printf
argument_list|(
literal|"\nThe following auxiliary table entries were unused:\n\n"
argument_list|)
expr_stmt|;
name|first_time
operator|=
literal|0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"    #%-5d %11ld  0x%08lx  %s\n"
argument_list|,
name|i
argument_list|,
operator|(
name|long
operator|)
name|aux_symbols
index|[
name|i
index|]
operator|.
name|isym
argument_list|,
operator|(
name|long
operator|)
name|aux_symbols
index|[
name|i
index|]
operator|.
name|isym
argument_list|,
name|type_to_string
argument_list|(
name|aux_symbols
argument_list|,
name|i
argument_list|,
operator|(
name|FDR
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mips-tdump internal error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fatal
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as `malloc' but report error if no memory available.  */
end_comment

begin_function
name|PTR_T
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|PTR_T
name|value
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"Virtual memory exhausted."
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

end_unit

