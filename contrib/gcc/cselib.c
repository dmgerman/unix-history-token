begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Common subexpression elimination library for GNU compiler.    Copyright (C) 1987, 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"cselib.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|entry_and_rtx_equal_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|get_value_hash
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elt_list
modifier|*
name|new_elt_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elt_list
operator|*
operator|,
name|cselib_val
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elt_loc_list
modifier|*
name|new_elt_loc_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elt_loc_list
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unchain_one_value
name|PARAMS
argument_list|(
operator|(
name|cselib_val
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unchain_one_elt_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elt_list
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unchain_one_elt_loc_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|elt_loc_list
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_table
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|discard_useless_locs
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|discard_useless_values
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_useless_values
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|wrap_constant
name|PARAMS
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_rtx
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cselib_val
modifier|*
name|new_cselib_val
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_mem_for_addr
name|PARAMS
argument_list|(
operator|(
name|cselib_val
operator|*
operator|,
name|cselib_val
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cselib_val
modifier|*
name|cselib_lookup_mem
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cselib_invalidate_regno
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
expr|enum
name|machine_mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cselib_mem_conflict_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cselib_invalidate_mem_1
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cselib_invalidate_mem
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cselib_invalidate_rtx
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cselib_record_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|cselib_val
operator|*
operator|,
name|cselib_val
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cselib_record_sets
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* There are three ways in which cselib can look up an rtx:    - for a REG, the reg_values table (which is indexed by regno) is used    - for a MEM, we recursively look up its address and then follow the      addr_list of that value    - for everything else, we compute a hash value and go through the hash      table.  Since different rtx's can still have the same hash value,      this involves walking the table entries for a given value and comparing      the locations of the entries with the rtx we are looking up.  */
end_comment

begin_comment
comment|/* A table that enables us to look up elts by their value.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a global so we don't have to pass this through every function.    It is used in new_elt_loc_list to set SETTING_INSN.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|cselib_current_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Every new unknown value gets a unique number.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|next_unknown_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of registers we had when the varrays were last resized.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cselib_nregs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count values without known locations.  Whenever this grows too big, we    remove these useless values from the table.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_useless_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of useless values before we remove them from the hash table.  */
end_comment

begin_define
define|#
directive|define
name|MAX_USELESS_VALUES
value|32
end_define

begin_comment
comment|/* This table maps from register number to values.  It does not contain    pointers to cselib_val structures, but rather elt_lists.  The purpose is    to be able to refer to the same register in different modes.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|reg_values
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REG_VALUES
parameter_list|(
name|I
parameter_list|)
value|VARRAY_ELT_LIST (reg_values, (I))
end_define

begin_comment
comment|/* Here the set of indices I with REG_VALUES(I) != 0 is saved.  This is used    in clear_table() for fast emptying.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|used_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We pass this to cselib_invalidate_mem to invalidate all of    memory for a non-const call instruction.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|callmem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Memory for our structures is allocated from this obstack.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|cselib_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to quickly free all memory.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cselib_startobj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Caches for unused structures.  */
end_comment

begin_decl_stmt
specifier|static
name|cselib_val
modifier|*
name|empty_vals
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elt_list
modifier|*
name|empty_elt_lists
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|elt_loc_list
modifier|*
name|empty_elt_loc_lists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set by discard_useless_locs if it deleted the last location of any    value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|values_became_useless
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Allocate a struct elt_list and fill in its two elements with the    arguments.  */
end_comment

begin_function
specifier|static
name|struct
name|elt_list
modifier|*
name|new_elt_list
parameter_list|(
name|next
parameter_list|,
name|elt
parameter_list|)
name|struct
name|elt_list
modifier|*
name|next
decl_stmt|;
name|cselib_val
modifier|*
name|elt
decl_stmt|;
block|{
name|struct
name|elt_list
modifier|*
name|el
init|=
name|empty_elt_lists
decl_stmt|;
if|if
condition|(
name|el
condition|)
name|empty_elt_lists
operator|=
name|el
operator|->
name|next
expr_stmt|;
else|else
name|el
operator|=
operator|(
expr|struct
name|elt_list
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|cselib_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elt_list
argument_list|)
argument_list|)
expr_stmt|;
name|el
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|el
operator|->
name|elt
operator|=
name|elt
expr_stmt|;
return|return
name|el
return|;
block|}
end_function

begin_comment
comment|/* Allocate a struct elt_loc_list and fill in its two elements with the    arguments.  */
end_comment

begin_function
specifier|static
name|struct
name|elt_loc_list
modifier|*
name|new_elt_loc_list
parameter_list|(
name|next
parameter_list|,
name|loc
parameter_list|)
name|struct
name|elt_loc_list
modifier|*
name|next
decl_stmt|;
name|rtx
name|loc
decl_stmt|;
block|{
name|struct
name|elt_loc_list
modifier|*
name|el
init|=
name|empty_elt_loc_lists
decl_stmt|;
if|if
condition|(
name|el
condition|)
name|empty_elt_loc_lists
operator|=
name|el
operator|->
name|next
expr_stmt|;
else|else
name|el
operator|=
operator|(
expr|struct
name|elt_loc_list
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|cselib_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|elt_loc_list
argument_list|)
argument_list|)
expr_stmt|;
name|el
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|el
operator|->
name|loc
operator|=
name|loc
expr_stmt|;
name|el
operator|->
name|setting_insn
operator|=
name|cselib_current_insn
expr_stmt|;
return|return
name|el
return|;
block|}
end_function

begin_comment
comment|/* The elt_list at *PL is no longer needed.  Unchain it and free its    storage.  */
end_comment

begin_function
specifier|static
name|void
name|unchain_one_elt_list
parameter_list|(
name|pl
parameter_list|)
name|struct
name|elt_list
modifier|*
modifier|*
name|pl
decl_stmt|;
block|{
name|struct
name|elt_list
modifier|*
name|l
init|=
operator|*
name|pl
decl_stmt|;
operator|*
name|pl
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|empty_elt_lists
expr_stmt|;
name|empty_elt_lists
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise for elt_loc_lists.  */
end_comment

begin_function
specifier|static
name|void
name|unchain_one_elt_loc_list
parameter_list|(
name|pl
parameter_list|)
name|struct
name|elt_loc_list
modifier|*
modifier|*
name|pl
decl_stmt|;
block|{
name|struct
name|elt_loc_list
modifier|*
name|l
init|=
operator|*
name|pl
decl_stmt|;
operator|*
name|pl
operator|=
name|l
operator|->
name|next
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|empty_elt_loc_lists
expr_stmt|;
name|empty_elt_loc_lists
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise for cselib_vals.  This also frees the addr_list associated with    V.  */
end_comment

begin_function
specifier|static
name|void
name|unchain_one_value
parameter_list|(
name|v
parameter_list|)
name|cselib_val
modifier|*
name|v
decl_stmt|;
block|{
while|while
condition|(
name|v
operator|->
name|addr_list
condition|)
name|unchain_one_elt_list
argument_list|(
operator|&
name|v
operator|->
name|addr_list
argument_list|)
expr_stmt|;
name|v
operator|->
name|u
operator|.
name|next_free
operator|=
name|empty_vals
expr_stmt|;
name|empty_vals
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove all entries from the hash table.  Also used during    initialization.  If CLEAR_ALL isn't set, then only clear the entries    which are known to have been used.  */
end_comment

begin_function
specifier|static
name|void
name|clear_table
parameter_list|(
name|clear_all
parameter_list|)
name|int
name|clear_all
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|clear_all
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cselib_nregs
condition|;
name|i
operator|++
control|)
name|REG_VALUES
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|used_regs
argument_list|)
condition|;
name|i
operator|++
control|)
name|REG_VALUES
argument_list|(
name|VARRAY_UINT
argument_list|(
name|used_regs
argument_list|,
name|i
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|VARRAY_POP_ALL
argument_list|(
name|used_regs
argument_list|)
expr_stmt|;
name|htab_empty
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|cselib_obstack
argument_list|,
name|cselib_startobj
argument_list|)
expr_stmt|;
name|empty_vals
operator|=
literal|0
expr_stmt|;
name|empty_elt_lists
operator|=
literal|0
expr_stmt|;
name|empty_elt_loc_lists
operator|=
literal|0
expr_stmt|;
name|n_useless_values
operator|=
literal|0
expr_stmt|;
name|next_unknown_value
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The equality test for our hash table.  The first argument ENTRY is a table    element (i.e. a cselib_val), while the second arg X is an rtx.  We know    that all callers of htab_find_slot_with_hash will wrap CONST_INTs into a    CONST of an appropriate mode.  */
end_comment

begin_function
specifier|static
name|int
name|entry_and_rtx_equal_p
parameter_list|(
name|entry
parameter_list|,
name|x_arg
parameter_list|)
specifier|const
name|void
modifier|*
name|entry
decl_stmt|,
decl|*
name|x_arg
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|elt_loc_list
modifier|*
name|l
decl_stmt|;
specifier|const
name|cselib_val
modifier|*
name|v
init|=
operator|(
specifier|const
name|cselib_val
operator|*
operator|)
name|entry
decl_stmt|;
name|rtx
name|x
init|=
operator|(
name|rtx
operator|)
name|x_arg
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
operator|||
operator|(
name|mode
operator|==
name|VOIDmode
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|GET_MODE
argument_list|(
name|v
operator|->
name|u
operator|.
name|val_rtx
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Unwrap X if necessary.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We don't guarantee that distinct rtx's have different hash values,      so we need to do a comparison.  */
for|for
control|(
name|l
operator|=
name|v
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|rtx_equal_for_cselib_p
argument_list|(
name|l
operator|->
name|loc
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* The hash function for our hash table.  The value is always computed with    hash_rtx when adding an element; this function just extracts the hash    value from a cselib_val structure.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|get_value_hash
parameter_list|(
name|entry
parameter_list|)
specifier|const
name|void
modifier|*
name|entry
decl_stmt|;
block|{
specifier|const
name|cselib_val
modifier|*
name|v
init|=
operator|(
specifier|const
name|cselib_val
operator|*
operator|)
name|entry
decl_stmt|;
return|return
name|v
operator|->
name|value
return|;
block|}
end_function

begin_comment
comment|/* Return true if X contains a VALUE rtx.  If ONLY_USELESS is set, we    only return true for values which point to a cselib_val whose value    element has been set to zero, which implies the cselib_val will be    removed.  */
end_comment

begin_function
name|int
name|references_value_p
parameter_list|(
name|x
parameter_list|,
name|only_useless
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|only_useless
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VALUE
operator|&&
operator|(
operator|!
name|only_useless
operator|||
name|CSELIB_VAL_PTR
argument_list|(
name|x
argument_list|)
operator|->
name|locs
operator|==
literal|0
operator|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
operator|&&
name|references_value_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|only_useless
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|references_value_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|only_useless
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* For all locations found in X, delete locations that reference useless    values (i.e. values without any location).  Called through    htab_traverse.  */
end_comment

begin_function
specifier|static
name|int
name|discard_useless_locs
parameter_list|(
name|x
parameter_list|,
name|info
parameter_list|)
name|void
modifier|*
modifier|*
name|x
decl_stmt|;
name|void
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|cselib_val
modifier|*
name|v
init|=
operator|(
name|cselib_val
operator|*
operator|)
operator|*
name|x
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
modifier|*
name|p
init|=
operator|&
name|v
operator|->
name|locs
decl_stmt|;
name|int
name|had_locs
init|=
name|v
operator|->
name|locs
operator|!=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|references_value_p
argument_list|(
operator|(
operator|*
name|p
operator|)
operator|->
name|loc
argument_list|,
literal|1
argument_list|)
condition|)
name|unchain_one_elt_loc_list
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|had_locs
operator|&&
name|v
operator|->
name|locs
operator|==
literal|0
condition|)
block|{
name|n_useless_values
operator|++
expr_stmt|;
name|values_became_useless
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If X is a value with no locations, remove it from the hashtable.  */
end_comment

begin_function
specifier|static
name|int
name|discard_useless_values
parameter_list|(
name|x
parameter_list|,
name|info
parameter_list|)
name|void
modifier|*
modifier|*
name|x
decl_stmt|;
name|void
modifier|*
name|info
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|cselib_val
modifier|*
name|v
init|=
operator|(
name|cselib_val
operator|*
operator|)
operator|*
name|x
decl_stmt|;
if|if
condition|(
name|v
operator|->
name|locs
operator|==
literal|0
condition|)
block|{
name|htab_clear_slot
argument_list|(
name|hash_table
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|unchain_one_value
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|n_useless_values
operator|--
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Clean out useless values (i.e. those which no longer have locations    associated with them) from the hash table.  */
end_comment

begin_function
specifier|static
name|void
name|remove_useless_values
parameter_list|()
block|{
comment|/* First pass: eliminate locations that reference the value.  That in      turn can make more values useless.  */
do|do
block|{
name|values_became_useless
operator|=
literal|0
expr_stmt|;
name|htab_traverse
argument_list|(
name|hash_table
argument_list|,
name|discard_useless_locs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|values_became_useless
condition|)
do|;
comment|/* Second pass: actually remove the values.  */
name|htab_traverse
argument_list|(
name|hash_table
argument_list|,
name|discard_useless_values
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_useless_values
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if we can prove that X and Y contain the same value, taking    our gathered information into account.  */
end_comment

begin_function
name|int
name|rtx_equal_for_cselib_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|cselib_val
modifier|*
name|e
init|=
name|cselib_lookup
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
condition|)
name|x
operator|=
name|e
operator|->
name|u
operator|.
name|val_rtx
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|cselib_val
modifier|*
name|e
init|=
name|cselib_lookup
argument_list|(
name|y
argument_list|,
name|GET_MODE
argument_list|(
name|y
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
condition|)
name|y
operator|=
name|e
operator|->
name|u
operator|.
name|val_rtx
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VALUE
operator|&&
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|VALUE
condition|)
return|return
name|CSELIB_VAL_PTR
argument_list|(
name|x
argument_list|)
operator|==
name|CSELIB_VAL_PTR
argument_list|(
name|y
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VALUE
condition|)
block|{
name|cselib_val
modifier|*
name|e
init|=
name|CSELIB_VAL_PTR
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|e
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|rtx
name|t
init|=
name|l
operator|->
name|loc
decl_stmt|;
comment|/* Avoid infinite recursion.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MEM
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|rtx_equal_for_cselib_p
argument_list|(
name|t
argument_list|,
name|y
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|VALUE
condition|)
block|{
name|cselib_val
modifier|*
name|e
init|=
name|CSELIB_VAL_PTR
argument_list|(
name|y
argument_list|)
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
name|l
decl_stmt|;
for|for
control|(
name|l
operator|=
name|e
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|rtx
name|t
init|=
name|l
operator|->
name|loc
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MEM
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|rtx_equal_for_cselib_p
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* This won't be handled correctly by the code below.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|j
decl_stmt|;
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|rtx_equal_for_cselib_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|rtx_equal_for_cselib_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
case|case
literal|'t'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* We need to pass down the mode of constants through the hash table    functions.  For that purpose, wrap them in a CONST of the appropriate    mode.  */
end_comment

begin_function
specifier|static
name|rtx
name|wrap_constant
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_INT
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|CONST_DOUBLE
operator|||
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
operator|)
condition|)
return|return
name|x
return|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|gen_rtx_CONST
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hash an rtx.  Return 0 if we couldn't hash the rtx.    For registers and memory locations, we look up their cselib_val structure    and return its VALUE element.    Possible reasons for return 0 are: the object is volatile, or we couldn't    find a register or memory location in the table and CREATE is zero.  If    CREATE is nonzero, table elts are created for regs and mem.    MODE is used in hashing for CONST_INTs only;    otherwise the mode of X is used.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_rtx
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|create
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|create
decl_stmt|;
block|{
name|cselib_val
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|unsigned
name|int
name|hash
init|=
literal|0
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|MEM
case|:
case|case
name|REG
case|:
name|e
operator|=
name|cselib_lookup
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
return|return
literal|0
return|;
return|return
name|e
operator|->
name|value
return|;
case|case
name|CONST_INT
case|:
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|CONST_INT
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
operator|)
name|mode
operator|+
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|hash
condition|?
name|hash
else|:
operator|(
name|unsigned
name|int
operator|)
name|CONST_INT
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* This is like the general case, except that it only counts 	 the integers representing the constant.  */
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|CONST_DOUBLE
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash
operator|+=
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
condition|?
name|hash
else|:
operator|(
name|unsigned
name|int
operator|)
name|CONST_DOUBLE
return|;
comment|/* Assume there is only one rtx object for any given label.  */
case|case
name|LABEL_REF
case|:
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|LABEL_REF
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|hash
condition|?
name|hash
else|:
operator|(
name|unsigned
name|int
operator|)
name|LABEL_REF
return|;
case|case
name|SYMBOL_REF
case|:
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|SYMBOL_REF
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|hash
condition|?
name|hash
else|:
operator|(
name|unsigned
name|int
operator|)
name|SYMBOL_REF
return|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|POST_MODIFY
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
break|break;
block|}
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|tem_hash
init|=
name|hash_rtx
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|,
name|create
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem_hash
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|hash
operator|+=
name|tem_hash
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|int
name|tem_hash
init|=
name|hash_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
name|create
argument_list|)
decl_stmt|;
if|if
condition|(
name|tem_hash
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|hash
operator|+=
name|tem_hash
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
while|while
condition|(
operator|*
name|p
condition|)
name|hash
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
name|hash
operator|+=
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'0'
operator|||
name|fmt
index|[
name|i
index|]
operator|==
literal|'t'
condition|)
comment|/* unused */
empty_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|hash
condition|?
name|hash
else|:
literal|1
operator|+
operator|(
name|unsigned
name|int
operator|)
name|GET_CODE
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new value structure for VALUE and initialize it.  The mode of the    value is MODE.  */
end_comment

begin_function
specifier|static
name|cselib_val
modifier|*
name|new_cselib_val
parameter_list|(
name|value
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|int
name|value
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|cselib_val
modifier|*
name|e
init|=
name|empty_vals
decl_stmt|;
if|if
condition|(
name|e
condition|)
name|empty_vals
operator|=
name|e
operator|->
name|u
operator|.
name|next_free
expr_stmt|;
else|else
name|e
operator|=
operator|(
name|cselib_val
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|cselib_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|cselib_val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|e
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|e
operator|->
name|u
operator|.
name|val_rtx
operator|=
name|gen_rtx_VALUE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|CSELIB_VAL_PTR
argument_list|(
name|e
operator|->
name|u
operator|.
name|val_rtx
argument_list|)
operator|=
name|e
expr_stmt|;
name|e
operator|->
name|addr_list
operator|=
literal|0
expr_stmt|;
name|e
operator|->
name|locs
operator|=
literal|0
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* ADDR_ELT is a value that is used as address.  MEM_ELT is the value that    contains the data at this address.  X is a MEM that represents the    value.  Update the two value structures to represent this situation.  */
end_comment

begin_function
specifier|static
name|void
name|add_mem_for_addr
parameter_list|(
name|addr_elt
parameter_list|,
name|mem_elt
parameter_list|,
name|x
parameter_list|)
name|cselib_val
modifier|*
name|addr_elt
decl_stmt|,
decl|*
name|mem_elt
decl_stmt|;
end_function

begin_decl_stmt
name|rtx
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|elt_loc_list
modifier|*
name|l
decl_stmt|;
comment|/* Avoid duplicates.  */
for|for
control|(
name|l
operator|=
name|mem_elt
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|l
operator|->
name|loc
argument_list|)
operator|==
name|MEM
operator|&&
name|CSELIB_VAL_PTR
argument_list|(
name|XEXP
argument_list|(
name|l
operator|->
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|addr_elt
condition|)
return|return;
name|addr_elt
operator|->
name|addr_list
operator|=
name|new_elt_list
argument_list|(
name|addr_elt
operator|->
name|addr_list
argument_list|,
name|mem_elt
argument_list|)
expr_stmt|;
name|mem_elt
operator|->
name|locs
operator|=
name|new_elt_loc_list
argument_list|(
name|mem_elt
operator|->
name|locs
argument_list|,
name|replace_equiv_address_nv
argument_list|(
name|x
argument_list|,
name|addr_elt
operator|->
name|u
operator|.
name|val_rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Subroutine of cselib_lookup.  Return a value for X, which is a MEM rtx.    If CREATE, make a new one if we haven't seen it before.  */
end_comment

begin_function
specifier|static
name|cselib_val
modifier|*
name|cselib_lookup_mem
parameter_list|(
name|x
parameter_list|,
name|create
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|create
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|cselib_val
modifier|*
name|addr
decl_stmt|;
name|cselib_val
modifier|*
name|mem_elt
decl_stmt|;
name|struct
name|elt_list
modifier|*
name|l
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|||
name|mode
operator|==
name|BLKmode
operator|||
operator|(
name|FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
operator|&&
name|flag_float_store
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Look up the value for the address.  */
name|addr
operator|=
name|cselib_lookup
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr
condition|)
return|return
literal|0
return|;
comment|/* Find a value that describes a value of our mode at that address.  */
for|for
control|(
name|l
operator|=
name|addr
operator|->
name|addr_list
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|l
operator|->
name|elt
operator|->
name|u
operator|.
name|val_rtx
argument_list|)
operator|==
name|mode
condition|)
return|return
name|l
operator|->
name|elt
return|;
if|if
condition|(
operator|!
name|create
condition|)
return|return
literal|0
return|;
name|mem_elt
operator|=
name|new_cselib_val
argument_list|(
operator|++
name|next_unknown_value
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|add_mem_for_addr
argument_list|(
name|addr
argument_list|,
name|mem_elt
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|hash_table
argument_list|,
name|wrap_constant
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|,
name|mem_elt
operator|->
name|value
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|mem_elt
expr_stmt|;
return|return
name|mem_elt
return|;
block|}
end_function

begin_comment
comment|/* Walk rtx X and replace all occurrences of REG and MEM subexpressions    with VALUE expressions.  This way, it becomes independent of changes    to registers and memory.    X isn't actually modified; if modifications are needed, new rtl is    allocated.  However, the return value can share rtl with X.  */
end_comment

begin_function
name|rtx
name|cselib_subst_to_values
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|cselib_val
modifier|*
name|e
decl_stmt|;
name|struct
name|elt_list
modifier|*
name|l
decl_stmt|;
name|rtx
name|copy
init|=
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
for|for
control|(
name|l
operator|=
name|REG_VALUES
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|GET_MODE
argument_list|(
name|l
operator|->
name|elt
operator|->
name|u
operator|.
name|val_rtx
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|l
operator|->
name|elt
operator|->
name|u
operator|.
name|val_rtx
return|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|MEM
case|:
name|e
operator|=
name|cselib_lookup_mem
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e
condition|)
block|{
comment|/* This happens for autoincrements.  Assign a value that doesn't 	     match any other.  */
name|e
operator|=
name|new_cselib_val
argument_list|(
operator|++
name|next_unknown_value
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|e
operator|->
name|u
operator|.
name|val_rtx
return|;
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
return|return
name|x
return|;
case|case
name|POST_INC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|PRE_DEC
case|:
case|case
name|POST_MODIFY
case|:
case|case
name|PRE_MODIFY
case|:
name|e
operator|=
name|new_cselib_val
argument_list|(
operator|++
name|next_unknown_value
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|e
operator|->
name|u
operator|.
name|val_rtx
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|t
init|=
name|cselib_subst_to_values
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|&&
name|x
operator|==
name|copy
condition|)
name|copy
operator|=
name|shallow_copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|rtx
name|t
init|=
name|cselib_subst_to_values
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|&&
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|==
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|x
operator|==
name|copy
condition|)
name|copy
operator|=
name|shallow_copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
operator|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Look up the rtl expression X in our tables and return the value it has.    If CREATE is zero, we return NULL if we don't know the value.  Otherwise,    we create a new one if possible, using mode MODE if X doesn't have a mode    (i.e. because it's a constant).  */
end_comment

begin_function
name|cselib_val
modifier|*
name|cselib_lookup
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|create
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|create
decl_stmt|;
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|cselib_val
modifier|*
name|e
decl_stmt|;
name|unsigned
name|int
name|hashval
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VALUE
condition|)
return|return
name|CSELIB_VAL_PTR
argument_list|(
name|x
argument_list|)
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
name|struct
name|elt_list
modifier|*
name|l
decl_stmt|;
name|unsigned
name|int
name|i
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
for|for
control|(
name|l
operator|=
name|REG_VALUES
argument_list|(
name|i
argument_list|)
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
name|mode
operator|==
name|GET_MODE
argument_list|(
name|l
operator|->
name|elt
operator|->
name|u
operator|.
name|val_rtx
argument_list|)
condition|)
return|return
name|l
operator|->
name|elt
return|;
if|if
condition|(
operator|!
name|create
condition|)
return|return
literal|0
return|;
name|e
operator|=
name|new_cselib_val
argument_list|(
operator|++
name|next_unknown_value
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|locs
operator|=
name|new_elt_loc_list
argument_list|(
name|e
operator|->
name|locs
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_VALUES
argument_list|(
name|i
argument_list|)
operator|==
literal|0
condition|)
name|VARRAY_PUSH_UINT
argument_list|(
name|used_regs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|REG_VALUES
argument_list|(
name|i
argument_list|)
operator|=
name|new_elt_list
argument_list|(
name|REG_VALUES
argument_list|(
name|i
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|hash_table
argument_list|,
name|x
argument_list|,
name|e
operator|->
name|value
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|e
expr_stmt|;
return|return
name|e
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|cselib_lookup_mem
argument_list|(
name|x
argument_list|,
name|create
argument_list|)
return|;
name|hashval
operator|=
name|hash_rtx
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|create
argument_list|)
expr_stmt|;
comment|/* Can't even create if hashing is not possible.  */
if|if
condition|(
operator|!
name|hashval
condition|)
return|return
literal|0
return|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|hash_table
argument_list|,
name|wrap_constant
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
argument_list|,
name|hashval
argument_list|,
name|create
condition|?
name|INSERT
else|:
name|NO_INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|e
operator|=
operator|(
name|cselib_val
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
if|if
condition|(
name|e
condition|)
return|return
name|e
return|;
name|e
operator|=
name|new_cselib_val
argument_list|(
name|hashval
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* We have to fill the slot before calling cselib_subst_to_values:      the hash table is inconsistent until we do so, and      cselib_subst_to_values will need to do lookups.  */
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|e
expr_stmt|;
name|e
operator|->
name|locs
operator|=
name|new_elt_loc_list
argument_list|(
name|e
operator|->
name|locs
argument_list|,
name|cselib_subst_to_values
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Invalidate any entries in reg_values that overlap REGNO.  This is called    if REGNO is changing.  MODE is the mode of the assignment to REGNO, which    is used to determine how many hard registers are being changed.  If MODE    is VOIDmode, then only REGNO is being changed; this is used when    invalidating call clobbered registers across a call.  */
end_comment

begin_function
specifier|static
name|void
name|cselib_invalidate_regno
parameter_list|(
name|regno
parameter_list|,
name|mode
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|int
name|endregno
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* If we see pseudos after reload, something is _wrong_.  */
if|if
condition|(
name|reload_completed
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|reg_renumber
index|[
name|regno
index|]
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Determine the range of registers that must be invalidated.  For      pseudos, only REGNO is affected.  For hard regs, we must take MODE      into account, and we must also invalidate lower register numbers      if they contain values that overlap REGNO.  */
name|endregno
operator|=
name|regno
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|mode
operator|!=
name|VOIDmode
condition|)
name|endregno
operator|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|elt_list
modifier|*
modifier|*
name|l
init|=
operator|&
name|REG_VALUES
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* Go through all known values for this reg; if it overlaps the range 	 we're invalidating, remove the value.  */
while|while
condition|(
operator|*
name|l
condition|)
block|{
name|cselib_val
modifier|*
name|v
init|=
operator|(
operator|*
name|l
operator|)
operator|->
name|elt
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|this_last
init|=
name|i
decl_stmt|;
if|if
condition|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|this_last
operator|+=
name|HARD_REGNO_NREGS
argument_list|(
name|i
argument_list|,
name|GET_MODE
argument_list|(
name|v
operator|->
name|u
operator|.
name|val_rtx
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|this_last
operator|<
name|regno
condition|)
block|{
name|l
operator|=
operator|&
operator|(
operator|*
name|l
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* We have an overlap.  */
name|unchain_one_elt_list
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* Now, we clear the mapping from value to reg.  It must exist, so 	     this code will crash intentionally if it doesn't.  */
for|for
control|(
name|p
operator|=
operator|&
name|v
operator|->
name|locs
init|;
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
block|{
name|rtx
name|x
init|=
operator|(
operator|*
name|p
operator|)
operator|->
name|loc
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|i
condition|)
block|{
name|unchain_one_elt_loc_list
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|v
operator|->
name|locs
operator|==
literal|0
condition|)
name|n_useless_values
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The memory at address MEM_BASE is being changed.    Return whether this change will invalidate VAL.  */
end_comment

begin_function
specifier|static
name|int
name|cselib_mem_conflict_p
parameter_list|(
name|mem_base
parameter_list|,
name|val
parameter_list|)
name|rtx
name|mem_base
decl_stmt|;
name|rtx
name|val
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
comment|/* Get rid of a few simple cases quickly.  */
case|case
name|REG
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SCRATCH
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
return|return
literal|0
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem_base
argument_list|)
operator|==
name|BLKmode
operator|||
name|GET_MODE
argument_list|(
name|val
argument_list|)
operator|==
name|BLKmode
operator|||
name|anti_dependence
argument_list|(
name|val
argument_list|,
name|mem_base
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The address may contain nested MEMs.  */
break|break;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|cselib_mem_conflict_p
argument_list|(
name|mem_base
argument_list|,
name|XEXP
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|val
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|cselib_mem_conflict_p
argument_list|(
name|mem_base
argument_list|,
name|XVECEXP
argument_list|(
name|val
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* For the value found in SLOT, walk its locations to determine if any overlap    INFO (which is a MEM rtx).  */
end_comment

begin_function
specifier|static
name|int
name|cselib_invalidate_mem_1
parameter_list|(
name|slot
parameter_list|,
name|info
parameter_list|)
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|void
modifier|*
name|info
decl_stmt|;
block|{
name|cselib_val
modifier|*
name|v
init|=
operator|(
name|cselib_val
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|rtx
name|mem_rtx
init|=
operator|(
name|rtx
operator|)
name|info
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
modifier|*
name|p
init|=
operator|&
name|v
operator|->
name|locs
decl_stmt|;
name|int
name|had_locs
init|=
name|v
operator|->
name|locs
operator|!=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|rtx
name|x
init|=
operator|(
operator|*
name|p
operator|)
operator|->
name|loc
decl_stmt|;
name|cselib_val
modifier|*
name|addr
decl_stmt|;
name|struct
name|elt_list
modifier|*
modifier|*
name|mem_chain
decl_stmt|;
comment|/* MEMs may occur in locations only at the top level; below 	 that every MEM or REG is substituted by its VALUE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|cselib_mem_conflict_p
argument_list|(
name|mem_rtx
argument_list|,
name|x
argument_list|)
condition|)
block|{
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* This one overlaps.  */
comment|/* We must have a mapping from this MEM's address to the 	 value (E).  Remove that, too.  */
name|addr
operator|=
name|cselib_lookup
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem_chain
operator|=
operator|&
name|addr
operator|->
name|addr_list
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|mem_chain
operator|)
operator|->
name|elt
operator|==
name|v
condition|)
block|{
name|unchain_one_elt_list
argument_list|(
name|mem_chain
argument_list|)
expr_stmt|;
break|break;
block|}
name|mem_chain
operator|=
operator|&
operator|(
operator|*
name|mem_chain
operator|)
operator|->
name|next
expr_stmt|;
block|}
name|unchain_one_elt_loc_list
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|had_locs
operator|&&
name|v
operator|->
name|locs
operator|==
literal|0
condition|)
name|n_useless_values
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Invalidate any locations in the table which are changed because of a    store to MEM_RTX.  If this is called because of a non-const call    instruction, MEM_RTX is (mem:BLK const0_rtx).  */
end_comment

begin_function
specifier|static
name|void
name|cselib_invalidate_mem
parameter_list|(
name|mem_rtx
parameter_list|)
name|rtx
name|mem_rtx
decl_stmt|;
block|{
name|htab_traverse
argument_list|(
name|hash_table
argument_list|,
name|cselib_invalidate_mem_1
argument_list|,
name|mem_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Invalidate DEST, which is being assigned to or clobbered.  The second and    the third parameter exist so that this function can be passed to    note_stores; they are ignored.  */
end_comment

begin_function
specifier|static
name|void
name|cselib_invalidate_rtx
parameter_list|(
name|dest
parameter_list|,
name|ignore
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|rtx
name|ignore
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|cselib_invalidate_regno
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|cselib_invalidate_mem
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* Some machines don't define AUTO_INC_DEC, but they still use push      instructions.  We need to catch that case here in order to      invalidate the stack pointer correctly.  Note that invalidating      the stack pointer is different from invalidating DEST.  */
if|if
condition|(
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
name|cselib_invalidate_rtx
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the result of a SET instruction.  DEST is being set; the source    contains the value described by SRC_ELT.  If DEST is a MEM, DEST_ADDR_ELT    describes its address.  */
end_comment

begin_function
specifier|static
name|void
name|cselib_record_set
parameter_list|(
name|dest
parameter_list|,
name|src_elt
parameter_list|,
name|dest_addr_elt
parameter_list|)
name|rtx
name|dest
decl_stmt|;
name|cselib_val
modifier|*
name|src_elt
decl_stmt|,
decl|*
name|dest_addr_elt
decl_stmt|;
end_function

begin_block
block|{
name|int
name|dreg
init|=
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|?
operator|(
name|int
operator|)
name|REGNO
argument_list|(
name|dest
argument_list|)
else|:
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|src_elt
operator|==
literal|0
operator|||
name|side_effects_p
argument_list|(
name|dest
argument_list|)
condition|)
return|return;
if|if
condition|(
name|dreg
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|REG_VALUES
argument_list|(
name|dreg
argument_list|)
operator|==
literal|0
condition|)
name|VARRAY_PUSH_UINT
argument_list|(
name|used_regs
argument_list|,
name|dreg
argument_list|)
expr_stmt|;
name|REG_VALUES
argument_list|(
name|dreg
argument_list|)
operator|=
name|new_elt_list
argument_list|(
name|REG_VALUES
argument_list|(
name|dreg
argument_list|)
argument_list|,
name|src_elt
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_elt
operator|->
name|locs
operator|==
literal|0
condition|)
name|n_useless_values
operator|--
expr_stmt|;
name|src_elt
operator|->
name|locs
operator|=
name|new_elt_loc_list
argument_list|(
name|src_elt
operator|->
name|locs
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|dest_addr_elt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|src_elt
operator|->
name|locs
operator|==
literal|0
condition|)
name|n_useless_values
operator|--
expr_stmt|;
name|add_mem_for_addr
argument_list|(
name|dest_addr_elt
argument_list|,
name|src_elt
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Describe a single set that is part of an insn.  */
end_comment

begin_struct
struct|struct
name|set
block|{
name|rtx
name|src
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
name|cselib_val
modifier|*
name|src_elt
decl_stmt|;
name|cselib_val
modifier|*
name|dest_addr_elt
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* There is no good way to determine how many elements there can be    in a PARALLEL.  Since it's fairly cheap, use a really large number.  */
end_comment

begin_define
define|#
directive|define
name|MAX_SETS
value|(FIRST_PSEUDO_REGISTER * 2)
end_define

begin_comment
comment|/* Record the effects of any sets in INSN.  */
end_comment

begin_function
specifier|static
name|void
name|cselib_record_sets
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|n_sets
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|set
name|sets
index|[
name|MAX_SETS
index|]
decl_stmt|;
name|rtx
name|body
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|cond
init|=
literal|0
decl_stmt|;
name|body
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|COND_EXEC
condition|)
block|{
name|cond
operator|=
name|COND_EXEC_TEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|body
operator|=
name|COND_EXEC_CODE
argument_list|(
name|body
argument_list|)
expr_stmt|;
block|}
comment|/* Find all sets.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|SET
condition|)
block|{
name|sets
index|[
literal|0
index|]
operator|.
name|src
operator|=
name|SET_SRC
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|sets
index|[
literal|0
index|]
operator|.
name|dest
operator|=
name|SET_DEST
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|n_sets
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* Look through the PARALLEL and record the values being 	 set, if possible.  Also handle any CLOBBERs.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|body
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|body
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
name|sets
index|[
name|n_sets
index|]
operator|.
name|src
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sets
index|[
name|n_sets
index|]
operator|.
name|dest
operator|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|n_sets
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Look up the values that are read.  Do this before invalidating the      locations that are written.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|dest
init|=
name|sets
index|[
name|i
index|]
operator|.
name|dest
decl_stmt|;
comment|/* A STRICT_LOW_PART can be ignored; we'll record the equivalence for          the low part after invalidating any knowledge about larger modes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|sets
index|[
name|i
index|]
operator|.
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|dest
operator|=
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We don't know how to record anything but REG or MEM.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|src
init|=
name|sets
index|[
name|i
index|]
operator|.
name|src
decl_stmt|;
if|if
condition|(
name|cond
condition|)
name|src
operator|=
name|gen_rtx_IF_THEN_ELSE
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|cond
argument_list|,
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
operator|=
name|cselib_lookup
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|sets
index|[
name|i
index|]
operator|.
name|dest_addr_elt
operator|=
name|cselib_lookup
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
name|Pmode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|sets
index|[
name|i
index|]
operator|.
name|dest_addr_elt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Invalidate all locations written by this insn.  Note that the elts we      looked up in the previous loop aren't affected, just some of their      locations may go away.  */
name|note_stores
argument_list|(
name|body
argument_list|,
name|cselib_invalidate_rtx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now enter the equivalences in our tables.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_sets
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|dest
init|=
name|sets
index|[
name|i
index|]
operator|.
name|dest
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|cselib_record_set
argument_list|(
name|dest
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|src_elt
argument_list|,
name|sets
index|[
name|i
index|]
operator|.
name|dest_addr_elt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record the effects of INSN.  */
end_comment

begin_function
name|void
name|cselib_process_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|cselib_current_insn
operator|=
name|insn
expr_stmt|;
comment|/* Forget everything at a CODE_LABEL, a volatile asm, or a setjmp.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|clear_table
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|cselib_current_insn
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* If this is a call instruction, forget anything stored in a      call clobbered register, or, if this is not a const call, in      memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
condition|)
name|cselib_invalidate_regno
argument_list|(
name|i
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|cselib_invalidate_mem
argument_list|(
name|callmem
argument_list|)
expr_stmt|;
block|}
name|cselib_record_sets
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Clobber any registers which appear in REG_INC notes.  We      could keep track of the changes to their values, but it is      unlikely to help.  */
for|for
control|(
name|x
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|x
argument_list|)
operator|==
name|REG_INC
condition|)
name|cselib_invalidate_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only      after we have processed the insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
for|for
control|(
name|x
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|cselib_invalidate_rtx
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cselib_current_insn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n_useless_values
operator|>
name|MAX_USELESS_VALUES
condition|)
name|remove_useless_values
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure our varrays are big enough.  Not called from any cselib routines;    it must be called by the user if it allocated new registers.  */
end_comment

begin_function
name|void
name|cselib_update_varray_sizes
parameter_list|()
block|{
name|unsigned
name|int
name|nregs
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
if|if
condition|(
name|nregs
operator|==
name|cselib_nregs
condition|)
return|return;
name|cselib_nregs
operator|=
name|nregs
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|reg_values
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|used_regs
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize cselib for one pass.  The caller must also call    init_alias_analysis.  */
end_comment

begin_function
name|void
name|cselib_init
parameter_list|()
block|{
comment|/* These are only created once.  */
if|if
condition|(
operator|!
name|callmem
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|cselib_obstack
argument_list|)
expr_stmt|;
name|cselib_startobj
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|cselib_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callmem
operator|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|callmem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|cselib_nregs
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|VARRAY_ELT_LIST_INIT
argument_list|(
name|reg_values
argument_list|,
name|cselib_nregs
argument_list|,
literal|"reg_values"
argument_list|)
expr_stmt|;
name|VARRAY_UINT_INIT
argument_list|(
name|used_regs
argument_list|,
name|cselib_nregs
argument_list|,
literal|"used_regs"
argument_list|)
expr_stmt|;
name|hash_table
operator|=
name|htab_create
argument_list|(
literal|31
argument_list|,
name|get_value_hash
argument_list|,
name|entry_and_rtx_equal_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|clear_table
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when the current user is done with cselib.  */
end_comment

begin_function
name|void
name|cselib_finish
parameter_list|()
block|{
name|clear_table
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|reg_values
argument_list|)
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|used_regs
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|hash_table
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

