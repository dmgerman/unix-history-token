begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RTL utility routines.    Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001, 2002,    2003 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Indexed by rtx code, gives number of operands for an rtx with that code.    Does NOT include rtx header data (code and links).  */
end_comment

begin_define
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|sizeof FORMAT - 1 ,
end_define

begin_decl_stmt
specifier|const
name|unsigned
name|char
name|rtx_length
index|[
name|NUM_RTX_CODE
index|]
init|=
block|{
include|#
directive|include
file|"rtl.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_RTL_EXPR
end_undef

begin_comment
comment|/* Indexed by rtx code, gives the name of that kind of rtx, as a C string.  */
end_comment

begin_define
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|NAME ,
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|rtx_name
index|[
name|NUM_RTX_CODE
index|]
init|=
block|{
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_RTL_EXPR
end_undef

begin_comment
comment|/* Indexed by rtx code, gives a sequence of operand-types for    rtx's of that code.  The sequence is a C string in which    each character describes one operand.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|rtx_format
index|[
name|NUM_RTX_CODE
index|]
init|=
block|{
comment|/* "*" undefined.          can cause a warning message      "0" field is unused (or used in a phase-dependent manner)          prints nothing      "i" an integer          prints the integer      "n" like "i", but prints entries from `note_insn_name'      "w" an integer of width HOST_BITS_PER_WIDE_INT          prints the integer      "s" a pointer to a string          prints the string      "S" like "s", but optional: 	 the containing rtx may end before this operand      "T" like "s", but treated specially by the RTL reader;          only found in machine description patterns.      "e" a pointer to an rtl expression          prints the expression      "E" a pointer to a vector that points to a number of rtl expressions          prints a list of the rtl expressions      "V" like "E", but optional: 	 the containing rtx may end before this operand      "u" a pointer to another insn          prints the uid of the insn.      "b" is a pointer to a bitmap header.      "B" is a basic block pointer.      "t" is a tree pointer.  */
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|FORMAT ,
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are defined here */
undef|#
directive|undef
name|DEF_RTL_EXPR
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by rtx code, gives a character representing the "class" of    that rtx code.  See rtl.def for documentation on the defined classes.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|rtx_class
index|[
name|NUM_RTX_CODE
index|]
init|=
block|{
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|CLASS,
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are defined here */
undef|#
directive|undef
name|DEF_RTL_EXPR
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by rtx code, gives the size of the rtx in bytes.  */
end_comment

begin_decl_stmt
specifier|const
name|unsigned
name|char
name|rtx_size
index|[
name|NUM_RTX_CODE
index|]
init|=
block|{
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
define|\
value|((ENUM) == CONST_INT || (ENUM) == CONST_DOUBLE			\    ? RTX_HDR_SIZE + (sizeof FORMAT - 1) * sizeof (HOST_WIDE_INT)	\    : RTX_HDR_SIZE + (sizeof FORMAT - 1) * sizeof (rtunion)),
include|#
directive|include
file|"rtl.def"
undef|#
directive|undef
name|DEF_RTL_EXPR
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names for kinds of NOTEs and REG_NOTEs.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|note_insn_name
index|[
name|NOTE_INSN_MAX
operator|-
name|NOTE_INSN_BIAS
index|]
init|=
block|{
literal|""
block|,
literal|"NOTE_INSN_DELETED"
block|,
literal|"NOTE_INSN_BLOCK_BEG"
block|,
literal|"NOTE_INSN_BLOCK_END"
block|,
literal|"NOTE_INSN_LOOP_BEG"
block|,
literal|"NOTE_INSN_LOOP_END"
block|,
literal|"NOTE_INSN_LOOP_CONT"
block|,
literal|"NOTE_INSN_LOOP_VTOP"
block|,
literal|"NOTE_INSN_LOOP_END_TOP_COND"
block|,
literal|"NOTE_INSN_FUNCTION_END"
block|,
literal|"NOTE_INSN_PROLOGUE_END"
block|,
literal|"NOTE_INSN_EPILOGUE_BEG"
block|,
literal|"NOTE_INSN_DELETED_LABEL"
block|,
literal|"NOTE_INSN_FUNCTION_BEG"
block|,
literal|"NOTE_INSN_EH_REGION_BEG"
block|,
literal|"NOTE_INSN_EH_REGION_END"
block|,
literal|"NOTE_INSN_REPEATED_LINE_NUMBER"
block|,
literal|"NOTE_INSN_BASIC_BLOCK"
block|,
literal|"NOTE_INSN_EXPECTED_VALUE"
block|,
literal|"NOTE_INSN_PREDICTION"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|reg_note_name
index|[]
init|=
block|{
literal|""
block|,
literal|"REG_DEAD"
block|,
literal|"REG_INC"
block|,
literal|"REG_EQUIV"
block|,
literal|"REG_EQUAL"
block|,
literal|"REG_RETVAL"
block|,
literal|"REG_LIBCALL"
block|,
literal|"REG_NONNEG"
block|,
literal|"REG_NO_CONFLICT"
block|,
literal|"REG_UNUSED"
block|,
literal|"REG_CC_SETTER"
block|,
literal|"REG_CC_USER"
block|,
literal|"REG_LABEL"
block|,
literal|"REG_DEP_ANTI"
block|,
literal|"REG_DEP_OUTPUT"
block|,
literal|"REG_BR_PROB"
block|,
literal|"REG_VALUE_PROFILE"
block|,
literal|"REG_NOALIAS"
block|,
literal|"REG_SAVE_AREA"
block|,
literal|"REG_BR_PRED"
block|,
literal|"REG_FRAME_RELATED_EXPR"
block|,
literal|"REG_EH_CONTEXT"
block|,
literal|"REG_EH_REGION"
block|,
literal|"REG_SAVE_NOTE"
block|,
literal|"REG_MAYBE_DEAD"
block|,
literal|"REG_NORETURN"
block|,
literal|"REG_NON_LOCAL_GOTO"
block|,
literal|"REG_SETJMP"
block|,
literal|"REG_ALWAYS_RETURN"
block|,
literal|"REG_VTABLE_REF"
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|rtx_alloc_counts
index|[
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtx_alloc_sizes
index|[
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_RTX_CODE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtvec_alloc_counts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtvec_alloc_sizes
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Allocate an rtx vector of N elements.    Store the length, and initialize all elements to zero.  */
end_comment

begin_function
name|rtvec
name|rtvec_alloc
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|rtvec
name|rt
decl_stmt|;
name|rt
operator|=
name|ggc_alloc_rtvec
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* clear out the vector */
name|memset
argument_list|(
operator|&
name|rt
operator|->
name|elem
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_NUM_ELEM
argument_list|(
name|rt
argument_list|,
name|n
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|rtvec_alloc_counts
operator|++
expr_stmt|;
name|rtvec_alloc_sizes
operator|+=
name|n
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/* Allocate an rtx of code CODE.  The CODE is stored in the rtx;    all the rest is initialized to zero.  */
end_comment

begin_function
name|rtx
name|rtx_alloc
parameter_list|(
name|RTX_CODE
name|code
parameter_list|)
block|{
name|rtx
name|rt
decl_stmt|;
name|rt
operator|=
name|ggc_alloc_rtx
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* We want to clear everything up to the FLD array.  Normally, this      is one int, but we don't want to assume that and it isn't very      portable anyway; this is.  */
name|memset
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|,
name|RTX_HDR_SIZE
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|rt
argument_list|,
name|code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|rtx_alloc_counts
index|[
name|code
index|]
operator|++
expr_stmt|;
name|rtx_alloc_sizes
index|[
name|code
index|]
operator|+=
name|RTX_SIZE
argument_list|(
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rt
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new copy of an rtx.    Recursively copies the operands of the rtx,    except for those few rtx codes that are sharable.  */
end_comment

begin_function
name|rtx
name|copy_rtx
parameter_list|(
name|rtx
name|orig
parameter_list|)
block|{
name|rtx
name|copy
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SCRATCH
case|:
comment|/* SCRATCH must be shared because they represent distinct values.  */
case|case
name|ADDRESSOF
case|:
return|return
name|orig
return|;
case|case
name|CONST
case|:
comment|/* CONST can be shared if it contains a SYMBOL_REF.  If it contains 	 a LABEL_REF, it isn't sharable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|orig
return|;
break|break;
comment|/* A MEM with a constant address is not sharable.  The problem is that 	 the constant address may need to be reloaded.  If the mem is shared, 	 then reloading one copy of this mem will cause all copies to appear 	 to have been reloaded.  */
default|default:
break|break;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Copy the various flags, and other information.  We assume that      all fields need copying, and then clear the fields that should      not be copied.  That is the sensible default behavior, and forces      us to explicitly document why we are *not* copying a flag.  */
name|memcpy
argument_list|(
name|copy
argument_list|,
name|orig
argument_list|,
name|RTX_HDR_SIZE
argument_list|)
expr_stmt|;
comment|/* We do not copy the USED flag, which is used as a mark bit during      walks over the RTL.  */
name|RTX_FLAG
argument_list|(
name|copy
argument_list|,
name|used
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We do not copy FRAME_RELATED for INSNs.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
name|RTX_FLAG
argument_list|(
name|copy
argument_list|,
name|frame_related
argument_list|)
operator|=
literal|0
expr_stmt|;
name|RTX_FLAG
argument_list|(
name|copy
argument_list|,
name|jump
argument_list|)
operator|=
name|RTX_FLAG
argument_list|(
name|orig
argument_list|,
name|jump
argument_list|)
expr_stmt|;
name|RTX_FLAG
argument_list|(
name|copy
argument_list|,
name|call
argument_list|)
operator|=
name|RTX_FLAG
argument_list|(
name|orig
argument_list|,
name|call
argument_list|)
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|copy
operator|->
name|u
operator|.
name|fld
index|[
name|i
index|]
operator|=
name|orig
operator|->
name|u
operator|.
name|fld
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
case|case
literal|'w'
case|:
case|case
literal|'i'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'u'
case|:
case|case
literal|'B'
case|:
case|case
literal|'0'
case|:
comment|/* These are left unchanged.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Create a new copy of an rtx.  Only copy just one level.  */
end_comment

begin_function
name|rtx
name|shallow_copy_rtx
parameter_list|(
name|rtx
name|orig
parameter_list|)
block|{
name|rtx
name|copy
decl_stmt|;
name|copy
operator|=
name|ggc_alloc_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|orig
argument_list|,
name|RTX_SIZE
argument_list|(
name|GET_CODE
argument_list|(
name|orig
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is 1 until after the rtl generation pass.  */
end_comment

begin_decl_stmt
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when we are generating CONCATs.  */
end_comment

begin_decl_stmt
name|int
name|generating_concat_p
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.    This is the Lisp function EQUAL for rtx arguments.  */
end_comment

begin_function
name|int
name|rtx_equal_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Some RTL can be compared nonrecursively.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
comment|/* Until rtl generation is complete, don't consider a reference 	 to the return register of the current function the same as 	 the return from a called function.  This eases the job of 	 function integration.  Once the distinction is no longer 	 needed, they can be considered equivalent.  */
return|return
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|&&
operator|(
operator|!
name|rtx_equal_function_value_matters
operator|||
name|REG_FUNCTION_VALUE_P
argument_list|(
name|x
argument_list|)
operator|==
name|REG_FUNCTION_VALUE_P
argument_list|(
name|y
argument_list|)
operator|)
operator|)
return|;
case|case
name|LABEL_REF
case|:
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SCRATCH
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_VECTOR
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole thing.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|||
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|||
operator|!
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
operator|||
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
case|case
literal|'t'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|dump_rtx_statistics
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|int
name|i
decl_stmt|;
name|int
name|total_counts
init|=
literal|0
decl_stmt|;
name|int
name|total_sizes
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nRTX Kind               Count      Bytes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"---------------------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LAST_AND_UNUSED_RTX_CODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rtx_alloc_counts
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s %7d %10d\n"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|i
argument_list|)
argument_list|,
name|rtx_alloc_counts
index|[
name|i
index|]
argument_list|,
name|rtx_alloc_sizes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|total_counts
operator|+=
name|rtx_alloc_counts
index|[
name|i
index|]
expr_stmt|;
name|total_sizes
operator|+=
name|rtx_alloc_sizes
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|rtvec_alloc_counts
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s %7d %10d\n"
argument_list|,
literal|"rtvec"
argument_list|,
name|rtvec_alloc_counts
argument_list|,
name|rtvec_alloc_sizes
argument_list|)
expr_stmt|;
name|total_counts
operator|+=
name|rtvec_alloc_counts
expr_stmt|;
name|total_sizes
operator|+=
name|rtvec_alloc_sizes
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"---------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-20s %7d %10d\n"
argument_list|,
literal|"Total"
argument_list|,
name|total_counts
argument_list|,
name|total_sizes
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"---------------------------------------\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
name|ENABLE_RTL_CHECKING
operator|&&
operator|(
name|GCC_VERSION
operator|>=
literal|2007
operator|)
end_if

begin_function
name|void
name|rtl_check_failed_bounds
parameter_list|(
name|rtx
name|r
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"RTL check: access of elt %d of `%s' with last elt %d in %s, at %s:%d"
argument_list|,
name|n
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtl_check_failed_type1
parameter_list|(
name|rtx
name|r
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|c1
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"RTL check: expected elt %d type '%c', have '%c' (rtx %s) in %s, at %s:%d"
argument_list|,
name|n
argument_list|,
name|c1
argument_list|,
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
index|[
name|n
index|]
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtl_check_failed_type2
parameter_list|(
name|rtx
name|r
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|c1
parameter_list|,
name|int
name|c2
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"RTL check: expected elt %d type '%c' or '%c', have '%c' (rtx %s) in %s, at %s:%d"
argument_list|,
name|n
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|,
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
index|[
name|n
index|]
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtl_check_failed_code1
parameter_list|(
name|rtx
name|r
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"RTL check: expected code `%s', have `%s' in %s, at %s:%d"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtl_check_failed_code2
parameter_list|(
name|rtx
name|r
parameter_list|,
name|enum
name|rtx_code
name|code1
parameter_list|,
name|enum
name|rtx_code
name|code2
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"RTL check: expected code `%s' or `%s', have `%s' in %s, at %s:%d"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|code1
argument_list|)
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|code2
argument_list|)
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX Maybe print the vector?  */
end_comment

begin_function
name|void
name|rtvec_check_failed_bounds
parameter_list|(
name|rtvec
name|r
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"RTL check: access of elt %d of vector with last elt %d in %s, at %s:%d"
argument_list|,
name|n
argument_list|,
name|GET_NUM_ELEM
argument_list|(
name|r
argument_list|)
operator|-
literal|1
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_RTL_CHECKING */
end_comment

begin_if
if|#
directive|if
name|defined
name|ENABLE_RTL_FLAG_CHECKING
end_if

begin_function
name|void
name|rtl_check_failed_flag
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|rtx
name|r
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|internal_error
argument_list|(
literal|"RTL flag check: %s used with unexpected rtx code `%s' in %s, at %s:%d"
argument_list|,
name|name
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_RTL_FLAG_CHECKING */
end_comment

end_unit

