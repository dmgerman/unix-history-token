begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Allocate and read RTL for GNU C Compiler.    Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Obstack used for allocating RTL objects.    Between functions, this is the permanent_obstack.    While parsing and expanding a function, this is maybepermanent_obstack    so we can save it if it is an inline function.    During optimization and output, this is function_obstack.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|rtl_obstack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Indexed by rtx code, gives number of operands for an rtx with that code.    Does NOT include rtx header data (code and links).    This array is initialized in init_rtl.  */
end_comment

begin_decl_stmt
name|int
name|rtx_length
index|[
name|NUM_RTX_CODE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by rtx code, gives the name of that kind of rtx, as a C string.  */
end_comment

begin_define
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|NAME ,
end_define

begin_decl_stmt
name|char
modifier|*
name|rtx_name
index|[]
init|=
block|{
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_RTL_EXPR
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the name of that machine mode.    This name does not include the letters "mode".  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
name|char
modifier|*
name|mode_name
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
operator|+
literal|1
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
ifdef|#
directive|ifdef
name|EXTRA_CC_MODES
name|EXTRA_CC_NAMES
block|,
endif|#
directive|endif
comment|/* Add an extra field to avoid a core dump if someone tries to convert      MAX_MACHINE_MODE to a string.   */
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the length of the mode, in bytes.    GET_MODE_CLASS uses this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
value|CLASS,
end_define

begin_decl_stmt
name|enum
name|mode_class
name|mode_class
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the length of the mode, in bytes.    GET_MODE_SIZE uses this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
value|SIZE,
end_define

begin_decl_stmt
name|int
name|mode_size
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the length of the mode's subunit.    GET_MODE_UNIT_SIZE uses this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
value|UNIT,
end_define

begin_decl_stmt
name|int
name|mode_unit_size
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
comment|/* machine modes are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives next wider natural mode    (QI -> HI -> SI -> DI, etc.)  Widening multiply instructions    use this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
define|\
value|(unsigned char) WIDER,
end_define

begin_decl_stmt
name|unsigned
name|char
name|mode_wider_mode
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
comment|/* machine modes are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
define|\
value|((SIZE) * BITS_PER_UNIT>= HOST_BITS_PER_WIDE_INT) ? ~(unsigned HOST_WIDE_INT)0 : ((unsigned HOST_WIDE_INT) 1<< (SIZE) * BITS_PER_UNIT) - 1,
end_define

begin_comment
comment|/* Indexed by machine mode, gives mask of significant bits in mode.  */
end_comment

begin_decl_stmt
name|unsigned
name|HOST_WIDE_INT
name|mode_mask_array
index|[
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by mode class, gives the narrowest mode for each class.  */
end_comment

begin_decl_stmt
name|enum
name|machine_mode
name|class_narrowest_mode
index|[
operator|(
name|int
operator|)
name|MAX_MODE_CLASS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by rtx code, gives a sequence of operand-types for    rtx's of that code.  The sequence is a C string in which    each character describes one operand.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rtx_format
index|[]
init|=
block|{
comment|/* "*" undefined.          can cause a warning message      "0" field is unused (or used in a phase-dependent manner)          prints nothing      "i" an integer          prints the integer      "n" like "i", but prints entries from `note_insn_name'      "w" an integer of width HOST_BITS_PER_WIDE_INT          prints the integer      "s" a pointer to a string          prints the string      "S" like "s", but optional: 	 the containing rtx may end before this operand      "e" a pointer to an rtl expression          prints the expression      "E" a pointer to a vector that points to a number of rtl expressions          prints a list of the rtl expressions      "V" like "E", but optional: 	 the containing rtx may end before this operand      "u" a pointer to another insn          prints the uid of the insn.      "b" is a pointer to a bitmap header.      "t" is a tree pointer. */
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|FORMAT ,
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are defined here */
undef|#
directive|undef
name|DEF_RTL_EXPR
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by rtx code, gives a character representing the "class" of    that rtx code.  See rtl.def for documentation on the defined classes.  */
end_comment

begin_decl_stmt
name|char
name|rtx_class
index|[]
init|=
block|{
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|CLASS,
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are defined here */
undef|#
directive|undef
name|DEF_RTL_EXPR
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names for kinds of NOTEs and REG_NOTEs.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|note_insn_name
index|[]
init|=
block|{
literal|0
block|,
literal|"NOTE_INSN_DELETED"
block|,
literal|"NOTE_INSN_BLOCK_BEG"
block|,
literal|"NOTE_INSN_BLOCK_END"
block|,
literal|"NOTE_INSN_LOOP_BEG"
block|,
literal|"NOTE_INSN_LOOP_END"
block|,
literal|"NOTE_INSN_FUNCTION_END"
block|,
literal|"NOTE_INSN_SETJMP"
block|,
literal|"NOTE_INSN_LOOP_CONT"
block|,
literal|"NOTE_INSN_LOOP_VTOP"
block|,
literal|"NOTE_INSN_PROLOGUE_END"
block|,
literal|"NOTE_INSN_EPILOGUE_BEG"
block|,
literal|"NOTE_INSN_DELETED_LABEL"
block|,
literal|"NOTE_INSN_FUNCTION_BEG"
block|,
literal|"NOTE_INSN_EH_REGION_BEG"
block|,
literal|"NOTE_INSN_EH_REGION_END"
block|,
literal|"NOTE_REPEATED_LINE_NUMBER"
block|,
literal|"NOTE_INSN_RANGE_START"
block|,
literal|"NOTE_INSN_RANGE_END"
block|,
literal|"NOTE_INSN_LIVE"
block|,
literal|"NOTE_INSN_BASIC_BLOCK"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|reg_note_name
index|[]
init|=
block|{
literal|""
block|,
literal|"REG_DEAD"
block|,
literal|"REG_INC"
block|,
literal|"REG_EQUIV"
block|,
literal|"REG_WAS_0"
block|,
literal|"REG_EQUAL"
block|,
literal|"REG_RETVAL"
block|,
literal|"REG_LIBCALL"
block|,
literal|"REG_NONNEG"
block|,
literal|"REG_NO_CONFLICT"
block|,
literal|"REG_UNUSED"
block|,
literal|"REG_CC_SETTER"
block|,
literal|"REG_CC_USER"
block|,
literal|"REG_LABEL"
block|,
literal|"REG_DEP_ANTI"
block|,
literal|"REG_DEP_OUTPUT"
block|,
literal|"REG_BR_PROB"
block|,
literal|"REG_EXEC_COUNT"
block|,
literal|"REG_NOALIAS"
block|,
literal|"REG_SAVE_AREA"
block|,
literal|"REG_BR_PRED"
block|,
literal|"REG_EH_CONTEXT"
block|,
literal|"REG_FRAME_RELATED_EXPR"
block|,
literal|"REG_EH_REGION"
block|,
literal|"REG_EH_RETHROW"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_and_abort
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_name
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Allocate an rtx vector of N elements.    Store the length, and initialize all elements to zero.  */
end_comment

begin_function
name|rtvec
name|rtvec_alloc
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|rtvec
name|rt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rt
operator|=
operator|(
name|rtvec
operator|)
name|obstack_alloc
argument_list|(
name|rtl_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rtvec_def
argument_list|)
operator|+
operator|(
operator|(
name|n
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* clear out the vector */
name|PUT_NUM_ELEM
argument_list|(
name|rt
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|elem
index|[
name|i
index|]
operator|.
name|rtwint
operator|=
literal|0
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/* Allocate an rtx of code CODE.  The CODE is stored in the rtx;    all the rest is initialized to zero.  */
end_comment

begin_function
name|rtx
name|rtx_alloc
parameter_list|(
name|code
parameter_list|)
name|RTX_CODE
name|code
decl_stmt|;
block|{
name|rtx
name|rt
decl_stmt|;
specifier|register
name|struct
name|obstack
modifier|*
name|ob
init|=
name|rtl_obstack
decl_stmt|;
specifier|register
name|int
name|nelts
init|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|length
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_def
argument_list|)
operator|+
operator|(
name|nelts
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
decl_stmt|;
comment|/* This function is called more than any other in GCC,      so we manipulate the obstack directly.       Even though rtx objects are word aligned, we may be sharing an obstack      with tree nodes, which may have to be double-word aligned.  So align      our length to the alignment mask in the obstack.  */
name|length
operator|=
operator|(
name|length
operator|+
name|ob
operator|->
name|alignment_mask
operator|)
operator|&
operator|~
name|ob
operator|->
name|alignment_mask
expr_stmt|;
if|if
condition|(
name|ob
operator|->
name|chunk_limit
operator|-
name|ob
operator|->
name|next_free
operator|<
name|length
condition|)
name|_obstack_newchunk
argument_list|(
name|ob
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|rt
operator|=
operator|(
name|rtx
operator|)
name|ob
operator|->
name|object_base
expr_stmt|;
name|ob
operator|->
name|next_free
operator|+=
name|length
expr_stmt|;
name|ob
operator|->
name|object_base
operator|=
name|ob
operator|->
name|next_free
expr_stmt|;
comment|/* We want to clear everything up to the FLD array.  Normally, this is      one int, but we don't want to assume that and it isn't very portable      anyway; this is.  */
name|memset
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_def
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|rt
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/* Free the rtx X and all RTL allocated since X.  */
end_comment

begin_function
name|void
name|rtx_free
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|obstack_free
argument_list|(
name|rtl_obstack
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new copy of an rtx.    Recursively copies the operands of the rtx,    except for those few rtx codes that are sharable.  */
end_comment

begin_function
name|rtx
name|copy_rtx
parameter_list|(
name|orig
parameter_list|)
specifier|register
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|rtx
name|copy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SCRATCH
case|:
comment|/* SCRATCH must be shared because they represent distinct values.  */
case|case
name|ADDRESSOF
case|:
return|return
name|orig
return|;
case|case
name|CONST
case|:
comment|/* CONST can be shared if it contains a SYMBOL_REF.  If it contains 	 a LABEL_REF, it isn't sharable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|orig
return|;
break|break;
comment|/* A MEM with a constant address is not sharable.  The problem is that 	 the constant address may need to be reloaded.  If the mem is shared, 	 then reloading one copy of this mem will cause all copies to appear 	 to have been reloaded.  */
default|default:
break|break;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Copy the various flags, and other information.  We assume that      all fields need copying, and then clear the fields that should      not be copied.  That is the sensible default behavior, and forces      us to explicitly document why we are *not* copying a flag.  */
name|memcpy
argument_list|(
name|copy
argument_list|,
name|orig
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_def
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We do not copy the USED flag, which is used as a mark bit during      walks over the RTL.  */
name|copy
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* We do not copy JUMP, CALL, or FRAME_RELATED for INSNs.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|copy
operator|->
name|jump
operator|=
literal|0
expr_stmt|;
name|copy
operator|->
name|call
operator|=
literal|0
expr_stmt|;
name|copy
operator|->
name|frame_related
operator|=
literal|0
expr_stmt|;
block|}
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'u'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'b'
case|:
block|{
name|bitmap
name|new_bits
init|=
name|BITMAP_OBSTACK_ALLOC
argument_list|(
name|rtl_obstack
argument_list|)
decl_stmt|;
name|bitmap_copy
argument_list|(
name|new_bits
argument_list|,
name|XBITMAP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|XBITMAP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|new_bits
expr_stmt|;
break|break;
block|}
case|case
literal|'t'
case|:
name|XTREE
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XTREE
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|XWINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XWINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|XSTR
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Similar to `copy_rtx' except that if MAY_SHARE is present, it is    placed in the result directly, rather than being copied.  */
end_comment

begin_function
name|rtx
name|copy_most_rtx
parameter_list|(
name|orig
parameter_list|,
name|may_share
parameter_list|)
specifier|register
name|rtx
name|orig
decl_stmt|;
specifier|register
name|rtx
name|may_share
decl_stmt|;
block|{
specifier|register
name|rtx
name|copy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|orig
operator|==
name|may_share
condition|)
return|return
name|orig
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|orig
return|;
default|default:
break|break;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|copy
operator|->
name|integrated
operator|=
name|orig
operator|->
name|integrated
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|may_share
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_most_rtx
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|,
name|may_share
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'u'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_most_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|may_share
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|XWINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XWINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'i'
case|:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|XSTR
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Create a new copy of an rtx.  Only copy just one level.  */
end_comment

begin_function
name|rtx
name|shallow_copy_rtx
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|copy
init|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|copy
operator|->
name|integrated
operator|=
name|orig
operator|->
name|integrated
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
name|copy
operator|->
name|fld
index|[
name|i
index|]
operator|=
name|orig
operator|->
name|fld
index|[
name|i
index|]
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of read_rtx.  */
end_comment

begin_comment
comment|/* Dump code after printing a message.  Used when read_rtx finds    invalid data.  */
end_comment

begin_function
specifier|static
name|void
name|dump_and_abort
parameter_list|(
name|expected_c
parameter_list|,
name|actual_c
parameter_list|,
name|infile
parameter_list|)
name|int
name|expected_c
decl_stmt|,
name|actual_c
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|expected_c
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Expected character %c.  Found character %c."
argument_list|,
name|expected_c
argument_list|,
name|actual_c
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  At file position: %ld\n"
argument_list|,
name|ftell
argument_list|(
name|infile
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Following characters are:\n\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|EOF
operator|==
name|c
condition|)
break|break;
name|putc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Aborting.\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read chars from INFILE until a non-whitespace char    and return that.  Comments, both Lisp style and C style,    are treated as whitespace.    Tools such as genflags use this function.  */
end_comment

begin_function
name|int
name|read_skip_spaces
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\f'
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
block|{
specifier|register
name|int
name|prevc
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
condition|)
name|dump_and_abort
argument_list|(
literal|'*'
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|prevc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|prevc
operator|==
literal|'*'
operator|&&
name|c
operator|==
literal|'/'
condition|)
break|break;
name|prevc
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Read an rtx code name into the buffer STR[].    It is terminated by any of the punctuation chars of rtx printed syntax.  */
end_comment

begin_function
specifier|static
name|void
name|read_name
parameter_list|(
name|str
parameter_list|,
name|infile
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|p
operator|=
name|str
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\f'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'/'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|'['
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|str
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"missing name or number"
argument_list|)
expr_stmt|;
name|dump_and_abort
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|infile
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Provide a version of a function to read a long long if the system does    not provide one.  */
end_comment

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
name|HOST_BITS_PER_LONG
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ATOLL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ATOQ
argument_list|)
end_if

begin_function
name|HOST_WIDE_INT
name|atoll
parameter_list|(
name|p
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|neg
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|tmp_wide
decl_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|neg
operator|=
literal|1
operator|,
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
name|tmp_wide
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|new_wide
init|=
name|tmp_wide
operator|*
literal|10
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
decl_stmt|;
if|if
condition|(
name|new_wide
operator|<
name|tmp_wide
condition|)
block|{
comment|/* Return INT_MAX equiv on overflow.  */
name|tmp_wide
operator|=
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|>>
literal|1
expr_stmt|;
break|break;
block|}
name|tmp_wide
operator|=
name|new_wide
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|neg
condition|)
name|tmp_wide
operator|=
operator|-
name|tmp_wide
expr_stmt|;
return|return
name|tmp_wide
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Read an rtx in printed representation from INFILE    and return an actual rtx in core constructed accordingly.    read_rtx is not used in the compiler proper, but rather in    the utilities gen*.c that construct C code from machine descriptions.  */
end_comment

begin_function
name|rtx
name|read_rtx
parameter_list|(
name|infile
parameter_list|)
name|FILE
modifier|*
name|infile
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|list_counter
decl_stmt|;
name|RTX_CODE
name|tmp_code
decl_stmt|;
specifier|register
name|char
modifier|*
name|format_ptr
decl_stmt|;
comment|/* tmp_char is a buffer used for reading decimal integers      and names of rtx types and machine modes.      Therefore, 256 must be enough.  */
name|char
name|tmp_char
index|[
literal|256
index|]
decl_stmt|;
name|rtx
name|return_rtx
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|tmp_int
decl_stmt|;
name|HOST_WIDE_INT
name|tmp_wide
decl_stmt|;
comment|/* Linked list structure for making RTXs: */
struct|struct
name|rtx_list
block|{
name|struct
name|rtx_list
modifier|*
name|next
decl_stmt|;
name|rtx
name|value
decl_stmt|;
comment|/* Value of this node...		*/
block|}
struct|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Should be open paren.  */
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
name|dump_and_abort
argument_list|(
literal|'('
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|tmp_code
operator|=
name|UNKNOWN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
comment|/* @@ might speed this search up */
block|{
if|if
condition|(
operator|!
operator|(
name|strcmp
argument_list|(
name|tmp_char
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|i
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|tmp_code
operator|=
operator|(
name|RTX_CODE
operator|)
name|i
expr_stmt|;
comment|/* get value for name */
break|break;
block|}
block|}
if|if
condition|(
name|tmp_code
operator|==
name|UNKNOWN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown rtx read in rtl.read_rtx(). Code name was %s ."
argument_list|,
name|tmp_char
argument_list|)
expr_stmt|;
block|}
comment|/* (NIL) stands for an expression that isn't there.  */
if|if
condition|(
name|tmp_code
operator|==
name|NIL
condition|)
block|{
comment|/* Discard the closeparen.  */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|&&
name|c
operator|!=
literal|')'
condition|)
empty_stmt|;
return|return
literal|0
return|;
block|}
name|return_rtx
operator|=
name|rtx_alloc
argument_list|(
name|tmp_code
argument_list|)
expr_stmt|;
comment|/* if we end up with an insn expression 				       then we free this space below.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|return_rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If what follows is `: mode ', read it and      store the mode in the rtx.  */
name|i
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|':'
condition|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_MACHINE_MODES
condition|;
name|k
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|GET_MODE_NAME
argument_list|(
name|k
argument_list|)
argument_list|,
name|tmp_char
argument_list|)
condition|)
break|break;
name|PUT_MODE
argument_list|(
name|return_rtx
argument_list|,
operator|(
expr|enum
name|machine_mode
operator|)
name|k
argument_list|)
expr_stmt|;
block|}
else|else
name|ungetc
argument_list|(
name|i
argument_list|,
name|infile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|return_rtx
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
comment|/* 0 means a field for internal use only. 	   Don't expect it to be present in the input.  */
case|case
literal|'0'
case|:
break|break;
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|XEXP
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* 'V' is an optional vector: if a closeparen follows, 	   just store NULL for this element.  */
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
name|XVEC
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Now process the vector.  */
case|case
literal|'E'
case|:
block|{
specifier|register
name|struct
name|rtx_list
modifier|*
name|next_rtx
decl_stmt|,
modifier|*
name|rtx_list_link
decl_stmt|;
name|struct
name|rtx_list
modifier|*
name|list_rtx
init|=
name|NULL
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'['
condition|)
name|dump_and_abort
argument_list|(
literal|'['
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
comment|/* add expressions to a list, while keeping a count */
name|next_rtx
operator|=
name|NULL
expr_stmt|;
name|list_counter
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
operator|)
operator|&&
name|c
operator|!=
literal|']'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|list_counter
operator|++
expr_stmt|;
name|rtx_list_link
operator|=
operator|(
expr|struct
name|rtx_list
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_list
argument_list|)
argument_list|)
expr_stmt|;
name|rtx_list_link
operator|->
name|value
operator|=
name|read_rtx
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_rtx
operator|==
literal|0
condition|)
name|list_rtx
operator|=
name|rtx_list_link
expr_stmt|;
else|else
name|next_rtx
operator|->
name|next
operator|=
name|rtx_list_link
expr_stmt|;
name|next_rtx
operator|=
name|rtx_list_link
expr_stmt|;
name|rtx_list_link
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
comment|/* get vector length and allocate it */
name|XVEC
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
operator|(
name|list_counter
condition|?
name|rtvec_alloc
argument_list|(
name|list_counter
argument_list|)
else|:
name|NULL_RTVEC
operator|)
expr_stmt|;
if|if
condition|(
name|list_counter
operator|>
literal|0
condition|)
block|{
name|next_rtx
operator|=
name|list_rtx
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|list_counter
condition|;
name|j
operator|++
operator|,
name|next_rtx
operator|=
name|next_rtx
operator|->
name|next
control|)
name|XVECEXP
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|next_rtx
operator|->
name|value
expr_stmt|;
block|}
comment|/* close bracket gotten */
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* 'S' is an optional string: if a closeparen follows, 	   just store NULL for this element.  */
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
name|XSTR
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
literal|'s'
case|:
block|{
name|int
name|saw_paren
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|stringbuf
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|saw_paren
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
name|dump_and_abort
argument_list|(
literal|'"'
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Read the string  */
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Read the string  */
comment|/* \; makes stuff for a C string constant containing 		     newline and tab.  */
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
name|obstack_grow
argument_list|(
name|rtl_obstack
argument_list|,
literal|"\\n\\t"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
break|break;
name|obstack_1grow
argument_list|(
name|rtl_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
name|rtl_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stringbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_finish
argument_list|(
name|rtl_obstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|saw_paren
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|dump_and_abort
argument_list|(
literal|')'
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
block|}
name|XSTR
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|stringbuf
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_INT
name|tmp_wide
operator|=
name|atoi
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_LONG
name|tmp_wide
operator|=
name|atol
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Prefer atoll over atoq, since the former is in the ISO C9X draft.  	   But prefer not to use our hand-rolled function above either.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ATOLL
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_ATOQ
argument_list|)
name|tmp_wide
operator|=
name|atoll
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
else|#
directive|else
name|tmp_wide
operator|=
name|atoq
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
name|XWINT
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|tmp_wide
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|tmp_int
operator|=
name|atoi
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|tmp_int
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"switch format wrong in rtl.read_rtx(). format was: %c.\n"
argument_list|,
name|format_ptr
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfile position: %ld\n"
argument_list|,
name|ftell
argument_list|(
name|infile
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|dump_and_abort
argument_list|(
literal|')'
argument_list|,
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
return|return
name|return_rtx
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is called once per compilation, before any rtx's are constructed.    It initializes the vector `rtx_length', the extra CC modes, if any,    and computes certain commonly-used modes.  */
end_comment

begin_function
name|void
name|init_rtl
parameter_list|()
block|{
name|int
name|min_class_size
index|[
operator|(
name|int
operator|)
name|MAX_MODE_CLASS
index|]
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
name|rtx_length
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|rtx_format
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Make CONST_DOUBLE bigger, if real values are bigger than      it normally expects to have room for.      Note that REAL_VALUE_TYPE is not defined by default,      since tree.h is not included.  But the default dfn as `double'      would do no harm.  */
ifdef|#
directive|ifdef
name|REAL_VALUE_TYPE
name|i
operator|=
sizeof|sizeof
argument_list|(
name|REAL_VALUE_TYPE
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|rtx_length
index|[
operator|(
name|int
operator|)
name|CONST_DOUBLE
index|]
operator|<
name|i
condition|)
block|{
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|rtx_length
index|[
operator|(
name|int
operator|)
name|CONST_DOUBLE
index|]
operator|=
name|i
expr_stmt|;
name|rtx_format
index|[
operator|(
name|int
operator|)
name|CONST_DOUBLE
index|]
operator|=
name|s
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'e'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
comment|/* Set the GET_RTX_FORMAT of CONST_DOUBLE to a string 	 of as many `w's as we now have elements.  Subtract two from 	 the size to account for the 'e' and the '0'.  */
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|rtx_length
index|[
operator|(
name|int
operator|)
name|CONST_DOUBLE
index|]
condition|;
name|i
operator|++
control|)
operator|*
name|s
operator|++
operator|=
literal|'w'
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTRA_CC_MODES
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|CCmode
operator|+
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|i
operator|++
control|)
block|{
name|mode_class
index|[
name|i
index|]
operator|=
name|MODE_CC
expr_stmt|;
name|mode_mask_array
index|[
name|i
index|]
operator|=
name|mode_mask_array
index|[
operator|(
name|int
operator|)
name|CCmode
index|]
expr_stmt|;
name|mode_size
index|[
name|i
index|]
operator|=
name|mode_size
index|[
operator|(
name|int
operator|)
name|CCmode
index|]
expr_stmt|;
name|mode_unit_size
index|[
name|i
index|]
operator|=
name|mode_unit_size
index|[
operator|(
name|int
operator|)
name|CCmode
index|]
expr_stmt|;
name|mode_wider_mode
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|mode_wider_mode
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|VOIDmode
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Find the narrowest mode for each class.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|MAX_MODE_CLASS
condition|;
name|i
operator|++
control|)
name|min_class_size
index|[
name|i
index|]
operator|=
literal|1000
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|VOIDmode
init|;
operator|(
name|int
operator|)
name|mode
operator|<
operator|(
name|int
operator|)
name|MAX_MACHINE_MODE
condition|;
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
operator|(
operator|(
name|int
operator|)
name|mode
operator|+
literal|1
operator|)
control|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|min_class_size
index|[
operator|(
name|int
operator|)
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
index|]
condition|)
block|{
name|class_narrowest_mode
index|[
operator|(
name|int
operator|)
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
index|]
operator|=
name|mode
expr_stmt|;
name|min_class_size
index|[
operator|(
name|int
operator|)
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
index|]
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

