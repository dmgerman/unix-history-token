begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RTL utility routines.    Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Calculate the format for CONST_DOUBLE.  This depends on the relative    widths of HOST_WIDE_INT and REAL_VALUE_TYPE.     We need to go out to 0wwwww, since REAL_ARITHMETIC assumes 16-bits    per element in REAL_VALUE_TYPE.     This is duplicated in gengenrtl.c.     A number of places assume that there are always at least two 'w'    slots in a CONST_DOUBLE, so we provide them even if one would suffice.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|REAL_ARITHMETIC
end_ifdef

begin_if
if|#
directive|if
name|MAX_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|96
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
define|\
value|(11*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|MAX_LONG_DOUBLE_TYPE_SIZE
operator|==
literal|128
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
define|\
value|(19*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HOST_FLOAT_FORMAT
operator|!=
name|TARGET_FLOAT_FORMAT
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
define|\
value|(7*8 + HOST_BITS_PER_WIDE_INT)/HOST_BITS_PER_WIDE_INT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REAL_ARITHMETIC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REAL_WIDTH
end_ifndef

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
operator|>=
name|MAX_LONG_DOUBLE_TYPE_SIZE
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|3
operator|>=
name|MAX_LONG_DOUBLE_TYPE_SIZE
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
value|3
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|4
operator|>=
name|MAX_LONG_DOUBLE_TYPE_SIZE
end_if

begin_define
define|#
directive|define
name|REAL_WIDTH
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REAL_WIDTH */
end_comment

begin_if
if|#
directive|if
name|REAL_WIDTH
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|"0ww"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|REAL_WIDTH
operator|==
literal|2
end_if

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|"0ww"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|REAL_WIDTH
operator|==
literal|3
end_if

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|"0www"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|REAL_WIDTH
operator|==
literal|4
end_if

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|"0wwww"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|REAL_WIDTH
operator|==
literal|5
end_if

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
value|"0wwwww"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONST_DOUBLE_FORMAT
end_define

begin_comment
comment|/* nothing - will cause syntax error */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Indexed by rtx code, gives number of operands for an rtx with that code.    Does NOT include rtx header data (code and links).  */
end_comment

begin_define
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|sizeof FORMAT - 1 ,
end_define

begin_decl_stmt
specifier|const
name|unsigned
name|char
name|rtx_length
index|[
name|NUM_RTX_CODE
index|]
init|=
block|{
include|#
directive|include
file|"rtl.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_RTL_EXPR
end_undef

begin_comment
comment|/* Indexed by rtx code, gives the name of that kind of rtx, as a C string.  */
end_comment

begin_define
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|NAME ,
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|rtx_name
index|[
name|NUM_RTX_CODE
index|]
init|=
block|{
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_RTL_EXPR
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the name of that machine mode.    This name does not include the letters "mode".  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|BITSIZE
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|mode_name
index|[
name|NUM_MACHINE_MODES
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the class mode for GET_MODE_CLASS.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|BITSIZE
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
value|CLASS,
end_define

begin_decl_stmt
specifier|const
name|enum
name|mode_class
name|mode_class
index|[
name|NUM_MACHINE_MODES
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the length of the mode, in bits.    GET_MODE_BITSIZE uses this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|BITSIZE
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
value|BITSIZE,
end_define

begin_decl_stmt
specifier|const
name|unsigned
name|short
name|mode_bitsize
index|[
name|NUM_MACHINE_MODES
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the length of the mode, in bytes.    GET_MODE_SIZE uses this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|BITSIZE
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
value|SIZE,
end_define

begin_decl_stmt
specifier|const
name|unsigned
name|char
name|mode_size
index|[
name|NUM_MACHINE_MODES
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives the length of the mode's subunit.    GET_MODE_UNIT_SIZE uses this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|BITSIZE
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
value|UNIT,
end_define

begin_decl_stmt
specifier|const
name|unsigned
name|char
name|mode_unit_size
index|[
name|NUM_MACHINE_MODES
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
comment|/* machine modes are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_comment
comment|/* Indexed by machine mode, gives next wider natural mode    (QI -> HI -> SI -> DI, etc.)  Widening multiply instructions    use this.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|BITSIZE
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
define|\
value|(unsigned char) WIDER,
end_define

begin_decl_stmt
specifier|const
name|unsigned
name|char
name|mode_wider_mode
index|[
name|NUM_MACHINE_MODES
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
comment|/* machine modes are documented here */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MACHMODE
end_undef

begin_define
define|#
directive|define
name|DEF_MACHMODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|BITSIZE
parameter_list|,
name|SIZE
parameter_list|,
name|UNIT
parameter_list|,
name|WIDER
parameter_list|)
define|\
value|((BITSIZE)>= HOST_BITS_PER_WIDE_INT) ? ~(unsigned HOST_WIDE_INT) 0 : ((unsigned HOST_WIDE_INT) 1<< (BITSIZE)) - 1,
end_define

begin_comment
comment|/* Indexed by machine mode, gives mask of significant bits in mode.  */
end_comment

begin_decl_stmt
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|mode_mask_array
index|[
name|NUM_MACHINE_MODES
index|]
init|=
block|{
include|#
directive|include
file|"machmode.def"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by mode class, gives the narrowest mode for each class.    The Q modes are always of width 1 (2 for complex) - it is impossible    for any mode to be narrower.     Note that we use QImode instead of BImode for MODE_INT, since    otherwise the middle end will try to use it for bitfields in    structures and the like, which we do not want.  Only the target    md file should generate BImode widgets.  */
end_comment

begin_decl_stmt
specifier|const
name|enum
name|machine_mode
name|class_narrowest_mode
index|[
operator|(
name|int
operator|)
name|MAX_MODE_CLASS
index|]
init|=
block|{
comment|/* MODE_RANDOM */
name|VOIDmode
block|,
comment|/* MODE_INT */
name|QImode
block|,
comment|/* MODE_FLOAT */
name|QFmode
block|,
comment|/* MODE_PARTIAL_INT */
name|PQImode
block|,
comment|/* MODE_CC */
name|CCmode
block|,
comment|/* MODE_COMPLEX_INT */
name|CQImode
block|,
comment|/* MODE_COMPLEX_FLOAT */
name|QCmode
block|,
comment|/* MODE_VECTOR_INT */
name|V2QImode
block|,
comment|/* MODE_VECTOR_FLOAT */
name|V2SFmode
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by rtx code, gives a sequence of operand-types for    rtx's of that code.  The sequence is a C string in which    each character describes one operand.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|rtx_format
index|[
name|NUM_RTX_CODE
index|]
init|=
block|{
comment|/* "*" undefined.          can cause a warning message      "0" field is unused (or used in a phase-dependent manner)          prints nothing      "i" an integer          prints the integer      "n" like "i", but prints entries from `note_insn_name'      "w" an integer of width HOST_BITS_PER_WIDE_INT          prints the integer      "s" a pointer to a string          prints the string      "S" like "s", but optional: 	 the containing rtx may end before this operand      "T" like "s", but treated specially by the RTL reader;          only found in machine description patterns.      "e" a pointer to an rtl expression          prints the expression      "E" a pointer to a vector that points to a number of rtl expressions          prints a list of the rtl expressions      "V" like "E", but optional: 	 the containing rtx may end before this operand      "u" a pointer to another insn          prints the uid of the insn.      "b" is a pointer to a bitmap header.      "t" is a tree pointer.  */
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|FORMAT ,
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are defined here */
undef|#
directive|undef
name|DEF_RTL_EXPR
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by rtx code, gives a character representing the "class" of    that rtx code.  See rtl.def for documentation on the defined classes.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|rtx_class
index|[
name|NUM_RTX_CODE
index|]
init|=
block|{
define|#
directive|define
name|DEF_RTL_EXPR
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|FORMAT
parameter_list|,
name|CLASS
parameter_list|)
value|CLASS,
include|#
directive|include
file|"rtl.def"
comment|/* rtl expressions are defined here */
undef|#
directive|undef
name|DEF_RTL_EXPR
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Names for kinds of NOTEs and REG_NOTEs.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|note_insn_name
index|[
name|NOTE_INSN_MAX
operator|-
name|NOTE_INSN_BIAS
index|]
init|=
block|{
literal|""
block|,
literal|"NOTE_INSN_DELETED"
block|,
literal|"NOTE_INSN_BLOCK_BEG"
block|,
literal|"NOTE_INSN_BLOCK_END"
block|,
literal|"NOTE_INSN_LOOP_BEG"
block|,
literal|"NOTE_INSN_LOOP_END"
block|,
literal|"NOTE_INSN_LOOP_CONT"
block|,
literal|"NOTE_INSN_LOOP_VTOP"
block|,
literal|"NOTE_INSN_LOOP_END_TOP_COND"
block|,
literal|"NOTE_INSN_FUNCTION_END"
block|,
literal|"NOTE_INSN_PROLOGUE_END"
block|,
literal|"NOTE_INSN_EPILOGUE_BEG"
block|,
literal|"NOTE_INSN_DELETED_LABEL"
block|,
literal|"NOTE_INSN_FUNCTION_BEG"
block|,
literal|"NOTE_INSN_EH_REGION_BEG"
block|,
literal|"NOTE_INSN_EH_REGION_END"
block|,
literal|"NOTE_INSN_REPEATED_LINE_NUMBER"
block|,
literal|"NOTE_INSN_RANGE_BEG"
block|,
literal|"NOTE_INSN_RANGE_END"
block|,
literal|"NOTE_INSN_LIVE"
block|,
literal|"NOTE_INSN_BASIC_BLOCK"
block|,
literal|"NOTE_INSN_EXPECTED_VALUE"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
specifier|const
name|reg_note_name
index|[]
init|=
block|{
literal|""
block|,
literal|"REG_DEAD"
block|,
literal|"REG_INC"
block|,
literal|"REG_EQUIV"
block|,
literal|"REG_EQUAL"
block|,
literal|"REG_WAS_0"
block|,
literal|"REG_RETVAL"
block|,
literal|"REG_LIBCALL"
block|,
literal|"REG_NONNEG"
block|,
literal|"REG_NO_CONFLICT"
block|,
literal|"REG_UNUSED"
block|,
literal|"REG_CC_SETTER"
block|,
literal|"REG_CC_USER"
block|,
literal|"REG_LABEL"
block|,
literal|"REG_DEP_ANTI"
block|,
literal|"REG_DEP_OUTPUT"
block|,
literal|"REG_BR_PROB"
block|,
literal|"REG_EXEC_COUNT"
block|,
literal|"REG_NOALIAS"
block|,
literal|"REG_SAVE_AREA"
block|,
literal|"REG_BR_PRED"
block|,
literal|"REG_FRAME_RELATED_EXPR"
block|,
literal|"REG_EH_CONTEXT"
block|,
literal|"REG_EH_REGION"
block|,
literal|"REG_SAVE_NOTE"
block|,
literal|"REG_MAYBE_DEAD"
block|,
literal|"REG_NORETURN"
block|,
literal|"REG_NON_LOCAL_GOTO"
block|,
literal|"REG_SETJMP"
block|,
literal|"REG_ALWAYS_RETURN"
block|,
literal|"REG_VTABLE_REF"
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Allocate an rtx vector of N elements.    Store the length, and initialize all elements to zero.  */
end_comment

begin_function
name|rtvec
name|rtvec_alloc
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|rtvec
name|rt
decl_stmt|;
name|rt
operator|=
name|ggc_alloc_rtvec
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* clear out the vector */
name|memset
argument_list|(
operator|&
name|rt
operator|->
name|elem
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_NUM_ELEM
argument_list|(
name|rt
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/* Allocate an rtx of code CODE.  The CODE is stored in the rtx;    all the rest is initialized to zero.  */
end_comment

begin_function
name|rtx
name|rtx_alloc
parameter_list|(
name|code
parameter_list|)
name|RTX_CODE
name|code
decl_stmt|;
block|{
name|rtx
name|rt
decl_stmt|;
name|int
name|n
init|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|rt
operator|=
name|ggc_alloc_rtx
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* We want to clear everything up to the FLD array.  Normally, this      is one int, but we don't want to assume that and it isn't very      portable anyway; this is.  */
name|memset
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_def
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|rt
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new copy of an rtx.    Recursively copies the operands of the rtx,    except for those few rtx codes that are sharable.  */
end_comment

begin_function
name|rtx
name|copy_rtx
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
name|rtx
name|copy
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|SCRATCH
case|:
comment|/* SCRATCH must be shared because they represent distinct values.  */
case|case
name|ADDRESSOF
case|:
return|return
name|orig
return|;
case|case
name|CONST
case|:
comment|/* CONST can be shared if it contains a SYMBOL_REF.  If it contains 	 a LABEL_REF, it isn't sharable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|orig
return|;
break|break;
comment|/* A MEM with a constant address is not sharable.  The problem is that 	 the constant address may need to be reloaded.  If the mem is shared, 	 then reloading one copy of this mem will cause all copies to appear 	 to have been reloaded.  */
default|default:
break|break;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Copy the various flags, and other information.  We assume that      all fields need copying, and then clear the fields that should      not be copied.  That is the sensible default behavior, and forces      us to explicitly document why we are *not* copying a flag.  */
name|memcpy
argument_list|(
name|copy
argument_list|,
name|orig
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rtx_def
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|rtunion
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We do not copy the USED flag, which is used as a mark bit during      walks over the RTL.  */
name|copy
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* We do not copy FRAME_RELATED for INSNs.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
name|copy
operator|->
name|frame_related
operator|=
literal|0
expr_stmt|;
name|copy
operator|->
name|jump
operator|=
name|orig
operator|->
name|jump
expr_stmt|;
name|copy
operator|->
name|call
operator|=
name|orig
operator|->
name|call
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|copy
operator|->
name|fld
index|[
name|i
index|]
operator|=
name|orig
operator|->
name|fld
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
case|case
literal|'w'
case|:
case|case
literal|'i'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'u'
case|:
case|case
literal|'0'
case|:
comment|/* These are left unchanged.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Similar to `copy_rtx' except that if MAY_SHARE is present, it is    placed in the result directly, rather than being copied.  */
end_comment

begin_function
name|rtx
name|copy_most_rtx
parameter_list|(
name|orig
parameter_list|,
name|may_share
parameter_list|)
name|rtx
name|orig
decl_stmt|;
name|rtx
name|may_share
decl_stmt|;
block|{
name|rtx
name|copy
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|RTX_CODE
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
if|if
condition|(
name|orig
operator|==
name|may_share
condition|)
return|return
name|orig
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|QUEUED
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CODE_LABEL
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|orig
return|;
default|default:
break|break;
block|}
name|copy
operator|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|copy
operator|->
name|integrated
operator|=
name|orig
operator|->
name|integrated
expr_stmt|;
name|copy
operator|->
name|frame_related
operator|=
name|orig
operator|->
name|frame_related
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|copy
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|format_ptr
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|may_share
condition|)
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|copy_most_rtx
argument_list|(
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|,
name|may_share
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|XEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'V'
case|:
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|XVEC
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|XVEC
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|copy
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|copy_most_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|orig
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|may_share
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|XWINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XWINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'i'
case|:
name|XINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|XTREE
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XTREE
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|XSTR
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|XSTR
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* Copy this through the wide int field; that's safest.  */
name|X0WINT
argument_list|(
name|copy
argument_list|,
name|i
argument_list|)
operator|=
name|X0WINT
argument_list|(
name|orig
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Create a new copy of an rtx.  Only copy just one level.  */
end_comment

begin_function
name|rtx
name|shallow_copy_rtx
parameter_list|(
name|orig
parameter_list|)
name|rtx
name|orig
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|orig
argument_list|)
decl_stmt|;
name|rtx
name|copy
init|=
name|rtx_alloc
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|PUT_MODE
argument_list|(
name|copy
argument_list|,
name|GET_MODE
argument_list|(
name|orig
argument_list|)
argument_list|)
expr_stmt|;
name|copy
operator|->
name|in_struct
operator|=
name|orig
operator|->
name|in_struct
expr_stmt|;
name|copy
operator|->
name|volatil
operator|=
name|orig
operator|->
name|volatil
expr_stmt|;
name|copy
operator|->
name|unchanging
operator|=
name|orig
operator|->
name|unchanging
expr_stmt|;
name|copy
operator|->
name|integrated
operator|=
name|orig
operator|->
name|integrated
expr_stmt|;
name|copy
operator|->
name|frame_related
operator|=
name|orig
operator|->
name|frame_related
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
condition|;
name|i
operator|++
control|)
name|copy
operator|->
name|fld
index|[
name|i
index|]
operator|=
name|orig
operator|->
name|fld
index|[
name|i
index|]
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* Return the alignment of MODE. This will be bounded by 1 and    BIGGEST_ALIGNMENT.  */
end_comment

begin_function
name|unsigned
name|int
name|get_mode_alignment
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|unsigned
name|int
name|alignment
init|=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* Extract the LSB of the size.  */
name|alignment
operator|=
name|alignment
operator|&
operator|-
name|alignment
expr_stmt|;
name|alignment
operator|*=
name|BITS_PER_UNIT
expr_stmt|;
name|alignment
operator|=
name|MIN
argument_list|(
name|BIGGEST_ALIGNMENT
argument_list|,
name|MAX
argument_list|(
literal|1
argument_list|,
name|alignment
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|alignment
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is 1 until after the rtl generation pass.  */
end_comment

begin_decl_stmt
name|int
name|rtx_equal_function_value_matters
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when we are generating CONCATs.  */
end_comment

begin_decl_stmt
name|int
name|generating_concat_p
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X and Y are identical-looking rtx's.    This is the Lisp function EQUAL for rtx arguments.  */
end_comment

begin_function
name|int
name|rtx_equal_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Rtx's of different codes cannot be equal.  */
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.      (REG:SI x) and (REG:HI x) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Some RTL can be compared nonrecursively.  */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
comment|/* Until rtl generation is complete, don't consider a reference 	 to the return register of the current function the same as 	 the return from a called function.  This eases the job of 	 function integration.  Once the distinction is no longer 	 needed, they can be considered equivalent.  */
return|return
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
operator|&&
operator|(
operator|!
name|rtx_equal_function_value_matters
operator|||
name|REG_FUNCTION_VALUE_P
argument_list|(
name|x
argument_list|)
operator|==
name|REG_FUNCTION_VALUE_P
argument_list|(
name|y
argument_list|)
operator|)
operator|)
return|;
case|case
name|LABEL_REF
case|:
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SCRATCH
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_INT
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole things.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
comment|/* Two vectors must have the same length.  */
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* And the corresponding elements must match.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
operator|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|||
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|||
operator|!
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
operator|||
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'u'
case|:
comment|/* These are just backpointers, so they don't matter.  */
break|break;
case|case
literal|'0'
case|:
case|case
literal|'t'
case|:
break|break;
comment|/* It is believed that rtx's at this level will never 	     contain anything but integers and other rtx's, 	     except for within LABEL_REFs and SYMBOL_REFs.  */
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
name|ENABLE_RTL_CHECKING
operator|&&
operator|(
name|GCC_VERSION
operator|>=
literal|2007
operator|)
end_if

begin_function
name|void
name|rtl_check_failed_bounds
parameter_list|(
name|r
parameter_list|,
name|n
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|func
parameter_list|)
name|rtx
name|r
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
block|{
name|internal_error
argument_list|(
literal|"RTL check: access of elt %d of `%s' with last elt %d in %s, at %s:%d"
argument_list|,
name|n
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtl_check_failed_type1
parameter_list|(
name|r
parameter_list|,
name|n
parameter_list|,
name|c1
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|func
parameter_list|)
name|rtx
name|r
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|c1
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
block|{
name|internal_error
argument_list|(
literal|"RTL check: expected elt %d type '%c', have '%c' (rtx %s) in %s, at %s:%d"
argument_list|,
name|n
argument_list|,
name|c1
argument_list|,
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
index|[
name|n
index|]
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtl_check_failed_type2
parameter_list|(
name|r
parameter_list|,
name|n
parameter_list|,
name|c1
parameter_list|,
name|c2
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|func
parameter_list|)
name|rtx
name|r
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|c1
decl_stmt|;
name|int
name|c2
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
block|{
name|internal_error
argument_list|(
literal|"RTL check: expected elt %d type '%c' or '%c', have '%c' (rtx %s) in %s, at %s:%d"
argument_list|,
name|n
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|,
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
index|[
name|n
index|]
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtl_check_failed_code1
parameter_list|(
name|r
parameter_list|,
name|code
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|func
parameter_list|)
name|rtx
name|r
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
block|{
name|internal_error
argument_list|(
literal|"RTL check: expected code `%s', have `%s' in %s, at %s:%d"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|code
argument_list|)
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rtl_check_failed_code2
parameter_list|(
name|r
parameter_list|,
name|code1
parameter_list|,
name|code2
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|func
parameter_list|)
name|rtx
name|r
decl_stmt|;
name|enum
name|rtx_code
name|code1
decl_stmt|,
name|code2
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
block|{
name|internal_error
argument_list|(
literal|"RTL check: expected code `%s' or `%s', have `%s' in %s, at %s:%d"
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|code1
argument_list|)
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|code2
argument_list|)
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
argument_list|)
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX Maybe print the vector?  */
end_comment

begin_function
name|void
name|rtvec_check_failed_bounds
parameter_list|(
name|r
parameter_list|,
name|n
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|,
name|func
parameter_list|)
name|rtvec
name|r
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
block|{
name|internal_error
argument_list|(
literal|"RTL check: access of elt %d of vector with last elt %d in %s, at %s:%d"
argument_list|,
name|n
argument_list|,
name|GET_NUM_ELEM
argument_list|(
name|r
argument_list|)
operator|-
literal|1
argument_list|,
name|func
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_RTL_CHECKING */
end_comment

end_unit

