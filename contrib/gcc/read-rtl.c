begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RTL reader for GCC.    Copyright (C) 1987, 1988, 1991, 1994, 1997, 1998, 1999, 2000, 2001, 2002,    2003, 2004, 2005    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bconfig.h"
end_include

begin_comment
comment|/* Disable rtl checking; it conflicts with the macro handling.  */
end_comment

begin_undef
undef|#
directive|undef
name|ENABLE_RTL_CHECKING
end_undef

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"gensupport.h"
end_include

begin_decl_stmt
specifier|static
name|htab_t
name|md_constants
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* One element in a singly-linked list of (integer, string) pairs.  */
end_comment

begin_struct
struct|struct
name|map_value
block|{
name|struct
name|map_value
modifier|*
name|next
decl_stmt|;
name|int
name|number
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Maps a macro or attribute name to a list of (integer, string) pairs.    The integers are mode or code values; the strings are either C conditions    or attribute values.  */
end_comment

begin_struct
struct|struct
name|mapping
block|{
comment|/* The name of the macro or attribute.  */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The group (modes or codes) to which the macro or attribute belongs.  */
name|struct
name|macro_group
modifier|*
name|group
decl_stmt|;
comment|/* Gives a unique number to the attribute or macro.  Numbers are      allocated consecutively, starting at 0.  */
name|int
name|index
decl_stmt|;
comment|/* The list of (integer, string) pairs.  */
name|struct
name|map_value
modifier|*
name|values
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A structure for abstracting the common parts of code and mode macros.  */
end_comment

begin_struct
struct|struct
name|macro_group
block|{
comment|/* Tables of "mapping" structures, one for attributes and one for macros.  */
name|htab_t
name|attrs
decl_stmt|,
name|macros
decl_stmt|;
comment|/* The number of "real" modes or codes (and by extension, the first      number available for use as a macro placeholder).  */
name|int
name|num_builtins
decl_stmt|;
comment|/* Treat the given string as the name of a standard mode or code and      return its integer value.  Use the given file for error reporting.  */
name|int
function_decl|(
modifier|*
name|find_builtin
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
comment|/* Return true if the given rtx uses the given mode or code.  */
name|bool
function_decl|(
modifier|*
name|uses_macro_p
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* Make the given rtx use the given mode or code.  */
name|void
function_decl|(
modifier|*
name|apply_macro
function_decl|)
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* Associates PTR (which can be a string, etc.) with the file location    specified by FILENAME and LINENO.  */
end_comment

begin_struct
struct|struct
name|ptr_loc
block|{
specifier|const
name|void
modifier|*
name|ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A structure used to pass data from read_rtx to apply_macro_traverse    via htab_traverse.  */
end_comment

begin_struct
struct|struct
name|macro_traverse_data
block|{
comment|/* Instruction queue.  */
name|rtx
name|queue
decl_stmt|;
comment|/* Attributes seen for modes.  */
name|struct
name|map_value
modifier|*
name|mode_maps
decl_stmt|;
comment|/* Input file.  */
name|FILE
modifier|*
name|infile
decl_stmt|;
comment|/* The last unknown attribute used as a mode.  */
specifier|const
name|char
modifier|*
name|unknown_mode_attr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If CODE is the number of a code macro, return a real rtx code that    has the same format.  Return CODE otherwise.  */
end_comment

begin_define
define|#
directive|define
name|BELLWETHER_CODE
parameter_list|(
name|CODE
parameter_list|)
define|\
value|((CODE)< NUM_RTX_CODE ? CODE : bellwether_codes[CODE - NUM_RTX_CODE])
end_define

begin_decl_stmt
specifier|static
name|void
name|fatal_with_file_and_line
argument_list|(
name|FILE
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
operator|...
argument_list|)
name|ATTRIBUTE_PRINTF_2
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fatal_expected_char
argument_list|(
name|FILE
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|find_mode
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|uses_mode_macro_p
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|apply_mode_macro
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_code
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|uses_code_macro_p
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|apply_code_macro
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|apply_macro_to_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|mapping
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|apply_macro_to_rtx
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|mapping
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|map_value
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|uses_macro_p
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|mapping
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|add_condition_to_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_condition_to_rtx
parameter_list|(
name|rtx
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|apply_macro_traverse
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mapping
modifier|*
name|add_mapping
parameter_list|(
name|struct
name|macro_group
modifier|*
parameter_list|,
name|htab_t
name|t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|map_value
modifier|*
modifier|*
name|add_map_value
parameter_list|(
name|struct
name|map_value
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_macros
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_name
parameter_list|(
name|char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|leading_ptr_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|leading_ptr_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_rtx_ptr_loc
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|ptr_loc
modifier|*
name|get_rtx_ptr_loc
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_string
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_quoted_string
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_braced_string
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_escape
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|def_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|def_name_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_constants
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|char
modifier|*
name|tmp_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_conditions
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|char
modifier|*
name|tmp_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validate_const_int
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_macro
parameter_list|(
name|struct
name|macro_group
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mapping
modifier|*
name|read_mapping
parameter_list|(
name|struct
name|macro_group
modifier|*
parameter_list|,
name|htab_t
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_code_macro
parameter_list|(
name|struct
name|mapping
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|read_rtx_1
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|map_value
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|read_rtx_variadic
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|struct
name|map_value
modifier|*
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The mode and code macro structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|macro_group
name|modes
decl_stmt|,
name|codes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index I is the value of BELLWETHER_CODE (I + NUM_RTX_CODE).  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|rtx_code
modifier|*
name|bellwether_codes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Obstack used for allocating RTL strings.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|string_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A table of ptr_locs, hashed on the PTR field.  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|ptr_locs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An obstack for the above.  Plain xmalloc is a bit heavyweight for a    small structure like ptr_loc.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|ptr_loc_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A hash table of triples (A, B, C), where each of A, B and C is a condition    and A is equivalent to "B&& C".  This is used to keep track of the source    of conditions that are made up of separate rtx strings (such as the split    condition of a define_insn_and_split).  */
end_comment

begin_decl_stmt
specifier|static
name|htab_t
name|joined_conditions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An obstack for allocating joined_conditions entries.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|joined_conditions_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Subroutines of read_rtx.  */
end_comment

begin_comment
comment|/* The current line number for the file.  */
end_comment

begin_decl_stmt
name|int
name|read_rtx_lineno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The filename for error reporting.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|read_rtx_filename
init|=
literal|"<unknown>"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|fatal_with_file_and_line
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|context
index|[
literal|64
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|read_rtx_filename
argument_list|,
name|read_rtx_lineno
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* Gather some following context.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|context
argument_list|)
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|context
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|context
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: following context is `%s'\n"
argument_list|,
name|read_rtx_filename
argument_list|,
name|read_rtx_lineno
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump code after printing a message.  Used when read_rtx finds    invalid data.  */
end_comment

begin_function
specifier|static
name|void
name|fatal_expected_char
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|int
name|expected_c
parameter_list|,
name|int
name|actual_c
parameter_list|)
block|{
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"expected character `%c', found `%c'"
argument_list|,
name|expected_c
argument_list|,
name|actual_c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implementations of the macro_group callbacks for modes.  */
end_comment

begin_function
specifier|static
name|int
name|find_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|GET_MODE_NAME
argument_list|(
name|i
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"unknown mode `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|uses_mode_macro_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|mode
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apply_mode_macro
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|PUT_MODE
argument_list|(
name|x
argument_list|,
operator|(
expr|enum
name|machine_mode
operator|)
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implementations of the macro_group callbacks for codes.  */
end_comment

begin_function
specifier|static
name|int
name|find_code
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|GET_RTX_NAME
argument_list|(
name|i
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"unknown rtx code `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|uses_code_macro_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
return|return
operator|(
name|int
operator|)
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|code
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apply_code_macro
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|PUT_CODE
argument_list|(
name|x
argument_list|,
operator|(
expr|enum
name|rtx_code
operator|)
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map a code or mode attribute string P to the underlying string for    MACRO and VALUE.  */
end_comment

begin_function
specifier|static
name|struct
name|map_value
modifier|*
name|map_attr_string
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|struct
name|mapping
modifier|*
name|macro
parameter_list|,
name|int
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|attr
decl_stmt|;
name|struct
name|mapping
modifier|*
name|m
decl_stmt|;
name|struct
name|map_value
modifier|*
name|v
decl_stmt|;
comment|/* If there's a "macro:" prefix, check whether the macro name matches.      Set ATTR to the start of the attribute name.  */
name|attr
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|==
literal|0
condition|)
name|attr
operator|=
name|p
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|macro
operator|->
name|name
argument_list|,
name|attr
operator|-
name|p
argument_list|)
operator|!=
literal|0
operator|||
name|macro
operator|->
name|name
index|[
name|attr
operator|-
name|p
index|]
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|attr
operator|++
expr_stmt|;
block|}
comment|/* Find the attribute specification.  */
name|m
operator|=
operator|(
expr|struct
name|mapping
operator|*
operator|)
name|htab_find
argument_list|(
name|macro
operator|->
name|group
operator|->
name|attrs
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Find the attribute value for VALUE.  */
for|for
control|(
name|v
operator|=
name|m
operator|->
name|values
init|;
name|v
operator|!=
literal|0
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
if|if
condition|(
name|v
operator|->
name|number
operator|==
name|value
condition|)
break|break;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Given an attribute string used as a machine mode, return an index    to store in the machine mode to be translated by    apply_macro_to_rtx.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|mode_attr_index
parameter_list|(
name|struct
name|map_value
modifier|*
modifier|*
name|mode_maps
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|map_value
modifier|*
name|mv
decl_stmt|;
comment|/* Copy the attribute string into permanent storage, without the      angle brackets around it.  */
name|obstack_grow0
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|string
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|mv
operator|=
name|XNEW
argument_list|(
expr|struct
name|map_value
argument_list|)
expr_stmt|;
name|mv
operator|->
name|number
operator|=
operator|*
name|mode_maps
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
operator|*
name|mode_maps
operator|)
operator|->
name|number
operator|+
literal|1
expr_stmt|;
name|mv
operator|->
name|string
operator|=
name|p
expr_stmt|;
name|mv
operator|->
name|next
operator|=
operator|*
name|mode_maps
expr_stmt|;
operator|*
name|mode_maps
operator|=
name|mv
expr_stmt|;
comment|/* We return a code which we can map back into this string: the      number of machine modes + the number of mode macros + the index      we just used.  */
return|return
name|MAX_MACHINE_MODE
operator|+
name|htab_elements
argument_list|(
name|modes
operator|.
name|macros
argument_list|)
operator|+
name|mv
operator|->
name|number
return|;
block|}
end_function

begin_comment
comment|/* Apply MODE_MAPS to the top level of X, expanding cases where an    attribute is used for a mode.  MACRO is the current macro we are    expanding, and VALUE is the value to which we are expanding it.    INFILE is used for error messages.  This sets *UNKNOWN to true if    we find a mode attribute which has not yet been defined, and does    not change it otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|apply_mode_maps
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|map_value
modifier|*
name|mode_maps
parameter_list|,
name|struct
name|mapping
modifier|*
name|macro
parameter_list|,
name|int
name|value
parameter_list|,
name|FILE
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|unknown
parameter_list|)
block|{
name|unsigned
name|int
name|offset
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|struct
name|map_value
modifier|*
name|pm
decl_stmt|;
name|offset
operator|=
name|MAX_MACHINE_MODE
operator|+
name|htab_elements
argument_list|(
name|modes
operator|.
name|macros
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|<
name|offset
condition|)
return|return;
name|indx
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|-
name|offset
expr_stmt|;
for|for
control|(
name|pm
operator|=
name|mode_maps
init|;
name|pm
condition|;
name|pm
operator|=
name|pm
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pm
operator|->
name|number
operator|==
name|indx
condition|)
block|{
name|struct
name|map_value
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|map_attr_string
argument_list|(
name|pm
operator|->
name|string
argument_list|,
name|macro
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|PUT_MODE
argument_list|(
name|x
argument_list|,
operator|(
expr|enum
name|machine_mode
operator|)
name|find_mode
argument_list|(
name|v
operator|->
name|string
argument_list|,
name|infile
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|unknown
operator|=
name|pm
operator|->
name|string
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Given that MACRO is being expanded as VALUE, apply the appropriate    string substitutions to STRING.  Return the new string if any changes    were needed, otherwise return STRING itself.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|apply_macro_to_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|struct
name|mapping
modifier|*
name|macro
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|copy
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|map_value
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|string
operator|==
literal|0
condition|)
return|return
name|string
return|;
name|base
operator|=
name|p
operator|=
name|copy
operator|=
name|ASTRDUP
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|start
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|&&
operator|(
name|end
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|'>'
argument_list|)
operator|)
condition|)
block|{
name|p
operator|=
name|start
operator|+
literal|1
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|map_attr_string
argument_list|(
name|p
argument_list|,
name|macro
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
literal|'>'
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
continue|continue;
comment|/* Add everything between the last copied byte and the '<', 	 then add in the attribute value.  */
name|obstack_grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|base
argument_list|,
name|start
operator|-
name|base
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|v
operator|->
name|string
argument_list|,
name|strlen
argument_list|(
name|v
operator|->
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
name|end
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|!=
name|copy
condition|)
block|{
name|obstack_grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|base
argument_list|,
name|strlen
argument_list|(
name|base
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|copy
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|copy_rtx_ptr_loc
argument_list|(
name|copy
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/* Return a copy of ORIGINAL in which all uses of MACRO have been    replaced by VALUE.  MODE_MAPS holds information about attribute    strings used for modes.  INFILE is used for error messages.  This    sets *UNKNOWN_MODE_ATTR to the value of an unknown mode attribute,    and does not change it otherwise.  */
end_comment

begin_function
specifier|static
name|rtx
name|apply_macro_to_rtx
parameter_list|(
name|rtx
name|original
parameter_list|,
name|struct
name|mapping
modifier|*
name|macro
parameter_list|,
name|int
name|value
parameter_list|,
name|struct
name|map_value
modifier|*
name|mode_maps
parameter_list|,
name|FILE
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|unknown_mode_attr
parameter_list|)
block|{
name|struct
name|macro_group
modifier|*
name|group
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|enum
name|rtx_code
name|bellwether_code
decl_stmt|;
if|if
condition|(
name|original
operator|==
literal|0
condition|)
return|return
name|original
return|;
comment|/* Create a shallow copy of ORIGINAL.  */
name|bellwether_code
operator|=
name|BELLWETHER_CODE
argument_list|(
name|GET_CODE
argument_list|(
name|original
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|rtx_alloc
argument_list|(
name|bellwether_code
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|x
argument_list|,
name|original
argument_list|,
name|RTX_CODE_SIZE
argument_list|(
name|bellwether_code
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Change the mode or code itself.  */
name|group
operator|=
name|macro
operator|->
name|group
expr_stmt|;
if|if
condition|(
name|group
operator|->
name|uses_macro_p
argument_list|(
name|x
argument_list|,
name|macro
operator|->
name|index
operator|+
name|group
operator|->
name|num_builtins
argument_list|)
condition|)
name|group
operator|->
name|apply_macro
argument_list|(
name|x
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_maps
condition|)
name|apply_mode_maps
argument_list|(
name|x
argument_list|,
name|mode_maps
argument_list|,
name|macro
argument_list|,
name|value
argument_list|,
name|infile
argument_list|,
name|unknown_mode_attr
argument_list|)
expr_stmt|;
comment|/* Change each string and recursively change each rtx.  */
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|bellwether_code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|format_ptr
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|format_ptr
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'T'
case|:
name|XTMPL
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|apply_macro_to_string
argument_list|(
name|XTMPL
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|macro
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|apply_macro_to_string
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|macro
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|apply_macro_to_rtx
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|macro
argument_list|,
name|value
argument_list|,
name|mode_maps
argument_list|,
name|infile
argument_list|,
name|unknown_mode_attr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|original
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|=
name|rtvec_alloc
argument_list|(
name|XVECLEN
argument_list|(
name|original
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|=
name|apply_macro_to_rtx
argument_list|(
name|XVECEXP
argument_list|(
name|original
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|macro
argument_list|,
name|value
argument_list|,
name|mode_maps
argument_list|,
name|infile
argument_list|,
name|unknown_mode_attr
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Return true if X (or some subexpression of X) uses macro MACRO.  */
end_comment

begin_function
specifier|static
name|bool
name|uses_macro_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|struct
name|mapping
modifier|*
name|macro
parameter_list|)
block|{
name|struct
name|macro_group
modifier|*
name|group
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|false
return|;
name|group
operator|=
name|macro
operator|->
name|group
expr_stmt|;
if|if
condition|(
name|group
operator|->
name|uses_macro_p
argument_list|(
name|x
argument_list|,
name|macro
operator|->
name|index
operator|+
name|group
operator|->
name|num_builtins
argument_list|)
condition|)
return|return
name|true
return|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|BELLWETHER_CODE
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|format_ptr
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|format_ptr
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|uses_macro_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|macro
argument_list|)
condition|)
return|return
name|true
return|;
break|break;
case|case
literal|'V'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|XVEC
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|uses_macro_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|macro
argument_list|)
condition|)
return|return
name|true
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return a condition that must satisfy both ORIGINAL and EXTRA.  If ORIGINAL    has the form "&& ..." (as used in define_insn_and_splits), assume that    EXTRA is already satisfied.  Empty strings are treated like "true".  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|add_condition_to_string
parameter_list|(
specifier|const
name|char
modifier|*
name|original
parameter_list|,
specifier|const
name|char
modifier|*
name|extra
parameter_list|)
block|{
if|if
condition|(
name|original
operator|!=
literal|0
operator|&&
name|original
index|[
literal|0
index|]
operator|==
literal|'&'
operator|&&
name|original
index|[
literal|1
index|]
operator|==
literal|'&'
condition|)
return|return
name|original
return|;
return|return
name|join_c_conditions
argument_list|(
name|original
argument_list|,
name|extra
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like add_condition, but applied to all conditions in rtx X.  */
end_comment

begin_function
specifier|static
name|void
name|add_condition_to_rtx
parameter_list|(
name|rtx
name|x
parameter_list|,
specifier|const
name|char
modifier|*
name|extra
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|DEFINE_INSN
case|:
case|case
name|DEFINE_EXPAND
case|:
name|XSTR
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|add_condition_to_string
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|extra
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_SPLIT
case|:
case|case
name|DEFINE_PEEPHOLE
case|:
case|case
name|DEFINE_PEEPHOLE2
case|:
case|case
name|DEFINE_COND_EXEC
case|:
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|add_condition_to_string
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|extra
argument_list|)
expr_stmt|;
break|break;
case|case
name|DEFINE_INSN_AND_SPLIT
case|:
name|XSTR
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
operator|=
name|add_condition_to_string
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
name|extra
argument_list|)
expr_stmt|;
name|XSTR
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
operator|=
name|add_condition_to_string
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
literal|4
argument_list|)
argument_list|,
name|extra
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* A htab_traverse callback.  Search the EXPR_LIST given by DATA    for rtxes that use the macro in *SLOT.  Replace each such rtx    with a list of expansions.  */
end_comment

begin_function
specifier|static
name|int
name|apply_macro_traverse
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|macro_traverse_data
modifier|*
name|mtd
init|=
operator|(
expr|struct
name|macro_traverse_data
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|mapping
modifier|*
name|macro
decl_stmt|;
name|struct
name|map_value
modifier|*
name|v
decl_stmt|;
name|rtx
name|elem
decl_stmt|,
name|new_elem
decl_stmt|,
name|original
decl_stmt|,
name|x
decl_stmt|;
name|macro
operator|=
operator|(
expr|struct
name|mapping
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|mtd
operator|->
name|queue
init|;
name|elem
operator|!=
literal|0
condition|;
name|elem
operator|=
name|XEXP
argument_list|(
name|elem
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|uses_macro_p
argument_list|(
name|XEXP
argument_list|(
name|elem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|macro
argument_list|)
condition|)
block|{
comment|/* For each macro we expand, we set UNKNOWN_MODE_ATTR to NULL. 	   If apply_macro_rtx finds an unknown attribute for a mode, 	   it will set it to the attribute.  We want to know whether 	   the attribute is unknown after we have expanded all 	   possible macros, so setting it to NULL here gives us the 	   right result when the hash table traversal is complete.  */
name|mtd
operator|->
name|unknown_mode_attr
operator|=
name|NULL
expr_stmt|;
name|original
operator|=
name|XEXP
argument_list|(
name|elem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|v
operator|=
name|macro
operator|->
name|values
init|;
name|v
operator|!=
literal|0
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
block|{
name|x
operator|=
name|apply_macro_to_rtx
argument_list|(
name|original
argument_list|,
name|macro
argument_list|,
name|v
operator|->
name|number
argument_list|,
name|mtd
operator|->
name|mode_maps
argument_list|,
name|mtd
operator|->
name|infile
argument_list|,
operator|&
name|mtd
operator|->
name|unknown_mode_attr
argument_list|)
expr_stmt|;
name|add_condition_to_rtx
argument_list|(
name|x
argument_list|,
name|v
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|macro
operator|->
name|values
condition|)
block|{
comment|/* Insert a new EXPR_LIST node after ELEM and put the 		   new expansion there.  */
name|new_elem
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|new_elem
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|elem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|elem
argument_list|,
literal|1
argument_list|)
operator|=
name|new_elem
expr_stmt|;
name|elem
operator|=
name|new_elem
expr_stmt|;
block|}
name|XEXP
argument_list|(
name|elem
argument_list|,
literal|0
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add a new "mapping" structure to hashtable TABLE.  NAME is the name    of the mapping, GROUP is the group to which it belongs, and INFILE    is the file that defined the mapping.  */
end_comment

begin_function
specifier|static
name|struct
name|mapping
modifier|*
name|add_mapping
parameter_list|(
name|struct
name|macro_group
modifier|*
name|group
parameter_list|,
name|htab_t
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|struct
name|mapping
modifier|*
name|m
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|m
operator|=
name|XNEW
argument_list|(
expr|struct
name|mapping
argument_list|)
expr_stmt|;
name|m
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|m
operator|->
name|group
operator|=
name|group
expr_stmt|;
name|m
operator|->
name|index
operator|=
name|htab_elements
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|m
operator|->
name|values
operator|=
literal|0
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|table
argument_list|,
name|m
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|!=
literal|0
condition|)
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"`%s' already defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|m
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* Add the pair (NUMBER, STRING) to a list of map_value structures.    END_PTR points to the current null terminator for the list; return    a pointer the new null terminator.  */
end_comment

begin_function
specifier|static
name|struct
name|map_value
modifier|*
modifier|*
name|add_map_value
parameter_list|(
name|struct
name|map_value
modifier|*
modifier|*
name|end_ptr
parameter_list|,
name|int
name|number
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|map_value
modifier|*
name|value
decl_stmt|;
name|value
operator|=
name|XNEW
argument_list|(
expr|struct
name|map_value
argument_list|)
expr_stmt|;
name|value
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|value
operator|->
name|number
operator|=
name|number
expr_stmt|;
name|value
operator|->
name|string
operator|=
name|string
expr_stmt|;
operator|*
name|end_ptr
operator|=
name|value
expr_stmt|;
return|return
operator|&
name|value
operator|->
name|next
return|;
block|}
end_function

begin_comment
comment|/* Do one-time initialization of the mode and code attributes.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_macros
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mapping
modifier|*
name|lower
decl_stmt|,
modifier|*
name|upper
decl_stmt|;
name|struct
name|map_value
modifier|*
modifier|*
name|lower_ptr
decl_stmt|,
modifier|*
modifier|*
name|upper_ptr
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|modes
operator|.
name|attrs
operator|=
name|htab_create
argument_list|(
literal|13
argument_list|,
name|def_hash
argument_list|,
name|def_name_eq_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|modes
operator|.
name|macros
operator|=
name|htab_create
argument_list|(
literal|13
argument_list|,
name|def_hash
argument_list|,
name|def_name_eq_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|modes
operator|.
name|num_builtins
operator|=
name|MAX_MACHINE_MODE
expr_stmt|;
name|modes
operator|.
name|find_builtin
operator|=
name|find_mode
expr_stmt|;
name|modes
operator|.
name|uses_macro_p
operator|=
name|uses_mode_macro_p
expr_stmt|;
name|modes
operator|.
name|apply_macro
operator|=
name|apply_mode_macro
expr_stmt|;
name|codes
operator|.
name|attrs
operator|=
name|htab_create
argument_list|(
literal|13
argument_list|,
name|def_hash
argument_list|,
name|def_name_eq_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|codes
operator|.
name|macros
operator|=
name|htab_create
argument_list|(
literal|13
argument_list|,
name|def_hash
argument_list|,
name|def_name_eq_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|codes
operator|.
name|num_builtins
operator|=
name|NUM_RTX_CODE
expr_stmt|;
name|codes
operator|.
name|find_builtin
operator|=
name|find_code
expr_stmt|;
name|codes
operator|.
name|uses_macro_p
operator|=
name|uses_code_macro_p
expr_stmt|;
name|codes
operator|.
name|apply_macro
operator|=
name|apply_code_macro
expr_stmt|;
name|lower
operator|=
name|add_mapping
argument_list|(
operator|&
name|modes
argument_list|,
name|modes
operator|.
name|attrs
argument_list|,
literal|"mode"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|upper
operator|=
name|add_mapping
argument_list|(
operator|&
name|modes
argument_list|,
name|modes
operator|.
name|attrs
argument_list|,
literal|"MODE"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lower_ptr
operator|=
operator|&
name|lower
operator|->
name|values
expr_stmt|;
name|upper_ptr
operator|=
operator|&
name|upper
operator|->
name|values
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MACHINE_MODE
condition|;
name|i
operator|++
control|)
block|{
name|copy
operator|=
name|xstrdup
argument_list|(
name|GET_MODE_NAME
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|copy
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|TOLOWER
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|upper_ptr
operator|=
name|add_map_value
argument_list|(
name|upper_ptr
argument_list|,
name|i
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|lower_ptr
operator|=
name|add_map_value
argument_list|(
name|lower_ptr
argument_list|,
name|i
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
name|lower
operator|=
name|add_mapping
argument_list|(
operator|&
name|codes
argument_list|,
name|codes
operator|.
name|attrs
argument_list|,
literal|"code"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|upper
operator|=
name|add_mapping
argument_list|(
operator|&
name|codes
argument_list|,
name|codes
operator|.
name|attrs
argument_list|,
literal|"CODE"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lower_ptr
operator|=
operator|&
name|lower
operator|->
name|values
expr_stmt|;
name|upper_ptr
operator|=
operator|&
name|upper
operator|->
name|values
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_RTX_CODE
condition|;
name|i
operator|++
control|)
block|{
name|copy
operator|=
name|xstrdup
argument_list|(
name|GET_RTX_NAME
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|copy
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
operator|*
name|p
operator|=
name|TOUPPER
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|lower_ptr
operator|=
name|add_map_value
argument_list|(
name|lower_ptr
argument_list|,
name|i
argument_list|,
name|GET_RTX_NAME
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|upper_ptr
operator|=
name|add_map_value
argument_list|(
name|upper_ptr
argument_list|,
name|i
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a hash value for the pointer pointed to by DEF.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|leading_ptr_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|def
parameter_list|)
block|{
return|return
name|htab_hash_pointer
argument_list|(
operator|*
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|def
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if DEF1 and DEF2 are pointers to the same pointer.  */
end_comment

begin_function
specifier|static
name|int
name|leading_ptr_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
name|def1
parameter_list|,
specifier|const
name|void
modifier|*
name|def2
parameter_list|)
block|{
return|return
operator|*
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|def1
operator|==
operator|*
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|def2
return|;
block|}
end_function

begin_comment
comment|/* Associate PTR with the file position given by FILENAME and LINENO.  */
end_comment

begin_function
specifier|static
name|void
name|set_rtx_ptr_loc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|struct
name|ptr_loc
modifier|*
name|loc
decl_stmt|;
name|loc
operator|=
operator|(
expr|struct
name|ptr_loc
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|ptr_loc_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ptr_loc
argument_list|)
argument_list|)
expr_stmt|;
name|loc
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|loc
operator|->
name|filename
operator|=
name|filename
expr_stmt|;
name|loc
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
operator|*
name|htab_find_slot
argument_list|(
name|ptr_locs
argument_list|,
name|loc
argument_list|,
name|INSERT
argument_list|)
operator|=
name|loc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the position associated with pointer PTR.  Return null if no    position was set.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|ptr_loc
modifier|*
name|get_rtx_ptr_loc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
specifier|const
expr|struct
name|ptr_loc
operator|*
operator|)
name|htab_find
argument_list|(
name|ptr_locs
argument_list|,
operator|&
name|ptr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Associate NEW_PTR with the same file position as OLD_PTR.  */
end_comment

begin_function
name|void
name|copy_rtx_ptr_loc
parameter_list|(
specifier|const
name|void
modifier|*
name|new_ptr
parameter_list|,
specifier|const
name|void
modifier|*
name|old_ptr
parameter_list|)
block|{
specifier|const
name|struct
name|ptr_loc
modifier|*
name|loc
init|=
name|get_rtx_ptr_loc
argument_list|(
name|old_ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|loc
operator|!=
literal|0
condition|)
name|set_rtx_ptr_loc
argument_list|(
name|new_ptr
argument_list|,
name|loc
operator|->
name|filename
argument_list|,
name|loc
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If PTR is associated with a known file position, print a #line    directive for it.  */
end_comment

begin_function
name|void
name|print_rtx_ptr_loc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
specifier|const
name|struct
name|ptr_loc
modifier|*
name|loc
init|=
name|get_rtx_ptr_loc
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|loc
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"#line %d \"%s\"\n"
argument_list|,
name|loc
operator|->
name|lineno
argument_list|,
name|loc
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a condition that satisfies both COND1 and COND2.  Either string    may be null or empty.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|join_c_conditions
parameter_list|(
specifier|const
name|char
modifier|*
name|cond1
parameter_list|,
specifier|const
name|char
modifier|*
name|cond2
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
specifier|const
name|void
modifier|*
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|cond1
operator|==
literal|0
operator|||
name|cond1
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
name|cond2
return|;
if|if
condition|(
name|cond2
operator|==
literal|0
operator|||
name|cond2
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
name|cond1
return|;
name|result
operator|=
name|concat
argument_list|(
literal|"("
argument_list|,
name|cond1
argument_list|,
literal|")&& ("
argument_list|,
name|cond2
argument_list|,
literal|")"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|joined_conditions_obstack
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|joined_conditions_obstack
argument_list|,
name|cond1
argument_list|)
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|joined_conditions_obstack
argument_list|,
name|cond2
argument_list|)
expr_stmt|;
name|entry
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|joined_conditions_obstack
argument_list|,
specifier|const
name|void
operator|*
operator|*
argument_list|)
expr_stmt|;
operator|*
name|htab_find_slot
argument_list|(
name|joined_conditions
argument_list|,
name|entry
argument_list|,
name|INSERT
argument_list|)
operator|=
name|entry
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Print condition COND, wrapped in brackets.  If COND was created by    join_c_conditions, recursively invoke this function for the original    conditions and join the result with "&&".  Otherwise print a #line    directive for COND if its original file position is known.  */
end_comment

begin_function
name|void
name|print_c_condition
parameter_list|(
specifier|const
name|char
modifier|*
name|cond
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|halves
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|htab_find
argument_list|(
name|joined_conditions
argument_list|,
operator|&
name|cond
argument_list|)
decl_stmt|;
if|if
condition|(
name|halves
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
name|print_c_condition
argument_list|(
name|halves
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"&& "
argument_list|)
expr_stmt|;
name|print_c_condition
argument_list|(
name|halves
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_rtx_ptr_loc
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read chars from INFILE until a non-whitespace char    and return that.  Comments, both Lisp style and C style,    are treated as whitespace.    Tools such as genflags use this function.  */
end_comment

begin_function
name|int
name|read_skip_spaces
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|read_rtx_lineno
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
break|break;
case|case
literal|';'
case|:
do|do
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
do|;
name|read_rtx_lineno
operator|++
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
block|{
name|int
name|prevc
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'*'
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|'*'
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|prevc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
operator|)
operator|&&
name|c
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|read_rtx_lineno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|prevc
operator|==
literal|'*'
operator|&&
name|c
operator|==
literal|'/'
condition|)
break|break;
name|prevc
operator|=
name|c
expr_stmt|;
block|}
block|}
break|break;
default|default:
return|return
name|c
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read an rtx code name into the buffer STR[].    It is terminated by any of the punctuation chars of rtx printed syntax.  */
end_comment

begin_function
specifier|static
name|void
name|read_name
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|p
operator|=
name|str
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\f'
operator|||
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|':'
operator|||
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|']'
operator|||
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'/'
operator|||
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|'['
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|str
condition|)
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"missing name or number"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|read_rtx_lineno
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|md_constants
condition|)
block|{
comment|/* Do constant expansion.  */
name|struct
name|md_constant
modifier|*
name|def
decl_stmt|;
name|p
operator|=
name|str
expr_stmt|;
do|do
block|{
name|struct
name|md_constant
name|tmp_def
decl_stmt|;
name|tmp_def
operator|.
name|name
operator|=
name|p
expr_stmt|;
name|def
operator|=
operator|(
expr|struct
name|md_constant
operator|*
operator|)
name|htab_find
argument_list|(
name|md_constants
argument_list|,
operator|&
name|tmp_def
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
condition|)
name|p
operator|=
name|def
operator|->
name|value
expr_stmt|;
block|}
do|while
condition|(
name|def
condition|)
do|;
if|if
condition|(
name|p
operator|!=
name|str
condition|)
name|strcpy
argument_list|(
name|str
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine of the string readers.  Handles backslash escapes.    Caller has read the backslash, but not placed it into the obstack.  */
end_comment

begin_function
specifier|static
name|void
name|read_escape
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|int
name|c
init|=
name|getc
argument_list|(
name|infile
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* Backslash-newline is replaced by nothing, as in C.  */
case|case
literal|'\n'
case|:
name|read_rtx_lineno
operator|++
expr_stmt|;
return|return;
comment|/* \" \' \\ are replaced by the second character.  */
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
break|break;
comment|/* Standard C string escapes: 	 \a \b \f \n \r \t \v 	 \[0-7] \x 	 all are passed through to the output string unmolested. 	 In normal use these wind up in a string constant processed 	 by the C compiler, which will translate them appropriately. 	 We do not bother checking that \[0-7] are followed by up to 	 two octal digits, or that \x is followed by N hex digits. 	 \? \u \U are left out because they are not in traditional C.  */
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'f'
case|:
case|case
literal|'n'
case|:
case|case
literal|'r'
case|:
case|case
literal|'t'
case|:
case|case
literal|'v'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'x'
case|:
name|obstack_1grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
comment|/* \; makes stuff for a C string constant containing 	 newline and tab.  */
case|case
literal|';'
case|:
name|obstack_grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
literal|"\\n\\t"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return;
comment|/* pass anything else through, but issue a warning.  */
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: warning: unrecognized escape \\%c\n"
argument_list|,
name|read_rtx_filename
argument_list|,
name|read_rtx_lineno
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
break|break;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a double-quoted string onto the obstack.  Caller has scanned    the leading quote.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_quoted_string
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Read the string  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|read_rtx_lineno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|read_escape
argument_list|(
name|infile
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
name|EOF
condition|)
break|break;
name|obstack_1grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XOBFINISH
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|char
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a braced string (a la Tcl) onto the string obstack.  Caller    has scanned the leading brace.  Note that unlike quoted strings,    the outermost braces _are_ included in the string constant.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_braced_string
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|brace_depth
init|=
literal|1
decl_stmt|;
comment|/* caller-processed */
name|unsigned
name|long
name|starting_read_rtx_lineno
init|=
name|read_rtx_lineno
decl_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
literal|'{'
argument_list|)
expr_stmt|;
while|while
condition|(
name|brace_depth
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Read the string  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|read_rtx_lineno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|brace_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|brace_depth
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|read_escape
argument_list|(
name|infile
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"missing closing } for opening brace on line %lu"
argument_list|,
name|starting_read_rtx_lineno
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|XOBFINISH
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|char
operator|*
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read some kind of string constant.  This is the high-level routine    used by read_rtx.  It handles surrounding parentheses, leading star,    and dispatch to the appropriate string constant reader.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_string
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|int
name|star_if_braced
parameter_list|)
block|{
name|char
modifier|*
name|stringbuf
decl_stmt|;
name|int
name|saw_paren
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|,
name|old_lineno
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|saw_paren
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
name|old_lineno
operator|=
name|read_rtx_lineno
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
name|stringbuf
operator|=
name|read_quoted_string
argument_list|(
name|infile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
if|if
condition|(
name|star_if_braced
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|stringbuf
operator|=
name|read_braced_string
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"expected `\"' or `{', found `%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|saw_paren
condition|)
block|{
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|')'
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|set_rtx_ptr_loc
argument_list|(
name|stringbuf
argument_list|,
name|read_rtx_filename
argument_list|,
name|old_lineno
argument_list|)
expr_stmt|;
return|return
name|stringbuf
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Provide a version of a function to read a long long if the system does    not provide one.  */
end_comment

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>
name|HOST_BITS_PER_LONG
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ATOLL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ATOQ
argument_list|)
end_if

begin_function_decl
name|HOST_WIDE_INT
name|atoll
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|HOST_WIDE_INT
name|atoll
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|neg
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|tmp_wide
decl_stmt|;
while|while
condition|(
name|ISSPACE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
name|neg
operator|=
literal|1
operator|,
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
name|tmp_wide
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|new_wide
init|=
name|tmp_wide
operator|*
literal|10
operator|+
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
decl_stmt|;
if|if
condition|(
name|new_wide
operator|<
name|tmp_wide
condition|)
block|{
comment|/* Return INT_MAX equiv on overflow.  */
name|tmp_wide
operator|=
operator|(
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
operator|)
operator|>>
literal|1
expr_stmt|;
break|break;
block|}
name|tmp_wide
operator|=
name|new_wide
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|neg
condition|)
name|tmp_wide
operator|=
operator|-
name|tmp_wide
expr_stmt|;
return|return
name|tmp_wide
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Given an object that starts with a char * name field, return a hash    code for its name.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|def_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|def
parameter_list|)
block|{
name|unsigned
name|result
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
init|=
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|def
decl_stmt|;
for|for
control|(
name|result
operator|=
name|i
operator|=
literal|0
init|;
operator|*
name|string
operator|++
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
name|result
operator|+=
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|string
operator|<<
operator|(
name|i
operator|%
name|CHAR_BIT
operator|)
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Given two objects that start with char * name fields, return true if    they have the same name.  */
end_comment

begin_function
specifier|static
name|int
name|def_name_eq_p
parameter_list|(
specifier|const
name|void
modifier|*
name|def1
parameter_list|,
specifier|const
name|void
modifier|*
name|def2
parameter_list|)
block|{
return|return
operator|!
name|strcmp
argument_list|(
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|def1
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|def2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* INFILE is a FILE pointer to read text from.  TMP_CHAR is a buffer suitable    to read a name or number into.  Process a define_constants directive,    starting with the optional space after the "define_constants".  */
end_comment

begin_function
specifier|static
name|void
name|read_constants
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|char
modifier|*
name|tmp_char
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|htab_t
name|defs
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'['
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|'['
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|defs
operator|=
name|md_constants
expr_stmt|;
if|if
condition|(
operator|!
name|defs
condition|)
name|defs
operator|=
name|htab_create
argument_list|(
literal|32
argument_list|,
name|def_hash
argument_list|,
name|def_name_eq_p
argument_list|,
operator|(
name|htab_del
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable constant expansion during definition processing.  */
name|md_constants
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|']'
condition|)
block|{
name|struct
name|md_constant
modifier|*
name|def
decl_stmt|;
name|void
modifier|*
modifier|*
name|entry_ptr
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|'('
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|def
operator|=
name|XNEW
argument_list|(
expr|struct
name|md_constant
argument_list|)
expr_stmt|;
name|def
operator|->
name|name
operator|=
name|tmp_char
expr_stmt|;
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|entry_ptr
operator|=
name|htab_find_slot
argument_list|(
name|defs
argument_list|,
name|def
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|entry_ptr
condition|)
name|def
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|entry_ptr
condition|)
block|{
name|def
operator|->
name|value
operator|=
name|xstrdup
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
operator|*
name|entry_ptr
operator|=
name|def
expr_stmt|;
block|}
else|else
block|{
name|def
operator|=
operator|(
expr|struct
name|md_constant
operator|*
operator|)
operator|*
name|entry_ptr
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|def
operator|->
name|value
argument_list|,
name|tmp_char
argument_list|)
condition|)
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"redefinition of %s, was %s, now %s"
argument_list|,
name|def
operator|->
name|name
argument_list|,
name|def
operator|->
name|value
argument_list|,
name|tmp_char
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|')'
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|md_constants
operator|=
name|defs
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|')'
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For every constant definition, call CALLBACK with two arguments:    a pointer a pointer to the constant definition and INFO.    Stops when CALLBACK returns zero.  */
end_comment

begin_function
name|void
name|traverse_md_constants
parameter_list|(
name|htab_trav
name|callback
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|md_constants
condition|)
name|htab_traverse
argument_list|(
name|md_constants
argument_list|,
name|callback
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INFILE is a FILE pointer to read text from.  TMP_CHAR is a buffer    suitable to read a name or number into.  Process a    define_conditions directive, starting with the optional space after    the "define_conditions".  The directive looks like this:       (define_conditions [         (number "string")         (number "string")         ...      ])     It's not intended to appear in machine descriptions.  It is    generated by (the program generated by) genconditions.c, and    slipped in at the beginning of the sequence of MD files read by    most of the other generators.  */
end_comment

begin_function
specifier|static
name|void
name|read_conditions
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|char
modifier|*
name|tmp_char
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'['
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|'['
argument_list|,
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
operator|)
operator|!=
literal|']'
condition|)
block|{
name|char
modifier|*
name|expr
decl_stmt|;
name|int
name|value
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|'('
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|validate_const_int
argument_list|(
name|infile
argument_list|,
name|tmp_char
argument_list|)
expr_stmt|;
name|value
operator|=
name|atoi
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'"'
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|'"'
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|expr
operator|=
name|read_quoted_string
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|')'
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|add_c_test
argument_list|(
name|expr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|')'
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|validate_const_int
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|valid
init|=
literal|1
decl_stmt|;
name|cp
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
name|ISSPACE
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'-'
operator|||
operator|*
name|cp
operator|==
literal|'+'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
name|valid
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"invalid decimal constant \"%s\"\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search GROUP for a mode or code called NAME and return its numerical    identifier.  INFILE is the file that contained NAME.  */
end_comment

begin_function
specifier|static
name|int
name|find_macro
parameter_list|(
name|struct
name|macro_group
modifier|*
name|group
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|struct
name|mapping
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mapping
operator|*
operator|)
name|htab_find
argument_list|(
name|group
operator|->
name|macros
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
literal|0
condition|)
return|return
name|m
operator|->
name|index
operator|+
name|group
operator|->
name|num_builtins
return|;
return|return
name|group
operator|->
name|find_builtin
argument_list|(
name|name
argument_list|,
name|infile
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Finish reading a declaration of the form:         (define...<name> [<value1> ...<valuen>])     from INFILE, where each<valuei> is either a bare symbol name or a    "(<name><string>)" pair.  The "(define..." part has already been read.     Represent the declaration as a "mapping" structure; add it to TABLE    (which belongs to GROUP) and return it.  */
end_comment

begin_function
specifier|static
name|struct
name|mapping
modifier|*
name|read_mapping
parameter_list|(
name|struct
name|macro_group
modifier|*
name|group
parameter_list|,
name|htab_t
name|table
parameter_list|,
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|char
name|tmp_char
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|mapping
modifier|*
name|m
decl_stmt|;
name|struct
name|map_value
modifier|*
modifier|*
name|end_ptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|number
decl_stmt|,
name|c
decl_stmt|;
comment|/* Read the mapping name and create a structure for it.  */
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|m
operator|=
name|add_mapping
argument_list|(
name|group
argument_list|,
name|table
argument_list|,
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'['
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|'['
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Read each value.  */
name|end_ptr
operator|=
operator|&
name|m
operator|->
name|values
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
block|{
comment|/* A bare symbol name that is implicitly paired to an 	     empty string.  */
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|string
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
comment|/* A "(name string)" pair.  */
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|string
operator|=
name|read_string
argument_list|(
name|infile
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|')'
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|number
operator|=
name|group
operator|->
name|find_builtin
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|end_ptr
operator|=
name|add_map_value
argument_list|(
name|end_ptr
argument_list|,
name|number
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|']'
condition|)
do|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|')'
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* Check newly-created code macro MACRO to see whether every code has the    same format.  Initialize the macro's entry in bellwether_codes.  */
end_comment

begin_function
specifier|static
name|void
name|check_code_macro
parameter_list|(
name|struct
name|mapping
modifier|*
name|macro
parameter_list|,
name|FILE
modifier|*
name|infile
parameter_list|)
block|{
name|struct
name|map_value
modifier|*
name|v
decl_stmt|;
name|enum
name|rtx_code
name|bellwether
decl_stmt|;
name|bellwether
operator|=
operator|(
expr|enum
name|rtx_code
operator|)
name|macro
operator|->
name|values
operator|->
name|number
expr_stmt|;
for|for
control|(
name|v
operator|=
name|macro
operator|->
name|values
operator|->
name|next
init|;
name|v
operator|!=
literal|0
condition|;
name|v
operator|=
name|v
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|GET_RTX_FORMAT
argument_list|(
name|bellwether
argument_list|)
argument_list|,
name|GET_RTX_FORMAT
argument_list|(
name|v
operator|->
name|number
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"code macro `%s' combines "
literal|"different rtx formats"
argument_list|,
name|macro
operator|->
name|name
argument_list|)
expr_stmt|;
name|bellwether_codes
operator|=
name|XRESIZEVEC
argument_list|(
expr|enum
name|rtx_code
argument_list|,
name|bellwether_codes
argument_list|,
name|macro
operator|->
name|index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bellwether_codes
index|[
name|macro
operator|->
name|index
index|]
operator|=
name|bellwether
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read an rtx in printed representation from INFILE and store its    core representation in *X.  Also store the line number of the    opening '(' in *LINENO.  Return true on success or false if the    end of file has been reached.     read_rtx is not used in the compiler proper, but rather in    the utilities gen*.c that construct C code from machine descriptions.  */
end_comment

begin_function
name|bool
name|read_rtx
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|rtx
modifier|*
name|x
parameter_list|,
name|int
modifier|*
name|lineno
parameter_list|)
block|{
specifier|static
name|rtx
name|queue_head
decl_stmt|,
name|queue_next
decl_stmt|;
specifier|static
name|int
name|queue_lineno
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* Do one-time initialization.  */
if|if
condition|(
name|queue_head
operator|==
literal|0
condition|)
block|{
name|initialize_macros
argument_list|()
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|string_obstack
argument_list|)
expr_stmt|;
name|queue_head
operator|=
name|rtx_alloc
argument_list|(
name|EXPR_LIST
argument_list|)
expr_stmt|;
name|ptr_locs
operator|=
name|htab_create
argument_list|(
literal|161
argument_list|,
name|leading_ptr_hash
argument_list|,
name|leading_ptr_eq_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|ptr_loc_obstack
argument_list|)
expr_stmt|;
name|joined_conditions
operator|=
name|htab_create
argument_list|(
literal|161
argument_list|,
name|leading_ptr_hash
argument_list|,
name|leading_ptr_eq_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|joined_conditions_obstack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queue_next
operator|==
literal|0
condition|)
block|{
name|struct
name|map_value
modifier|*
name|mode_maps
decl_stmt|;
name|struct
name|macro_traverse_data
name|mtd
decl_stmt|;
name|rtx
name|from_file
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
name|false
return|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|queue_lineno
operator|=
name|read_rtx_lineno
expr_stmt|;
name|mode_maps
operator|=
literal|0
expr_stmt|;
name|from_file
operator|=
name|read_rtx_1
argument_list|(
name|infile
argument_list|,
operator|&
name|mode_maps
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_file
operator|==
literal|0
condition|)
return|return
name|false
return|;
comment|/* This confuses a top level (nil) with end of 			  file, but a top level (nil) would have 			  crashed our caller anyway.  */
name|queue_next
operator|=
name|queue_head
expr_stmt|;
name|XEXP
argument_list|(
name|queue_next
argument_list|,
literal|0
argument_list|)
operator|=
name|from_file
expr_stmt|;
name|XEXP
argument_list|(
name|queue_next
argument_list|,
literal|1
argument_list|)
operator|=
literal|0
expr_stmt|;
name|mtd
operator|.
name|queue
operator|=
name|queue_next
expr_stmt|;
name|mtd
operator|.
name|mode_maps
operator|=
name|mode_maps
expr_stmt|;
name|mtd
operator|.
name|infile
operator|=
name|infile
expr_stmt|;
name|mtd
operator|.
name|unknown_mode_attr
operator|=
name|mode_maps
condition|?
name|mode_maps
operator|->
name|string
else|:
name|NULL
expr_stmt|;
name|htab_traverse
argument_list|(
name|modes
operator|.
name|macros
argument_list|,
name|apply_macro_traverse
argument_list|,
operator|&
name|mtd
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|codes
operator|.
name|macros
argument_list|,
name|apply_macro_traverse
argument_list|,
operator|&
name|mtd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtd
operator|.
name|unknown_mode_attr
condition|)
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"undefined attribute '%s' used for mode"
argument_list|,
name|mtd
operator|.
name|unknown_mode_attr
argument_list|)
expr_stmt|;
block|}
operator|*
name|x
operator|=
name|XEXP
argument_list|(
name|queue_next
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|lineno
operator|=
name|queue_lineno
expr_stmt|;
name|queue_next
operator|=
name|XEXP
argument_list|(
name|queue_next
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of read_rtx that reads one construct from INFILE but    doesn't apply any macros.  */
end_comment

begin_function
specifier|static
name|rtx
name|read_rtx_1
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|struct
name|map_value
modifier|*
modifier|*
name|mode_maps
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|RTX_CODE
name|real_code
decl_stmt|,
name|bellwether_code
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_ptr
decl_stmt|;
comment|/* tmp_char is a buffer used for reading decimal integers      and names of rtx types and machine modes.      Therefore, 256 must be enough.  */
name|char
name|tmp_char
index|[
literal|256
index|]
decl_stmt|;
name|rtx
name|return_rtx
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|tmp_int
decl_stmt|;
name|HOST_WIDE_INT
name|tmp_wide
decl_stmt|;
comment|/* Linked list structure for making RTXs: */
struct|struct
name|rtx_list
block|{
name|struct
name|rtx_list
modifier|*
name|next
decl_stmt|;
name|rtx
name|value
decl_stmt|;
comment|/* Value of this node.  */
block|}
struct|;
name|again
label|:
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* Should be open paren.  */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|!=
literal|'('
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|'('
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tmp_char
argument_list|,
literal|"nil"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* (nil) stands for an expression that isn't there.  */
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|')'
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tmp_char
argument_list|,
literal|"define_constants"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|read_constants
argument_list|(
name|infile
argument_list|,
name|tmp_char
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tmp_char
argument_list|,
literal|"define_conditions"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|read_conditions
argument_list|(
name|infile
argument_list|,
name|tmp_char
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tmp_char
argument_list|,
literal|"define_mode_attr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|read_mapping
argument_list|(
operator|&
name|modes
argument_list|,
name|modes
operator|.
name|attrs
argument_list|,
name|infile
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tmp_char
argument_list|,
literal|"define_mode_macro"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|read_mapping
argument_list|(
operator|&
name|modes
argument_list|,
name|modes
operator|.
name|macros
argument_list|,
name|infile
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tmp_char
argument_list|,
literal|"define_code_attr"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|read_mapping
argument_list|(
operator|&
name|codes
argument_list|,
name|codes
operator|.
name|attrs
argument_list|,
name|infile
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tmp_char
argument_list|,
literal|"define_code_macro"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|check_code_macro
argument_list|(
name|read_mapping
argument_list|(
operator|&
name|codes
argument_list|,
name|codes
operator|.
name|macros
argument_list|,
name|infile
argument_list|)
argument_list|,
name|infile
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|real_code
operator|=
operator|(
expr|enum
name|rtx_code
operator|)
name|find_macro
argument_list|(
operator|&
name|codes
argument_list|,
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|bellwether_code
operator|=
name|BELLWETHER_CODE
argument_list|(
name|real_code
argument_list|)
expr_stmt|;
comment|/* If we end up with an insn expression then we free this space below.  */
name|return_rtx
operator|=
name|rtx_alloc
argument_list|(
name|bellwether_code
argument_list|)
expr_stmt|;
name|format_ptr
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|bellwether_code
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|return_rtx
argument_list|,
name|real_code
argument_list|)
expr_stmt|;
comment|/* If what follows is `: mode ', read it and      store the mode in the rtx.  */
name|i
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|':'
condition|)
block|{
name|unsigned
name|int
name|mode
decl_stmt|;
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_char
index|[
literal|0
index|]
operator|!=
literal|'<'
operator|||
name|tmp_char
index|[
name|strlen
argument_list|(
name|tmp_char
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'>'
condition|)
name|mode
operator|=
name|find_macro
argument_list|(
operator|&
name|modes
argument_list|,
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|mode_attr_index
argument_list|(
name|mode_maps
argument_list|,
name|tmp_char
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|return_rtx
argument_list|,
operator|(
expr|enum
name|machine_mode
operator|)
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|return_rtx
argument_list|)
operator|!=
name|mode
condition|)
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"mode too large"
argument_list|)
expr_stmt|;
block|}
else|else
name|ungetc
argument_list|(
name|i
argument_list|,
name|infile
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|format_ptr
index|[
name|i
index|]
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|format_ptr
index|[
name|i
index|]
condition|)
block|{
comment|/* 0 means a field for internal use only. 	   Don't expect it to be present in the input.  */
case|case
literal|'0'
case|:
break|break;
case|case
literal|'e'
case|:
case|case
literal|'u'
case|:
name|XEXP
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|read_rtx_1
argument_list|(
name|infile
argument_list|,
name|mode_maps
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* 'V' is an optional vector: if a closeparen follows, 	   just store NULL for this element.  */
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
name|XVEC
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Now process the vector.  */
case|case
literal|'E'
case|:
block|{
comment|/* Obstack to store scratch vector in.  */
name|struct
name|obstack
name|vector_stack
decl_stmt|;
name|int
name|list_counter
init|=
literal|0
decl_stmt|;
name|rtvec
name|return_vec
init|=
name|NULL_RTVEC
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'['
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|'['
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Add expressions to a list, while keeping a count.  */
name|obstack_init
argument_list|(
operator|&
name|vector_stack
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
operator|)
operator|&&
name|c
operator|!=
literal|']'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|list_counter
operator|++
expr_stmt|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|vector_stack
argument_list|,
name|read_rtx_1
argument_list|(
name|infile
argument_list|,
name|mode_maps
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|list_counter
operator|>
literal|0
condition|)
block|{
name|return_vec
operator|=
name|rtvec_alloc
argument_list|(
name|list_counter
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|return_vec
operator|->
name|elem
index|[
literal|0
index|]
argument_list|,
name|obstack_finish
argument_list|(
operator|&
name|vector_stack
argument_list|)
argument_list|,
name|list_counter
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|format_ptr
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
name|fatal_with_file_and_line
argument_list|(
name|infile
argument_list|,
literal|"vector must have at least one element"
argument_list|)
expr_stmt|;
name|XVEC
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|return_vec
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|vector_stack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* close bracket gotten */
block|}
break|break;
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'s'
case|:
block|{
name|char
modifier|*
name|stringbuf
decl_stmt|;
name|int
name|star_if_braced
decl_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
comment|/* 'S' fields are optional and should be NULL if no string 		 was given.  Also allow normal 's' and 'T' strings to be 		 omitted, treating them in the same way as empty strings.  */
name|XSTR
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
operator|(
name|format_ptr
index|[
name|i
index|]
operator|==
literal|'S'
condition|?
name|NULL
else|:
literal|""
operator|)
expr_stmt|;
break|break;
block|}
comment|/* The output template slot of a DEFINE_INSN, 	     DEFINE_INSN_AND_SPLIT, or DEFINE_PEEPHOLE automatically 	     gets a star inserted as its first character, if it is 	     written with a brace block instead of a string constant.  */
name|star_if_braced
operator|=
operator|(
name|format_ptr
index|[
name|i
index|]
operator|==
literal|'T'
operator|)
expr_stmt|;
name|stringbuf
operator|=
name|read_string
argument_list|(
name|infile
argument_list|,
name|star_if_braced
argument_list|)
expr_stmt|;
comment|/* For insn patterns, we want to provide a default name 	     based on the file and line, like "*foo.md:12", if the 	     given name is blank.  These are only for define_insn and 	     define_insn_and_split, to aid debugging.  */
if|if
condition|(
operator|*
name|stringbuf
operator|==
literal|'\0'
operator|&&
name|i
operator|==
literal|0
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|return_rtx
argument_list|)
operator|==
name|DEFINE_INSN
operator|||
name|GET_CODE
argument_list|(
name|return_rtx
argument_list|)
operator|==
name|DEFINE_INSN_AND_SPLIT
operator|)
condition|)
block|{
name|char
name|line_name
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fn
init|=
operator|(
name|read_rtx_filename
condition|?
name|read_rtx_filename
else|:
literal|"rtx"
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|slash
decl_stmt|;
for|for
control|(
name|slash
operator|=
name|fn
init|;
operator|*
name|slash
condition|;
name|slash
operator|++
control|)
if|if
condition|(
operator|*
name|slash
operator|==
literal|'/'
operator|||
operator|*
name|slash
operator|==
literal|'\\'
operator|||
operator|*
name|slash
operator|==
literal|':'
condition|)
name|fn
operator|=
name|slash
operator|+
literal|1
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|fn
argument_list|,
name|strlen
argument_list|(
name|fn
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line_name
argument_list|,
literal|":%d"
argument_list|,
name|read_rtx_lineno
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|line_name
argument_list|,
name|strlen
argument_list|(
name|line_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stringbuf
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|string_obstack
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|star_if_braced
condition|)
name|XTMPL
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|stringbuf
expr_stmt|;
else|else
name|XSTR
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|stringbuf
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|validate_const_int
argument_list|(
name|infile
argument_list|,
name|tmp_char
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_INT
name|tmp_wide
operator|=
name|atoi
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
name|HOST_BITS_PER_LONG
name|tmp_wide
operator|=
name|atol
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Prefer atoll over atoq, since the former is in the ISO C99 standard. 	   But prefer not to use our hand-rolled function above either.  */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ATOLL
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAVE_ATOQ
argument_list|)
name|tmp_wide
operator|=
name|atoll
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
else|#
directive|else
name|tmp_wide
operator|=
name|atoq
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
name|XWINT
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|tmp_wide
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
name|read_name
argument_list|(
name|tmp_char
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|validate_const_int
argument_list|(
name|infile
argument_list|,
name|tmp_char
argument_list|)
expr_stmt|;
name|tmp_int
operator|=
name|atoi
argument_list|(
name|tmp_char
argument_list|)
expr_stmt|;
name|XINT
argument_list|(
name|return_rtx
argument_list|,
name|i
argument_list|)
operator|=
name|tmp_int
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
block|{
comment|/* Syntactic sugar for AND and IOR, allowing Lisp-like 	 arbitrary number of arguments for them.  */
if|if
condition|(
name|c
operator|==
literal|'('
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|return_rtx
argument_list|)
operator|==
name|AND
operator|||
name|GET_CODE
argument_list|(
name|return_rtx
argument_list|)
operator|==
name|IOR
operator|)
condition|)
return|return
name|read_rtx_variadic
argument_list|(
name|infile
argument_list|,
name|mode_maps
argument_list|,
name|return_rtx
argument_list|)
return|;
else|else
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|')'
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|return_rtx
return|;
block|}
end_function

begin_comment
comment|/* Mutually recursive subroutine of read_rtx which reads    (thing x1 x2 x3 ...) and produces RTL as if    (thing x1 (thing x2 (thing x3 ...)))  had been written.    When called, FORM is (thing x1 x2), and the file position    is just past the leading parenthesis of x3.  Only works    for THINGs which are dyadic expressions, e.g. AND, IOR.  */
end_comment

begin_function
specifier|static
name|rtx
name|read_rtx_variadic
parameter_list|(
name|FILE
modifier|*
name|infile
parameter_list|,
name|struct
name|map_value
modifier|*
modifier|*
name|mode_maps
parameter_list|,
name|rtx
name|form
parameter_list|)
block|{
name|char
name|c
init|=
literal|'('
decl_stmt|;
name|rtx
name|p
init|=
name|form
decl_stmt|,
name|q
decl_stmt|;
do|do
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|q
operator|=
name|rtx_alloc
argument_list|(
name|GET_CODE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|q
argument_list|,
name|GET_MODE
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|q
argument_list|,
literal|1
argument_list|)
operator|=
name|read_rtx_1
argument_list|(
name|infile
argument_list|,
name|mode_maps
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
operator|=
name|q
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
name|c
operator|=
name|read_skip_spaces
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
literal|'('
condition|)
do|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
name|fatal_expected_char
argument_list|(
name|infile
argument_list|,
literal|')'
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|form
return|;
block|}
end_function

end_unit

