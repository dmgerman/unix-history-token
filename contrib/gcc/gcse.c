begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Global common subexpression elimination/Partial redundancy elimination    and global constant/copy propagation for GNU compiler.    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* TODO    - reordering of memory allocation and freeing to be more space efficient    - do rough calc of how many regs are needed in each block, and a rough      calc of how many regs are available in each class and use that to      throttle back the code in cases where RTX_COST is minimal.    - a store to the same address as a load does not kill the load if the      source of the store is also the destination of the load.  Handling this      allows more load motion, particularly out of loops.    - ability to realloc sbitmap vectors would allow one initial computation      of reg_set_in_block with only subsequent additions, rather than      recomputing it for each pass  */
end_comment

begin_comment
comment|/* References searched while implementing this.     Compilers Principles, Techniques and Tools    Aho, Sethi, Ullman    Addison-Wesley, 1988     Global Optimization by Suppression of Partial Redundancies    E. Morel, C. Renvoise    communications of the acm, Vol. 22, Num. 2, Feb. 1979     A Portable Machine-Independent Global Optimizer - Design and Measurements    Frederick Chow    Stanford Ph.D. thesis, Dec. 1983     A Fast Algorithm for Code Movement Optimization    D.M. Dhamdhere    SIGPLAN Notices, Vol. 23, Num. 10, Oct. 1988     A Solution to a Problem with Morel and Renvoise's    Global Optimization by Suppression of Partial Redundancies    K-H Drechsler, M.P. Stadel    ACM TOPLAS, Vol. 10, Num. 4, Oct. 1988     Practical Adaptation of the Global Optimization    Algorithm of Morel and Renvoise    D.M. Dhamdhere    ACM TOPLAS, Vol. 13, Num. 2. Apr. 1991     Efficiently Computing Static Single Assignment Form and the Control    Dependence Graph    R. Cytron, J. Ferrante, B.K. Rosen, M.N. Wegman, and F.K. Zadeck    ACM TOPLAS, Vol. 13, Num. 4, Oct. 1991     Lazy Code Motion    J. Knoop, O. Ruthing, B. Steffen    ACM SIGPLAN Notices Vol. 27, Num. 7, Jul. 1992, '92 Conference on PLDI     What's In a Region?  Or Computing Control Dependence Regions in Near-Linear    Time for Reducible Flow Control    Thomas Ball    ACM Letters on Programming Languages and Systems,    Vol. 2, Num. 1-4, Mar-Dec 1993     An Efficient Representation for Sparse Sets    Preston Briggs, Linda Torczon    ACM Letters on Programming Languages and Systems,    Vol. 2, Num. 1-4, Mar-Dec 1993     A Variation of Knoop, Ruthing, and Steffen's Lazy Code Motion    K-H Drechsler, M.P. Stadel    ACM SIGPLAN Notices, Vol. 28, Num. 5, May 1993     Partial Dead Code Elimination    J. Knoop, O. Ruthing, B. Steffen    ACM SIGPLAN Notices, Vol. 29, Num. 6, Jun. 1994     Effective Partial Redundancy Elimination    P. Briggs, K.D. Cooper    ACM SIGPLAN Notices, Vol. 29, Num. 6, Jun. 1994     The Program Structure Tree: Computing Control Regions in Linear Time    R. Johnson, D. Pearson, K. Pingali    ACM SIGPLAN Notices, Vol. 29, Num. 6, Jun. 1994     Optimal Code Motion: Theory and Practice    J. Knoop, O. Ruthing, B. Steffen    ACM TOPLAS, Vol. 16, Num. 4, Jul. 1994     The power of assignment motion    J. Knoop, O. Ruthing, B. Steffen    ACM SIGPLAN Notices Vol. 30, Num. 6, Jun. 1995, '95 Conference on PLDI     Global code motion / global value numbering    C. Click    ACM SIGPLAN Notices Vol. 30, Num. 6, Jun. 1995, '95 Conference on PLDI     Value Driven Redundancy Elimination    L.T. Simpson    Rice University Ph.D. thesis, Apr. 1996     Value Numbering    L.T. Simpson    Massively Scalar Compiler Project, Rice University, Sep. 1996     High Performance Compilers for Parallel Computing    Michael Wolfe    Addison-Wesley, 1996     Advanced Compiler Design and Implementation    Steven Muchnick    Morgan Kaufmann, 1997     Building an Optimizing Compiler    Robert Morgan    Digital Press, 1998     People wishing to speed up the code here should read:      Elimination Algorithms for Data Flow Analysis      B.G. Ryder, M.C. Paull      ACM Computing Surveys, Vol. 18, Num. 3, Sep. 1986       How to Analyze Large Programs Efficiently and Informatively      D.M. Dhamdhere, B.K. Rosen, F.K. Zadeck      ACM SIGPLAN Notices Vol. 27, Num. 7, Jul. 1992, '92 Conference on PLDI     People wishing to do something different can find various possibilities    in the above papers and elsewhere. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|gmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Propagate flow information through back edges and thus enable PRE's    moving loop invariant calculations out of loops.     Originally this tended to create worse overall code, but several    improvements during the development of PRE seem to have made following    back edges generally a win.     Note much of the loop invariant code motion done here would normally    be done by loop.c, which has more heuristics for when to move invariants    out of loops.  At some point we might need to move some of those    heuristics into gcse.c.  */
end_comment

begin_define
define|#
directive|define
name|FOLLOW_BACK_EDGES
value|1
end_define

begin_comment
comment|/* We support GCSE via Partial Redundancy Elimination.  PRE optimizations    are a superset of those done by GCSE.     We perform the following steps:     1) Compute basic block information.     2) Compute table of places where registers are set.     3) Perform copy/constant propagation.     4) Perform global cse.     5) Perform another pass of copy/constant propagation.     Two passes of copy/constant propagation are done because the first one    enables more GCSE and the second one helps to clean up the copies that    GCSE creates.  This is needed more for PRE than for Classic because Classic    GCSE will try to use an existing register containing the common    subexpression rather than create a new one.  This is harder to do for PRE    because of the code motion (which Classic GCSE doesn't do).     Expressions we are interested in GCSE-ing are of the form    (set (pseudo-reg) (expression)).    Function want_to_gcse_p says what these are.     PRE handles moving invariant expressions out of loops (by treating them as    partially redundant).     Eventually it would be nice to replace cse.c/gcse.c with SSA (static single    assignment) based GVN (global value numbering).  L. T. Simpson's paper    (Rice University) on value numbering is a useful reference for this.     **********************     We used to support multiple passes but there are diminishing returns in    doing so.  The first pass usually makes 90% of the changes that are doable.    A second pass can make a few more changes made possible by the first pass.    Experiments show any further passes don't make enough changes to justify    the expense.     A study of spec92 using an unlimited number of passes:    [1 pass] = 1208 substitutions, [2] = 577, [3] = 202, [4] = 192, [5] = 83,    [6] = 34, [7] = 17, [8] = 9, [9] = 4, [10] = 4, [11] = 2,    [12] = 2, [13] = 1, [15] = 1, [16] = 2, [41] = 1     It was found doing copy propagation between each pass enables further    substitutions.     PRE is quite expensive in complicated functions because the DFA can take    awhile to converge.  Hence we only perform one pass.  The parameter max-gcse-passes can    be modified if one wants to experiment.     **********************     The steps for PRE are:     1) Build the hash table of expressions we wish to GCSE (expr_hash_table).     2) Perform the data flow analysis for PRE.     3) Delete the redundant instructions     4) Insert the required copies [if any] that make the partially       redundant instructions fully redundant.     5) For other reaching expressions, insert an instruction to copy the value       to a newly created pseudo that will reach the redundant instruction.     The deletion is done first so that when we do insertions we    know which pseudo reg to use.     Various papers have argued that PRE DFA is expensive (O(n^2)) and others    argue it is not.  The number of iterations for the algorithm to converge    is typically 2-4 so I don't view it as that expensive (relatively speaking).     PRE GCSE depends heavily on the second CSE pass to clean up the copies    we create.  To make an expression reach the place where it's redundant,    the result of the expression is copied to a new register, and the redundant    expression is deleted by replacing it with this new register.  Classic GCSE    doesn't have this problem as much as it computes the reaching defs of    each register in each block and thus can try to use an existing register.     **********************     A fair bit of simplicity is created by creating small functions for simple    tasks, even when the function is only called in one place.  This may    measurably slow things down [or may not] by creating more function call    overhead than is necessary.  The source is laid out so that it's trivial    to make the affected functions inline so that one can measure what speed    up, if any, can be achieved, and maybe later when things settle things can    be rearranged.     Help stamp out big monolithic functions!  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* GCSE global vars.  */
end_comment

begin_comment
comment|/* -dG dump file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|gcse_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Note whether or not we should run jump optimization after gcse.  We    want to do this for two cases.      * If we changed any jumps via cprop.      * If we added any labels via edge splitting.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|run_jump_opt_after_gcse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmaps are normally not included in debugging dumps.    However it's useful to be able to print them from GDB.    We could create special functions for this, but it's simpler to    just allow passing stderr to the dump_foo fns.  Since stderr can    be a macro, we store a copy here.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|debug_stderr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An obstack for our working variables.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|gcse_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero for each mode that supports (set (reg) (reg)).    This is trivially true for integer and floating point values.    It may or may not be true for condition codes.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|can_copy_p
index|[
operator|(
name|int
operator|)
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if can_copy_p has been initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|can_copy_init_p
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|reg_use
block|{
name|rtx
name|reg_rtx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hash table of expressions.  */
end_comment

begin_struct
struct|struct
name|expr
block|{
comment|/* The expression (SET_SRC for expressions, PATTERN for assignments).  */
name|rtx
name|expr
decl_stmt|;
comment|/* Index in the available expression bitmaps.  */
name|int
name|bitmap_index
decl_stmt|;
comment|/* Next entry with the same hash.  */
name|struct
name|expr
modifier|*
name|next_same_hash
decl_stmt|;
comment|/* List of anticipatable occurrences in basic blocks in the function.      An "anticipatable occurrence" is one that is the first occurrence in the      basic block, the operands are not modified in the basic block prior      to the occurrence and the output is not used between the start of      the block and the occurrence.  */
name|struct
name|occr
modifier|*
name|antic_occr
decl_stmt|;
comment|/* List of available occurrence in basic blocks in the function.      An "available occurrence" is one that is the last occurrence in the      basic block and the operands are not modified by following statements in      the basic block [including this insn].  */
name|struct
name|occr
modifier|*
name|avail_occr
decl_stmt|;
comment|/* Non-null if the computation is PRE redundant.      The value is the newly created pseudo-reg to record a copy of the      expression in all the places that reach the redundant copy.  */
name|rtx
name|reaching_reg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Occurrence of an expression.    There is one per basic block.  If a pattern appears more than once the    last appearance is used [or first for anticipatable expressions].  */
end_comment

begin_struct
struct|struct
name|occr
block|{
comment|/* Next occurrence of this expression.  */
name|struct
name|occr
modifier|*
name|next
decl_stmt|;
comment|/* The insn that computes the expression.  */
name|rtx
name|insn
decl_stmt|;
comment|/* Non-zero if this [anticipatable] occurrence has been deleted.  */
name|char
name|deleted_p
decl_stmt|;
comment|/* Non-zero if this [available] occurrence has been copied to      reaching_reg.  */
comment|/* ??? This is mutually exclusive with deleted_p, so they could share      the same byte.  */
name|char
name|copied_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Expression and copy propagation hash tables.    Each hash table is an array of buckets.    ??? It is known that if it were an array of entries, structure elements    `next_same_hash' and `bitmap_index' wouldn't be necessary.  However, it is    not clear whether in the final analysis a sufficient amount of memory would    be saved as the size of the available expression bitmaps would be larger    [one could build a mapping table without holes afterwards though].    Someday I'll perform the computation and figure it out.  */
end_comment

begin_comment
comment|/* Total size of the expression hash table, in elements.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|expr_hash_table_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The table itself.    This is an array of `expr_hash_table_size' elements.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
modifier|*
name|expr_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total size of the copy propagation hash table, in elements.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|set_hash_table_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The table itself.    This is an array of `set_hash_table_size' elements.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
modifier|*
name|set_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping of uids to cuids.    Only real insns get cuids.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest UID in UID_CUID.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the cuid of an insn.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_define
define|#
directive|define
name|INSN_CUID
parameter_list|(
name|INSN
parameter_list|)
value|(INSN_UID (INSN)> max_uid ? (abort (), 0) : uid_cuid[INSN_UID (INSN)])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INSN_CUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_cuid[INSN_UID (INSN)])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of cuids.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping of cuids to insns.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|cuid_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get insn from cuid.  */
end_comment

begin_define
define|#
directive|define
name|CUID_INSN
parameter_list|(
name|CUID
parameter_list|)
value|(cuid_insn[CUID])
end_define

begin_comment
comment|/* Maximum register number in function prior to doing gcse + 1.    Registers created during this pass have regno>= max_gcse_regno.    This is named with "gcse" to not collide with global of same name.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_gcse_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of cse-able expressions found.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_exprs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of assignments for copy propagation found.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of registers that are modified.     For each register, each element is a list of places where the pseudo-reg    is set.     For simplicity, GCSE is done on sets of pseudo-regs only.  PRE GCSE only    requires knowledge of which blocks kill which regs [and thus could use    a bitmap instead of the lists `reg_set_table' uses].     `reg_set_table' and could be turned into an array of bitmaps (num-bbs x    num-regs) [however perhaps it may be useful to keep the data as is].  One    advantage of recording things this way is that `reg_set_table' is fairly    sparse with respect to pseudo regs but for hard regs could be fairly dense    [relatively speaking].  And recording sets of pseudo-regs in lists speeds    up functions like compute_transp since in the case of pseudo-regs we only    need to iterate over the number of times a pseudo-reg is set, not over the    number of basic blocks [clearly there is a bit of a slow down in the cases    where a pseudo is set more than once in a block, however it is believed    that the net effect is to speed things up].  This isn't done for hard-regs    because recording call-clobbered hard-regs in `reg_set_table' at each    function call can consume a fair bit of memory, and iterating over    hard-regs stored this way in compute_transp will be more expensive.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|reg_set
block|{
comment|/* The next setting of this register.  */
name|struct
name|reg_set
modifier|*
name|next
decl_stmt|;
comment|/* The insn where it was set.  */
name|rtx
name|insn
decl_stmt|;
block|}
name|reg_set
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|reg_set
modifier|*
modifier|*
name|reg_set_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of `reg_set_table'.    The table starts out at max_gcse_regno + slop, and is enlarged as    necessary.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_set_table_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount to grow `reg_set_table' by when it's full.  */
end_comment

begin_define
define|#
directive|define
name|REG_SET_TABLE_SLOP
value|100
end_define

begin_comment
comment|/* This is a list of expressions which are MEMs and will be used by load    or store motion.     Load motion tracks MEMs which aren't killed by    anything except itself. (ie, loads and stores to a single location).    We can then allow movement of these MEM refs with a little special     allowance. (all stores copy the same value to the reaching reg used    for the loads).  This means all values used to store into memory must have    no side effects so we can re-issue the setter value.      Store Motion uses this structure as an expression table to track stores    which look interesting, and might be moveable towards the exit block.  */
end_comment

begin_struct
struct|struct
name|ls_expr
block|{
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
comment|/* Gcse expression reference for LM.  */
name|rtx
name|pattern
decl_stmt|;
comment|/* Pattern of this mem.  */
name|rtx
name|loads
decl_stmt|;
comment|/* INSN list of loads seen.  */
name|rtx
name|stores
decl_stmt|;
comment|/* INSN list of stores seen.  */
name|struct
name|ls_expr
modifier|*
name|next
decl_stmt|;
comment|/* Next in the list.  */
name|int
name|invalid
decl_stmt|;
comment|/* Invalid for some reason.  */
name|int
name|index
decl_stmt|;
comment|/* If it maps to a bitmap index.  */
name|int
name|hash_index
decl_stmt|;
comment|/* Index when in a hash table.  */
name|rtx
name|reaching_reg
decl_stmt|;
comment|/* Register to use when re-writing.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Head of the list of load/store memory refs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ls_expr
modifier|*
name|pre_ldst_mems
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmap containing one bit for each register in the program.    Used when performing GCSE to track which registers have been set since    the start of the basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|reg_set_bitmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each block, a bitmap of registers set in the block.    This is used by expr_killed_p and compute_transp.    It is computed during hash table computation and not by compute_sets    as it includes registers added since the last pass (or between cprop and    gcse) and it's currently not easy to realloc sbitmap vectors.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|reg_set_in_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array, indexed by basic block number for a list of insns which modify    memory within that block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|modify_mem_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bitmap
name|modify_mem_list_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array parallels modify_mem_list, but is kept canonicalized.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|canon_modify_mem_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bitmap
name|canon_modify_mem_list_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various variables for statistics gathering.  */
end_comment

begin_comment
comment|/* Memory used in a pass.    This isn't intended to be absolutely precise.  Its intent is only    to keep an eye on memory usage.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bytes_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GCSE substitutions made.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gcse_subst_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of copy instructions created.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gcse_create_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of constants propagated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|const_prop_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of copys propagated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|copy_prop_count
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* These variables are used by classic GCSE.    Normally they'd be defined a bit later, but `rd_gen' needs to    be declared sooner.  */
end_comment

begin_comment
comment|/* Each block has a bitmap of each type.    The length of each blocks bitmap is:         max_cuid  - for reaching definitions        n_exprs - for available expressions     Thus we view the bitmaps as 2 dimensional arrays.  i.e.    rd_kill[block_num][cuid_num]    ae_kill[block_num][expr_num]			 */
end_comment

begin_comment
comment|/* For reaching defs */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|rd_kill
decl_stmt|,
modifier|*
name|rd_gen
decl_stmt|,
modifier|*
name|reaching_defs
decl_stmt|,
modifier|*
name|rd_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for available exprs */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|ae_kill
decl_stmt|,
modifier|*
name|ae_gen
decl_stmt|,
modifier|*
name|ae_in
decl_stmt|,
modifier|*
name|ae_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Objects of this type are passed around by the null-pointer check    removal routines.  */
end_comment

begin_struct
struct|struct
name|null_pointer_info
block|{
comment|/* The basic block being processed.  */
name|int
name|current_block
decl_stmt|;
comment|/* The first register to be handled in this pass.  */
name|unsigned
name|int
name|min_reg
decl_stmt|;
comment|/* One greater than the last register to be handled in this pass.  */
name|unsigned
name|int
name|max_reg
decl_stmt|;
name|sbitmap
modifier|*
name|nonnull_local
decl_stmt|;
name|sbitmap
modifier|*
name|nonnull_killed
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|compute_can_copy
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gmalloc
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|grealloc
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gcse_alloc
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_gcse_mem
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_gcse_mem
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_reg_set_mem
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_reg_set_mem
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_bitmap_width
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_one_set
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_set_info
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_sets
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_scan_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_scan_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_scan_clobber
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_scan_call
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|want_to_gcse_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oprs_unchanged_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oprs_anticipatable_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oprs_available_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_expr_in_table
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_set_in_table
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_expr
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_expr_1
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_string_1
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_set
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expr_equiv_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_last_reg_set_info
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_last_mem_set_info
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_last_set_info
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_hash_table
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_set_hash_table
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_set_hash_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_set_hash_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_expr_hash_table
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_expr_hash_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_expr_hash_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_hash_table
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|expr
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
name|lookup_expr
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
name|lookup_set
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
name|next_set
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
expr|struct
name|expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_opr_set_tables
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oprs_not_set_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_call
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_clobber
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_oprs_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_cprop_mem
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_cprop_mem
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_transp
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|sbitmap
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_transpout
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_local_properties
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_cprop_data
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_used_regs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_replace_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
name|find_avail_set
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cprop_jump
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|cprop_cc0_jump
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|rtx
operator|,
expr|struct
name|reg_use
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|mems_conflict_for_gcse_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|load_killed_in_block_p
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|int
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|canon_list_insert
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cprop_insn
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cprop
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|one_cprop_pass
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_pre_mem
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_pre_mem
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_pre_data
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pre_expr_reaches_here_p
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
expr|struct
name|expr
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_insn_end_bb
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expr
operator|*
operator|,
name|basic_block
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pre_insert_copy_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expr
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pre_insert_copies
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pre_delete
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pre_gcse
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|one_pre_gcse_pass
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_label_notes
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_code_hoist_mem
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_code_hoist_mem
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_code_hoist_vbeinout
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_code_hoist_data
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hoist_expr_reaches_here_p
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
name|int
operator|,
name|basic_block
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hoist_code
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|one_code_hoisting_pass
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_rd_mem
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_rd_mem
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_rd_kill_set
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_kill_rd
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_rd
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_avail_expr_mem
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_avail_expr_mem
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_ae_gen
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expr_killed_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_ae_kill
name|PARAMS
argument_list|(
operator|(
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expr_reaches_here_p
name|PARAMS
argument_list|(
operator|(
expr|struct
name|occr
operator|*
operator|,
expr|struct
name|expr
operator|*
operator|,
name|basic_block
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|computing_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expr
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_reaches_here_p
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_disregard_other_sets
name|PARAMS
argument_list|(
operator|(
expr|struct
name|reg_set
operator|*
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|handle_avail_expr
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|classic_gcse
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|one_classic_gcse_pass
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|invalidate_nonnull_info
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_null_pointer_checks_1
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
expr|struct
name|null_pointer_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|process_insert_insn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pre_edge_insert
name|PARAMS
argument_list|(
operator|(
expr|struct
name|edge_list
operator|*
operator|,
expr|struct
name|expr
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expr_reaches_here_p_work
name|PARAMS
argument_list|(
operator|(
expr|struct
name|occr
operator|*
operator|,
expr|struct
name|expr
operator|*
operator|,
name|basic_block
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pre_expr_reaches_here_p_work
name|PARAMS
argument_list|(
operator|(
name|basic_block
operator|,
expr|struct
name|expr
operator|*
operator|,
name|basic_block
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ls_expr
modifier|*
name|ldst_entry
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_ldst_entry
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ls_expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_ldst_mems
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_ldst_list
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ls_expr
modifier|*
name|find_rtx_in_ldst
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|enumerate_ldsts
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|struct
name|ls_expr
modifier|*
name|first_ls_expr
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|struct
name|ls_expr
modifier|*
name|next_ls_expr
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ls_expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|simple_mem
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|invalidate_any_buried_refs
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_ld_motion_mems
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trim_ld_motion_mems
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_ld_motion_stores
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_set_info
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|store_ops_ok
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_moveable_store
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compute_store_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|load_kills_store
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_loads
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|store_killed_in_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|store_killed_after
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|store_killed_before
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_store_vectors
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_insn_start_bb
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insert_store
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ls_expr
operator|*
operator|,
name|edge
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|replace_store_insn
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_store
name|PARAMS
argument_list|(
operator|(
expr|struct
name|ls_expr
operator|*
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_store_memory
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store_motion
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_modify_mem_tables
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_modify_mem_tables
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Entry point for global common subexpression elimination.    F is the first instruction in the function.  */
end_comment

begin_function
name|int
name|gcse_main
parameter_list|(
name|f
parameter_list|,
name|file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|changed
decl_stmt|,
name|pass
decl_stmt|;
comment|/* Bytes used at start of pass.  */
name|int
name|initial_bytes_used
decl_stmt|;
comment|/* Maximum number of bytes used by a pass.  */
name|int
name|max_pass_bytes
decl_stmt|;
comment|/* Point to release obstack data from for each pass.  */
name|char
modifier|*
name|gcse_obstack_bottom
decl_stmt|;
comment|/* Insertion of instructions on edges can create new basic blocks; we      need the original basic block count so that we can properly deallocate      arrays sized on the number of basic blocks originally in the cfg.  */
name|int
name|orig_bb_count
decl_stmt|;
comment|/* We do not construct an accurate cfg in functions which call      setjmp, so just punt to be safe.  */
if|if
condition|(
name|current_function_calls_setjmp
condition|)
return|return
literal|0
return|;
comment|/* Assume that we do not need to run jump optimizations after gcse.  */
name|run_jump_opt_after_gcse
operator|=
literal|0
expr_stmt|;
comment|/* For calling dump_foo fns from gdb.  */
name|debug_stderr
operator|=
name|stderr
expr_stmt|;
name|gcse_file
operator|=
name|file
expr_stmt|;
comment|/* Identify the basic block information for this function, including      successors and predecessors.  */
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_flow_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|orig_bb_count
operator|=
name|n_basic_blocks
expr_stmt|;
comment|/* Return if there's nothing to do.  */
if|if
condition|(
name|n_basic_blocks
operator|<=
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Trying to perform global optimizations on flow graphs which have      a high connectivity will take a long time and is unlikely to be      particularly useful.       In normal circumstances a cfg should have about twice as many edges      as blocks.  But we do not want to punish small functions which have      a couple switch statements.  So we require a relatively large number      of basic blocks and the ratio of edges to blocks to be high.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|1000
operator|&&
name|n_edges
operator|/
name|n_basic_blocks
operator|>=
literal|20
condition|)
block|{
if|if
condition|(
name|warn_disabled_optimization
condition|)
name|warning
argument_list|(
literal|"GCSE disabled: %d> 1000 basic blocks and %d>= 20 edges/basic block"
argument_list|,
name|n_basic_blocks
argument_list|,
name|n_edges
operator|/
name|n_basic_blocks
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If allocating memory for the cprop bitmap would take up too much      storage it's better just to disable the optimization.  */
if|if
condition|(
operator|(
name|n_basic_blocks
operator|*
name|SBITMAP_SET_SIZE
argument_list|(
name|max_gcse_regno
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|SBITMAP_ELT_TYPE
argument_list|)
operator|)
operator|>
name|MAX_GCSE_MEMORY
condition|)
block|{
if|if
condition|(
name|warn_disabled_optimization
condition|)
name|warning
argument_list|(
literal|"GCSE disabled: %d basic blocks and %d registers"
argument_list|,
name|n_basic_blocks
argument_list|,
name|max_gcse_regno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* See what modes support reg/reg copy operations.  */
if|if
condition|(
operator|!
name|can_copy_init_p
condition|)
block|{
name|compute_can_copy
argument_list|()
expr_stmt|;
name|can_copy_init_p
operator|=
literal|1
expr_stmt|;
block|}
name|gcc_obstack_init
argument_list|(
operator|&
name|gcse_obstack
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
literal|0
expr_stmt|;
comment|/* We need alias.  */
name|init_alias_analysis
argument_list|()
expr_stmt|;
comment|/* Record where pseudo-registers are set.  This data is kept accurate      during each pass.  ??? We could also record hard-reg information here      [since it's unchanging], however it is currently done during hash table      computation.       It may be tempting to compute MEM set information here too, but MEM sets      will be subject to code motion one day and thus we need to compute      information about memory sets when we build the hash tables.  */
name|alloc_reg_set_mem
argument_list|(
name|max_gcse_regno
argument_list|)
expr_stmt|;
name|compute_sets
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|pass
operator|=
literal|0
expr_stmt|;
name|initial_bytes_used
operator|=
name|bytes_used
expr_stmt|;
name|max_pass_bytes
operator|=
literal|0
expr_stmt|;
name|gcse_obstack_bottom
operator|=
name|gcse_alloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
operator|&&
name|pass
operator|<
name|MAX_GCSE_PASSES
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"GCSE pass %d\n\n"
argument_list|,
name|pass
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize bytes_used to the space for the pred/succ lists, 	 and the reg_set_table data.  */
name|bytes_used
operator|=
name|initial_bytes_used
expr_stmt|;
comment|/* Each pass may create new registers, so recalculate each time.  */
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|alloc_gcse_mem
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Don't allow constant propagation to modify jumps 	 during this pass.  */
name|changed
operator|=
name|one_cprop_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize_size
condition|)
name|changed
operator||=
name|one_classic_gcse_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|changed
operator||=
name|one_pre_gcse_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* We may have just created new basic blocks.  Release and 	     recompute various things which are sized on the number of 	     basic blocks.  */
if|if
condition|(
name|changed
condition|)
block|{
name|free_modify_mem_tables
argument_list|()
expr_stmt|;
name|modify_mem_list
operator|=
operator|(
name|rtx
operator|*
operator|)
name|gmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|canon_modify_mem_list
operator|=
operator|(
name|rtx
operator|*
operator|)
name|gmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modify_mem_list
argument_list|,
literal|0
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|canon_modify_mem_list
argument_list|,
literal|0
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|orig_bb_count
operator|=
name|n_basic_blocks
expr_stmt|;
block|}
name|free_reg_set_mem
argument_list|()
expr_stmt|;
name|alloc_reg_set_mem
argument_list|(
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|compute_sets
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|run_jump_opt_after_gcse
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|max_pass_bytes
operator|<
name|bytes_used
condition|)
name|max_pass_bytes
operator|=
name|bytes_used
expr_stmt|;
comment|/* Free up memory, then reallocate for code hoisting.  We can 	 not re-use the existing allocated memory because the tables 	 will not have info for the insns or registers created by 	 partial redundancy elimination.  */
name|free_gcse_mem
argument_list|()
expr_stmt|;
comment|/* It does not make sense to run code hoisting unless we optimizing 	 for code size -- it rarely makes programs faster, and can make 	 them bigger if we did partial redundancy elimination (when optimizing 	 for space, we use a classic gcse algorithm instead of partial 	 redundancy algorithms).  */
if|if
condition|(
name|optimize_size
condition|)
block|{
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|alloc_gcse_mem
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|changed
operator||=
name|one_code_hoisting_pass
argument_list|()
expr_stmt|;
name|free_gcse_mem
argument_list|()
expr_stmt|;
if|if
condition|(
name|max_pass_bytes
operator|<
name|bytes_used
condition|)
name|max_pass_bytes
operator|=
name|bytes_used
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|gcse_obstack
argument_list|,
name|gcse_obstack_bottom
argument_list|)
expr_stmt|;
name|pass
operator|++
expr_stmt|;
block|}
comment|/* Do one last pass of copy propagation, including cprop into      conditional jumps.  */
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|alloc_gcse_mem
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* This time, go ahead and allow cprop to alter jumps.  */
name|one_cprop_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_gcse_mem
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"GCSE of %s: %d basic blocks, "
argument_list|,
name|current_function_name
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d pass%s, %d bytes\n\n"
argument_list|,
name|pass
argument_list|,
name|pass
operator|>
literal|1
condition|?
literal|"es"
else|:
literal|""
argument_list|,
name|max_pass_bytes
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|gcse_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_reg_set_mem
argument_list|()
expr_stmt|;
comment|/* We are finished with alias.  */
name|end_alias_analysis
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|flag_gcse_sm
condition|)
name|store_motion
argument_list|()
expr_stmt|;
comment|/* Record where pseudo-registers are set.  */
return|return
name|run_jump_opt_after_gcse
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Misc. utilities.  */
end_comment

begin_comment
comment|/* Compute which modes support reg/reg copy operations.  */
end_comment

begin_function
specifier|static
name|void
name|compute_can_copy
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|AVOID_CCMODE_COPIES
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|can_copy_p
argument_list|,
literal|0
argument_list|,
name|NUM_MACHINE_MODES
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|i
argument_list|)
operator|==
name|MODE_CC
condition|)
block|{
ifdef|#
directive|ifdef
name|AVOID_CCMODE_COPIES
name|can_copy_p
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|)
name|i
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|0
condition|)
name|can_copy_p
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|can_copy_p
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cover function to xmalloc to record bytes allocated.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|bytes_used
operator|+=
name|size
expr_stmt|;
return|return
name|xmalloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cover function to xrealloc.    We don't record the additional size since we don't know it.    It won't affect memory usage stats much anyway.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|grealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
return|return
name|xrealloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cover function to obstack_alloc.    We don't need to record the bytes allocated here since    obstack_chunk_alloc is set to gmalloc.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gcse_alloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|gcse_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate memory for the cuid mapping array,    and reg/memory set tracking tables.     This is called at the start of each pass.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_gcse_mem
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Find the largest UID and create a mapping from UIDs to CUIDs.      CUIDs are like UIDs except they increase monotonically, have no gaps,      and only apply to real insns.  */
name|max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|n
operator|=
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|uid_cuid
operator|=
operator|(
name|int
operator|*
operator|)
name|gmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|uid_cuid
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|uid_cuid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
operator|++
expr_stmt|;
else|else
name|uid_cuid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* Create a table mapping cuids to insns.  */
name|max_cuid
operator|=
name|i
expr_stmt|;
name|n
operator|=
operator|(
name|max_cuid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
expr_stmt|;
name|cuid_insn
operator|=
operator|(
name|rtx
operator|*
operator|)
name|gmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cuid_insn
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|CUID_INSN
argument_list|(
name|i
operator|++
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* Allocate vars to track sets of regs.  */
name|reg_set_bitmap
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
comment|/* Allocate vars to track sets of regs, memory per block.  */
name|reg_set_in_block
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|max_gcse_regno
argument_list|)
expr_stmt|;
comment|/* Allocate array to keep a list of insns which modify memory in each      basic block.  */
name|modify_mem_list
operator|=
operator|(
name|rtx
operator|*
operator|)
name|gmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|canon_modify_mem_list
operator|=
operator|(
name|rtx
operator|*
operator|)
name|gmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|modify_mem_list
argument_list|,
literal|0
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|canon_modify_mem_list
argument_list|,
literal|0
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|modify_mem_list_set
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|canon_modify_mem_list_set
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free memory allocated by alloc_gcse_mem.  */
end_comment

begin_function
specifier|static
name|void
name|free_gcse_mem
parameter_list|()
block|{
name|free
argument_list|(
name|uid_cuid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cuid_insn
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|reg_set_bitmap
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|reg_set_in_block
argument_list|)
expr_stmt|;
name|free_modify_mem_tables
argument_list|()
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|modify_mem_list_set
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|canon_modify_mem_list_set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Many of the global optimization algorithms work by solving dataflow    equations for various expressions.  Initially, some local value is    computed for each expression in each block.  Then, the values across the    various blocks are combined (by following flow graph edges) to arrive at    global values.  Conceptually, each set of equations is independent.  We    may therefore solve all the equations in parallel, solve them one at a    time, or pick any intermediate approach.     When you're going to need N two-dimensional bitmaps, each X (say, the    number of blocks) by Y (say, the number of expressions), call this    function.  It's not important what X and Y represent; only that Y    correspond to the things that can be done in parallel.  This function will    return an appropriate chunking factor C; you should solve C sets of    equations in parallel.  By going through this function, we can easily    trade space against time; by solving fewer equations in parallel we use    less space.  */
end_comment

begin_function
specifier|static
name|int
name|get_bitmap_width
parameter_list|(
name|n
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
name|int
name|n
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
block|{
comment|/* It's not really worth figuring out *exactly* how much memory will      be used by a particular choice.  The important thing is to get      something approximately right.  */
name|size_t
name|max_bitmap_memory
init|=
literal|10
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|/* The number of bytes we'd use for a single column of minimum      width.  */
name|size_t
name|column_size
init|=
name|n
operator|*
name|x
operator|*
sizeof|sizeof
argument_list|(
name|SBITMAP_ELT_TYPE
argument_list|)
decl_stmt|;
comment|/* Often, it's reasonable just to solve all the equations in      parallel.  */
if|if
condition|(
name|column_size
operator|*
name|SBITMAP_SET_SIZE
argument_list|(
name|y
argument_list|)
operator|<=
name|max_bitmap_memory
condition|)
return|return
name|y
return|;
comment|/* Otherwise, pick the largest width we can, without going over the      limit.  */
return|return
name|SBITMAP_ELT_BITS
operator|*
operator|(
operator|(
name|max_bitmap_memory
operator|+
name|column_size
operator|-
literal|1
operator|)
operator|/
name|column_size
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the local properties of each recorded expression.     Local properties are those that are defined by the block, irrespective of    other blocks.     An expression is transparent in a block if its operands are not modified    in the block.     An expression is computed (locally available) in a block if it is computed    at least once and expression would contain the same value if the    computation was moved to the end of the block.     An expression is locally anticipatable in a block if it is computed at    least once and expression would contain the same value if the computation    was moved to the beginning of the block.     We call this routine for cprop, pre and code hoisting.  They all compute    basically the same information and thus can easily share this code.     TRANSP, COMP, and ANTLOC are destination sbitmaps for recording local    properties.  If NULL, then it is not necessary to compute or record that    particular property.     SETP controls which hash table to look at.  If zero, this routine looks at    the expr hash table; if nonzero this routine looks at the set hash table.    Additionally, TRANSP is computed as ~TRANSP, since this is really cprop's    ABSALTERED.  */
end_comment

begin_function
specifier|static
name|void
name|compute_local_properties
parameter_list|(
name|transp
parameter_list|,
name|comp
parameter_list|,
name|antloc
parameter_list|,
name|setp
parameter_list|)
name|sbitmap
modifier|*
name|transp
decl_stmt|;
name|sbitmap
modifier|*
name|comp
decl_stmt|;
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
name|int
name|setp
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|hash_table_size
decl_stmt|;
name|struct
name|expr
modifier|*
modifier|*
name|hash_table
decl_stmt|;
comment|/* Initialize any bitmaps that were passed in.  */
if|if
condition|(
name|transp
condition|)
block|{
if|if
condition|(
name|setp
condition|)
name|sbitmap_vector_zero
argument_list|(
name|transp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
else|else
name|sbitmap_vector_ones
argument_list|(
name|transp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
condition|)
name|sbitmap_vector_zero
argument_list|(
name|comp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|antloc
condition|)
name|sbitmap_vector_zero
argument_list|(
name|antloc
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* We use the same code for cprop, pre and hoisting.  For cprop      we care about the set hash table, for pre and hoisting we      care about the expr hash table.  */
name|hash_table_size
operator|=
name|setp
condition|?
name|set_hash_table_size
else|:
name|expr_hash_table_size
expr_stmt|;
name|hash_table
operator|=
name|setp
condition|?
name|set_hash_table
else|:
name|expr_hash_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hash_table_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
for|for
control|(
name|expr
operator|=
name|hash_table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
name|int
name|indx
init|=
name|expr
operator|->
name|bitmap_index
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
comment|/* The expression is transparent in this block if it is not killed. 	     We start by assuming all are transparent [none are killed], and 	     then reset the bits for those that are.  */
if|if
condition|(
name|transp
condition|)
name|compute_transp
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|indx
argument_list|,
name|transp
argument_list|,
name|setp
argument_list|)
expr_stmt|;
comment|/* The occurrences recorded in antic_occr are exactly those that 	     we want to set to non-zero in ANTLOC.  */
if|if
condition|(
name|antloc
condition|)
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
name|SET_BIT
argument_list|(
name|antloc
index|[
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* While we're scanning the table, this is a good place to 		   initialize this.  */
name|occr
operator|->
name|deleted_p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The occurrences recorded in avail_occr are exactly those that 	     we want to set to non-zero in COMP.  */
if|if
condition|(
name|comp
condition|)
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
name|SET_BIT
argument_list|(
name|comp
index|[
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* While we're scanning the table, this is a good place to 		   initialize this.  */
name|occr
operator|->
name|copied_p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* While we're scanning the table, this is a good place to 	     initialize this.  */
name|expr
operator|->
name|reaching_reg
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register set information.     `reg_set_table' records where each register is set or otherwise    modified.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|reg_set_obstack
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|alloc_reg_set_mem
parameter_list|(
name|n_regs
parameter_list|)
name|int
name|n_regs
decl_stmt|;
block|{
name|unsigned
name|int
name|n
decl_stmt|;
name|reg_set_table_size
operator|=
name|n_regs
operator|+
name|REG_SET_TABLE_SLOP
expr_stmt|;
name|n
operator|=
name|reg_set_table_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
operator|*
argument_list|)
expr_stmt|;
name|reg_set_table
operator|=
operator|(
expr|struct
name|reg_set
operator|*
operator|*
operator|)
name|gmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_set_table
argument_list|,
literal|0
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|reg_set_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_reg_set_mem
parameter_list|()
block|{
name|free
argument_list|(
name|reg_set_table
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|reg_set_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record REGNO in the reg_set table.  */
end_comment

begin_function
specifier|static
name|void
name|record_one_set
parameter_list|(
name|regno
parameter_list|,
name|insn
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Allocate a new reg_set element and link it onto the list.  */
name|struct
name|reg_set
modifier|*
name|new_reg_info
decl_stmt|;
comment|/* If the table isn't big enough, enlarge it.  */
if|if
condition|(
name|regno
operator|>=
name|reg_set_table_size
condition|)
block|{
name|int
name|new_size
init|=
name|regno
operator|+
name|REG_SET_TABLE_SLOP
decl_stmt|;
name|reg_set_table
operator|=
operator|(
expr|struct
name|reg_set
operator|*
operator|*
operator|)
name|grealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_set_table
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|reg_set_table
operator|+
name|reg_set_table_size
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|new_size
operator|-
name|reg_set_table_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|reg_set_table_size
operator|=
name|new_size
expr_stmt|;
block|}
name|new_reg_info
operator|=
operator|(
expr|struct
name|reg_set
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reg_set_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
argument_list|)
expr_stmt|;
name|new_reg_info
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|new_reg_info
operator|->
name|next
operator|=
name|reg_set_table
index|[
name|regno
index|]
expr_stmt|;
name|reg_set_table
index|[
name|regno
index|]
operator|=
name|new_reg_info
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from compute_sets via note_stores to handle one SET or CLOBBER in    an insn.  The DATA is really the instruction in which the SET is    occurring.  */
end_comment

begin_function
specifier|static
name|void
name|record_set_info
parameter_list|(
name|dest
parameter_list|,
name|setter
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|record_set_insn
init|=
operator|(
name|rtx
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|record_one_set
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|,
name|record_set_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the function and record each set of each pseudo-register.     This is called once, at the start of the gcse pass.  See the comments for    `reg_set_table' for further documenation.  */
end_comment

begin_function
specifier|static
name|void
name|compute_sets
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_set_info
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hash table support.  */
end_comment

begin_comment
comment|/* For each register, the cuid of the first/last insn in the block    that set it, or -1 if not set.  */
end_comment

begin_define
define|#
directive|define
name|NEVER_SET
value|-1
end_define

begin_struct
struct|struct
name|reg_avail_info
block|{
name|int
name|last_bb
decl_stmt|;
name|int
name|first_set
decl_stmt|;
name|int
name|last_set
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|reg_avail_info
modifier|*
name|reg_avail_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See whether X, the source of a set, is something we want to consider for    GCSE.  */
end_comment

begin_function
specifier|static
name|int
name|want_to_gcse_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|static
name|rtx
name|test_insn
init|=
literal|0
decl_stmt|;
name|int
name|num_clobbers
init|=
literal|0
decl_stmt|;
name|int
name|icode
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CALL
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|/* If this is a valid operand, we are OK.  If it's VOIDmode, we aren't.  */
if|if
condition|(
name|general_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, check if we can make a valid insn from it.  First initialize      our test insn if we haven't already.  */
if|if
condition|(
name|test_insn
operator|==
literal|0
condition|)
block|{
name|test_insn
operator|=
name|make_insn_raw
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
literal|2
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|test_insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|test_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ggc_add_rtx_root
argument_list|(
operator|&
name|test_insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now make an insn like the one we would make when GCSE'ing and see if      valid.  */
name|PUT_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|test_insn
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|test_insn
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
return|return
operator|(
operator|(
name|icode
operator|=
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|test_insn
argument_list|)
argument_list|,
name|test_insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|num_clobbers
operator|==
literal|0
operator|||
operator|!
name|added_clobbers_hard_reg_p
argument_list|(
name|icode
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the operands of expression X are unchanged from the    start of INSN's basic block up to but not including INSN (if AVAIL_P == 0),    or from INSN to the end of INSN's basic block (if AVAIL_P != 0).  */
end_comment

begin_function
specifier|static
name|int
name|oprs_unchanged_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|avail_p
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|avail_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
block|{
name|struct
name|reg_avail_info
modifier|*
name|info
init|=
operator|&
name|reg_avail_info
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|last_bb
operator|!=
name|current_bb
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|avail_p
condition|)
return|return
name|info
operator|->
name|last_set
operator|<
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|info
operator|->
name|first_set
operator|>=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
return|;
block|}
case|case
name|MEM
case|:
if|if
condition|(
name|load_killed_in_block_p
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|current_bb
argument_list|)
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|x
argument_list|,
name|avail_p
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|oprs_unchanged_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|avail_p
argument_list|)
return|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call needed at this 	     level, change it into iteration.  This function is called enough 	     to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|oprs_unchanged_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|avail_p
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|oprs_unchanged_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|avail_p
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|oprs_unchanged_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|avail_p
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Used for communication between mems_conflict_for_gcse_p and    load_killed_in_block_p.  Nonzero if mems_conflict_for_gcse_p finds a    conflict between two memory references.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gcse_mems_conflict_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for communication between mems_conflict_for_gcse_p and    load_killed_in_block_p.  A memory reference for a load instruction,    mems_conflict_for_gcse_p will see if a memory store conflicts with    this memory load.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|gcse_mem_operand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DEST is the output of an instruction.  If it is a memory reference, and    possibly conflicts with the load found in gcse_mem_operand, then set    gcse_mems_conflict_p to a nonzero value.  */
end_comment

begin_function
specifier|static
name|void
name|mems_conflict_for_gcse_p
parameter_list|(
name|dest
parameter_list|,
name|setter
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If DEST is not a MEM, then it will not conflict with the load.  Note      that function calls are assumed to clobber memory, but are handled      elsewhere.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
comment|/* If we are setting a MEM in our list of specially recognized MEMs,      don't mark as killed this time.  */
if|if
condition|(
name|dest
operator|==
name|gcse_mem_operand
operator|&&
name|pre_ldst_mems
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|find_rtx_in_ldst
argument_list|(
name|dest
argument_list|)
condition|)
name|gcse_mems_conflict_p
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|true_dependence
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|gcse_mem_operand
argument_list|,
name|rtx_addr_varies_p
argument_list|)
condition|)
name|gcse_mems_conflict_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the expression in X (a memory reference) is killed    in block BB before or after the insn with the CUID in UID_LIMIT.    AVAIL_P is nonzero for kills after UID_LIMIT, and zero for kills    before UID_LIMIT.     To check the entire block, set UID_LIMIT to max_uid + 1 and    AVAIL_P to 0.  */
end_comment

begin_function
specifier|static
name|int
name|load_killed_in_block_p
parameter_list|(
name|bb
parameter_list|,
name|uid_limit
parameter_list|,
name|x
parameter_list|,
name|avail_p
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|int
name|uid_limit
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|avail_p
decl_stmt|;
block|{
name|rtx
name|list_entry
init|=
name|modify_mem_list
index|[
name|bb
operator|->
name|index
index|]
decl_stmt|;
while|while
condition|(
name|list_entry
condition|)
block|{
name|rtx
name|setter
decl_stmt|;
comment|/* Ignore entries in the list that do not apply.  */
if|if
condition|(
operator|(
name|avail_p
operator|&&
name|INSN_CUID
argument_list|(
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|uid_limit
operator|)
operator|||
operator|(
operator|!
name|avail_p
operator|&&
name|INSN_CUID
argument_list|(
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|uid_limit
operator|)
condition|)
block|{
name|list_entry
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|setter
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If SETTER is a call everything is clobbered.  Note that calls 	 to pure functions are never put on the list, so we need not 	 worry about them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|1
return|;
comment|/* SETTER must be an INSN of some kind that sets memory.  Call 	 note_stores to examine each hunk of memory that is modified.   	 The note_stores interface is pretty limited, so we have to 	 communicate via global variables.  Yuk.  */
name|gcse_mem_operand
operator|=
name|x
expr_stmt|;
name|gcse_mems_conflict_p
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|setter
argument_list|)
argument_list|,
name|mems_conflict_for_gcse_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_mems_conflict_p
condition|)
return|return
literal|1
return|;
name|list_entry
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the operands of expression X are unchanged from    the start of INSN's basic block up to but not including INSN.  */
end_comment

begin_function
specifier|static
name|int
name|oprs_anticipatable_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
return|return
name|oprs_unchanged_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the operands of expression X are unchanged from    INSN to the end of INSN's basic block.  */
end_comment

begin_function
specifier|static
name|int
name|oprs_available_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
return|return
name|oprs_unchanged_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hash expression X.     MODE is only used if X is a CONST_INT.  DO_NOT_RECORD_P is a boolean    indicating if a volatile operand is found or if the expression contains    something we don't want to insert in the table.     ??? One might want to merge this with canon_hash.  Later.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_expr
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|do_not_record_p
parameter_list|,
name|hash_table_size
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
modifier|*
name|do_not_record_p
decl_stmt|;
name|int
name|hash_table_size
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
operator|*
name|do_not_record_p
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|hash_expr_1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|do_not_record_p
argument_list|)
expr_stmt|;
return|return
name|hash
operator|%
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Hash a string.  Just add its bytes up.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|hash_string_1
parameter_list|(
name|ps
parameter_list|)
specifier|const
name|char
modifier|*
name|ps
decl_stmt|;
block|{
name|unsigned
name|hash
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|ps
decl_stmt|;
if|if
condition|(
name|p
condition|)
while|while
condition|(
operator|*
name|p
condition|)
name|hash
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of hash_expr to do the actual work.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_expr_1
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|do_not_record_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
modifier|*
name|do_not_record_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|hash
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Used to turn recursion into iteration.  We can't rely on GCC's      tail-recursion eliminatio since we need to keep accumulating values      in HASH.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|hash
return|;
name|repeat
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
name|hash
operator|+=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|REG
operator|<<
literal|7
operator|)
operator|+
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|CONST_INT
case|:
name|hash
operator|+=
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|CONST_INT
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
name|int
operator|)
name|mode
operator|+
operator|(
name|unsigned
name|int
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* This is like the general case, except that it only counts 	 the integers representing the constant.  */
name|hash
operator|+=
operator|(
name|unsigned
name|int
operator|)
name|code
operator|+
operator|(
name|unsigned
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|CONST_DOUBLE
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash
operator|+=
operator|(
name|unsigned
name|int
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|hash
operator|+=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|unsigned
name|int
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
comment|/* Assume there is only one rtx object for any given label.  */
case|case
name|LABEL_REF
case|:
comment|/* We don't hash on the address of the CODE_LABEL to avoid bootstrap 	 differences and differences between each stage's debugging dumps.  */
name|hash
operator|+=
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|LABEL_REF
operator|<<
literal|7
operator|)
operator|+
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|SYMBOL_REF
case|:
block|{
comment|/* Don't hash on the symbol's address to avoid bootstrap differences. 	   Different hash values may cause expressions to be recorded in 	   different orders and thus different registers to be used in the 	   final assembler.  This also avoids differences in the dump files 	   between various stages.  */
name|unsigned
name|int
name|h
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|h
operator|+=
operator|(
name|h
operator|<<
literal|7
operator|)
operator|+
operator|*
name|p
operator|++
expr_stmt|;
comment|/* ??? revisit */
name|hash
operator|+=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|SYMBOL_REF
operator|<<
literal|7
operator|)
operator|+
name|h
expr_stmt|;
return|return
name|hash
return|;
block|}
case|case
name|MEM
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|do_not_record_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hash
operator|+=
operator|(
name|unsigned
name|int
operator|)
name|MEM
expr_stmt|;
name|hash
operator|+=
name|MEM_ALIAS_SET
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
operator|*
name|do_not_record_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|do_not_record_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* We don't want to take the filename and line into account.  */
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|+
name|hash_string_1
argument_list|(
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
name|hash_string_1
argument_list|(
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|+=
operator|(
name|hash_expr_1
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|do_not_record_p
argument_list|)
operator|+
name|hash_string_1
argument_list|(
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|hash
operator|+=
name|hash_string_1
argument_list|(
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
return|return
name|hash
return|;
block|}
default|default:
break|break;
block|}
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|hash
operator|+=
name|hash_expr_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|do_not_record_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|do_not_record_p
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|hash
operator|+=
name|hash_expr_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
name|do_not_record_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|do_not_record_p
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
name|hash
operator|+=
name|hash_string_1
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
name|hash
operator|+=
operator|(
name|unsigned
name|int
operator|)
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Hash a set of register REGNO.     Sets are hashed on the register that is set.  This simplifies the PRE copy    propagation code.     ??? May need to make things more elaborate.  Later, as necessary.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_set
parameter_list|(
name|regno
parameter_list|,
name|hash_table_size
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|hash_table_size
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
name|hash
operator|=
name|regno
expr_stmt|;
return|return
name|hash
operator|%
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if exp1 is equivalent to exp2.    ??? Borrowed from cse.c.  Might want to remerge with cse.c.  Later.  */
end_comment

begin_function
specifier|static
name|int
name|expr_equiv_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
name|x
operator|==
name|y
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|x
operator|==
name|y
return|;
case|case
name|CONST_INT
case|:
return|return
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|y
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|REG
case|:
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
return|;
case|case
name|MEM
case|:
comment|/* Can't merge two expressions in different alias sets, since we can 	 decide that the expression is transparent in a block when it isn't, 	 due to it being set with the different alias set.  */
if|if
condition|(
name|MEM_ALIAS_SET
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM_ALIAS_SET
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
comment|/*  For commutative operations, check both orders.  */
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
return|return
operator|(
operator|(
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
return|;
case|case
name|ASM_OPERANDS
case|:
comment|/* We don't use the generic code below because we want to 	 disregard filename and line numbers.  */
comment|/* A volatile asm isn't equivalent to any other.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|||
name|strcmp
argument_list|(
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|y
argument_list|)
argument_list|)
operator|||
name|strcmp
argument_list|(
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|y
argument_list|)
argument_list|)
operator|||
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|x
argument_list|)
operator|!=
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|y
argument_list|)
operator|||
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|!=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|expr_equiv_p
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|||
name|strcmp
argument_list|(
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole thing.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|expr_equiv_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'0'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Insert expression X in INSN in the hash table.    If it is already present, record it as the last occurrence in INSN's    basic block.     MODE is the mode of the value X is being stored into.    It is only used if X is a CONST_INT.     ANTIC_P is non-zero if X is an anticipatable expression.    AVAIL_P is non-zero if X is an available expression.  */
end_comment

begin_function
specifier|static
name|void
name|insert_expr_in_table
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|insn
parameter_list|,
name|antic_p
parameter_list|,
name|avail_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|antic_p
decl_stmt|,
name|avail_p
decl_stmt|;
block|{
name|int
name|found
decl_stmt|,
name|do_not_record_p
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|struct
name|expr
modifier|*
name|cur_expr
decl_stmt|,
modifier|*
name|last_expr
init|=
name|NULL
decl_stmt|;
name|struct
name|occr
modifier|*
name|antic_occr
decl_stmt|,
modifier|*
name|avail_occr
decl_stmt|;
name|struct
name|occr
modifier|*
name|last_occr
init|=
name|NULL
decl_stmt|;
name|hash
operator|=
name|hash_expr
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
operator|&
name|do_not_record_p
argument_list|,
name|expr_hash_table_size
argument_list|)
expr_stmt|;
comment|/* Do not insert expression in table if it contains volatile operands,      or if hash_expr determines the expression is something we don't want      to or can't handle.  */
if|if
condition|(
name|do_not_record_p
condition|)
return|return;
name|cur_expr
operator|=
name|expr_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cur_expr
operator|&&
literal|0
operator|==
operator|(
name|found
operator|=
name|expr_equiv_p
argument_list|(
name|cur_expr
operator|->
name|expr
argument_list|,
name|x
argument_list|)
operator|)
condition|)
block|{
comment|/* If the expression isn't found, save a pointer to the end of 	 the list.  */
name|last_expr
operator|=
name|cur_expr
expr_stmt|;
name|cur_expr
operator|=
name|cur_expr
operator|->
name|next_same_hash
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|cur_expr
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|)
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr_hash_table
index|[
name|hash
index|]
operator|==
name|NULL
condition|)
comment|/* This is the first pattern that hashed to this index.  */
name|expr_hash_table
index|[
name|hash
index|]
operator|=
name|cur_expr
expr_stmt|;
else|else
comment|/* Add EXPR to end of this hash chain.  */
name|last_expr
operator|->
name|next_same_hash
operator|=
name|cur_expr
expr_stmt|;
comment|/* Set the fields of the expr element.  */
name|cur_expr
operator|->
name|expr
operator|=
name|x
expr_stmt|;
name|cur_expr
operator|->
name|bitmap_index
operator|=
name|n_exprs
operator|++
expr_stmt|;
name|cur_expr
operator|->
name|next_same_hash
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|antic_occr
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|avail_occr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now record the occurrence(s).  */
if|if
condition|(
name|antic_p
condition|)
block|{
name|antic_occr
operator|=
name|cur_expr
operator|->
name|antic_occr
expr_stmt|;
comment|/* Search for another occurrence in the same basic block.  */
while|while
condition|(
name|antic_occr
operator|&&
name|BLOCK_NUM
argument_list|(
name|antic_occr
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If an occurrence isn't found, save a pointer to the end of 	     the list.  */
name|last_occr
operator|=
name|antic_occr
expr_stmt|;
name|antic_occr
operator|=
name|antic_occr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|antic_occr
condition|)
comment|/* Found another instance of the expression in the same basic block. 	   Prefer the currently recorded one.  We want the first one in the 	   block and the block is scanned from start to end.  */
empty_stmt|;
comment|/* nothing to do */
else|else
block|{
comment|/* First occurrence of this expression in this basic block.  */
name|antic_occr
operator|=
operator|(
expr|struct
name|occr
operator|*
operator|)
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
expr_stmt|;
comment|/* First occurrence of this expression in any block?  */
if|if
condition|(
name|cur_expr
operator|->
name|antic_occr
operator|==
name|NULL
condition|)
name|cur_expr
operator|->
name|antic_occr
operator|=
name|antic_occr
expr_stmt|;
else|else
name|last_occr
operator|->
name|next
operator|=
name|antic_occr
expr_stmt|;
name|antic_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|antic_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|avail_p
condition|)
block|{
name|avail_occr
operator|=
name|cur_expr
operator|->
name|avail_occr
expr_stmt|;
comment|/* Search for another occurrence in the same basic block.  */
while|while
condition|(
name|avail_occr
operator|&&
name|BLOCK_NUM
argument_list|(
name|avail_occr
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If an occurrence isn't found, save a pointer to the end of 	     the list.  */
name|last_occr
operator|=
name|avail_occr
expr_stmt|;
name|avail_occr
operator|=
name|avail_occr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|avail_occr
condition|)
comment|/* Found another instance of the expression in the same basic block. 	   Prefer this occurrence to the currently recorded one.  We want 	   the last one in the block and the block is scanned from start 	   to end.  */
name|avail_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
comment|/* First occurrence of this expression in this basic block.  */
name|avail_occr
operator|=
operator|(
expr|struct
name|occr
operator|*
operator|)
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
expr_stmt|;
comment|/* First occurrence of this expression in any block?  */
if|if
condition|(
name|cur_expr
operator|->
name|avail_occr
operator|==
name|NULL
condition|)
name|cur_expr
operator|->
name|avail_occr
operator|=
name|avail_occr
expr_stmt|;
else|else
name|last_occr
operator|->
name|next
operator|=
name|avail_occr
expr_stmt|;
name|avail_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|avail_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Insert pattern X in INSN in the hash table.    X is a SET of a reg to either another reg or a constant.    If it is already present, record it as the last occurrence in INSN's    basic block.  */
end_comment

begin_function
specifier|static
name|void
name|insert_set_in_table
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|found
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|struct
name|expr
modifier|*
name|cur_expr
decl_stmt|,
modifier|*
name|last_expr
init|=
name|NULL
decl_stmt|;
name|struct
name|occr
modifier|*
name|cur_occr
decl_stmt|,
modifier|*
name|last_occr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|hash
operator|=
name|hash_set
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|set_hash_table_size
argument_list|)
expr_stmt|;
name|cur_expr
operator|=
name|set_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cur_expr
operator|&&
literal|0
operator|==
operator|(
name|found
operator|=
name|expr_equiv_p
argument_list|(
name|cur_expr
operator|->
name|expr
argument_list|,
name|x
argument_list|)
operator|)
condition|)
block|{
comment|/* If the expression isn't found, save a pointer to the end of 	 the list.  */
name|last_expr
operator|=
name|cur_expr
expr_stmt|;
name|cur_expr
operator|=
name|cur_expr
operator|->
name|next_same_hash
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|cur_expr
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|)
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_hash_table
index|[
name|hash
index|]
operator|==
name|NULL
condition|)
comment|/* This is the first pattern that hashed to this index.  */
name|set_hash_table
index|[
name|hash
index|]
operator|=
name|cur_expr
expr_stmt|;
else|else
comment|/* Add EXPR to end of this hash chain.  */
name|last_expr
operator|->
name|next_same_hash
operator|=
name|cur_expr
expr_stmt|;
comment|/* Set the fields of the expr element. 	 We must copy X because it can be modified when copy propagation is 	 performed on its operands.  */
name|cur_expr
operator|->
name|expr
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|cur_expr
operator|->
name|bitmap_index
operator|=
name|n_sets
operator|++
expr_stmt|;
name|cur_expr
operator|->
name|next_same_hash
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|antic_occr
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|avail_occr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now record the occurrence.  */
name|cur_occr
operator|=
name|cur_expr
operator|->
name|avail_occr
expr_stmt|;
comment|/* Search for another occurrence in the same basic block.  */
while|while
condition|(
name|cur_occr
operator|&&
name|BLOCK_NUM
argument_list|(
name|cur_occr
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If an occurrence isn't found, save a pointer to the end of 	 the list.  */
name|last_occr
operator|=
name|cur_occr
expr_stmt|;
name|cur_occr
operator|=
name|cur_occr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|cur_occr
condition|)
comment|/* Found another instance of the expression in the same basic block.        Prefer this occurrence to the currently recorded one.  We want the        last one in the block and the block is scanned from start to end.  */
name|cur_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
comment|/* First occurrence of this expression in this basic block.  */
name|cur_occr
operator|=
operator|(
expr|struct
name|occr
operator|*
operator|)
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
expr_stmt|;
comment|/* First occurrence of this expression in any block?  */
if|if
condition|(
name|cur_expr
operator|->
name|avail_occr
operator|==
name|NULL
condition|)
name|cur_expr
operator|->
name|avail_occr
operator|=
name|cur_occr
expr_stmt|;
else|else
name|last_occr
operator|->
name|next
operator|=
name|cur_occr
expr_stmt|;
name|cur_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|cur_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan pattern PAT of INSN and add an entry to the hash table.  If SET_P is    non-zero, this is for the assignment hash table, otherwise it is for the    expression hash table.  */
end_comment

begin_function
specifier|static
name|void
name|hash_scan_set
parameter_list|(
name|pat
parameter_list|,
name|insn
parameter_list|,
name|set_p
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|set_p
decl_stmt|;
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CALL
condition|)
name|hash_scan_call
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* If this is a single set and we are doing constant propagation, 	 see if a REG_NOTE shows this equivalent to a constant.  */
if|if
condition|(
name|set_p
operator|&&
operator|(
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|,
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* Only record sets of pseudo-regs in the hash table.  */
if|if
condition|(
operator|!
name|set_p
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
comment|/* Don't GCSE something if we can't do a reg/reg copy.  */
operator|&&
name|can_copy_p
index|[
name|GET_MODE
argument_list|(
name|dest
argument_list|)
index|]
comment|/* Is SET_SRC something we want to gcse?  */
operator|&&
name|want_to_gcse_p
argument_list|(
name|src
argument_list|)
comment|/* Don't CSE a nop.  */
operator|&&
operator|!
name|set_noop_p
argument_list|(
name|pat
argument_list|)
comment|/* Don't GCSE if it has attached REG_EQUIV note. 	     At this point this only function parameters should have 	     REG_EQUIV notes and if the argument slot is used somewhere 	     explicitly, it means address of parameter has been taken, 	     so we should not extend the lifetime of the pseudo.  */
operator|&&
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|)
condition|)
block|{
comment|/* An expression is not anticipatable if its operands are 	     modified before this insn or if this is not the only SET in 	     this insn.  */
name|int
name|antic_p
init|=
name|oprs_anticipatable_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
operator|&&
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* An expression is not available if its operands are 	     subsequently modified, including this insn.  It's also not 	     available if this is a branch, because we can't insert 	     a set after the branch.  */
name|int
name|avail_p
init|=
operator|(
name|oprs_available_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
operator|&&
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|)
decl_stmt|;
name|insert_expr_in_table
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|insn
argument_list|,
name|antic_p
argument_list|,
name|avail_p
argument_list|)
expr_stmt|;
block|}
comment|/* Record sets for constant/copy propagation.  */
elseif|else
if|if
condition|(
name|set_p
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|can_copy_p
index|[
name|GET_MODE
argument_list|(
name|dest
argument_list|)
index|]
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|!=
name|regno
operator|)
operator|||
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|)
comment|/* A copy is not available if its src or dest is subsequently 		  modified.  Here we want to search from INSN+1 on, but 		  oprs_available_p searches from INSN on.  */
operator|&&
operator|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|tmp
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|oprs_available_p
argument_list|(
name|pat
argument_list|,
name|tmp
argument_list|)
operator|)
operator|)
condition|)
name|insert_set_in_table
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hash_scan_clobber
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Currently nothing to do.  */
block|}
end_function

begin_function
specifier|static
name|void
name|hash_scan_call
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Currently nothing to do.  */
block|}
end_function

begin_comment
comment|/* Process INSN and add hash table entries as appropriate.     Only available expressions that set a single pseudo-reg are recorded.     Single sets in a PARALLEL could be handled, but it's an extra complication    that isn't dealt with right now.  The trick is handling the CLOBBERs that    are also in the PARALLEL.  Later.     If SET_P is non-zero, this is for the assignment hash table,    otherwise it is for the expression hash table.    If IN_LIBCALL_BLOCK nonzero, we are in a libcall block, and should    not record any expressions.  */
end_comment

begin_function
specifier|static
name|void
name|hash_scan_insn
parameter_list|(
name|insn
parameter_list|,
name|set_p
parameter_list|,
name|in_libcall_block
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|set_p
decl_stmt|;
name|int
name|in_libcall_block
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|in_libcall_block
condition|)
return|return;
comment|/* Pick out the sets of INSN and for other forms of instructions record      what's been modified.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
name|hash_scan_set
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
name|set_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|hash_scan_set
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|set_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
name|hash_scan_clobber
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
name|hash_scan_call
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
name|hash_scan_clobber
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL
condition|)
name|hash_scan_call
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_hash_table
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|,
name|table
parameter_list|,
name|table_size
parameter_list|,
name|total_size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|expr
modifier|*
modifier|*
name|table
decl_stmt|;
name|int
name|table_size
decl_stmt|,
name|total_size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Flattened out table, so it's printed in proper order.  */
name|struct
name|expr
modifier|*
modifier|*
name|flat_table
decl_stmt|;
name|unsigned
name|int
modifier|*
name|hash_val
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|flat_table
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|total_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|hash_val
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|total_size
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
name|flat_table
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|expr
expr_stmt|;
name|hash_val
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|i
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s hash table (%d buckets, %d entries)\n"
argument_list|,
name|name
argument_list|,
name|table_size
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flat_table
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|expr
operator|=
name|flat_table
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Index %d (hash value %d)\n  "
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|,
name|hash_val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|expr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|flat_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hash_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record register first/last/block set information for REGNO in INSN.     first_set records the first place in the block where the register    is set and is used to compute "anticipatability".     last_set records the last place in the block where the register    is set and is used to compute "availability".     last_bb records the block for which first_set and last_set are    valid, as a quick test to invalidate them.     reg_set_in_block records whether the register is set in the block    and is used to compute "transparency".  */
end_comment

begin_function
specifier|static
name|void
name|record_last_reg_set_info
parameter_list|(
name|insn
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|reg_avail_info
modifier|*
name|info
init|=
operator|&
name|reg_avail_info
index|[
name|regno
index|]
decl_stmt|;
name|int
name|cuid
init|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|info
operator|->
name|last_set
operator|=
name|cuid
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|last_bb
operator|!=
name|current_bb
condition|)
block|{
name|info
operator|->
name|last_bb
operator|=
name|current_bb
expr_stmt|;
name|info
operator|->
name|first_set
operator|=
name|cuid
expr_stmt|;
name|SET_BIT
argument_list|(
name|reg_set_in_block
index|[
name|current_bb
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record all of the canonicalized MEMs of record_last_mem_set_info's insn.    Note we store a pair of elements in the list, so they have to be    taken off pairwise.  */
end_comment

begin_function
specifier|static
name|void
name|canon_list_insert
parameter_list|(
name|dest
parameter_list|,
name|unused1
parameter_list|,
name|v_insn
parameter_list|)
name|rtx
name|dest
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|rtx
name|unused1
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|v_insn
decl_stmt|;
block|{
name|rtx
name|dest_addr
decl_stmt|,
name|insn
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If DEST is not a MEM, then it will not conflict with a load.  Note      that function calls are assumed to clobber memory, but are handled      elsewhere.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
name|dest_addr
operator|=
name|get_addr
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|canon_rtx
argument_list|(
name|dest_addr
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|rtx
operator|)
name|v_insn
expr_stmt|;
name|canon_modify_mem_list
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|dest_addr
argument_list|,
name|canon_modify_mem_list
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|canon_modify_mem_list
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|dest
argument_list|,
name|canon_modify_mem_list
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|canon_modify_mem_list_set
argument_list|,
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record memory modification information for INSN.  We do not actually care    about the memory location(s) that are set, or even how they are set (consider    a CALL_INSN).  We merely need to record which insns modify memory.  */
end_comment

begin_function
specifier|static
name|void
name|record_last_mem_set_info
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* load_killed_in_block_p will handle the case of calls clobbering      everything.  */
name|modify_mem_list
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|modify_mem_list
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|modify_mem_list_set
argument_list|,
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* Note that traversals of this loop (other than for free-ing) 	 will break after encountering a CALL_INSN.  So, there's no 	 need to insert a pair of items, as canon_list_insert does.  */
name|canon_modify_mem_list
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|canon_modify_mem_list
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|canon_modify_mem_list_set
argument_list|,
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|canon_list_insert
argument_list|,
operator|(
name|void
operator|*
operator|)
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from compute_hash_table via note_stores to handle one    SET or CLOBBER in an insn.  DATA is really the instruction in which    the SET is taking place.  */
end_comment

begin_function
specifier|static
name|void
name|record_last_set_info
parameter_list|(
name|dest
parameter_list|,
name|setter
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|rtx
name|last_set_insn
init|=
operator|(
name|rtx
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|record_last_reg_set_info
argument_list|(
name|last_set_insn
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
comment|/* Ignore pushes, they clobber nothing.  */
operator|&&
operator|!
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
name|record_last_mem_set_info
argument_list|(
name|last_set_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level function to create an expression or assignment hash table.     Expression entries are placed in the hash table if    - they are of the form (set (pseudo-reg) src),    - src is something we want to perform GCSE on,    - none of the operands are subsequently modified in the block     Assignment entries are placed in the hash table if    - they are of the form (set (pseudo-reg) src),    - src is something we want to perform const/copy propagation on,    - none of the operands or target are subsequently modified in the block     Currently src must be a pseudo-reg or a const_int.     F is the first insn.    SET_P is non-zero for computing the assignment hash table.  */
end_comment

begin_function
specifier|static
name|void
name|compute_hash_table
parameter_list|(
name|set_p
parameter_list|)
name|int
name|set_p
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* While we compute the hash table we also compute a bit array of which      registers are set in which blocks.      ??? This isn't needed during const/copy propagation, but it's cheap to      compute.  Later.  */
name|sbitmap_vector_zero
argument_list|(
name|reg_set_in_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* re-Cache any INSN_LIST nodes we have allocated.  */
name|clear_modify_mem_tables
argument_list|()
expr_stmt|;
comment|/* Some working arrays used to track first and last set in each block.  */
name|reg_avail_info
operator|=
operator|(
expr|struct
name|reg_avail_info
operator|*
operator|)
name|gmalloc
argument_list|(
name|max_gcse_regno
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_avail_info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_gcse_regno
condition|;
operator|++
name|i
control|)
name|reg_avail_info
index|[
name|i
index|]
operator|.
name|last_bb
operator|=
name|NEVER_SET
expr_stmt|;
for|for
control|(
name|current_bb
operator|=
literal|0
init|;
name|current_bb
operator|<
name|n_basic_blocks
condition|;
name|current_bb
operator|++
control|)
block|{
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|in_libcall_block
decl_stmt|;
comment|/* First pass over the instructions records information used to 	 determine when registers and memory are first and last set. 	 ??? hard-reg reg_set_in_block computation 	 could be moved to compute_sets since they currently don't change.  */
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|current_bb
argument_list|)
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|current_bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|bool
name|clobbers_all
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|clobbers_all
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|clobbers_all
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
condition|)
name|record_last_reg_set_info
argument_list|(
name|insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|mark_call
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_last_set_info
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* The next pass builds the hash table.  */
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|current_bb
argument_list|)
operator|,
name|in_libcall_block
operator|=
literal|0
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|current_bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|set_p
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|0
expr_stmt|;
name|hash_scan_insn
argument_list|(
name|insn
argument_list|,
name|set_p
argument_list|,
name|in_libcall_block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_p
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|reg_avail_info
argument_list|)
expr_stmt|;
name|reg_avail_info
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate space for the set hash table.    N_INSNS is the number of instructions in the function.    It is used to determine the number of buckets to use.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_set_hash_table
parameter_list|(
name|n_insns
parameter_list|)
name|int
name|n_insns
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|set_hash_table_size
operator|=
name|n_insns
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|set_hash_table_size
operator|<
literal|11
condition|)
name|set_hash_table_size
operator|=
literal|11
expr_stmt|;
comment|/* Attempt to maintain efficient use of hash table.      Making it an odd number is simplest for now.      ??? Later take some measurements.  */
name|set_hash_table_size
operator||=
literal|1
expr_stmt|;
name|n
operator|=
name|set_hash_table_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
expr_stmt|;
name|set_hash_table
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
name|gmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free things allocated by alloc_set_hash_table.  */
end_comment

begin_function
specifier|static
name|void
name|free_set_hash_table
parameter_list|()
block|{
name|free
argument_list|(
name|set_hash_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the hash table for doing copy/const propagation.  */
end_comment

begin_function
specifier|static
name|void
name|compute_set_hash_table
parameter_list|()
block|{
comment|/* Initialize count of number of entries in hash table.  */
name|n_sets
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|set_hash_table
argument_list|,
literal|0
argument_list|,
name|set_hash_table_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|compute_hash_table
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate space for the expression hash table.    N_INSNS is the number of instructions in the function.    It is used to determine the number of buckets to use.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_expr_hash_table
parameter_list|(
name|n_insns
parameter_list|)
name|unsigned
name|int
name|n_insns
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|expr_hash_table_size
operator|=
name|n_insns
operator|/
literal|2
expr_stmt|;
comment|/* Make sure the amount is usable.  */
if|if
condition|(
name|expr_hash_table_size
operator|<
literal|11
condition|)
name|expr_hash_table_size
operator|=
literal|11
expr_stmt|;
comment|/* Attempt to maintain efficient use of hash table.      Making it an odd number is simplest for now.      ??? Later take some measurements.  */
name|expr_hash_table_size
operator||=
literal|1
expr_stmt|;
name|n
operator|=
name|expr_hash_table_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
expr_stmt|;
name|expr_hash_table
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
name|gmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free things allocated by alloc_expr_hash_table.  */
end_comment

begin_function
specifier|static
name|void
name|free_expr_hash_table
parameter_list|()
block|{
name|free
argument_list|(
name|expr_hash_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the hash table for doing GCSE.  */
end_comment

begin_function
specifier|static
name|void
name|compute_expr_hash_table
parameter_list|()
block|{
comment|/* Initialize count of number of entries in hash table.  */
name|n_exprs
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expr_hash_table
argument_list|,
literal|0
argument_list|,
name|expr_hash_table_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|compute_hash_table
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expression tracking support.  */
end_comment

begin_comment
comment|/* Lookup pattern PAT in the expression table.    The result is a pointer to the table entry, or NULL if not found.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|lookup_expr
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
name|int
name|do_not_record_p
decl_stmt|;
name|unsigned
name|int
name|hash
init|=
name|hash_expr
argument_list|(
name|pat
argument_list|,
name|GET_MODE
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|do_not_record_p
argument_list|,
name|expr_hash_table_size
argument_list|)
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
if|if
condition|(
name|do_not_record_p
condition|)
return|return
name|NULL
return|;
name|expr
operator|=
name|expr_hash_table
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|expr
operator|&&
operator|!
name|expr_equiv_p
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|pat
argument_list|)
condition|)
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Lookup REGNO in the set table.  If PAT is non-NULL look for the entry that    matches it, otherwise return the first entry for REGNO.  The result is a    pointer to the table entry, or NULL if not found.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|lookup_set
parameter_list|(
name|regno
parameter_list|,
name|pat
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
init|=
name|hash_set
argument_list|(
name|regno
argument_list|,
name|set_hash_table_size
argument_list|)
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|expr
operator|=
name|set_hash_table
index|[
name|hash
index|]
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
while|while
condition|(
name|expr
operator|&&
operator|!
name|expr_equiv_p
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|pat
argument_list|)
condition|)
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|expr
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
argument_list|)
operator|!=
name|regno
condition|)
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Return the next entry for REGNO in list EXPR.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|next_set
parameter_list|(
name|regno
parameter_list|,
name|expr
parameter_list|)
name|unsigned
name|int
name|regno
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
block|{
do|do
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
do|while
condition|(
name|expr
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
argument_list|)
operator|!=
name|regno
condition|)
do|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Clear canon_modify_mem_list and modify_mem_list tables.  */
end_comment

begin_function
specifier|static
name|void
name|clear_modify_mem_tables
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
name|canon_modify_mem_list_set
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|free_INSN_LIST_list
argument_list|(
name|modify_mem_list
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|canon_modify_mem_list_set
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
name|canon_modify_mem_list_set
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|free_INSN_LIST_list
argument_list|(
name|canon_modify_mem_list
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|modify_mem_list_set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release memory used by modify_mem_list_set and canon_modify_mem_list_set.  */
end_comment

begin_function
specifier|static
name|void
name|free_modify_mem_tables
parameter_list|()
block|{
name|clear_modify_mem_tables
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|modify_mem_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|canon_modify_mem_list
argument_list|)
expr_stmt|;
name|modify_mem_list
operator|=
literal|0
expr_stmt|;
name|canon_modify_mem_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset tables used to keep track of what's still available [since the    start of the block].  */
end_comment

begin_function
specifier|static
name|void
name|reset_opr_set_tables
parameter_list|()
block|{
comment|/* Maintain a bitmap of which regs have been set since beginning of      the block.  */
name|CLEAR_REG_SET
argument_list|(
name|reg_set_bitmap
argument_list|)
expr_stmt|;
comment|/* Also keep a record of the last instruction to modify memory.      For now this is very trivial, we only record whether any memory      location has been modified.  */
name|clear_modify_mem_tables
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the operands of X are not set before INSN in    INSN's basic block.  */
end_comment

begin_function
specifier|static
name|int
name|oprs_not_set_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|load_killed_in_block_p
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|oprs_not_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
case|case
name|REG
case|:
return|return
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|reg_set_bitmap
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|oprs_not_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
if|if
condition|(
operator|!
name|oprs_not_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|oprs_not_set_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Mark things set by a CALL.  */
end_comment

begin_function
specifier|static
name|void
name|mark_call
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|record_last_mem_set_info
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark things set by a SET.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set
parameter_list|(
name|pat
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_set_bitmap
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|record_last_mem_set_info
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
name|mark_call
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record things set by a CLOBBER.  */
end_comment

begin_function
specifier|static
name|void
name|mark_clobber
parameter_list|(
name|pat
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|clob
init|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|clob
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|clob
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|clob
operator|=
name|XEXP
argument_list|(
name|clob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|clob
argument_list|)
operator|==
name|REG
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_set_bitmap
argument_list|,
name|REGNO
argument_list|(
name|clob
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|record_last_mem_set_info
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record things set by INSN.    This data is used by oprs_not_set_p.  */
end_comment

begin_function
specifier|static
name|void
name|mark_oprs_set
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
name|mark_set
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|mark_set
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_clobber
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
name|mark_call
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_clobber
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL
condition|)
name|mark_call
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Classic GCSE reaching definition support.  */
end_comment

begin_comment
comment|/* Allocate reaching def variables.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_rd_mem
parameter_list|(
name|n_blocks
parameter_list|,
name|n_insns
parameter_list|)
name|int
name|n_blocks
decl_stmt|,
name|n_insns
decl_stmt|;
block|{
name|rd_kill
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|rd_kill
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|rd_gen
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|rd_gen
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|reaching_defs
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|reaching_defs
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|rd_out
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|rd_out
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free reaching def variables.  */
end_comment

begin_function
specifier|static
name|void
name|free_rd_mem
parameter_list|()
block|{
name|sbitmap_vector_free
argument_list|(
name|rd_kill
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|rd_gen
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|reaching_defs
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|rd_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN to the kills of BB.  REGNO, set in BB, is killed by INSN.  */
end_comment

begin_function
specifier|static
name|void
name|handle_rd_kill_set
parameter_list|(
name|insn
parameter_list|,
name|regno
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|struct
name|reg_set
modifier|*
name|this_reg
decl_stmt|;
for|for
control|(
name|this_reg
operator|=
name|reg_set_table
index|[
name|regno
index|]
init|;
name|this_reg
condition|;
name|this_reg
operator|=
name|this_reg
operator|->
name|next
control|)
if|if
condition|(
name|BLOCK_NUM
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|rd_kill
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|INSN_CUID
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the set of kill's for reaching definitions.  */
end_comment

begin_function
specifier|static
name|void
name|compute_kill_rd
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|cuid
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* For each block        For each set bit in `gen' of the block (i.e each insn which 	   generates a definition in the block) 	 Call the reg set by the insn corresponding to that bit regx 	 Look at the linked list starting at reg_set_table[regx] 	 For each setting of regx in the linked list, which is not in 	     this block 	   Set the bit in `kill' corresponding to that insn.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
for|for
control|(
name|cuid
operator|=
literal|0
init|;
name|cuid
operator|<
name|max_cuid
condition|;
name|cuid
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|rd_gen
index|[
name|bb
index|]
argument_list|,
name|cuid
argument_list|)
condition|)
block|{
name|rtx
name|insn
init|=
name|CUID_INSN
argument_list|(
name|cuid
argument_list|)
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
condition|)
name|handle_rd_kill_set
argument_list|(
name|insn
argument_list|,
name|regno
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|handle_rd_kill_set
argument_list|(
name|insn
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
comment|/* Each setting of this register outside of this block 	       must be marked in the set of kills in this block.  */
name|handle_rd_kill_set
argument_list|(
name|insn
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the reaching definitions as in     Compilers Principles, Techniques, and Tools. Aho, Sethi, Ullman,    Chapter 10.  It is the same algorithm as used for computing available    expressions but applied to the gens and kills of reaching definitions.  */
end_comment

begin_function
specifier|static
name|void
name|compute_rd
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
name|sbitmap_copy
argument_list|(
name|rd_out
index|[
name|bb
index|]
comment|/*dst*/
argument_list|,
name|rd_gen
index|[
name|bb
index|]
comment|/*src*/
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|sbitmap_union_of_preds
argument_list|(
name|reaching_defs
index|[
name|bb
index|]
argument_list|,
name|rd_out
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_union_of_diff
argument_list|(
name|rd_out
index|[
name|bb
index|]
argument_list|,
name|rd_gen
index|[
name|bb
index|]
argument_list|,
name|reaching_defs
index|[
name|bb
index|]
argument_list|,
name|rd_kill
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"reaching def computation: %d passes\n"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Classic GCSE available expression support.  */
end_comment

begin_comment
comment|/* Allocate memory for available expression computation.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_avail_expr_mem
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|)
name|int
name|n_blocks
decl_stmt|,
name|n_exprs
decl_stmt|;
block|{
name|ae_kill
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_kill
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|ae_gen
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_gen
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|ae_in
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_in
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|ae_out
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_out
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_avail_expr_mem
parameter_list|()
block|{
name|sbitmap_vector_free
argument_list|(
name|ae_kill
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|ae_gen
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|ae_in
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|ae_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the set of available expressions generated in each basic block.  */
end_comment

begin_function
specifier|static
name|void
name|compute_ae_gen
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
comment|/* For each recorded occurrence of each expression, set ae_gen[bb][expr].      This is all we have to do because an expression is not recorded if it      is not available, and the only expressions we want to work with are the      ones that are recorded.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
operator|!=
literal|0
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|occr
operator|!=
literal|0
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
name|SET_BIT
argument_list|(
name|ae_gen
index|[
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero if expression X is killed in BB.  */
end_comment

begin_function
specifier|static
name|int
name|expr_killed_p
parameter_list|(
name|x
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
return|return
name|TEST_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|load_killed_in_block_p
argument_list|(
name|bb
argument_list|,
name|get_max_uid
argument_list|()
operator|+
literal|1
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
name|expr_killed_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb
argument_list|)
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|expr_killed_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|bb
argument_list|)
return|;
elseif|else
if|if
condition|(
name|expr_killed_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|bb
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|expr_killed_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|bb
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the set of available expressions killed in each basic block.  */
end_comment

begin_function
specifier|static
name|void
name|compute_ae_kill
parameter_list|(
name|ae_gen
parameter_list|,
name|ae_kill
parameter_list|)
name|sbitmap
modifier|*
name|ae_gen
decl_stmt|,
decl|*
name|ae_kill
decl_stmt|;
end_function

begin_block
block|{
name|int
name|bb
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
comment|/* Skip EXPR if generated in this block.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|expr_killed_p
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|ae_kill
index|[
name|bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Actually perform the Classic GCSE optimizations.  */
end_comment

begin_comment
comment|/* Return non-zero if occurrence OCCR of expression EXPR reaches block BB.     CHECK_SELF_LOOP is non-zero if we should consider a block reaching itself    as a positive reach.  We want to do this when there are two computations    of the expression in the block.     VISITED is a pointer to a working buffer for tracking which BB's have    been visited.  It is NULL for the top-level call.     We treat reaching expressions that go through blocks containing the same    reaching expression as "not reaching".  E.g. if EXPR is generated in blocks    2 and 3, INSN is in block 4, and 2->3->4, we treat the expression in block    2 as not reaching.  The intent is to improve the probability of finding    only one reaching expression and to reduce register lifetimes by picking    the closest such expression.  */
end_comment

begin_function
specifier|static
name|int
name|expr_reaches_here_p_work
parameter_list|(
name|occr
parameter_list|,
name|expr
parameter_list|,
name|bb
parameter_list|,
name|check_self_loop
parameter_list|,
name|visited
parameter_list|)
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|check_self_loop
decl_stmt|;
name|char
modifier|*
name|visited
decl_stmt|;
block|{
name|edge
name|pred
decl_stmt|;
for|for
control|(
name|pred
operator|=
name|bb
operator|->
name|pred
init|;
name|pred
operator|!=
name|NULL
condition|;
name|pred
operator|=
name|pred
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|pred_bb
init|=
name|pred
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
condition|)
comment|/* This predecessor has already been visited. Nothing to do.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|pred_bb
operator|==
name|bb
condition|)
block|{
comment|/* BB loops on itself.  */
if|if
condition|(
name|check_self_loop
operator|&&
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
operator|&&
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|==
name|pred_bb
operator|->
name|index
condition|)
return|return
literal|1
return|;
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Ignore this predecessor if it kills the expression.  */
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|ae_kill
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Does this predecessor generate this expression?  */
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
block|{
comment|/* Is this the occurrence we're looking for? 	     Note that there's only one generating occurrence per block 	     so we just need to check the block number.  */
if|if
condition|(
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|==
name|pred_bb
operator|->
name|index
condition|)
return|return
literal|1
return|;
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Neither gen nor kill.  */
else|else
block|{
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|expr_reaches_here_p_work
argument_list|(
name|occr
argument_list|,
name|expr
argument_list|,
name|pred_bb
argument_list|,
name|check_self_loop
argument_list|,
name|visited
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* All paths have been checked.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This wrapper for expr_reaches_here_p_work() is to ensure that any    memory allocated for that function is returned.  */
end_comment

begin_function
specifier|static
name|int
name|expr_reaches_here_p
parameter_list|(
name|occr
parameter_list|,
name|expr
parameter_list|,
name|bb
parameter_list|,
name|check_self_loop
parameter_list|)
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|check_self_loop
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|visited
init|=
operator|(
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rval
operator|=
name|expr_reaches_here_p_work
argument_list|(
name|occr
argument_list|,
name|expr
argument_list|,
name|bb
argument_list|,
name|check_self_loop
argument_list|,
name|visited
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Return the instruction that computes EXPR that reaches INSN's basic block.    If there is more than one such instruction, return NULL.     Called only by handle_avail_expr.  */
end_comment

begin_function
specifier|static
name|rtx
name|computing_insn
parameter_list|(
name|expr
parameter_list|,
name|insn
parameter_list|)
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|->
name|avail_occr
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|expr
operator|->
name|avail_occr
operator|->
name|insn
argument_list|)
operator|==
name|bb
condition|)
comment|/* The available expression is actually itself 	   (i.e. a loop in the flow graph) so do nothing.  */
return|return
name|NULL
return|;
comment|/* (FIXME) Case that we found a pattern that was created by 	 a substitution that took place.  */
return|return
name|expr
operator|->
name|avail_occr
operator|->
name|insn
return|;
block|}
else|else
block|{
comment|/* Pattern is computed more than once. 	 Search backwards from this insn to see how many of these  	 computations actually reach this insn.  */
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|rtx
name|insn_computes_expr
init|=
name|NULL
decl_stmt|;
name|int
name|can_reach
init|=
literal|0
decl_stmt|;
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|==
name|bb
condition|)
block|{
comment|/* The expression is generated in this block. 		 The only time we care about this is when the expression 		 is generated later in the block [and thus there's a loop]. 		 We let the normal cse pass handle the other cases.  */
if|if
condition|(
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|<
name|INSN_CUID
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|&&
name|expr_reaches_here_p
argument_list|(
name|occr
argument_list|,
name|expr
argument_list|,
name|bb
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|can_reach
operator|++
expr_stmt|;
if|if
condition|(
name|can_reach
operator|>
literal|1
condition|)
return|return
name|NULL
return|;
name|insn_computes_expr
operator|=
name|occr
operator|->
name|insn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|expr_reaches_here_p
argument_list|(
name|occr
argument_list|,
name|expr
argument_list|,
name|bb
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|can_reach
operator|++
expr_stmt|;
if|if
condition|(
name|can_reach
operator|>
literal|1
condition|)
return|return
name|NULL
return|;
name|insn_computes_expr
operator|=
name|occr
operator|->
name|insn
expr_stmt|;
block|}
block|}
if|if
condition|(
name|insn_computes_expr
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|insn_computes_expr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if the definition in DEF_INSN can reach INSN.    Only called by can_disregard_other_sets.  */
end_comment

begin_function
specifier|static
name|int
name|def_reaches_here_p
parameter_list|(
name|insn
parameter_list|,
name|def_insn
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|def_insn
decl_stmt|;
block|{
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reaching_defs
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_CUID
argument_list|(
name|def_insn
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|def_insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|INSN_CUID
argument_list|(
name|def_insn
argument_list|)
operator|<
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|reg
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
operator|!
name|reg_set_between_p
argument_list|(
name|reg
argument_list|,
name|NEXT_INSN
argument_list|(
name|def_insn
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if *ADDR_THIS_REG can only have one value at INSN.  The    value returned is the number of definitions that reach INSN.  Returning a    value of zero means that [maybe] more than one definition reaches INSN and    the caller can't perform whatever optimization it is trying.  i.e. it is    always safe to return zero.  */
end_comment

begin_function
specifier|static
name|int
name|can_disregard_other_sets
parameter_list|(
name|addr_this_reg
parameter_list|,
name|insn
parameter_list|,
name|for_combine
parameter_list|)
name|struct
name|reg_set
modifier|*
modifier|*
name|addr_this_reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|for_combine
decl_stmt|;
block|{
name|int
name|number_of_reaching_defs
init|=
literal|0
decl_stmt|;
name|struct
name|reg_set
modifier|*
name|this_reg
decl_stmt|;
for|for
control|(
name|this_reg
operator|=
operator|*
name|addr_this_reg
init|;
name|this_reg
operator|!=
literal|0
condition|;
name|this_reg
operator|=
name|this_reg
operator|->
name|next
control|)
if|if
condition|(
name|def_reaches_here_p
argument_list|(
name|insn
argument_list|,
name|this_reg
operator|->
name|insn
argument_list|)
condition|)
block|{
name|number_of_reaching_defs
operator|++
expr_stmt|;
comment|/* Ignore parallels for now.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|for_combine
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* A setting of the reg to a different value reaches INSN.  */
return|return
literal|0
return|;
if|if
condition|(
name|number_of_reaching_defs
operator|>
literal|1
condition|)
block|{
comment|/* If in this setting the value the register is being set to is 	       equal to the previous value the register was set to and this 	       setting reaches the insn we are trying to do the substitution 	       on then we are ok.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
operator|*
name|addr_this_reg
operator|=
name|this_reg
expr_stmt|;
block|}
return|return
name|number_of_reaching_defs
return|;
block|}
end_function

begin_comment
comment|/* Expression computed by insn is available and the substitution is legal,    so try to perform the substitution.     The result is non-zero if any changes were made.  */
end_comment

begin_function
specifier|static
name|int
name|handle_avail_expr
parameter_list|(
name|insn
parameter_list|,
name|expr
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|,
name|insn_computes_expr
decl_stmt|,
name|expr_set
decl_stmt|;
name|rtx
name|to
decl_stmt|;
name|struct
name|reg_set
modifier|*
name|this_reg
decl_stmt|;
name|int
name|found_setting
decl_stmt|,
name|use_src
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
comment|/* We only handle the case where one computation of the expression      reaches this instruction.  */
name|insn_computes_expr
operator|=
name|computing_insn
argument_list|(
name|expr
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_computes_expr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|expr_set
operator|=
name|single_set
argument_list|(
name|insn_computes_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expr_set
condition|)
name|abort
argument_list|()
expr_stmt|;
name|found_setting
operator|=
literal|0
expr_stmt|;
name|use_src
operator|=
literal|0
expr_stmt|;
comment|/* At this point we know only one computation of EXPR outside of this      block reaches this insn.  Now try to find a register that the      expression is computed into.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|expr_set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* This is the case when the available expression that reaches 	 here has already been handled as an available expression.  */
name|unsigned
name|int
name|regnum_for_replacing
init|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|expr_set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the register was created by GCSE we can't use `reg_set_table', 	 however we know it's set only once.  */
if|if
condition|(
name|regnum_for_replacing
operator|>=
name|max_gcse_regno
comment|/* If the register the expression is computed into is set only once, 	     or only one set reaches this insn, we can use it.  */
operator|||
operator|(
operator|(
operator|(
name|this_reg
operator|=
name|reg_set_table
index|[
name|regnum_for_replacing
index|]
operator|)
operator|,
name|this_reg
operator|->
name|next
operator|==
name|NULL
operator|)
operator|||
name|can_disregard_other_sets
argument_list|(
operator|&
name|this_reg
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|use_src
operator|=
literal|1
expr_stmt|;
name|found_setting
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found_setting
condition|)
block|{
name|unsigned
name|int
name|regnum_for_replacing
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|expr_set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* This shouldn't happen.  */
if|if
condition|(
name|regnum_for_replacing
operator|>=
name|max_gcse_regno
condition|)
name|abort
argument_list|()
expr_stmt|;
name|this_reg
operator|=
name|reg_set_table
index|[
name|regnum_for_replacing
index|]
expr_stmt|;
comment|/* If the register the expression is computed into is set only once, 	 or only one set reaches this insn, use it.  */
if|if
condition|(
name|this_reg
operator|->
name|next
operator|==
name|NULL
operator|||
name|can_disregard_other_sets
argument_list|(
operator|&
name|this_reg
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
condition|)
name|found_setting
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found_setting
condition|)
block|{
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_src
condition|)
name|to
operator|=
name|SET_SRC
argument_list|(
name|expr_set
argument_list|)
expr_stmt|;
else|else
name|to
operator|=
name|SET_DEST
argument_list|(
name|expr_set
argument_list|)
expr_stmt|;
name|changed
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We should be able to ignore the return code from validate_change but 	 to play it safe we check.  */
if|if
condition|(
name|changed
condition|)
block|{
name|gcse_subst_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE: Replacing the source in insn %d with"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|" reg %d %s insn %d\n"
argument_list|,
name|REGNO
argument_list|(
name|to
argument_list|)
argument_list|,
name|use_src
condition|?
literal|"from"
else|:
literal|"set in"
argument_list|,
name|INSN_UID
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* The register that the expr is computed into is set more than once.  */
elseif|else
if|if
condition|(
literal|1
comment|/*expensive_op(this_pattrn->op)&& do_expensive_gcse)*/
condition|)
block|{
comment|/* Insert an insn after insnx that copies the reg set in insnx 	 into a new pseudo register call this new register REGN. 	 From insnb until end of basic block or until REGB is set 	 replace all uses of REGB with REGN.  */
name|rtx
name|new_insn
decl_stmt|;
name|to
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|expr_set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate the new insn.  */
comment|/* ??? If the change fails, we return 0, even though we created 	 an insn.  I think this is ok.  */
name|new_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|to
argument_list|,
name|SET_DEST
argument_list|(
name|expr_set
argument_list|)
argument_list|)
argument_list|,
name|insn_computes_expr
argument_list|)
expr_stmt|;
comment|/* Keep register set table up to date.  */
name|record_one_set
argument_list|(
name|REGNO
argument_list|(
name|to
argument_list|)
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
name|gcse_create_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE: Creating insn %d to copy value of reg %d"
argument_list|,
name|INSN_UID
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|", computed in insn %d,\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"      into newly allocated reg %d\n"
argument_list|,
name|REGNO
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Do register replacement for INSN.  */
name|changed
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We should be able to ignore the return code from validate_change but 	 to play it safe we check.  */
if|if
condition|(
name|changed
condition|)
block|{
name|gcse_subst_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE: Replacing the source in insn %d with reg %d "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"set in insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Perform classic GCSE.  This is called by one_classic_gcse_pass after all    the dataflow analysis has been done.     The result is non-zero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|classic_gcse
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Note we start at block 1.  */
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|1
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
comment|/* Reset tables used to keep track of what's still valid [since the 	 start of the block].  */
name|reset_opr_set_tables
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NULL
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Is insn of form (set (pseudo-reg) ...)?  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
if|if
condition|(
name|want_to_gcse_p
argument_list|(
name|src
argument_list|)
comment|/* Is the expression recorded?  */
operator|&&
operator|(
operator|(
name|expr
operator|=
name|lookup_expr
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
comment|/* Is the expression available [at the start of the 		     block]?  */
operator|&&
name|TEST_BIT
argument_list|(
name|ae_in
index|[
name|bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
comment|/* Are the operands unchanged since the start of the 		     block?  */
operator|&&
name|oprs_not_set_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
condition|)
name|changed
operator||=
name|handle_avail_expr
argument_list|(
name|insn
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* Keep track of everything modified by this insn.  */
comment|/* ??? Need to be careful w.r.t. mods done to INSN.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|mark_oprs_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Top level routine to perform one classic GCSE pass.     Return non-zero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|one_classic_gcse_pass
parameter_list|(
name|pass
parameter_list|)
name|int
name|pass
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|gcse_subst_count
operator|=
literal|0
expr_stmt|;
name|gcse_create_count
operator|=
literal|0
expr_stmt|;
name|alloc_expr_hash_table
argument_list|(
name|max_cuid
argument_list|)
expr_stmt|;
name|alloc_rd_mem
argument_list|(
name|n_basic_blocks
argument_list|,
name|max_cuid
argument_list|)
expr_stmt|;
name|compute_expr_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|dump_hash_table
argument_list|(
name|gcse_file
argument_list|,
literal|"Expression"
argument_list|,
name|expr_hash_table
argument_list|,
name|expr_hash_table_size
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_exprs
operator|>
literal|0
condition|)
block|{
name|compute_kill_rd
argument_list|()
expr_stmt|;
name|compute_rd
argument_list|()
expr_stmt|;
name|alloc_avail_expr_mem
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_ae_gen
argument_list|()
expr_stmt|;
name|compute_ae_kill
argument_list|(
name|ae_gen
argument_list|,
name|ae_kill
argument_list|)
expr_stmt|;
name|compute_available
argument_list|(
name|ae_gen
argument_list|,
name|ae_kill
argument_list|,
name|ae_out
argument_list|,
name|ae_in
argument_list|)
expr_stmt|;
name|changed
operator|=
name|classic_gcse
argument_list|()
expr_stmt|;
name|free_avail_expr_mem
argument_list|()
expr_stmt|;
block|}
name|free_rd_mem
argument_list|()
expr_stmt|;
name|free_expr_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE of %s, pass %d: %d bytes needed, %d substs,"
argument_list|,
name|current_function_name
argument_list|,
name|pass
argument_list|,
name|bytes_used
argument_list|,
name|gcse_subst_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"%d insns created\n"
argument_list|,
name|gcse_create_count
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute copy/constant propagation working variables.  */
end_comment

begin_comment
comment|/* Local properties of assignments.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_pavloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_absaltered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global properties of assignments (computed from the local properties).  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_avin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_avout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate vars used for copy/const propagation.  N_BLOCKS is the number of    basic blocks.  N_SETS is the number of sets.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_cprop_mem
parameter_list|(
name|n_blocks
parameter_list|,
name|n_sets
parameter_list|)
name|int
name|n_blocks
decl_stmt|,
name|n_sets
decl_stmt|;
block|{
name|cprop_pavloc
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
name|cprop_absaltered
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
name|cprop_avin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
name|cprop_avout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free vars used by copy/const propagation.  */
end_comment

begin_function
specifier|static
name|void
name|free_cprop_mem
parameter_list|()
block|{
name|sbitmap_vector_free
argument_list|(
name|cprop_pavloc
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|cprop_absaltered
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|cprop_avin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|cprop_avout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each block, compute whether X is transparent.  X is either an    expression or an assignment [though we don't care which, for this context    an assignment is treated as an expression].  For each block where an    element of X is modified, set (SET_P == 1) or reset (SET_P == 0) the INDX    bit in BMAP.  */
end_comment

begin_function
specifier|static
name|void
name|compute_transp
parameter_list|(
name|x
parameter_list|,
name|indx
parameter_list|,
name|bmap
parameter_list|,
name|set_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|sbitmap
modifier|*
name|bmap
decl_stmt|;
name|int
name|set_p
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|reg_set
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration since GCC      can't do it when there's no return value.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|set_p
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
index|]
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|r
operator|=
name|reg_set_table
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
name|SET_BIT
argument_list|(
name|bmap
index|[
name|BLOCK_NUM
argument_list|(
name|r
operator|->
name|insn
argument_list|)
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
index|]
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|RESET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|r
operator|=
name|reg_set_table
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
name|RESET_BIT
argument_list|(
name|bmap
index|[
name|BLOCK_NUM
argument_list|(
name|r
operator|->
name|insn
argument_list|)
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
case|case
name|MEM
case|:
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|list_entry
init|=
name|canon_modify_mem_list
index|[
name|bb
index|]
decl_stmt|;
while|while
condition|(
name|list_entry
condition|)
block|{
name|rtx
name|dest
decl_stmt|,
name|dest_addr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|set_p
condition|)
name|SET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
else|else
name|RESET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* LIST_ENTRY must be an INSN of some kind that sets memory. 		 Examine each hunk of memory that is modified.  */
name|dest
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|list_entry
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|canon_true_dependence
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|dest_addr
argument_list|,
name|x
argument_list|,
name|rtx_addr_varies_p
argument_list|)
condition|)
block|{
if|if
condition|(
name|set_p
condition|)
name|SET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
else|else
name|RESET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
break|break;
block|}
name|list_entry
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|compute_transp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|indx
argument_list|,
name|bmap
argument_list|,
name|set_p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|compute_transp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|indx
argument_list|,
name|bmap
argument_list|,
name|set_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Top level routine to do the dataflow analysis needed by copy/const    propagation.  */
end_comment

begin_function
specifier|static
name|void
name|compute_cprop_data
parameter_list|()
block|{
name|compute_local_properties
argument_list|(
name|cprop_absaltered
argument_list|,
name|cprop_pavloc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|compute_available
argument_list|(
name|cprop_pavloc
argument_list|,
name|cprop_absaltered
argument_list|,
name|cprop_avout
argument_list|,
name|cprop_avin
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy/constant propagation.  */
end_comment

begin_comment
comment|/* Maximum number of register uses in an insn that we handle.  */
end_comment

begin_define
define|#
directive|define
name|MAX_USES
value|8
end_define

begin_comment
comment|/* Table of uses found in an insn.    Allocated statically to avoid alloc/free complexity and overhead.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|reg_use
name|reg_use_table
index|[
name|MAX_USES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into `reg_use_table' while building it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_use_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up a list of register numbers used in INSN.  The found uses are stored    in `reg_use_table'.  `reg_use_count' is initialized to zero before entry,    and contains the number of uses in the table upon exit.     ??? If a register appears multiple times we will record it multiple times.    This doesn't hurt anything but it will slow things down.  */
end_comment

begin_function
specifier|static
name|void
name|find_used_regs
parameter_list|(
name|xptr
parameter_list|,
name|data
parameter_list|)
name|rtx
modifier|*
name|xptr
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|xptr
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration since GCC      can't do it when there's no return value.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_use_count
operator|==
name|MAX_USES
condition|)
return|return;
name|reg_use_table
index|[
name|reg_use_count
index|]
operator|.
name|reg_rtx
operator|=
name|x
expr_stmt|;
name|reg_use_count
operator|++
expr_stmt|;
block|}
comment|/* Recursively scan the operands of this expression.  */
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|find_used_regs
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|find_used_regs
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to replace all non-SET_DEST occurrences of FROM in INSN with TO.    Returns non-zero is successful.  */
end_comment

begin_function
specifier|static
name|int
name|try_replace_reg
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|success
operator|=
name|validate_replace_src
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* If above failed and this is a single set, try to simplify the source of      the set given our substitution.  We could perhaps try this for multiple      SETs, but it probably won't buy us anything.  */
if|if
condition|(
operator|!
name|success
operator|&&
name|set
operator|!=
literal|0
condition|)
block|{
name|src
operator|=
name|simplify_replace_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|src
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
condition|)
name|success
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we've failed to do replacement, have a single SET, and don't already      have a note, add a REG_EQUAL note to not lose information.  */
if|if
condition|(
operator|!
name|success
operator|&&
name|note
operator|==
literal|0
operator|&&
name|set
operator|!=
literal|0
condition|)
name|note
operator|=
name|set_unique_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|copy_rtx
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is already a NOTE, update the expression in it with our      replacement.  */
elseif|else
if|if
condition|(
name|note
operator|!=
literal|0
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* REG_EQUAL may get simplified into register.      We don't allow that. Remove that note. This code ought      not to hapen, because previous code ought to syntetize      reg-reg move, but be on the safe side.  */
if|if
condition|(
name|note
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/* Find a set of REGNOs that are available on entry to INSN's block.  Returns    NULL no such set is found.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|find_avail_set
parameter_list|(
name|regno
parameter_list|,
name|insn
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* SET1 contains the last set found that can be returned to the caller for      use in a substitution.  */
name|struct
name|expr
modifier|*
name|set1
init|=
literal|0
decl_stmt|;
comment|/* Loops are not possible here.  To get a loop we would need two sets      available at the start of the block containing INSN.  ie we would      need two sets like this available at the start of the block:         (set (reg X) (reg Y))        (set (reg Y) (reg X))       This can not happen since the set of (reg Y) would have killed the      set of (reg X) making it unavailable at the start of this block.  */
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|src
decl_stmt|;
name|struct
name|expr
modifier|*
name|set
init|=
name|lookup_set
argument_list|(
name|regno
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
comment|/* Find a set that is available at the start of the block 	 which contains INSN.  */
while|while
condition|(
name|set
condition|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|cprop_avin
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|set
operator|->
name|bitmap_index
argument_list|)
condition|)
break|break;
name|set
operator|=
name|next_set
argument_list|(
name|regno
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
comment|/* If no available set was found we've reached the end of the 	 (possibly empty) copy chain.  */
if|if
condition|(
name|set
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
operator|->
name|expr
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
operator|->
name|expr
argument_list|)
expr_stmt|;
comment|/* We know the set is available. 	 Now check that SRC is ANTLOC (i.e. none of the source operands 	 have changed since the start of the block).             If the source operand changed, we may still use it for the next          iteration of this loop, but we may not use it for substitutions.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
operator|||
name|oprs_not_set_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
condition|)
name|set1
operator|=
name|set
expr_stmt|;
comment|/* If the source of the set is anything except a register, then 	 we have reached the end of the copy chain.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
condition|)
break|break;
comment|/* Follow the copy chain, ie start another iteration of the loop 	 and see if we have an available copy into SRC.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* SET1 holds the last set that was available and anticipatable at      INSN.  */
return|return
name|set1
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of cprop_insn that tries to propagate constants into    JUMP_INSNS.  INSN must be a conditional jump.  FROM is what we will try to    replace, SRC is the constant we will try to substitute for it.  Returns    nonzero if a change was made.  We know INSN has just a SET.  */
end_comment

begin_function
specifier|static
name|int
name|cprop_jump
parameter_list|(
name|bb
parameter_list|,
name|insn
parameter_list|,
name|from
parameter_list|,
name|src
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|rtx
name|from
decl_stmt|;
name|rtx
name|src
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|set
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new
init|=
name|simplify_replace_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|from
argument_list|,
name|src
argument_list|)
decl_stmt|;
comment|/* If no simplification can be made, then try the next      register.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|new
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is now a no-op delete it, otherwise this must be a valid insn.  */
if|if
condition|(
name|new
operator|==
name|pc_rtx
condition|)
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this has turned into an unconditional jump, 	 then put a barrier after it so that the unreachable 	 code will be deleted.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|run_jump_opt_after_gcse
operator|=
literal|1
expr_stmt|;
name|const_prop_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"CONST-PROP: Replacing reg %d in insn %d with constant "
argument_list|,
name|REGNO
argument_list|(
name|from
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|purge_dead_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_cc0
end_ifdef

begin_comment
comment|/* Subroutine of cprop_insn that tries to propagate constants into JUMP_INSNS    for machines that have CC0.  INSN is a single set that stores into CC0;    the insn following it is a conditional jump.  REG_USED is the use we will    try to replace, SRC is the constant we will try to substitute for it.    Returns nonzero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|cprop_cc0_jump
parameter_list|(
name|bb
parameter_list|,
name|insn
parameter_list|,
name|reg_used
parameter_list|,
name|src
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|reg_use
modifier|*
name|reg_used
decl_stmt|;
name|rtx
name|src
decl_stmt|;
block|{
comment|/* First substitute in the SET_SRC of INSN, then substitute that for      CC0 in JUMP.  */
name|rtx
name|jump
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new_src
init|=
name|simplify_replace_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cprop_jump
argument_list|(
name|bb
argument_list|,
name|jump
argument_list|,
name|cc0_rtx
argument_list|,
name|new_src
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If we succeeded, delete the cc0 setter.  */
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Perform constant and copy propagation on INSN.    The result is non-zero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|cprop_insn
parameter_list|(
name|bb
parameter_list|,
name|insn
parameter_list|,
name|alter_jumps
parameter_list|)
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|alter_jumps
decl_stmt|;
block|{
name|struct
name|reg_use
modifier|*
name|reg_used
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
name|reg_use_count
operator|=
literal|0
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|find_used_regs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We may win even when propagating constants into notes.  */
if|if
condition|(
name|note
condition|)
name|find_used_regs
argument_list|(
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|reg_used
operator|=
operator|&
name|reg_use_table
index|[
literal|0
index|]
init|;
name|reg_use_count
operator|>
literal|0
condition|;
name|reg_used
operator|++
operator|,
name|reg_use_count
operator|--
control|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|src
decl_stmt|;
name|struct
name|expr
modifier|*
name|set
decl_stmt|;
comment|/* Ignore registers created by GCSE. 	 We do this because ...  */
if|if
condition|(
name|regno
operator|>=
name|max_gcse_regno
condition|)
continue|continue;
comment|/* If the register has already been set in this block, there's 	 nothing we can do.  */
if|if
condition|(
operator|!
name|oprs_not_set_p
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Find an assignment that sets reg_used and is available 	 at the start of the block.  */
name|set
operator|=
name|find_avail_set
argument_list|(
name|regno
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
name|pat
operator|=
name|set
operator|->
name|expr
expr_stmt|;
comment|/* ??? We might be able to handle PARALLELs.  Later.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* Constant propagation.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* Handle normal insns first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|try_replace_reg
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|src
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|const_prop_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"CONST-PROP: Replacing reg %d in "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"insn %d with constant "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* The original insn setting reg_used may or may not now be 		 deletable.  We leave the deletion to flow.  */
block|}
comment|/* Try to propagate a CONST_INT into a conditional jump. 	     We're pretty specific about what we will handle in this 	     code, we can extend this as necessary over time.  	     Right now the insn in question must look like 	     (set (pc) (if_then_else ...))  */
elseif|else
if|if
condition|(
name|alter_jumps
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|changed
operator||=
name|cprop_jump
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|,
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|src
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Similar code for machines that use a pair of CC0 setter and 	     conditional jump insn.  */
elseif|else
if|if
condition|(
name|alter_jumps
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|cc0_rtx
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|condjump_p
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
name|cprop_cc0_jump
argument_list|(
name|bb
argument_list|,
name|insn
argument_list|,
name|reg_used
argument_list|,
name|src
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|!=
name|regno
condition|)
block|{
if|if
condition|(
name|try_replace_reg
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|src
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|copy_prop_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"COPY-PROP: Replacing reg %d in insn %d"
argument_list|,
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|" with reg %d\n"
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The original insn setting reg_used may or may not now be 		 deletable.  We leave the deletion to flow.  */
comment|/* FIXME: If it turns out that the insn isn't deletable, 		 then we may have unnecessarily extended register lifetimes 		 and made things worse.  */
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Forward propagate copies.  This includes copies and constants.  Return    non-zero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|cprop
parameter_list|(
name|alter_jumps
parameter_list|)
name|int
name|alter_jumps
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Note we start at block 1.  */
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|1
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
comment|/* Reset tables used to keep track of what's still valid [since the 	 start of the block].  */
name|reset_opr_set_tables
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NULL
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|changed
operator||=
name|cprop_insn
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
name|insn
argument_list|,
name|alter_jumps
argument_list|)
expr_stmt|;
comment|/* Keep track of everything modified by this insn.  */
comment|/* ??? Need to be careful w.r.t. mods done to INSN.  Don't 	       call mark_oprs_set if we turned the insn into a NOTE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|mark_oprs_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Perform one copy/constant propagation pass.    F is the first insn in the function.    PASS is the pass count.  */
end_comment

begin_function
specifier|static
name|int
name|one_cprop_pass
parameter_list|(
name|pass
parameter_list|,
name|alter_jumps
parameter_list|)
name|int
name|pass
decl_stmt|;
name|int
name|alter_jumps
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|const_prop_count
operator|=
literal|0
expr_stmt|;
name|copy_prop_count
operator|=
literal|0
expr_stmt|;
name|alloc_set_hash_table
argument_list|(
name|max_cuid
argument_list|)
expr_stmt|;
name|compute_set_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|dump_hash_table
argument_list|(
name|gcse_file
argument_list|,
literal|"SET"
argument_list|,
name|set_hash_table
argument_list|,
name|set_hash_table_size
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_sets
operator|>
literal|0
condition|)
block|{
name|alloc_cprop_mem
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
name|compute_cprop_data
argument_list|()
expr_stmt|;
name|changed
operator|=
name|cprop
argument_list|(
name|alter_jumps
argument_list|)
expr_stmt|;
name|free_cprop_mem
argument_list|()
expr_stmt|;
block|}
name|free_set_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"CPROP of %s, pass %d: %d bytes needed, "
argument_list|,
name|current_function_name
argument_list|,
name|pass
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"%d const props, %d copy props\n\n"
argument_list|,
name|const_prop_count
argument_list|,
name|copy_prop_count
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute PRE+LCM working variables.  */
end_comment

begin_comment
comment|/* Local properties of expressions.  */
end_comment

begin_comment
comment|/* Nonzero for expressions that are transparent in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|transp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are transparent at the end of the block.    This is only zero for expressions killed by abnormal critical edge    created by a calls.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|transpout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are computed (available) in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|comp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are locally anticipatable in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions where this block is an optimal computation    point.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_optimal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions which are redundant in a particular block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_redundant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions which should be inserted on a specific edge.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_insert_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions which should be deleted in a specific block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_delete_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains the edge_list returned by pre_edge_lcm.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Redundant insns.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|pre_redundant_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate vars used for PRE analysis.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_pre_mem
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|)
name|int
name|n_blocks
decl_stmt|,
name|n_exprs
decl_stmt|;
block|{
name|transp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|comp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|antloc
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|pre_optimal
operator|=
name|NULL
expr_stmt|;
name|pre_redundant
operator|=
name|NULL
expr_stmt|;
name|pre_insert_map
operator|=
name|NULL
expr_stmt|;
name|pre_delete_map
operator|=
name|NULL
expr_stmt|;
name|ae_in
operator|=
name|NULL
expr_stmt|;
name|ae_out
operator|=
name|NULL
expr_stmt|;
name|ae_kill
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
comment|/* pre_insert and pre_delete are allocated later.  */
block|}
end_function

begin_comment
comment|/* Free vars used for PRE analysis.  */
end_comment

begin_function
specifier|static
name|void
name|free_pre_mem
parameter_list|()
block|{
name|sbitmap_vector_free
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
comment|/* ANTLOC and AE_KILL are freed just after pre_lcm finishes.  */
if|if
condition|(
name|pre_optimal
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_optimal
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_redundant
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_redundant
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_insert_map
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_insert_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_delete_map
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_delete_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae_in
condition|)
name|sbitmap_vector_free
argument_list|(
name|ae_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae_out
condition|)
name|sbitmap_vector_free
argument_list|(
name|ae_out
argument_list|)
expr_stmt|;
name|transp
operator|=
name|comp
operator|=
name|NULL
expr_stmt|;
name|pre_optimal
operator|=
name|pre_redundant
operator|=
name|pre_insert_map
operator|=
name|pre_delete_map
operator|=
name|NULL
expr_stmt|;
name|ae_in
operator|=
name|ae_out
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level routine to do the dataflow analysis needed by PRE.  */
end_comment

begin_function
specifier|static
name|void
name|compute_pre_data
parameter_list|()
block|{
name|sbitmap
name|trapping_expr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|ui
decl_stmt|;
name|compute_local_properties
argument_list|(
name|transp
argument_list|,
name|comp
argument_list|,
name|antloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_kill
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Collect expressions which might trap.  */
name|trapping_expr
operator|=
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|trapping_expr
argument_list|)
expr_stmt|;
for|for
control|(
name|ui
operator|=
literal|0
init|;
name|ui
operator|<
name|expr_hash_table_size
condition|;
name|ui
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|expr_hash_table
index|[
name|ui
index|]
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|may_trap_p
argument_list|(
name|e
operator|->
name|expr
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|trapping_expr
argument_list|,
name|e
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
comment|/* Compute ae_kill for each basic block using:       ~(TRANSP | COMP)       This is significantly faster than compute_ae_kill.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|edge
name|e
decl_stmt|;
comment|/* If the current block is the destination of an abnormal edge, we 	 kill all trapping expressions because we won't be able to properly 	 place the instruction on the edge.  So make them neither 	 anticipatable nor transparent.  This is fairly conservative.  */
for|for
control|(
name|e
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
name|sbitmap_difference
argument_list|(
name|antloc
index|[
name|i
index|]
argument_list|,
name|antloc
index|[
name|i
index|]
argument_list|,
name|trapping_expr
argument_list|)
expr_stmt|;
name|sbitmap_difference
argument_list|(
name|transp
index|[
name|i
index|]
argument_list|,
name|transp
index|[
name|i
index|]
argument_list|,
name|trapping_expr
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbitmap_a_or_b
argument_list|(
name|ae_kill
index|[
name|i
index|]
argument_list|,
name|transp
index|[
name|i
index|]
argument_list|,
name|comp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sbitmap_not
argument_list|(
name|ae_kill
index|[
name|i
index|]
argument_list|,
name|ae_kill
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|edge_list
operator|=
name|pre_edge_lcm
argument_list|(
name|gcse_file
argument_list|,
name|n_exprs
argument_list|,
name|transp
argument_list|,
name|comp
argument_list|,
name|antloc
argument_list|,
name|ae_kill
argument_list|,
operator|&
name|pre_insert_map
argument_list|,
operator|&
name|pre_delete_map
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|antloc
argument_list|)
expr_stmt|;
name|antloc
operator|=
name|NULL
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|ae_kill
argument_list|)
expr_stmt|;
name|ae_kill
operator|=
name|NULL
expr_stmt|;
name|sbitmap_free
argument_list|(
name|trapping_expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* PRE utilities */
end_comment

begin_comment
comment|/* Return non-zero if an occurrence of expression EXPR in OCCR_BB would reach    block BB.     VISITED is a pointer to a working buffer for tracking which BB's have    been visited.  It is NULL for the top-level call.     We treat reaching expressions that go through blocks containing the same    reaching expression as "not reaching".  E.g. if EXPR is generated in blocks    2 and 3, INSN is in block 4, and 2->3->4, we treat the expression in block    2 as not reaching.  The intent is to improve the probability of finding    only one reaching expression and to reduce register lifetimes by picking    the closest such expression.  */
end_comment

begin_function
specifier|static
name|int
name|pre_expr_reaches_here_p_work
parameter_list|(
name|occr_bb
parameter_list|,
name|expr
parameter_list|,
name|bb
parameter_list|,
name|visited
parameter_list|)
name|basic_block
name|occr_bb
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|char
modifier|*
name|visited
decl_stmt|;
block|{
name|edge
name|pred
decl_stmt|;
for|for
control|(
name|pred
operator|=
name|bb
operator|->
name|pred
init|;
name|pred
operator|!=
name|NULL
condition|;
name|pred
operator|=
name|pred
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|pred_bb
init|=
name|pred
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|pred
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
comment|/* Has predecessor has already been visited?  */
operator|||
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
condition|)
empty_stmt|;
comment|/* Nothing to do.  */
comment|/* Does this predecessor generate this expression?  */
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|comp
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
block|{
comment|/* Is this the occurrence we're looking for? 	     Note that there's only one generating occurrence per block 	     so we just need to check the block number.  */
if|if
condition|(
name|occr_bb
operator|==
name|pred_bb
condition|)
return|return
literal|1
return|;
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Ignore this predecessor if it kills the expression.  */
elseif|else
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|transp
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Neither gen nor kill.  */
else|else
block|{
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pre_expr_reaches_here_p_work
argument_list|(
name|occr_bb
argument_list|,
name|expr
argument_list|,
name|pred_bb
argument_list|,
name|visited
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* All paths have been checked.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The wrapper for pre_expr_reaches_here_work that ensures that any    memory allocated for that function is returned.  */
end_comment

begin_function
specifier|static
name|int
name|pre_expr_reaches_here_p
parameter_list|(
name|occr_bb
parameter_list|,
name|expr
parameter_list|,
name|bb
parameter_list|)
name|basic_block
name|occr_bb
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|visited
init|=
operator|(
name|char
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rval
operator|=
name|pre_expr_reaches_here_p_work
argument_list|(
name|occr_bb
argument_list|,
name|expr
argument_list|,
name|bb
argument_list|,
name|visited
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expr, generate RTL which we can insert at the end of a BB,    or on an edge.  Set the block number of any insns generated to     the value of BB.  */
end_comment

begin_function
specifier|static
name|rtx
name|process_insert_insn
parameter_list|(
name|expr
parameter_list|)
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|expr
operator|->
name|reaching_reg
decl_stmt|;
name|rtx
name|exp
init|=
name|copy_rtx
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* If the expression is something that's an operand, like a constant,      just copy it to a register.  */
if|if
condition|(
name|general_operand
argument_list|(
name|exp
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* Otherwise, make a new insn to compute this expression and make sure the      insn will be recognized (this also adds any needed CLOBBERs).  Copy the      expression to make sure we don't have any sharing issues.  */
elseif|else
if|if
condition|(
name|insn_invalid_p
argument_list|(
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pat
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|pat
return|;
block|}
end_function

begin_comment
comment|/* Add EXPR to the end of basic block BB.     This is used by both the PRE and code hoisting.     For PRE, we want to verify that the expr is either transparent    or locally anticipatable in the target block.  This check makes    no sense for code hoisting.  */
end_comment

begin_function
specifier|static
name|void
name|insert_insn_end_bb
parameter_list|(
name|expr
parameter_list|,
name|bb
parameter_list|,
name|pre
parameter_list|)
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|pre
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|bb
operator|->
name|end
decl_stmt|;
name|rtx
name|new_insn
decl_stmt|;
name|rtx
name|reg
init|=
name|expr
operator|->
name|reaching_reg
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pat
operator|=
name|process_insert_insn
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* If the last insn is a jump, insert EXPR in front [taking care to      handle cc0, etc. properly].  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|note
decl_stmt|;
endif|#
directive|endif
comment|/* If this is a jump table, then we can't insert stuff here.  Since 	 we know the previous real insn must be the tablejump, we insert 	 the new instruction just before the tablejump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|insn
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* FIXME: 'twould be nice to call prev_cc0_setter here but it aborts 	 if cc0 isn't set.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|maybe_cc0_setter
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|maybe_cc0_setter
operator|&&
name|INSN_P
argument_list|(
name|maybe_cc0_setter
argument_list|)
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|maybe_cc0_setter
argument_list|)
argument_list|)
condition|)
name|insn
operator|=
name|maybe_cc0_setter
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FIXME: What if something in cc0/jump uses value set in new insn?  */
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise if the last insn is a call, as will happen in the presence      of exception handling.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers, 	 we search backward and place the instructions before the first 	 parameter is loaded.  Do this for everyone for consistency and a 	 presumtion that we'll get better code elsewhere as well.    	 It should always be the case that we can put these instructions 	 anywhere in the basic block with performing PRE optimizations. 	 Check this.  */
if|if
condition|(
name|pre
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|antloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Since different machines initialize their parameter registers 	 in different orders, assume nothing.  Collect the set of all 	 parameter registers.  */
name|insn
operator|=
name|find_first_parameter_load
argument_list|(
name|insn
argument_list|,
name|bb
operator|->
name|head
argument_list|)
expr_stmt|;
comment|/* If we found all the parameter loads, then we want to insert 	 before the first parameter load.  	 If we did not find all the parameter loads, then we might have 	 stopped on the head of the block, which could be a CODE_LABEL. 	 If we inserted before the CODE_LABEL, then we would be putting 	 the insn in the wrong basic block.  In that case, put the insn 	 after the CODE_LABEL.  Also, respect NOTE_INSN_BASIC_BLOCK.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|new_insn
operator|=
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Keep block number table up to date.      Note, PAT could be a multiple insn sequence, we have to make      sure that each insn in the sequence is handled.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|add_label_notes
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_set_info
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|add_label_notes
argument_list|(
name|pat
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
comment|/* Keep register set table up to date.  */
name|record_one_set
argument_list|(
name|regno
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
block|}
name|gcse_create_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE/HOIST: end of bb %d, insn %d, "
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|INSN_UID
argument_list|(
name|new_insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"copying expression %d to reg %d\n"
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert partially redundant expressions on edges in the CFG to make    the expressions fully redundant.  */
end_comment

begin_function
specifier|static
name|int
name|pre_edge_insert
parameter_list|(
name|edge_list
parameter_list|,
name|index_map
parameter_list|)
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
name|struct
name|expr
modifier|*
modifier|*
name|index_map
decl_stmt|;
block|{
name|int
name|e
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|num_edges
decl_stmt|,
name|set_size
decl_stmt|,
name|did_insert
init|=
literal|0
decl_stmt|;
name|sbitmap
modifier|*
name|inserted
decl_stmt|;
comment|/* Where PRE_INSERT_MAP is nonzero, we add the expression on that edge      if it reaches any of the deleted expressions.  */
name|set_size
operator|=
name|pre_insert_map
index|[
literal|0
index|]
operator|->
name|size
expr_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|inserted
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|inserted
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
literal|0
init|;
name|e
operator|<
name|num_edges
condition|;
name|e
operator|++
control|)
block|{
name|int
name|indx
decl_stmt|;
name|basic_block
name|bb
init|=
name|INDEX_EDGE_PRED_BB
argument_list|(
name|edge_list
argument_list|,
name|e
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indx
operator|=
literal|0
init|;
name|i
operator|<
name|set_size
condition|;
name|i
operator|++
operator|,
name|indx
operator|+=
name|SBITMAP_ELT_BITS
control|)
block|{
name|SBITMAP_ELT_TYPE
name|insert
init|=
name|pre_insert_map
index|[
name|e
index|]
operator|->
name|elms
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
name|indx
init|;
name|insert
operator|&&
name|j
operator|<
name|n_exprs
condition|;
name|j
operator|++
operator|,
name|insert
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|insert
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|index_map
index|[
name|j
index|]
operator|->
name|reaching_reg
operator|!=
name|NULL_RTX
condition|)
block|{
name|struct
name|expr
modifier|*
name|expr
init|=
name|index_map
index|[
name|j
index|]
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
comment|/* Now look at each deleted occurrence of this expression.  */
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|occr
operator|->
name|deleted_p
condition|)
continue|continue;
comment|/* Insert this expression on this edge if if it would 		       reach the deleted occurrence in BB.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|inserted
index|[
name|e
index|]
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|edge
name|eg
init|=
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|e
argument_list|)
decl_stmt|;
comment|/* We can't insert anything on an abnormal and 			   critical edge, so we insert the insn at the end of 			   the previous block. There are several alternatives 			   detailed in Morgans book P277 (sec 10.5) for 			   handling this situation.  This one is easiest for 			   now.  */
if|if
condition|(
operator|(
name|eg
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
name|EDGE_ABNORMAL
condition|)
name|insert_insn_end_bb
argument_list|(
name|index_map
index|[
name|j
index|]
argument_list|,
name|bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|process_insert_insn
argument_list|(
name|index_map
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|insn
argument_list|,
name|eg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE/HOIST: edge (%d,%d), "
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|edge_list
argument_list|,
name|e
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"copy expression %d\n"
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
name|update_ld_motion_stores
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|inserted
index|[
name|e
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|did_insert
operator|=
literal|1
expr_stmt|;
name|gcse_create_count
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|sbitmap_vector_free
argument_list|(
name|inserted
argument_list|)
expr_stmt|;
return|return
name|did_insert
return|;
block|}
end_function

begin_comment
comment|/* Copy the result of INSN to REG.  INDX is the expression number.  */
end_comment

begin_function
specifier|static
name|void
name|pre_insert_copy_insn
parameter_list|(
name|expr
parameter_list|,
name|insn
parameter_list|)
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|expr
operator|->
name|reaching_reg
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|indx
init|=
name|expr
operator|->
name|bitmap_index
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new_insn
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Keep register set table up to date.  */
name|record_one_set
argument_list|(
name|regno
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
name|gcse_create_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE: bb %d, insn %d, copy expression %d in insn %d to reg %d\n"
argument_list|,
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|new_insn
argument_list|)
argument_list|,
name|indx
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|update_ld_motion_stores
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy available expressions that reach the redundant expression    to `reaching_reg'.  */
end_comment

begin_function
specifier|static
name|void
name|pre_insert_copies
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|struct
name|occr
modifier|*
name|avail
decl_stmt|;
comment|/* For each available expression in the table, copy the result to      `reaching_reg' if the expression reaches a deleted one.       ??? The current algorithm is rather brute force.      Need to do some profiling.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
comment|/* If the basic block isn't reachable, PPOUT will be TRUE.  However, 	   we don't want to insert a copy here because the expression may not 	   really be redundant.  So only insert an insn if the expression was 	   deleted.  This test also avoids further processing if the 	   expression wasn't deleted anywhere.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|occr
operator|->
name|deleted_p
condition|)
continue|continue;
for|for
control|(
name|avail
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|avail
operator|!=
name|NULL
condition|;
name|avail
operator|=
name|avail
operator|->
name|next
control|)
block|{
name|rtx
name|insn
init|=
name|avail
operator|->
name|insn
decl_stmt|;
comment|/* No need to handle this one if handled already.  */
if|if
condition|(
name|avail
operator|->
name|copied_p
condition|)
continue|continue;
comment|/* Don't handle this one if it's a redundant one.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pre_redundant_insns
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Or if the expression doesn't reach the deleted one.  */
if|if
condition|(
operator|!
name|pre_expr_reaches_here_p
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|avail
operator|->
name|insn
argument_list|)
argument_list|,
name|expr
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Copy the result of avail to reaching_reg.  */
name|pre_insert_copy_insn
argument_list|(
name|expr
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|avail
operator|->
name|copied_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete redundant computations.    Deletion is done by changing the insn to copy the `reaching_reg' of    the expression into the result of the SET.  It is left to later passes    (cprop, cse2, flow, combine, regmove) to propagate the copy or eliminate it.     Returns non-zero if a change is made.  */
end_comment

begin_function
specifier|static
name|int
name|pre_delete
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
name|int
name|indx
init|=
name|expr
operator|->
name|bitmap_index
decl_stmt|;
comment|/* We only need to search antic_occr since we require 	   ANTLOC != 0.  */
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
name|rtx
name|insn
init|=
name|occr
operator|->
name|insn
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pre_delete_map
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|indx
argument_list|)
condition|)
block|{
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create a pseudo-reg to store the result of reaching 		   expressions into.  Get the mode for the new pseudo from 		   the mode of the original destination pseudo.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL
condition|)
name|expr
operator|->
name|reaching_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In theory this should never fail since we're creating 		   a reg->reg copy.  		   However, on the x86 some of the movXX patterns actually 		   contain clobbers of scratch regs.  This may cause the 		   insn created by validate_change to not match any pattern 		   and thus cause validate_change to fail.  */
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|expr
operator|->
name|reaching_reg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|occr
operator|->
name|deleted_p
operator|=
literal|1
expr_stmt|;
name|SET_BIT
argument_list|(
name|pre_redundant_insns
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|gcse_subst_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE: redundant insn %d (expression %d) in "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|indx
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"bb %d, reaching reg is %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|REGNO
argument_list|(
name|expr
operator|->
name|reaching_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Perform GCSE optimizations using PRE.    This is called by one_pre_gcse_pass after all the dataflow analysis    has been done.     This is based on the original Morel-Renvoise paper Fred Chow's thesis, and    lazy code motion from Knoop, Ruthing and Steffen as described in Advanced    Compiler Design and Implementation.     ??? A new pseudo reg is created to hold the reaching expression.  The nice    thing about the classical approach is that it would try to use an existing    reg.  If the register can't be adequately optimized [i.e. we introduce    reload problems], one could add a pass here to propagate the new register    through the block.     ??? We don't handle single sets in PARALLELs because we're [currently] not    able to copy the rest of the parallel when we insert copies to create full    redundancies from partial redundancies.  However, there's no reason why we    can't handle PARALLELs in the cases where there are no partial    redundancies.  */
end_comment

begin_function
specifier|static
name|int
name|pre_gcse
parameter_list|()
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|did_insert
decl_stmt|,
name|changed
decl_stmt|;
name|struct
name|expr
modifier|*
modifier|*
name|index_map
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
comment|/* Compute a mapping from expression number (`bitmap_index') to      hash table entry.  */
name|index_map
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_exprs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
name|index_map
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|expr
expr_stmt|;
comment|/* Reset bitmap used to track which insns are redundant.  */
name|pre_redundant_insns
operator|=
name|sbitmap_alloc
argument_list|(
name|max_cuid
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|pre_redundant_insns
argument_list|)
expr_stmt|;
comment|/* Delete the redundant insns first so that      - we know what register to use for the new insns and for the other        ones with reaching expressions      - we know which insns are redundant when we go to create copies  */
name|changed
operator|=
name|pre_delete
argument_list|()
expr_stmt|;
name|did_insert
operator|=
name|pre_edge_insert
argument_list|(
name|edge_list
argument_list|,
name|index_map
argument_list|)
expr_stmt|;
comment|/* In other places with reaching expressions, copy the expression to the      specially allocated pseudo-reg that reaches the redundant expr.  */
name|pre_insert_copies
argument_list|()
expr_stmt|;
if|if
condition|(
name|did_insert
condition|)
block|{
name|commit_edge_insertions
argument_list|()
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|index_map
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|pre_redundant_insns
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Top level routine to perform one PRE GCSE pass.     Return non-zero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|one_pre_gcse_pass
parameter_list|(
name|pass
parameter_list|)
name|int
name|pass
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|gcse_subst_count
operator|=
literal|0
expr_stmt|;
name|gcse_create_count
operator|=
literal|0
expr_stmt|;
name|alloc_expr_hash_table
argument_list|(
name|max_cuid
argument_list|)
expr_stmt|;
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_gcse_lm
condition|)
name|compute_ld_motion_mems
argument_list|()
expr_stmt|;
name|compute_expr_hash_table
argument_list|()
expr_stmt|;
name|trim_ld_motion_mems
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|dump_hash_table
argument_list|(
name|gcse_file
argument_list|,
literal|"Expression"
argument_list|,
name|expr_hash_table
argument_list|,
name|expr_hash_table_size
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_exprs
operator|>
literal|0
condition|)
block|{
name|alloc_pre_mem
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_pre_data
argument_list|()
expr_stmt|;
name|changed
operator||=
name|pre_gcse
argument_list|()
expr_stmt|;
name|free_edge_list
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|free_pre_mem
argument_list|()
expr_stmt|;
block|}
name|free_ldst_mems
argument_list|()
expr_stmt|;
name|remove_fake_edges
argument_list|()
expr_stmt|;
name|free_expr_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\nPRE GCSE of %s, pass %d: %d bytes needed, "
argument_list|,
name|current_function_name
argument_list|,
name|pass
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"%d substs, %d insns created\n"
argument_list|,
name|gcse_subst_count
argument_list|,
name|gcse_create_count
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X contains any LABEL_REF's, add REG_LABEL notes for them to INSN.    If notes are added to an insn which references a CODE_LABEL, the    LABEL_NUSES count is incremented.  We have to add REG_LABEL notes,    because the following loop optimization pass requires them.  */
end_comment

begin_comment
comment|/* ??? This is very similar to the loop.c add_label_notes function.  We    could probably share code here.  */
end_comment

begin_comment
comment|/* ??? If there was a jump optimization pass after gcse and before loop,    then we would not need to do this here, because jump would add the    necessary REG_LABEL notes.  */
end_comment

begin_function
specifier|static
name|void
name|add_label_notes
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
operator|&&
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* This code used to ignore labels that referred to dispatch tables to 	 avoid flow generating (slighly) worse code.  	 We no longer ignore such label references (see LABEL_REF handling in 	 mark_jump_label for additional information).  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|add_label_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|add_label_notes
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute transparent outgoing information for each block.     An expression is transparent to an edge unless it is killed by    the edge itself.  This can only happen with abnormal control flow,    when the edge is traversed through a call.  This happens with    non-local labels and exceptions.     This would not be necessary if we split the edge.  While this is    normally impossible for abnormal critical edges, with some effort    it should be possible with exception handling, since we still have    control over which handler should be invoked.  But due to increased    EH table sizes, this may not be worthwhile.  */
end_comment

begin_function
specifier|static
name|void
name|compute_transpout
parameter_list|()
block|{
name|int
name|bb
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|transpout
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
operator|++
name|bb
control|)
block|{
comment|/* Note that flow inserted a nop a the end of basic blocks that 	 end in call instructions for reasons other than abnormal 	 control flow.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|!=
name|CALL_INSN
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* ??? Optimally, we would use interprocedural alias 		 analysis to determine if this mem is actually killed 		 by this call.  */
name|RESET_BIT
argument_list|(
name|transpout
index|[
name|bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Removal of useless null pointer checks */
end_comment

begin_comment
comment|/* Called via note_stores.  X is set by SETTER.  If X is a register we must    invalidate nonnull_local and set nonnull_killed.  DATA is really a    `null_pointer_info *'.     We ignore hard registers.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_nonnull_info
parameter_list|(
name|x
parameter_list|,
name|setter
parameter_list|,
name|data
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|struct
name|null_pointer_info
modifier|*
name|npi
init|=
operator|(
expr|struct
name|null_pointer_info
operator|*
operator|)
name|data
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Ignore anything that is not a register or is a hard register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|npi
operator|->
name|min_reg
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|npi
operator|->
name|max_reg
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|npi
operator|->
name|min_reg
expr_stmt|;
name|RESET_BIT
argument_list|(
name|npi
operator|->
name|nonnull_local
index|[
name|npi
operator|->
name|current_block
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|npi
operator|->
name|nonnull_killed
index|[
name|npi
operator|->
name|current_block
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do null-pointer check elimination for the registers indicated in    NPI.  NONNULL_AVIN and NONNULL_AVOUT are pre-allocated sbitmaps;    they are not our responsibility to free.  */
end_comment

begin_function
specifier|static
name|void
name|delete_null_pointer_checks_1
parameter_list|(
name|block_reg
parameter_list|,
name|nonnull_avin
parameter_list|,
name|nonnull_avout
parameter_list|,
name|npi
parameter_list|)
name|unsigned
name|int
modifier|*
name|block_reg
decl_stmt|;
name|sbitmap
modifier|*
name|nonnull_avin
decl_stmt|;
name|sbitmap
modifier|*
name|nonnull_avout
decl_stmt|;
name|struct
name|null_pointer_info
modifier|*
name|npi
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
name|int
name|current_block
decl_stmt|;
name|sbitmap
modifier|*
name|nonnull_local
init|=
name|npi
operator|->
name|nonnull_local
decl_stmt|;
name|sbitmap
modifier|*
name|nonnull_killed
init|=
name|npi
operator|->
name|nonnull_killed
decl_stmt|;
comment|/* Compute local properties, nonnull and killed.  A register will have      the nonnull property if at the end of the current block its value is      known to be nonnull.  The killed property indicates that somewhere in      the block any information we had about the register is killed.       Note that a register can have both properties in a single block.  That      indicates that it's killed, then later in the block a new value is      computed.  */
name|sbitmap_vector_zero
argument_list|(
name|nonnull_local
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|nonnull_killed
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|current_block
operator|=
literal|0
init|;
name|current_block
operator|<
name|n_basic_blocks
condition|;
name|current_block
operator|++
control|)
block|{
name|rtx
name|insn
decl_stmt|,
name|stop_insn
decl_stmt|;
comment|/* Set the current block for invalidate_nonnull_info.  */
name|npi
operator|->
name|current_block
operator|=
name|current_block
expr_stmt|;
comment|/* Scan each insn in the basic block looking for memory references and 	 register sets.  */
name|stop_insn
operator|=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|current_block
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|current_block
argument_list|)
init|;
name|insn
operator|!=
name|stop_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
comment|/* Ignore anything that is not a normal insn.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Basically ignore anything that is not a simple SET.  We do have 	     to make sure to invalidate nonnull_local and set nonnull_killed 	     for such insns though.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|invalidate_nonnull_info
argument_list|,
name|npi
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See if we've got a usable memory load.  We handle it first 	     in case it uses its address register as a dest (which kills 	     the nonnull property).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
operator|(
name|reg
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|npi
operator|->
name|min_reg
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|npi
operator|->
name|max_reg
condition|)
name|SET_BIT
argument_list|(
name|nonnull_local
index|[
name|current_block
index|]
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|-
name|npi
operator|->
name|min_reg
argument_list|)
expr_stmt|;
comment|/* Now invalidate stuff clobbered by this insn.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|invalidate_nonnull_info
argument_list|,
name|npi
argument_list|)
expr_stmt|;
comment|/* And handle stores, we do these last since any sets in INSN can 	     not kill the nonnull property if it is derived from a MEM 	     appearing in a SET_DEST.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
operator|(
name|reg
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|npi
operator|->
name|min_reg
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|npi
operator|->
name|max_reg
condition|)
name|SET_BIT
argument_list|(
name|nonnull_local
index|[
name|current_block
index|]
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|-
name|npi
operator|->
name|min_reg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now compute global properties based on the local properties.   This      is a classic global availablity algorithm.  */
name|compute_available
argument_list|(
name|nonnull_local
argument_list|,
name|nonnull_killed
argument_list|,
name|nonnull_avout
argument_list|,
name|nonnull_avin
argument_list|)
expr_stmt|;
comment|/* Now look at each bb and see if it ends with a compare of a value      against zero.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|last_insn
init|=
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|condition
decl_stmt|,
name|earliest
decl_stmt|;
name|int
name|compare_and_branch
decl_stmt|;
comment|/* Since MIN_REG is always at least FIRST_PSEUDO_REGISTER, and 	 since BLOCK_REG[BB] is zero if this block did not end with a 	 comparison against zero, this condition works.  */
if|if
condition|(
name|block_reg
index|[
name|bb
index|]
operator|<
name|npi
operator|->
name|min_reg
operator|||
name|block_reg
index|[
name|bb
index|]
operator|>=
name|npi
operator|->
name|max_reg
condition|)
continue|continue;
comment|/* LAST_INSN is a conditional jump.  Get its condition.  */
name|condition
operator|=
name|get_condition
argument_list|(
name|last_insn
argument_list|,
operator|&
name|earliest
argument_list|)
expr_stmt|;
comment|/* If we can't determine the condition then skip.  */
if|if
condition|(
operator|!
name|condition
condition|)
continue|continue;
comment|/* Is the register known to have a nonzero value?  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|nonnull_avout
index|[
name|bb
index|]
argument_list|,
name|block_reg
index|[
name|bb
index|]
operator|-
name|npi
operator|->
name|min_reg
argument_list|)
condition|)
continue|continue;
comment|/* Try to compute whether the compare/branch at the loop end is one or 	 two instructions.  */
if|if
condition|(
name|earliest
operator|==
name|last_insn
condition|)
name|compare_and_branch
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|earliest
operator|==
name|prev_nonnote_insn
argument_list|(
name|last_insn
argument_list|)
condition|)
name|compare_and_branch
operator|=
literal|2
expr_stmt|;
else|else
continue|continue;
comment|/* We know the register in this comparison is nonnull at exit from 	 this block.  We can optimize this comparison.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
operator|==
name|NE
condition|)
block|{
name|rtx
name|new_jump
decl_stmt|;
name|new_jump
operator|=
name|emit_jump_insn_before
argument_list|(
name|gen_jump
argument_list|(
name|JUMP_LABEL
argument_list|(
name|last_insn
argument_list|)
argument_list|)
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|new_jump
argument_list|)
operator|=
name|JUMP_LABEL
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|new_jump
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|new_jump
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_and_branch
operator|==
literal|2
condition|)
name|delete_insn
argument_list|(
name|earliest
argument_list|)
expr_stmt|;
name|purge_dead_edges
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't check this block again.  (Note that BLOCK_END is 	 invalid here; we deleted the last instruction in the  	 block.)  */
name|block_reg
index|[
name|bb
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find EQ/NE comparisons against zero which can be (indirectly) evaluated    at compile time.     This is conceptually similar to global constant/copy propagation and    classic global CSE (it even uses the same dataflow equations as cprop).     If a register is used as memory address with the form (mem (reg)), then we    know that REG can not be zero at that point in the program.  Any instruction    which sets REG "kills" this property.     So, if every path leading to a conditional branch has an available memory    reference of that form, then we know the register can not have the value    zero at the conditional branch.       So we merely need to compute the local properies and propagate that data    around the cfg, then optimize where possible.     We run this pass two times.  Once before CSE, then again after CSE.  This    has proven to be the most profitable approach.  It is rare for new    optimization opportunities of this nature to appear after the first CSE    pass.     This could probably be integrated with global cprop with a little work.  */
end_comment

begin_function
name|void
name|delete_null_pointer_checks
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|sbitmap
modifier|*
name|nonnull_avin
decl_stmt|,
modifier|*
name|nonnull_avout
decl_stmt|;
name|unsigned
name|int
modifier|*
name|block_reg
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|regs_per_pass
decl_stmt|;
name|int
name|max_reg
decl_stmt|;
name|struct
name|null_pointer_info
name|npi
decl_stmt|;
comment|/* If we have only a single block, then there's nothing to do.  */
if|if
condition|(
name|n_basic_blocks
operator|<=
literal|1
condition|)
return|return;
comment|/* Trying to perform global optimizations on flow graphs which have      a high connectivity will take a long time and is unlikely to be      particularly useful.       In normal circumstances a cfg should have about twice as many edges      as blocks.  But we do not want to punish small functions which have      a couple switch statements.  So we require a relatively large number      of basic blocks and the ratio of edges to blocks to be high.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|1000
operator|&&
name|n_edges
operator|/
name|n_basic_blocks
operator|>=
literal|20
condition|)
return|return;
comment|/* We need four bitmaps, each with a bit for each register in each      basic block.  */
name|max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|regs_per_pass
operator|=
name|get_bitmap_width
argument_list|(
literal|4
argument_list|,
name|n_basic_blocks
argument_list|,
name|max_reg
argument_list|)
expr_stmt|;
comment|/* Allocate bitmaps to hold local and global properties.  */
name|npi
operator|.
name|nonnull_local
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|regs_per_pass
argument_list|)
expr_stmt|;
name|npi
operator|.
name|nonnull_killed
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|regs_per_pass
argument_list|)
expr_stmt|;
name|nonnull_avin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|regs_per_pass
argument_list|)
expr_stmt|;
name|nonnull_avout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|regs_per_pass
argument_list|)
expr_stmt|;
comment|/* Go through the basic blocks, seeing whether or not each block      ends with a conditional branch whose condition is a comparison      against zero.  Record the register compared in BLOCK_REG.  */
name|block_reg
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|last_insn
init|=
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|condition
decl_stmt|,
name|earliest
decl_stmt|,
name|reg
decl_stmt|;
comment|/* We only want conditional branches.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|last_insn
argument_list|)
operator|||
operator|!
name|onlyjump_p
argument_list|(
name|last_insn
argument_list|)
condition|)
continue|continue;
comment|/* LAST_INSN is a conditional jump.  Get its condition.  */
name|condition
operator|=
name|get_condition
argument_list|(
name|last_insn
argument_list|,
operator|&
name|earliest
argument_list|)
expr_stmt|;
comment|/* If we were unable to get the condition, or it is not an equality 	 comparison against zero then there's nothing we can do.  */
if|if
condition|(
operator|!
name|condition
operator|||
operator|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
operator|!=
name|NE
operator|&&
name|GET_CODE
argument_list|(
name|condition
argument_list|)
operator|!=
name|EQ
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|!=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* We must be checking a register against zero.  */
name|reg
operator|=
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
name|block_reg
index|[
name|bb
index|]
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Go through the algorithm for each block of registers.  */
for|for
control|(
name|reg
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|reg
operator|<
name|max_reg
condition|;
name|reg
operator|+=
name|regs_per_pass
control|)
block|{
name|npi
operator|.
name|min_reg
operator|=
name|reg
expr_stmt|;
name|npi
operator|.
name|max_reg
operator|=
name|MIN
argument_list|(
name|reg
operator|+
name|regs_per_pass
argument_list|,
name|max_reg
argument_list|)
expr_stmt|;
name|delete_null_pointer_checks_1
argument_list|(
name|block_reg
argument_list|,
name|nonnull_avin
argument_list|,
name|nonnull_avout
argument_list|,
operator|&
name|npi
argument_list|)
expr_stmt|;
block|}
comment|/* Free the table of registers compared at the end of every block.  */
name|free
argument_list|(
name|block_reg
argument_list|)
expr_stmt|;
comment|/* Free bitmaps.  */
name|sbitmap_vector_free
argument_list|(
name|npi
operator|.
name|nonnull_local
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|npi
operator|.
name|nonnull_killed
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|nonnull_avin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|nonnull_avout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Code Hoisting variables and subroutines.  */
end_comment

begin_comment
comment|/* Very busy expressions.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|hoist_vbein
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|hoist_vbeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hoistable expressions.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|hoist_exprs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Dominator bitmaps.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|dominators
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? We could compute post dominators and run this algorithm in    reverse to to perform tail merging, doing so would probably be    more effective than the tail merging code in jump.c.     It's unclear if tail merging could be run in parallel with    code hoisting.  It would be nice.  */
end_comment

begin_comment
comment|/* Allocate vars used for code hoisting analysis.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_code_hoist_mem
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|)
name|int
name|n_blocks
decl_stmt|,
name|n_exprs
decl_stmt|;
block|{
name|antloc
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|transp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|comp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|hoist_vbein
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|hoist_vbeout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|hoist_exprs
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|transpout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|dominators
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free vars used for code hoisting analysis.  */
end_comment

begin_function
specifier|static
name|void
name|free_code_hoist_mem
parameter_list|()
block|{
name|sbitmap_vector_free
argument_list|(
name|antloc
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|hoist_vbein
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|hoist_vbeout
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|hoist_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|transpout
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|dominators
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the very busy expressions at entry/exit from each block.     An expression is very busy if all paths from a given point    compute the expression.  */
end_comment

begin_function
specifier|static
name|void
name|compute_code_hoist_vbeinout
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|hoist_vbeout
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|hoist_vbein
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
comment|/* We scan the blocks in the reverse order to speed up 	 the convergence.  */
for|for
control|(
name|bb
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|bb
operator|>=
literal|0
condition|;
name|bb
operator|--
control|)
block|{
name|changed
operator||=
name|sbitmap_a_or_b_and_c
argument_list|(
name|hoist_vbein
index|[
name|bb
index|]
argument_list|,
name|antloc
index|[
name|bb
index|]
argument_list|,
name|hoist_vbeout
index|[
name|bb
index|]
argument_list|,
name|transp
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|!=
name|n_basic_blocks
operator|-
literal|1
condition|)
name|sbitmap_intersection_of_succs
argument_list|(
name|hoist_vbeout
index|[
name|bb
index|]
argument_list|,
name|hoist_vbein
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"hoisting vbeinout computation: %d passes\n"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level routine to do the dataflow analysis needed by code hoisting.  */
end_comment

begin_function
specifier|static
name|void
name|compute_code_hoist_data
parameter_list|()
block|{
name|compute_local_properties
argument_list|(
name|transp
argument_list|,
name|comp
argument_list|,
name|antloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compute_transpout
argument_list|()
expr_stmt|;
name|compute_code_hoist_vbeinout
argument_list|()
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|NULL
argument_list|,
name|dominators
argument_list|,
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if the expression identified by EXPR_INDEX would    reach BB unimpared if it was placed at the end of EXPR_BB.     It's unclear exactly what Muchnick meant by "unimpared".  It seems    to me that the expression must either be computed or transparent in    *every* block in the path(s) from EXPR_BB to BB.  Any other definition    would allow the expression to be hoisted out of loops, even if    the expression wasn't a loop invariant.     Contrast this to reachability for PRE where an expression is    considered reachable if *any* path reaches instead of *all*    paths.  */
end_comment

begin_function
specifier|static
name|int
name|hoist_expr_reaches_here_p
parameter_list|(
name|expr_bb
parameter_list|,
name|expr_index
parameter_list|,
name|bb
parameter_list|,
name|visited
parameter_list|)
name|basic_block
name|expr_bb
decl_stmt|;
name|int
name|expr_index
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|char
modifier|*
name|visited
decl_stmt|;
block|{
name|edge
name|pred
decl_stmt|;
name|int
name|visited_allocated_locally
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|visited
operator|==
name|NULL
condition|)
block|{
name|visited_allocated_locally
operator|=
literal|1
expr_stmt|;
name|visited
operator|=
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pred
operator|=
name|bb
operator|->
name|pred
init|;
name|pred
operator|!=
name|NULL
condition|;
name|pred
operator|=
name|pred
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|pred_bb
init|=
name|pred
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|pred
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
break|break;
elseif|else
if|if
condition|(
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
condition|)
continue|continue;
comment|/* Does this predecessor generate this expression?  */
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|comp
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr_index
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|transp
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr_index
argument_list|)
condition|)
break|break;
comment|/* Not killed.  */
else|else
block|{
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|hoist_expr_reaches_here_p
argument_list|(
name|expr_bb
argument_list|,
name|expr_index
argument_list|,
name|pred_bb
argument_list|,
name|visited
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|visited_allocated_locally
condition|)
name|free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
operator|(
name|pred
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Actually perform code hoisting.  */
end_comment

begin_function
specifier|static
name|void
name|hoist_code
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|dominated
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|expr
modifier|*
modifier|*
name|index_map
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|hoist_exprs
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Compute a mapping from expression number (`bitmap_index') to      hash table entry.  */
name|index_map
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|n_exprs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
name|index_map
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|expr
expr_stmt|;
comment|/* Walk over each basic block looking for potentially hoistable      expressions, nothing gets hoisted from the entry block.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|insn_inserted_p
decl_stmt|;
comment|/* Examine each expression that is very busy at the exit of this 	 block.  These are the potentially hoistable expressions.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hoist_vbeout
index|[
name|bb
index|]
operator|->
name|n_bits
condition|;
name|i
operator|++
control|)
block|{
name|int
name|hoistable
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|hoist_vbeout
index|[
name|bb
index|]
argument_list|,
name|i
argument_list|)
operator|&&
name|TEST_BIT
argument_list|(
name|transpout
index|[
name|bb
index|]
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* We've found a potentially hoistable expression, now 		 we look at every block BB dominates to see if it 		 computes the expression.  */
for|for
control|(
name|dominated
operator|=
literal|0
init|;
name|dominated
operator|<
name|n_basic_blocks
condition|;
name|dominated
operator|++
control|)
block|{
comment|/* Ignore self dominance.  */
if|if
condition|(
name|bb
operator|==
name|dominated
operator|||
operator|!
name|TEST_BIT
argument_list|(
name|dominators
index|[
name|dominated
index|]
argument_list|,
name|bb
argument_list|)
condition|)
continue|continue;
comment|/* We've found a dominated block, now see if it computes 		     the busy expression and whether or not moving that 		     expression to the "beginning" of that block is safe.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|antloc
index|[
name|dominated
index|]
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
comment|/* Note if the expression would reach the dominated block 		     unimpared if it was placed at the end of BB.   		     Keep track of how many times this expression is hoistable 		     from a dominated block into BB.  */
if|if
condition|(
name|hoist_expr_reaches_here_p
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
name|i
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|dominated
argument_list|)
argument_list|,
name|NULL
argument_list|)
condition|)
name|hoistable
operator|++
expr_stmt|;
block|}
comment|/* If we found more than one hoistable occurrence of this 		 expression, then note it in the bitmap of expressions to 		 hoist.  It makes no sense to hoist things which are computed 		 in only one BB, and doing so tends to pessimize register 		 allocation.  One could increase this value to try harder 		 to avoid any possible code expansion due to register 		 allocation issues; however experiments have shown that 		 the vast majority of hoistable expressions are only movable 		 from two successors, so raising this threshhold is likely 		 to nullify any benefit we get from code hoisting.  */
if|if
condition|(
name|hoistable
operator|>
literal|1
condition|)
block|{
name|SET_BIT
argument_list|(
name|hoist_exprs
index|[
name|bb
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If we found nothing to hoist, then quit now.  */
if|if
condition|(
operator|!
name|found
condition|)
continue|continue;
comment|/* Loop over all the hoistable expressions.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hoist_exprs
index|[
name|bb
index|]
operator|->
name|n_bits
condition|;
name|i
operator|++
control|)
block|{
comment|/* We want to insert the expression into BB only once, so 	     note when we've inserted it.  */
name|insn_inserted_p
operator|=
literal|0
expr_stmt|;
comment|/* These tests should be the same as the tests above.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|hoist_vbeout
index|[
name|bb
index|]
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* We've found a potentially hoistable expression, now 		 we look at every block BB dominates to see if it 		 computes the expression.  */
for|for
control|(
name|dominated
operator|=
literal|0
init|;
name|dominated
operator|<
name|n_basic_blocks
condition|;
name|dominated
operator|++
control|)
block|{
comment|/* Ignore self dominance.  */
if|if
condition|(
name|bb
operator|==
name|dominated
operator|||
operator|!
name|TEST_BIT
argument_list|(
name|dominators
index|[
name|dominated
index|]
argument_list|,
name|bb
argument_list|)
condition|)
continue|continue;
comment|/* We've found a dominated block, now see if it computes 		     the busy expression and whether or not moving that 		     expression to the "beginning" of that block is safe.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|antloc
index|[
name|dominated
index|]
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
comment|/* The expression is computed in the dominated block and 		     it would be safe to compute it at the start of the 		     dominated block.  Now we have to determine if the 		     expression would reach the dominated block if it was 		     placed at the end of BB.  */
if|if
condition|(
name|hoist_expr_reaches_here_p
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
name|i
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|dominated
argument_list|)
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|struct
name|expr
modifier|*
name|expr
init|=
name|index_map
index|[
name|i
index|]
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
init|=
name|expr
operator|->
name|antic_occr
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Find the right occurrence of this expression.  */
while|while
condition|(
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|!=
name|dominated
operator|&&
name|occr
condition|)
name|occr
operator|=
name|occr
operator|->
name|next
expr_stmt|;
comment|/* Should never happen.  */
if|if
condition|(
operator|!
name|occr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insn
operator|=
name|occr
operator|->
name|insn
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create a pseudo-reg to store the result of reaching 			 expressions into.  Get the mode for the new pseudo 			 from the mode of the original destination pseudo.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL
condition|)
name|expr
operator|->
name|reaching_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In theory this should never fail since we're creating 			 a reg->reg copy.  			 However, on the x86 some of the movXX patterns 			 actually contain clobbers of scratch regs.  This may 			 cause the insn created by validate_change to not 			 match any pattern and thus cause validate_change to 			 fail.  */
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|expr
operator|->
name|reaching_reg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|occr
operator|->
name|deleted_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|insn_inserted_p
condition|)
block|{
name|insert_insn_end_bb
argument_list|(
name|index_map
index|[
name|i
index|]
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insn_inserted_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|index_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level routine to perform one code hoisting (aka unification) pass     Return non-zero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|one_code_hoisting_pass
parameter_list|()
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|alloc_expr_hash_table
argument_list|(
name|max_cuid
argument_list|)
expr_stmt|;
name|compute_expr_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|dump_hash_table
argument_list|(
name|gcse_file
argument_list|,
literal|"Code Hosting Expressions"
argument_list|,
name|expr_hash_table
argument_list|,
name|expr_hash_table_size
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_exprs
operator|>
literal|0
condition|)
block|{
name|alloc_code_hoist_mem
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_code_hoist_data
argument_list|()
expr_stmt|;
name|hoist_code
argument_list|()
expr_stmt|;
name|free_code_hoist_mem
argument_list|()
expr_stmt|;
block|}
name|free_expr_hash_table
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Here we provide the things required to do store motion towards     the exit. In order for this to be effective, gcse also needed to     be taught how to move a load when it is kill only by a store to itself.  	    int i; 	    float a[10];  	    void foo(float scale) 	    { 	      for (i=0; i<10; i++) 		a[i] *= scale; 	    }      'i' is both loaded and stored to in the loop. Normally, gcse cannot move     the load out since its live around the loop, and stored at the bottom      of the loop.         The 'Load Motion' referred to and implemented in this file is      an enhancement to gcse which when using edge based lcm, recognizes     this situation and allows gcse to move the load out of the loop.        Once gcse has hoisted the load, store motion can then push this     load towards the exit, and we end up with no loads or stores of 'i'     in the loop.  */
end_comment

begin_comment
comment|/* This will search the ldst list for a matching expression. If it    doesn't find one, we create one and initialize it.  */
end_comment

begin_function
specifier|static
name|struct
name|ls_expr
modifier|*
name|ldst_entry
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|first_ls_expr
argument_list|()
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|next_ls_expr
argument_list|(
name|ptr
argument_list|)
control|)
if|if
condition|(
name|expr_equiv_p
argument_list|(
name|ptr
operator|->
name|pattern
argument_list|,
name|x
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|ptr
operator|=
operator|(
expr|struct
name|ls_expr
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ls_expr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|pre_ldst_mems
expr_stmt|;
name|ptr
operator|->
name|expr
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|->
name|pattern
operator|=
name|x
expr_stmt|;
name|ptr
operator|->
name|loads
operator|=
name|NULL_RTX
expr_stmt|;
name|ptr
operator|->
name|stores
operator|=
name|NULL_RTX
expr_stmt|;
name|ptr
operator|->
name|reaching_reg
operator|=
name|NULL_RTX
expr_stmt|;
name|ptr
operator|->
name|invalid
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|hash_index
operator|=
literal|0
expr_stmt|;
name|pre_ldst_mems
operator|=
name|ptr
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Free up an individual ldst entry.  */
end_comment

begin_function
specifier|static
name|void
name|free_ldst_entry
parameter_list|(
name|ptr
parameter_list|)
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
block|{
name|free_INSN_LIST_list
argument_list|(
operator|&
name|ptr
operator|->
name|loads
argument_list|)
expr_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|ptr
operator|->
name|stores
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free up all memory associated with the ldst list.  */
end_comment

begin_function
specifier|static
name|void
name|free_ldst_mems
parameter_list|()
block|{
while|while
condition|(
name|pre_ldst_mems
condition|)
block|{
name|struct
name|ls_expr
modifier|*
name|tmp
init|=
name|pre_ldst_mems
decl_stmt|;
name|pre_ldst_mems
operator|=
name|pre_ldst_mems
operator|->
name|next
expr_stmt|;
name|free_ldst_entry
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|pre_ldst_mems
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump debugging info about the ldst list.  */
end_comment

begin_function
specifier|static
name|void
name|print_ldst_list
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"LDST list: \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|first_ls_expr
argument_list|()
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|next_ls_expr
argument_list|(
name|ptr
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  Pattern (%3d): "
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|file
argument_list|,
name|ptr
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n	 Loads : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|loads
condition|)
name|print_rtl
argument_list|(
name|file
argument_list|,
name|ptr
operator|->
name|loads
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(nil)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n	Stores : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|stores
condition|)
name|print_rtl
argument_list|(
name|file
argument_list|,
name|ptr
operator|->
name|stores
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(nil)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if X is in the list of ldst only expressions.  */
end_comment

begin_function
specifier|static
name|struct
name|ls_expr
modifier|*
name|find_rtx_in_ldst
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|pre_ldst_mems
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|expr_equiv_p
argument_list|(
name|ptr
operator|->
name|pattern
argument_list|,
name|x
argument_list|)
operator|&&
operator|!
name|ptr
operator|->
name|invalid
condition|)
return|return
name|ptr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Assign each element of the list of mems a monotonically increasing value.  */
end_comment

begin_function
specifier|static
name|int
name|enumerate_ldsts
parameter_list|()
block|{
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|pre_ldst_mems
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|ptr
operator|->
name|index
operator|=
name|n
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Return first item in the list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|ls_expr
modifier|*
name|first_ls_expr
parameter_list|()
block|{
return|return
name|pre_ldst_mems
return|;
block|}
end_function

begin_comment
comment|/* Return the next item in ther list after the specified one.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|ls_expr
modifier|*
name|next_ls_expr
parameter_list|(
name|ptr
parameter_list|)
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
block|{
return|return
name|ptr
operator|->
name|next
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load Motion for loads which only kill themselves.  */
end_comment

begin_comment
comment|/* Return true if x is a simple MEM operation, with no registers or    side effects. These are the types of loads we consider for the    ld_motion list, otherwise we let the usual aliasing take care of it.  */
end_comment

begin_function
specifier|static
name|int
name|simple_mem
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Make sure there isn't a buried reference in this pattern anywhere.      If there is, invalidate the entry for it since we're not capable     of fixing it up just yet.. We have to be sure we know about ALL     loads since the aliasing code will allow all entries in the    ld_motion list to not-alias itself.  If we miss a load, we will get    the wrong value since gcse might common it and we won't know to     fix it up.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_any_buried_refs
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
comment|/* Invalidate it in the list.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|simple_mem
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|ptr
operator|=
name|ldst_entry
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Recursively process the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|invalidate_any_buried_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|invalidate_any_buried_refs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find all the 'simple' MEMs which are used in LOADs and STORES. Simple    being defined as MEM loads and stores to symbols, with no    side effects and no registers in the expression. If there are any     uses/defs which don't match this criteria, it is invalidated and    trimmed out later.  */
end_comment

begin_function
specifier|static
name|void
name|compute_ld_motion_mems
parameter_list|()
block|{
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|pre_ldst_mems
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Check for a simple LOAD...  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|simple_mem
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|ptr
operator|=
name|ldst_entry
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|ptr
operator|->
name|loads
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|ptr
operator|->
name|loads
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|->
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure there isn't a buried load somewhere.  */
name|invalidate_any_buried_refs
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* Check for stores. Don't worry about aliased ones, they 		     will block any movement we might do later. We only care 		     about this exact pattern since those are the only 		     circumstance that we will ignore the aliasing info.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|simple_mem
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|ptr
operator|=
name|ldst_entry
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|ASM_OPERANDS
condition|)
name|ptr
operator|->
name|stores
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|ptr
operator|->
name|stores
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|->
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|invalidate_any_buried_refs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remove any references that have been either invalidated or are not in the     expression list for pre gcse.  */
end_comment

begin_function
specifier|static
name|void
name|trim_ld_motion_mems
parameter_list|()
block|{
name|struct
name|ls_expr
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
name|struct
name|ls_expr
modifier|*
name|ptr
init|=
name|first_ls_expr
argument_list|()
decl_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|int
name|del
init|=
name|ptr
operator|->
name|invalid
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
init|=
name|NULL
decl_stmt|;
comment|/* Delete if entry has been made invalid.  */
if|if
condition|(
operator|!
name|del
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|del
operator|=
literal|1
expr_stmt|;
comment|/* Delete if we cannot find this mem in the expression list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
operator|&&
name|del
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|expr_equiv_p
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|ptr
operator|->
name|pattern
argument_list|)
condition|)
block|{
name|del
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|del
condition|)
block|{
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
block|{
name|last
operator|->
name|next
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|free_ldst_entry
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|last
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|pre_ldst_mems
operator|=
name|pre_ldst_mems
operator|->
name|next
expr_stmt|;
name|free_ldst_entry
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|pre_ldst_mems
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Set the expression field if we are keeping it.  */
name|last
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Show the world what we've found.  */
if|if
condition|(
name|gcse_file
operator|&&
name|pre_ldst_mems
operator|!=
name|NULL
condition|)
name|print_ldst_list
argument_list|(
name|gcse_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine will take an expression which we are replacing with    a reaching register, and update any stores that are needed if    that expression is in the ld_motion list.  Stores are updated by    copying their SRC to the reaching register, and then storeing    the reaching register into the store location. These keeps the    correct value in the reaching register for the loads.  */
end_comment

begin_function
specifier|static
name|void
name|update_ld_motion_stores
parameter_list|(
name|expr
parameter_list|)
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
block|{
name|struct
name|ls_expr
modifier|*
name|mem_ptr
decl_stmt|;
if|if
condition|(
operator|(
name|mem_ptr
operator|=
name|find_rtx_in_ldst
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
operator|)
condition|)
block|{
comment|/* We can try to find just the REACHED stores, but is shouldn't  	 matter to set the reaching reg everywhere...  some might be  	 dead and should be eliminated later.  */
comment|/* We replace  SET mem = expr   with 	   SET reg = expr 	   SET mem = reg , where reg is the  	   reaching reg used in the load.  */
name|rtx
name|list
init|=
name|mem_ptr
operator|->
name|stores
decl_stmt|;
for|for
control|(
init|;
name|list
operator|!=
name|NULL_RTX
condition|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn
init|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|expr
operator|->
name|reaching_reg
decl_stmt|;
name|rtx
name|copy
decl_stmt|,
name|new
decl_stmt|;
comment|/* If we've already copied it, continue.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|src
condition|)
continue|continue;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE:  store updated with reaching reg "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|expr
operator|->
name|reaching_reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|":\n	"
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|gcse_file
argument_list|,
name|insn
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|copy
operator|=
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|emit_insn_before
argument_list|(
name|copy
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|record_one_set
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
comment|/* un-recognize this pattern since it's probably different now.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|gcse_create_count
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store motion code.  */
end_comment

begin_comment
comment|/* This is used to communicate the target bitvector we want to use in the     reg_set_info routine when called via the note_stores mechanism.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|regvec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in computing the reverse edge graph bit vectors.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|st_antloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global holding the number of store expressions we are dealing with.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_stores
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Checks to set if we need to mark a register set. Called from note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|reg_set_info
parameter_list|(
name|dest
parameter_list|,
name|setter
parameter_list|,
name|data
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|SET_BIT
argument_list|(
operator|*
name|regvec
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the register operands of expression X are killed     anywhere in basic block BB.  */
end_comment

begin_function
specifier|static
name|int
name|store_ops_ok
parameter_list|(
name|x
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
comment|/* If a reg has changed after us in this 	   block, the operand has been killed.  */
return|return
name|TEST_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
case|case
name|MEM
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|tem
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
if|if
condition|(
operator|!
name|store_ops_ok
argument_list|(
name|tem
argument_list|,
name|bb
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|store_ops_ok
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|bb
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Determine whether insn is MEM store pattern that we will consider moving.  */
end_comment

begin_function
specifier|static
name|void
name|find_moveable_store
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|rtx
name|dest
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
return|return;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|MEM
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|dest
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|BLKmode
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
return|return;
if|if
condition|(
name|rtx_varies_p
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|ptr
operator|=
name|ldst_entry
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|stores
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|ptr
operator|->
name|stores
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform store motion. Much like gcse, except we move expressions the    other way by looking at the flowgraph in reverse.  */
end_comment

begin_function
specifier|static
name|int
name|compute_store_table
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|ret
decl_stmt|;
name|unsigned
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|;
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|reg_set_in_block
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|max_gcse_regno
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|reg_set_in_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|pre_ldst_mems
operator|=
literal|0
expr_stmt|;
comment|/* Find all the stores we care about.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|regvec
operator|=
operator|&
operator|(
name|reg_set_in_block
index|[
name|bb
index|]
operator|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|&&
name|insn
operator|!=
name|PREV_INSN
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Ignore anything that is not a normal insn.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|bool
name|clobbers_all
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|clobbers_all
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|clobbers_all
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|pat
argument_list|,
name|reg_set_info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now that we've marked regs, look for stores.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
name|find_moveable_store
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|enumerate_ldsts
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"Store Motion Expressions.\n"
argument_list|)
expr_stmt|;
name|print_ldst_list
argument_list|(
name|gcse_file
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the load X is aliased with STORE_PATTERN.  */
end_comment

begin_function
specifier|static
name|int
name|load_kills_store
parameter_list|(
name|x
parameter_list|,
name|store_pattern
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|store_pattern
decl_stmt|;
block|{
if|if
condition|(
name|true_dependence
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|store_pattern
argument_list|,
name|rtx_addr_varies_p
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Go through the entire insn X, looking for any loads which might alias     STORE_PATTERN.  Return 1 if found.  */
end_comment

begin_function
specifier|static
name|int
name|find_loads
parameter_list|(
name|x
parameter_list|,
name|store_pattern
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|store_pattern
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|load_kills_store
argument_list|(
name|x
argument_list|,
name|store_pattern
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Recursively process the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
operator|!
name|ret
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|ret
operator||=
name|find_loads
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|store_pattern
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|ret
operator||=
name|find_loads
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|store_pattern
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Check if INSN kills the store pattern X (is aliased with it).      Return 1 if it it does.  */
end_comment

begin_function
specifier|static
name|int
name|store_killed_in_insn
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* A normal or pure call might read from pattern, 	 but a const call will not.  */
if|if
condition|(
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SCRATCH
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Check for memory stores to aliased objects.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|expr_equiv_p
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
comment|/* pretend its a load and check for aliasing.  */
if|if
condition|(
name|find_loads
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|find_loads
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
block|}
else|else
return|return
name|find_loads
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the expression X is loaded or clobbered on or after INSN    within basic block BB.  */
end_comment

begin_function
specifier|static
name|int
name|store_killed_after
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|last
init|=
name|bb
operator|->
name|end
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|last
condition|)
return|return
literal|0
return|;
comment|/* Check if the register operands of the store are OK in this block.      Note that if registers are changed ANYWHERE in the block, we'll       decide we can't move it, regardless of whether it changed above       or below the store. This could be improved by checking the register      operands while lookinng for aliasing in each insn.  */
if|if
condition|(
operator|!
name|store_ops_ok
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|store_killed_in_insn
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 if the expression X is loaded or clobbered on or before INSN    within basic block BB.  */
end_comment

begin_function
specifier|static
name|int
name|store_killed_before
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|first
init|=
name|bb
operator|->
name|head
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|first
condition|)
return|return
name|store_killed_in_insn
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
return|;
comment|/* Check if the register operands of the store are OK in this block.      Note that if registers are changed ANYWHERE in the block, we'll       decide we can't move it, regardless of whether it changed above       or below the store. This could be improved by checking the register      operands while lookinng for aliasing in each insn.  */
if|if
condition|(
operator|!
name|store_ops_ok
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
init|;
name|insn
operator|&&
name|insn
operator|!=
name|PREV_INSN
argument_list|(
name|first
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|store_killed_in_insn
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ANTIC_STORE_LIST
parameter_list|(
name|x
parameter_list|)
value|((x)->loads)
end_define

begin_define
define|#
directive|define
name|AVAIL_STORE_LIST
parameter_list|(
name|x
parameter_list|)
value|((x)->stores)
end_define

begin_comment
comment|/* Given the table of available store insns at the end of blocks,    determine which ones are not killed by aliasing, and generate    the appropriate vectors for gen and killed.  */
end_comment

begin_function
specifier|static
name|void
name|build_store_vectors
parameter_list|()
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|b
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|st
decl_stmt|;
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
comment|/* Build the gen_vector. This is any store in the table which is not killed      by aliasing later in its block.  */
name|ae_gen
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|num_stores
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_gen
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|st_antloc
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|num_stores
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|st_antloc
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|first_ls_expr
argument_list|()
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|next_ls_expr
argument_list|(
name|ptr
argument_list|)
control|)
block|{
comment|/* Put all the stores into either the antic list, or the avail list, 	 or both.  */
name|rtx
name|store_list
init|=
name|ptr
operator|->
name|stores
decl_stmt|;
name|ptr
operator|->
name|stores
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
name|st
operator|=
name|store_list
init|;
name|st
operator|!=
name|NULL
condition|;
name|st
operator|=
name|XEXP
argument_list|(
name|st
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|store_killed_after
argument_list|(
name|ptr
operator|->
name|pattern
argument_list|,
name|insn
argument_list|,
name|bb
argument_list|)
condition|)
block|{
comment|/* If we've already seen an availale expression in this block, 		 we can delete the one we saw already (It occurs earlier in 		 the block), and replace it with this one). We'll copy the 		 old SRC expression to an unused register in case there 		 are any side effects.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
condition|)
block|{
comment|/* Find previous store.  */
name|rtx
name|st
decl_stmt|;
for|for
control|(
name|st
operator|=
name|AVAIL_STORE_LIST
argument_list|(
name|ptr
argument_list|)
init|;
name|st
condition|;
name|st
operator|=
name|XEXP
argument_list|(
name|st
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|XEXP
argument_list|(
name|st
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|bb
condition|)
break|break;
if|if
condition|(
name|st
condition|)
block|{
name|rtx
name|r
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|ptr
operator|->
name|pattern
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"Removing redundant store:\n"
argument_list|)
expr_stmt|;
name|replace_store_insn
argument_list|(
name|r
argument_list|,
name|XEXP
argument_list|(
name|st
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|st
argument_list|,
literal|0
argument_list|)
operator|=
name|insn
expr_stmt|;
continue|continue;
block|}
block|}
name|SET_BIT
argument_list|(
name|ae_gen
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
expr_stmt|;
name|AVAIL_STORE_LIST
argument_list|(
name|ptr
argument_list|)
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|AVAIL_STORE_LIST
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|store_killed_before
argument_list|(
name|ptr
operator|->
name|pattern
argument_list|,
name|insn
argument_list|,
name|bb
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|st_antloc
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
expr_stmt|;
name|ANTIC_STORE_LIST
argument_list|(
name|ptr
argument_list|)
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|ANTIC_STORE_LIST
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free the original list of store insns.  */
name|free_INSN_LIST_list
argument_list|(
operator|&
name|store_list
argument_list|)
expr_stmt|;
block|}
name|ae_kill
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|num_stores
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_kill
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|transp
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|num_stores
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|transp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|first_ls_expr
argument_list|()
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|next_ls_expr
argument_list|(
name|ptr
argument_list|)
control|)
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|n_basic_blocks
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|store_killed_after
argument_list|(
name|ptr
operator|->
name|pattern
argument_list|,
name|BLOCK_HEAD
argument_list|(
name|b
argument_list|)
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The anticipatable expression is not killed if it's gen'd.  */
comment|/* 	      We leave this check out for now. If we have a code sequence  	      in a block which looks like: 			ST MEMa = x 			L     y = MEMa 			ST MEMa = z 	      We should flag this as having an ANTIC expression, NOT 	      transparent, NOT killed, and AVAIL. 	      Unfortunately, since we haven't re-written all loads to 	      use the reaching reg, we'll end up doing an incorrect  	      Load in the middle here if we push the store down. It happens in 		    gcc.c-torture/execute/960311-1.c with -O3 	      If we always kill it in this case, we'll sometimes do 	      uneccessary work, but it shouldn't actually hurt anything. 	    if (!TEST_BIT (ae_gen[b], ptr->index)).  */
name|SET_BIT
argument_list|(
name|ae_kill
index|[
name|b
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
name|SET_BIT
argument_list|(
name|transp
index|[
name|b
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Any block with no exits calls some non-returning function, so      we better mark the store killed here, or we might not store to      it at all.  If we knew it was abort, we wouldn't have to store,      but we don't know that for sure.  */
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"ST_avail and ST_antic (shown under loads..)\n"
argument_list|)
expr_stmt|;
name|print_ldst_list
argument_list|(
name|gcse_file
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|gcse_file
argument_list|,
literal|"st_antloc"
argument_list|,
literal|""
argument_list|,
name|st_antloc
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|gcse_file
argument_list|,
literal|"st_kill"
argument_list|,
literal|""
argument_list|,
name|ae_kill
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|gcse_file
argument_list|,
literal|"Transpt"
argument_list|,
literal|""
argument_list|,
name|transp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|gcse_file
argument_list|,
literal|"st_avloc"
argument_list|,
literal|""
argument_list|,
name|ae_gen
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert an instruction at the begining of a basic block, and update     the BLOCK_HEAD if needed.  */
end_comment

begin_function
specifier|static
name|void
name|insert_insn_start_bb
parameter_list|(
name|insn
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
comment|/* Insert at start of successor block.  */
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|bb
operator|->
name|head
argument_list|)
decl_stmt|;
name|rtx
name|before
init|=
name|bb
operator|->
name|head
decl_stmt|;
while|while
condition|(
name|before
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|before
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|before
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|before
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
operator|)
condition|)
break|break;
name|prev
operator|=
name|before
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
name|before
operator|=
name|NEXT_INSN
argument_list|(
name|before
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"STORE_MOTION  insert store at start of BB %d:\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|gcse_file
argument_list|,
name|insn
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine will insert a store on an edge. EXPR is the ldst entry for    the memory reference, and E is the edge to insert it on.  Returns non-zero    if an edge insertion was performed.  */
end_comment

begin_function
specifier|static
name|int
name|insert_store
parameter_list|(
name|expr
parameter_list|,
name|e
parameter_list|)
name|struct
name|ls_expr
modifier|*
name|expr
decl_stmt|;
name|edge
name|e
decl_stmt|;
block|{
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge
name|tmp
decl_stmt|;
comment|/* We did all the deleted before this insert, so if we didn't delete a      store, then we haven't set the reaching reg yet either.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
name|reg
operator|=
name|expr
operator|->
name|reaching_reg
expr_stmt|;
name|insn
operator|=
name|gen_move_insn
argument_list|(
name|expr
operator|->
name|pattern
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* If we are inserting this expression on ALL predecessor edges of a BB,      insert it at the start of the BB, and reset the insert bits on the other      edges so we don't try to insert it on the other edges.  */
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|e
operator|->
name|dest
operator|->
name|pred
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|pred_next
control|)
block|{
name|int
name|index
init|=
name|EDGE_INDEX
argument_list|(
name|edge_list
argument_list|,
name|tmp
operator|->
name|src
argument_list|,
name|tmp
operator|->
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
name|EDGE_INDEX_NO_EDGE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|pre_insert_map
index|[
name|index
index|]
argument_list|,
name|expr
operator|->
name|index
argument_list|)
condition|)
break|break;
block|}
comment|/* If tmp is NULL, we found an insertion on every edge, blank the      insertion vector for these edges, and insert at the start of the BB.  */
if|if
condition|(
operator|!
name|tmp
operator|&&
name|bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
for|for
control|(
name|tmp
operator|=
name|e
operator|->
name|dest
operator|->
name|pred
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|pred_next
control|)
block|{
name|int
name|index
init|=
name|EDGE_INDEX
argument_list|(
name|edge_list
argument_list|,
name|tmp
operator|->
name|src
argument_list|,
name|tmp
operator|->
name|dest
argument_list|)
decl_stmt|;
name|RESET_BIT
argument_list|(
name|pre_insert_map
index|[
name|index
index|]
argument_list|,
name|expr
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|insert_insn_start_bb
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We can't insert on this edge, so we'll insert at the head of the      successors block.  See Morgan, sec 10.5.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
name|EDGE_ABNORMAL
condition|)
block|{
name|insert_insn_start_bb
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|insert_insn_on_edge
argument_list|(
name|insn
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"STORE_MOTION  insert insn on edge (%d, %d):\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|gcse_file
argument_list|,
name|insn
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This routine will replace a store with a SET to a specified register.  */
end_comment

begin_function
specifier|static
name|void
name|replace_store_insn
parameter_list|(
name|reg
parameter_list|,
name|del
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|reg
decl_stmt|,
name|del
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|insn
operator|=
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|del
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|insn
argument_list|,
name|del
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"STORE_MOTION  delete insn in BB %d:\n      "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|gcse_file
argument_list|,
name|del
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\nSTORE MOTION  replaced with insn:\n      "
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|gcse_file
argument_list|,
name|insn
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|del
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete a store, but copy the value that would have been stored into    the reaching_reg for later storing.  */
end_comment

begin_function
specifier|static
name|void
name|delete_store
parameter_list|(
name|expr
parameter_list|,
name|bb
parameter_list|)
name|struct
name|ls_expr
modifier|*
name|expr
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|rtx
name|reg
decl_stmt|,
name|i
decl_stmt|,
name|del
decl_stmt|;
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL_RTX
condition|)
name|expr
operator|->
name|reaching_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|expr
operator|->
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is more than 1 store, the earlier ones will be dead,       but it doesn't hurt to replace them here.  */
name|reg
operator|=
name|expr
operator|->
name|reaching_reg
expr_stmt|;
for|for
control|(
name|i
operator|=
name|AVAIL_STORE_LIST
argument_list|(
name|expr
argument_list|)
init|;
name|i
condition|;
name|i
operator|=
name|XEXP
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|del
operator|=
name|XEXP
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|del
argument_list|)
operator|==
name|bb
condition|)
block|{
comment|/* We know there is only one since we deleted redundant  	     ones during the available computation.  */
name|replace_store_insn
argument_list|(
name|reg
argument_list|,
name|del
argument_list|,
name|bb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free memory used by store motion.  */
end_comment

begin_function
specifier|static
name|void
name|free_store_memory
parameter_list|()
block|{
name|free_ldst_mems
argument_list|()
expr_stmt|;
if|if
condition|(
name|ae_gen
condition|)
name|sbitmap_vector_free
argument_list|(
name|ae_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae_kill
condition|)
name|sbitmap_vector_free
argument_list|(
name|ae_kill
argument_list|)
expr_stmt|;
if|if
condition|(
name|transp
condition|)
name|sbitmap_vector_free
argument_list|(
name|transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_antloc
condition|)
name|sbitmap_vector_free
argument_list|(
name|st_antloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_insert_map
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_insert_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_delete_map
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_delete_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_set_in_block
condition|)
name|sbitmap_vector_free
argument_list|(
name|reg_set_in_block
argument_list|)
expr_stmt|;
name|ae_gen
operator|=
name|ae_kill
operator|=
name|transp
operator|=
name|st_antloc
operator|=
name|NULL
expr_stmt|;
name|pre_insert_map
operator|=
name|pre_delete_map
operator|=
name|reg_set_in_block
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform store motion. Much like gcse, except we move expressions the    other way by looking at the flowgraph in reverse.  */
end_comment

begin_function
specifier|static
name|void
name|store_motion
parameter_list|()
block|{
name|int
name|x
decl_stmt|;
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|int
name|update_flow
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"before store motion\n"
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|init_alias_analysis
argument_list|()
expr_stmt|;
comment|/* Find all the stores that are live to the end of their block.  */
name|num_stores
operator|=
name|compute_store_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_stores
operator|==
literal|0
condition|)
block|{
name|sbitmap_vector_free
argument_list|(
name|reg_set_in_block
argument_list|)
expr_stmt|;
name|end_alias_analysis
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Now compute whats actually available to move.  */
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
name|build_store_vectors
argument_list|()
expr_stmt|;
name|edge_list
operator|=
name|pre_edge_rev_lcm
argument_list|(
name|gcse_file
argument_list|,
name|num_stores
argument_list|,
name|transp
argument_list|,
name|ae_gen
argument_list|,
name|st_antloc
argument_list|,
name|ae_kill
argument_list|,
operator|&
name|pre_insert_map
argument_list|,
operator|&
name|pre_delete_map
argument_list|)
expr_stmt|;
comment|/* Now we want to insert the new stores which are going to be needed.  */
for|for
control|(
name|ptr
operator|=
name|first_ls_expr
argument_list|()
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|next_ls_expr
argument_list|(
name|ptr
argument_list|)
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|n_basic_blocks
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pre_delete_map
index|[
name|x
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
condition|)
name|delete_store
argument_list|(
name|ptr
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pre_insert_map
index|[
name|x
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
condition|)
name|update_flow
operator||=
name|insert_store
argument_list|(
name|ptr
argument_list|,
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_flow
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
name|free_store_memory
argument_list|()
expr_stmt|;
name|free_edge_list
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|remove_fake_edges
argument_list|()
expr_stmt|;
name|end_alias_analysis
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

