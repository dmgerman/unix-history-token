begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Global common subexpression elimination/Partial redundancy elimination    and global constant/copy propagation for GNU compiler.    Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* TODO    - reordering of memory allocation and freeing to be more space efficient    - do rough calc of how many regs are needed in each block, and a rough      calc of how many regs are available in each class and use that to      throttle back the code in cases where RTX_COST is minimal.    - a store to the same address as a load does not kill the load if the      source of the store is also the destination of the load.  Handling this      allows more load motion, particularly out of loops.    - ability to realloc sbitmap vectors would allow one initial computation      of reg_set_in_block with only subsequent additions, rather than      recomputing it for each pass  */
end_comment

begin_comment
comment|/* References searched while implementing this.     Compilers Principles, Techniques and Tools    Aho, Sethi, Ullman    Addison-Wesley, 1988     Global Optimization by Suppression of Partial Redundancies    E. Morel, C. Renvoise    communications of the acm, Vol. 22, Num. 2, Feb. 1979     A Portable Machine-Independent Global Optimizer - Design and Measurements    Frederick Chow    Stanford Ph.D. thesis, Dec. 1983     A Fast Algorithm for Code Movement Optimization    D.M. Dhamdhere    SIGPLAN Notices, Vol. 23, Num. 10, Oct. 1988     A Solution to a Problem with Morel and Renvoise's    Global Optimization by Suppression of Partial Redundancies    K-H Drechsler, M.P. Stadel    ACM TOPLAS, Vol. 10, Num. 4, Oct. 1988     Practical Adaptation of the Global Optimization    Algorithm of Morel and Renvoise    D.M. Dhamdhere    ACM TOPLAS, Vol. 13, Num. 2. Apr. 1991     Efficiently Computing Static Single Assignment Form and the Control    Dependence Graph    R. Cytron, J. Ferrante, B.K. Rosen, M.N. Wegman, and F.K. Zadeck    ACM TOPLAS, Vol. 13, Num. 4, Oct. 1991     Lazy Code Motion    J. Knoop, O. Ruthing, B. Steffen    ACM SIGPLAN Notices Vol. 27, Num. 7, Jul. 1992, '92 Conference on PLDI     What's In a Region?  Or Computing Control Dependence Regions in Near-Linear    Time for Reducible Flow Control    Thomas Ball    ACM Letters on Programming Languages and Systems,    Vol. 2, Num. 1-4, Mar-Dec 1993     An Efficient Representation for Sparse Sets    Preston Briggs, Linda Torczon    ACM Letters on Programming Languages and Systems,    Vol. 2, Num. 1-4, Mar-Dec 1993     A Variation of Knoop, Ruthing, and Steffen's Lazy Code Motion    K-H Drechsler, M.P. Stadel    ACM SIGPLAN Notices, Vol. 28, Num. 5, May 1993     Partial Dead Code Elimination    J. Knoop, O. Ruthing, B. Steffen    ACM SIGPLAN Notices, Vol. 29, Num. 6, Jun. 1994     Effective Partial Redundancy Elimination    P. Briggs, K.D. Cooper    ACM SIGPLAN Notices, Vol. 29, Num. 6, Jun. 1994     The Program Structure Tree: Computing Control Regions in Linear Time    R. Johnson, D. Pearson, K. Pingali    ACM SIGPLAN Notices, Vol. 29, Num. 6, Jun. 1994     Optimal Code Motion: Theory and Practice    J. Knoop, O. Ruthing, B. Steffen    ACM TOPLAS, Vol. 16, Num. 4, Jul. 1994     The power of assignment motion    J. Knoop, O. Ruthing, B. Steffen    ACM SIGPLAN Notices Vol. 30, Num. 6, Jun. 1995, '95 Conference on PLDI     Global code motion / global value numbering    C. Click    ACM SIGPLAN Notices Vol. 30, Num. 6, Jun. 1995, '95 Conference on PLDI     Value Driven Redundancy Elimination    L.T. Simpson    Rice University Ph.D. thesis, Apr. 1996     Value Numbering    L.T. Simpson    Massively Scalar Compiler Project, Rice University, Sep. 1996     High Performance Compilers for Parallel Computing    Michael Wolfe    Addison-Wesley, 1996     Advanced Compiler Design and Implementation    Steven Muchnick    Morgan Kaufmann, 1997     Building an Optimizing Compiler    Robert Morgan    Digital Press, 1998     People wishing to speed up the code here should read:      Elimination Algorithms for Data Flow Analysis      B.G. Ryder, M.C. Paull      ACM Computing Surveys, Vol. 18, Num. 3, Sep. 1986       How to Analyze Large Programs Efficiently and Informatively      D.M. Dhamdhere, B.K. Rosen, F.K. Zadeck      ACM SIGPLAN Notices Vol. 27, Num. 7, Jul. 1992, '92 Conference on PLDI     People wishing to do something different can find various possibilities    in the above papers and elsewhere. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"cselib.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* Propagate flow information through back edges and thus enable PRE's    moving loop invariant calculations out of loops.     Originally this tended to create worse overall code, but several    improvements during the development of PRE seem to have made following    back edges generally a win.     Note much of the loop invariant code motion done here would normally    be done by loop.c, which has more heuristics for when to move invariants    out of loops.  At some point we might need to move some of those    heuristics into gcse.c.  */
end_comment

begin_comment
comment|/* We support GCSE via Partial Redundancy Elimination.  PRE optimizations    are a superset of those done by GCSE.     We perform the following steps:     1) Compute basic block information.     2) Compute table of places where registers are set.     3) Perform copy/constant propagation.     4) Perform global cse.     5) Perform another pass of copy/constant propagation.     Two passes of copy/constant propagation are done because the first one    enables more GCSE and the second one helps to clean up the copies that    GCSE creates.  This is needed more for PRE than for Classic because Classic    GCSE will try to use an existing register containing the common    subexpression rather than create a new one.  This is harder to do for PRE    because of the code motion (which Classic GCSE doesn't do).     Expressions we are interested in GCSE-ing are of the form    (set (pseudo-reg) (expression)).    Function want_to_gcse_p says what these are.     PRE handles moving invariant expressions out of loops (by treating them as    partially redundant).     Eventually it would be nice to replace cse.c/gcse.c with SSA (static single    assignment) based GVN (global value numbering).  L. T. Simpson's paper    (Rice University) on value numbering is a useful reference for this.     **********************     We used to support multiple passes but there are diminishing returns in    doing so.  The first pass usually makes 90% of the changes that are doable.    A second pass can make a few more changes made possible by the first pass.    Experiments show any further passes don't make enough changes to justify    the expense.     A study of spec92 using an unlimited number of passes:    [1 pass] = 1208 substitutions, [2] = 577, [3] = 202, [4] = 192, [5] = 83,    [6] = 34, [7] = 17, [8] = 9, [9] = 4, [10] = 4, [11] = 2,    [12] = 2, [13] = 1, [15] = 1, [16] = 2, [41] = 1     It was found doing copy propagation between each pass enables further    substitutions.     PRE is quite expensive in complicated functions because the DFA can take    awhile to converge.  Hence we only perform one pass.  The parameter max-gcse-passes can    be modified if one wants to experiment.     **********************     The steps for PRE are:     1) Build the hash table of expressions we wish to GCSE (expr_hash_table).     2) Perform the data flow analysis for PRE.     3) Delete the redundant instructions     4) Insert the required copies [if any] that make the partially       redundant instructions fully redundant.     5) For other reaching expressions, insert an instruction to copy the value       to a newly created pseudo that will reach the redundant instruction.     The deletion is done first so that when we do insertions we    know which pseudo reg to use.     Various papers have argued that PRE DFA is expensive (O(n^2)) and others    argue it is not.  The number of iterations for the algorithm to converge    is typically 2-4 so I don't view it as that expensive (relatively speaking).     PRE GCSE depends heavily on the second CSE pass to clean up the copies    we create.  To make an expression reach the place where it's redundant,    the result of the expression is copied to a new register, and the redundant    expression is deleted by replacing it with this new register.  Classic GCSE    doesn't have this problem as much as it computes the reaching defs of    each register in each block and thus can try to use an existing register.     **********************     A fair bit of simplicity is created by creating small functions for simple    tasks, even when the function is only called in one place.  This may    measurably slow things down [or may not] by creating more function call    overhead than is necessary.  The source is laid out so that it's trivial    to make the affected functions inline so that one can measure what speed    up, if any, can be achieved, and maybe later when things settle things can    be rearranged.     Help stamp out big monolithic functions!  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* GCSE global vars.  */
end_comment

begin_comment
comment|/* -dG dump file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|gcse_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Note whether or not we should run jump optimization after gcse.  We    want to do this for two cases.      * If we changed any jumps via cprop.      * If we added any labels via edge splitting.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|run_jump_opt_after_gcse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmaps are normally not included in debugging dumps.    However it's useful to be able to print them from GDB.    We could create special functions for this, but it's simpler to    just allow passing stderr to the dump_foo fns.  Since stderr can    be a macro, we store a copy here.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|debug_stderr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An obstack for our working variables.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|gcse_obstack
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|reg_use
block|{
name|rtx
name|reg_rtx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hash table of expressions.  */
end_comment

begin_struct
struct|struct
name|expr
block|{
comment|/* The expression (SET_SRC for expressions, PATTERN for assignments).  */
name|rtx
name|expr
decl_stmt|;
comment|/* Index in the available expression bitmaps.  */
name|int
name|bitmap_index
decl_stmt|;
comment|/* Next entry with the same hash.  */
name|struct
name|expr
modifier|*
name|next_same_hash
decl_stmt|;
comment|/* List of anticipatable occurrences in basic blocks in the function.      An "anticipatable occurrence" is one that is the first occurrence in the      basic block, the operands are not modified in the basic block prior      to the occurrence and the output is not used between the start of      the block and the occurrence.  */
name|struct
name|occr
modifier|*
name|antic_occr
decl_stmt|;
comment|/* List of available occurrence in basic blocks in the function.      An "available occurrence" is one that is the last occurrence in the      basic block and the operands are not modified by following statements in      the basic block [including this insn].  */
name|struct
name|occr
modifier|*
name|avail_occr
decl_stmt|;
comment|/* Non-null if the computation is PRE redundant.      The value is the newly created pseudo-reg to record a copy of the      expression in all the places that reach the redundant copy.  */
name|rtx
name|reaching_reg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Occurrence of an expression.    There is one per basic block.  If a pattern appears more than once the    last appearance is used [or first for anticipatable expressions].  */
end_comment

begin_struct
struct|struct
name|occr
block|{
comment|/* Next occurrence of this expression.  */
name|struct
name|occr
modifier|*
name|next
decl_stmt|;
comment|/* The insn that computes the expression.  */
name|rtx
name|insn
decl_stmt|;
comment|/* Nonzero if this [anticipatable] occurrence has been deleted.  */
name|char
name|deleted_p
decl_stmt|;
comment|/* Nonzero if this [available] occurrence has been copied to      reaching_reg.  */
comment|/* ??? This is mutually exclusive with deleted_p, so they could share      the same byte.  */
name|char
name|copied_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Expression and copy propagation hash tables.    Each hash table is an array of buckets.    ??? It is known that if it were an array of entries, structure elements    `next_same_hash' and `bitmap_index' wouldn't be necessary.  However, it is    not clear whether in the final analysis a sufficient amount of memory would    be saved as the size of the available expression bitmaps would be larger    [one could build a mapping table without holes afterwards though].    Someday I'll perform the computation and figure it out.  */
end_comment

begin_struct
struct|struct
name|hash_table
block|{
comment|/* The table itself.      This is an array of `expr_hash_table_size' elements.  */
name|struct
name|expr
modifier|*
modifier|*
name|table
decl_stmt|;
comment|/* Size of the hash table, in elements.  */
name|unsigned
name|int
name|size
decl_stmt|;
comment|/* Number of hash table elements.  */
name|unsigned
name|int
name|n_elems
decl_stmt|;
comment|/* Whether the table is expression of copy propagation one.  */
name|int
name|set_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Expression hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_table
name|expr_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy propagation hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_table
name|set_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping of uids to cuids.    Only real insns get cuids.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest UID in UID_CUID.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the cuid of an insn.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_define
define|#
directive|define
name|INSN_CUID
parameter_list|(
name|INSN
parameter_list|)
value|(INSN_UID (INSN)> max_uid ? (abort (), 0) : uid_cuid[INSN_UID (INSN)])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INSN_CUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_cuid[INSN_UID (INSN)])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of cuids.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping of cuids to insns.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|cuid_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get insn from cuid.  */
end_comment

begin_define
define|#
directive|define
name|CUID_INSN
parameter_list|(
name|CUID
parameter_list|)
value|(cuid_insn[CUID])
end_define

begin_comment
comment|/* Maximum register number in function prior to doing gcse + 1.    Registers created during this pass have regno>= max_gcse_regno.    This is named with "gcse" to not collide with global of same name.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|max_gcse_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of registers that are modified.     For each register, each element is a list of places where the pseudo-reg    is set.     For simplicity, GCSE is done on sets of pseudo-regs only.  PRE GCSE only    requires knowledge of which blocks kill which regs [and thus could use    a bitmap instead of the lists `reg_set_table' uses].     `reg_set_table' and could be turned into an array of bitmaps (num-bbs x    num-regs) [however perhaps it may be useful to keep the data as is].  One    advantage of recording things this way is that `reg_set_table' is fairly    sparse with respect to pseudo regs but for hard regs could be fairly dense    [relatively speaking].  And recording sets of pseudo-regs in lists speeds    up functions like compute_transp since in the case of pseudo-regs we only    need to iterate over the number of times a pseudo-reg is set, not over the    number of basic blocks [clearly there is a bit of a slow down in the cases    where a pseudo is set more than once in a block, however it is believed    that the net effect is to speed things up].  This isn't done for hard-regs    because recording call-clobbered hard-regs in `reg_set_table' at each    function call can consume a fair bit of memory, and iterating over    hard-regs stored this way in compute_transp will be more expensive.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|reg_set
block|{
comment|/* The next setting of this register.  */
name|struct
name|reg_set
modifier|*
name|next
decl_stmt|;
comment|/* The insn where it was set.  */
name|rtx
name|insn
decl_stmt|;
block|}
name|reg_set
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|reg_set
modifier|*
modifier|*
name|reg_set_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of `reg_set_table'.    The table starts out at max_gcse_regno + slop, and is enlarged as    necessary.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_set_table_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount to grow `reg_set_table' by when it's full.  */
end_comment

begin_define
define|#
directive|define
name|REG_SET_TABLE_SLOP
value|100
end_define

begin_comment
comment|/* This is a list of expressions which are MEMs and will be used by load    or store motion.    Load motion tracks MEMs which aren't killed by    anything except itself. (ie, loads and stores to a single location).    We can then allow movement of these MEM refs with a little special    allowance. (all stores copy the same value to the reaching reg used    for the loads).  This means all values used to store into memory must have    no side effects so we can re-issue the setter value.    Store Motion uses this structure as an expression table to track stores    which look interesting, and might be moveable towards the exit block.  */
end_comment

begin_struct
struct|struct
name|ls_expr
block|{
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
comment|/* Gcse expression reference for LM.  */
name|rtx
name|pattern
decl_stmt|;
comment|/* Pattern of this mem.  */
name|rtx
name|pattern_regs
decl_stmt|;
comment|/* List of registers mentioned by the mem.  */
name|rtx
name|loads
decl_stmt|;
comment|/* INSN list of loads seen.  */
name|rtx
name|stores
decl_stmt|;
comment|/* INSN list of stores seen.  */
name|struct
name|ls_expr
modifier|*
name|next
decl_stmt|;
comment|/* Next in the list.  */
name|int
name|invalid
decl_stmt|;
comment|/* Invalid for some reason.  */
name|int
name|index
decl_stmt|;
comment|/* If it maps to a bitmap index.  */
name|unsigned
name|int
name|hash_index
decl_stmt|;
comment|/* Index when in a hash table.  */
name|rtx
name|reaching_reg
decl_stmt|;
comment|/* Register to use when re-writing.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Array of implicit set patterns indexed by basic block index.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|implicit_sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Head of the list of load/store memory refs.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ls_expr
modifier|*
name|pre_ldst_mems
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmap containing one bit for each register in the program.    Used when performing GCSE to track which registers have been set since    the start of the basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|regset
name|reg_set_bitmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each block, a bitmap of registers set in the block.    This is used by expr_killed_p and compute_transp.    It is computed during hash table computation and not by compute_sets    as it includes registers added since the last pass (or between cprop and    gcse) and it's currently not easy to realloc sbitmap vectors.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|reg_set_in_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array, indexed by basic block number for a list of insns which modify    memory within that block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|modify_mem_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bitmap
name|modify_mem_list_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array parallels modify_mem_list, but is kept canonicalized.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|canon_modify_mem_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bitmap
name|canon_modify_mem_list_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various variables for statistics gathering.  */
end_comment

begin_comment
comment|/* Memory used in a pass.    This isn't intended to be absolutely precise.  Its intent is only    to keep an eye on memory usage.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bytes_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GCSE substitutions made.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gcse_subst_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of copy instructions created.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gcse_create_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of constants propagated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|const_prop_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of copys propagated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|copy_prop_count
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* These variables are used by classic GCSE.    Normally they'd be defined a bit later, but `rd_gen' needs to    be declared sooner.  */
end_comment

begin_comment
comment|/* Each block has a bitmap of each type.    The length of each blocks bitmap is:         max_cuid  - for reaching definitions        n_exprs - for available expressions     Thus we view the bitmaps as 2 dimensional arrays.  i.e.    rd_kill[block_num][cuid_num]    ae_kill[block_num][expr_num]			 */
end_comment

begin_comment
comment|/* For reaching defs */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|rd_kill
decl_stmt|,
modifier|*
name|rd_gen
decl_stmt|,
modifier|*
name|reaching_defs
decl_stmt|,
modifier|*
name|rd_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for available exprs */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|ae_kill
decl_stmt|,
modifier|*
name|ae_gen
decl_stmt|,
modifier|*
name|ae_in
decl_stmt|,
modifier|*
name|ae_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Objects of this type are passed around by the null-pointer check    removal routines.  */
end_comment

begin_struct
struct|struct
name|null_pointer_info
block|{
comment|/* The basic block being processed.  */
name|basic_block
name|current_block
decl_stmt|;
comment|/* The first register to be handled in this pass.  */
name|unsigned
name|int
name|min_reg
decl_stmt|;
comment|/* One greater than the last register to be handled in this pass.  */
name|unsigned
name|int
name|max_reg
decl_stmt|;
name|sbitmap
modifier|*
name|nonnull_local
decl_stmt|;
name|sbitmap
modifier|*
name|nonnull_killed
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|compute_can_copy
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
modifier|*
name|gmalloc
argument_list|(
name|size_t
argument_list|)
name|ATTRIBUTE_MALLOC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|gcalloc
argument_list|(
name|size_t
argument_list|,
name|size_t
argument_list|)
name|ATTRIBUTE_MALLOC
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
modifier|*
name|grealloc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|gcse_alloc
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alloc_gcse_mem
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_gcse_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alloc_reg_set_mem
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_reg_set_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_bitmap_width
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_one_set
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_one_set
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_set_info
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_sets
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_scan_insn
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_scan_set
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_scan_clobber
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_scan_call
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|want_to_gcse_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|gcse_constant_p
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oprs_unchanged_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oprs_anticipatable_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oprs_available_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_expr_in_table
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_set_in_table
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|hash_expr
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|hash_expr_1
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|hash_string_1
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|hash_set
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expr_equiv_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_last_reg_set_info
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_last_mem_set_info
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_last_set_info
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_hash_table
parameter_list|(
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alloc_hash_table
parameter_list|(
name|int
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_hash_table
parameter_list|(
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_hash_table_work
parameter_list|(
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_hash_table
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|expr
modifier|*
name|lookup_expr
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|expr
modifier|*
name|lookup_set
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|expr
modifier|*
name|next_set
parameter_list|(
name|unsigned
name|int
parameter_list|,
name|struct
name|expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reset_opr_set_tables
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|oprs_not_set_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_call
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_set
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_clobber
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_oprs_set
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alloc_cprop_mem
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_cprop_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_transp
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_transpout
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_local_properties
parameter_list|(
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_cprop_data
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_used_regs
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_replace_reg
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|expr
modifier|*
name|find_avail_set
parameter_list|(
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cprop_jump
parameter_list|(
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mems_conflict_for_gcse_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|load_killed_in_block_p
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|canon_list_insert
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cprop_insn
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cprop
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_implicit_sets
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|one_cprop_pass
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|constprop_register
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|expr
modifier|*
name|find_bypass_set
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|reg_killed_on_edge
parameter_list|(
name|rtx
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bypass_block
parameter_list|(
name|basic_block
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bypass_conditional_jumps
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alloc_pre_mem
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_pre_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_pre_data
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_expr_reaches_here_p
parameter_list|(
name|basic_block
parameter_list|,
name|struct
name|expr
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_insn_end_bb
parameter_list|(
name|struct
name|expr
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pre_insert_copy_insn
parameter_list|(
name|struct
name|expr
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pre_insert_copies
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_delete
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_gcse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|one_pre_gcse_pass
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_label_notes
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alloc_code_hoist_mem
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_code_hoist_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_code_hoist_vbeinout
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_code_hoist_data
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hoist_expr_reaches_here_p
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|,
name|basic_block
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hoist_code
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|one_code_hoisting_pass
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alloc_rd_mem
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_rd_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_rd_kill_set
parameter_list|(
name|rtx
parameter_list|,
name|int
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_kill_rd
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_rd
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alloc_avail_expr_mem
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_avail_expr_mem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_ae_gen
parameter_list|(
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expr_killed_p
parameter_list|(
name|rtx
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_ae_kill
parameter_list|(
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|struct
name|hash_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expr_reaches_here_p
parameter_list|(
name|struct
name|occr
modifier|*
parameter_list|,
name|struct
name|expr
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|computing_insn
parameter_list|(
name|struct
name|expr
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|def_reaches_here_p
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|can_disregard_other_sets
parameter_list|(
name|struct
name|reg_set
modifier|*
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_avail_expr
parameter_list|(
name|rtx
parameter_list|,
name|struct
name|expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|classic_gcse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|one_classic_gcse_pass
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalidate_nonnull_info
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|delete_null_pointer_checks_1
parameter_list|(
name|unsigned
name|int
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|sbitmap
modifier|*
parameter_list|,
name|struct
name|null_pointer_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|process_insert_insn
parameter_list|(
name|struct
name|expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_edge_insert
parameter_list|(
name|struct
name|edge_list
modifier|*
parameter_list|,
name|struct
name|expr
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expr_reaches_here_p_work
parameter_list|(
name|struct
name|occr
modifier|*
parameter_list|,
name|struct
name|expr
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pre_expr_reaches_here_p_work
parameter_list|(
name|basic_block
parameter_list|,
name|struct
name|expr
modifier|*
parameter_list|,
name|basic_block
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ls_expr
modifier|*
name|ldst_entry
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_ldst_entry
parameter_list|(
name|struct
name|ls_expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_ldst_mems
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_ldst_list
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ls_expr
modifier|*
name|find_rtx_in_ldst
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|enumerate_ldsts
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|ls_expr
modifier|*
name|first_ls_expr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|struct
name|ls_expr
modifier|*
name|next_ls_expr
parameter_list|(
name|struct
name|ls_expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|simple_mem
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalidate_any_buried_refs
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_ld_motion_mems
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trim_ld_motion_mems
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_ld_motion_stores
parameter_list|(
name|struct
name|expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_set_info
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_clear_last_set
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|store_ops_ok
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|extract_mentioned_regs
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|extract_mentioned_regs_helper
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_moveable_store
parameter_list|(
name|rtx
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compute_store_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|load_kills_store
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|find_loads
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|store_killed_in_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|store_killed_after
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|basic_block
parameter_list|,
name|int
modifier|*
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|store_killed_before
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|basic_block
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_store_vectors
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_insn_start_bb
parameter_list|(
name|rtx
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insert_store
parameter_list|(
name|struct
name|ls_expr
modifier|*
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_reachable_equiv_notes
parameter_list|(
name|basic_block
parameter_list|,
name|struct
name|ls_expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|replace_store_insn
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|basic_block
parameter_list|,
name|struct
name|ls_expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_store
parameter_list|(
name|struct
name|ls_expr
modifier|*
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_store_memory
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_motion
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_insn_expr_list_list
parameter_list|(
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_modify_mem_tables
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_modify_mem_tables
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|gcse_emit_move_after
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|local_cprop_find_used_regs
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|do_local_cprop
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|adjust_libcall_notes
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|local_cprop_pass
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_too_expensive
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Entry point for global common subexpression elimination.    F is the first instruction in the function.  */
end_comment

begin_function
name|int
name|gcse_main
parameter_list|(
name|rtx
name|f
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|changed
decl_stmt|,
name|pass
decl_stmt|;
comment|/* Bytes used at start of pass.  */
name|int
name|initial_bytes_used
decl_stmt|;
comment|/* Maximum number of bytes used by a pass.  */
name|int
name|max_pass_bytes
decl_stmt|;
comment|/* Point to release obstack data from for each pass.  */
name|char
modifier|*
name|gcse_obstack_bottom
decl_stmt|;
comment|/* We do not construct an accurate cfg in functions which call      setjmp, so just punt to be safe.  */
if|if
condition|(
name|current_function_calls_setjmp
condition|)
return|return
literal|0
return|;
comment|/* Assume that we do not need to run jump optimizations after gcse.  */
name|run_jump_opt_after_gcse
operator|=
literal|0
expr_stmt|;
comment|/* For calling dump_foo fns from gdb.  */
name|debug_stderr
operator|=
name|stderr
expr_stmt|;
name|gcse_file
operator|=
name|file
expr_stmt|;
comment|/* Identify the basic block information for this function, including      successors and predecessors.  */
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_flow_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Return if there's nothing to do, or it is too expensive.  */
if|if
condition|(
name|n_basic_blocks
operator|<=
literal|1
operator|||
name|is_too_expensive
argument_list|(
name|_
argument_list|(
literal|"GCSE disabled"
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|gcc_obstack_init
argument_list|(
operator|&
name|gcse_obstack
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
literal|0
expr_stmt|;
comment|/* We need alias.  */
name|init_alias_analysis
argument_list|()
expr_stmt|;
comment|/* Record where pseudo-registers are set.  This data is kept accurate      during each pass.  ??? We could also record hard-reg information here      [since it's unchanging], however it is currently done during hash table      computation.       It may be tempting to compute MEM set information here too, but MEM sets      will be subject to code motion one day and thus we need to compute      information about memory sets when we build the hash tables.  */
name|alloc_reg_set_mem
argument_list|(
name|max_gcse_regno
argument_list|)
expr_stmt|;
name|compute_sets
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|pass
operator|=
literal|0
expr_stmt|;
name|initial_bytes_used
operator|=
name|bytes_used
expr_stmt|;
name|max_pass_bytes
operator|=
literal|0
expr_stmt|;
name|gcse_obstack_bottom
operator|=
name|gcse_alloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
operator|&&
name|pass
operator|<
name|MAX_GCSE_PASSES
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"GCSE pass %d\n\n"
argument_list|,
name|pass
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize bytes_used to the space for the pred/succ lists, 	 and the reg_set_table data.  */
name|bytes_used
operator|=
name|initial_bytes_used
expr_stmt|;
comment|/* Each pass may create new registers, so recalculate each time.  */
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|alloc_gcse_mem
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Don't allow constant propagation to modify jumps 	 during this pass.  */
name|changed
operator|=
name|one_cprop_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize_size
condition|)
name|changed
operator||=
name|one_classic_gcse_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|changed
operator||=
name|one_pre_gcse_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* We may have just created new basic blocks.  Release and 	     recompute various things which are sized on the number of 	     basic blocks.  */
if|if
condition|(
name|changed
condition|)
block|{
name|free_modify_mem_tables
argument_list|()
expr_stmt|;
name|modify_mem_list
operator|=
name|gcalloc
argument_list|(
name|last_basic_block
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|canon_modify_mem_list
operator|=
name|gcalloc
argument_list|(
name|last_basic_block
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free_reg_set_mem
argument_list|()
expr_stmt|;
name|alloc_reg_set_mem
argument_list|(
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|compute_sets
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|run_jump_opt_after_gcse
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|max_pass_bytes
operator|<
name|bytes_used
condition|)
name|max_pass_bytes
operator|=
name|bytes_used
expr_stmt|;
comment|/* Free up memory, then reallocate for code hoisting.  We can 	 not re-use the existing allocated memory because the tables 	 will not have info for the insns or registers created by 	 partial redundancy elimination.  */
name|free_gcse_mem
argument_list|()
expr_stmt|;
comment|/* It does not make sense to run code hoisting unless we are optimizing 	 for code size -- it rarely makes programs faster, and can make 	 them bigger if we did partial redundancy elimination (when optimizing 	 for space, we use a classic gcse algorithm instead of partial 	 redundancy algorithms).  */
if|if
condition|(
name|optimize_size
condition|)
block|{
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|alloc_gcse_mem
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|changed
operator||=
name|one_code_hoisting_pass
argument_list|()
expr_stmt|;
name|free_gcse_mem
argument_list|()
expr_stmt|;
if|if
condition|(
name|max_pass_bytes
operator|<
name|bytes_used
condition|)
name|max_pass_bytes
operator|=
name|bytes_used
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|gcse_obstack
argument_list|,
name|gcse_obstack_bottom
argument_list|)
expr_stmt|;
name|pass
operator|++
expr_stmt|;
block|}
comment|/* Do one last pass of copy propagation, including cprop into      conditional jumps.  */
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|alloc_gcse_mem
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* This time, go ahead and allow cprop to alter jumps.  */
name|one_cprop_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_gcse_mem
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"GCSE of %s: %d basic blocks, "
argument_list|,
name|current_function_name
argument_list|()
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d pass%s, %d bytes\n\n"
argument_list|,
name|pass
argument_list|,
name|pass
operator|>
literal|1
condition|?
literal|"es"
else|:
literal|""
argument_list|,
name|max_pass_bytes
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|gcse_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_reg_set_mem
argument_list|()
expr_stmt|;
comment|/* We are finished with alias.  */
name|end_alias_analysis
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optimize_size
operator|&&
name|flag_gcse_sm
condition|)
name|store_motion
argument_list|()
expr_stmt|;
comment|/* Record where pseudo-registers are set.  */
return|return
name|run_jump_opt_after_gcse
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Misc. utilities.  */
end_comment

begin_comment
comment|/* Nonzero for each mode that supports (set (reg) (reg)).    This is trivially true for integer and floating point values.    It may or may not be true for condition codes.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|can_copy
index|[
operator|(
name|int
operator|)
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute which modes support reg/reg copy operations.  */
end_comment

begin_function
specifier|static
name|void
name|compute_can_copy
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|AVOID_CCMODE_COPIES
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|can_copy
argument_list|,
literal|0
argument_list|,
name|NUM_MACHINE_MODES
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|i
argument_list|)
operator|==
name|MODE_CC
condition|)
block|{
ifdef|#
directive|ifdef
name|AVOID_CCMODE_COPIES
name|can_copy
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|)
name|i
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|0
condition|)
name|can_copy
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|can_copy
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns whether the mode supports reg/reg copy operations.  */
end_comment

begin_function
name|bool
name|can_copy_p
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
specifier|static
name|bool
name|can_copy_init_p
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|can_copy_init_p
condition|)
block|{
name|compute_can_copy
argument_list|()
expr_stmt|;
name|can_copy_init_p
operator|=
name|true
expr_stmt|;
block|}
return|return
name|can_copy
index|[
name|mode
index|]
operator|!=
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cover function to xmalloc to record bytes allocated.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|gmalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|bytes_used
operator|+=
name|size
expr_stmt|;
return|return
name|xmalloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cover function to xcalloc to record bytes allocated.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|gcalloc
parameter_list|(
name|size_t
name|nelem
parameter_list|,
name|size_t
name|elsize
parameter_list|)
block|{
name|bytes_used
operator|+=
name|nelem
operator|*
name|elsize
expr_stmt|;
return|return
name|xcalloc
argument_list|(
name|nelem
argument_list|,
name|elsize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cover function to xrealloc.    We don't record the additional size since we don't know it.    It won't affect memory usage stats much anyway.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|grealloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
name|xrealloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cover function to obstack_alloc.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|gcse_alloc
parameter_list|(
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|bytes_used
operator|+=
name|size
expr_stmt|;
return|return
name|obstack_alloc
argument_list|(
operator|&
name|gcse_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate memory for the cuid mapping array,    and reg/memory set tracking tables.     This is called at the start of each pass.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_gcse_mem
parameter_list|(
name|rtx
name|f
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Find the largest UID and create a mapping from UIDs to CUIDs.      CUIDs are like UIDs except they increase monotonically, have no gaps,      and only apply to real insns.  */
name|max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|uid_cuid
operator|=
name|gcalloc
argument_list|(
name|max_uid
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|uid_cuid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
operator|++
expr_stmt|;
else|else
name|uid_cuid
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* Create a table mapping cuids to insns.  */
name|max_cuid
operator|=
name|i
expr_stmt|;
name|cuid_insn
operator|=
name|gcalloc
argument_list|(
name|max_cuid
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|CUID_INSN
argument_list|(
name|i
operator|++
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* Allocate vars to track sets of regs.  */
name|reg_set_bitmap
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
comment|/* Allocate vars to track sets of regs, memory per block.  */
name|reg_set_in_block
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|max_gcse_regno
argument_list|)
expr_stmt|;
comment|/* Allocate array to keep a list of insns which modify memory in each      basic block.  */
name|modify_mem_list
operator|=
name|gcalloc
argument_list|(
name|last_basic_block
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|canon_modify_mem_list
operator|=
name|gcalloc
argument_list|(
name|last_basic_block
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|modify_mem_list_set
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
name|canon_modify_mem_list_set
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free memory allocated by alloc_gcse_mem.  */
end_comment

begin_function
specifier|static
name|void
name|free_gcse_mem
parameter_list|(
name|void
parameter_list|)
block|{
name|free
argument_list|(
name|uid_cuid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cuid_insn
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|reg_set_bitmap
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|reg_set_in_block
argument_list|)
expr_stmt|;
name|free_modify_mem_tables
argument_list|()
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|modify_mem_list_set
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|canon_modify_mem_list_set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Many of the global optimization algorithms work by solving dataflow    equations for various expressions.  Initially, some local value is    computed for each expression in each block.  Then, the values across the    various blocks are combined (by following flow graph edges) to arrive at    global values.  Conceptually, each set of equations is independent.  We    may therefore solve all the equations in parallel, solve them one at a    time, or pick any intermediate approach.     When you're going to need N two-dimensional bitmaps, each X (say, the    number of blocks) by Y (say, the number of expressions), call this    function.  It's not important what X and Y represent; only that Y    correspond to the things that can be done in parallel.  This function will    return an appropriate chunking factor C; you should solve C sets of    equations in parallel.  By going through this function, we can easily    trade space against time; by solving fewer equations in parallel we use    less space.  */
end_comment

begin_function
specifier|static
name|int
name|get_bitmap_width
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
comment|/* It's not really worth figuring out *exactly* how much memory will      be used by a particular choice.  The important thing is to get      something approximately right.  */
name|size_t
name|max_bitmap_memory
init|=
literal|10
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
comment|/* The number of bytes we'd use for a single column of minimum      width.  */
name|size_t
name|column_size
init|=
name|n
operator|*
name|x
operator|*
sizeof|sizeof
argument_list|(
name|SBITMAP_ELT_TYPE
argument_list|)
decl_stmt|;
comment|/* Often, it's reasonable just to solve all the equations in      parallel.  */
if|if
condition|(
name|column_size
operator|*
name|SBITMAP_SET_SIZE
argument_list|(
name|y
argument_list|)
operator|<=
name|max_bitmap_memory
condition|)
return|return
name|y
return|;
comment|/* Otherwise, pick the largest width we can, without going over the      limit.  */
return|return
name|SBITMAP_ELT_BITS
operator|*
operator|(
operator|(
name|max_bitmap_memory
operator|+
name|column_size
operator|-
literal|1
operator|)
operator|/
name|column_size
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the local properties of each recorded expression.     Local properties are those that are defined by the block, irrespective of    other blocks.     An expression is transparent in a block if its operands are not modified    in the block.     An expression is computed (locally available) in a block if it is computed    at least once and expression would contain the same value if the    computation was moved to the end of the block.     An expression is locally anticipatable in a block if it is computed at    least once and expression would contain the same value if the computation    was moved to the beginning of the block.     We call this routine for cprop, pre and code hoisting.  They all compute    basically the same information and thus can easily share this code.     TRANSP, COMP, and ANTLOC are destination sbitmaps for recording local    properties.  If NULL, then it is not necessary to compute or record that    particular property.     TABLE controls which hash table to look at.  If it is  set hash table,    additionally, TRANSP is computed as ~TRANSP, since this is really cprop's    ABSALTERED.  */
end_comment

begin_function
specifier|static
name|void
name|compute_local_properties
parameter_list|(
name|sbitmap
modifier|*
name|transp
parameter_list|,
name|sbitmap
modifier|*
name|comp
parameter_list|,
name|sbitmap
modifier|*
name|antloc
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Initialize any bitmaps that were passed in.  */
if|if
condition|(
name|transp
condition|)
block|{
if|if
condition|(
name|table
operator|->
name|set_p
condition|)
name|sbitmap_vector_zero
argument_list|(
name|transp
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
else|else
name|sbitmap_vector_ones
argument_list|(
name|transp
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
condition|)
name|sbitmap_vector_zero
argument_list|(
name|comp
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|antloc
condition|)
name|sbitmap_vector_zero
argument_list|(
name|antloc
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
for|for
control|(
name|expr
operator|=
name|table
operator|->
name|table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
name|int
name|indx
init|=
name|expr
operator|->
name|bitmap_index
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
comment|/* The expression is transparent in this block if it is not killed. 	     We start by assuming all are transparent [none are killed], and 	     then reset the bits for those that are.  */
if|if
condition|(
name|transp
condition|)
name|compute_transp
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|indx
argument_list|,
name|transp
argument_list|,
name|table
operator|->
name|set_p
argument_list|)
expr_stmt|;
comment|/* The occurrences recorded in antic_occr are exactly those that 	     we want to set to nonzero in ANTLOC.  */
if|if
condition|(
name|antloc
condition|)
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
name|SET_BIT
argument_list|(
name|antloc
index|[
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* While we're scanning the table, this is a good place to 		   initialize this.  */
name|occr
operator|->
name|deleted_p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The occurrences recorded in avail_occr are exactly those that 	     we want to set to nonzero in COMP.  */
if|if
condition|(
name|comp
condition|)
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
name|SET_BIT
argument_list|(
name|comp
index|[
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* While we're scanning the table, this is a good place to 		   initialize this.  */
name|occr
operator|->
name|copied_p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* While we're scanning the table, this is a good place to 	     initialize this.  */
name|expr
operator|->
name|reaching_reg
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register set information.     `reg_set_table' records where each register is set or otherwise    modified.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|reg_set_obstack
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|alloc_reg_set_mem
parameter_list|(
name|int
name|n_regs
parameter_list|)
block|{
name|reg_set_table_size
operator|=
name|n_regs
operator|+
name|REG_SET_TABLE_SLOP
expr_stmt|;
name|reg_set_table
operator|=
name|gcalloc
argument_list|(
name|reg_set_table_size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|reg_set_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_reg_set_mem
parameter_list|(
name|void
parameter_list|)
block|{
name|free
argument_list|(
name|reg_set_table
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|reg_set_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An OLD_INSN that used to set REGNO was replaced by NEW_INSN.    Update the corresponding `reg_set_table' entry accordingly.    We assume that NEW_INSN is not already recorded in reg_set_table[regno].  */
end_comment

begin_function
specifier|static
name|void
name|replace_one_set
parameter_list|(
name|int
name|regno
parameter_list|,
name|rtx
name|old_insn
parameter_list|,
name|rtx
name|new_insn
parameter_list|)
block|{
name|struct
name|reg_set
modifier|*
name|reg_info
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|reg_set_table_size
condition|)
return|return;
for|for
control|(
name|reg_info
operator|=
name|reg_set_table
index|[
name|regno
index|]
init|;
name|reg_info
condition|;
name|reg_info
operator|=
name|reg_info
operator|->
name|next
control|)
if|if
condition|(
name|reg_info
operator|->
name|insn
operator|==
name|old_insn
condition|)
block|{
name|reg_info
operator|->
name|insn
operator|=
name|new_insn
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Record REGNO in the reg_set table.  */
end_comment

begin_function
specifier|static
name|void
name|record_one_set
parameter_list|(
name|int
name|regno
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
comment|/* Allocate a new reg_set element and link it onto the list.  */
name|struct
name|reg_set
modifier|*
name|new_reg_info
decl_stmt|;
comment|/* If the table isn't big enough, enlarge it.  */
if|if
condition|(
name|regno
operator|>=
name|reg_set_table_size
condition|)
block|{
name|int
name|new_size
init|=
name|regno
operator|+
name|REG_SET_TABLE_SLOP
decl_stmt|;
name|reg_set_table
operator|=
name|grealloc
argument_list|(
name|reg_set_table
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|reg_set_table
operator|+
name|reg_set_table_size
argument_list|,
literal|0
argument_list|,
operator|(
name|new_size
operator|-
name|reg_set_table_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|reg_set_table_size
operator|=
name|new_size
expr_stmt|;
block|}
name|new_reg_info
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|reg_set_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
argument_list|)
expr_stmt|;
name|new_reg_info
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|new_reg_info
operator|->
name|next
operator|=
name|reg_set_table
index|[
name|regno
index|]
expr_stmt|;
name|reg_set_table
index|[
name|regno
index|]
operator|=
name|new_reg_info
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from compute_sets via note_stores to handle one SET or CLOBBER in    an insn.  The DATA is really the instruction in which the SET is    occurring.  */
end_comment

begin_function
specifier|static
name|void
name|record_set_info
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|record_set_insn
init|=
operator|(
name|rtx
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|record_one_set
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|,
name|record_set_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the function and record each set of each pseudo-register.     This is called once, at the start of the gcse pass.  See the comments for    `reg_set_table' for further documentation.  */
end_comment

begin_function
specifier|static
name|void
name|compute_sets
parameter_list|(
name|rtx
name|f
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
operator|!=
literal|0
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_set_info
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hash table support.  */
end_comment

begin_struct
struct|struct
name|reg_avail_info
block|{
name|basic_block
name|last_bb
decl_stmt|;
name|int
name|first_set
decl_stmt|;
name|int
name|last_set
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|reg_avail_info
modifier|*
name|reg_avail_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|basic_block
name|current_bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See whether X, the source of a set, is something we want to consider for    GCSE.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|rtx
name|test_insn
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|want_to_gcse_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|num_clobbers
init|=
literal|0
decl_stmt|;
name|int
name|icode
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|CALL
case|:
case|case
name|CONSTANT_P_RTX
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
comment|/* If this is a valid operand, we are OK.  If it's VOIDmode, we aren't.  */
if|if
condition|(
name|general_operand
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, check if we can make a valid insn from it.  First initialize      our test insn if we haven't already.  */
if|if
condition|(
name|test_insn
operator|==
literal|0
condition|)
block|{
name|test_insn
operator|=
name|make_insn_raw
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|gen_rtx_REG
argument_list|(
name|word_mode
argument_list|,
name|FIRST_PSEUDO_REGISTER
operator|*
literal|2
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|test_insn
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|test_insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now make an insn like the one we would make when GCSE'ing and see if      valid.  */
name|PUT_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|test_insn
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|test_insn
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
return|return
operator|(
operator|(
name|icode
operator|=
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|test_insn
argument_list|)
argument_list|,
name|test_insn
argument_list|,
operator|&
name|num_clobbers
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|num_clobbers
operator|==
literal|0
operator|||
operator|!
name|added_clobbers_hard_reg_p
argument_list|(
name|icode
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the operands of expression X are unchanged from the    start of INSN's basic block up to but not including INSN (if AVAIL_P == 0),    or from INSN to the end of INSN's basic block (if AVAIL_P != 0).  */
end_comment

begin_function
specifier|static
name|int
name|oprs_unchanged_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|avail_p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
block|{
name|struct
name|reg_avail_info
modifier|*
name|info
init|=
operator|&
name|reg_avail_info
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|last_bb
operator|!=
name|current_bb
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|avail_p
condition|)
return|return
name|info
operator|->
name|last_set
operator|<
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
return|;
else|else
return|return
name|info
operator|->
name|first_set
operator|>=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
return|;
block|}
case|case
name|MEM
case|:
if|if
condition|(
name|load_killed_in_block_p
argument_list|(
name|current_bb
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|x
argument_list|,
name|avail_p
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|oprs_unchanged_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|,
name|avail_p
argument_list|)
return|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call needed at this 	     level, change it into iteration.  This function is called enough 	     to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|oprs_unchanged_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|avail_p
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|oprs_unchanged_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|avail_p
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|oprs_unchanged_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|avail_p
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Used for communication between mems_conflict_for_gcse_p and    load_killed_in_block_p.  Nonzero if mems_conflict_for_gcse_p finds a    conflict between two memory references.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gcse_mems_conflict_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used for communication between mems_conflict_for_gcse_p and    load_killed_in_block_p.  A memory reference for a load instruction,    mems_conflict_for_gcse_p will see if a memory store conflicts with    this memory load.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|gcse_mem_operand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DEST is the output of an instruction.  If it is a memory reference, and    possibly conflicts with the load found in gcse_mem_operand, then set    gcse_mems_conflict_p to a nonzero value.  */
end_comment

begin_function
specifier|static
name|void
name|mems_conflict_for_gcse_p
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If DEST is not a MEM, then it will not conflict with the load.  Note      that function calls are assumed to clobber memory, but are handled      elsewhere.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
comment|/* If we are setting a MEM in our list of specially recognized MEMs,      don't mark as killed this time.  */
if|if
condition|(
name|expr_equiv_p
argument_list|(
name|dest
argument_list|,
name|gcse_mem_operand
argument_list|)
operator|&&
name|pre_ldst_mems
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|find_rtx_in_ldst
argument_list|(
name|dest
argument_list|)
condition|)
name|gcse_mems_conflict_p
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|true_dependence
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|gcse_mem_operand
argument_list|,
name|rtx_addr_varies_p
argument_list|)
condition|)
name|gcse_mems_conflict_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the expression in X (a memory reference) is killed    in block BB before or after the insn with the CUID in UID_LIMIT.    AVAIL_P is nonzero for kills after UID_LIMIT, and zero for kills    before UID_LIMIT.     To check the entire block, set UID_LIMIT to max_uid + 1 and    AVAIL_P to 0.  */
end_comment

begin_function
specifier|static
name|int
name|load_killed_in_block_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|uid_limit
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|avail_p
parameter_list|)
block|{
name|rtx
name|list_entry
init|=
name|modify_mem_list
index|[
name|bb
operator|->
name|index
index|]
decl_stmt|;
while|while
condition|(
name|list_entry
condition|)
block|{
name|rtx
name|setter
decl_stmt|;
comment|/* Ignore entries in the list that do not apply.  */
if|if
condition|(
operator|(
name|avail_p
operator|&&
name|INSN_CUID
argument_list|(
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|uid_limit
operator|)
operator|||
operator|(
operator|!
name|avail_p
operator|&&
name|INSN_CUID
argument_list|(
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>
name|uid_limit
operator|)
condition|)
block|{
name|list_entry
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|setter
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If SETTER is a call everything is clobbered.  Note that calls 	 to pure functions are never put on the list, so we need not 	 worry about them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|setter
argument_list|)
operator|==
name|CALL_INSN
condition|)
return|return
literal|1
return|;
comment|/* SETTER must be an INSN of some kind that sets memory.  Call 	 note_stores to examine each hunk of memory that is modified.  	 The note_stores interface is pretty limited, so we have to 	 communicate via global variables.  Yuk.  */
name|gcse_mem_operand
operator|=
name|x
expr_stmt|;
name|gcse_mems_conflict_p
operator|=
literal|0
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|setter
argument_list|)
argument_list|,
name|mems_conflict_for_gcse_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_mems_conflict_p
condition|)
return|return
literal|1
return|;
name|list_entry
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the operands of expression X are unchanged from    the start of INSN's basic block up to but not including INSN.  */
end_comment

begin_function
specifier|static
name|int
name|oprs_anticipatable_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|oprs_unchanged_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the operands of expression X are unchanged from    INSN to the end of INSN's basic block.  */
end_comment

begin_function
specifier|static
name|int
name|oprs_available_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
return|return
name|oprs_unchanged_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hash expression X.     MODE is only used if X is a CONST_INT.  DO_NOT_RECORD_P is a boolean    indicating if a volatile operand is found or if the expression contains    something we don't want to insert in the table.  HASH_TABLE_SIZE is    the current size of the hash table to be probed.     ??? One might want to merge this with canon_hash.  Later.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_expr
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
modifier|*
name|do_not_record_p
parameter_list|,
name|int
name|hash_table_size
parameter_list|)
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
operator|*
name|do_not_record_p
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|hash_expr_1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|do_not_record_p
argument_list|)
expr_stmt|;
return|return
name|hash
operator|%
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Hash a string.  Just add its bytes up.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|hash_string_1
parameter_list|(
specifier|const
name|char
modifier|*
name|ps
parameter_list|)
block|{
name|unsigned
name|hash
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|ps
decl_stmt|;
if|if
condition|(
name|p
condition|)
while|while
condition|(
operator|*
name|p
condition|)
name|hash
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of hash_expr to do the actual work.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_expr_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
modifier|*
name|do_not_record_p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|hash
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Used to turn recursion into iteration.  We can't rely on GCC's      tail-recursion elimination since we need to keep accumulating values      in HASH.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|hash
return|;
name|repeat
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
name|hash
operator|+=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|REG
operator|<<
literal|7
operator|)
operator|+
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|CONST_INT
case|:
name|hash
operator|+=
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|CONST_INT
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
name|int
operator|)
name|mode
operator|+
operator|(
name|unsigned
name|int
operator|)
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|CONST_DOUBLE
case|:
comment|/* This is like the general case, except that it only counts 	 the integers representing the constant.  */
name|hash
operator|+=
operator|(
name|unsigned
name|int
operator|)
name|code
operator|+
operator|(
name|unsigned
name|int
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|CONST_DOUBLE
argument_list|)
condition|;
name|i
operator|++
control|)
name|hash
operator|+=
operator|(
name|unsigned
name|int
operator|)
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|hash
operator|+=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|unsigned
name|int
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|CONST_VECTOR
case|:
block|{
name|int
name|units
decl_stmt|;
name|rtx
name|elt
decl_stmt|;
name|units
operator|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|units
condition|;
operator|++
name|i
control|)
block|{
name|elt
operator|=
name|CONST_VECTOR_ELT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|hash
operator|+=
name|hash_expr_1
argument_list|(
name|elt
argument_list|,
name|GET_MODE
argument_list|(
name|elt
argument_list|)
argument_list|,
name|do_not_record_p
argument_list|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
comment|/* Assume there is only one rtx object for any given label.  */
case|case
name|LABEL_REF
case|:
comment|/* We don't hash on the address of the CODE_LABEL to avoid bootstrap 	 differences and differences between each stage's debugging dumps.  */
name|hash
operator|+=
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|LABEL_REF
operator|<<
literal|7
operator|)
operator|+
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|SYMBOL_REF
case|:
block|{
comment|/* Don't hash on the symbol's address to avoid bootstrap differences. 	   Different hash values may cause expressions to be recorded in 	   different orders and thus different registers to be used in the 	   final assembler.  This also avoids differences in the dump files 	   between various stages.  */
name|unsigned
name|int
name|h
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|h
operator|+=
operator|(
name|h
operator|<<
literal|7
operator|)
operator|+
operator|*
name|p
operator|++
expr_stmt|;
comment|/* ??? revisit */
name|hash
operator|+=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|SYMBOL_REF
operator|<<
literal|7
operator|)
operator|+
name|h
expr_stmt|;
return|return
name|hash
return|;
block|}
case|case
name|MEM
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|do_not_record_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hash
operator|+=
operator|(
name|unsigned
name|int
operator|)
name|MEM
expr_stmt|;
comment|/* We used alias set for hashing, but this is not good, since the alias 	 set may differ in -fprofile-arcs and -fbranch-probabilities compilation 	 causing the profiles to fail to match.  */
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
operator|*
name|do_not_record_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|do_not_record_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* We don't want to take the filename and line into account.  */
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|+
name|hash_string_1
argument_list|(
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
name|hash_string_1
argument_list|(
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|+=
operator|(
name|hash_expr_1
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|do_not_record_p
argument_list|)
operator|+
name|hash_string_1
argument_list|(
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|hash
operator|+=
name|hash_string_1
argument_list|(
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
return|return
name|hash
return|;
block|}
default|default:
break|break;
block|}
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|hash
operator|+=
name|hash_expr_1
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|do_not_record_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|do_not_record_p
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|hash
operator|+=
name|hash_expr_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
name|do_not_record_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|do_not_record_p
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
name|hash
operator|+=
name|hash_string_1
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
name|hash
operator|+=
operator|(
name|unsigned
name|int
operator|)
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Hash a set of register REGNO.     Sets are hashed on the register that is set.  This simplifies the PRE copy    propagation code.     ??? May need to make things more elaborate.  Later, as necessary.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_set
parameter_list|(
name|int
name|regno
parameter_list|,
name|int
name|hash_table_size
parameter_list|)
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
name|hash
operator|=
name|regno
expr_stmt|;
return|return
name|hash
operator|%
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if exp1 is equivalent to exp2.    ??? Borrowed from cse.c.  Might want to remerge with cse.c.  Later.  */
end_comment

begin_function
specifier|static
name|int
name|expr_equiv_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|y
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST_INT
case|:
return|return
literal|0
return|;
case|case
name|LABEL_REF
case|:
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|REG
case|:
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
return|;
case|case
name|MEM
case|:
comment|/* Can't merge two expressions in different alias sets, since we can 	 decide that the expression is transparent in a block when it isn't, 	 due to it being set with the different alias set.  */
if|if
condition|(
name|MEM_ALIAS_SET
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM_ALIAS_SET
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* A volatile mem should not be considered equivalent to any other.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
comment|/*  For commutative operations, check both orders.  */
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
return|return
operator|(
operator|(
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
return|;
case|case
name|ASM_OPERANDS
case|:
comment|/* We don't use the generic code below because we want to 	 disregard filename and line numbers.  */
comment|/* A volatile asm isn't equivalent to any other.  */
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
operator|||
name|strcmp
argument_list|(
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_TEMPLATE
argument_list|(
name|y
argument_list|)
argument_list|)
operator|||
name|strcmp
argument_list|(
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|x
argument_list|)
argument_list|,
name|ASM_OPERANDS_OUTPUT_CONSTRAINT
argument_list|(
name|y
argument_list|)
argument_list|)
operator|||
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|x
argument_list|)
operator|!=
name|ASM_OPERANDS_OUTPUT_IDX
argument_list|(
name|y
argument_list|)
operator|||
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|!=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|expr_equiv_p
argument_list|(
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
operator|||
name|strcmp
argument_list|(
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|ASM_OPERANDS_INPUT_CONSTRAINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
default|default:
break|break;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole thing.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|expr_equiv_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'0'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Insert expression X in INSN in the hash TABLE.    If it is already present, record it as the last occurrence in INSN's    basic block.     MODE is the mode of the value X is being stored into.    It is only used if X is a CONST_INT.     ANTIC_P is nonzero if X is an anticipatable expression.    AVAIL_P is nonzero if X is an available expression.  */
end_comment

begin_function
specifier|static
name|void
name|insert_expr_in_table
parameter_list|(
name|rtx
name|x
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|antic_p
parameter_list|,
name|int
name|avail_p
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|int
name|found
decl_stmt|,
name|do_not_record_p
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|struct
name|expr
modifier|*
name|cur_expr
decl_stmt|,
modifier|*
name|last_expr
init|=
name|NULL
decl_stmt|;
name|struct
name|occr
modifier|*
name|antic_occr
decl_stmt|,
modifier|*
name|avail_occr
decl_stmt|;
name|struct
name|occr
modifier|*
name|last_occr
init|=
name|NULL
decl_stmt|;
name|hash
operator|=
name|hash_expr
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
operator|&
name|do_not_record_p
argument_list|,
name|table
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* Do not insert expression in table if it contains volatile operands,      or if hash_expr determines the expression is something we don't want      to or can't handle.  */
if|if
condition|(
name|do_not_record_p
condition|)
return|return;
name|cur_expr
operator|=
name|table
operator|->
name|table
index|[
name|hash
index|]
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cur_expr
operator|&&
literal|0
operator|==
operator|(
name|found
operator|=
name|expr_equiv_p
argument_list|(
name|cur_expr
operator|->
name|expr
argument_list|,
name|x
argument_list|)
operator|)
condition|)
block|{
comment|/* If the expression isn't found, save a pointer to the end of 	 the list.  */
name|last_expr
operator|=
name|cur_expr
expr_stmt|;
name|cur_expr
operator|=
name|cur_expr
operator|->
name|next_same_hash
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|cur_expr
operator|=
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|table
index|[
name|hash
index|]
operator|==
name|NULL
condition|)
comment|/* This is the first pattern that hashed to this index.  */
name|table
operator|->
name|table
index|[
name|hash
index|]
operator|=
name|cur_expr
expr_stmt|;
else|else
comment|/* Add EXPR to end of this hash chain.  */
name|last_expr
operator|->
name|next_same_hash
operator|=
name|cur_expr
expr_stmt|;
comment|/* Set the fields of the expr element.  */
name|cur_expr
operator|->
name|expr
operator|=
name|x
expr_stmt|;
name|cur_expr
operator|->
name|bitmap_index
operator|=
name|table
operator|->
name|n_elems
operator|++
expr_stmt|;
name|cur_expr
operator|->
name|next_same_hash
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|antic_occr
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|avail_occr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now record the occurrence(s).  */
if|if
condition|(
name|antic_p
condition|)
block|{
name|antic_occr
operator|=
name|cur_expr
operator|->
name|antic_occr
expr_stmt|;
comment|/* Search for another occurrence in the same basic block.  */
while|while
condition|(
name|antic_occr
operator|&&
name|BLOCK_NUM
argument_list|(
name|antic_occr
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If an occurrence isn't found, save a pointer to the end of 	     the list.  */
name|last_occr
operator|=
name|antic_occr
expr_stmt|;
name|antic_occr
operator|=
name|antic_occr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|antic_occr
condition|)
comment|/* Found another instance of the expression in the same basic block. 	   Prefer the currently recorded one.  We want the first one in the 	   block and the block is scanned from start to end.  */
empty_stmt|;
comment|/* nothing to do */
else|else
block|{
comment|/* First occurrence of this expression in this basic block.  */
name|antic_occr
operator|=
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
expr_stmt|;
comment|/* First occurrence of this expression in any block?  */
if|if
condition|(
name|cur_expr
operator|->
name|antic_occr
operator|==
name|NULL
condition|)
name|cur_expr
operator|->
name|antic_occr
operator|=
name|antic_occr
expr_stmt|;
else|else
name|last_occr
operator|->
name|next
operator|=
name|antic_occr
expr_stmt|;
name|antic_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|antic_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|avail_p
condition|)
block|{
name|avail_occr
operator|=
name|cur_expr
operator|->
name|avail_occr
expr_stmt|;
comment|/* Search for another occurrence in the same basic block.  */
while|while
condition|(
name|avail_occr
operator|&&
name|BLOCK_NUM
argument_list|(
name|avail_occr
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If an occurrence isn't found, save a pointer to the end of 	     the list.  */
name|last_occr
operator|=
name|avail_occr
expr_stmt|;
name|avail_occr
operator|=
name|avail_occr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|avail_occr
condition|)
comment|/* Found another instance of the expression in the same basic block. 	   Prefer this occurrence to the currently recorded one.  We want 	   the last one in the block and the block is scanned from start 	   to end.  */
name|avail_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
comment|/* First occurrence of this expression in this basic block.  */
name|avail_occr
operator|=
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
expr_stmt|;
comment|/* First occurrence of this expression in any block?  */
if|if
condition|(
name|cur_expr
operator|->
name|avail_occr
operator|==
name|NULL
condition|)
name|cur_expr
operator|->
name|avail_occr
operator|=
name|avail_occr
expr_stmt|;
else|else
name|last_occr
operator|->
name|next
operator|=
name|avail_occr
expr_stmt|;
name|avail_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|avail_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Insert pattern X in INSN in the hash table.    X is a SET of a reg to either another reg or a constant.    If it is already present, record it as the last occurrence in INSN's    basic block.  */
end_comment

begin_function
specifier|static
name|void
name|insert_set_in_table
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|int
name|found
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|struct
name|expr
modifier|*
name|cur_expr
decl_stmt|,
modifier|*
name|last_expr
init|=
name|NULL
decl_stmt|;
name|struct
name|occr
modifier|*
name|cur_occr
decl_stmt|,
modifier|*
name|last_occr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|hash
operator|=
name|hash_set
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|table
operator|->
name|size
argument_list|)
expr_stmt|;
name|cur_expr
operator|=
name|table
operator|->
name|table
index|[
name|hash
index|]
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cur_expr
operator|&&
literal|0
operator|==
operator|(
name|found
operator|=
name|expr_equiv_p
argument_list|(
name|cur_expr
operator|->
name|expr
argument_list|,
name|x
argument_list|)
operator|)
condition|)
block|{
comment|/* If the expression isn't found, save a pointer to the end of 	 the list.  */
name|last_expr
operator|=
name|cur_expr
expr_stmt|;
name|cur_expr
operator|=
name|cur_expr
operator|->
name|next_same_hash
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|cur_expr
operator|=
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|table
index|[
name|hash
index|]
operator|==
name|NULL
condition|)
comment|/* This is the first pattern that hashed to this index.  */
name|table
operator|->
name|table
index|[
name|hash
index|]
operator|=
name|cur_expr
expr_stmt|;
else|else
comment|/* Add EXPR to end of this hash chain.  */
name|last_expr
operator|->
name|next_same_hash
operator|=
name|cur_expr
expr_stmt|;
comment|/* Set the fields of the expr element. 	 We must copy X because it can be modified when copy propagation is 	 performed on its operands.  */
name|cur_expr
operator|->
name|expr
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|cur_expr
operator|->
name|bitmap_index
operator|=
name|table
operator|->
name|n_elems
operator|++
expr_stmt|;
name|cur_expr
operator|->
name|next_same_hash
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|antic_occr
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|avail_occr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now record the occurrence.  */
name|cur_occr
operator|=
name|cur_expr
operator|->
name|avail_occr
expr_stmt|;
comment|/* Search for another occurrence in the same basic block.  */
while|while
condition|(
name|cur_occr
operator|&&
name|BLOCK_NUM
argument_list|(
name|cur_occr
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If an occurrence isn't found, save a pointer to the end of 	 the list.  */
name|last_occr
operator|=
name|cur_occr
expr_stmt|;
name|cur_occr
operator|=
name|cur_occr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|cur_occr
condition|)
comment|/* Found another instance of the expression in the same basic block.        Prefer this occurrence to the currently recorded one.  We want the        last one in the block and the block is scanned from start to end.  */
name|cur_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
else|else
block|{
comment|/* First occurrence of this expression in this basic block.  */
name|cur_occr
operator|=
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
expr_stmt|;
comment|/* First occurrence of this expression in any block?  */
if|if
condition|(
name|cur_expr
operator|->
name|avail_occr
operator|==
name|NULL
condition|)
name|cur_expr
operator|->
name|avail_occr
operator|=
name|cur_occr
expr_stmt|;
else|else
name|last_occr
operator|->
name|next
operator|=
name|cur_occr
expr_stmt|;
name|cur_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|cur_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine whether the rtx X should be treated as a constant for    the purposes of GCSE's constant propagation.  */
end_comment

begin_function
specifier|static
name|bool
name|gcse_constant_p
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
comment|/* Consider a COMPARE of two integers constant.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COMPARE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
name|true
return|;
comment|/* Consider a COMPARE of the same registers is a constant     if they are not floating point registers.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COMPARE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|&&
operator|!
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONSTANT_P_RTX
condition|)
return|return
name|false
return|;
return|return
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Scan pattern PAT of INSN and add an entry to the hash TABLE (set or    expression one).  */
end_comment

begin_function
specifier|static
name|void
name|hash_scan_set
parameter_list|(
name|rtx
name|pat
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CALL
condition|)
name|hash_scan_call
argument_list|(
name|src
argument_list|,
name|insn
argument_list|,
name|table
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* If this is a single set and we are doing constant propagation, 	 see if a REG_NOTE shows this equivalent to a constant.  */
if|if
condition|(
name|table
operator|->
name|set_p
operator|&&
operator|(
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|gcse_constant_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|src
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|,
name|pat
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* Only record sets of pseudo-regs in the hash table.  */
if|if
condition|(
operator|!
name|table
operator|->
name|set_p
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
comment|/* Don't GCSE something if we can't do a reg/reg copy.  */
operator|&&
name|can_copy_p
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
comment|/* GCSE commonly inserts instruction after the insn.  We can't 	     do that easily for EH_REGION notes so disable GCSE on these 	     for now.  */
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
comment|/* Is SET_SRC something we want to gcse?  */
operator|&&
name|want_to_gcse_p
argument_list|(
name|src
argument_list|)
comment|/* Don't CSE a nop.  */
operator|&&
operator|!
name|set_noop_p
argument_list|(
name|pat
argument_list|)
comment|/* Don't GCSE if it has attached REG_EQUIV note. 	     At this point this only function parameters should have 	     REG_EQUIV notes and if the argument slot is used somewhere 	     explicitly, it means address of parameter has been taken, 	     so we should not extend the lifetime of the pseudo.  */
operator|&&
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|)
condition|)
block|{
comment|/* An expression is not anticipatable if its operands are 	     modified before this insn or if this is not the only SET in 	     this insn.  */
name|int
name|antic_p
init|=
name|oprs_anticipatable_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
operator|&&
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* An expression is not available if its operands are 	     subsequently modified, including this insn.  It's also not 	     available if this is a branch, because we can't insert 	     a set after the branch.  */
name|int
name|avail_p
init|=
operator|(
name|oprs_available_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
operator|&&
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
operator|)
decl_stmt|;
name|insert_expr_in_table
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|insn
argument_list|,
name|antic_p
argument_list|,
name|avail_p
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
comment|/* Record sets for constant/copy propagation.  */
elseif|else
if|if
condition|(
name|table
operator|->
name|set_p
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|can_copy_p
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|!=
name|regno
operator|)
operator|||
name|gcse_constant_p
argument_list|(
name|src
argument_list|)
operator|)
comment|/* A copy is not available if its src or dest is subsequently 		  modified.  Here we want to search from INSN+1 on, but 		  oprs_available_p searches from INSN on.  */
operator|&&
operator|(
name|insn
operator|==
name|BB_END
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|tmp
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|oprs_available_p
argument_list|(
name|pat
argument_list|,
name|tmp
argument_list|)
operator|)
operator|)
condition|)
name|insert_set_in_table
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
comment|/* In case of store we want to consider the memory value as available in      the REG stored in that memory. This makes it possible to remove      redundant loads from due to stores to the same location.  */
elseif|else
if|if
condition|(
name|flag_gcse_las
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|src
argument_list|)
decl_stmt|;
comment|/* Do not do this for constant/copy propagation.  */
if|if
condition|(
operator|!
name|table
operator|->
name|set_p
comment|/* Only record sets of pseudo-regs in the hash table.  */
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
comment|/* Don't GCSE something if we can't do a reg/reg copy.  */
operator|&&
name|can_copy_p
argument_list|(
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
comment|/* GCSE commonly inserts instruction after the insn.  We can't 	      do that easily for EH_REGION notes so disable GCSE on these 	      for now.  */
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
comment|/* Is SET_DEST something we want to gcse?  */
operator|&&
name|want_to_gcse_p
argument_list|(
name|dest
argument_list|)
comment|/* Don't CSE a nop.  */
operator|&&
operator|!
name|set_noop_p
argument_list|(
name|pat
argument_list|)
comment|/* Don't GCSE if it has attached REG_EQUIV note. 	      At this point this only function parameters should have 	      REG_EQUIV notes and if the argument slot is used somewhere 	      explicitly, it means address of parameter has been taken, 	      so we should not extend the lifetime of the pseudo.  */
operator|&&
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|)
condition|)
block|{
comment|/* Stores are never anticipatable.  */
name|int
name|antic_p
init|=
literal|0
decl_stmt|;
comment|/* An expression is not available if its operands are 	          subsequently modified, including this insn.  It's also not 	          available if this is a branch, because we can't insert 	          a set after the branch.  */
name|int
name|avail_p
init|=
name|oprs_available_p
argument_list|(
name|dest
argument_list|,
name|insn
argument_list|)
operator|&&
operator|!
name|JUMP_P
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Record the memory expression (DEST) in the hash table.  */
name|insert_expr_in_table
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|insn
argument_list|,
name|antic_p
argument_list|,
name|avail_p
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hash_scan_clobber
parameter_list|(
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Currently nothing to do.  */
block|}
end_function

begin_function
specifier|static
name|void
name|hash_scan_call
parameter_list|(
name|rtx
name|x
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|insn
name|ATTRIBUTE_UNUSED
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Currently nothing to do.  */
block|}
end_function

begin_comment
comment|/* Process INSN and add hash table entries as appropriate.     Only available expressions that set a single pseudo-reg are recorded.     Single sets in a PARALLEL could be handled, but it's an extra complication    that isn't dealt with right now.  The trick is handling the CLOBBERs that    are also in the PARALLEL.  Later.     If SET_P is nonzero, this is for the assignment hash table,    otherwise it is for the expression hash table.    If IN_LIBCALL_BLOCK nonzero, we are in a libcall block, and should    not record any expressions.  */
end_comment

begin_function
specifier|static
name|void
name|hash_scan_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
parameter_list|,
name|int
name|in_libcall_block
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|in_libcall_block
condition|)
return|return;
comment|/* Pick out the sets of INSN and for other forms of instructions record      what's been modified.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
name|hash_scan_set
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
name|table
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|hash_scan_set
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|table
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
name|hash_scan_clobber
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|table
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
name|hash_scan_call
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
name|hash_scan_clobber
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
name|table
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL
condition|)
name|hash_scan_call
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_hash_table
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Flattened out table, so it's printed in proper order.  */
name|struct
name|expr
modifier|*
modifier|*
name|flat_table
decl_stmt|;
name|unsigned
name|int
modifier|*
name|hash_val
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|flat_table
operator|=
name|xcalloc
argument_list|(
name|table
operator|->
name|n_elems
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|hash_val
operator|=
name|xmalloc
argument_list|(
name|table
operator|->
name|n_elems
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|table
operator|->
name|size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|table
operator|->
name|table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
name|flat_table
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|expr
expr_stmt|;
name|hash_val
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|i
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s hash table (%d buckets, %d entries)\n"
argument_list|,
name|name
argument_list|,
name|table
operator|->
name|size
argument_list|,
name|table
operator|->
name|n_elems
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|table
operator|->
name|n_elems
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flat_table
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|expr
operator|=
name|flat_table
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Index %d (hash value %d)\n  "
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|,
name|hash_val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|expr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|flat_table
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hash_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record register first/last/block set information for REGNO in INSN.     first_set records the first place in the block where the register    is set and is used to compute "anticipatability".     last_set records the last place in the block where the register    is set and is used to compute "availability".     last_bb records the block for which first_set and last_set are    valid, as a quick test to invalidate them.     reg_set_in_block records whether the register is set in the block    and is used to compute "transparency".  */
end_comment

begin_function
specifier|static
name|void
name|record_last_reg_set_info
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|struct
name|reg_avail_info
modifier|*
name|info
init|=
operator|&
name|reg_avail_info
index|[
name|regno
index|]
decl_stmt|;
name|int
name|cuid
init|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|info
operator|->
name|last_set
operator|=
name|cuid
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|last_bb
operator|!=
name|current_bb
condition|)
block|{
name|info
operator|->
name|last_bb
operator|=
name|current_bb
expr_stmt|;
name|info
operator|->
name|first_set
operator|=
name|cuid
expr_stmt|;
name|SET_BIT
argument_list|(
name|reg_set_in_block
index|[
name|current_bb
operator|->
name|index
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record all of the canonicalized MEMs of record_last_mem_set_info's insn.    Note we store a pair of elements in the list, so they have to be    taken off pairwise.  */
end_comment

begin_function
specifier|static
name|void
name|canon_list_insert
parameter_list|(
name|rtx
name|dest
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|unused1
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|v_insn
parameter_list|)
block|{
name|rtx
name|dest_addr
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|bb
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If DEST is not a MEM, then it will not conflict with a load.  Note      that function calls are assumed to clobber memory, but are handled      elsewhere.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|MEM
condition|)
return|return;
name|dest_addr
operator|=
name|get_addr
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|canon_rtx
argument_list|(
name|dest_addr
argument_list|)
expr_stmt|;
name|insn
operator|=
operator|(
name|rtx
operator|)
name|v_insn
expr_stmt|;
name|bb
operator|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|canon_modify_mem_list
index|[
name|bb
index|]
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|dest_addr
argument_list|,
name|canon_modify_mem_list
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|canon_modify_mem_list
index|[
name|bb
index|]
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|dest
argument_list|,
name|canon_modify_mem_list
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|canon_modify_mem_list_set
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record memory modification information for INSN.  We do not actually care    about the memory location(s) that are set, or even how they are set (consider    a CALL_INSN).  We merely need to record which insns modify memory.  */
end_comment

begin_function
specifier|static
name|void
name|record_last_mem_set_info
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|bb
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* load_killed_in_block_p will handle the case of calls clobbering      everything.  */
name|modify_mem_list
index|[
name|bb
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|modify_mem_list
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|modify_mem_list_set
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* Note that traversals of this loop (other than for free-ing) 	 will break after encountering a CALL_INSN.  So, there's no 	 need to insert a pair of items, as canon_list_insert does.  */
name|canon_modify_mem_list
index|[
name|bb
index|]
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|canon_modify_mem_list
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|canon_modify_mem_list_set
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
else|else
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|canon_list_insert
argument_list|,
operator|(
name|void
operator|*
operator|)
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called from compute_hash_table via note_stores to handle one    SET or CLOBBER in an insn.  DATA is really the instruction in which    the SET is taking place.  */
end_comment

begin_function
specifier|static
name|void
name|record_last_set_info
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|last_set_insn
init|=
operator|(
name|rtx
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|record_last_reg_set_info
argument_list|(
name|last_set_insn
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
comment|/* Ignore pushes, they clobber nothing.  */
operator|&&
operator|!
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
name|record_last_mem_set_info
argument_list|(
name|last_set_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level function to create an expression or assignment hash table.     Expression entries are placed in the hash table if    - they are of the form (set (pseudo-reg) src),    - src is something we want to perform GCSE on,    - none of the operands are subsequently modified in the block     Assignment entries are placed in the hash table if    - they are of the form (set (pseudo-reg) src),    - src is something we want to perform const/copy propagation on,    - none of the operands or target are subsequently modified in the block     Currently src must be a pseudo-reg or a const_int.     TABLE is the table computed.  */
end_comment

begin_function
specifier|static
name|void
name|compute_hash_table_work
parameter_list|(
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* While we compute the hash table we also compute a bit array of which      registers are set in which blocks.      ??? This isn't needed during const/copy propagation, but it's cheap to      compute.  Later.  */
name|sbitmap_vector_zero
argument_list|(
name|reg_set_in_block
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* re-Cache any INSN_LIST nodes we have allocated.  */
name|clear_modify_mem_tables
argument_list|()
expr_stmt|;
comment|/* Some working arrays used to track first and last set in each block.  */
name|reg_avail_info
operator|=
name|gmalloc
argument_list|(
name|max_gcse_regno
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_avail_info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_gcse_regno
condition|;
operator|++
name|i
control|)
name|reg_avail_info
index|[
name|i
index|]
operator|.
name|last_bb
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|current_bb
argument_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|in_libcall_block
decl_stmt|;
comment|/* First pass over the instructions records information used to 	 determine when registers and memory are first and last set. 	 ??? hard-reg reg_set_in_block computation 	 could be moved to compute_sets since they currently don't change.  */
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|current_bb
argument_list|)
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|current_bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|bool
name|clobbers_all
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|clobbers_all
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|clobbers_all
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
condition|)
name|record_last_reg_set_info
argument_list|(
name|insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|mark_call
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_last_set_info
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Insert implicit sets in the hash table.  */
if|if
condition|(
name|table
operator|->
name|set_p
operator|&&
name|implicit_sets
index|[
name|current_bb
operator|->
name|index
index|]
operator|!=
name|NULL_RTX
condition|)
name|hash_scan_set
argument_list|(
name|implicit_sets
index|[
name|current_bb
operator|->
name|index
index|]
argument_list|,
name|BB_HEAD
argument_list|(
name|current_bb
argument_list|)
argument_list|,
name|table
argument_list|)
expr_stmt|;
comment|/* The next pass builds the hash table.  */
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|current_bb
argument_list|)
operator|,
name|in_libcall_block
operator|=
literal|0
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|current_bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|table
operator|->
name|set_p
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|0
expr_stmt|;
name|hash_scan_insn
argument_list|(
name|insn
argument_list|,
name|table
argument_list|,
name|in_libcall_block
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|set_p
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|reg_avail_info
argument_list|)
expr_stmt|;
name|reg_avail_info
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate space for the set/expr hash TABLE.    N_INSNS is the number of instructions in the function.    It is used to determine the number of buckets to use.    SET_P determines whether set or expression table will    be created.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_hash_table
parameter_list|(
name|int
name|n_insns
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
parameter_list|,
name|int
name|set_p
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|table
operator|->
name|size
operator|=
name|n_insns
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|size
operator|<
literal|11
condition|)
name|table
operator|->
name|size
operator|=
literal|11
expr_stmt|;
comment|/* Attempt to maintain efficient use of hash table.      Making it an odd number is simplest for now.      ??? Later take some measurements.  */
name|table
operator|->
name|size
operator||=
literal|1
expr_stmt|;
name|n
operator|=
name|table
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
expr_stmt|;
name|table
operator|->
name|table
operator|=
name|gmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|table
operator|->
name|set_p
operator|=
name|set_p
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free things allocated by alloc_hash_table.  */
end_comment

begin_function
specifier|static
name|void
name|free_hash_table
parameter_list|(
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|free
argument_list|(
name|table
operator|->
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the hash TABLE for doing copy/const propagation or    expression hash table.  */
end_comment

begin_function
specifier|static
name|void
name|compute_hash_table
parameter_list|(
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
comment|/* Initialize count of number of entries in hash table.  */
name|table
operator|->
name|n_elems
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|table
operator|->
name|table
argument_list|,
literal|0
argument_list|,
name|table
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|compute_hash_table_work
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expression tracking support.  */
end_comment

begin_comment
comment|/* Lookup pattern PAT in the expression TABLE.    The result is a pointer to the table entry, or NULL if not found.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|lookup_expr
parameter_list|(
name|rtx
name|pat
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|int
name|do_not_record_p
decl_stmt|;
name|unsigned
name|int
name|hash
init|=
name|hash_expr
argument_list|(
name|pat
argument_list|,
name|GET_MODE
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|do_not_record_p
argument_list|,
name|table
operator|->
name|size
argument_list|)
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
if|if
condition|(
name|do_not_record_p
condition|)
return|return
name|NULL
return|;
name|expr
operator|=
name|table
operator|->
name|table
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|expr
operator|&&
operator|!
name|expr_equiv_p
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|pat
argument_list|)
condition|)
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Lookup REGNO in the set TABLE.  The result is a pointer to the    table entry, or NULL if not found.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|lookup_set
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|struct
name|hash_table
modifier|*
name|table
parameter_list|)
block|{
name|unsigned
name|int
name|hash
init|=
name|hash_set
argument_list|(
name|regno
argument_list|,
name|table
operator|->
name|size
argument_list|)
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|expr
operator|=
name|table
operator|->
name|table
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|expr
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
argument_list|)
operator|!=
name|regno
condition|)
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Return the next entry for REGNO in list EXPR.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|next_set
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|,
name|struct
name|expr
modifier|*
name|expr
parameter_list|)
block|{
do|do
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
do|while
condition|(
name|expr
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
argument_list|)
operator|!=
name|regno
condition|)
do|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Like free_INSN_LIST_list or free_EXPR_LIST_list, except that the node    types may be mixed.  */
end_comment

begin_function
specifier|static
name|void
name|free_insn_expr_list_list
parameter_list|(
name|rtx
modifier|*
name|listp
parameter_list|)
block|{
name|rtx
name|list
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|list
operator|=
operator|*
name|listp
init|;
name|list
condition|;
name|list
operator|=
name|next
control|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|list
argument_list|)
operator|==
name|EXPR_LIST
condition|)
name|free_EXPR_LIST_node
argument_list|(
name|list
argument_list|)
expr_stmt|;
else|else
name|free_INSN_LIST_node
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
operator|*
name|listp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear canon_modify_mem_list and modify_mem_list tables.  */
end_comment

begin_function
specifier|static
name|void
name|clear_modify_mem_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
name|modify_mem_list_set
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|free_INSN_LIST_list
argument_list|(
name|modify_mem_list
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|modify_mem_list_set
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
name|canon_modify_mem_list_set
argument_list|,
literal|0
argument_list|,
name|i
argument_list|,
name|free_insn_expr_list_list
argument_list|(
name|canon_modify_mem_list
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|bitmap_clear
argument_list|(
name|canon_modify_mem_list_set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release memory used by modify_mem_list_set and canon_modify_mem_list_set.  */
end_comment

begin_function
specifier|static
name|void
name|free_modify_mem_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|clear_modify_mem_tables
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|modify_mem_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|canon_modify_mem_list
argument_list|)
expr_stmt|;
name|modify_mem_list
operator|=
literal|0
expr_stmt|;
name|canon_modify_mem_list
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset tables used to keep track of what's still available [since the    start of the block].  */
end_comment

begin_function
specifier|static
name|void
name|reset_opr_set_tables
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Maintain a bitmap of which regs have been set since beginning of      the block.  */
name|CLEAR_REG_SET
argument_list|(
name|reg_set_bitmap
argument_list|)
expr_stmt|;
comment|/* Also keep a record of the last instruction to modify memory.      For now this is very trivial, we only record whether any memory      location has been modified.  */
name|clear_modify_mem_tables
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the operands of X are not set before INSN in    INSN's basic block.  */
end_comment

begin_function
specifier|static
name|int
name|oprs_not_set_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|load_killed_in_block_p
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|oprs_not_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
case|case
name|REG
case|:
return|return
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|reg_set_bitmap
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|oprs_not_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
if|if
condition|(
operator|!
name|oprs_not_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|oprs_not_set_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Mark things set by a CALL.  */
end_comment

begin_function
specifier|static
name|void
name|mark_call
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|record_last_mem_set_info
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark things set by a SET.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set
parameter_list|(
name|rtx
name|pat
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_set_bitmap
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|record_last_mem_set_info
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
name|mark_call
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record things set by a CLOBBER.  */
end_comment

begin_function
specifier|static
name|void
name|mark_clobber
parameter_list|(
name|rtx
name|pat
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|clob
init|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|clob
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|clob
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|clob
operator|=
name|XEXP
argument_list|(
name|clob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|clob
argument_list|)
operator|==
name|REG
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|reg_set_bitmap
argument_list|,
name|REGNO
argument_list|(
name|clob
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|record_last_mem_set_info
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record things set by INSN.    This data is used by oprs_not_set_p.  */
end_comment

begin_function
specifier|static
name|void
name|mark_oprs_set
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
name|mark_set
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|mark_set
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_clobber
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
name|mark_call
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_clobber
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL
condition|)
name|mark_call
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Classic GCSE reaching definition support.  */
end_comment

begin_comment
comment|/* Allocate reaching def variables.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_rd_mem
parameter_list|(
name|int
name|n_blocks
parameter_list|,
name|int
name|n_insns
parameter_list|)
block|{
name|rd_kill
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|rd_kill
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|rd_gen
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|rd_gen
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|reaching_defs
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|reaching_defs
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|rd_out
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|rd_out
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free reaching def variables.  */
end_comment

begin_function
specifier|static
name|void
name|free_rd_mem
parameter_list|(
name|void
parameter_list|)
block|{
name|sbitmap_vector_free
argument_list|(
name|rd_kill
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|rd_gen
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|reaching_defs
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|rd_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN to the kills of BB.  REGNO, set in BB, is killed by INSN.  */
end_comment

begin_function
specifier|static
name|void
name|handle_rd_kill_set
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|regno
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|struct
name|reg_set
modifier|*
name|this_reg
decl_stmt|;
for|for
control|(
name|this_reg
operator|=
name|reg_set_table
index|[
name|regno
index|]
init|;
name|this_reg
condition|;
name|this_reg
operator|=
name|this_reg
operator|->
name|next
control|)
if|if
condition|(
name|BLOCK_NUM
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|rd_kill
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|INSN_CUID
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the set of kill's for reaching definitions.  */
end_comment

begin_function
specifier|static
name|void
name|compute_kill_rd
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cuid
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* For each block        For each set bit in `gen' of the block (i.e each insn which 	   generates a definition in the block) 	 Call the reg set by the insn corresponding to that bit regx 	 Look at the linked list starting at reg_set_table[regx] 	 For each setting of regx in the linked list, which is not in 	     this block 	   Set the bit in `kill' corresponding to that insn.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|cuid
operator|=
literal|0
init|;
name|cuid
operator|<
name|max_cuid
condition|;
name|cuid
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|rd_gen
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|cuid
argument_list|)
condition|)
block|{
name|rtx
name|insn
init|=
name|CUID_INSN
argument_list|(
name|cuid
argument_list|)
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
condition|)
name|handle_rd_kill_set
argument_list|(
name|insn
argument_list|,
name|regno
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|handle_rd_kill_set
argument_list|(
name|insn
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
comment|/* Each setting of this register outside of this block 	       must be marked in the set of kills in this block.  */
name|handle_rd_kill_set
argument_list|(
name|insn
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the reaching definitions as in    Compilers Principles, Techniques, and Tools. Aho, Sethi, Ullman,    Chapter 10.  It is the same algorithm as used for computing available    expressions but applied to the gens and kills of reaching definitions.  */
end_comment

begin_function
specifier|static
name|void
name|compute_rd
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
name|sbitmap_copy
argument_list|(
name|rd_out
index|[
name|bb
operator|->
name|index
index|]
comment|/*dst*/
argument_list|,
name|rd_gen
index|[
name|bb
operator|->
name|index
index|]
comment|/*src*/
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|sbitmap_union_of_preds
argument_list|(
name|reaching_defs
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|rd_out
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_union_of_diff_cg
argument_list|(
name|rd_out
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|rd_gen
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|reaching_defs
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|rd_kill
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"reaching def computation: %d passes\n"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Classic GCSE available expression support.  */
end_comment

begin_comment
comment|/* Allocate memory for available expression computation.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_avail_expr_mem
parameter_list|(
name|int
name|n_blocks
parameter_list|,
name|int
name|n_exprs
parameter_list|)
block|{
name|ae_kill
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_kill
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|ae_gen
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_gen
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|ae_in
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_in
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
name|ae_out
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_out
argument_list|,
name|n_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_avail_expr_mem
parameter_list|(
name|void
parameter_list|)
block|{
name|sbitmap_vector_free
argument_list|(
name|ae_kill
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|ae_gen
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|ae_in
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|ae_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the set of available expressions generated in each basic block.  */
end_comment

begin_function
specifier|static
name|void
name|compute_ae_gen
parameter_list|(
name|struct
name|hash_table
modifier|*
name|expr_hash_table
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
comment|/* For each recorded occurrence of each expression, set ae_gen[bb][expr].      This is all we have to do because an expression is not recorded if it      is not available, and the only expressions we want to work with are the      ones that are recorded.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table
operator|->
name|size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
operator|->
name|table
index|[
name|i
index|]
init|;
name|expr
operator|!=
literal|0
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|occr
operator|!=
literal|0
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
name|SET_BIT
argument_list|(
name|ae_gen
index|[
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if expression X is killed in BB.  */
end_comment

begin_function
specifier|static
name|int
name|expr_killed_p
parameter_list|(
name|rtx
name|x
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
return|return
name|TEST_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|load_killed_in_block_p
argument_list|(
name|bb
argument_list|,
name|get_max_uid
argument_list|()
operator|+
literal|1
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
return|return
name|expr_killed_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb
argument_list|)
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
name|expr_killed_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|bb
argument_list|)
return|;
elseif|else
if|if
condition|(
name|expr_killed_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|bb
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|expr_killed_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|bb
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the set of available expressions killed in each basic block.  */
end_comment

begin_function
specifier|static
name|void
name|compute_ae_kill
parameter_list|(
name|sbitmap
modifier|*
name|ae_gen
parameter_list|,
name|sbitmap
modifier|*
name|ae_kill
parameter_list|,
name|struct
name|hash_table
modifier|*
name|expr_hash_table
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table
operator|->
name|size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
operator|->
name|table
index|[
name|i
index|]
init|;
name|expr
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
comment|/* Skip EXPR if generated in this block.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|expr_killed_p
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|bb
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|ae_kill
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Actually perform the Classic GCSE optimizations.  */
end_comment

begin_comment
comment|/* Return nonzero if occurrence OCCR of expression EXPR reaches block BB.     CHECK_SELF_LOOP is nonzero if we should consider a block reaching itself    as a positive reach.  We want to do this when there are two computations    of the expression in the block.     VISITED is a pointer to a working buffer for tracking which BB's have    been visited.  It is NULL for the top-level call.     We treat reaching expressions that go through blocks containing the same    reaching expression as "not reaching".  E.g. if EXPR is generated in blocks    2 and 3, INSN is in block 4, and 2->3->4, we treat the expression in block    2 as not reaching.  The intent is to improve the probability of finding    only one reaching expression and to reduce register lifetimes by picking    the closest such expression.  */
end_comment

begin_function
specifier|static
name|int
name|expr_reaches_here_p_work
parameter_list|(
name|struct
name|occr
modifier|*
name|occr
parameter_list|,
name|struct
name|expr
modifier|*
name|expr
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|check_self_loop
parameter_list|,
name|char
modifier|*
name|visited
parameter_list|)
block|{
name|edge
name|pred
decl_stmt|;
for|for
control|(
name|pred
operator|=
name|bb
operator|->
name|pred
init|;
name|pred
operator|!=
name|NULL
condition|;
name|pred
operator|=
name|pred
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|pred_bb
init|=
name|pred
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
condition|)
comment|/* This predecessor has already been visited. Nothing to do.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|pred_bb
operator|==
name|bb
condition|)
block|{
comment|/* BB loops on itself.  */
if|if
condition|(
name|check_self_loop
operator|&&
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
operator|&&
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|==
name|pred_bb
operator|->
name|index
condition|)
return|return
literal|1
return|;
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Ignore this predecessor if it kills the expression.  */
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|ae_kill
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Does this predecessor generate this expression?  */
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
block|{
comment|/* Is this the occurrence we're looking for? 	     Note that there's only one generating occurrence per block 	     so we just need to check the block number.  */
if|if
condition|(
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|==
name|pred_bb
operator|->
name|index
condition|)
return|return
literal|1
return|;
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Neither gen nor kill.  */
else|else
block|{
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|expr_reaches_here_p_work
argument_list|(
name|occr
argument_list|,
name|expr
argument_list|,
name|pred_bb
argument_list|,
name|check_self_loop
argument_list|,
name|visited
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* All paths have been checked.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This wrapper for expr_reaches_here_p_work() is to ensure that any    memory allocated for that function is returned.  */
end_comment

begin_function
specifier|static
name|int
name|expr_reaches_here_p
parameter_list|(
name|struct
name|occr
modifier|*
name|occr
parameter_list|,
name|struct
name|expr
modifier|*
name|expr
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|check_self_loop
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|visited
init|=
name|xcalloc
argument_list|(
name|last_basic_block
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rval
operator|=
name|expr_reaches_here_p_work
argument_list|(
name|occr
argument_list|,
name|expr
argument_list|,
name|bb
argument_list|,
name|check_self_loop
argument_list|,
name|visited
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Return the instruction that computes EXPR that reaches INSN's basic block.    If there is more than one such instruction, return NULL.     Called only by handle_avail_expr.  */
end_comment

begin_function
specifier|static
name|rtx
name|computing_insn
parameter_list|(
name|struct
name|expr
modifier|*
name|expr
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|->
name|avail_occr
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|expr
operator|->
name|avail_occr
operator|->
name|insn
argument_list|)
operator|==
name|bb
condition|)
comment|/* The available expression is actually itself 	   (i.e. a loop in the flow graph) so do nothing.  */
return|return
name|NULL
return|;
comment|/* (FIXME) Case that we found a pattern that was created by 	 a substitution that took place.  */
return|return
name|expr
operator|->
name|avail_occr
operator|->
name|insn
return|;
block|}
else|else
block|{
comment|/* Pattern is computed more than once. 	 Search backwards from this insn to see how many of these 	 computations actually reach this insn.  */
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|rtx
name|insn_computes_expr
init|=
name|NULL
decl_stmt|;
name|int
name|can_reach
init|=
literal|0
decl_stmt|;
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|==
name|bb
condition|)
block|{
comment|/* The expression is generated in this block. 		 The only time we care about this is when the expression 		 is generated later in the block [and thus there's a loop]. 		 We let the normal cse pass handle the other cases.  */
if|if
condition|(
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|<
name|INSN_CUID
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|&&
name|expr_reaches_here_p
argument_list|(
name|occr
argument_list|,
name|expr
argument_list|,
name|bb
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|can_reach
operator|++
expr_stmt|;
if|if
condition|(
name|can_reach
operator|>
literal|1
condition|)
return|return
name|NULL
return|;
name|insn_computes_expr
operator|=
name|occr
operator|->
name|insn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|expr_reaches_here_p
argument_list|(
name|occr
argument_list|,
name|expr
argument_list|,
name|bb
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|can_reach
operator|++
expr_stmt|;
if|if
condition|(
name|can_reach
operator|>
literal|1
condition|)
return|return
name|NULL
return|;
name|insn_computes_expr
operator|=
name|occr
operator|->
name|insn
expr_stmt|;
block|}
block|}
if|if
condition|(
name|insn_computes_expr
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|insn_computes_expr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if the definition in DEF_INSN can reach INSN.    Only called by can_disregard_other_sets.  */
end_comment

begin_function
specifier|static
name|int
name|def_reaches_here_p
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|def_insn
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reaching_defs
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_CUID
argument_list|(
name|def_insn
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|def_insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|INSN_CUID
argument_list|(
name|def_insn
argument_list|)
operator|<
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|reg
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
operator|!
name|reg_set_between_p
argument_list|(
name|reg
argument_list|,
name|NEXT_INSN
argument_list|(
name|def_insn
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if *ADDR_THIS_REG can only have one value at INSN.  The    value returned is the number of definitions that reach INSN.  Returning a    value of zero means that [maybe] more than one definition reaches INSN and    the caller can't perform whatever optimization it is trying.  i.e. it is    always safe to return zero.  */
end_comment

begin_function
specifier|static
name|int
name|can_disregard_other_sets
parameter_list|(
name|struct
name|reg_set
modifier|*
modifier|*
name|addr_this_reg
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|for_combine
parameter_list|)
block|{
name|int
name|number_of_reaching_defs
init|=
literal|0
decl_stmt|;
name|struct
name|reg_set
modifier|*
name|this_reg
decl_stmt|;
for|for
control|(
name|this_reg
operator|=
operator|*
name|addr_this_reg
init|;
name|this_reg
operator|!=
literal|0
condition|;
name|this_reg
operator|=
name|this_reg
operator|->
name|next
control|)
if|if
condition|(
name|def_reaches_here_p
argument_list|(
name|insn
argument_list|,
name|this_reg
operator|->
name|insn
argument_list|)
condition|)
block|{
name|number_of_reaching_defs
operator|++
expr_stmt|;
comment|/* Ignore parallels for now.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|for_combine
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* A setting of the reg to a different value reaches INSN.  */
return|return
literal|0
return|;
if|if
condition|(
name|number_of_reaching_defs
operator|>
literal|1
condition|)
block|{
comment|/* If in this setting the value the register is being set to is 	       equal to the previous value the register was set to and this 	       setting reaches the insn we are trying to do the substitution 	       on then we are ok.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
operator|*
name|addr_this_reg
operator|=
name|this_reg
expr_stmt|;
block|}
return|return
name|number_of_reaching_defs
return|;
block|}
end_function

begin_comment
comment|/* Expression computed by insn is available and the substitution is legal,    so try to perform the substitution.     The result is nonzero if any changes were made.  */
end_comment

begin_function
specifier|static
name|int
name|handle_avail_expr
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|struct
name|expr
modifier|*
name|expr
parameter_list|)
block|{
name|rtx
name|pat
decl_stmt|,
name|insn_computes_expr
decl_stmt|,
name|expr_set
decl_stmt|;
name|rtx
name|to
decl_stmt|;
name|struct
name|reg_set
modifier|*
name|this_reg
decl_stmt|;
name|int
name|found_setting
decl_stmt|,
name|use_src
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
comment|/* We only handle the case where one computation of the expression      reaches this instruction.  */
name|insn_computes_expr
operator|=
name|computing_insn
argument_list|(
name|expr
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_computes_expr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|expr_set
operator|=
name|single_set
argument_list|(
name|insn_computes_expr
argument_list|)
expr_stmt|;
comment|/* The set might be in a parallel with multiple sets; we could      probably handle that, but there's currently no easy way to find      the relevant sub-expression.  */
if|if
condition|(
operator|!
name|expr_set
condition|)
return|return
literal|0
return|;
name|found_setting
operator|=
literal|0
expr_stmt|;
name|use_src
operator|=
literal|0
expr_stmt|;
comment|/* At this point we know only one computation of EXPR outside of this      block reaches this insn.  Now try to find a register that the      expression is computed into.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|expr_set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* This is the case when the available expression that reaches 	 here has already been handled as an available expression.  */
name|unsigned
name|int
name|regnum_for_replacing
init|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|expr_set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the register was created by GCSE we can't use `reg_set_table', 	 however we know it's set only once.  */
if|if
condition|(
name|regnum_for_replacing
operator|>=
name|max_gcse_regno
comment|/* If the register the expression is computed into is set only once, 	     or only one set reaches this insn, we can use it.  */
operator|||
operator|(
operator|(
operator|(
name|this_reg
operator|=
name|reg_set_table
index|[
name|regnum_for_replacing
index|]
operator|)
operator|,
name|this_reg
operator|->
name|next
operator|==
name|NULL
operator|)
operator|||
name|can_disregard_other_sets
argument_list|(
operator|&
name|this_reg
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|use_src
operator|=
literal|1
expr_stmt|;
name|found_setting
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found_setting
condition|)
block|{
name|unsigned
name|int
name|regnum_for_replacing
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|expr_set
argument_list|)
argument_list|)
decl_stmt|;
comment|/* This shouldn't happen.  */
if|if
condition|(
name|regnum_for_replacing
operator|>=
name|max_gcse_regno
condition|)
name|abort
argument_list|()
expr_stmt|;
name|this_reg
operator|=
name|reg_set_table
index|[
name|regnum_for_replacing
index|]
expr_stmt|;
comment|/* If the register the expression is computed into is set only once, 	 or only one set reaches this insn, use it.  */
if|if
condition|(
name|this_reg
operator|->
name|next
operator|==
name|NULL
operator|||
name|can_disregard_other_sets
argument_list|(
operator|&
name|this_reg
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
condition|)
name|found_setting
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found_setting
condition|)
block|{
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_src
condition|)
name|to
operator|=
name|SET_SRC
argument_list|(
name|expr_set
argument_list|)
expr_stmt|;
else|else
name|to
operator|=
name|SET_DEST
argument_list|(
name|expr_set
argument_list|)
expr_stmt|;
name|changed
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We should be able to ignore the return code from validate_change but 	 to play it safe we check.  */
if|if
condition|(
name|changed
condition|)
block|{
name|gcse_subst_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE: Replacing the source in insn %d with"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|" reg %d %s insn %d\n"
argument_list|,
name|REGNO
argument_list|(
name|to
argument_list|)
argument_list|,
name|use_src
condition|?
literal|"from"
else|:
literal|"set in"
argument_list|,
name|INSN_UID
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* The register that the expr is computed into is set more than once.  */
elseif|else
if|if
condition|(
literal|1
comment|/*expensive_op(this_pattrn->op)&& do_expensive_gcse)*/
condition|)
block|{
comment|/* Insert an insn after insnx that copies the reg set in insnx 	 into a new pseudo register call this new register REGN. 	 From insnb until end of basic block or until REGB is set 	 replace all uses of REGB with REGN.  */
name|rtx
name|new_insn
decl_stmt|;
name|to
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|expr_set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate the new insn.  */
comment|/* ??? If the change fails, we return 0, even though we created 	 an insn.  I think this is ok.  */
name|new_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|to
argument_list|,
name|SET_DEST
argument_list|(
name|expr_set
argument_list|)
argument_list|)
argument_list|,
name|insn_computes_expr
argument_list|)
expr_stmt|;
comment|/* Keep register set table up to date.  */
name|record_one_set
argument_list|(
name|REGNO
argument_list|(
name|to
argument_list|)
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
name|gcse_create_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE: Creating insn %d to copy value of reg %d"
argument_list|,
name|INSN_UID
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|", computed in insn %d,\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"      into newly allocated reg %d\n"
argument_list|,
name|REGNO
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Do register replacement for INSN.  */
name|changed
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We should be able to ignore the return code from validate_change but 	 to play it safe we check.  */
if|if
condition|(
name|changed
condition|)
block|{
name|gcse_subst_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE: Replacing the source in insn %d with reg %d "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"set in insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Perform classic GCSE.  This is called by one_classic_gcse_pass after all    the dataflow analysis has been done.     The result is nonzero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|classic_gcse
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|changed
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* Note we start at block 1.  */
if|if
condition|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
literal|0
return|;
name|changed
operator|=
literal|0
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR->next_bb->next_bb
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
comment|/* Reset tables used to keep track of what's still valid [since the 	 start of the block].  */
name|reset_opr_set_tables
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NULL
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Is insn of form (set (pseudo-reg) ...)?  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
if|if
condition|(
name|want_to_gcse_p
argument_list|(
name|src
argument_list|)
comment|/* Is the expression recorded?  */
operator|&&
operator|(
operator|(
name|expr
operator|=
name|lookup_expr
argument_list|(
name|src
argument_list|,
operator|&
name|expr_hash_table
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
comment|/* Is the expression available [at the start of the 		     block]?  */
operator|&&
name|TEST_BIT
argument_list|(
name|ae_in
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
comment|/* Are the operands unchanged since the start of the 		     block?  */
operator|&&
name|oprs_not_set_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
condition|)
name|changed
operator||=
name|handle_avail_expr
argument_list|(
name|insn
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* Keep track of everything modified by this insn.  */
comment|/* ??? Need to be careful w.r.t. mods done to INSN.  */
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|mark_oprs_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Top level routine to perform one classic GCSE pass.     Return nonzero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|one_classic_gcse_pass
parameter_list|(
name|int
name|pass
parameter_list|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|gcse_subst_count
operator|=
literal|0
expr_stmt|;
name|gcse_create_count
operator|=
literal|0
expr_stmt|;
name|alloc_hash_table
argument_list|(
name|max_cuid
argument_list|,
operator|&
name|expr_hash_table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alloc_rd_mem
argument_list|(
name|last_basic_block
argument_list|,
name|max_cuid
argument_list|)
expr_stmt|;
name|compute_hash_table
argument_list|(
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|dump_hash_table
argument_list|(
name|gcse_file
argument_list|,
literal|"Expression"
argument_list|,
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr_hash_table
operator|.
name|n_elems
operator|>
literal|0
condition|)
block|{
name|compute_kill_rd
argument_list|()
expr_stmt|;
name|compute_rd
argument_list|()
expr_stmt|;
name|alloc_avail_expr_mem
argument_list|(
name|last_basic_block
argument_list|,
name|expr_hash_table
operator|.
name|n_elems
argument_list|)
expr_stmt|;
name|compute_ae_gen
argument_list|(
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
name|compute_ae_kill
argument_list|(
name|ae_gen
argument_list|,
name|ae_kill
argument_list|,
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
name|compute_available
argument_list|(
name|ae_gen
argument_list|,
name|ae_kill
argument_list|,
name|ae_out
argument_list|,
name|ae_in
argument_list|)
expr_stmt|;
name|changed
operator|=
name|classic_gcse
argument_list|()
expr_stmt|;
name|free_avail_expr_mem
argument_list|()
expr_stmt|;
block|}
name|free_rd_mem
argument_list|()
expr_stmt|;
name|free_hash_table
argument_list|(
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE of %s, pass %d: %d bytes needed, %d substs,"
argument_list|,
name|current_function_name
argument_list|()
argument_list|,
name|pass
argument_list|,
name|bytes_used
argument_list|,
name|gcse_subst_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"%d insns created\n"
argument_list|,
name|gcse_create_count
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute copy/constant propagation working variables.  */
end_comment

begin_comment
comment|/* Local properties of assignments.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_pavloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_absaltered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global properties of assignments (computed from the local properties).  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_avin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_avout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate vars used for copy/const propagation.  N_BLOCKS is the number of    basic blocks.  N_SETS is the number of sets.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_cprop_mem
parameter_list|(
name|int
name|n_blocks
parameter_list|,
name|int
name|n_sets
parameter_list|)
block|{
name|cprop_pavloc
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
name|cprop_absaltered
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
name|cprop_avin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
name|cprop_avout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free vars used by copy/const propagation.  */
end_comment

begin_function
specifier|static
name|void
name|free_cprop_mem
parameter_list|(
name|void
parameter_list|)
block|{
name|sbitmap_vector_free
argument_list|(
name|cprop_pavloc
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|cprop_absaltered
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|cprop_avin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|cprop_avout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each block, compute whether X is transparent.  X is either an    expression or an assignment [though we don't care which, for this context    an assignment is treated as an expression].  For each block where an    element of X is modified, set (SET_P == 1) or reset (SET_P == 0) the INDX    bit in BMAP.  */
end_comment

begin_function
specifier|static
name|void
name|compute_transp
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
name|indx
parameter_list|,
name|sbitmap
modifier|*
name|bmap
parameter_list|,
name|int
name|set_p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|reg_set
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration since GCC      can't do it when there's no return value.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|set_p
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|bmap
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|r
operator|=
name|reg_set_table
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
name|SET_BIT
argument_list|(
name|bmap
index|[
name|BLOCK_NUM
argument_list|(
name|r
operator|->
name|insn
argument_list|)
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|RESET_BIT
argument_list|(
name|bmap
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|r
operator|=
name|reg_set_table
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
name|RESET_BIT
argument_list|(
name|bmap
index|[
name|BLOCK_NUM
argument_list|(
name|r
operator|->
name|insn
argument_list|)
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
case|case
name|MEM
case|:
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|list_entry
init|=
name|canon_modify_mem_list
index|[
name|bb
operator|->
name|index
index|]
decl_stmt|;
while|while
condition|(
name|list_entry
condition|)
block|{
name|rtx
name|dest
decl_stmt|,
name|dest_addr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
if|if
condition|(
name|set_p
condition|)
name|SET_BIT
argument_list|(
name|bmap
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
else|else
name|RESET_BIT
argument_list|(
name|bmap
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* LIST_ENTRY must be an INSN of some kind that sets memory. 		 Examine each hunk of memory that is modified.  */
name|dest
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|list_entry
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dest_addr
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|canon_true_dependence
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|dest_addr
argument_list|,
name|x
argument_list|,
name|rtx_addr_varies_p
argument_list|)
condition|)
block|{
if|if
condition|(
name|set_p
condition|)
name|SET_BIT
argument_list|(
name|bmap
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
else|else
name|RESET_BIT
argument_list|(
name|bmap
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
break|break;
block|}
name|list_entry
operator|=
name|XEXP
argument_list|(
name|list_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|compute_transp
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|indx
argument_list|,
name|bmap
argument_list|,
name|set_p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|compute_transp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|indx
argument_list|,
name|bmap
argument_list|,
name|set_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Top level routine to do the dataflow analysis needed by copy/const    propagation.  */
end_comment

begin_function
specifier|static
name|void
name|compute_cprop_data
parameter_list|(
name|void
parameter_list|)
block|{
name|compute_local_properties
argument_list|(
name|cprop_absaltered
argument_list|,
name|cprop_pavloc
argument_list|,
name|NULL
argument_list|,
operator|&
name|set_hash_table
argument_list|)
expr_stmt|;
name|compute_available
argument_list|(
name|cprop_pavloc
argument_list|,
name|cprop_absaltered
argument_list|,
name|cprop_avout
argument_list|,
name|cprop_avin
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy/constant propagation.  */
end_comment

begin_comment
comment|/* Maximum number of register uses in an insn that we handle.  */
end_comment

begin_define
define|#
directive|define
name|MAX_USES
value|8
end_define

begin_comment
comment|/* Table of uses found in an insn.    Allocated statically to avoid alloc/free complexity and overhead.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|reg_use
name|reg_use_table
index|[
name|MAX_USES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into `reg_use_table' while building it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_use_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up a list of register numbers used in INSN.  The found uses are stored    in `reg_use_table'.  `reg_use_count' is initialized to zero before entry,    and contains the number of uses in the table upon exit.     ??? If a register appears multiple times we will record it multiple times.    This doesn't hurt anything but it will slow things down.  */
end_comment

begin_function
specifier|static
name|void
name|find_used_regs
parameter_list|(
name|rtx
modifier|*
name|xptr
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|rtx
name|x
init|=
operator|*
name|xptr
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration since GCC      can't do it when there's no return value.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_use_count
operator|==
name|MAX_USES
condition|)
return|return;
name|reg_use_table
index|[
name|reg_use_count
index|]
operator|.
name|reg_rtx
operator|=
name|x
expr_stmt|;
name|reg_use_count
operator|++
expr_stmt|;
block|}
comment|/* Recursively scan the operands of this expression.  */
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|find_used_regs
argument_list|(
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|find_used_regs
argument_list|(
operator|&
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to replace all non-SET_DEST occurrences of FROM in INSN with TO.    Returns nonzero is successful.  */
end_comment

begin_function
specifier|static
name|int
name|try_replace_reg
parameter_list|(
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|note
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|validate_replace_src_group
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_changes_pending
argument_list|()
operator|&&
name|apply_change_group
argument_list|()
condition|)
name|success
operator|=
literal|1
expr_stmt|;
comment|/* Try to simplify SET_SRC if we have substituted a constant.  */
if|if
condition|(
name|success
operator|&&
name|set
operator|&&
name|CONSTANT_P
argument_list|(
name|to
argument_list|)
condition|)
block|{
name|src
operator|=
name|simplify_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
condition|)
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If there is already a NOTE, update the expression in it with our      replacement.  */
if|if
condition|(
name|note
operator|!=
literal|0
condition|)
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
operator|&&
name|set
operator|&&
name|reg_mentioned_p
argument_list|(
name|from
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If above failed and this is a single set, try to simplify the source of 	 the set given our substitution.  We could perhaps try this for multiple 	 SETs, but it probably won't buy us anything.  */
name|src
operator|=
name|simplify_replace_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|src
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|&&
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
condition|)
name|success
operator|=
literal|1
expr_stmt|;
comment|/* If we've failed to do replacement, have a single SET, don't already 	 have a note, and have no special SET, add a REG_EQUAL note to not 	 lose information.  */
if|if
condition|(
operator|!
name|success
operator|&&
name|note
operator|==
literal|0
operator|&&
name|set
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|set
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ZERO_EXTRACT
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|set
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SIGN_EXTRACT
condition|)
name|note
operator|=
name|set_unique_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|copy_rtx
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* REG_EQUAL may get simplified into register.      We don't allow that. Remove that note. This code ought      not to happen, because previous code ought to synthesize      reg-reg move, but be on the safe side.  */
if|if
condition|(
name|note
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/* Find a set of REGNOs that are available on entry to INSN's block.  Returns    NULL no such set is found.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|find_avail_set
parameter_list|(
name|int
name|regno
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
comment|/* SET1 contains the last set found that can be returned to the caller for      use in a substitution.  */
name|struct
name|expr
modifier|*
name|set1
init|=
literal|0
decl_stmt|;
comment|/* Loops are not possible here.  To get a loop we would need two sets      available at the start of the block containing INSN.  ie we would      need two sets like this available at the start of the block:         (set (reg X) (reg Y))        (set (reg Y) (reg X))       This can not happen since the set of (reg Y) would have killed the      set of (reg X) making it unavailable at the start of this block.  */
while|while
condition|(
literal|1
condition|)
block|{
name|rtx
name|src
decl_stmt|;
name|struct
name|expr
modifier|*
name|set
init|=
name|lookup_set
argument_list|(
name|regno
argument_list|,
operator|&
name|set_hash_table
argument_list|)
decl_stmt|;
comment|/* Find a set that is available at the start of the block 	 which contains INSN.  */
while|while
condition|(
name|set
condition|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|cprop_avin
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|set
operator|->
name|bitmap_index
argument_list|)
condition|)
break|break;
name|set
operator|=
name|next_set
argument_list|(
name|regno
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
comment|/* If no available set was found we've reached the end of the 	 (possibly empty) copy chain.  */
if|if
condition|(
name|set
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
operator|->
name|expr
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
operator|->
name|expr
argument_list|)
expr_stmt|;
comment|/* We know the set is available. 	 Now check that SRC is ANTLOC (i.e. none of the source operands 	 have changed since the start of the block).           If the source operand changed, we may still use it for the next          iteration of this loop, but we may not use it for substitutions.  */
if|if
condition|(
name|gcse_constant_p
argument_list|(
name|src
argument_list|)
operator|||
name|oprs_not_set_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
condition|)
name|set1
operator|=
name|set
expr_stmt|;
comment|/* If the source of the set is anything except a register, then 	 we have reached the end of the copy chain.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
condition|)
break|break;
comment|/* Follow the copy chain, ie start another iteration of the loop 	 and see if we have an available copy into SRC.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* SET1 holds the last set that was available and anticipatable at      INSN.  */
return|return
name|set1
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of cprop_insn that tries to propagate constants into    JUMP_INSNS.  JUMP must be a conditional jump.  If SETCC is non-NULL    it is the instruction that immediately precedes JUMP, and must be a    single SET of a register.  FROM is what we will try to replace,    SRC is the constant we will try to substitute for it.  Returns nonzero    if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|cprop_jump
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
name|setcc
parameter_list|,
name|rtx
name|jump
parameter_list|,
name|rtx
name|from
parameter_list|,
name|rtx
name|src
parameter_list|)
block|{
name|rtx
name|new
decl_stmt|,
name|set_src
decl_stmt|,
name|note_src
decl_stmt|;
name|rtx
name|set
init|=
name|pc_set
argument_list|(
name|jump
argument_list|)
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|jump
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|note_src
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|note_src
argument_list|)
operator|==
name|EXPR_LIST
condition|)
name|note_src
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
name|note_src
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Prefer REG_EQUAL notes except those containing EXPR_LISTs.  */
name|set_src
operator|=
name|note_src
condition|?
name|note_src
else|:
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* First substitute the SETCC condition into the JUMP instruction,      then substitute that given values into this expanded JUMP.  */
if|if
condition|(
name|setcc
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|modified_between_p
argument_list|(
name|from
argument_list|,
name|setcc
argument_list|,
name|jump
argument_list|)
operator|&&
operator|!
name|modified_between_p
argument_list|(
name|src
argument_list|,
name|setcc
argument_list|,
name|jump
argument_list|)
condition|)
block|{
name|rtx
name|setcc_src
decl_stmt|;
name|rtx
name|setcc_set
init|=
name|single_set
argument_list|(
name|setcc
argument_list|)
decl_stmt|;
name|rtx
name|setcc_note
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|setcc
argument_list|)
decl_stmt|;
name|setcc_src
operator|=
operator|(
name|setcc_note
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|setcc_note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|EXPR_LIST
operator|)
condition|?
name|XEXP
argument_list|(
name|setcc_note
argument_list|,
literal|0
argument_list|)
else|:
name|SET_SRC
argument_list|(
name|setcc_set
argument_list|)
expr_stmt|;
name|set_src
operator|=
name|simplify_replace_rtx
argument_list|(
name|set_src
argument_list|,
name|SET_DEST
argument_list|(
name|setcc_set
argument_list|)
argument_list|,
name|setcc_src
argument_list|)
expr_stmt|;
block|}
else|else
name|setcc
operator|=
name|NULL_RTX
expr_stmt|;
name|new
operator|=
name|simplify_replace_rtx
argument_list|(
name|set_src
argument_list|,
name|from
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* If no simplification can be made, then try the next register.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|new
argument_list|,
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is now a no-op delete it, otherwise this must be a valid insn.  */
if|if
condition|(
name|new
operator|==
name|pc_rtx
condition|)
name|delete_insn
argument_list|(
name|jump
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Ensure the value computed inside the jump insn to be equivalent          to one computed by setcc.  */
if|if
condition|(
name|setcc
operator|&&
name|modified_in_p
argument_list|(
name|new
argument_list|,
name|setcc
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|jump
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|new
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* When (some) constants are not valid in a comparison, and there 	     are two registers to be replaced by constants before the entire 	     comparison can be folded into a constant, we need to keep 	     intermediate information in REG_EQUAL notes.  For targets with 	     separate compare insns, such notes are added by try_replace_reg. 	     When we have a combined compare-and-branch instruction, however, 	     we need to attach a note to the branch itself to make this 	     optimization work.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|new
argument_list|,
name|note_src
argument_list|)
condition|)
name|set_unique_reg_note
argument_list|(
name|jump
argument_list|,
name|REG_EQUAL
argument_list|,
name|copy_rtx
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Remove REG_EQUAL note after simplification.  */
if|if
condition|(
name|note_src
condition|)
name|remove_note
argument_list|(
name|jump
argument_list|,
name|note
argument_list|)
expr_stmt|;
comment|/* If this has turned into an unconditional jump, 	 then put a barrier after it so that the unreachable 	 code will be deleted.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|emit_barrier_after
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* Delete the cc0 setter.  */
if|if
condition|(
name|setcc
operator|!=
name|NULL
operator|&&
name|CC0_P
argument_list|(
name|SET_DEST
argument_list|(
name|single_set
argument_list|(
name|setcc
argument_list|)
argument_list|)
argument_list|)
condition|)
name|delete_insn
argument_list|(
name|setcc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|run_jump_opt_after_gcse
operator|=
literal|1
expr_stmt|;
name|const_prop_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"CONST-PROP: Replacing reg %d in jump_insn %d with constant "
argument_list|,
name|REGNO
argument_list|(
name|from
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|purge_dead_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|constprop_register
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|from
parameter_list|,
name|rtx
name|to
parameter_list|,
name|int
name|alter_jumps
parameter_list|)
block|{
name|rtx
name|sset
decl_stmt|;
comment|/* Check for reg or cc0 setting instructions followed by      conditional branch instructions first.  */
if|if
condition|(
name|alter_jumps
operator|&&
operator|(
name|sset
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|&&
name|any_condjump_p
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|sset
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|REG_P
argument_list|(
name|dest
argument_list|)
operator|||
name|CC0_P
argument_list|(
name|dest
argument_list|)
operator|)
operator|&&
name|cprop_jump
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* Handle normal insns next.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|try_replace_reg
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Try to propagate a CONST_INT into a conditional jump.      We're pretty specific about what we will handle in this      code, we can extend this as necessary over time.       Right now the insn in question must look like      (set (pc) (if_then_else ...))  */
elseif|else
if|if
condition|(
name|alter_jumps
operator|&&
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|cprop_jump
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|insn
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Perform constant and copy propagation on INSN.    The result is nonzero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|cprop_insn
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
name|alter_jumps
parameter_list|)
block|{
name|struct
name|reg_use
modifier|*
name|reg_used
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|rtx
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
name|reg_use_count
operator|=
literal|0
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|find_used_regs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* We may win even when propagating constants into notes.  */
if|if
condition|(
name|note
condition|)
name|find_used_regs
argument_list|(
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|reg_used
operator|=
operator|&
name|reg_use_table
index|[
literal|0
index|]
init|;
name|reg_use_count
operator|>
literal|0
condition|;
name|reg_used
operator|++
operator|,
name|reg_use_count
operator|--
control|)
block|{
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|src
decl_stmt|;
name|struct
name|expr
modifier|*
name|set
decl_stmt|;
comment|/* Ignore registers created by GCSE. 	 We do this because ...  */
if|if
condition|(
name|regno
operator|>=
name|max_gcse_regno
condition|)
continue|continue;
comment|/* If the register has already been set in this block, there's 	 nothing we can do.  */
if|if
condition|(
operator|!
name|oprs_not_set_p
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Find an assignment that sets reg_used and is available 	 at the start of the block.  */
name|set
operator|=
name|find_avail_set
argument_list|(
name|regno
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
name|pat
operator|=
name|set
operator|->
name|expr
expr_stmt|;
comment|/* ??? We might be able to handle PARALLELs.  Later.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* Constant propagation.  */
if|if
condition|(
name|gcse_constant_p
argument_list|(
name|src
argument_list|)
condition|)
block|{
if|if
condition|(
name|constprop_register
argument_list|(
name|insn
argument_list|,
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|src
argument_list|,
name|alter_jumps
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|const_prop_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GLOBAL CONST-PROP: Replacing reg %d in "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"insn %d with constant "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|!=
name|regno
condition|)
block|{
if|if
condition|(
name|try_replace_reg
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|src
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|copy_prop_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GLOBAL COPY-PROP: Replacing reg %d in insn %d"
argument_list|,
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|" with reg %d\n"
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The original insn setting reg_used may or may not now be 		 deletable.  We leave the deletion to flow.  */
comment|/* FIXME: If it turns out that the insn isn't deletable, 		 then we may have unnecessarily extended register lifetimes 		 and made things worse.  */
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Like find_used_regs, but avoid recording uses that appear in    input-output contexts such as zero_extract or pre_dec.  This    restricts the cases we consider to those for which local cprop    can legitimately make replacements.  */
end_comment

begin_function
specifier|static
name|void
name|local_cprop_find_used_regs
parameter_list|(
name|rtx
modifier|*
name|xptr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|xptr
decl_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
case|case
name|STRICT_LOW_PART
case|:
return|return;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
comment|/* Can only legitimately appear this early in the context of 	 stack pushes for function arguments, but handle all of the 	 codes nonetheless.  */
return|return;
case|case
name|SUBREG
case|:
comment|/* Setting a subreg of a register larger than word_mode leaves 	 the non-written words unchanged.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|>
name|BITS_PER_WORD
condition|)
return|return;
break|break;
default|default:
break|break;
block|}
name|find_used_regs
argument_list|(
name|xptr
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* LIBCALL_SP is a zero-terminated array of insns at the end of a libcall;    their REG_EQUAL notes need updating.  */
end_comment

begin_function
specifier|static
name|bool
name|do_local_cprop
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|alter_jumps
parameter_list|,
name|rtx
modifier|*
name|libcall_sp
parameter_list|)
block|{
name|rtx
name|newreg
init|=
name|NULL
decl_stmt|,
name|newcnst
init|=
name|NULL
decl_stmt|;
comment|/* Rule out USE instructions and ASM statements as we don't want to      change the hard registers mentioned.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|cselib_val
modifier|*
name|val
init|=
name|cselib_lookup
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|elt_loc_list
modifier|*
name|l
decl_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
return|return
name|false
return|;
for|for
control|(
name|l
operator|=
name|val
operator|->
name|locs
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|rtx
name|this_rtx
init|=
name|l
operator|->
name|loc
decl_stmt|;
name|rtx
name|note
decl_stmt|;
comment|/* Don't CSE non-constant values out of libcall blocks.  */
if|if
condition|(
name|l
operator|->
name|in_libcall
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|this_rtx
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|gcse_constant_p
argument_list|(
name|this_rtx
argument_list|)
condition|)
name|newcnst
operator|=
name|this_rtx
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|this_rtx
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|this_rtx
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
comment|/* Don't copy propagate if it has attached REG_EQUIV note. 		 At this point this only function parameters should have 		 REG_EQUIV notes and if the argument slot is used somewhere 		 explicitly, it means address of parameter has been taken, 		 so we should not extend the lifetime of the pseudo.  */
operator|&&
operator|(
operator|!
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|l
operator|->
name|setting_insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|)
condition|)
name|newreg
operator|=
name|this_rtx
expr_stmt|;
block|}
if|if
condition|(
name|newcnst
operator|&&
name|constprop_register
argument_list|(
name|insn
argument_list|,
name|x
argument_list|,
name|newcnst
argument_list|,
name|alter_jumps
argument_list|)
condition|)
block|{
comment|/* If we find a case where we can't fix the retval REG_EQUAL notes 	     match the new register, we either have to abandon this replacement 	     or fix delete_trivially_dead_insns to preserve the setting insn, 	     or make it delete the REG_EUAQL note, and fix up all passes that 	     require the REG_EQUAL note there.  */
if|if
condition|(
operator|!
name|adjust_libcall_notes
argument_list|(
name|x
argument_list|,
name|newcnst
argument_list|,
name|insn
argument_list|,
name|libcall_sp
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"LOCAL CONST-PROP: Replacing reg %d in "
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"insn %d with constant "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|newcnst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|const_prop_count
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|newreg
operator|&&
name|newreg
operator|!=
name|x
operator|&&
name|try_replace_reg
argument_list|(
name|x
argument_list|,
name|newreg
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|adjust_libcall_notes
argument_list|(
name|x
argument_list|,
name|newreg
argument_list|,
name|insn
argument_list|,
name|libcall_sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"LOCAL COPY-PROP: Replacing reg %d in insn %d"
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|" with reg %d\n"
argument_list|,
name|REGNO
argument_list|(
name|newreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|copy_prop_count
operator|++
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* LIBCALL_SP is a zero-terminated array of insns at the end of a libcall;    their REG_EQUAL notes need updating to reflect that OLDREG has been    replaced with NEWVAL in INSN.  Return true if all substitutions could    be made.  */
end_comment

begin_function
specifier|static
name|bool
name|adjust_libcall_notes
parameter_list|(
name|rtx
name|oldreg
parameter_list|,
name|rtx
name|newval
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
modifier|*
name|libcall_sp
parameter_list|)
block|{
name|rtx
name|end
decl_stmt|;
while|while
condition|(
operator|(
name|end
operator|=
operator|*
name|libcall_sp
operator|++
operator|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_equal_equiv_note
argument_list|(
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
continue|continue;
if|if
condition|(
name|REG_P
argument_list|(
name|newval
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg_set_between_p
argument_list|(
name|newval
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|end
argument_list|)
condition|)
block|{
do|do
block|{
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
continue|continue;
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|newval
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
do|while
condition|(
operator|(
name|end
operator|=
operator|*
name|libcall_sp
operator|++
operator|)
condition|)
do|;
return|return
name|true
return|;
block|}
block|}
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|simplify_replace_rtx
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|oldreg
argument_list|,
name|newval
argument_list|)
expr_stmt|;
name|insn
operator|=
name|end
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_NESTED_LIBCALLS
value|9
end_define

begin_function
specifier|static
name|void
name|local_cprop_pass
parameter_list|(
name|int
name|alter_jumps
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|struct
name|reg_use
modifier|*
name|reg_used
decl_stmt|;
name|rtx
name|libcall_stack
index|[
name|MAX_NESTED_LIBCALLS
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|libcall_sp
decl_stmt|;
name|bool
name|changed
init|=
name|false
decl_stmt|;
name|cselib_init
argument_list|()
expr_stmt|;
name|libcall_sp
operator|=
operator|&
name|libcall_stack
index|[
name|MAX_NESTED_LIBCALLS
index|]
expr_stmt|;
operator|*
name|libcall_sp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|note
condition|)
block|{
if|if
condition|(
name|libcall_sp
operator|==
name|libcall_stack
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|*
operator|--
name|libcall_sp
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|libcall_sp
operator|++
expr_stmt|;
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
expr_stmt|;
do|do
block|{
name|reg_use_count
operator|=
literal|0
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|local_cprop_find_used_regs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|local_cprop_find_used_regs
argument_list|(
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|reg_used
operator|=
operator|&
name|reg_use_table
index|[
literal|0
index|]
init|;
name|reg_use_count
operator|>
literal|0
condition|;
name|reg_used
operator|++
operator|,
name|reg_use_count
operator|--
control|)
if|if
condition|(
name|do_local_cprop
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|insn
argument_list|,
name|alter_jumps
argument_list|,
name|libcall_sp
argument_list|)
condition|)
block|{
name|changed
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
name|reg_use_count
condition|)
do|;
block|}
name|cselib_process_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|cselib_finish
argument_list|()
expr_stmt|;
comment|/* Global analysis may get into infinite loops for unreachable blocks.  */
if|if
condition|(
name|changed
operator|&&
name|alter_jumps
condition|)
block|{
name|delete_unreachable_blocks
argument_list|()
expr_stmt|;
name|free_reg_set_mem
argument_list|()
expr_stmt|;
name|alloc_reg_set_mem
argument_list|(
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
name|compute_sets
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Forward propagate copies.  This includes copies and constants.  Return    nonzero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|cprop
parameter_list|(
name|int
name|alter_jumps
parameter_list|)
block|{
name|int
name|changed
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Note we start at block 1.  */
if|if
condition|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
block|{
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|changed
operator|=
literal|0
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR->next_bb->next_bb
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
comment|/* Reset tables used to keep track of what's still valid [since the 	 start of the block].  */
name|reset_opr_set_tables
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NULL
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|changed
operator||=
name|cprop_insn
argument_list|(
name|insn
argument_list|,
name|alter_jumps
argument_list|)
expr_stmt|;
comment|/* Keep track of everything modified by this insn.  */
comment|/* ??? Need to be careful w.r.t. mods done to INSN.  Don't 	       call mark_oprs_set if we turned the insn into a NOTE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|mark_oprs_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Similar to get_condition, only the resulting condition must be    valid at JUMP, instead of at EARLIEST.     This differs from noce_get_condition in ifcvt.c in that we prefer not to    settle for the condition variable in the jump instruction being integral.    We prefer to be able to record the value of a user variable, rather than    the value of a temporary used in a condition.  This could be solved by    recording the value of *every* register scaned by canonicalize_condition,    but this would require some code reorganization.  */
end_comment

begin_function
name|rtx
name|fis_get_condition
parameter_list|(
name|rtx
name|jump
parameter_list|)
block|{
name|rtx
name|cond
decl_stmt|,
name|set
decl_stmt|,
name|tmp
decl_stmt|,
name|insn
decl_stmt|,
name|earliest
decl_stmt|;
name|bool
name|reverse
decl_stmt|;
if|if
condition|(
operator|!
name|any_condjump_p
argument_list|(
name|jump
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
name|set
operator|=
name|pc_set
argument_list|(
name|jump
argument_list|)
expr_stmt|;
name|cond
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this branches to JUMP_LABEL when the condition is false,      reverse the condition.  */
name|reverse
operator|=
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|)
expr_stmt|;
comment|/* Use canonicalize_condition to do the dirty work of manipulating      MODE_CC values and COMPARE rtx codes.  */
name|tmp
operator|=
name|canonicalize_condition
argument_list|(
name|jump
argument_list|,
name|cond
argument_list|,
name|reverse
argument_list|,
operator|&
name|earliest
argument_list|,
name|NULL_RTX
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
name|NULL_RTX
return|;
comment|/* Verify that the given condition is valid at JUMP by virtue of not      having been modified since EARLIEST.  */
for|for
control|(
name|insn
operator|=
name|earliest
init|;
name|insn
operator|!=
name|jump
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|modified_in_p
argument_list|(
name|tmp
argument_list|,
name|insn
argument_list|)
condition|)
break|break;
if|if
condition|(
name|insn
operator|==
name|jump
condition|)
return|return
name|tmp
return|;
comment|/* The condition was modified.  See if we can get a partial result      that doesn't follow all the reversals.  Perhaps combine can fold      them together later.  */
name|tmp
operator|=
name|XEXP
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|tmp
argument_list|)
operator|||
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|!=
name|MODE_INT
condition|)
return|return
name|NULL_RTX
return|;
name|tmp
operator|=
name|canonicalize_condition
argument_list|(
name|jump
argument_list|,
name|cond
argument_list|,
name|reverse
argument_list|,
operator|&
name|earliest
argument_list|,
name|tmp
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
return|return
name|NULL_RTX
return|;
comment|/* For sanity's sake, re-validate the new result.  */
for|for
control|(
name|insn
operator|=
name|earliest
init|;
name|insn
operator|!=
name|jump
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|modified_in_p
argument_list|(
name|tmp
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|NULL_RTX
return|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* Check the comparison COND to see if we can safely form an implicit set from    it.  COND is either an EQ or NE comparison.  */
end_comment

begin_function
specifier|static
name|bool
name|implicit_set_cond_p
parameter_list|(
name|rtx
name|cond
parameter_list|)
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|cst
init|=
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* We can't perform this optimization if either operand might be or might      contain a signed zero.  */
if|if
condition|(
name|HONOR_SIGNED_ZEROS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* It is sufficient to check if CST is or contains a zero.  We must 	 handle float, complex, and vector.  If any subpart is a zero, then 	 the optimization can't be performed.  */
comment|/* ??? The complex and vector checks are not implemented yet.  We just 	 always return zero for them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|cst
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|cst
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|d
argument_list|,
name|dconst0
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
return|return
name|gcse_constant_p
argument_list|(
name|cst
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find the implicit sets of a function.  An "implicit set" is a constraint    on the value of a variable, implied by a conditional jump.  For example,    following "if (x == 2)", the then branch may be optimized as though the    conditional performed an "explicit set", in this example, "x = 2".  This    function records the set patterns that are implicit at the start of each    basic block.  */
end_comment

begin_function
specifier|static
name|void
name|find_implicit_sets
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|dest
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|rtx
name|cond
decl_stmt|,
name|new
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
comment|/* Check for more than one successor.  */
if|if
condition|(
name|bb
operator|->
name|succ
operator|&&
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
name|cond
operator|=
name|fis_get_condition
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
operator|||
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|NE
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|implicit_set_cond_p
argument_list|(
name|cond
argument_list|)
condition|)
block|{
name|dest
operator|=
name|GET_CODE
argument_list|(
name|cond
argument_list|)
operator|==
name|EQ
condition|?
name|BRANCH_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|dest
else|:
name|FALLTHRU_EDGE
argument_list|(
name|bb
argument_list|)
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|dest
operator|&&
operator|!
name|dest
operator|->
name|pred
operator|->
name|pred_next
operator|&&
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|new
operator|=
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|implicit_sets
index|[
name|dest
operator|->
name|index
index|]
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"Implicit set of reg %d in "
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"basic block %d\n"
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"Found %d implicit sets\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform one copy/constant propagation pass.    PASS is the pass count.  If CPROP_JUMPS is true, perform constant    propagation into conditional jumps.  If BYPASS_JUMPS is true,    perform conditional jump bypassing optimizations.  */
end_comment

begin_function
specifier|static
name|int
name|one_cprop_pass
parameter_list|(
name|int
name|pass
parameter_list|,
name|int
name|cprop_jumps
parameter_list|,
name|int
name|bypass_jumps
parameter_list|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|const_prop_count
operator|=
literal|0
expr_stmt|;
name|copy_prop_count
operator|=
literal|0
expr_stmt|;
name|local_cprop_pass
argument_list|(
name|cprop_jumps
argument_list|)
expr_stmt|;
comment|/* Determine implicit sets.  */
name|implicit_sets
operator|=
name|xcalloc
argument_list|(
name|last_basic_block
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|find_implicit_sets
argument_list|()
expr_stmt|;
name|alloc_hash_table
argument_list|(
name|max_cuid
argument_list|,
operator|&
name|set_hash_table
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|compute_hash_table
argument_list|(
operator|&
name|set_hash_table
argument_list|)
expr_stmt|;
comment|/* Free implicit_sets before peak usage.  */
name|free
argument_list|(
name|implicit_sets
argument_list|)
expr_stmt|;
name|implicit_sets
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|dump_hash_table
argument_list|(
name|gcse_file
argument_list|,
literal|"SET"
argument_list|,
operator|&
name|set_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_hash_table
operator|.
name|n_elems
operator|>
literal|0
condition|)
block|{
name|alloc_cprop_mem
argument_list|(
name|last_basic_block
argument_list|,
name|set_hash_table
operator|.
name|n_elems
argument_list|)
expr_stmt|;
name|compute_cprop_data
argument_list|()
expr_stmt|;
name|changed
operator|=
name|cprop
argument_list|(
name|cprop_jumps
argument_list|)
expr_stmt|;
if|if
condition|(
name|bypass_jumps
condition|)
name|changed
operator||=
name|bypass_conditional_jumps
argument_list|()
expr_stmt|;
name|free_cprop_mem
argument_list|()
expr_stmt|;
block|}
name|free_hash_table
argument_list|(
operator|&
name|set_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"CPROP of %s, pass %d: %d bytes needed, "
argument_list|,
name|current_function_name
argument_list|()
argument_list|,
name|pass
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"%d const props, %d copy props\n\n"
argument_list|,
name|const_prop_count
argument_list|,
name|copy_prop_count
argument_list|)
expr_stmt|;
block|}
comment|/* Global analysis may get into infinite loops for unreachable blocks.  */
if|if
condition|(
name|changed
operator|&&
name|cprop_jumps
condition|)
name|delete_unreachable_blocks
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Bypass conditional jumps.  */
end_comment

begin_comment
comment|/* The value of last_basic_block at the beginning of the jump_bypass    pass.  The use of redirect_edge_and_branch_force may introduce new    basic blocks, but the data flow analysis is only valid for basic    block indices less than bypass_last_basic_block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bypass_last_basic_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find a set of REGNO to a constant that is available at the end of basic    block BB.  Returns NULL if no such set is found.  Based heavily upon    find_avail_set.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|find_bypass_set
parameter_list|(
name|int
name|regno
parameter_list|,
name|int
name|bb
parameter_list|)
block|{
name|struct
name|expr
modifier|*
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rtx
name|src
decl_stmt|;
name|struct
name|expr
modifier|*
name|set
init|=
name|lookup_set
argument_list|(
name|regno
argument_list|,
operator|&
name|set_hash_table
argument_list|)
decl_stmt|;
while|while
condition|(
name|set
condition|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|cprop_avout
index|[
name|bb
index|]
argument_list|,
name|set
operator|->
name|bitmap_index
argument_list|)
condition|)
break|break;
name|set
operator|=
name|next_set
argument_list|(
name|regno
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set
operator|->
name|expr
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
operator|->
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_constant_p
argument_list|(
name|src
argument_list|)
condition|)
name|result
operator|=
name|set
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
condition|)
break|break;
name|regno
operator|=
name|REGNO
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of bypass_block that checks whether a pseudo is killed by    any of the instructions inserted on an edge.  Jump bypassing places    condition code setters on CFG edges using insert_insn_on_edge.  This    function is required to check that our data flow analysis is still    valid prior to commit_edge_insertions.  */
end_comment

begin_function
specifier|static
name|bool
name|reg_killed_on_edge
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|e
operator|->
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|reg_set_p
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of bypass_conditional_jumps that attempts to bypass the given    basic block BB which has more than one predecessor.  If not NULL, SETCC    is the first instruction of BB, which is immediately followed by JUMP_INSN    JUMP.  Otherwise, SETCC is NULL, and JUMP is the first insn of BB.    Returns nonzero if a change was made.     During the jump bypassing pass, we may place copies of SETCC instructions    on CFG edges.  The following routine must be careful to pay attention to    these inserted insns when performing its transformations.  */
end_comment

begin_function
specifier|static
name|int
name|bypass_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|rtx
name|setcc
parameter_list|,
name|rtx
name|jump
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|note
decl_stmt|;
name|edge
name|e
decl_stmt|,
name|enext
decl_stmt|,
name|edest
decl_stmt|;
name|int
name|i
decl_stmt|,
name|change
decl_stmt|;
name|int
name|may_be_loop_header
decl_stmt|;
name|insn
operator|=
operator|(
name|setcc
operator|!=
name|NULL
operator|)
condition|?
name|setcc
else|:
name|jump
expr_stmt|;
comment|/* Determine set of register uses in INSN.  */
name|reg_use_count
operator|=
literal|0
expr_stmt|;
name|note_uses
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|find_used_regs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|find_used_regs
argument_list|(
operator|&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|may_be_loop_header
operator|=
name|false
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
condition|)
block|{
name|may_be_loop_header
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|change
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|enext
control|)
block|{
name|enext
operator|=
name|e
operator|->
name|pred_next
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
condition|)
continue|continue;
comment|/* We can't redirect edges from new basic blocks.  */
if|if
condition|(
name|e
operator|->
name|src
operator|->
name|index
operator|>=
name|bypass_last_basic_block
condition|)
continue|continue;
comment|/* The irreducible loops created by redirecting of edges entering the 	 loop from outside would decrease effectiveness of some of the following 	 optimizations, so prevent this.  */
if|if
condition|(
name|may_be_loop_header
operator|&&
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_DFS_BACK
operator|)
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg_use_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|reg_use
modifier|*
name|reg_used
init|=
operator|&
name|reg_use_table
index|[
name|i
index|]
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|)
decl_stmt|;
name|basic_block
name|dest
decl_stmt|,
name|old_dest
decl_stmt|;
name|struct
name|expr
modifier|*
name|set
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|new
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|max_gcse_regno
condition|)
continue|continue;
name|set
operator|=
name|find_bypass_set
argument_list|(
name|regno
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
comment|/* Check the data flow is valid after edge insertions.  */
if|if
condition|(
name|e
operator|->
name|insns
operator|&&
name|reg_killed_on_edge
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|e
argument_list|)
condition|)
continue|continue;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setcc
operator|!=
name|NULL
condition|)
name|src
operator|=
name|simplify_replace_rtx
argument_list|(
name|src
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|setcc
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|setcc
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|simplify_replace_rtx
argument_list|(
name|src
argument_list|,
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|SET_SRC
argument_list|(
name|set
operator|->
name|expr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Jump bypassing may have already placed instructions on 	     edges of the CFG.  We can't bypass an outgoing edge that 	     has instructions associated with it, as these insns won't 	     get executed if the incoming edge is redirected.  */
if|if
condition|(
name|new
operator|==
name|pc_rtx
condition|)
block|{
name|edest
operator|=
name|FALLTHRU_EDGE
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|dest
operator|=
name|edest
operator|->
name|insns
condition|?
name|NULL
else|:
name|edest
operator|->
name|dest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|new
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|dest
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|XEXP
argument_list|(
name|new
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't bypass edges containing instructions.  */
for|for
control|(
name|edest
operator|=
name|bb
operator|->
name|succ
init|;
name|edest
condition|;
name|edest
operator|=
name|edest
operator|->
name|succ_next
control|)
if|if
condition|(
name|edest
operator|->
name|dest
operator|==
name|dest
operator|&&
name|edest
operator|->
name|insns
condition|)
block|{
name|dest
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
else|else
name|dest
operator|=
name|NULL
expr_stmt|;
comment|/* Avoid unification of the edge with other edges from original 	     branch.  We would end up emitting the instruction on "both" 	     edges.  */
if|if
condition|(
name|dest
operator|&&
name|setcc
operator|&&
operator|!
name|CC0_P
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|setcc
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|edge
name|e2
decl_stmt|;
for|for
control|(
name|e2
operator|=
name|e
operator|->
name|src
operator|->
name|succ
init|;
name|e2
condition|;
name|e2
operator|=
name|e2
operator|->
name|succ_next
control|)
if|if
condition|(
name|e2
operator|->
name|dest
operator|==
name|dest
condition|)
break|break;
if|if
condition|(
name|e2
condition|)
name|dest
operator|=
name|NULL
expr_stmt|;
block|}
name|old_dest
operator|=
name|e
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|dest
operator|!=
name|NULL
operator|&&
name|dest
operator|!=
name|old_dest
operator|&&
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* Copy the register setter to the redirected edge. 		 Don't copy CC0 setters, as CC0 is dead after jump.  */
if|if
condition|(
name|setcc
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|setcc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CC0_P
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
condition|)
name|insert_insn_on_edge
argument_list|(
name|copy_insn
argument_list|(
name|pat
argument_list|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"JUMP-BYPASS: Proved reg %d in jump_insn %d equals constant "
argument_list|,
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|SET_SRC
argument_list|(
name|set
operator|->
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\nBypass edge from %d->%d to %d\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|old_dest
operator|->
name|index
argument_list|,
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|change
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|change
return|;
block|}
end_function

begin_comment
comment|/* Find basic blocks with more than one predecessor that only contain a    single conditional jump.  If the result of the comparison is known at    compile-time from any incoming edge, redirect that edge to the    appropriate target.  Returns nonzero if a change was made.     This function is now mis-named, because we also handle indirect jumps.  */
end_comment

begin_function
specifier|static
name|int
name|bypass_conditional_jumps
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|rtx
name|setcc
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|dest
decl_stmt|;
comment|/* Note we start at block 1.  */
if|if
condition|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return
literal|0
return|;
name|bypass_last_basic_block
operator|=
name|last_basic_block
expr_stmt|;
name|mark_dfs_back_edges
argument_list|()
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR->next_bb->next_bb
argument_list|,
argument|EXIT_BLOCK_PTR
argument_list|,
argument|next_bb
argument_list|)
block|{
comment|/* Check for more than one predecessor.  */
if|if
condition|(
name|bb
operator|->
name|pred
operator|&&
name|bb
operator|->
name|pred
operator|->
name|pred_next
condition|)
block|{
name|setcc
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NULL
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
condition|)
block|{
if|if
condition|(
name|setcc
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
break|break;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|dest
argument_list|)
operator|||
name|CC0_P
argument_list|(
name|dest
argument_list|)
condition|)
name|setcc
operator|=
name|insn
expr_stmt|;
else|else
break|break;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
operator|(
name|any_condjump_p
argument_list|(
name|insn
argument_list|)
operator|||
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|onlyjump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|changed
operator||=
name|bypass_block
argument_list|(
name|bb
argument_list|,
name|setcc
argument_list|,
name|insn
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* If we bypassed any register setting insns, we inserted a      copy on the redirected edge.  These need to be committed.  */
if|if
condition|(
name|changed
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute PRE+LCM working variables.  */
end_comment

begin_comment
comment|/* Local properties of expressions.  */
end_comment

begin_comment
comment|/* Nonzero for expressions that are transparent in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|transp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are transparent at the end of the block.    This is only zero for expressions killed by abnormal critical edge    created by a calls.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|transpout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are computed (available) in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|comp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are locally anticipatable in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions where this block is an optimal computation    point.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_optimal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions which are redundant in a particular block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_redundant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions which should be inserted on a specific edge.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_insert_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions which should be deleted in a specific block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_delete_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Contains the edge_list returned by pre_edge_lcm.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|edge_list
modifier|*
name|edge_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Redundant insns.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|pre_redundant_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate vars used for PRE analysis.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_pre_mem
parameter_list|(
name|int
name|n_blocks
parameter_list|,
name|int
name|n_exprs
parameter_list|)
block|{
name|transp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|comp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|antloc
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|pre_optimal
operator|=
name|NULL
expr_stmt|;
name|pre_redundant
operator|=
name|NULL
expr_stmt|;
name|pre_insert_map
operator|=
name|NULL
expr_stmt|;
name|pre_delete_map
operator|=
name|NULL
expr_stmt|;
name|ae_in
operator|=
name|NULL
expr_stmt|;
name|ae_out
operator|=
name|NULL
expr_stmt|;
name|ae_kill
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
comment|/* pre_insert and pre_delete are allocated later.  */
block|}
end_function

begin_comment
comment|/* Free vars used for PRE analysis.  */
end_comment

begin_function
specifier|static
name|void
name|free_pre_mem
parameter_list|(
name|void
parameter_list|)
block|{
name|sbitmap_vector_free
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
comment|/* ANTLOC and AE_KILL are freed just after pre_lcm finishes.  */
if|if
condition|(
name|pre_optimal
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_optimal
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_redundant
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_redundant
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_insert_map
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_insert_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_delete_map
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_delete_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae_in
condition|)
name|sbitmap_vector_free
argument_list|(
name|ae_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae_out
condition|)
name|sbitmap_vector_free
argument_list|(
name|ae_out
argument_list|)
expr_stmt|;
name|transp
operator|=
name|comp
operator|=
name|NULL
expr_stmt|;
name|pre_optimal
operator|=
name|pre_redundant
operator|=
name|pre_insert_map
operator|=
name|pre_delete_map
operator|=
name|NULL
expr_stmt|;
name|ae_in
operator|=
name|ae_out
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level routine to do the dataflow analysis needed by PRE.  */
end_comment

begin_function
specifier|static
name|void
name|compute_pre_data
parameter_list|(
name|void
parameter_list|)
block|{
name|sbitmap
name|trapping_expr
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|int
name|ui
decl_stmt|;
name|compute_local_properties
argument_list|(
name|transp
argument_list|,
name|comp
argument_list|,
name|antloc
argument_list|,
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_kill
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* Collect expressions which might trap.  */
name|trapping_expr
operator|=
name|sbitmap_alloc
argument_list|(
name|expr_hash_table
operator|.
name|n_elems
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|trapping_expr
argument_list|)
expr_stmt|;
for|for
control|(
name|ui
operator|=
literal|0
init|;
name|ui
operator|<
name|expr_hash_table
operator|.
name|size
condition|;
name|ui
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|expr_hash_table
operator|.
name|table
index|[
name|ui
index|]
init|;
name|e
operator|!=
name|NULL
condition|;
name|e
operator|=
name|e
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|may_trap_p
argument_list|(
name|e
operator|->
name|expr
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|trapping_expr
argument_list|,
name|e
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
comment|/* Compute ae_kill for each basic block using:       ~(TRANSP | COMP)       This is significantly faster than compute_ae_kill.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|edge
name|e
decl_stmt|;
comment|/* If the current block is the destination of an abnormal edge, we 	 kill all trapping expressions because we won't be able to properly 	 place the instruction on the edge.  So make them neither 	 anticipatable nor transparent.  This is fairly conservative.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
name|sbitmap_difference
argument_list|(
name|antloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|antloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|trapping_expr
argument_list|)
expr_stmt|;
name|sbitmap_difference
argument_list|(
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|trapping_expr
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbitmap_a_or_b
argument_list|(
name|ae_kill
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|comp
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbitmap_not
argument_list|(
name|ae_kill
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|ae_kill
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|edge_list
operator|=
name|pre_edge_lcm
argument_list|(
name|gcse_file
argument_list|,
name|expr_hash_table
operator|.
name|n_elems
argument_list|,
name|transp
argument_list|,
name|comp
argument_list|,
name|antloc
argument_list|,
name|ae_kill
argument_list|,
operator|&
name|pre_insert_map
argument_list|,
operator|&
name|pre_delete_map
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|antloc
argument_list|)
expr_stmt|;
name|antloc
operator|=
name|NULL
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|ae_kill
argument_list|)
expr_stmt|;
name|ae_kill
operator|=
name|NULL
expr_stmt|;
name|sbitmap_free
argument_list|(
name|trapping_expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* PRE utilities */
end_comment

begin_comment
comment|/* Return nonzero if an occurrence of expression EXPR in OCCR_BB would reach    block BB.     VISITED is a pointer to a working buffer for tracking which BB's have    been visited.  It is NULL for the top-level call.     We treat reaching expressions that go through blocks containing the same    reaching expression as "not reaching".  E.g. if EXPR is generated in blocks    2 and 3, INSN is in block 4, and 2->3->4, we treat the expression in block    2 as not reaching.  The intent is to improve the probability of finding    only one reaching expression and to reduce register lifetimes by picking    the closest such expression.  */
end_comment

begin_function
specifier|static
name|int
name|pre_expr_reaches_here_p_work
parameter_list|(
name|basic_block
name|occr_bb
parameter_list|,
name|struct
name|expr
modifier|*
name|expr
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|char
modifier|*
name|visited
parameter_list|)
block|{
name|edge
name|pred
decl_stmt|;
for|for
control|(
name|pred
operator|=
name|bb
operator|->
name|pred
init|;
name|pred
operator|!=
name|NULL
condition|;
name|pred
operator|=
name|pred
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|pred_bb
init|=
name|pred
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|pred
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
comment|/* Has predecessor has already been visited?  */
operator|||
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
condition|)
empty_stmt|;
comment|/* Nothing to do.  */
comment|/* Does this predecessor generate this expression?  */
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|comp
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
block|{
comment|/* Is this the occurrence we're looking for? 	     Note that there's only one generating occurrence per block 	     so we just need to check the block number.  */
if|if
condition|(
name|occr_bb
operator|==
name|pred_bb
condition|)
return|return
literal|1
return|;
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Ignore this predecessor if it kills the expression.  */
elseif|else
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|transp
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Neither gen nor kill.  */
else|else
block|{
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pre_expr_reaches_here_p_work
argument_list|(
name|occr_bb
argument_list|,
name|expr
argument_list|,
name|pred_bb
argument_list|,
name|visited
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* All paths have been checked.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The wrapper for pre_expr_reaches_here_work that ensures that any    memory allocated for that function is returned.  */
end_comment

begin_function
specifier|static
name|int
name|pre_expr_reaches_here_p
parameter_list|(
name|basic_block
name|occr_bb
parameter_list|,
name|struct
name|expr
modifier|*
name|expr
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|visited
init|=
name|xcalloc
argument_list|(
name|last_basic_block
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|rval
operator|=
name|pre_expr_reaches_here_p_work
argument_list|(
name|occr_bb
argument_list|,
name|expr
argument_list|,
name|bb
argument_list|,
name|visited
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expr, generate RTL which we can insert at the end of a BB,    or on an edge.  Set the block number of any insns generated to    the value of BB.  */
end_comment

begin_function
specifier|static
name|rtx
name|process_insert_insn
parameter_list|(
name|struct
name|expr
modifier|*
name|expr
parameter_list|)
block|{
name|rtx
name|reg
init|=
name|expr
operator|->
name|reaching_reg
decl_stmt|;
name|rtx
name|exp
init|=
name|copy_rtx
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* If the expression is something that's an operand, like a constant,      just copy it to a register.  */
if|if
condition|(
name|general_operand
argument_list|(
name|exp
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|exp
argument_list|)
expr_stmt|;
comment|/* Otherwise, make a new insn to compute this expression and make sure the      insn will be recognized (this also adds any needed CLOBBERs).  Copy the      expression to make sure we don't have any sharing issues.  */
elseif|else
if|if
condition|(
name|insn_invalid_p
argument_list|(
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|exp
argument_list|)
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pat
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
return|return
name|pat
return|;
block|}
end_function

begin_comment
comment|/* Add EXPR to the end of basic block BB.     This is used by both the PRE and code hoisting.     For PRE, we want to verify that the expr is either transparent    or locally anticipatable in the target block.  This check makes    no sense for code hoisting.  */
end_comment

begin_function
specifier|static
name|void
name|insert_insn_end_bb
parameter_list|(
name|struct
name|expr
modifier|*
name|expr
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
name|pre
parameter_list|)
block|{
name|rtx
name|insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|new_insn
decl_stmt|;
name|rtx
name|reg
init|=
name|expr
operator|->
name|reaching_reg
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|pat_end
decl_stmt|;
name|pat
operator|=
name|process_insert_insn
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
operator|==
name|NULL_RTX
operator|||
operator|!
name|INSN_P
argument_list|(
name|pat
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|pat_end
operator|=
name|pat
expr_stmt|;
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|pat_end
argument_list|)
operator|!=
name|NULL_RTX
condition|)
name|pat_end
operator|=
name|NEXT_INSN
argument_list|(
name|pat_end
argument_list|)
expr_stmt|;
comment|/* If the last insn is a jump, insert EXPR in front [taking care to      handle cc0, etc. properly].  Similarly we need to care trapping      instructions in presence of non-call exceptions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|||
operator|(
name|bb
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|note
decl_stmt|;
endif|#
directive|endif
comment|/* It should always be the case that we can put these instructions 	 anywhere in the basic block with performing PRE optimizations. 	 Check this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|pre
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|antloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If this is a jump table, then we can't insert stuff here.  Since 	 we know the previous real insn must be the tablejump, we insert 	 the new instruction just before the tablejump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|insn
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* FIXME: 'twould be nice to call prev_cc0_setter here but it aborts 	 if cc0 isn't set.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|maybe_cc0_setter
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|maybe_cc0_setter
operator|&&
name|INSN_P
argument_list|(
name|maybe_cc0_setter
argument_list|)
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|maybe_cc0_setter
argument_list|)
argument_list|)
condition|)
name|insn
operator|=
name|maybe_cc0_setter
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FIXME: What if something in cc0/jump uses value set in new insn?  */
name|new_insn
operator|=
name|emit_insn_before_noloc
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise if the last insn is a call, as will happen in the presence      of exception handling.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|||
operator|(
name|bb
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|)
condition|)
block|{
comment|/* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers, 	 we search backward and place the instructions before the first 	 parameter is loaded.  Do this for everyone for consistency and a 	 presumption that we'll get better code elsewhere as well.  	 It should always be the case that we can put these instructions 	 anywhere in the basic block with performing PRE optimizations. 	 Check this.  */
if|if
condition|(
name|pre
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|antloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Since different machines initialize their parameter registers 	 in different orders, assume nothing.  Collect the set of all 	 parameter registers.  */
name|insn
operator|=
name|find_first_parameter_load
argument_list|(
name|insn
argument_list|,
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we found all the parameter loads, then we want to insert 	 before the first parameter load.  	 If we did not find all the parameter loads, then we might have 	 stopped on the head of the block, which could be a CODE_LABEL. 	 If we inserted before the CODE_LABEL, then we would be putting 	 the insn in the wrong basic block.  In that case, put the insn 	 after the CODE_LABEL.  Also, respect NOTE_INSN_BASIC_BLOCK.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_before_noloc
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
name|new_insn
operator|=
name|emit_insn_after_noloc
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|pat
argument_list|)
condition|)
block|{
name|add_label_notes
argument_list|(
name|PATTERN
argument_list|(
name|pat
argument_list|)
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|pat
argument_list|)
argument_list|,
name|record_set_info
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pat
operator|==
name|pat_end
condition|)
break|break;
name|pat
operator|=
name|NEXT_INSN
argument_list|(
name|pat
argument_list|)
expr_stmt|;
block|}
name|gcse_create_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE/HOIST: end of bb %d, insn %d, "
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|INSN_UID
argument_list|(
name|new_insn
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"copying expression %d to reg %d\n"
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert partially redundant expressions on edges in the CFG to make    the expressions fully redundant.  */
end_comment

begin_function
specifier|static
name|int
name|pre_edge_insert
parameter_list|(
name|struct
name|edge_list
modifier|*
name|edge_list
parameter_list|,
name|struct
name|expr
modifier|*
modifier|*
name|index_map
parameter_list|)
block|{
name|int
name|e
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|num_edges
decl_stmt|,
name|set_size
decl_stmt|,
name|did_insert
init|=
literal|0
decl_stmt|;
name|sbitmap
modifier|*
name|inserted
decl_stmt|;
comment|/* Where PRE_INSERT_MAP is nonzero, we add the expression on that edge      if it reaches any of the deleted expressions.  */
name|set_size
operator|=
name|pre_insert_map
index|[
literal|0
index|]
operator|->
name|size
expr_stmt|;
name|num_edges
operator|=
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|inserted
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|num_edges
argument_list|,
name|expr_hash_table
operator|.
name|n_elems
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|inserted
argument_list|,
name|num_edges
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
literal|0
init|;
name|e
operator|<
name|num_edges
condition|;
name|e
operator|++
control|)
block|{
name|int
name|indx
decl_stmt|;
name|basic_block
name|bb
init|=
name|INDEX_EDGE_PRED_BB
argument_list|(
name|edge_list
argument_list|,
name|e
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indx
operator|=
literal|0
init|;
name|i
operator|<
name|set_size
condition|;
name|i
operator|++
operator|,
name|indx
operator|+=
name|SBITMAP_ELT_BITS
control|)
block|{
name|SBITMAP_ELT_TYPE
name|insert
init|=
name|pre_insert_map
index|[
name|e
index|]
operator|->
name|elms
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
name|indx
init|;
name|insert
operator|&&
name|j
operator|<
operator|(
name|int
operator|)
name|expr_hash_table
operator|.
name|n_elems
condition|;
name|j
operator|++
operator|,
name|insert
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|insert
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|index_map
index|[
name|j
index|]
operator|->
name|reaching_reg
operator|!=
name|NULL_RTX
condition|)
block|{
name|struct
name|expr
modifier|*
name|expr
init|=
name|index_map
index|[
name|j
index|]
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
comment|/* Now look at each deleted occurrence of this expression.  */
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|occr
operator|->
name|deleted_p
condition|)
continue|continue;
comment|/* Insert this expression on this edge if if it would 		       reach the deleted occurrence in BB.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|inserted
index|[
name|e
index|]
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
name|edge
name|eg
init|=
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|e
argument_list|)
decl_stmt|;
comment|/* We can't insert anything on an abnormal and 			   critical edge, so we insert the insn at the end of 			   the previous block. There are several alternatives 			   detailed in Morgans book P277 (sec 10.5) for 			   handling this situation.  This one is easiest for 			   now.  */
if|if
condition|(
operator|(
name|eg
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
name|EDGE_ABNORMAL
condition|)
name|insert_insn_end_bb
argument_list|(
name|index_map
index|[
name|j
index|]
argument_list|,
name|bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|process_insert_insn
argument_list|(
name|index_map
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|insert_insn_on_edge
argument_list|(
name|insn
argument_list|,
name|eg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE/HOIST: edge (%d,%d), "
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|INDEX_EDGE_SUCC_BB
argument_list|(
name|edge_list
argument_list|,
name|e
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"copy expression %d\n"
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
name|update_ld_motion_stores
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|inserted
index|[
name|e
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|did_insert
operator|=
literal|1
expr_stmt|;
name|gcse_create_count
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|sbitmap_vector_free
argument_list|(
name|inserted
argument_list|)
expr_stmt|;
return|return
name|did_insert
return|;
block|}
end_function

begin_comment
comment|/* Copy the result of EXPR->EXPR generated by INSN to EXPR->REACHING_REG.    Given "old_reg<- expr" (INSN), instead of adding after it      reaching_reg<- old_reg    it's better to do the following:      reaching_reg<- expr      old_reg<- reaching_reg    because this way copy propagation can discover additional PRE    opportunities.  But if this fails, we try the old way.    When "expr" is a store, i.e.    given "MEM<- old_reg", instead of adding after it      reaching_reg<- old_reg    it's better to add it before as follows:      reaching_reg<- old_reg      MEM<- reaching_reg.  */
end_comment

begin_function
specifier|static
name|void
name|pre_insert_copy_insn
parameter_list|(
name|struct
name|expr
modifier|*
name|expr
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|reg
init|=
name|expr
operator|->
name|reaching_reg
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|indx
init|=
name|expr
operator|->
name|bitmap_index
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|new_insn
decl_stmt|;
name|rtx
name|old_reg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* This block matches the logic in hash_scan_insn.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
name|set
operator|=
name|pat
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* Search through the parallel looking for the set whose 	 source was the expression that we're interested in.  */
name|set
operator|=
name|NULL_RTX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
name|expr_equiv_p
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|expr
operator|->
name|expr
argument_list|)
condition|)
block|{
name|set
operator|=
name|x
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|old_reg
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* Check if we can modify the set destination in the original insn.  */
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|new_insn
operator|=
name|gen_move_insn
argument_list|(
name|old_reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_after
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Keep register set table up to date.  */
name|replace_one_set
argument_list|(
name|REGNO
argument_list|(
name|old_reg
argument_list|)
argument_list|,
name|insn
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
name|record_one_set
argument_list|(
name|regno
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_insn
operator|=
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|old_reg
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_after
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Keep register set table up to date.  */
name|record_one_set
argument_list|(
name|regno
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* This is possible only in case of a store to memory.  */
block|{
name|old_reg
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|new_insn
operator|=
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|old_reg
argument_list|)
expr_stmt|;
comment|/* Check if we can modify the set source in the original insn.  */
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
condition|)
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
else|else
name|new_insn
operator|=
name|emit_insn_after
argument_list|(
name|new_insn
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Keep register set table up to date.  */
name|record_one_set
argument_list|(
name|regno
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
block|}
name|gcse_create_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE: bb %d, insn %d, copy expression %d in insn %d to reg %d\n"
argument_list|,
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|new_insn
argument_list|)
argument_list|,
name|indx
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy available expressions that reach the redundant expression    to `reaching_reg'.  */
end_comment

begin_function
specifier|static
name|void
name|pre_insert_copies
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|added_copy
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|struct
name|occr
modifier|*
name|avail
decl_stmt|;
comment|/* For each available expression in the table, copy the result to      `reaching_reg' if the expression reaches a deleted one.       ??? The current algorithm is rather brute force.      Need to do some profiling.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table
operator|.
name|size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
operator|.
name|table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
comment|/* If the basic block isn't reachable, PPOUT will be TRUE.  However, 	   we don't want to insert a copy here because the expression may not 	   really be redundant.  So only insert an insn if the expression was 	   deleted.  This test also avoids further processing if the 	   expression wasn't deleted anywhere.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Set when we add a copy for that expression.  */
name|added_copy
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|occr
operator|->
name|deleted_p
condition|)
continue|continue;
for|for
control|(
name|avail
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|avail
operator|!=
name|NULL
condition|;
name|avail
operator|=
name|avail
operator|->
name|next
control|)
block|{
name|rtx
name|insn
init|=
name|avail
operator|->
name|insn
decl_stmt|;
comment|/* No need to handle this one if handled already.  */
if|if
condition|(
name|avail
operator|->
name|copied_p
condition|)
continue|continue;
comment|/* Don't handle this one if it's a redundant one.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pre_redundant_insns
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Or if the expression doesn't reach the deleted one.  */
if|if
condition|(
operator|!
name|pre_expr_reaches_here_p
argument_list|(
name|BLOCK_FOR_INSN
argument_list|(
name|avail
operator|->
name|insn
argument_list|)
argument_list|,
name|expr
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
argument_list|)
condition|)
continue|continue;
name|added_copy
operator|=
literal|1
expr_stmt|;
comment|/* Copy the result of avail to reaching_reg.  */
name|pre_insert_copy_insn
argument_list|(
name|expr
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|avail
operator|->
name|copied_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|added_copy
condition|)
name|update_ld_motion_stores
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit move from SRC to DEST noting the equivalence with expression computed    in INSN.  */
end_comment

begin_function
specifier|static
name|rtx
name|gcse_emit_move_after
parameter_list|(
name|rtx
name|src
parameter_list|,
name|rtx
name|dest
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|new
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|,
name|set2
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|eqv
decl_stmt|;
comment|/* This should never fail since we're creating a reg->reg copy      we've verified to be valid.  */
name|new
operator|=
name|emit_insn_after
argument_list|(
name|gen_move_insn
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Note the equivalence for local CSE pass.  */
name|set2
operator|=
name|single_set
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set2
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|SET_DEST
argument_list|(
name|set2
argument_list|)
argument_list|,
name|dest
argument_list|)
condition|)
return|return
name|new
return|;
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
operator|)
condition|)
name|eqv
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|eqv
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|set_unique_reg_note
argument_list|(
name|new
argument_list|,
name|REG_EQUAL
argument_list|,
name|copy_insn_1
argument_list|(
name|eqv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Delete redundant computations.    Deletion is done by changing the insn to copy the `reaching_reg' of    the expression into the result of the SET.  It is left to later passes    (cprop, cse2, flow, combine, regmove) to propagate the copy or eliminate it.     Returns nonzero if a change is made.  */
end_comment

begin_function
specifier|static
name|int
name|pre_delete
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table
operator|.
name|size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
operator|.
name|table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
name|int
name|indx
init|=
name|expr
operator|->
name|bitmap_index
decl_stmt|;
comment|/* We only need to search antic_occr since we require 	   ANTLOC != 0.  */
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
name|rtx
name|insn
init|=
name|occr
operator|->
name|insn
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* We only delete insns that have a single_set.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pre_delete_map
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|indx
argument_list|)
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Create a pseudo-reg to store the result of reaching 		   expressions into.  Get the mode for the new pseudo from 		   the mode of the original destination pseudo.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL
condition|)
name|expr
operator|->
name|reaching_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcse_emit_move_after
argument_list|(
name|expr
operator|->
name|reaching_reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|occr
operator|->
name|deleted_p
operator|=
literal|1
expr_stmt|;
name|SET_BIT
argument_list|(
name|pre_redundant_insns
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|gcse_subst_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE: redundant insn %d (expression %d) in "
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|indx
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"bb %d, reaching reg is %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|REGNO
argument_list|(
name|expr
operator|->
name|reaching_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Perform GCSE optimizations using PRE.    This is called by one_pre_gcse_pass after all the dataflow analysis    has been done.     This is based on the original Morel-Renvoise paper Fred Chow's thesis, and    lazy code motion from Knoop, Ruthing and Steffen as described in Advanced    Compiler Design and Implementation.     ??? A new pseudo reg is created to hold the reaching expression.  The nice    thing about the classical approach is that it would try to use an existing    reg.  If the register can't be adequately optimized [i.e. we introduce    reload problems], one could add a pass here to propagate the new register    through the block.     ??? We don't handle single sets in PARALLELs because we're [currently] not    able to copy the rest of the parallel when we insert copies to create full    redundancies from partial redundancies.  However, there's no reason why we    can't handle PARALLELs in the cases where there are no partial    redundancies.  */
end_comment

begin_function
specifier|static
name|int
name|pre_gcse
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|did_insert
decl_stmt|,
name|changed
decl_stmt|;
name|struct
name|expr
modifier|*
modifier|*
name|index_map
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
comment|/* Compute a mapping from expression number (`bitmap_index') to      hash table entry.  */
name|index_map
operator|=
name|xcalloc
argument_list|(
name|expr_hash_table
operator|.
name|n_elems
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table
operator|.
name|size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
operator|.
name|table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
name|index_map
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|expr
expr_stmt|;
comment|/* Reset bitmap used to track which insns are redundant.  */
name|pre_redundant_insns
operator|=
name|sbitmap_alloc
argument_list|(
name|max_cuid
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|pre_redundant_insns
argument_list|)
expr_stmt|;
comment|/* Delete the redundant insns first so that      - we know what register to use for the new insns and for the other        ones with reaching expressions      - we know which insns are redundant when we go to create copies  */
name|changed
operator|=
name|pre_delete
argument_list|()
expr_stmt|;
name|did_insert
operator|=
name|pre_edge_insert
argument_list|(
name|edge_list
argument_list|,
name|index_map
argument_list|)
expr_stmt|;
comment|/* In other places with reaching expressions, copy the expression to the      specially allocated pseudo-reg that reaches the redundant expr.  */
name|pre_insert_copies
argument_list|()
expr_stmt|;
if|if
condition|(
name|did_insert
condition|)
block|{
name|commit_edge_insertions
argument_list|()
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|index_map
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|pre_redundant_insns
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Top level routine to perform one PRE GCSE pass.     Return nonzero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|one_pre_gcse_pass
parameter_list|(
name|int
name|pass
parameter_list|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|gcse_subst_count
operator|=
literal|0
expr_stmt|;
name|gcse_create_count
operator|=
literal|0
expr_stmt|;
name|alloc_hash_table
argument_list|(
name|max_cuid
argument_list|,
operator|&
name|expr_hash_table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_gcse_lm
condition|)
name|compute_ld_motion_mems
argument_list|()
expr_stmt|;
name|compute_hash_table
argument_list|(
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
name|trim_ld_motion_mems
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|dump_hash_table
argument_list|(
name|gcse_file
argument_list|,
literal|"Expression"
argument_list|,
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr_hash_table
operator|.
name|n_elems
operator|>
literal|0
condition|)
block|{
name|alloc_pre_mem
argument_list|(
name|last_basic_block
argument_list|,
name|expr_hash_table
operator|.
name|n_elems
argument_list|)
expr_stmt|;
name|compute_pre_data
argument_list|()
expr_stmt|;
name|changed
operator||=
name|pre_gcse
argument_list|()
expr_stmt|;
name|free_edge_list
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|free_pre_mem
argument_list|()
expr_stmt|;
block|}
name|free_ldst_mems
argument_list|()
expr_stmt|;
name|remove_fake_edges
argument_list|()
expr_stmt|;
name|free_hash_table
argument_list|(
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\nPRE GCSE of %s, pass %d: %d bytes needed, "
argument_list|,
name|current_function_name
argument_list|()
argument_list|,
name|pass
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"%d substs, %d insns created\n"
argument_list|,
name|gcse_subst_count
argument_list|,
name|gcse_create_count
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X contains any LABEL_REF's, add REG_LABEL notes for them to INSN.    If notes are added to an insn which references a CODE_LABEL, the    LABEL_NUSES count is incremented.  We have to add REG_LABEL notes,    because the following loop optimization pass requires them.  */
end_comment

begin_comment
comment|/* ??? This is very similar to the loop.c add_label_notes function.  We    could probably share code here.  */
end_comment

begin_comment
comment|/* ??? If there was a jump optimization pass after gcse and before loop,    then we would not need to do this here, because jump would add the    necessary REG_LABEL notes.  */
end_comment

begin_function
specifier|static
name|void
name|add_label_notes
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
operator|&&
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* This code used to ignore labels that referred to dispatch tables to 	 avoid flow generating (slightly) worse code.  	 We no longer ignore such label references (see LABEL_REF handling in 	 mark_jump_label for additional information).  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|LABEL_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|++
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
operator|,
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|add_label_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|add_label_notes
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute transparent outgoing information for each block.     An expression is transparent to an edge unless it is killed by    the edge itself.  This can only happen with abnormal control flow,    when the edge is traversed through a call.  This happens with    non-local labels and exceptions.     This would not be necessary if we split the edge.  While this is    normally impossible for abnormal critical edges, with some effort    it should be possible with exception handling, since we still have    control over which handler should be invoked.  But due to increased    EH table sizes, this may not be worthwhile.  */
end_comment

begin_function
specifier|static
name|void
name|compute_transpout
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|transpout
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
comment|/* Note that flow inserted a nop a the end of basic blocks that 	 end in call instructions for reasons other than abnormal 	 control flow.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|!=
name|CALL_INSN
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table
operator|.
name|size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
operator|.
name|table
index|[
name|i
index|]
init|;
name|expr
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* ??? Optimally, we would use interprocedural alias 		 analysis to determine if this mem is actually killed 		 by this call.  */
name|RESET_BIT
argument_list|(
name|transpout
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Removal of useless null pointer checks */
end_comment

begin_comment
comment|/* Called via note_stores.  X is set by SETTER.  If X is a register we must    invalidate nonnull_local and set nonnull_killed.  DATA is really a    `null_pointer_info *'.     We ignore hard registers.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_nonnull_info
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
name|struct
name|null_pointer_info
modifier|*
name|npi
init|=
operator|(
expr|struct
name|null_pointer_info
operator|*
operator|)
name|data
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SUBREG
condition|)
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Ignore anything that is not a register or is a hard register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|<
name|npi
operator|->
name|min_reg
operator|||
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|npi
operator|->
name|max_reg
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
operator|-
name|npi
operator|->
name|min_reg
expr_stmt|;
name|RESET_BIT
argument_list|(
name|npi
operator|->
name|nonnull_local
index|[
name|npi
operator|->
name|current_block
operator|->
name|index
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|npi
operator|->
name|nonnull_killed
index|[
name|npi
operator|->
name|current_block
operator|->
name|index
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do null-pointer check elimination for the registers indicated in    NPI.  NONNULL_AVIN and NONNULL_AVOUT are pre-allocated sbitmaps;    they are not our responsibility to free.  */
end_comment

begin_function
specifier|static
name|int
name|delete_null_pointer_checks_1
parameter_list|(
name|unsigned
name|int
modifier|*
name|block_reg
parameter_list|,
name|sbitmap
modifier|*
name|nonnull_avin
parameter_list|,
name|sbitmap
modifier|*
name|nonnull_avout
parameter_list|,
name|struct
name|null_pointer_info
modifier|*
name|npi
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|current_block
decl_stmt|;
name|sbitmap
modifier|*
name|nonnull_local
init|=
name|npi
operator|->
name|nonnull_local
decl_stmt|;
name|sbitmap
modifier|*
name|nonnull_killed
init|=
name|npi
operator|->
name|nonnull_killed
decl_stmt|;
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
comment|/* Compute local properties, nonnull and killed.  A register will have      the nonnull property if at the end of the current block its value is      known to be nonnull.  The killed property indicates that somewhere in      the block any information we had about the register is killed.       Note that a register can have both properties in a single block.  That      indicates that it's killed, then later in the block a new value is      computed.  */
name|sbitmap_vector_zero
argument_list|(
name|nonnull_local
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|nonnull_killed
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|current_block
argument_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|stop_insn
decl_stmt|;
comment|/* Set the current block for invalidate_nonnull_info.  */
name|npi
operator|->
name|current_block
operator|=
name|current_block
expr_stmt|;
comment|/* Scan each insn in the basic block looking for memory references and 	 register sets.  */
name|stop_insn
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|current_block
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|current_block
argument_list|)
init|;
name|insn
operator|!=
name|stop_insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|rtx
name|set
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
comment|/* Ignore anything that is not a normal insn.  */
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Basically ignore anything that is not a simple SET.  We do have 	     to make sure to invalidate nonnull_local and set nonnull_killed 	     for such insns though.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|invalidate_nonnull_info
argument_list|,
name|npi
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* See if we've got a usable memory load.  We handle it first 	     in case it uses its address register as a dest (which kills 	     the nonnull property).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
operator|(
name|reg
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|npi
operator|->
name|min_reg
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|npi
operator|->
name|max_reg
condition|)
name|SET_BIT
argument_list|(
name|nonnull_local
index|[
name|current_block
operator|->
name|index
index|]
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|-
name|npi
operator|->
name|min_reg
argument_list|)
expr_stmt|;
comment|/* Now invalidate stuff clobbered by this insn.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|invalidate_nonnull_info
argument_list|,
name|npi
argument_list|)
expr_stmt|;
comment|/* And handle stores, we do these last since any sets in INSN can 	     not kill the nonnull property if it is derived from a MEM 	     appearing in a SET_DEST.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
operator|(
name|reg
operator|=
name|XEXP
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|npi
operator|->
name|min_reg
operator|&&
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|<
name|npi
operator|->
name|max_reg
condition|)
name|SET_BIT
argument_list|(
name|nonnull_local
index|[
name|current_block
operator|->
name|index
index|]
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|-
name|npi
operator|->
name|min_reg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now compute global properties based on the local properties.   This      is a classic global availability algorithm.  */
name|compute_available
argument_list|(
name|nonnull_local
argument_list|,
name|nonnull_killed
argument_list|,
name|nonnull_avout
argument_list|,
name|nonnull_avin
argument_list|)
expr_stmt|;
comment|/* Now look at each bb and see if it ends with a compare of a value      against zero.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|last_insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|condition
decl_stmt|,
name|earliest
decl_stmt|;
name|int
name|compare_and_branch
decl_stmt|;
comment|/* Since MIN_REG is always at least FIRST_PSEUDO_REGISTER, and 	 since BLOCK_REG[BB] is zero if this block did not end with a 	 comparison against zero, this condition works.  */
if|if
condition|(
name|block_reg
index|[
name|bb
operator|->
name|index
index|]
operator|<
name|npi
operator|->
name|min_reg
operator|||
name|block_reg
index|[
name|bb
operator|->
name|index
index|]
operator|>=
name|npi
operator|->
name|max_reg
condition|)
continue|continue;
comment|/* LAST_INSN is a conditional jump.  Get its condition.  */
name|condition
operator|=
name|get_condition
argument_list|(
name|last_insn
argument_list|,
operator|&
name|earliest
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If we can't determine the condition then skip.  */
if|if
condition|(
operator|!
name|condition
condition|)
continue|continue;
comment|/* Is the register known to have a nonzero value?  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|nonnull_avout
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|block_reg
index|[
name|bb
operator|->
name|index
index|]
operator|-
name|npi
operator|->
name|min_reg
argument_list|)
condition|)
continue|continue;
comment|/* Try to compute whether the compare/branch at the loop end is one or 	 two instructions.  */
if|if
condition|(
name|earliest
operator|==
name|last_insn
condition|)
name|compare_and_branch
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|earliest
operator|==
name|prev_nonnote_insn
argument_list|(
name|last_insn
argument_list|)
condition|)
name|compare_and_branch
operator|=
literal|2
expr_stmt|;
else|else
continue|continue;
comment|/* We know the register in this comparison is nonnull at exit from 	 this block.  We can optimize this comparison.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
operator|==
name|NE
condition|)
block|{
name|rtx
name|new_jump
decl_stmt|;
name|new_jump
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|JUMP_LABEL
argument_list|(
name|last_insn
argument_list|)
argument_list|)
argument_list|,
name|last_insn
argument_list|)
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|new_jump
argument_list|)
operator|=
name|JUMP_LABEL
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|new_jump
argument_list|)
argument_list|)
operator|++
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|new_jump
argument_list|)
expr_stmt|;
block|}
name|something_changed
operator|=
literal|1
expr_stmt|;
name|delete_insn
argument_list|(
name|last_insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|compare_and_branch
operator|==
literal|2
condition|)
name|delete_insn
argument_list|(
name|earliest
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|purge_dead_edges
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Don't check this block again.  (Note that BB_END is 	 invalid here; we deleted the last instruction in the 	 block.)  */
name|block_reg
index|[
name|bb
operator|->
name|index
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|something_changed
return|;
block|}
end_function

begin_comment
comment|/* Find EQ/NE comparisons against zero which can be (indirectly) evaluated    at compile time.     This is conceptually similar to global constant/copy propagation and    classic global CSE (it even uses the same dataflow equations as cprop).     If a register is used as memory address with the form (mem (reg)), then we    know that REG can not be zero at that point in the program.  Any instruction    which sets REG "kills" this property.     So, if every path leading to a conditional branch has an available memory    reference of that form, then we know the register can not have the value    zero at the conditional branch.     So we merely need to compute the local properties and propagate that data    around the cfg, then optimize where possible.     We run this pass two times.  Once before CSE, then again after CSE.  This    has proven to be the most profitable approach.  It is rare for new    optimization opportunities of this nature to appear after the first CSE    pass.     This could probably be integrated with global cprop with a little work.  */
end_comment

begin_function
name|int
name|delete_null_pointer_checks
parameter_list|(
name|rtx
name|f
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|sbitmap
modifier|*
name|nonnull_avin
decl_stmt|,
modifier|*
name|nonnull_avout
decl_stmt|;
name|unsigned
name|int
modifier|*
name|block_reg
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|regs_per_pass
decl_stmt|;
name|int
name|max_reg
init|=
name|max_reg_num
argument_list|()
decl_stmt|;
name|struct
name|null_pointer_info
name|npi
decl_stmt|;
name|int
name|something_changed
init|=
literal|0
decl_stmt|;
comment|/* If we have only a single block, or it is too expensive, give up.  */
if|if
condition|(
name|n_basic_blocks
operator|<=
literal|1
operator|||
name|is_too_expensive
argument_list|(
name|_
argument_list|(
literal|"NULL pointer checks disabled"
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We need four bitmaps, each with a bit for each register in each      basic block.  */
name|regs_per_pass
operator|=
name|get_bitmap_width
argument_list|(
literal|4
argument_list|,
name|last_basic_block
argument_list|,
name|max_reg
argument_list|)
expr_stmt|;
comment|/* Allocate bitmaps to hold local and global properties.  */
name|npi
operator|.
name|nonnull_local
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|regs_per_pass
argument_list|)
expr_stmt|;
name|npi
operator|.
name|nonnull_killed
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|regs_per_pass
argument_list|)
expr_stmt|;
name|nonnull_avin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|regs_per_pass
argument_list|)
expr_stmt|;
name|nonnull_avout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|regs_per_pass
argument_list|)
expr_stmt|;
comment|/* Go through the basic blocks, seeing whether or not each block      ends with a conditional branch whose condition is a comparison      against zero.  Record the register compared in BLOCK_REG.  */
name|block_reg
operator|=
name|xcalloc
argument_list|(
name|last_basic_block
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|rtx
name|last_insn
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|condition
decl_stmt|,
name|earliest
decl_stmt|,
name|reg
decl_stmt|;
comment|/* We only want conditional branches.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|last_insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|||
operator|!
name|any_condjump_p
argument_list|(
name|last_insn
argument_list|)
operator|||
operator|!
name|onlyjump_p
argument_list|(
name|last_insn
argument_list|)
condition|)
continue|continue;
comment|/* LAST_INSN is a conditional jump.  Get its condition.  */
name|condition
operator|=
name|get_condition
argument_list|(
name|last_insn
argument_list|,
operator|&
name|earliest
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* If we were unable to get the condition, or it is not an equality 	 comparison against zero then there's nothing we can do.  */
if|if
condition|(
operator|!
name|condition
operator|||
operator|(
name|GET_CODE
argument_list|(
name|condition
argument_list|)
operator|!=
name|NE
operator|&&
name|GET_CODE
argument_list|(
name|condition
argument_list|)
operator|!=
name|EQ
operator|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
operator|||
operator|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
operator|!=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* We must be checking a register against zero.  */
name|reg
operator|=
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|REG
condition|)
continue|continue;
name|block_reg
index|[
name|bb
operator|->
name|index
index|]
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* Go through the algorithm for each block of registers.  */
for|for
control|(
name|reg
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|reg
operator|<
name|max_reg
condition|;
name|reg
operator|+=
name|regs_per_pass
control|)
block|{
name|npi
operator|.
name|min_reg
operator|=
name|reg
expr_stmt|;
name|npi
operator|.
name|max_reg
operator|=
name|MIN
argument_list|(
name|reg
operator|+
name|regs_per_pass
argument_list|,
name|max_reg
argument_list|)
expr_stmt|;
name|something_changed
operator||=
name|delete_null_pointer_checks_1
argument_list|(
name|block_reg
argument_list|,
name|nonnull_avin
argument_list|,
name|nonnull_avout
argument_list|,
operator|&
name|npi
argument_list|)
expr_stmt|;
block|}
comment|/* Free the table of registers compared at the end of every block.  */
name|free
argument_list|(
name|block_reg
argument_list|)
expr_stmt|;
comment|/* Free bitmaps.  */
name|sbitmap_vector_free
argument_list|(
name|npi
operator|.
name|nonnull_local
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|npi
operator|.
name|nonnull_killed
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|nonnull_avin
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|nonnull_avout
argument_list|)
expr_stmt|;
return|return
name|something_changed
return|;
block|}
end_function

begin_comment
comment|/* Code Hoisting variables and subroutines.  */
end_comment

begin_comment
comment|/* Very busy expressions.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|hoist_vbein
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|hoist_vbeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hoistable expressions.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|hoist_exprs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ??? We could compute post dominators and run this algorithm in    reverse to perform tail merging, doing so would probably be    more effective than the tail merging code in jump.c.     It's unclear if tail merging could be run in parallel with    code hoisting.  It would be nice.  */
end_comment

begin_comment
comment|/* Allocate vars used for code hoisting analysis.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_code_hoist_mem
parameter_list|(
name|int
name|n_blocks
parameter_list|,
name|int
name|n_exprs
parameter_list|)
block|{
name|antloc
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|transp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|comp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|hoist_vbein
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|hoist_vbeout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|hoist_exprs
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|transpout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free vars used for code hoisting analysis.  */
end_comment

begin_function
specifier|static
name|void
name|free_code_hoist_mem
parameter_list|(
name|void
parameter_list|)
block|{
name|sbitmap_vector_free
argument_list|(
name|antloc
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|hoist_vbein
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|hoist_vbeout
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|hoist_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_free
argument_list|(
name|transpout
argument_list|)
expr_stmt|;
name|free_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the very busy expressions at entry/exit from each block.     An expression is very busy if all paths from a given point    compute the expression.  */
end_comment

begin_function
specifier|static
name|void
name|compute_code_hoist_vbeinout
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|hoist_vbeout
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|hoist_vbein
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
comment|/* We scan the blocks in the reverse order to speed up 	 the convergence.  */
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|changed
operator||=
name|sbitmap_a_or_b_and_c_cg
argument_list|(
name|hoist_vbein
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|antloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|hoist_vbeout
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|next_bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
name|sbitmap_intersection_of_succs
argument_list|(
name|hoist_vbeout
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|hoist_vbein
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"hoisting vbeinout computation: %d passes\n"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level routine to do the dataflow analysis needed by code hoisting.  */
end_comment

begin_function
specifier|static
name|void
name|compute_code_hoist_data
parameter_list|(
name|void
parameter_list|)
block|{
name|compute_local_properties
argument_list|(
name|transp
argument_list|,
name|comp
argument_list|,
name|antloc
argument_list|,
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
name|compute_transpout
argument_list|()
expr_stmt|;
name|compute_code_hoist_vbeinout
argument_list|()
expr_stmt|;
name|calculate_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if the expression identified by EXPR_INDEX would    reach BB unimpared if it was placed at the end of EXPR_BB.     It's unclear exactly what Muchnick meant by "unimpared".  It seems    to me that the expression must either be computed or transparent in    *every* block in the path(s) from EXPR_BB to BB.  Any other definition    would allow the expression to be hoisted out of loops, even if    the expression wasn't a loop invariant.     Contrast this to reachability for PRE where an expression is    considered reachable if *any* path reaches instead of *all*    paths.  */
end_comment

begin_function
specifier|static
name|int
name|hoist_expr_reaches_here_p
parameter_list|(
name|basic_block
name|expr_bb
parameter_list|,
name|int
name|expr_index
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|char
modifier|*
name|visited
parameter_list|)
block|{
name|edge
name|pred
decl_stmt|;
name|int
name|visited_allocated_locally
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|visited
operator|==
name|NULL
condition|)
block|{
name|visited_allocated_locally
operator|=
literal|1
expr_stmt|;
name|visited
operator|=
name|xcalloc
argument_list|(
name|last_basic_block
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pred
operator|=
name|bb
operator|->
name|pred
init|;
name|pred
operator|!=
name|NULL
condition|;
name|pred
operator|=
name|pred
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|pred_bb
init|=
name|pred
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|pred
operator|->
name|src
operator|==
name|ENTRY_BLOCK_PTR
condition|)
break|break;
elseif|else
if|if
condition|(
name|pred_bb
operator|==
name|expr_bb
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
condition|)
continue|continue;
comment|/* Does this predecessor generate this expression?  */
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|comp
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr_index
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|transp
index|[
name|pred_bb
operator|->
name|index
index|]
argument_list|,
name|expr_index
argument_list|)
condition|)
break|break;
comment|/* Not killed.  */
else|else
block|{
name|visited
index|[
name|pred_bb
operator|->
name|index
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|hoist_expr_reaches_here_p
argument_list|(
name|expr_bb
argument_list|,
name|expr_index
argument_list|,
name|pred_bb
argument_list|,
name|visited
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|visited_allocated_locally
condition|)
name|free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return
operator|(
name|pred
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Actually perform code hoisting.  */
end_comment

begin_function
specifier|static
name|void
name|hoist_code
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|,
name|dominated
decl_stmt|;
name|basic_block
modifier|*
name|domby
decl_stmt|;
name|unsigned
name|int
name|domby_len
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|expr
modifier|*
modifier|*
name|index_map
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|hoist_exprs
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* Compute a mapping from expression number (`bitmap_index') to      hash table entry.  */
name|index_map
operator|=
name|xcalloc
argument_list|(
name|expr_hash_table
operator|.
name|n_elems
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table
operator|.
name|size
condition|;
name|i
operator|++
control|)
for|for
control|(
name|expr
operator|=
name|expr_hash_table
operator|.
name|table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
name|index_map
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|expr
expr_stmt|;
comment|/* Walk over each basic block looking for potentially hoistable      expressions, nothing gets hoisted from the entry block.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|insn_inserted_p
decl_stmt|;
name|domby_len
operator|=
name|get_dominated_by
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
operator|&
name|domby
argument_list|)
expr_stmt|;
comment|/* Examine each expression that is very busy at the exit of this 	 block.  These are the potentially hoistable expressions.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hoist_vbeout
index|[
name|bb
operator|->
name|index
index|]
operator|->
name|n_bits
condition|;
name|i
operator|++
control|)
block|{
name|int
name|hoistable
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|hoist_vbeout
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|i
argument_list|)
operator|&&
name|TEST_BIT
argument_list|(
name|transpout
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* We've found a potentially hoistable expression, now 		 we look at every block BB dominates to see if it 		 computes the expression.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|domby_len
condition|;
name|j
operator|++
control|)
block|{
name|dominated
operator|=
name|domby
index|[
name|j
index|]
expr_stmt|;
comment|/* Ignore self dominance.  */
if|if
condition|(
name|bb
operator|==
name|dominated
condition|)
continue|continue;
comment|/* We've found a dominated block, now see if it computes 		     the busy expression and whether or not moving that 		     expression to the "beginning" of that block is safe.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|antloc
index|[
name|dominated
operator|->
name|index
index|]
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
comment|/* Note if the expression would reach the dominated block 		     unimpared if it was placed at the end of BB.  		     Keep track of how many times this expression is hoistable 		     from a dominated block into BB.  */
if|if
condition|(
name|hoist_expr_reaches_here_p
argument_list|(
name|bb
argument_list|,
name|i
argument_list|,
name|dominated
argument_list|,
name|NULL
argument_list|)
condition|)
name|hoistable
operator|++
expr_stmt|;
block|}
comment|/* If we found more than one hoistable occurrence of this 		 expression, then note it in the bitmap of expressions to 		 hoist.  It makes no sense to hoist things which are computed 		 in only one BB, and doing so tends to pessimize register 		 allocation.  One could increase this value to try harder 		 to avoid any possible code expansion due to register 		 allocation issues; however experiments have shown that 		 the vast majority of hoistable expressions are only movable 		 from two successors, so raising this threshold is likely 		 to nullify any benefit we get from code hoisting.  */
if|if
condition|(
name|hoistable
operator|>
literal|1
condition|)
block|{
name|SET_BIT
argument_list|(
name|hoist_exprs
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* If we found nothing to hoist, then quit now.  */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|free
argument_list|(
name|domby
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Loop over all the hoistable expressions.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hoist_exprs
index|[
name|bb
operator|->
name|index
index|]
operator|->
name|n_bits
condition|;
name|i
operator|++
control|)
block|{
comment|/* We want to insert the expression into BB only once, so 	     note when we've inserted it.  */
name|insn_inserted_p
operator|=
literal|0
expr_stmt|;
comment|/* These tests should be the same as the tests above.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|hoist_vbeout
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* We've found a potentially hoistable expression, now 		 we look at every block BB dominates to see if it 		 computes the expression.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|domby_len
condition|;
name|j
operator|++
control|)
block|{
name|dominated
operator|=
name|domby
index|[
name|j
index|]
expr_stmt|;
comment|/* Ignore self dominance.  */
if|if
condition|(
name|bb
operator|==
name|dominated
condition|)
continue|continue;
comment|/* We've found a dominated block, now see if it computes 		     the busy expression and whether or not moving that 		     expression to the "beginning" of that block is safe.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|antloc
index|[
name|dominated
operator|->
name|index
index|]
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
comment|/* The expression is computed in the dominated block and 		     it would be safe to compute it at the start of the 		     dominated block.  Now we have to determine if the 		     expression would reach the dominated block if it was 		     placed at the end of BB.  */
if|if
condition|(
name|hoist_expr_reaches_here_p
argument_list|(
name|bb
argument_list|,
name|i
argument_list|,
name|dominated
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|struct
name|expr
modifier|*
name|expr
init|=
name|index_map
index|[
name|i
index|]
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
init|=
name|expr
operator|->
name|antic_occr
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Find the right occurrence of this expression.  */
while|while
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|!=
name|dominated
operator|&&
name|occr
condition|)
name|occr
operator|=
name|occr
operator|->
name|next
expr_stmt|;
comment|/* Should never happen.  */
if|if
condition|(
operator|!
name|occr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|insn
operator|=
name|occr
operator|->
name|insn
expr_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create a pseudo-reg to store the result of reaching 			 expressions into.  Get the mode for the new pseudo 			 from the mode of the original destination pseudo.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL
condition|)
name|expr
operator|->
name|reaching_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gcse_emit_move_after
argument_list|(
name|expr
operator|->
name|reaching_reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|occr
operator|->
name|deleted_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|insn_inserted_p
condition|)
block|{
name|insert_insn_end_bb
argument_list|(
name|index_map
index|[
name|i
index|]
argument_list|,
name|bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insn_inserted_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|free
argument_list|(
name|domby
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|index_map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level routine to perform one code hoisting (aka unification) pass     Return nonzero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|one_code_hoisting_pass
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|alloc_hash_table
argument_list|(
name|max_cuid
argument_list|,
operator|&
name|expr_hash_table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compute_hash_table
argument_list|(
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|dump_hash_table
argument_list|(
name|gcse_file
argument_list|,
literal|"Code Hosting Expressions"
argument_list|,
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr_hash_table
operator|.
name|n_elems
operator|>
literal|0
condition|)
block|{
name|alloc_code_hoist_mem
argument_list|(
name|last_basic_block
argument_list|,
name|expr_hash_table
operator|.
name|n_elems
argument_list|)
expr_stmt|;
name|compute_code_hoist_data
argument_list|()
expr_stmt|;
name|hoist_code
argument_list|()
expr_stmt|;
name|free_code_hoist_mem
argument_list|()
expr_stmt|;
block|}
name|free_hash_table
argument_list|(
operator|&
name|expr_hash_table
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Here we provide the things required to do store motion towards     the exit. In order for this to be effective, gcse also needed to     be taught how to move a load when it is kill only by a store to itself.  	    int i; 	    float a[10];  	    void foo(float scale) 	    { 	      for (i=0; i<10; i++) 		a[i] *= scale; 	    }      'i' is both loaded and stored to in the loop. Normally, gcse cannot move     the load out since its live around the loop, and stored at the bottom     of the loop.        The 'Load Motion' referred to and implemented in this file is     an enhancement to gcse which when using edge based lcm, recognizes     this situation and allows gcse to move the load out of the loop.        Once gcse has hoisted the load, store motion can then push this     load towards the exit, and we end up with no loads or stores of 'i'     in the loop.  */
end_comment

begin_comment
comment|/* This will search the ldst list for a matching expression. If it    doesn't find one, we create one and initialize it.  */
end_comment

begin_function
specifier|static
name|struct
name|ls_expr
modifier|*
name|ldst_entry
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|int
name|do_not_record_p
init|=
literal|0
decl_stmt|;
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|hash
operator|=
name|hash_expr_1
argument_list|(
name|x
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|do_not_record_p
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|pre_ldst_mems
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|ptr
operator|->
name|hash_index
operator|==
name|hash
operator|&&
name|expr_equiv_p
argument_list|(
name|ptr
operator|->
name|pattern
argument_list|,
name|x
argument_list|)
condition|)
return|return
name|ptr
return|;
name|ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ls_expr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|pre_ldst_mems
expr_stmt|;
name|ptr
operator|->
name|expr
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|->
name|pattern
operator|=
name|x
expr_stmt|;
name|ptr
operator|->
name|pattern_regs
operator|=
name|NULL_RTX
expr_stmt|;
name|ptr
operator|->
name|loads
operator|=
name|NULL_RTX
expr_stmt|;
name|ptr
operator|->
name|stores
operator|=
name|NULL_RTX
expr_stmt|;
name|ptr
operator|->
name|reaching_reg
operator|=
name|NULL_RTX
expr_stmt|;
name|ptr
operator|->
name|invalid
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|hash_index
operator|=
name|hash
expr_stmt|;
name|pre_ldst_mems
operator|=
name|ptr
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/* Free up an individual ldst entry.  */
end_comment

begin_function
specifier|static
name|void
name|free_ldst_entry
parameter_list|(
name|struct
name|ls_expr
modifier|*
name|ptr
parameter_list|)
block|{
name|free_INSN_LIST_list
argument_list|(
operator|&
name|ptr
operator|->
name|loads
argument_list|)
expr_stmt|;
name|free_INSN_LIST_list
argument_list|(
operator|&
name|ptr
operator|->
name|stores
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free up all memory associated with the ldst list.  */
end_comment

begin_function
specifier|static
name|void
name|free_ldst_mems
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|pre_ldst_mems
condition|)
block|{
name|struct
name|ls_expr
modifier|*
name|tmp
init|=
name|pre_ldst_mems
decl_stmt|;
name|pre_ldst_mems
operator|=
name|pre_ldst_mems
operator|->
name|next
expr_stmt|;
name|free_ldst_entry
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|pre_ldst_mems
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump debugging info about the ldst list.  */
end_comment

begin_function
specifier|static
name|void
name|print_ldst_list
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"LDST list: \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|first_ls_expr
argument_list|()
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|next_ls_expr
argument_list|(
name|ptr
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  Pattern (%3d): "
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|file
argument_list|,
name|ptr
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n	 Loads : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|loads
condition|)
name|print_rtl
argument_list|(
name|file
argument_list|,
name|ptr
operator|->
name|loads
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(nil)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n	Stores : "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|->
name|stores
condition|)
name|print_rtl
argument_list|(
name|file
argument_list|,
name|ptr
operator|->
name|stores
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(nil)"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns 1 if X is in the list of ldst only expressions.  */
end_comment

begin_function
specifier|static
name|struct
name|ls_expr
modifier|*
name|find_rtx_in_ldst
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|pre_ldst_mems
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|expr_equiv_p
argument_list|(
name|ptr
operator|->
name|pattern
argument_list|,
name|x
argument_list|)
operator|&&
operator|!
name|ptr
operator|->
name|invalid
condition|)
return|return
name|ptr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Assign each element of the list of mems a monotonically increasing value.  */
end_comment

begin_function
specifier|static
name|int
name|enumerate_ldsts
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|pre_ldst_mems
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|ptr
operator|->
name|index
operator|=
name|n
operator|++
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Return first item in the list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|ls_expr
modifier|*
name|first_ls_expr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|pre_ldst_mems
return|;
block|}
end_function

begin_comment
comment|/* Return the next item in the list after the specified one.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|ls_expr
modifier|*
name|next_ls_expr
parameter_list|(
name|struct
name|ls_expr
modifier|*
name|ptr
parameter_list|)
block|{
return|return
name|ptr
operator|->
name|next
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load Motion for loads which only kill themselves.  */
end_comment

begin_comment
comment|/* Return true if x is a simple MEM operation, with no registers or    side effects. These are the types of loads we consider for the    ld_motion list, otherwise we let the usual aliasing take care of it.  */
end_comment

begin_function
specifier|static
name|int
name|simple_mem
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
comment|/* If we are handling exceptions, we must be careful with memory references      that may trap. If we are not, the behavior is undefined, so we may just      continue.  */
if|if
condition|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|side_effects_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Do not consider function arguments passed on stack.  */
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag_float_store
operator|&&
name|FLOAT_MODE_P
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Make sure there isn't a buried reference in this pattern anywhere.    If there is, invalidate the entry for it since we're not capable    of fixing it up just yet.. We have to be sure we know about ALL    loads since the aliasing code will allow all entries in the    ld_motion list to not-alias itself.  If we miss a load, we will get    the wrong value since gcse might common it and we won't know to    fix it up.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_any_buried_refs
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
comment|/* Invalidate it in the list.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|simple_mem
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|ptr
operator|=
name|ldst_entry
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Recursively process the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|invalidate_any_buried_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|invalidate_any_buried_refs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find all the 'simple' MEMs which are used in LOADs and STORES.  Simple    being defined as MEM loads and stores to symbols, with no side effects    and no registers in the expression.  For a MEM destination, we also    check that the insn is still valid if we replace the destination with a    REG, as is done in update_ld_motion_stores.  If there are any uses/defs    which don't match this criteria, they are invalidated and trimmed out    later.  */
end_comment

begin_function
specifier|static
name|void
name|compute_ld_motion_mems
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|pre_ldst_mems
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Check for a simple LOAD...  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MEM
operator|&&
name|simple_mem
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|ptr
operator|=
name|ldst_entry
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|ptr
operator|->
name|loads
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|ptr
operator|->
name|loads
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|->
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure there isn't a buried load somewhere.  */
name|invalidate_any_buried_refs
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* Check for stores. Don't worry about aliased ones, they 		     will block any movement we might do later. We only care 		     about this exact pattern since those are the only 		     circumstance that we will ignore the aliasing info.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
name|simple_mem
argument_list|(
name|dest
argument_list|)
condition|)
block|{
name|ptr
operator|=
name|ldst_entry
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|ASM_OPERANDS
comment|/* Check for REG manually since want_to_gcse_p 			     returns 0 for all REGs.  */
operator|&&
operator|(
name|REG_P
argument_list|(
name|src
argument_list|)
operator|||
name|want_to_gcse_p
argument_list|(
name|src
argument_list|)
operator|)
condition|)
name|ptr
operator|->
name|stores
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|ptr
operator|->
name|stores
argument_list|)
expr_stmt|;
else|else
name|ptr
operator|->
name|invalid
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|invalidate_any_buried_refs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remove any references that have been either invalidated or are not in the    expression list for pre gcse.  */
end_comment

begin_function
specifier|static
name|void
name|trim_ld_motion_mems
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ls_expr
modifier|*
modifier|*
name|last
init|=
operator|&
name|pre_ldst_mems
decl_stmt|;
name|struct
name|ls_expr
modifier|*
name|ptr
init|=
name|pre_ldst_mems
decl_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
comment|/* Delete if entry has been made invalid.  */
if|if
condition|(
operator|!
name|ptr
operator|->
name|invalid
condition|)
block|{
comment|/* Delete if we cannot find this mem in the expression list.  */
name|unsigned
name|int
name|hash
init|=
name|ptr
operator|->
name|hash_index
operator|%
name|expr_hash_table
operator|.
name|size
decl_stmt|;
for|for
control|(
name|expr
operator|=
name|expr_hash_table
operator|.
name|table
index|[
name|hash
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|expr_equiv_p
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|ptr
operator|->
name|pattern
argument_list|)
condition|)
break|break;
block|}
else|else
name|expr
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|expr
condition|)
block|{
comment|/* Set the expression field if we are keeping it.  */
name|ptr
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|last
operator|=
operator|&
name|ptr
operator|->
name|next
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
operator|*
name|last
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|free_ldst_entry
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|*
name|last
expr_stmt|;
block|}
block|}
comment|/* Show the world what we've found.  */
if|if
condition|(
name|gcse_file
operator|&&
name|pre_ldst_mems
operator|!=
name|NULL
condition|)
name|print_ldst_list
argument_list|(
name|gcse_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine will take an expression which we are replacing with    a reaching register, and update any stores that are needed if    that expression is in the ld_motion list.  Stores are updated by    copying their SRC to the reaching register, and then storing    the reaching register into the store location. These keeps the    correct value in the reaching register for the loads.  */
end_comment

begin_function
specifier|static
name|void
name|update_ld_motion_stores
parameter_list|(
name|struct
name|expr
modifier|*
name|expr
parameter_list|)
block|{
name|struct
name|ls_expr
modifier|*
name|mem_ptr
decl_stmt|;
if|if
condition|(
operator|(
name|mem_ptr
operator|=
name|find_rtx_in_ldst
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
operator|)
condition|)
block|{
comment|/* We can try to find just the REACHED stores, but is shouldn't 	 matter to set the reaching reg everywhere...  some might be 	 dead and should be eliminated later.  */
comment|/* We replace (set mem expr) with (set reg expr) (set mem reg) 	 where reg is the reaching reg used in the load.  We checked in 	 compute_ld_motion_mems that we can replace (set mem expr) with 	 (set reg expr) in that insn.  */
name|rtx
name|list
init|=
name|mem_ptr
operator|->
name|stores
decl_stmt|;
for|for
control|(
init|;
name|list
operator|!=
name|NULL_RTX
condition|;
name|list
operator|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|insn
init|=
name|XEXP
argument_list|(
name|list
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|expr
operator|->
name|reaching_reg
decl_stmt|;
name|rtx
name|copy
decl_stmt|,
name|new
decl_stmt|;
comment|/* If we've already copied it, continue.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|src
condition|)
continue|continue;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE:  store updated with reaching reg "
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|expr
operator|->
name|reaching_reg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|":\n	"
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|gcse_file
argument_list|,
name|insn
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|copy
operator|=
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|copy_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|emit_insn_before
argument_list|(
name|copy
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|record_one_set
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|SET_SRC
argument_list|(
name|pat
argument_list|)
operator|=
name|reg
expr_stmt|;
comment|/* un-recognize this pattern since it's probably different now.  */
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|gcse_create_count
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store motion code.  */
end_comment

begin_define
define|#
directive|define
name|ANTIC_STORE_LIST
parameter_list|(
name|x
parameter_list|)
value|((x)->loads)
end_define

begin_define
define|#
directive|define
name|AVAIL_STORE_LIST
parameter_list|(
name|x
parameter_list|)
value|((x)->stores)
end_define

begin_define
define|#
directive|define
name|LAST_AVAIL_CHECK_FAILURE
parameter_list|(
name|x
parameter_list|)
value|((x)->reaching_reg)
end_define

begin_comment
comment|/* This is used to communicate the target bitvector we want to use in the    reg_set_info routine when called via the note_stores mechanism.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|regvec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* And current insn, for the same routine.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|compute_store_table_current_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used in computing the reverse edge graph bit vectors.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|st_antloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global holding the number of store expressions we are dealing with.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_stores
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Checks to set if we need to mark a register set.  Called from    note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|reg_set_info
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|sbitmap
name|bb_reg
init|=
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regvec
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
name|INSN_UID
argument_list|(
name|compute_store_table_current_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb_reg
condition|)
name|SET_BIT
argument_list|(
name|bb_reg
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear any mark that says that this insn sets dest.  Called from    note_stores.  */
end_comment

begin_function
specifier|static
name|void
name|reg_clear_last_set
parameter_list|(
name|rtx
name|dest
parameter_list|,
name|rtx
name|setter
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
modifier|*
name|dead_vec
init|=
name|data
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
operator|&&
name|dead_vec
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|==
name|INSN_UID
argument_list|(
name|compute_store_table_current_insn
argument_list|)
condition|)
name|dead_vec
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return zero if some of the registers in list X are killed    due to set of registers in bitmap REGS_SET.  */
end_comment

begin_function
specifier|static
name|bool
name|store_ops_ok
parameter_list|(
name|rtx
name|x
parameter_list|,
name|int
modifier|*
name|regs_set
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|;
for|for
control|(
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|reg
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs_set
index|[
name|REGNO
argument_list|(
name|reg
argument_list|)
index|]
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Returns a list of registers mentioned in X.  */
end_comment

begin_function
specifier|static
name|rtx
name|extract_mentioned_regs
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
return|return
name|extract_mentioned_regs_helper
argument_list|(
name|x
argument_list|,
name|NULL_RTX
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper for extract_mentioned_regs; ACCUM is used to accumulate used    registers.  */
end_comment

begin_function
specifier|static
name|rtx
name|extract_mentioned_regs_helper
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|accum
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* Repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|accum
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
return|return
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|x
argument_list|,
name|accum
argument_list|)
return|;
case|case
name|MEM
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
comment|/* We do not run this function with arguments having side effects.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
name|accum
return|;
default|default:
break|break;
block|}
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|tem
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|accum
operator|=
name|extract_mentioned_regs_helper
argument_list|(
name|tem
argument_list|,
name|accum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|accum
operator|=
name|extract_mentioned_regs_helper
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|accum
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|accum
return|;
block|}
end_function

begin_comment
comment|/* Determine whether INSN is MEM store pattern that we will consider moving.    REGS_SET_BEFORE is bitmap of registers set before (and including) the    current insn, REGS_SET_AFTER is bitmap of registers set after (and    including) the insn in this basic block.  We must be passing through BB from    head to end, as we are using this fact to speed things up.     The results are stored this way:     -- the first anticipatable expression is added into ANTIC_STORE_LIST    -- if the processed expression is not anticipatable, NULL_RTX is added       there instead, so that we can use it as indicator that no further       expression of this type may be anticipatable    -- if the expression is available, it is added as head of AVAIL_STORE_LIST;       consequently, all of them but this head are dead and may be deleted.    -- if the expression is not available, the insn due to that it fails to be       available is stored in reaching_reg.     The things are complicated a bit by fact that there already may be stores    to the same MEM from other blocks; also caller must take care of the    necessary cleanup of the temporary markers after end of the basic block.    */
end_comment

begin_function
specifier|static
name|void
name|find_moveable_store
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|int
modifier|*
name|regs_set_before
parameter_list|,
name|int
modifier|*
name|regs_set_after
parameter_list|)
block|{
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|rtx
name|dest
decl_stmt|,
name|set
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|check_anticipatable
decl_stmt|,
name|check_available
decl_stmt|;
name|basic_block
name|bb
init|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|!=
name|MEM
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|dest
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|dest
argument_list|)
operator|==
name|BLKmode
condition|)
return|return;
if|if
condition|(
name|side_effects_p
argument_list|(
name|dest
argument_list|)
condition|)
return|return;
comment|/* If we are handling exceptions, we must be careful with memory references      that may trap. If we are not, the behavior is undefined, so we may just      continue.  */
if|if
condition|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|dest
argument_list|)
condition|)
return|return;
name|ptr
operator|=
name|ldst_entry
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|->
name|pattern_regs
condition|)
name|ptr
operator|->
name|pattern_regs
operator|=
name|extract_mentioned_regs
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* Do not check for anticipatability if we either found one anticipatable      store already, or tested for one and found out that it was killed.  */
name|check_anticipatable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ANTIC_STORE_LIST
argument_list|(
name|ptr
argument_list|)
condition|)
name|check_anticipatable
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|tmp
operator|=
name|XEXP
argument_list|(
name|ANTIC_STORE_LIST
argument_list|(
name|ptr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL_RTX
operator|&&
name|BLOCK_FOR_INSN
argument_list|(
name|tmp
argument_list|)
operator|!=
name|bb
condition|)
name|check_anticipatable
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|check_anticipatable
condition|)
block|{
if|if
condition|(
name|store_killed_before
argument_list|(
name|dest
argument_list|,
name|ptr
operator|->
name|pattern_regs
argument_list|,
name|insn
argument_list|,
name|bb
argument_list|,
name|regs_set_before
argument_list|)
condition|)
name|tmp
operator|=
name|NULL_RTX
expr_stmt|;
else|else
name|tmp
operator|=
name|insn
expr_stmt|;
name|ANTIC_STORE_LIST
argument_list|(
name|ptr
argument_list|)
operator|=
name|alloc_INSN_LIST
argument_list|(
name|tmp
argument_list|,
name|ANTIC_STORE_LIST
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* It is not necessary to check whether store is available if we did      it successfully before; if we failed before, do not bother to check      until we reach the insn that caused us to fail.  */
name|check_available
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|AVAIL_STORE_LIST
argument_list|(
name|ptr
argument_list|)
condition|)
name|check_available
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|tmp
operator|=
name|XEXP
argument_list|(
name|AVAIL_STORE_LIST
argument_list|(
name|ptr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|tmp
argument_list|)
operator|!=
name|bb
condition|)
name|check_available
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|check_available
condition|)
block|{
comment|/* Check that we have already reached the insn at that the check 	 failed last time.  */
if|if
condition|(
name|LAST_AVAIL_CHECK_FAILURE
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
for|for
control|(
name|tmp
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
init|;
name|tmp
operator|!=
name|insn
operator|&&
name|tmp
operator|!=
name|LAST_AVAIL_CHECK_FAILURE
argument_list|(
name|ptr
argument_list|)
condition|;
name|tmp
operator|=
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
control|)
continue|continue;
if|if
condition|(
name|tmp
operator|==
name|insn
condition|)
name|check_available
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|check_available
operator|=
name|store_killed_after
argument_list|(
name|dest
argument_list|,
name|ptr
operator|->
name|pattern_regs
argument_list|,
name|insn
argument_list|,
name|bb
argument_list|,
name|regs_set_after
argument_list|,
operator|&
name|LAST_AVAIL_CHECK_FAILURE
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|check_available
condition|)
name|AVAIL_STORE_LIST
argument_list|(
name|ptr
argument_list|)
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|AVAIL_STORE_LIST
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find available and anticipatable stores.  */
end_comment

begin_function
specifier|static
name|int
name|compute_store_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|unsigned
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|pat
decl_stmt|,
name|tmp
decl_stmt|;
name|int
modifier|*
name|last_set_in
decl_stmt|,
modifier|*
name|already_set
decl_stmt|;
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|,
modifier|*
modifier|*
name|prev_next_ptr_ptr
decl_stmt|;
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|reg_set_in_block
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|max_gcse_regno
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|reg_set_in_block
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|pre_ldst_mems
operator|=
literal|0
expr_stmt|;
name|last_set_in
operator|=
name|xcalloc
argument_list|(
name|max_gcse_regno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|already_set
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|max_gcse_regno
argument_list|)
expr_stmt|;
comment|/* Find all the stores we care about.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
comment|/* First compute the registers set in this block.  */
name|regvec
operator|=
name|last_set_in
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|bool
name|clobbers_all
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|clobbers_all
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|clobbers_all
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
condition|)
block|{
name|last_set_in
index|[
name|regno
index|]
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|compute_store_table_current_insn
operator|=
name|insn
expr_stmt|;
name|note_stores
argument_list|(
name|pat
argument_list|,
name|reg_set_info
argument_list|,
name|reg_set_in_block
index|[
name|bb
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Now find the stores.  */
name|memset
argument_list|(
name|already_set
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|max_gcse_regno
argument_list|)
expr_stmt|;
name|regvec
operator|=
name|already_set
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|bool
name|clobbers_all
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|clobbers_all
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|clobbers_all
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
condition|)
name|already_set
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|note_stores
argument_list|(
name|pat
argument_list|,
name|reg_set_info
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now that we've marked regs, look for stores.  */
name|find_moveable_store
argument_list|(
name|insn
argument_list|,
name|already_set
argument_list|,
name|last_set_in
argument_list|)
expr_stmt|;
comment|/* Unmark regs that are no longer set.  */
name|compute_store_table_current_insn
operator|=
name|insn
expr_stmt|;
name|note_stores
argument_list|(
name|pat
argument_list|,
name|reg_clear_last_set
argument_list|,
name|last_set_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|bool
name|clobbers_all
init|=
name|false
decl_stmt|;
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|clobbers_all
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|clobbers_all
operator|||
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|regno
argument_list|)
operator|)
operator|&&
name|last_set_in
index|[
name|regno
index|]
operator|==
name|INSN_UID
argument_list|(
name|insn
argument_list|)
condition|)
name|last_set_in
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* last_set_in should now be all-zero.  */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_gcse_regno
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|last_set_in
index|[
name|regno
index|]
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Clear temporary marks.  */
for|for
control|(
name|ptr
operator|=
name|first_ls_expr
argument_list|()
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|next_ls_expr
argument_list|(
name|ptr
argument_list|)
control|)
block|{
name|LAST_AVAIL_CHECK_FAILURE
argument_list|(
name|ptr
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|ANTIC_STORE_LIST
argument_list|(
name|ptr
argument_list|)
operator|&&
operator|(
name|tmp
operator|=
name|XEXP
argument_list|(
name|ANTIC_STORE_LIST
argument_list|(
name|ptr
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL_RTX
condition|)
name|ANTIC_STORE_LIST
argument_list|(
name|ptr
argument_list|)
operator|=
name|XEXP
argument_list|(
name|ANTIC_STORE_LIST
argument_list|(
name|ptr
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove the stores that are not available anywhere, as there will      be no opportunity to optimize them.  */
for|for
control|(
name|ptr
operator|=
name|pre_ldst_mems
operator|,
name|prev_next_ptr_ptr
operator|=
operator|&
name|pre_ldst_mems
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
operator|*
name|prev_next_ptr_ptr
control|)
block|{
if|if
condition|(
operator|!
name|AVAIL_STORE_LIST
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
operator|*
name|prev_next_ptr_ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
name|free_ldst_entry
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|prev_next_ptr_ptr
operator|=
operator|&
name|ptr
operator|->
name|next
expr_stmt|;
block|}
name|ret
operator|=
name|enumerate_ldsts
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"ST_avail and ST_antic (shown under loads..)\n"
argument_list|)
expr_stmt|;
name|print_ldst_list
argument_list|(
name|gcse_file
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|last_set_in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|already_set
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Check to see if the load X is aliased with STORE_PATTERN.    AFTER is true if we are checking the case when STORE_PATTERN occurs    after the X.  */
end_comment

begin_function
specifier|static
name|bool
name|load_kills_store
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|store_pattern
parameter_list|,
name|int
name|after
parameter_list|)
block|{
if|if
condition|(
name|after
condition|)
return|return
name|anti_dependence
argument_list|(
name|x
argument_list|,
name|store_pattern
argument_list|)
return|;
else|else
return|return
name|true_dependence
argument_list|(
name|store_pattern
argument_list|,
name|GET_MODE
argument_list|(
name|store_pattern
argument_list|)
argument_list|,
name|x
argument_list|,
name|rtx_addr_varies_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Go through the entire insn X, looking for any loads which might alias    STORE_PATTERN.  Return true if found.    AFTER is true if we are checking the case when STORE_PATTERN occurs    after the insn X.  */
end_comment

begin_function
specifier|static
name|bool
name|find_loads
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|store_pattern
parameter_list|,
name|int
name|after
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|ret
init|=
name|false
decl_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
block|{
if|if
condition|(
name|load_kills_store
argument_list|(
name|x
argument_list|,
name|store_pattern
argument_list|,
name|after
argument_list|)
condition|)
return|return
name|true
return|;
block|}
comment|/* Recursively process the insn.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
operator|!
name|ret
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|ret
operator||=
name|find_loads
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|store_pattern
argument_list|,
name|after
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|ret
operator||=
name|find_loads
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|store_pattern
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Check if INSN kills the store pattern X (is aliased with it).    AFTER is true if we are checking the case when store X occurs    after the insn.  Return true if it it does.  */
end_comment

begin_function
specifier|static
name|bool
name|store_killed_in_insn
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|x_regs
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|after
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|,
name|base
decl_stmt|,
name|note
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* A normal or pure call might read from pattern, 	 but a const call will not.  */
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
operator|||
name|pure_call_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* But even a const call reads its parameters.  Check whether the 	 base of some of registers used in mem is stack pointer.  */
for|for
control|(
name|reg
operator|=
name|x_regs
init|;
name|reg
condition|;
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|base
operator|=
name|find_base_term
argument_list|(
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
operator|||
operator|(
name|GET_CODE
argument_list|(
name|base
argument_list|)
operator|==
name|ADDRESS
operator|&&
name|GET_MODE
argument_list|(
name|base
argument_list|)
operator|==
name|Pmode
operator|&&
name|XEXP
argument_list|(
name|base
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for memory stores to aliased objects.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|expr_equiv_p
argument_list|(
name|dest
argument_list|,
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|after
condition|)
block|{
if|if
condition|(
name|output_dependence
argument_list|(
name|dest
argument_list|,
name|x
argument_list|)
condition|)
return|return
name|true
return|;
block|}
else|else
block|{
if|if
condition|(
name|output_dependence
argument_list|(
name|x
argument_list|,
name|dest
argument_list|)
condition|)
return|return
name|true
return|;
block|}
block|}
if|if
condition|(
name|find_loads
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|x
argument_list|,
name|after
argument_list|)
condition|)
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|find_loads
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|x
argument_list|,
name|after
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* If this insn has a REG_EQUAL or REG_EQUIV note referencing a memory      location aliased with X, then this insn kills X.  */
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
condition|)
return|return
name|false
return|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* However, if the note represents a must alias rather than a may      alias relationship, then it does not kill X.  */
if|if
condition|(
name|expr_equiv_p
argument_list|(
name|note
argument_list|,
name|x
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* See if there are any aliased loads in the note.  */
return|return
name|find_loads
argument_list|(
name|note
argument_list|,
name|x
argument_list|,
name|after
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the expression X is loaded or clobbered on or after INSN    within basic block BB.  REGS_SET_AFTER is bitmap of registers set in    or after the insn.  X_REGS is list of registers mentioned in X. If the store    is killed, return the last insn in that it occurs in FAIL_INSN.  */
end_comment

begin_function
specifier|static
name|bool
name|store_killed_after
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|x_regs
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
modifier|*
name|regs_set_after
parameter_list|,
name|rtx
modifier|*
name|fail_insn
parameter_list|)
block|{
name|rtx
name|last
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|,
name|act
decl_stmt|;
if|if
condition|(
operator|!
name|store_ops_ok
argument_list|(
name|x_regs
argument_list|,
name|regs_set_after
argument_list|)
condition|)
block|{
comment|/* We do not know where it will happen.  */
if|if
condition|(
name|fail_insn
condition|)
operator|*
name|fail_insn
operator|=
name|NULL_RTX
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Scan from the end, so that fail_insn is determined correctly.  */
for|for
control|(
name|act
operator|=
name|last
init|;
name|act
operator|!=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
condition|;
name|act
operator|=
name|PREV_INSN
argument_list|(
name|act
argument_list|)
control|)
if|if
condition|(
name|store_killed_in_insn
argument_list|(
name|x
argument_list|,
name|x_regs
argument_list|,
name|act
argument_list|,
name|false
argument_list|)
condition|)
block|{
if|if
condition|(
name|fail_insn
condition|)
operator|*
name|fail_insn
operator|=
name|act
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Returns true if the expression X is loaded or clobbered on or before INSN    within basic block BB. X_REGS is list of registers mentioned in X.    REGS_SET_BEFORE is bitmap of registers set before or in this insn.  */
end_comment

begin_function
specifier|static
name|bool
name|store_killed_before
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|x_regs
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|int
modifier|*
name|regs_set_before
parameter_list|)
block|{
name|rtx
name|first
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|store_ops_ok
argument_list|(
name|x_regs
argument_list|,
name|regs_set_before
argument_list|)
condition|)
return|return
name|true
return|;
for|for
control|(
init|;
name|insn
operator|!=
name|PREV_INSN
argument_list|(
name|first
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|store_killed_in_insn
argument_list|(
name|x
argument_list|,
name|x_regs
argument_list|,
name|insn
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Fill in available, anticipatable, transparent and kill vectors in    STORE_DATA, based on lists of available and anticipatable stores.  */
end_comment

begin_function
specifier|static
name|void
name|build_store_vectors
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
modifier|*
name|regs_set_in_block
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|st
decl_stmt|;
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|regno
decl_stmt|;
comment|/* Build the gen_vector. This is any store in the table which is not killed      by aliasing later in its block.  */
name|ae_gen
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|num_stores
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_gen
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|st_antloc
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|num_stores
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|st_antloc
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|first_ls_expr
argument_list|()
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|next_ls_expr
argument_list|(
name|ptr
argument_list|)
control|)
block|{
for|for
control|(
name|st
operator|=
name|AVAIL_STORE_LIST
argument_list|(
name|ptr
argument_list|)
init|;
name|st
operator|!=
name|NULL
condition|;
name|st
operator|=
name|XEXP
argument_list|(
name|st
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* If we've already seen an available expression in this block, 	     we can delete this one (It occurs earlier in the block). We'll 	     copy the SRC expression to an unused register in case there 	     are any side effects.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
condition|)
block|{
name|rtx
name|r
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|ptr
operator|->
name|pattern
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"Removing redundant store:\n"
argument_list|)
expr_stmt|;
name|replace_store_insn
argument_list|(
name|r
argument_list|,
name|XEXP
argument_list|(
name|st
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bb
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SET_BIT
argument_list|(
name|ae_gen
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|st
operator|=
name|ANTIC_STORE_LIST
argument_list|(
name|ptr
argument_list|)
init|;
name|st
operator|!=
name|NULL
condition|;
name|st
operator|=
name|XEXP
argument_list|(
name|st
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|insn
operator|=
name|XEXP
argument_list|(
name|st
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|st_antloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|ae_kill
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|num_stores
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_kill
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|transp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|last_basic_block
argument_list|,
name|num_stores
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|transp
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|regs_set_in_block
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|max_gcse_regno
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_gcse_regno
condition|;
name|regno
operator|++
control|)
name|regs_set_in_block
index|[
name|regno
index|]
operator|=
name|TEST_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|first_ls_expr
argument_list|()
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|next_ls_expr
argument_list|(
name|ptr
argument_list|)
control|)
block|{
if|if
condition|(
name|store_killed_after
argument_list|(
name|ptr
operator|->
name|pattern
argument_list|,
name|ptr
operator|->
name|pattern_regs
argument_list|,
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|,
name|bb
argument_list|,
name|regs_set_in_block
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* It should not be necessary to consider the expression 		 killed if it is both anticipatable and available.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|st_antloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
operator|||
operator|!
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|ae_kill
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
name|SET_BIT
argument_list|(
name|transp
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|regs_set_in_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|dump_sbitmap_vector
argument_list|(
name|gcse_file
argument_list|,
literal|"st_antloc"
argument_list|,
literal|""
argument_list|,
name|st_antloc
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|gcse_file
argument_list|,
literal|"st_kill"
argument_list|,
literal|""
argument_list|,
name|ae_kill
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|gcse_file
argument_list|,
literal|"Transpt"
argument_list|,
literal|""
argument_list|,
name|transp
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|dump_sbitmap_vector
argument_list|(
name|gcse_file
argument_list|,
literal|"st_avloc"
argument_list|,
literal|""
argument_list|,
name|ae_gen
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert an instruction at the beginning of a basic block, and update    the BB_HEAD if needed.  */
end_comment

begin_function
specifier|static
name|void
name|insert_insn_start_bb
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
comment|/* Insert at start of successor block.  */
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|before
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|;
while|while
condition|(
name|before
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|before
argument_list|)
operator|!=
name|CODE_LABEL
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|before
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|before
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
operator|)
condition|)
break|break;
name|prev
operator|=
name|before
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
name|before
operator|=
name|NEXT_INSN
argument_list|(
name|before
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|emit_insn_after_noloc
argument_list|(
name|insn
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"STORE_MOTION  insert store at start of BB %d:\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|gcse_file
argument_list|,
name|insn
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine will insert a store on an edge. EXPR is the ldst entry for    the memory reference, and E is the edge to insert it on.  Returns nonzero    if an edge insertion was performed.  */
end_comment

begin_function
specifier|static
name|int
name|insert_store
parameter_list|(
name|struct
name|ls_expr
modifier|*
name|expr
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge
name|tmp
decl_stmt|;
comment|/* We did all the deleted before this insert, so if we didn't delete a      store, then we haven't set the reaching reg yet either.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FAKE
condition|)
return|return
literal|0
return|;
name|reg
operator|=
name|expr
operator|->
name|reaching_reg
expr_stmt|;
name|insn
operator|=
name|gen_move_insn
argument_list|(
name|copy_rtx
argument_list|(
name|expr
operator|->
name|pattern
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* If we are inserting this expression on ALL predecessor edges of a BB,      insert it at the start of the BB, and reset the insert bits on the other      edges so we don't try to insert it on the other edges.  */
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|e
operator|->
name|dest
operator|->
name|pred
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|pred_next
control|)
if|if
condition|(
operator|!
operator|(
name|tmp
operator|->
name|flags
operator|&
name|EDGE_FAKE
operator|)
condition|)
block|{
name|int
name|index
init|=
name|EDGE_INDEX
argument_list|(
name|edge_list
argument_list|,
name|tmp
operator|->
name|src
argument_list|,
name|tmp
operator|->
name|dest
argument_list|)
decl_stmt|;
if|if
condition|(
name|index
operator|==
name|EDGE_INDEX_NO_EDGE
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|pre_insert_map
index|[
name|index
index|]
argument_list|,
name|expr
operator|->
name|index
argument_list|)
condition|)
break|break;
block|}
comment|/* If tmp is NULL, we found an insertion on every edge, blank the      insertion vector for these edges, and insert at the start of the BB.  */
if|if
condition|(
operator|!
name|tmp
operator|&&
name|bb
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
for|for
control|(
name|tmp
operator|=
name|e
operator|->
name|dest
operator|->
name|pred
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|pred_next
control|)
block|{
name|int
name|index
init|=
name|EDGE_INDEX
argument_list|(
name|edge_list
argument_list|,
name|tmp
operator|->
name|src
argument_list|,
name|tmp
operator|->
name|dest
argument_list|)
decl_stmt|;
name|RESET_BIT
argument_list|(
name|pre_insert_map
index|[
name|index
index|]
argument_list|,
name|expr
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|insert_insn_start_bb
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We can't insert on this edge, so we'll insert at the head of the      successors block.  See Morgan, sec 10.5.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
name|EDGE_ABNORMAL
condition|)
block|{
name|insert_insn_start_bb
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|insert_insn_on_edge
argument_list|(
name|insn
argument_list|,
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"STORE_MOTION  insert insn on edge (%d, %d):\n"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|gcse_file
argument_list|,
name|insn
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Remove any REG_EQUAL or REG_EQUIV notes containing a reference to the    memory location in SMEXPR set in basic block BB.     This could be rather expensive.  */
end_comment

begin_function
specifier|static
name|void
name|remove_reachable_equiv_notes
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|struct
name|ls_expr
modifier|*
name|smexpr
parameter_list|)
block|{
name|edge
modifier|*
name|stack
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
operator|*
name|n_basic_blocks
argument_list|)
decl_stmt|,
name|act
decl_stmt|;
name|sbitmap
name|visited
init|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
decl_stmt|;
name|int
name|stack_top
init|=
literal|0
decl_stmt|;
name|rtx
name|last
decl_stmt|,
name|insn
decl_stmt|,
name|note
decl_stmt|;
name|rtx
name|mem
init|=
name|smexpr
operator|->
name|pattern
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|visited
argument_list|)
expr_stmt|;
name|act
operator|=
name|bb
operator|->
name|succ
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|act
condition|)
block|{
if|if
condition|(
operator|!
name|stack_top
condition|)
block|{
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
return|return;
block|}
name|act
operator|=
name|stack
index|[
operator|--
name|stack_top
index|]
expr_stmt|;
block|}
name|bb
operator|=
name|act
operator|->
name|dest
expr_stmt|;
comment|/* We used to continue the loop without scanning this block if the 	 store expression was killed in this block.  That is wrong as 	 we could have had a REG_EQUAL note with the store expression 	 appear in the block before the insn which killed the store 	 expression and that REG_EQUAL note needs to be removed as it 	 is invalid.  */
if|if
condition|(
name|bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|TEST_BIT
argument_list|(
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|act
operator|=
name|act
operator|->
name|succ_next
expr_stmt|;
continue|continue;
block|}
name|SET_BIT
argument_list|(
name|visited
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|st_antloc
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|smexpr
operator|->
name|index
argument_list|)
condition|)
block|{
for|for
control|(
name|last
operator|=
name|ANTIC_STORE_LIST
argument_list|(
name|smexpr
argument_list|)
init|;
name|BLOCK_FOR_INSN
argument_list|(
name|XEXP
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|bb
condition|;
name|last
operator|=
name|XEXP
argument_list|(
name|last
argument_list|,
literal|1
argument_list|)
control|)
continue|continue;
name|last
operator|=
name|XEXP
argument_list|(
name|last
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|last
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
operator|!
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"STORE_MOTION  drop REG_EQUAL note at insn %d:\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
name|act
operator|=
name|act
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|succ
condition|)
block|{
if|if
condition|(
name|act
condition|)
name|stack
index|[
name|stack_top
operator|++
index|]
operator|=
name|act
expr_stmt|;
name|act
operator|=
name|bb
operator|->
name|succ
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This routine will replace a store with a SET to a specified register.  */
end_comment

begin_function
specifier|static
name|void
name|replace_store_insn
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|rtx
name|del
parameter_list|,
name|basic_block
name|bb
parameter_list|,
name|struct
name|ls_expr
modifier|*
name|smexpr
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|mem
decl_stmt|,
name|note
decl_stmt|,
name|set
decl_stmt|,
name|ptr
decl_stmt|,
name|pair
decl_stmt|;
name|mem
operator|=
name|smexpr
operator|->
name|pattern
expr_stmt|;
name|insn
operator|=
name|gen_move_insn
argument_list|(
name|reg
argument_list|,
name|SET_SRC
argument_list|(
name|single_set
argument_list|(
name|del
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn_after
argument_list|(
name|insn
argument_list|,
name|del
argument_list|)
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"STORE_MOTION  delete insn in BB %d:\n      "
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|gcse_file
argument_list|,
name|del
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\nSTORE MOTION  replaced with insn:\n      "
argument_list|)
expr_stmt|;
name|print_inline_rtx
argument_list|(
name|gcse_file
argument_list|,
name|insn
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ptr
operator|=
name|ANTIC_STORE_LIST
argument_list|(
name|smexpr
argument_list|)
init|;
name|ptr
condition|;
name|ptr
operator|=
name|XEXP
argument_list|(
name|ptr
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|)
operator|==
name|del
condition|)
block|{
name|XEXP
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|)
operator|=
name|insn
expr_stmt|;
break|break;
block|}
comment|/* Move the notes from the deleted insn to its replacement, and patch      up the LIBCALL notes.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|REG_NOTES
argument_list|(
name|del
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|pair
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|pair
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|pair
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|pair
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|=
name|insn
expr_stmt|;
block|}
name|delete_insn
argument_list|(
name|del
argument_list|)
expr_stmt|;
comment|/* Now we must handle REG_EQUAL notes whose contents is equal to the mem;      they are no longer accurate provided that they are reached by this      definition, so drop them.  */
for|for
control|(
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
if|if
condition|(
name|expr_equiv_p
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|mem
argument_list|)
condition|)
return|return;
name|note
operator|=
name|find_reg_equal_equiv_note
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|note
operator|||
operator|!
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mem
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"STORE_MOTION  drop REG_EQUAL note at insn %d:\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
name|remove_reachable_equiv_notes
argument_list|(
name|bb
argument_list|,
name|smexpr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete a store, but copy the value that would have been stored into    the reaching_reg for later storing.  */
end_comment

begin_function
specifier|static
name|void
name|delete_store
parameter_list|(
name|struct
name|ls_expr
modifier|*
name|expr
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|,
name|i
decl_stmt|,
name|del
decl_stmt|;
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL_RTX
condition|)
name|expr
operator|->
name|reaching_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|expr
operator|->
name|pattern
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|=
name|expr
operator|->
name|reaching_reg
expr_stmt|;
for|for
control|(
name|i
operator|=
name|AVAIL_STORE_LIST
argument_list|(
name|expr
argument_list|)
init|;
name|i
condition|;
name|i
operator|=
name|XEXP
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|del
operator|=
name|XEXP
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|del
argument_list|)
operator|==
name|bb
condition|)
block|{
comment|/* We know there is only one since we deleted redundant 	     ones during the available computation.  */
name|replace_store_insn
argument_list|(
name|reg
argument_list|,
name|del
argument_list|,
name|bb
argument_list|,
name|expr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free memory used by store motion.  */
end_comment

begin_function
specifier|static
name|void
name|free_store_memory
parameter_list|(
name|void
parameter_list|)
block|{
name|free_ldst_mems
argument_list|()
expr_stmt|;
if|if
condition|(
name|ae_gen
condition|)
name|sbitmap_vector_free
argument_list|(
name|ae_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae_kill
condition|)
name|sbitmap_vector_free
argument_list|(
name|ae_kill
argument_list|)
expr_stmt|;
if|if
condition|(
name|transp
condition|)
name|sbitmap_vector_free
argument_list|(
name|transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_antloc
condition|)
name|sbitmap_vector_free
argument_list|(
name|st_antloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_insert_map
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_insert_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|pre_delete_map
condition|)
name|sbitmap_vector_free
argument_list|(
name|pre_delete_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_set_in_block
condition|)
name|sbitmap_vector_free
argument_list|(
name|reg_set_in_block
argument_list|)
expr_stmt|;
name|ae_gen
operator|=
name|ae_kill
operator|=
name|transp
operator|=
name|st_antloc
operator|=
name|NULL
expr_stmt|;
name|pre_insert_map
operator|=
name|pre_delete_map
operator|=
name|reg_set_in_block
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform store motion. Much like gcse, except we move expressions the    other way by looking at the flowgraph in reverse.  */
end_comment

begin_function
specifier|static
name|void
name|store_motion
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|int
name|x
decl_stmt|;
name|struct
name|ls_expr
modifier|*
name|ptr
decl_stmt|;
name|int
name|update_flow
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"before store motion\n"
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|init_alias_analysis
argument_list|()
expr_stmt|;
comment|/* Find all the available and anticipatable stores.  */
name|num_stores
operator|=
name|compute_store_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_stores
operator|==
literal|0
condition|)
block|{
name|sbitmap_vector_free
argument_list|(
name|reg_set_in_block
argument_list|)
expr_stmt|;
name|end_alias_analysis
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Now compute kill& transp vectors.  */
name|build_store_vectors
argument_list|()
expr_stmt|;
name|add_noreturn_fake_exit_edges
argument_list|()
expr_stmt|;
name|connect_infinite_loops_to_exit
argument_list|()
expr_stmt|;
name|edge_list
operator|=
name|pre_edge_rev_lcm
argument_list|(
name|gcse_file
argument_list|,
name|num_stores
argument_list|,
name|transp
argument_list|,
name|ae_gen
argument_list|,
name|st_antloc
argument_list|,
name|ae_kill
argument_list|,
operator|&
name|pre_insert_map
argument_list|,
operator|&
name|pre_delete_map
argument_list|)
expr_stmt|;
comment|/* Now we want to insert the new stores which are going to be needed.  */
for|for
control|(
name|ptr
operator|=
name|first_ls_expr
argument_list|()
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|next_ls_expr
argument_list|(
name|ptr
argument_list|)
control|)
block|{
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pre_delete_map
index|[
name|bb
operator|->
name|index
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
condition|)
name|delete_store
argument_list|(
name|ptr
argument_list|,
name|bb
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NUM_EDGES
argument_list|(
name|edge_list
argument_list|)
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pre_insert_map
index|[
name|x
index|]
argument_list|,
name|ptr
operator|->
name|index
argument_list|)
condition|)
name|update_flow
operator||=
name|insert_store
argument_list|(
name|ptr
argument_list|,
name|INDEX_EDGE
argument_list|(
name|edge_list
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|update_flow
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
name|free_store_memory
argument_list|()
expr_stmt|;
name|free_edge_list
argument_list|(
name|edge_list
argument_list|)
expr_stmt|;
name|remove_fake_edges
argument_list|()
expr_stmt|;
name|end_alias_analysis
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Entry point for jump bypassing optimization pass.  */
end_comment

begin_function
name|int
name|bypass_jumps
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|)
block|{
name|int
name|changed
decl_stmt|;
comment|/* We do not construct an accurate cfg in functions which call      setjmp, so just punt to be safe.  */
if|if
condition|(
name|current_function_calls_setjmp
condition|)
return|return
literal|0
return|;
comment|/* For calling dump_foo fns from gdb.  */
name|debug_stderr
operator|=
name|stderr
expr_stmt|;
name|gcse_file
operator|=
name|file
expr_stmt|;
comment|/* Identify the basic block information for this function, including      successors and predecessors.  */
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_flow_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Return if there's nothing to do, or it is too expensive.  */
if|if
condition|(
name|n_basic_blocks
operator|<=
literal|1
operator|||
name|is_too_expensive
argument_list|(
name|_
argument_list|(
literal|"jump bypassing disabled"
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|gcc_obstack_init
argument_list|(
operator|&
name|gcse_obstack
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
literal|0
expr_stmt|;
comment|/* We need alias.  */
name|init_alias_analysis
argument_list|()
expr_stmt|;
comment|/* Record where pseudo-registers are set.  This data is kept accurate      during each pass.  ??? We could also record hard-reg information here      [since it's unchanging], however it is currently done during hash table      computation.       It may be tempting to compute MEM set information here too, but MEM sets      will be subject to code motion one day and thus we need to compute      information about memory sets when we build the hash tables.  */
name|alloc_reg_set_mem
argument_list|(
name|max_gcse_regno
argument_list|)
expr_stmt|;
name|compute_sets
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|alloc_gcse_mem
argument_list|(
name|get_insns
argument_list|()
argument_list|)
expr_stmt|;
name|changed
operator|=
name|one_cprop_pass
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_gcse_mem
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"BYPASS of %s: %d basic blocks, "
argument_list|,
name|current_function_name
argument_list|()
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d bytes\n\n"
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|gcse_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free_reg_set_mem
argument_list|()
expr_stmt|;
comment|/* We are finished with alias.  */
name|end_alias_analysis
argument_list|()
expr_stmt|;
name|allocate_reg_info
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Return true if the graph is too expensive to optimize. PASS is the    optimization about to be performed.  */
end_comment

begin_function
specifier|static
name|bool
name|is_too_expensive
parameter_list|(
specifier|const
name|char
modifier|*
name|pass
parameter_list|)
block|{
comment|/* Trying to perform global optimizations on flow graphs which have      a high connectivity will take a long time and is unlikely to be      particularly useful.            In normal circumstances a cfg should have about twice as many      edges as blocks.  But we do not want to punish small functions      which have a couple switch statements.  Rather than simply      threshold the number of blocks, uses something with a more      graceful degradation.  */
if|if
condition|(
name|n_edges
operator|>
literal|20000
operator|+
name|n_basic_blocks
operator|*
literal|4
condition|)
block|{
if|if
condition|(
name|warn_disabled_optimization
condition|)
name|warning
argument_list|(
literal|"%s: %d basic blocks and %d edges/basic block"
argument_list|,
name|pass
argument_list|,
name|n_basic_blocks
argument_list|,
name|n_edges
operator|/
name|n_basic_blocks
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* If allocating memory for the cprop bitmap would take up too much      storage it's better just to disable the optimization.  */
if|if
condition|(
operator|(
name|n_basic_blocks
operator|*
name|SBITMAP_SET_SIZE
argument_list|(
name|max_reg_num
argument_list|()
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|SBITMAP_ELT_TYPE
argument_list|)
operator|)
operator|>
name|MAX_GCSE_MEMORY
condition|)
block|{
if|if
condition|(
name|warn_disabled_optimization
condition|)
name|warning
argument_list|(
literal|"%s: %d basic blocks and %d registers"
argument_list|,
name|pass
argument_list|,
name|n_basic_blocks
argument_list|,
name|max_reg_num
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-gcse.h"
end_include

end_unit

