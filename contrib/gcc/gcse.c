begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Global common subexpression elimination/Partial redundancy elimination    and global constant/copy propagation for GNU compiler.    Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* TODO    - reordering of memory allocation and freeing to be more space efficient    - do rough calc of how many regs are needed in each block, and a rough      calc of how many regs are available in each class and use that to      throttle back the code in cases where RTX_COST is minimal.    - dead store elimination    - a store to the same address as a load does not kill the load if the      source of the store is also the destination of the load.  Handling this      allows more load motion, particularly out of loops.    - ability to realloc sbitmap vectors would allow one initial computation      of reg_set_in_block with only subsequent additions, rather than      recomputing it for each pass  */
end_comment

begin_comment
comment|/* References searched while implementing this.     Compilers Principles, Techniques and Tools    Aho, Sethi, Ullman    Addison-Wesley, 1988     Global Optimization by Suppression of Partial Redundancies    E. Morel, C. Renvoise    communications of the acm, Vol. 22, Num. 2, Feb. 1979     A Portable Machine-Independent Global Optimizer - Design and Measurements    Frederick Chow    Stanford Ph.D. thesis, Dec. 1983     A Fast Algorithm for Code Movement Optimization    D.M. Dhamdhere    SIGPLAN Notices, Vol. 23, Num. 10, Oct. 1988     A Solution to a Problem with Morel and Renvoise's    Global Optimization by Suppression of Partial Redundancies    K-H Drechsler, M.P. Stadel    ACM TOPLAS, Vol. 10, Num. 4, Oct. 1988     Practical Adaptation of the Global Optimization    Algorithm of Morel and Renvoise    D.M. Dhamdhere    ACM TOPLAS, Vol. 13, Num. 2. Apr. 1991     Efficiently Computing Static Single Assignment Form and the Control    Dependence Graph    R. Cytron, J. Ferrante, B.K. Rosen, M.N. Wegman, and F.K. Zadeck    ACM TOPLAS, Vol. 13, Num. 4, Oct. 1991     Lazy Code Motion    J. Knoop, O. Ruthing, B. Steffen    ACM SIGPLAN Notices Vol. 27, Num. 7, Jul. 1992, '92 Conference on PLDI     What's In a Region?  Or Computing Control Dependence Regions in Near-Linear    Time for Reducible Flow Control    Thomas Ball    ACM Letters on Programming Languages and Systems,    Vol. 2, Num. 1-4, Mar-Dec 1993     An Efficient Representation for Sparse Sets    Preston Briggs, Linda Torczon    ACM Letters on Programming Languages and Systems,    Vol. 2, Num. 1-4, Mar-Dec 1993     A Variation of Knoop, Ruthing, and Steffen's Lazy Code Motion    K-H Drechsler, M.P. Stadel    ACM SIGPLAN Notices, Vol. 28, Num. 5, May 1993     Partial Dead Code Elimination    J. Knoop, O. Ruthing, B. Steffen    ACM SIGPLAN Notices, Vol. 29, Num. 6, Jun. 1994     Effective Partial Redundancy Elimination    P. Briggs, K.D. Cooper    ACM SIGPLAN Notices, Vol. 29, Num. 6, Jun. 1994     The Program Structure Tree: Computing Control Regions in Linear Time    R. Johnson, D. Pearson, K. Pingali    ACM SIGPLAN Notices, Vol. 29, Num. 6, Jun. 1994     Optimal Code Motion: Theory and Practice    J. Knoop, O. Ruthing, B. Steffen    ACM TOPLAS, Vol. 16, Num. 4, Jul. 1994     The power of assignment motion    J. Knoop, O. Ruthing, B. Steffen    ACM SIGPLAN Notices Vol. 30, Num. 6, Jun. 1995, '95 Conference on PLDI     Global code motion / global value numbering    C. Click    ACM SIGPLAN Notices Vol. 30, Num. 6, Jun. 1995, '95 Conference on PLDI     Value Driven Redundancy Elimination    L.T. Simpson    Rice University Ph.D. thesis, Apr. 1996     Value Numbering    L.T. Simpson    Massively Scalar Compiler Project, Rice University, Sep. 1996     High Performance Compilers for Parallel Computing    Michael Wolfe    Addison-Wesley, 1996     Advanced Compiler Design and Implementation    Steven Muchnick    Morgan Kaufmann, 1997     People wishing to speed up the code here should read:      Elimination Algorithms for Data Flow Analysis      B.G. Ryder, M.C. Paull      ACM Computing Surveys, Vol. 18, Num. 3, Sep. 1986       How to Analyze Large Programs Efficiently and Informatively      D.M. Dhamdhere, B.K. Rosen, F.K. Zadeck      ACM SIGPLAN Notices Vol. 27, Num. 7, Jul. 1992, '92 Conference on PLDI     People wishing to do something different can find various possibilities    in the above papers and elsewhere. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|gmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Maximum number of passes to perform.  */
end_comment

begin_define
define|#
directive|define
name|MAX_PASSES
value|1
end_define

begin_comment
comment|/* Propagate flow information through back edges and thus enable PRE's    moving loop invariant calculations out of loops.     Originally this tended to create worse overall code, but several    improvements during the development of PRE seem to have made following    back edges generally a win.     Note much of the loop invariant code motion done here would normally    be done by loop.c, which has more heuristics for when to move invariants    out of loops.  At some point we might need to move some of those    heuristics into gcse.c.  */
end_comment

begin_define
define|#
directive|define
name|FOLLOW_BACK_EDGES
value|1
end_define

begin_comment
comment|/* We support GCSE via Partial Redundancy Elimination.  PRE optimizations    are a superset of those done by GCSE.     We perform the following steps:     1) Compute basic block information.     2) Compute table of places where registers are set.     3) Perform copy/constant propagation.     4) Perform global cse.     5) Perform another pass of copy/constant propagation.     Two passes of copy/constant propagation are done because the first one    enables more GCSE and the second one helps to clean up the copies that    GCSE creates.  This is needed more for PRE than for Classic because Classic    GCSE will try to use an existing register containing the common    subexpression rather than create a new one.  This is harder to do for PRE    because of the code motion (which Classic GCSE doesn't do).     Expressions we are interested in GCSE-ing are of the form    (set (pseudo-reg) (expression)).    Function want_to_gcse_p says what these are.     PRE handles moving invariant expressions out of loops (by treating them as    partially redundant).     Eventually it would be nice to replace cse.c/gcse.c with SSA (static single    assignment) based GVN (global value numbering).  L. T. Simpson's paper    (Rice University) on value numbering is a useful reference for this.     **********************     We used to support multiple passes but there are diminishing returns in    doing so.  The first pass usually makes 90% of the changes that are doable.    A second pass can make a few more changes made possible by the first pass.    Experiments show any further passes don't make enough changes to justify    the expense.     A study of spec92 using an unlimited number of passes:    [1 pass] = 1208 substitutions, [2] = 577, [3] = 202, [4] = 192, [5] = 83,    [6] = 34, [7] = 17, [8] = 9, [9] = 4, [10] = 4, [11] = 2,    [12] = 2, [13] = 1, [15] = 1, [16] = 2, [41] = 1     It was found doing copy propagation between each pass enables further    substitutions.     PRE is quite expensive in complicated functions because the DFA can take    awhile to converge.  Hence we only perform one pass.  Macro MAX_PASSES can    be modified if one wants to experiment.     **********************     The steps for PRE are:     1) Build the hash table of expressions we wish to GCSE (expr_hash_table).     2) Perform the data flow analysis for PRE.     3) Delete the redundant instructions     4) Insert the required copies [if any] that make the partially       redundant instructions fully redundant.     5) For other reaching expressions, insert an instruction to copy the value       to a newly created pseudo that will reach the redundant instruction.     The deletion is done first so that when we do insertions we    know which pseudo reg to use.     Various papers have argued that PRE DFA is expensive (O(n^2)) and others    argue it is not.  The number of iterations for the algorithm to converge    is typically 2-4 so I don't view it as that expensive (relatively speaking).     PRE GCSE depends heavily on the second CSE pass to clean up the copies    we create.  To make an expression reach the place where it's redundant,    the result of the expression is copied to a new register, and the redundant    expression is deleted by replacing it with this new register.  Classic GCSE    doesn't have this problem as much as it computes the reaching defs of    each register in each block and thus can try to use an existing register.     **********************     A fair bit of simplicity is created by creating small functions for simple    tasks, even when the function is only called in one place.  This may    measurably slow things down [or may not] by creating more function call    overhead than is necessary.  The source is laid out so that it's trivial    to make the affected functions inline so that one can measure what speed    up, if any, can be achieved, and maybe later when things settle things can    be rearranged.     Help stamp out big monolithic functions!  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* GCSE global vars.  */
end_comment

begin_comment
comment|/* -dG dump file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|gcse_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Note whether or not we should run jump optimization after gcse.  We    want to do this for two cases.      * If we changed any jumps via cprop.      * If we added any labels via edge splitting.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|run_jump_opt_after_gcse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element I is a list of I's predecessors/successors.  */
end_comment

begin_decl_stmt
specifier|static
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element I is the number of predecessors/successors of basic block I.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|num_preds
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|num_succs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmaps are normally not included in debugging dumps.    However it's useful to be able to print them from GDB.    We could create special functions for this, but it's simpler to    just allow passing stderr to the dump_foo fns.  Since stderr can    be a macro, we store a copy here.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|debug_stderr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An obstack for our working variables.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|gcse_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero for each mode that supports (set (reg) (reg)).    This is trivially true for integer and floating point values.    It may or may not be true for condition codes.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|can_copy_p
index|[
operator|(
name|int
operator|)
name|NUM_MACHINE_MODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if can_copy_p has been initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|can_copy_init_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table of expressions.  */
end_comment

begin_struct
struct|struct
name|expr
block|{
comment|/* The expression (SET_SRC for expressions, PATTERN for assignments).  */
name|rtx
name|expr
decl_stmt|;
comment|/* Index in the available expression bitmaps.  */
name|int
name|bitmap_index
decl_stmt|;
comment|/* Next entry with the same hash.  */
name|struct
name|expr
modifier|*
name|next_same_hash
decl_stmt|;
comment|/* List of anticipatable occurrences in basic blocks in the function.      An "anticipatable occurrence" is one that is the first occurrence in the      basic block, the operands are not modified in the basic block prior      to the occurrence and the output is not used between the start of      the block and the occurrence.  */
name|struct
name|occr
modifier|*
name|antic_occr
decl_stmt|;
comment|/* List of available occurrence in basic blocks in the function.      An "available occurrence" is one that is the last occurrence in the      basic block and the operands are not modified by following statements in      the basic block [including this insn].  */
name|struct
name|occr
modifier|*
name|avail_occr
decl_stmt|;
comment|/* Non-null if the computation is PRE redundant.      The value is the newly created pseudo-reg to record a copy of the      expression in all the places that reach the redundant copy.  */
name|rtx
name|reaching_reg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Occurrence of an expression.    There is one per basic block.  If a pattern appears more than once the    last appearance is used [or first for anticipatable expressions].  */
end_comment

begin_struct
struct|struct
name|occr
block|{
comment|/* Next occurrence of this expression.  */
name|struct
name|occr
modifier|*
name|next
decl_stmt|;
comment|/* The insn that computes the expression.  */
name|rtx
name|insn
decl_stmt|;
comment|/* Non-zero if this [anticipatable] occurrence has been deleted.  */
name|char
name|deleted_p
decl_stmt|;
comment|/* Non-zero if this [available] occurrence has been copied to      reaching_reg.  */
comment|/* ??? This is mutually exclusive with deleted_p, so they could share      the same byte.  */
name|char
name|copied_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Expression and copy propagation hash tables.    Each hash table is an array of buckets.    ??? It is known that if it were an array of entries, structure elements    `next_same_hash' and `bitmap_index' wouldn't be necessary.  However, it is    not clear whether in the final analysis a sufficient amount of memory would    be saved as the size of the available expression bitmaps would be larger    [one could build a mapping table without holes afterwards though].    Someday I'll perform the computation and figure it out. */
end_comment

begin_comment
comment|/* Total size of the expression hash table, in elements.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|expr_hash_table_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The table itself.    This is an array of `expr_hash_table_size' elements.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
modifier|*
name|expr_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total size of the copy propagation hash table, in elements.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|set_hash_table_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The table itself.    This is an array of `set_hash_table_size' elements.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
modifier|*
name|set_hash_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping of uids to cuids.    Only real insns get cuids.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|uid_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest UID in UID_CUID.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the cuid of an insn.  */
end_comment

begin_define
define|#
directive|define
name|INSN_CUID
parameter_list|(
name|INSN
parameter_list|)
value|(uid_cuid[INSN_UID (INSN)])
end_define

begin_comment
comment|/* Number of cuids.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_cuid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mapping of cuids to insns.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|cuid_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get insn from cuid.  */
end_comment

begin_define
define|#
directive|define
name|CUID_INSN
parameter_list|(
name|CUID
parameter_list|)
value|(cuid_insn[CUID])
end_define

begin_comment
comment|/* Maximum register number in function prior to doing gcse + 1.    Registers created during this pass have regno>= max_gcse_regno.    This is named with "gcse" to not collide with global of same name.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_gcse_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of cse-able expressions found.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_exprs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of assignments for copy propagation found.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_sets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of registers that are modified.    For each register, each element is a list of places where the pseudo-reg    is set.     For simplicity, GCSE is done on sets of pseudo-regs only.  PRE GCSE only    requires knowledge of which blocks kill which regs [and thus could use    a bitmap instead of the lists `reg_set_table' uses].     `reg_set_table' and could be turned into an array of bitmaps    (num-bbs x num-regs)    [however perhaps it may be useful to keep the data as is].    One advantage of recording things this way is that `reg_set_table' is    fairly sparse with respect to pseudo regs but for hard regs could be    fairly dense [relatively speaking].    And recording sets of pseudo-regs in lists speeds    up functions like compute_transp since in the case of pseudo-regs we only    need to iterate over the number of times a pseudo-reg is set, not over the    number of basic blocks [clearly there is a bit of a slow down in the cases    where a pseudo is set more than once in a block, however it is believed    that the net effect is to speed things up].  This isn't done for hard-regs    because recording call-clobbered hard-regs in `reg_set_table' at each    function call can consume a fair bit of memory, and iterating over hard-regs    stored this way in compute_transp will be more expensive.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|reg_set
block|{
comment|/* The next setting of this register.  */
name|struct
name|reg_set
modifier|*
name|next
decl_stmt|;
comment|/* The insn where it was set.  */
name|rtx
name|insn
decl_stmt|;
block|}
name|reg_set
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|reg_set
modifier|*
modifier|*
name|reg_set_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of `reg_set_table'.    The table starts out at max_gcse_regno + slop, and is enlarged as    necessary.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_set_table_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount to grow `reg_set_table' by when it's full.  */
end_comment

begin_define
define|#
directive|define
name|REG_SET_TABLE_SLOP
value|100
end_define

begin_comment
comment|/* Bitmap containing one bit for each register in the program.    Used when performing GCSE to track which registers have been set since    the start of the basic block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|reg_set_bitmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each block, a bitmap of registers set in the block.    This is used by expr_killed_p and compute_transp.    It is computed during hash table computation and not by compute_sets    as it includes registers added since the last pass (or between cprop and    gcse) and it's currently not easy to realloc sbitmap vectors.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|reg_set_in_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each block, non-zero if memory is set in that block.    This is computed during hash table computation and is used by    expr_killed_p and compute_transp.    ??? Handling of memory is very simple, we don't make any attempt    to optimize things (later).    ??? This can be computed by compute_sets since the information    doesn't change.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mem_set_in_block
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various variables for statistics gathering.  */
end_comment

begin_comment
comment|/* Memory used in a pass.    This isn't intended to be absolutely precise.  Its intent is only    to keep an eye on memory usage.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bytes_used
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GCSE substitutions made.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gcse_subst_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of copy instructions created.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gcse_create_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of constants propagated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|const_prop_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of copys propagated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|copy_prop_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|current_function_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|current_function_calls_setjmp
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* These variables are used by classic GCSE.    Normally they'd be defined a bit later, but `rd_gen' needs to    be declared sooner.  */
end_comment

begin_comment
comment|/* A bitmap of all ones for implementing the algorithm for available    expressions and reaching definitions.  */
end_comment

begin_comment
comment|/* ??? Available expression bitmaps have a different size than reaching    definition bitmaps.  This should be the larger of the two, however, it    is not currently used for reaching definitions.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|u_bitmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each block has a bitmap of each type.    The length of each blocks bitmap is:         max_cuid  - for reaching definitions        n_exprs - for available expressions     Thus we view the bitmaps as 2 dimensional arrays.  i.e.    rd_kill[block_num][cuid_num]    ae_kill[block_num][expr_num] */
end_comment

begin_comment
comment|/* For reaching defs */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|rd_kill
decl_stmt|,
modifier|*
name|rd_gen
decl_stmt|,
modifier|*
name|reaching_defs
decl_stmt|,
modifier|*
name|rd_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for available exprs */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|ae_kill
decl_stmt|,
modifier|*
name|ae_gen
decl_stmt|,
modifier|*
name|ae_in
decl_stmt|,
modifier|*
name|ae_out
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|void
name|compute_can_copy
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gmalloc
name|PROTO
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|grealloc
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gcse_alloc
name|PROTO
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_gcse_mem
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_gcse_mem
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_reg_set_mem
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_reg_set_mem
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_one_set
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_set_info
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_sets
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_scan_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_scan_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_scan_clobber
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hash_scan_call
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|want_to_gcse_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oprs_unchanged_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oprs_anticipatable_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oprs_available_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_expr_in_table
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_set_in_table
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_expr
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_expr_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|hash_set
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expr_equiv_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_last_reg_set_info
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_last_mem_set_info
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_last_set_info
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_hash_table
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_set_hash_table
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_set_hash_table
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_set_hash_table
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_expr_hash_table
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_expr_hash_table
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_expr_hash_table
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_hash_table
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|expr
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
name|lookup_expr
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
name|lookup_set
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
name|next_set
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_opr_set_tables
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|oprs_not_set_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_call
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_clobber
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_oprs_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_cprop_mem
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_cprop_mem
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_transp
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|sbitmap
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_transpout
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_local_properties
name|PROTO
argument_list|(
operator|(
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|sbitmap
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_cprop_avinout
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_cprop_data
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_used_regs
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_replace_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|expr
modifier|*
name|find_avail_set
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cprop_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cprop
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|one_cprop_pass
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_pre_mem
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_pre_mem
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_pre_data
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pre_expr_reaches_here_p
name|PROTO
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|expr
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insert_insn_end_bb
name|PROTO
argument_list|(
operator|(
expr|struct
name|expr
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pre_insert
name|PROTO
argument_list|(
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pre_insert_copy_insn
name|PROTO
argument_list|(
operator|(
expr|struct
name|expr
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pre_insert_copies
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pre_delete
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pre_gcse
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|one_pre_gcse_pass
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_label_notes
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_rd_mem
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_rd_mem
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_rd_kill_set
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_kill_rd
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_rd
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alloc_avail_expr_mem
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_avail_expr_mem
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_ae_gen
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expr_killed_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_ae_kill
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_available
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expr_reaches_here_p
name|PROTO
argument_list|(
operator|(
expr|struct
name|occr
operator|*
operator|,
expr|struct
name|expr
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|computing_insn
name|PROTO
argument_list|(
operator|(
expr|struct
name|expr
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_reaches_here_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_disregard_other_sets
name|PROTO
argument_list|(
operator|(
expr|struct
name|reg_set
operator|*
operator|*
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|handle_avail_expr
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
expr|struct
name|expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|classic_gcse
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|one_classic_gcse_pass
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Entry point for global common subexpression elimination.    F is the first instruction in the function.  */
end_comment

begin_function
name|int
name|gcse_main
parameter_list|(
name|f
parameter_list|,
name|file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|changed
decl_stmt|,
name|pass
decl_stmt|;
comment|/* Bytes used at start of pass.  */
name|int
name|initial_bytes_used
decl_stmt|;
comment|/* Maximum number of bytes used by a pass.  */
name|int
name|max_pass_bytes
decl_stmt|;
comment|/* Point to release obstack data from for each pass.  */
name|char
modifier|*
name|gcse_obstack_bottom
decl_stmt|;
comment|/* We do not construct an accurate cfg in functions which call      setjmp, so just punt to be safe.  */
if|if
condition|(
name|current_function_calls_setjmp
condition|)
return|return
literal|0
return|;
comment|/* Assume that we do not need to run jump optimizations after gcse.  */
name|run_jump_opt_after_gcse
operator|=
literal|0
expr_stmt|;
comment|/* For calling dump_foo fns from gdb.  */
name|debug_stderr
operator|=
name|stderr
expr_stmt|;
name|gcse_file
operator|=
name|file
expr_stmt|;
comment|/* Identify the basic block information for this function, including      successors and predecessors.  */
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|find_basic_blocks
argument_list|(
name|f
argument_list|,
name|max_gcse_regno
argument_list|,
name|file
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Return if there's nothing to do.  */
if|if
condition|(
name|n_basic_blocks
operator|<=
literal|1
condition|)
block|{
comment|/* Free storage allocated by find_basic_blocks.  */
name|free_basic_block_vars
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* See what modes support reg/reg copy operations.  */
if|if
condition|(
operator|!
name|can_copy_init_p
condition|)
block|{
name|compute_can_copy
argument_list|()
expr_stmt|;
name|can_copy_init_p
operator|=
literal|1
expr_stmt|;
block|}
name|gcc_obstack_init
argument_list|(
operator|&
name|gcse_obstack
argument_list|)
expr_stmt|;
comment|/* Allocate and compute predecessors/successors.  */
name|s_preds
operator|=
operator|(
name|int_list_ptr
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int_list_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|s_succs
operator|=
operator|(
name|int_list_ptr
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int_list_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|num_preds
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|num_succs
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
literal|4
operator|*
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int_list_ptr
argument_list|)
expr_stmt|;
name|compute_preds_succs
argument_list|(
name|s_preds
argument_list|,
name|s_succs
argument_list|,
name|num_preds
argument_list|,
name|num_succs
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_bb_data
argument_list|(
name|file
argument_list|,
name|s_preds
argument_list|,
name|s_succs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Record where pseudo-registers are set.      This data is kept accurate during each pass.      ??? We could also record hard-reg information here      [since it's unchanging], however it is currently done during      hash table computation.       It may be tempting to compute MEM set information here too, but MEM      sets will be subject to code motion one day and thus we need to compute      information about memory sets when we build the hash tables.  */
name|alloc_reg_set_mem
argument_list|(
name|max_gcse_regno
argument_list|)
expr_stmt|;
name|compute_sets
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|pass
operator|=
literal|0
expr_stmt|;
name|initial_bytes_used
operator|=
name|bytes_used
expr_stmt|;
name|max_pass_bytes
operator|=
literal|0
expr_stmt|;
name|gcse_obstack_bottom
operator|=
name|gcse_alloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
operator|&&
name|pass
operator|<
name|MAX_PASSES
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"GCSE pass %d\n\n"
argument_list|,
name|pass
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Initialize bytes_used to the space for the pred/succ lists, 	 and the reg_set_table data.  */
name|bytes_used
operator|=
name|initial_bytes_used
expr_stmt|;
comment|/* Each pass may create new registers, so recalculate each time.  */
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|alloc_gcse_mem
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Don't allow constant propagation to modify jumps 	 during this pass.  */
name|changed
operator|=
name|one_cprop_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize_size
condition|)
name|changed
operator||=
name|one_classic_gcse_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|changed
operator||=
name|one_pre_gcse_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_pass_bytes
operator|<
name|bytes_used
condition|)
name|max_pass_bytes
operator|=
name|bytes_used
expr_stmt|;
name|free_gcse_mem
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|gcse_obstack
argument_list|,
name|gcse_obstack_bottom
argument_list|)
expr_stmt|;
name|pass
operator|++
expr_stmt|;
block|}
comment|/* Do one last pass of copy propagation, including cprop into      conditional jumps.  */
name|max_gcse_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
name|alloc_gcse_mem
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* This time, go ahead and allow cprop to alter jumps.  */
name|one_cprop_pass
argument_list|(
name|pass
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_gcse_mem
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"GCSE of %s: %d basic blocks, "
argument_list|,
name|current_function_name
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d pass%s, %d bytes\n\n"
argument_list|,
name|pass
argument_list|,
name|pass
operator|>
literal|1
condition|?
literal|"es"
else|:
literal|""
argument_list|,
name|max_pass_bytes
argument_list|)
expr_stmt|;
block|}
comment|/* Free our obstack.  */
name|obstack_free
argument_list|(
operator|&
name|gcse_obstack
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Free reg_set_table.  */
name|free_reg_set_mem
argument_list|()
expr_stmt|;
comment|/* Free storage used to record predecessor/successor data.  */
name|free_bb_mem
argument_list|()
expr_stmt|;
comment|/* Free storage allocated by find_basic_blocks.  */
name|free_basic_block_vars
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|run_jump_opt_after_gcse
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Misc. utilities.  */
end_comment

begin_comment
comment|/* Compute which modes support reg/reg copy operations.  */
end_comment

begin_function
specifier|static
name|void
name|compute_can_copy
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|AVOID_CCMODE_COPIES
name|rtx
name|reg
decl_stmt|,
name|insn
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|free_point
init|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|can_copy_p
argument_list|,
name|NUM_MACHINE_MODES
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_MACHINE_MODES
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|MODE_CC
case|:
ifdef|#
directive|ifdef
name|AVOID_CCMODE_COPIES
name|can_copy_p
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
operator|(
expr|enum
name|machine_mode
operator|)
name|i
argument_list|,
name|LAST_VIRTUAL_REGISTER
operator|+
literal|1
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
name|NULL_PTR
argument_list|)
operator|>=
literal|0
condition|)
name|can_copy_p
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
default|default :
name|can_copy_p
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Free the objects we just allocated.  */
name|obfree
argument_list|(
name|free_point
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cover function to xmalloc to record bytes allocated.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|bytes_used
operator|+=
name|size
expr_stmt|;
return|return
name|xmalloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cover function to xrealloc.    We don't record the additional size since we don't know it.    It won't affect memory usage stats much anyway.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|grealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
return|return
name|xrealloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cover function to obstack_alloc.    We don't need to record the bytes allocated here since    obstack_chunk_alloc is set to gmalloc.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gcse_alloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|gcse_obstack
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate memory for the cuid mapping array,    and reg/memory set tracking tables.     This is called at the start of each pass.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_gcse_mem
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Find the largest UID and create a mapping from UIDs to CUIDs.      CUIDs are like UIDs except they increase monotonically, have no gaps,      and only apply to real insns.  */
name|max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
name|n
operator|=
operator|(
name|max_uid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|uid_cuid
operator|=
operator|(
name|int
operator|*
operator|)
name|gmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|uid_cuid
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|=
name|i
operator|++
expr_stmt|;
else|else
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|=
name|i
expr_stmt|;
block|}
comment|/* Create a table mapping cuids to insns.  */
name|max_cuid
operator|=
name|i
expr_stmt|;
name|n
operator|=
operator|(
name|max_cuid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
expr_stmt|;
name|cuid_insn
operator|=
operator|(
name|rtx
operator|*
operator|)
name|gmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cuid_insn
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|CUID_INSN
argument_list|(
name|i
argument_list|)
operator|=
name|insn
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* Allocate vars to track sets of regs.  */
name|reg_set_bitmap
operator|=
operator|(
name|sbitmap
operator|)
name|sbitmap_alloc
argument_list|(
name|max_gcse_regno
argument_list|)
expr_stmt|;
comment|/* Allocate vars to track sets of regs, memory per block.  */
name|reg_set_in_block
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|max_gcse_regno
argument_list|)
expr_stmt|;
name|mem_set_in_block
operator|=
operator|(
name|char
operator|*
operator|)
name|gmalloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free memory allocated by alloc_gcse_mem.  */
end_comment

begin_function
specifier|static
name|void
name|free_gcse_mem
parameter_list|()
block|{
name|free
argument_list|(
name|uid_cuid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cuid_insn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_set_bitmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_set_in_block
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mem_set_in_block
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the local properties of each recorded expression.    Local properties are those that are defined by the block, irrespective    of other blocks.     An expression is transparent in a block if its operands are not modified    in the block.     An expression is computed (locally available) in a block if it is computed    at least once and expression would contain the same value if the    computation was moved to the end of the block.     An expression is locally anticipatable in a block if it is computed at    least once and expression would contain the same value if the computation    was moved to the beginning of the block.     We call this routine for cprop, pre and code hoisting.  They all    compute basically the same information and thus can easily share    this code.     TRANSP, COMP, and ANTLOC are destination sbitmaps for recording    local properties.  If NULL, then it is not necessary to compute    or record that particular property.     SETP controls which hash table to look at.  If zero, this routine    looks at the expr hash table; if nonzero this routine looks at    the set hash table.  Additionally, TRANSP is computed as ~TRANSP,    since this is really cprop's ABSALTERED.  */
end_comment

begin_function
specifier|static
name|void
name|compute_local_properties
parameter_list|(
name|transp
parameter_list|,
name|comp
parameter_list|,
name|antloc
parameter_list|,
name|setp
parameter_list|)
name|sbitmap
modifier|*
name|transp
decl_stmt|;
name|sbitmap
modifier|*
name|comp
decl_stmt|;
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
name|int
name|setp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|hash_table_size
decl_stmt|;
name|struct
name|expr
modifier|*
modifier|*
name|hash_table
decl_stmt|;
comment|/* Initialize any bitmaps that were passed in.  */
if|if
condition|(
name|transp
condition|)
block|{
if|if
condition|(
name|setp
condition|)
name|sbitmap_vector_zero
argument_list|(
name|transp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
else|else
name|sbitmap_vector_ones
argument_list|(
name|transp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|comp
condition|)
name|sbitmap_vector_zero
argument_list|(
name|comp
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|antloc
condition|)
name|sbitmap_vector_zero
argument_list|(
name|antloc
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* We use the same code for cprop, pre and hoisting.  For cprop      we care about the set hash table, for pre and hoisting we      care about the expr hash table.  */
name|hash_table_size
operator|=
name|setp
condition|?
name|set_hash_table_size
else|:
name|expr_hash_table_size
expr_stmt|;
name|hash_table
operator|=
name|setp
condition|?
name|set_hash_table
else|:
name|expr_hash_table
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hash_table_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
for|for
control|(
name|expr
operator|=
name|hash_table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|int
name|indx
init|=
name|expr
operator|->
name|bitmap_index
decl_stmt|;
comment|/* The expression is transparent in this block if it is not killed. 	     We start by assuming all are transparent [none are killed], and 	     then reset the bits for those that are.  */
if|if
condition|(
name|transp
condition|)
name|compute_transp
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|indx
argument_list|,
name|transp
argument_list|,
name|setp
argument_list|)
expr_stmt|;
comment|/* The occurrences recorded in antic_occr are exactly those that 	     we want to set to non-zero in ANTLOC.  */
if|if
condition|(
name|antloc
condition|)
block|{
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
name|int
name|bb
init|=
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
decl_stmt|;
name|SET_BIT
argument_list|(
name|antloc
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* While we're scanning the table, this is a good place to 		     initialize this.  */
name|occr
operator|->
name|deleted_p
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* The occurrences recorded in avail_occr are exactly those that 	     we want to set to non-zero in COMP.  */
if|if
condition|(
name|comp
condition|)
block|{
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
name|int
name|bb
init|=
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
decl_stmt|;
name|SET_BIT
argument_list|(
name|comp
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
comment|/* While we're scanning the table, this is a good place to 		     initialize this.  */
name|occr
operator|->
name|copied_p
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* While we're scanning the table, this is a good place to 	     initialize this.  */
name|expr
operator|->
name|reaching_reg
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register set information.     `reg_set_table' records where each register is set or otherwise    modified.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|reg_set_obstack
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|alloc_reg_set_mem
parameter_list|(
name|n_regs
parameter_list|)
name|int
name|n_regs
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|reg_set_table_size
operator|=
name|n_regs
operator|+
name|REG_SET_TABLE_SLOP
expr_stmt|;
name|n
operator|=
name|reg_set_table_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
operator|*
argument_list|)
expr_stmt|;
name|reg_set_table
operator|=
operator|(
expr|struct
name|reg_set
operator|*
operator|*
operator|)
name|gmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_set_table
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|reg_set_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_reg_set_mem
parameter_list|()
block|{
name|free
argument_list|(
name|reg_set_table
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|reg_set_obstack
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record REGNO in the reg_set table.  */
end_comment

begin_function
specifier|static
name|void
name|record_one_set
parameter_list|(
name|regno
parameter_list|,
name|insn
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* allocate a new reg_set element and link it onto the list */
name|struct
name|reg_set
modifier|*
name|new_reg_info
decl_stmt|,
modifier|*
name|reg_info_ptr1
decl_stmt|,
modifier|*
name|reg_info_ptr2
decl_stmt|;
comment|/* If the table isn't big enough, enlarge it.  */
if|if
condition|(
name|regno
operator|>=
name|reg_set_table_size
condition|)
block|{
name|int
name|new_size
init|=
name|regno
operator|+
name|REG_SET_TABLE_SLOP
decl_stmt|;
name|reg_set_table
operator|=
operator|(
expr|struct
name|reg_set
operator|*
operator|*
operator|)
name|grealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_set_table
argument_list|,
name|new_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|reg_set_table
operator|+
name|reg_set_table_size
operator|)
argument_list|,
operator|(
name|new_size
operator|-
name|reg_set_table_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|reg_set_table_size
operator|=
name|new_size
expr_stmt|;
block|}
name|new_reg_info
operator|=
operator|(
expr|struct
name|reg_set
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|reg_set_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|reg_set
argument_list|)
expr_stmt|;
name|new_reg_info
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|new_reg_info
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|reg_set_table
index|[
name|regno
index|]
operator|==
name|NULL
condition|)
name|reg_set_table
index|[
name|regno
index|]
operator|=
name|new_reg_info
expr_stmt|;
else|else
block|{
name|reg_info_ptr1
operator|=
name|reg_info_ptr2
operator|=
name|reg_set_table
index|[
name|regno
index|]
expr_stmt|;
comment|/* ??? One could keep a "last" pointer to speed this up.  */
while|while
condition|(
name|reg_info_ptr1
operator|!=
name|NULL
condition|)
block|{
name|reg_info_ptr2
operator|=
name|reg_info_ptr1
expr_stmt|;
name|reg_info_ptr1
operator|=
name|reg_info_ptr1
operator|->
name|next
expr_stmt|;
block|}
name|reg_info_ptr2
operator|->
name|next
operator|=
name|new_reg_info
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For communication between next two functions (via note_stores).  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|record_set_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called from compute_sets via note_stores to handle one    SET or CLOBBER in an insn.  */
end_comment

begin_function
specifier|static
name|void
name|record_set_info
parameter_list|(
name|dest
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|record_one_set
argument_list|(
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|,
name|record_set_insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan the function and record each set of each pseudo-register.     This is called once, at the start of the gcse pass.    See the comments for `reg_set_table' for further docs.  */
end_comment

begin_function
specifier|static
name|void
name|compute_sets
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|f
decl_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|record_set_insn
operator|=
name|insn
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_set_info
argument_list|)
expr_stmt|;
block|}
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hash table support.  */
end_comment

begin_define
define|#
directive|define
name|NEVER_SET
value|-1
end_define

begin_comment
comment|/* For each register, the cuid of the first/last insn in the block to set it,    or -1 if not set.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_first_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|reg_last_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While computing "first/last set" info, this is the CUID of first/last insn    to set memory or -1 if not set.  `mem_last_set' is also used when    performing GCSE to record whether memory has been set since the beginning    of the block.    Note that handling of memory is very simple, we don't make any attempt    to optimize things (later).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mem_first_set
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mem_last_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Perform a quick check whether X, the source of a set, is something    we want to consider for GCSE.  */
end_comment

begin_function
specifier|static
name|int
name|want_to_gcse_p
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CALL
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the operands of expression X are unchanged from the    start of INSN's basic block up to but not including INSN (if AVAIL_P == 0),    or from INSN to the end of INSN's basic block (if AVAIL_P != 0).  */
end_comment

begin_function
specifier|static
name|int
name|oprs_unchanged_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|avail_p
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|avail_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|avail_p
condition|)
return|return
operator|(
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|NEVER_SET
operator|||
name|reg_last_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|<
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|reg_first_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|NEVER_SET
operator|||
name|reg_first_set
index|[
name|REGNO
argument_list|(
name|x
argument_list|)
index|]
operator|>=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|)
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|avail_p
condition|)
block|{
if|if
condition|(
name|mem_last_set
operator|!=
name|NEVER_SET
operator|&&
name|mem_last_set
operator|>=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|mem_first_set
operator|!=
name|NEVER_SET
operator|&&
name|mem_first_set
operator|<
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
return|return
literal|0
return|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|1
return|;
default|default:
break|break;
block|}
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|tem
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
if|if
condition|(
operator|!
name|oprs_unchanged_p
argument_list|(
name|tem
argument_list|,
name|insn
argument_list|,
name|avail_p
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|oprs_unchanged_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
name|avail_p
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the operands of expression X are unchanged from    the start of INSN's basic block up to but not including INSN.  */
end_comment

begin_function
specifier|static
name|int
name|oprs_anticipatable_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
return|return
name|oprs_unchanged_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the operands of expression X are unchanged from    INSN to the end of INSN's basic block.  */
end_comment

begin_function
specifier|static
name|int
name|oprs_available_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
return|return
name|oprs_unchanged_p
argument_list|(
name|x
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Hash expression X.    MODE is only used if X is a CONST_INT.    A boolean indicating if a volatile operand is found or if the expression    contains something we don't want to insert in the table is stored in    DO_NOT_RECORD_P.     ??? One might want to merge this with canon_hash.  Later.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_expr
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|do_not_record_p
parameter_list|,
name|hash_table_size
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
modifier|*
name|do_not_record_p
decl_stmt|;
name|int
name|hash_table_size
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
operator|*
name|do_not_record_p
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|hash_expr_1
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|do_not_record_p
argument_list|)
expr_stmt|;
return|return
name|hash
operator|%
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of hash_expr to do the actual work.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_expr_1
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|do_not_record_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
modifier|*
name|do_not_record_p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|hash
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
name|hash
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
block|{
specifier|register
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|REG
operator|<<
literal|7
operator|)
operator|+
name|regno
expr_stmt|;
return|return
name|hash
return|;
block|}
case|case
name|CONST_INT
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|tem
init|=
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|CONST_INT
operator|<<
literal|7
operator|)
operator|+
operator|(
name|unsigned
operator|)
name|mode
operator|+
name|tem
expr_stmt|;
return|return
name|hash
return|;
block|}
case|case
name|CONST_DOUBLE
case|:
comment|/* This is like the general case, except that it only counts 	 the integers representing the constant.  */
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|GET_RTX_LENGTH
argument_list|(
name|CONST_DOUBLE
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|tem
init|=
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|hash
operator|+=
name|tem
expr_stmt|;
block|}
else|else
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
operator|)
expr_stmt|;
return|return
name|hash
return|;
comment|/* Assume there is only one rtx object for any given label.  */
case|case
name|LABEL_REF
case|:
comment|/* We don't hash on the address of the CODE_LABEL to avoid bootstrap 	 differences and differences between each stage's debugging dumps.  */
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|LABEL_REF
operator|<<
literal|7
operator|)
operator|+
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|hash
return|;
case|case
name|SYMBOL_REF
case|:
block|{
comment|/* Don't hash on the symbol's address to avoid bootstrap differences. 	   Different hash values may cause expressions to be recorded in 	   different orders and thus different registers to be used in the 	   final assembler.  This also avoids differences in the dump files 	   between various stages.  */
name|unsigned
name|int
name|h
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|h
operator|+=
operator|(
name|h
operator|<<
literal|7
operator|)
operator|+
operator|*
name|p
operator|++
expr_stmt|;
comment|/* ??? revisit */
name|hash
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|SYMBOL_REF
operator|<<
literal|7
operator|)
operator|+
name|h
expr_stmt|;
return|return
name|hash
return|;
block|}
case|case
name|MEM
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|do_not_record_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|MEM
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PRE_DEC
case|:
case|case
name|PRE_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_INC
case|:
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CALL
case|:
case|case
name|UNSPEC_VOLATILE
case|:
operator|*
name|do_not_record_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|ASM_OPERANDS
case|:
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|do_not_record_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
break|break;
block|}
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
expr_stmt|;
name|hash
operator|+=
operator|(
name|unsigned
operator|)
name|code
operator|+
operator|(
name|unsigned
operator|)
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|tem
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|hash
operator|+=
name|hash_expr_1
argument_list|(
name|tem
argument_list|,
literal|0
argument_list|,
name|do_not_record_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|do_not_record_p
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|hash
operator|+=
name|hash_expr_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
name|do_not_record_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|do_not_record_p
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'s'
condition|)
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
while|while
condition|(
operator|*
name|p
condition|)
name|hash
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'i'
condition|)
block|{
specifier|register
name|unsigned
name|tem
init|=
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|hash
operator|+=
name|tem
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/* Hash a set of register REGNO.     Sets are hashed on the register that is set.    This simplifies the PRE copy propagation code.     ??? May need to make things more elaborate.  Later, as necessary.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|hash_set
parameter_list|(
name|regno
parameter_list|,
name|hash_table_size
parameter_list|)
name|int
name|regno
decl_stmt|;
name|int
name|hash_table_size
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
decl_stmt|;
name|hash
operator|=
name|regno
expr_stmt|;
return|return
name|hash
operator|%
name|hash_table_size
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if exp1 is equivalent to exp2.    ??? Borrowed from cse.c.  Might want to remerge with cse.c.  Later.  */
end_comment

begin_function
specifier|static
name|int
name|expr_equiv_p
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|y
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|enum
name|rtx_code
name|code
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|x
operator|==
literal|0
operator|||
name|y
operator|==
literal|0
condition|)
return|return
name|x
operator|==
name|y
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|GET_CODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* (MULT:SI x y) and (MULT:HI x y) are NOT equivalent.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|y
argument_list|)
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
return|return
name|x
operator|==
name|y
return|;
case|case
name|CONST_INT
case|:
return|return
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|==
name|INTVAL
argument_list|(
name|y
argument_list|)
return|;
case|case
name|LABEL_REF
case|:
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|SYMBOL_REF
case|:
return|return
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|XSTR
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|REG
case|:
return|return
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|REGNO
argument_list|(
name|y
argument_list|)
return|;
comment|/*  For commutative operations, check both orders.  */
case|case
name|PLUS
case|:
case|case
name|MULT
case|:
case|case
name|AND
case|:
case|case
name|IOR
case|:
case|case
name|XOR
case|:
case|case
name|NE
case|:
case|case
name|EQ
case|:
return|return
operator|(
operator|(
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
return|;
default|default:
break|break;
block|}
comment|/* Compare the elements.  If any pair of corresponding elements      fail to match, return 0 for the whole thing.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|fmt
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
operator|!
name|expr_equiv_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XVECLEN
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|expr_equiv_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|XVECEXP
argument_list|(
name|y
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|XINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|XWINT
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|!=
name|XWINT
argument_list|(
name|y
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'0'
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Insert expression X in INSN in the hash table.    If it is already present, record it as the last occurrence in INSN's    basic block.     MODE is the mode of the value X is being stored into.    It is only used if X is a CONST_INT.     ANTIC_P is non-zero if X is an anticipatable expression.    AVAIL_P is non-zero if X is an available expression.  */
end_comment

begin_function
specifier|static
name|void
name|insert_expr_in_table
parameter_list|(
name|x
parameter_list|,
name|mode
parameter_list|,
name|insn
parameter_list|,
name|antic_p
parameter_list|,
name|avail_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|antic_p
decl_stmt|,
name|avail_p
decl_stmt|;
block|{
name|int
name|found
decl_stmt|,
name|do_not_record_p
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|struct
name|expr
modifier|*
name|cur_expr
decl_stmt|,
modifier|*
name|last_expr
init|=
name|NULL
decl_stmt|;
name|struct
name|occr
modifier|*
name|antic_occr
decl_stmt|,
modifier|*
name|avail_occr
decl_stmt|;
name|struct
name|occr
modifier|*
name|last_occr
init|=
name|NULL
decl_stmt|;
name|hash
operator|=
name|hash_expr
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
operator|&
name|do_not_record_p
argument_list|,
name|expr_hash_table_size
argument_list|)
expr_stmt|;
comment|/* Do not insert expression in table if it contains volatile operands,      or if hash_expr determines the expression is something we don't want      to or can't handle.  */
if|if
condition|(
name|do_not_record_p
condition|)
return|return;
name|cur_expr
operator|=
name|expr_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cur_expr
operator|&&
operator|!
operator|(
name|found
operator|=
name|expr_equiv_p
argument_list|(
name|cur_expr
operator|->
name|expr
argument_list|,
name|x
argument_list|)
operator|)
condition|)
block|{
comment|/* If the expression isn't found, save a pointer to the end of 	 the list.  */
name|last_expr
operator|=
name|cur_expr
expr_stmt|;
name|cur_expr
operator|=
name|cur_expr
operator|->
name|next_same_hash
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|cur_expr
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|)
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr_hash_table
index|[
name|hash
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* This is the first pattern that hashed to this index.  */
name|expr_hash_table
index|[
name|hash
index|]
operator|=
name|cur_expr
expr_stmt|;
block|}
else|else
block|{
comment|/* Add EXPR to end of this hash chain.  */
name|last_expr
operator|->
name|next_same_hash
operator|=
name|cur_expr
expr_stmt|;
block|}
comment|/* Set the fields of the expr element.  */
name|cur_expr
operator|->
name|expr
operator|=
name|x
expr_stmt|;
name|cur_expr
operator|->
name|bitmap_index
operator|=
name|n_exprs
operator|++
expr_stmt|;
name|cur_expr
operator|->
name|next_same_hash
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|antic_occr
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|avail_occr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now record the occurrence(s).  */
if|if
condition|(
name|antic_p
condition|)
block|{
name|antic_occr
operator|=
name|cur_expr
operator|->
name|antic_occr
expr_stmt|;
comment|/* Search for another occurrence in the same basic block.  */
while|while
condition|(
name|antic_occr
operator|&&
name|BLOCK_NUM
argument_list|(
name|antic_occr
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If an occurrence isn't found, save a pointer to the end of 	     the list.  */
name|last_occr
operator|=
name|antic_occr
expr_stmt|;
name|antic_occr
operator|=
name|antic_occr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|antic_occr
condition|)
block|{
comment|/* Found another instance of the expression in the same basic block. 	     Prefer the currently recorded one.  We want the first one in the 	     block and the block is scanned from start to end.  */
empty_stmt|;
comment|/* nothing to do */
block|}
else|else
block|{
comment|/* First occurrence of this expression in this basic block.  */
name|antic_occr
operator|=
operator|(
expr|struct
name|occr
operator|*
operator|)
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
expr_stmt|;
comment|/* First occurrence of this expression in any block?  */
if|if
condition|(
name|cur_expr
operator|->
name|antic_occr
operator|==
name|NULL
condition|)
name|cur_expr
operator|->
name|antic_occr
operator|=
name|antic_occr
expr_stmt|;
else|else
name|last_occr
operator|->
name|next
operator|=
name|antic_occr
expr_stmt|;
name|antic_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|antic_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|avail_p
condition|)
block|{
name|avail_occr
operator|=
name|cur_expr
operator|->
name|avail_occr
expr_stmt|;
comment|/* Search for another occurrence in the same basic block.  */
while|while
condition|(
name|avail_occr
operator|&&
name|BLOCK_NUM
argument_list|(
name|avail_occr
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If an occurrence isn't found, save a pointer to the end of 	     the list.  */
name|last_occr
operator|=
name|avail_occr
expr_stmt|;
name|avail_occr
operator|=
name|avail_occr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|avail_occr
condition|)
block|{
comment|/* Found another instance of the expression in the same basic block. 	     Prefer this occurrence to the currently recorded one.  We want 	     the last one in the block and the block is scanned from start 	     to end.  */
name|avail_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
block|}
else|else
block|{
comment|/* First occurrence of this expression in this basic block.  */
name|avail_occr
operator|=
operator|(
expr|struct
name|occr
operator|*
operator|)
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
expr_stmt|;
comment|/* First occurrence of this expression in any block?  */
if|if
condition|(
name|cur_expr
operator|->
name|avail_occr
operator|==
name|NULL
condition|)
name|cur_expr
operator|->
name|avail_occr
operator|=
name|avail_occr
expr_stmt|;
else|else
name|last_occr
operator|->
name|next
operator|=
name|avail_occr
expr_stmt|;
name|avail_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|avail_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Insert pattern X in INSN in the hash table.    X is a SET of a reg to either another reg or a constant.    If it is already present, record it as the last occurrence in INSN's    basic block.  */
end_comment

begin_function
specifier|static
name|void
name|insert_set_in_table
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|found
decl_stmt|;
name|unsigned
name|int
name|hash
decl_stmt|;
name|struct
name|expr
modifier|*
name|cur_expr
decl_stmt|,
modifier|*
name|last_expr
init|=
name|NULL
decl_stmt|;
name|struct
name|occr
modifier|*
name|cur_occr
decl_stmt|,
modifier|*
name|last_occr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|hash
operator|=
name|hash_set
argument_list|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|,
name|set_hash_table_size
argument_list|)
expr_stmt|;
name|cur_expr
operator|=
name|set_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cur_expr
operator|&&
operator|!
operator|(
name|found
operator|=
name|expr_equiv_p
argument_list|(
name|cur_expr
operator|->
name|expr
argument_list|,
name|x
argument_list|)
operator|)
condition|)
block|{
comment|/* If the expression isn't found, save a pointer to the end of 	 the list.  */
name|last_expr
operator|=
name|cur_expr
expr_stmt|;
name|cur_expr
operator|=
name|cur_expr
operator|->
name|next_same_hash
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|cur_expr
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|)
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_hash_table
index|[
name|hash
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* This is the first pattern that hashed to this index.  */
name|set_hash_table
index|[
name|hash
index|]
operator|=
name|cur_expr
expr_stmt|;
block|}
else|else
block|{
comment|/* Add EXPR to end of this hash chain.  */
name|last_expr
operator|->
name|next_same_hash
operator|=
name|cur_expr
expr_stmt|;
block|}
comment|/* Set the fields of the expr element. 	 We must copy X because it can be modified when copy propagation is 	 performed on its operands.  */
comment|/* ??? Should this go in a different obstack?  */
name|cur_expr
operator|->
name|expr
operator|=
name|copy_rtx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|cur_expr
operator|->
name|bitmap_index
operator|=
name|n_sets
operator|++
expr_stmt|;
name|cur_expr
operator|->
name|next_same_hash
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|antic_occr
operator|=
name|NULL
expr_stmt|;
name|cur_expr
operator|->
name|avail_occr
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now record the occurrence.  */
name|cur_occr
operator|=
name|cur_expr
operator|->
name|avail_occr
expr_stmt|;
comment|/* Search for another occurrence in the same basic block.  */
while|while
condition|(
name|cur_occr
operator|&&
name|BLOCK_NUM
argument_list|(
name|cur_occr
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If an occurrence isn't found, save a pointer to the end of 	 the list.  */
name|last_occr
operator|=
name|cur_occr
expr_stmt|;
name|cur_occr
operator|=
name|cur_occr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|cur_occr
condition|)
block|{
comment|/* Found another instance of the expression in the same basic block. 	 Prefer this occurrence to the currently recorded one.  We want 	 the last one in the block and the block is scanned from start 	 to end.  */
name|cur_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
block|}
else|else
block|{
comment|/* First occurrence of this expression in this basic block.  */
name|cur_occr
operator|=
operator|(
expr|struct
name|occr
operator|*
operator|)
name|gcse_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
argument_list|)
expr_stmt|;
name|bytes_used
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|occr
argument_list|)
expr_stmt|;
comment|/* First occurrence of this expression in any block?  */
if|if
condition|(
name|cur_expr
operator|->
name|avail_occr
operator|==
name|NULL
condition|)
name|cur_expr
operator|->
name|avail_occr
operator|=
name|cur_occr
expr_stmt|;
else|else
name|last_occr
operator|->
name|next
operator|=
name|cur_occr
expr_stmt|;
name|cur_occr
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|cur_occr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan pattern PAT of INSN and add an entry to the hash table.    If SET_P is non-zero, this is for the assignment hash table,    otherwise it is for the expression hash table.  */
end_comment

begin_function
specifier|static
name|void
name|hash_scan_set
parameter_list|(
name|pat
parameter_list|,
name|insn
parameter_list|,
name|set_p
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|set_p
decl_stmt|;
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CALL
condition|)
name|hash_scan_call
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|rtx
name|tmp
decl_stmt|;
comment|/* Only record sets of pseudo-regs in the hash table.  */
if|if
condition|(
operator|!
name|set_p
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
comment|/* Don't GCSE something if we can't do a reg/reg copy.  */
operator|&&
name|can_copy_p
index|[
name|GET_MODE
argument_list|(
name|dest
argument_list|)
index|]
comment|/* Is SET_SRC something we want to gcse?  */
operator|&&
name|want_to_gcse_p
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* An expression is not anticipatable if its operands are 	     modified before this insn.  */
name|int
name|antic_p
init|=
operator|!
name|optimize_size
operator|&&
name|oprs_anticipatable_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
decl_stmt|;
comment|/* An expression is not available if its operands are 	     subsequently modified, including this insn.  */
name|int
name|avail_p
init|=
name|oprs_available_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
decl_stmt|;
name|insert_expr_in_table
argument_list|(
name|src
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|,
name|insn
argument_list|,
name|antic_p
argument_list|,
name|avail_p
argument_list|)
expr_stmt|;
block|}
comment|/* Record sets for constant/copy propagation.  */
elseif|else
if|if
condition|(
name|set_p
operator|&&
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|can_copy_p
index|[
name|GET_MODE
argument_list|(
name|dest
argument_list|)
index|]
operator|)
comment|/* ??? CONST_INT:wip */
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_DOUBLE
operator|)
comment|/* A copy is not available if its src or dest is subsequently 		  modified.  Here we want to search from INSN+1 on, but 		  oprs_available_p searches from INSN on.  */
operator|&&
operator|(
name|insn
operator|==
name|BLOCK_END
argument_list|(
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|||
operator|(
operator|(
name|tmp
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|oprs_available_p
argument_list|(
name|pat
argument_list|,
name|tmp
argument_list|)
operator|)
operator|)
condition|)
name|insert_set_in_table
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|hash_scan_clobber
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Currently nothing to do.  */
block|}
end_function

begin_function
specifier|static
name|void
name|hash_scan_call
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
name|ATTRIBUTE_UNUSED
decl_stmt|,
name|insn
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
comment|/* Currently nothing to do.  */
block|}
end_function

begin_comment
comment|/* Process INSN and add hash table entries as appropriate.     Only available expressions that set a single pseudo-reg are recorded.     Single sets in a PARALLEL could be handled, but it's an extra complication    that isn't dealt with right now.  The trick is handling the CLOBBERs that    are also in the PARALLEL.  Later.     If SET_P is non-zero, this is for the assignment hash table,    otherwise it is for the expression hash table.    If IN_LIBCALL_BLOCK nonzero, we are in a libcall block, and should    not record any expressions.  */
end_comment

begin_function
specifier|static
name|void
name|hash_scan_insn
parameter_list|(
name|insn
parameter_list|,
name|set_p
parameter_list|,
name|in_libcall_block
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|set_p
decl_stmt|;
name|int
name|in_libcall_block
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Pick out the sets of INSN and for other forms of instructions record      what's been modified.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
operator|!
name|in_libcall_block
condition|)
name|hash_scan_set
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|,
name|set_p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
name|hash_scan_call
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
name|hash_scan_clobber
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
name|hash_scan_call
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
name|hash_scan_clobber
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL
condition|)
name|hash_scan_call
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_hash_table
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|,
name|table
parameter_list|,
name|table_size
parameter_list|,
name|total_size
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|expr
modifier|*
modifier|*
name|table
decl_stmt|;
name|int
name|table_size
decl_stmt|,
name|total_size
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Flattened out table, so it's printed in proper order.  */
name|struct
name|expr
modifier|*
modifier|*
name|flat_table
init|=
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|total_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
modifier|*
name|hash_val
init|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|total_size
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|flat_table
argument_list|,
name|total_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
for|for
control|(
name|expr
operator|=
name|table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
name|flat_table
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|expr
expr_stmt|;
name|hash_val
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s hash table (%d buckets, %d entries)\n"
argument_list|,
name|name
argument_list|,
name|table_size
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|expr
init|=
name|flat_table
index|[
name|i
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Index %d (hash value %d)\n  "
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|,
name|hash_val
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|file
argument_list|,
name|expr
operator|->
name|expr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record register first/last/block set information for REGNO in INSN.    reg_first_set records the first place in the block where the register    is set and is used to compute "anticipatability".    reg_last_set records the last place in the block where the register    is set and is used to compute "availability".    reg_set_in_block records whether the register is set in the block    and is used to compute "transparency".  */
end_comment

begin_function
specifier|static
name|void
name|record_last_reg_set_info
parameter_list|(
name|insn
parameter_list|,
name|regno
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|reg_first_set
index|[
name|regno
index|]
operator|==
name|NEVER_SET
condition|)
name|reg_first_set
index|[
name|regno
index|]
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|reg_last_set
index|[
name|regno
index|]
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|reg_set_in_block
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record memory first/last/block set information for INSN.  */
end_comment

begin_function
specifier|static
name|void
name|record_last_mem_set_info
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|mem_first_set
operator|==
name|NEVER_SET
condition|)
name|mem_first_set
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|mem_last_set
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|mem_set_in_block
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Used for communicating between next two routines.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_set_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called from compute_hash_table via note_stores to handle one    SET or CLOBBER in an insn.  */
end_comment

begin_function
specifier|static
name|void
name|record_last_set_info
parameter_list|(
name|dest
parameter_list|,
name|setter
parameter_list|)
name|rtx
name|dest
decl_stmt|,
name|setter
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
condition|)
name|dest
operator|=
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|record_last_reg_set_info
argument_list|(
name|last_set_insn
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
comment|/* Ignore pushes, they clobber nothing.  */
operator|&&
operator|!
name|push_operand
argument_list|(
name|dest
argument_list|,
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
condition|)
name|record_last_mem_set_info
argument_list|(
name|last_set_insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level function to create an expression or assignment hash table.     Expression entries are placed in the hash table if    - they are of the form (set (pseudo-reg) src),    - src is something we want to perform GCSE on,    - none of the operands are subsequently modified in the block     Assignment entries are placed in the hash table if    - they are of the form (set (pseudo-reg) src),    - src is something we want to perform const/copy propagation on,    - none of the operands or target are subsequently modified in the block    Currently src must be a pseudo-reg or a const_int.     F is the first insn.    SET_P is non-zero for computing the assignment hash table.  */
end_comment

begin_function
specifier|static
name|void
name|compute_hash_table
parameter_list|(
name|set_p
parameter_list|)
name|int
name|set_p
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
comment|/* While we compute the hash table we also compute a bit array of which      registers are set in which blocks.      We also compute which blocks set memory, in the absence of aliasing      support [which is TODO].      ??? This isn't needed during const/copy propagation, but it's cheap to      compute.  Later.  */
name|sbitmap_vector_zero
argument_list|(
name|reg_set_in_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mem_set_in_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Some working arrays used to track first and last set in each block.  */
comment|/* ??? One could use alloca here, but at some size a threshold is crossed      beyond which one should use malloc.  Are we at that threshold here?  */
name|reg_first_set
operator|=
operator|(
name|int
operator|*
operator|)
name|gmalloc
argument_list|(
name|max_gcse_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|reg_last_set
operator|=
operator|(
name|int
operator|*
operator|)
name|gmalloc
argument_list|(
name|max_gcse_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|in_libcall_block
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First pass over the instructions records information used to 	 determine when registers and memory are first and last set. 	 ??? The mem_set_in_block and hard-reg reg_set_in_block computation 	 could be moved to compute_sets since they currently don't change.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_gcse_regno
condition|;
name|i
operator|++
control|)
name|reg_first_set
index|[
name|i
index|]
operator|=
name|reg_last_set
index|[
name|i
index|]
operator|=
name|NEVER_SET
expr_stmt|;
name|mem_first_set
operator|=
name|NEVER_SET
expr_stmt|;
name|mem_last_set
operator|=
name|NEVER_SET
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|NON_SAVING_SETJMP
if|if
condition|(
name|NON_SAVING_SETJMP
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
name|record_last_reg_set_info
argument_list|(
name|insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|'i'
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
if|if
condition|(
operator|(
name|call_used_regs
index|[
name|regno
index|]
operator|&&
name|regno
operator|!=
name|STACK_POINTER_REGNUM
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
argument_list|)
operator|&&
operator|!
operator|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|flag_pic
operator|)
endif|#
directive|endif
operator|&&
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|)
operator|||
name|global_regs
index|[
name|regno
index|]
condition|)
name|record_last_reg_set_info
argument_list|(
name|insn
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONST_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
name|record_last_mem_set_info
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
name|last_set_insn
operator|=
name|insn
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_last_set_info
argument_list|)
expr_stmt|;
block|}
comment|/* The next pass builds the hash table.  */
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
operator|,
name|in_libcall_block
operator|=
literal|0
init|;
name|insn
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|0
expr_stmt|;
name|hash_scan_insn
argument_list|(
name|insn
argument_list|,
name|set_p
argument_list|,
name|in_libcall_block
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|reg_first_set
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg_last_set
argument_list|)
expr_stmt|;
comment|/* Catch bugs early.  */
name|reg_first_set
operator|=
name|reg_last_set
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate space for the set hash table.    N_INSNS is the number of instructions in the function.    It is used to determine the number of buckets to use.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_set_hash_table
parameter_list|(
name|n_insns
parameter_list|)
name|int
name|n_insns
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|set_hash_table_size
operator|=
name|n_insns
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|set_hash_table_size
operator|<
literal|11
condition|)
name|set_hash_table_size
operator|=
literal|11
expr_stmt|;
comment|/* Attempt to maintain efficient use of hash table.      Making it an odd number is simplest for now.      ??? Later take some measurements.  */
name|set_hash_table_size
operator||=
literal|1
expr_stmt|;
name|n
operator|=
name|set_hash_table_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
expr_stmt|;
name|set_hash_table
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
name|gmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free things allocated by alloc_set_hash_table.  */
end_comment

begin_function
specifier|static
name|void
name|free_set_hash_table
parameter_list|()
block|{
name|free
argument_list|(
name|set_hash_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the hash table for doing copy/const propagation.  */
end_comment

begin_function
specifier|static
name|void
name|compute_set_hash_table
parameter_list|()
block|{
comment|/* Initialize count of number of entries in hash table.  */
name|n_sets
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|set_hash_table
argument_list|,
name|set_hash_table_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|compute_hash_table
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate space for the expression hash table.    N_INSNS is the number of instructions in the function.    It is used to determine the number of buckets to use.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_expr_hash_table
parameter_list|(
name|n_insns
parameter_list|)
name|int
name|n_insns
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|expr_hash_table_size
operator|=
name|n_insns
operator|/
literal|2
expr_stmt|;
comment|/* Make sure the amount is usable.  */
if|if
condition|(
name|expr_hash_table_size
operator|<
literal|11
condition|)
name|expr_hash_table_size
operator|=
literal|11
expr_stmt|;
comment|/* Attempt to maintain efficient use of hash table.      Making it an odd number is simplest for now.      ??? Later take some measurements.  */
name|expr_hash_table_size
operator||=
literal|1
expr_stmt|;
name|n
operator|=
name|expr_hash_table_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
expr_stmt|;
name|expr_hash_table
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
name|gmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free things allocated by alloc_expr_hash_table.  */
end_comment

begin_function
specifier|static
name|void
name|free_expr_hash_table
parameter_list|()
block|{
name|free
argument_list|(
name|expr_hash_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the hash table for doing GCSE.  */
end_comment

begin_function
specifier|static
name|void
name|compute_expr_hash_table
parameter_list|()
block|{
comment|/* Initialize count of number of entries in hash table.  */
name|n_exprs
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|expr_hash_table
argument_list|,
name|expr_hash_table_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|compute_hash_table
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expression tracking support.  */
end_comment

begin_comment
comment|/* Lookup pattern PAT in the expression table.    The result is a pointer to the table entry, or NULL if not found.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|lookup_expr
parameter_list|(
name|pat
parameter_list|)
name|rtx
name|pat
decl_stmt|;
block|{
name|int
name|do_not_record_p
decl_stmt|;
name|unsigned
name|int
name|hash
init|=
name|hash_expr
argument_list|(
name|pat
argument_list|,
name|GET_MODE
argument_list|(
name|pat
argument_list|)
argument_list|,
operator|&
name|do_not_record_p
argument_list|,
name|expr_hash_table_size
argument_list|)
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
if|if
condition|(
name|do_not_record_p
condition|)
return|return
name|NULL
return|;
name|expr
operator|=
name|expr_hash_table
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|expr
operator|&&
operator|!
name|expr_equiv_p
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|pat
argument_list|)
condition|)
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Lookup REGNO in the set table.    If PAT is non-NULL look for the entry that matches it, otherwise return    the first entry for REGNO.    The result is a pointer to the table entry, or NULL if not found.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|lookup_set
parameter_list|(
name|regno
parameter_list|,
name|pat
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
block|{
name|unsigned
name|int
name|hash
init|=
name|hash_set
argument_list|(
name|regno
argument_list|,
name|set_hash_table_size
argument_list|)
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|expr
operator|=
name|set_hash_table
index|[
name|hash
index|]
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
while|while
condition|(
name|expr
operator|&&
operator|!
name|expr_equiv_p
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|pat
argument_list|)
condition|)
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|expr
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
argument_list|)
operator|!=
name|regno
condition|)
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Return the next entry for REGNO in list EXPR.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|next_set
parameter_list|(
name|regno
parameter_list|,
name|expr
parameter_list|)
name|int
name|regno
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
block|{
do|do
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
do|while
condition|(
name|expr
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
argument_list|)
operator|!=
name|regno
condition|)
do|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Reset tables used to keep track of what's still available [since the    start of the block].  */
end_comment

begin_function
specifier|static
name|void
name|reset_opr_set_tables
parameter_list|()
block|{
comment|/* Maintain a bitmap of which regs have been set since beginning of      the block.  */
name|sbitmap_zero
argument_list|(
name|reg_set_bitmap
argument_list|)
expr_stmt|;
comment|/* Also keep a record of the last instruction to modify memory.      For now this is very trivial, we only record whether any memory      location has been modified.  */
name|mem_last_set
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the operands of X are not set before INSN in    INSN's basic block.  */
end_comment

begin_function
specifier|static
name|int
name|oprs_not_set_p
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|1
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|mem_last_set
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|REG
case|:
return|return
operator|!
name|TEST_BIT
argument_list|(
name|reg_set_bitmap
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
default|default:
break|break;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|int
name|not_set_p
decl_stmt|;
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|not_set_p
operator|=
name|oprs_not_set_p
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|not_set_p
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|not_set_p
init|=
name|oprs_not_set_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|not_set_p
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Mark things set by a CALL.  */
end_comment

begin_function
specifier|static
name|void
name|mark_call
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|mem_last_set
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark things set by a SET.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set
parameter_list|(
name|pat
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pat
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|dest
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|REG
condition|)
name|SET_BIT
argument_list|(
name|reg_set_bitmap
argument_list|,
name|REGNO
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
name|mem_last_set
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
name|mark_call
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record things set by a CLOBBER.  */
end_comment

begin_function
specifier|static
name|void
name|mark_clobber
parameter_list|(
name|pat
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|pat
decl_stmt|,
name|insn
decl_stmt|;
block|{
name|rtx
name|clob
init|=
name|XEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|clob
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|clob
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|clob
operator|=
name|XEXP
argument_list|(
name|clob
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|clob
argument_list|)
operator|==
name|REG
condition|)
name|SET_BIT
argument_list|(
name|reg_set_bitmap
argument_list|,
name|REGNO
argument_list|(
name|clob
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|mem_last_set
operator|=
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record things set by INSN.    This data is used by oprs_not_set_p.  */
end_comment

begin_function
specifier|static
name|void
name|mark_oprs_set
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
name|mark_set
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
condition|)
name|mark_set
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_clobber
argument_list|(
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CALL
condition|)
name|mark_call
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_clobber
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|CALL
condition|)
name|mark_call
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Classic GCSE reaching definition support.  */
end_comment

begin_comment
comment|/* Allocate reaching def variables.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_rd_mem
parameter_list|(
name|n_blocks
parameter_list|,
name|n_insns
parameter_list|)
name|int
name|n_blocks
decl_stmt|,
name|n_insns
decl_stmt|;
block|{
name|rd_kill
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|rd_kill
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|rd_gen
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|rd_gen
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|reaching_defs
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|reaching_defs
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|rd_out
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_insns
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|rd_out
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free reaching def variables.  */
end_comment

begin_function
specifier|static
name|void
name|free_rd_mem
parameter_list|()
block|{
name|free
argument_list|(
name|rd_kill
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rd_gen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reaching_defs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rd_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add INSN to the kills of BB.    REGNO, set in BB, is killed by INSN.  */
end_comment

begin_function
specifier|static
name|void
name|handle_rd_kill_set
parameter_list|(
name|insn
parameter_list|,
name|regno
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|regno
decl_stmt|,
name|bb
decl_stmt|;
block|{
name|struct
name|reg_set
modifier|*
name|this_reg
init|=
name|reg_set_table
index|[
name|regno
index|]
decl_stmt|;
while|while
condition|(
name|this_reg
condition|)
block|{
if|if
condition|(
name|BLOCK_NUM
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|rd_kill
index|[
name|bb
index|]
argument_list|,
name|INSN_CUID
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|this_reg
operator|=
name|this_reg
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the set of kill's for reaching definitions.  */
end_comment

begin_function
specifier|static
name|void
name|compute_kill_rd
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|cuid
decl_stmt|;
comment|/* For each block        For each set bit in `gen' of the block (i.e each insn which 	   generates a definition in the block) 	 Call the reg set by the insn corresponding to that bit regx 	 Look at the linked list starting at reg_set_table[regx] 	 For each setting of regx in the linked list, which is not in 	     this block 	   Set the bit in `kill' corresponding to that insn     */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
for|for
control|(
name|cuid
operator|=
literal|0
init|;
name|cuid
operator|<
name|max_cuid
condition|;
name|cuid
operator|++
control|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|rd_gen
index|[
name|bb
index|]
argument_list|,
name|cuid
argument_list|)
condition|)
block|{
name|rtx
name|insn
init|=
name|CUID_INSN
argument_list|(
name|cuid
argument_list|)
decl_stmt|;
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|call_used_regs
index|[
name|regno
index|]
operator|&&
name|regno
operator|!=
name|STACK_POINTER_REGNUM
if|#
directive|if
name|HARD_FRAME_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
argument_list|)
operator|&&
operator|!
operator|(
name|regno
operator|==
name|PIC_OFFSET_TABLE_REGNUM
operator|&&
name|flag_pic
operator|)
endif|#
directive|endif
operator|&&
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|)
operator|||
name|global_regs
index|[
name|regno
index|]
condition|)
name|handle_rd_kill_set
argument_list|(
name|insn
argument_list|,
name|regno
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* We work backwards because ... */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|handle_rd_kill_set
argument_list|(
name|insn
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Each setting of this register outside of this block 			 must be marked in the set of kills in this block.  */
name|handle_rd_kill_set
argument_list|(
name|insn
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|pat
argument_list|)
argument_list|)
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* FIXME: CLOBBER? */
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute the reaching definitions as in     Compilers Principles, Techniques, and Tools. Aho, Sethi, Ullman,    Chapter 10.  It is the same algorithm as used for computing available    expressions but applied to the gens and kills of reaching definitions.  */
end_comment

begin_function
specifier|static
name|void
name|compute_rd
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
name|sbitmap_copy
argument_list|(
name|rd_out
index|[
name|bb
index|]
comment|/*dst*/
argument_list|,
name|rd_gen
index|[
name|bb
index|]
comment|/*src*/
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|sbitmap_union_of_predecessors
argument_list|(
name|reaching_defs
index|[
name|bb
index|]
argument_list|,
name|rd_out
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_union_of_diff
argument_list|(
name|rd_out
index|[
name|bb
index|]
argument_list|,
name|rd_gen
index|[
name|bb
index|]
argument_list|,
name|reaching_defs
index|[
name|bb
index|]
argument_list|,
name|rd_kill
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"reaching def computation: %d passes\n"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Classic GCSE available expression support.  */
end_comment

begin_comment
comment|/* Allocate memory for available expression computation.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_avail_expr_mem
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|)
name|int
name|n_blocks
decl_stmt|,
name|n_exprs
decl_stmt|;
block|{
name|ae_kill
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_kill
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|ae_gen
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_gen
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|ae_in
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_in
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|ae_out
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|ae_out
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|u_bitmap
operator|=
operator|(
name|sbitmap
operator|)
name|sbitmap_alloc
argument_list|(
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|u_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_avail_expr_mem
parameter_list|()
block|{
name|free
argument_list|(
name|ae_kill
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ae_gen
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ae_in
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ae_out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|u_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the set of available expressions generated in each basic block.  */
end_comment

begin_function
specifier|static
name|void
name|compute_ae_gen
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* For each recorded occurrence of each expression, set ae_gen[bb][expr].      This is all we have to do because an expression is not recorded if it      is not available, and the only expressions we want to work with are the      ones that are recorded.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|expr
init|=
name|expr_hash_table
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|expr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|occr
modifier|*
name|occr
init|=
name|expr
operator|->
name|avail_occr
decl_stmt|;
while|while
condition|(
name|occr
operator|!=
name|NULL
condition|)
block|{
name|SET_BIT
argument_list|(
name|ae_gen
index|[
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
name|occr
operator|=
name|occr
operator|->
name|next
expr_stmt|;
block|}
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if expression X is killed in BB.  */
end_comment

begin_function
specifier|static
name|int
name|expr_killed_p
parameter_list|(
name|x
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|bb
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
return|return
name|TEST_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
index|]
argument_list|,
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
return|;
case|case
name|MEM
case|:
if|if
condition|(
name|mem_set_in_block
index|[
name|bb
index|]
condition|)
return|return
literal|1
return|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|tem
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
if|if
condition|(
name|expr_killed_p
argument_list|(
name|tem
argument_list|,
name|bb
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|expr_killed_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|bb
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute the set of available expressions killed in each basic block.  */
end_comment

begin_function
specifier|static
name|void
name|compute_ae_kill
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|expr
init|=
name|expr_hash_table
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
comment|/* Skip EXPR if generated in this block.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|expr_killed_p
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
name|bb
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|ae_kill
index|[
name|bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute available expressions.     Implement the algorithm to find available expressions    as given in the Aho Sethi Ullman book, pages 627-631.  */
end_comment

begin_function
specifier|static
name|void
name|compute_available
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|ae_in
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sbitmap_copy
argument_list|(
name|ae_out
index|[
literal|0
index|]
comment|/*dst*/
argument_list|,
name|ae_gen
index|[
literal|0
index|]
comment|/*src*/
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|1
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
name|sbitmap_difference
argument_list|(
name|ae_out
index|[
name|bb
index|]
argument_list|,
name|u_bitmap
argument_list|,
name|ae_kill
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|1
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|sbitmap_intersect_of_predecessors
argument_list|(
name|ae_in
index|[
name|bb
index|]
argument_list|,
name|ae_out
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_union_of_diff
argument_list|(
name|ae_out
index|[
name|bb
index|]
argument_list|,
name|ae_gen
index|[
name|bb
index|]
argument_list|,
name|ae_in
index|[
name|bb
index|]
argument_list|,
name|ae_kill
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"avail expr computation: %d passes\n"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Actually perform the Classic GCSE optimizations.  */
end_comment

begin_comment
comment|/* Return non-zero if occurrence OCCR of expression EXPR reaches block BB.     CHECK_SELF_LOOP is non-zero if we should consider a block reaching itself    as a positive reach.  We want to do this when there are two computations    of the expression in the block.     VISITED is a pointer to a working buffer for tracking which BB's have    been visited.  It is NULL for the top-level call.     We treat reaching expressions that go through blocks containing the same    reaching expression as "not reaching".  E.g. if EXPR is generated in blocks    2 and 3, INSN is in block 4, and 2->3->4, we treat the expression in block    2 as not reaching.  The intent is to improve the probability of finding    only one reaching expression and to reduce register lifetimes by picking    the closest such expression.  */
end_comment

begin_function
specifier|static
name|int
name|expr_reaches_here_p
parameter_list|(
name|occr
parameter_list|,
name|expr
parameter_list|,
name|bb
parameter_list|,
name|check_self_loop
parameter_list|,
name|visited
parameter_list|)
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int
name|check_self_loop
decl_stmt|;
name|char
modifier|*
name|visited
decl_stmt|;
block|{
name|int_list_ptr
name|pred
decl_stmt|;
if|if
condition|(
name|visited
operator|==
name|NULL
condition|)
block|{
name|visited
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|visited
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pred
operator|=
name|s_preds
index|[
name|bb
index|]
init|;
name|pred
operator|!=
name|NULL
condition|;
name|pred
operator|=
name|pred
operator|->
name|next
control|)
block|{
name|int
name|pred_bb
init|=
name|INT_LIST_VAL
argument_list|(
name|pred
argument_list|)
decl_stmt|;
if|if
condition|(
name|visited
index|[
name|pred_bb
index|]
condition|)
block|{
comment|/* This predecessor has already been visited. 	     Nothing to do.  */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|pred_bb
operator|==
name|bb
condition|)
block|{
comment|/* BB loops on itself.  */
if|if
condition|(
name|check_self_loop
operator|&&
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|pred_bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
operator|&&
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|==
name|pred_bb
condition|)
return|return
literal|1
return|;
name|visited
index|[
name|pred_bb
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Ignore this predecessor if it kills the expression.  */
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|ae_kill
index|[
name|pred_bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
name|visited
index|[
name|pred_bb
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Does this predecessor generate this expression?  */
elseif|else
if|if
condition|(
name|TEST_BIT
argument_list|(
name|ae_gen
index|[
name|pred_bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
block|{
comment|/* Is this the occurrence we're looking for? 	     Note that there's only one generating occurrence per block 	     so we just need to check the block number.  */
if|if
condition|(
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|==
name|pred_bb
condition|)
return|return
literal|1
return|;
name|visited
index|[
name|pred_bb
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Neither gen nor kill.  */
else|else
block|{
name|visited
index|[
name|pred_bb
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|expr_reaches_here_p
argument_list|(
name|occr
argument_list|,
name|expr
argument_list|,
name|pred_bb
argument_list|,
name|check_self_loop
argument_list|,
name|visited
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* All paths have been checked.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the instruction that computes EXPR that reaches INSN's basic block.    If there is more than one such instruction, return NULL.     Called only by handle_avail_expr.  */
end_comment

begin_function
specifier|static
name|rtx
name|computing_insn
parameter_list|(
name|expr
parameter_list|,
name|insn
parameter_list|)
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|int
name|bb
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|expr
operator|->
name|avail_occr
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|BLOCK_NUM
argument_list|(
name|expr
operator|->
name|avail_occr
operator|->
name|insn
argument_list|)
operator|==
name|bb
condition|)
block|{
comment|/* The available expression is actually itself 	     (i.e. a loop in the flow graph) so do nothing.  */
return|return
name|NULL
return|;
block|}
comment|/* (FIXME) Case that we found a pattern that was created by 	 a substitution that took place.  */
return|return
name|expr
operator|->
name|avail_occr
operator|->
name|insn
return|;
block|}
else|else
block|{
comment|/* Pattern is computed more than once. 	 Search backwards from this insn to see how many of these  	 computations actually reach this insn.  */
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|rtx
name|insn_computes_expr
init|=
name|NULL
decl_stmt|;
name|int
name|can_reach
init|=
literal|0
decl_stmt|;
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
operator|==
name|bb
condition|)
block|{
comment|/* The expression is generated in this block. 		 The only time we care about this is when the expression 		 is generated later in the block [and thus there's a loop]. 		 We let the normal cse pass handle the other cases.  */
if|if
condition|(
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
operator|<
name|INSN_CUID
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|expr_reaches_here_p
argument_list|(
name|occr
argument_list|,
name|expr
argument_list|,
name|bb
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|can_reach
operator|++
expr_stmt|;
if|if
condition|(
name|can_reach
operator|>
literal|1
condition|)
return|return
name|NULL
return|;
name|insn_computes_expr
operator|=
name|occr
operator|->
name|insn
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* Computation of the pattern outside this block.  */
block|{
if|if
condition|(
name|expr_reaches_here_p
argument_list|(
name|occr
argument_list|,
name|expr
argument_list|,
name|bb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|can_reach
operator|++
expr_stmt|;
if|if
condition|(
name|can_reach
operator|>
literal|1
condition|)
return|return
name|NULL
return|;
name|insn_computes_expr
operator|=
name|occr
operator|->
name|insn
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|insn_computes_expr
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|insn_computes_expr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if the definition in DEF_INSN can reach INSN.    Only called by can_disregard_other_sets.  */
end_comment

begin_function
specifier|static
name|int
name|def_reaches_here_p
parameter_list|(
name|insn
parameter_list|,
name|def_insn
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|def_insn
decl_stmt|;
block|{
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reaching_defs
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|INSN_CUID
argument_list|(
name|def_insn
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|def_insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|INSN_CUID
argument_list|(
name|def_insn
argument_list|)
operator|<
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|reg
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|def_insn
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return
operator|!
name|reg_set_between_p
argument_list|(
name|reg
argument_list|,
name|NEXT_INSN
argument_list|(
name|def_insn
argument_list|)
argument_list|,
name|insn
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if *ADDR_THIS_REG can only have one value at INSN.    The value returned is the number of definitions that reach INSN.    Returning a value of zero means that [maybe] more than one definition    reaches INSN and the caller can't perform whatever optimization it is    trying.  i.e. it is always safe to return zero.  */
end_comment

begin_function
specifier|static
name|int
name|can_disregard_other_sets
parameter_list|(
name|addr_this_reg
parameter_list|,
name|insn
parameter_list|,
name|for_combine
parameter_list|)
name|struct
name|reg_set
modifier|*
modifier|*
name|addr_this_reg
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|for_combine
decl_stmt|;
block|{
name|int
name|number_of_reaching_defs
init|=
literal|0
decl_stmt|;
name|struct
name|reg_set
modifier|*
name|this_reg
init|=
operator|*
name|addr_this_reg
decl_stmt|;
while|while
condition|(
name|this_reg
condition|)
block|{
if|if
condition|(
name|def_reaches_here_p
argument_list|(
name|insn
argument_list|,
name|this_reg
operator|->
name|insn
argument_list|)
condition|)
block|{
name|number_of_reaching_defs
operator|++
expr_stmt|;
comment|/* Ignore parallels for now.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|for_combine
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
operator|||
operator|!
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* A setting of the reg to a different value reaches INSN.  */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|number_of_reaching_defs
operator|>
literal|1
condition|)
block|{
comment|/* If in this setting the value the register is being 		 set to is equal to the previous value the register  		 was set to and this setting reaches the insn we are 		 trying to do the substitution on then we are ok.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|this_reg
operator|->
name|insn
argument_list|)
argument_list|)
argument_list|,
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
operator|*
name|addr_this_reg
operator|=
name|this_reg
expr_stmt|;
block|}
comment|/* prev_this_reg = this_reg; */
name|this_reg
operator|=
name|this_reg
operator|->
name|next
expr_stmt|;
block|}
return|return
name|number_of_reaching_defs
return|;
block|}
end_function

begin_comment
comment|/* Expression computed by insn is available and the substitution is legal,    so try to perform the substitution.     The result is non-zero if any changes were made.  */
end_comment

begin_function
specifier|static
name|int
name|handle_avail_expr
parameter_list|(
name|insn
parameter_list|,
name|expr
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
block|{
name|rtx
name|pat
decl_stmt|,
name|insn_computes_expr
decl_stmt|;
name|rtx
name|to
decl_stmt|;
name|struct
name|reg_set
modifier|*
name|this_reg
decl_stmt|;
name|int
name|found_setting
decl_stmt|,
name|use_src
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
comment|/* We only handle the case where one computation of the expression      reaches this instruction.  */
name|insn_computes_expr
operator|=
name|computing_insn
argument_list|(
name|expr
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn_computes_expr
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|found_setting
operator|=
literal|0
expr_stmt|;
name|use_src
operator|=
literal|0
expr_stmt|;
comment|/* At this point we know only one computation of EXPR outside of this      block reaches this insn.  Now try to find a register that the      expression is computed into.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* This is the case when the available expression that reaches 	 here has already been handled as an available expression.  */
name|int
name|regnum_for_replacing
init|=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If the register was created by GCSE we can't use `reg_set_table', 	 however we know it's set only once.  */
if|if
condition|(
name|regnum_for_replacing
operator|>=
name|max_gcse_regno
comment|/* If the register the expression is computed into is set only once, 	     or only one set reaches this insn, we can use it.  */
operator|||
operator|(
operator|(
operator|(
name|this_reg
operator|=
name|reg_set_table
index|[
name|regnum_for_replacing
index|]
operator|)
operator|,
name|this_reg
operator|->
name|next
operator|==
name|NULL
operator|)
operator|||
name|can_disregard_other_sets
argument_list|(
operator|&
name|this_reg
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|use_src
operator|=
literal|1
expr_stmt|;
name|found_setting
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found_setting
condition|)
block|{
name|int
name|regnum_for_replacing
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* This shouldn't happen.  */
if|if
condition|(
name|regnum_for_replacing
operator|>=
name|max_gcse_regno
condition|)
name|abort
argument_list|()
expr_stmt|;
name|this_reg
operator|=
name|reg_set_table
index|[
name|regnum_for_replacing
index|]
expr_stmt|;
comment|/* If the register the expression is computed into is set only once, 	 or only one set reaches this insn, use it.  */
if|if
condition|(
name|this_reg
operator|->
name|next
operator|==
name|NULL
operator|||
name|can_disregard_other_sets
argument_list|(
operator|&
name|this_reg
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
condition|)
name|found_setting
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found_setting
condition|)
block|{
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_src
condition|)
name|to
operator|=
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|to
operator|=
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|to
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We should be able to ignore the return code from validate_change but 	 to play it safe we check.  */
if|if
condition|(
name|changed
condition|)
block|{
name|gcse_subst_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE: Replacing the source in insn %d with reg %d %s insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|to
argument_list|)
argument_list|,
name|use_src
condition|?
literal|"from"
else|:
literal|"set in"
argument_list|,
name|INSN_UID
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* The register that the expr is computed into is set more than once.  */
elseif|else
if|if
condition|(
literal|1
comment|/*expensive_op(this_pattrn->op)&& do_expensive_gcse)*/
condition|)
block|{
comment|/* Insert an insn after insnx that copies the reg set in insnx 	 into a new pseudo register call this new register REGN. 	 From insnb until end of basic block or until REGB is set 	 replace all uses of REGB with REGN.  */
name|rtx
name|new_insn
decl_stmt|;
name|to
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Generate the new insn.  */
comment|/* ??? If the change fails, we return 0, even though we created 	 an insn.  I think this is ok.  */
name|new_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|to
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|insn_computes_expr
argument_list|)
expr_stmt|;
comment|/* Keep block number table up to date.  */
name|set_block_num
argument_list|(
name|new_insn
argument_list|,
name|BLOCK_NUM
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep register set table up to date.  */
name|record_one_set
argument_list|(
name|REGNO
argument_list|(
name|to
argument_list|)
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
name|gcse_create_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE: Creating insn %d to copy value of reg %d, computed in insn %d,\n"
argument_list|,
name|INSN_UID
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"      into newly allocated reg %d\n"
argument_list|,
name|REGNO
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pat
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Do register replacement for INSN.  */
name|changed
operator|=
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We should be able to ignore the return code from validate_change but 	 to play it safe we check.  */
if|if
condition|(
name|changed
condition|)
block|{
name|gcse_subst_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE: Replacing the source in insn %d with reg %d set in insn %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|insn_computes_expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Perform classic GCSE.    This is called by one_classic_gcse_pass after all the dataflow analysis    has been done.     The result is non-zero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|classic_gcse
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Note we start at block 1.  */
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|1
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
comment|/* Reset tables used to keep track of what's still valid [since the 	 start of the block].  */
name|reset_opr_set_tables
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NULL
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Is insn of form (set (pseudo-reg) ...)?  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
if|if
condition|(
name|want_to_gcse_p
argument_list|(
name|src
argument_list|)
comment|/* Is the expression recorded?  */
operator|&&
operator|(
operator|(
name|expr
operator|=
name|lookup_expr
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
comment|/* Is the expression available [at the start of the 		     block]?  */
operator|&&
name|TEST_BIT
argument_list|(
name|ae_in
index|[
name|bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
comment|/* Are the operands unchanged since the start of the 		     block?  */
operator|&&
name|oprs_not_set_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
condition|)
name|changed
operator||=
name|handle_avail_expr
argument_list|(
name|insn
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* Keep track of everything modified by this insn.  */
comment|/* ??? Need to be careful w.r.t. mods done to INSN.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|mark_oprs_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Top level routine to perform one classic GCSE pass.     Return non-zero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|one_classic_gcse_pass
parameter_list|(
name|pass
parameter_list|)
name|int
name|pass
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|gcse_subst_count
operator|=
literal|0
expr_stmt|;
name|gcse_create_count
operator|=
literal|0
expr_stmt|;
name|alloc_expr_hash_table
argument_list|(
name|max_cuid
argument_list|)
expr_stmt|;
name|alloc_rd_mem
argument_list|(
name|n_basic_blocks
argument_list|,
name|max_cuid
argument_list|)
expr_stmt|;
name|compute_expr_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|dump_hash_table
argument_list|(
name|gcse_file
argument_list|,
literal|"Expression"
argument_list|,
name|expr_hash_table
argument_list|,
name|expr_hash_table_size
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_exprs
operator|>
literal|0
condition|)
block|{
name|compute_kill_rd
argument_list|()
expr_stmt|;
name|compute_rd
argument_list|()
expr_stmt|;
name|alloc_avail_expr_mem
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_ae_gen
argument_list|()
expr_stmt|;
name|compute_ae_kill
argument_list|()
expr_stmt|;
name|compute_available
argument_list|()
expr_stmt|;
name|changed
operator|=
name|classic_gcse
argument_list|()
expr_stmt|;
name|free_avail_expr_mem
argument_list|()
expr_stmt|;
block|}
name|free_rd_mem
argument_list|()
expr_stmt|;
name|free_expr_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"GCSE of %s, pass %d: %d bytes needed, %d substs, %d insns created\n"
argument_list|,
name|current_function_name
argument_list|,
name|pass
argument_list|,
name|bytes_used
argument_list|,
name|gcse_subst_count
argument_list|,
name|gcse_create_count
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute copy/constant propagation working variables.  */
end_comment

begin_comment
comment|/* Local properties of assignments.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_pavloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_absaltered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global properties of assignments (computed from the local properties).  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_avin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|cprop_avout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate vars used for copy/const propagation.    N_BLOCKS is the number of basic blocks.    N_SETS is the number of sets.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_cprop_mem
parameter_list|(
name|n_blocks
parameter_list|,
name|n_sets
parameter_list|)
name|int
name|n_blocks
decl_stmt|,
name|n_sets
decl_stmt|;
block|{
name|cprop_pavloc
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
name|cprop_absaltered
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
name|cprop_avin
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
name|cprop_avout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free vars used by copy/const propagation.  */
end_comment

begin_function
specifier|static
name|void
name|free_cprop_mem
parameter_list|()
block|{
name|free
argument_list|(
name|cprop_pavloc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cprop_absaltered
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cprop_avin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cprop_avout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each block, compute whether X is transparent.    X is either an expression or an assignment [though we don't care which,    for this context an assignment is treated as an expression].    For each block where an element of X is modified, set (SET_P == 1) or reset    (SET_P == 0) the INDX bit in BMAP.  */
end_comment

begin_function
specifier|static
name|void
name|compute_transp
parameter_list|(
name|x
parameter_list|,
name|indx
parameter_list|,
name|bmap
parameter_list|,
name|set_p
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|sbitmap
modifier|*
name|bmap
decl_stmt|;
name|int
name|set_p
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
block|{
name|reg_set
modifier|*
name|r
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|set_p
condition|)
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|SET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|r
operator|=
name|reg_set_table
index|[
name|regno
index|]
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|bb
operator|=
name|BLOCK_NUM
argument_list|(
name|r
operator|->
name|insn
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|reg_set_in_block
index|[
name|bb
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|RESET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|r
operator|=
name|reg_set_table
index|[
name|regno
index|]
init|;
name|r
operator|!=
name|NULL
condition|;
name|r
operator|=
name|r
operator|->
name|next
control|)
block|{
name|bb
operator|=
name|BLOCK_NUM
argument_list|(
name|r
operator|->
name|insn
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
case|case
name|MEM
case|:
if|if
condition|(
name|set_p
condition|)
block|{
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
if|if
condition|(
name|mem_set_in_block
index|[
name|bb
index|]
condition|)
name|SET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
if|if
condition|(
name|mem_set_in_block
index|[
name|bb
index|]
condition|)
name|RESET_BIT
argument_list|(
name|bmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
comment|/*FIXME*/
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
default|default:
break|break;
block|}
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
expr_stmt|;
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|rtx
name|tem
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|tem
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|compute_transp
argument_list|(
name|tem
argument_list|,
name|indx
argument_list|,
name|bmap
argument_list|,
name|set_p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|compute_transp
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|indx
argument_list|,
name|bmap
argument_list|,
name|set_p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Compute the available expressions at the start and end of each    basic block for cprop.  This particular dataflow equation is    used often enough that we might want to generalize it and make    as a subroutine for other global optimizations that need available    in/out information.  */
end_comment

begin_function
specifier|static
name|void
name|compute_cprop_avinout
parameter_list|()
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|cprop_avin
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|cprop_avout
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
if|if
condition|(
name|bb
operator|!=
literal|0
condition|)
name|sbitmap_intersect_of_predecessors
argument_list|(
name|cprop_avin
index|[
name|bb
index|]
argument_list|,
name|cprop_avout
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_union_of_diff
argument_list|(
name|cprop_avout
index|[
name|bb
index|]
argument_list|,
name|cprop_pavloc
index|[
name|bb
index|]
argument_list|,
name|cprop_avin
index|[
name|bb
index|]
argument_list|,
name|cprop_absaltered
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"cprop avail expr computation: %d passes\n"
argument_list|,
name|passes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level routine to do the dataflow analysis needed by copy/const    propagation.  */
end_comment

begin_function
specifier|static
name|void
name|compute_cprop_data
parameter_list|()
block|{
name|compute_local_properties
argument_list|(
name|cprop_absaltered
argument_list|,
name|cprop_pavloc
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|compute_cprop_avinout
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy/constant propagation.  */
end_comment

begin_struct
struct|struct
name|reg_use
block|{
name|rtx
name|reg_rtx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Maximum number of register uses in an insn that we handle.  */
end_comment

begin_define
define|#
directive|define
name|MAX_USES
value|8
end_define

begin_comment
comment|/* Table of uses found in an insn.    Allocated statically to avoid alloc/free complexity and overhead.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|reg_use
name|reg_use_table
index|[
name|MAX_USES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index into `reg_use_table' while building it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reg_use_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up a list of register numbers used in INSN.    The found uses are stored in `reg_use_table'.    `reg_use_count' is initialized to zero before entry, and    contains the number of uses in the table upon exit.     ??? If a register appears multiple times we will record it multiple    times.  This doesn't hurt anything but it will slow things down.  */
end_comment

begin_function
specifier|static
name|void
name|find_used_regs
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* repeat is used to turn tail-recursion into iteration.  */
name|repeat
label|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|reg_use_count
operator|==
name|MAX_USES
condition|)
return|return;
name|reg_use_table
index|[
name|reg_use_count
index|]
operator|.
name|reg_rtx
operator|=
name|x
expr_stmt|;
name|reg_use_count
operator|++
expr_stmt|;
return|return;
case|case
name|MEM
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PC
case|:
case|case
name|CC0
case|:
case|case
name|CONST
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CLOBBER
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|ASM_INPUT
case|:
comment|/*FIXME*/
return|return;
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|find_used_regs
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* If we are about to do the last recursive call 	     needed at this level, change it into iteration. 	     This function is called enough to be worth it.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|find_used_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|find_used_regs
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Try to replace all non-SET_DEST occurrences of FROM in INSN with TO.    Returns non-zero is successful.  */
end_comment

begin_function
specifier|static
name|int
name|try_replace_reg
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|from
decl_stmt|,
name|to
decl_stmt|,
name|insn
decl_stmt|;
block|{
comment|/* If this fails we could try to simplify the result of the      replacement and attempt to recognize the simplified insn.       But we need a general simplify_rtx that doesn't have pass      specific state variables.  I'm not aware of one at the moment.  */
return|return
name|validate_replace_src
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find a set of REGNO that is available on entry to INSN's block.    Returns NULL if not found.  */
end_comment

begin_function
specifier|static
name|struct
name|expr
modifier|*
name|find_avail_set
parameter_list|(
name|regno
parameter_list|,
name|insn
parameter_list|)
name|int
name|regno
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|expr
modifier|*
name|set
init|=
name|lookup_set
argument_list|(
name|regno
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
while|while
condition|(
name|set
condition|)
block|{
if|if
condition|(
name|TEST_BIT
argument_list|(
name|cprop_avin
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
argument_list|,
name|set
operator|->
name|bitmap_index
argument_list|)
condition|)
break|break;
name|set
operator|=
name|next_set
argument_list|(
name|regno
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
return|return
name|set
return|;
block|}
end_function

begin_comment
comment|/* Perform constant and copy propagation on INSN.    The result is non-zero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|cprop_insn
parameter_list|(
name|insn
parameter_list|,
name|alter_jumps
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|alter_jumps
decl_stmt|;
block|{
name|struct
name|reg_use
modifier|*
name|reg_used
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
comment|/* Only propagate into SETs.  Note that a conditional jump is a      SET with pc_rtx as the destination.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|)
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|SET
condition|)
return|return
literal|0
return|;
name|reg_use_count
operator|=
literal|0
expr_stmt|;
name|find_used_regs
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|reg_used
operator|=
operator|&
name|reg_use_table
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
init|;
name|reg_use_count
operator|>
literal|0
condition|;
name|reg_used
operator|++
operator|,
name|reg_use_count
operator|--
control|)
block|{
name|rtx
name|pat
decl_stmt|,
name|src
decl_stmt|;
name|struct
name|expr
modifier|*
name|set
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|)
decl_stmt|;
comment|/* Ignore registers created by GCSE. 	 We do this because ... */
if|if
condition|(
name|regno
operator|>=
name|max_gcse_regno
condition|)
continue|continue;
comment|/* If the register has already been set in this block, there's 	 nothing we can do.  */
if|if
condition|(
operator|!
name|oprs_not_set_p
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|insn
argument_list|)
condition|)
continue|continue;
comment|/* Find an assignment that sets reg_used and is available 	 at the start of the block.  */
name|set
operator|=
name|find_avail_set
argument_list|(
name|regno
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
continue|continue;
name|pat
operator|=
name|set
operator|->
name|expr
expr_stmt|;
comment|/* ??? We might be able to handle PARALLELs.  Later.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* Constant propagation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
comment|/* Handle normal insns first.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
name|try_replace_reg
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|src
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|const_prop_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"CONST-PROP: Replacing reg %d in insn %d with constant "
argument_list|,
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* The original insn setting reg_used may or may not now be 		 deletable.  We leave the deletion to flow.  */
block|}
comment|/* Try to propagate a CONST_INT into a conditional jump. 	     We're pretty specific about what we will handle in this 	     code, we can extend this as necessary over time.  	     Right now the insn in question must look like  	     (set (pc) (if_then_else ...))  	     Note this does not currently handle machines which use cc0.  */
elseif|else
if|if
condition|(
name|alter_jumps
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|condjump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* We want a copy of the JUMP_INSN so we can modify it 		 in-place as needed without effecting the original.  */
name|rtx
name|copy
init|=
name|copy_rtx
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|PATTERN
argument_list|(
name|copy
argument_list|)
decl_stmt|;
name|rtx
name|temp
decl_stmt|;
comment|/* Replace the register with the appropriate constant.  */
name|replace_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|temp
operator|=
name|simplify_ternary_operation
argument_list|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If no simplification can be made, then try the next 		 register.  */
if|if
condition|(
name|temp
condition|)
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|=
name|temp
expr_stmt|;
else|else
continue|continue;
comment|/* That may have changed the structure of TEMP, so 		 force it to be rerecognized if it has not turned 		 into a nop or unconditional jump.  */
name|INSN_CODE
argument_list|(
name|copy
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|pc_rtx
operator|&&
operator|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|pc_rtx
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
operator|)
operator|)
operator|||
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|copy
argument_list|)
argument_list|,
name|copy
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* This has either become an unconditional jump 		     or a nop-jump.  We'd like to delete nop jumps 		     here, but doing so confuses gcse.  So we just 		     make the replacement and let later passes 		     sort things out.  */
name|PATTERN
argument_list|(
name|insn
argument_list|)
operator|=
name|set
expr_stmt|;
name|INSN_CODE
argument_list|(
name|insn
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* One less use of the label this insn used to jump to 		     if we turned this into a NOP jump.  */
if|if
condition|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
operator|--
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this has turned into an unconditional jump, 		     then put a barrier after it so that the unreachable 		     code will be deleted.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|emit_barrier_after
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|run_jump_opt_after_gcse
operator|=
literal|1
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|const_prop_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"CONST-PROP: Replacing reg %d in insn %d with constant "
argument_list|,
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|print_rtl
argument_list|(
name|gcse_file
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|!=
name|regno
condition|)
block|{
comment|/* We know the set is available. 	     Now check that SET_SRC is ANTLOC (i.e. none of the source operands 	     have changed since the start of the block).  */
if|if
condition|(
name|oprs_not_set_p
argument_list|(
name|src
argument_list|,
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
name|try_replace_reg
argument_list|(
name|reg_used
operator|->
name|reg_rtx
argument_list|,
name|src
argument_list|,
name|insn
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
name|copy_prop_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"COPY-PROP: Replacing reg %d in insn %d with reg %d\n"
argument_list|,
name|regno
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The original insn setting reg_used may or may not now be 		     deletable.  We leave the deletion to flow.  */
comment|/* FIXME: If it turns out that the insn isn't deletable, 		     then we may have unnecessarily extended register lifetimes 		     and made things worse.  */
block|}
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Forward propagate copies.    This includes copies and constants.    Return non-zero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|cprop
parameter_list|(
name|alter_jumps
parameter_list|)
name|int
name|alter_jumps
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Note we start at block 1.  */
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|1
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
comment|/* Reset tables used to keep track of what's still valid [since the 	 start of the block].  */
name|reset_opr_set_tables
argument_list|()
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NULL
operator|&&
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|changed
operator||=
name|cprop_insn
argument_list|(
name|insn
argument_list|,
name|alter_jumps
argument_list|)
expr_stmt|;
comment|/* Keep track of everything modified by this insn.  */
comment|/* ??? Need to be careful w.r.t. mods done to INSN.  */
name|mark_oprs_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|gcse_file
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Perform one copy/constant propagation pass.    F is the first insn in the function.    PASS is the pass count.  */
end_comment

begin_function
specifier|static
name|int
name|one_cprop_pass
parameter_list|(
name|pass
parameter_list|,
name|alter_jumps
parameter_list|)
name|int
name|pass
decl_stmt|;
name|int
name|alter_jumps
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|const_prop_count
operator|=
literal|0
expr_stmt|;
name|copy_prop_count
operator|=
literal|0
expr_stmt|;
name|alloc_set_hash_table
argument_list|(
name|max_cuid
argument_list|)
expr_stmt|;
name|compute_set_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|dump_hash_table
argument_list|(
name|gcse_file
argument_list|,
literal|"SET"
argument_list|,
name|set_hash_table
argument_list|,
name|set_hash_table_size
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_sets
operator|>
literal|0
condition|)
block|{
name|alloc_cprop_mem
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_sets
argument_list|)
expr_stmt|;
name|compute_cprop_data
argument_list|()
expr_stmt|;
name|changed
operator|=
name|cprop
argument_list|(
name|alter_jumps
argument_list|)
expr_stmt|;
name|free_cprop_mem
argument_list|()
expr_stmt|;
block|}
name|free_set_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"CPROP of %s, pass %d: %d bytes needed, %d const props, %d copy props\n"
argument_list|,
name|current_function_name
argument_list|,
name|pass
argument_list|,
name|bytes_used
argument_list|,
name|const_prop_count
argument_list|,
name|copy_prop_count
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute PRE+LCM working variables.  */
end_comment

begin_comment
comment|/* Local properties of expressions.  */
end_comment

begin_comment
comment|/* Nonzero for expressions that are transparent in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|transp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are transparent at the end of the block.    This is only zero for expressions killed by abnormal critical edge    created by a calls.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|transpout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are computed (available) in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|comp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions that are locally anticipatable in the block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|antloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions where this block is an optimal computation    point.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_optimal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero for expressions which are redundant in a particular block.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|pre_redundant
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sbitmap
modifier|*
name|temp_bitmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Redundant insns.  */
end_comment

begin_decl_stmt
specifier|static
name|sbitmap
name|pre_redundant_insns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate vars used for PRE analysis.  */
end_comment

begin_function
specifier|static
name|void
name|alloc_pre_mem
parameter_list|(
name|n_blocks
parameter_list|,
name|n_exprs
parameter_list|)
name|int
name|n_blocks
decl_stmt|,
name|n_exprs
decl_stmt|;
block|{
name|transp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|comp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|antloc
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|pre_optimal
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|pre_redundant
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|transpout
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free vars used for PRE analysis.  */
end_comment

begin_function
specifier|static
name|void
name|free_pre_mem
parameter_list|()
block|{
name|free
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|antloc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pre_optimal
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pre_redundant
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|transpout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Top level routine to do the dataflow analysis needed by PRE.  */
end_comment

begin_function
specifier|static
name|void
name|compute_pre_data
parameter_list|()
block|{
name|compute_local_properties
argument_list|(
name|transp
argument_list|,
name|comp
argument_list|,
name|antloc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|compute_transpout
argument_list|()
expr_stmt|;
name|pre_lcm
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|,
name|s_preds
argument_list|,
name|s_succs
argument_list|,
name|transp
argument_list|,
name|antloc
argument_list|,
name|pre_redundant
argument_list|,
name|pre_optimal
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* PRE utilities */
end_comment

begin_comment
comment|/* Return non-zero if an occurrence of expression EXPR in OCCR_BB would reach    block BB.     VISITED is a pointer to a working buffer for tracking which BB's have    been visited.  It is NULL for the top-level call.     CHECK_PRE_COMP controls whether or not we check for a computation of    EXPR in OCCR_BB.     We treat reaching expressions that go through blocks containing the same    reaching expression as "not reaching".  E.g. if EXPR is generated in blocks    2 and 3, INSN is in block 4, and 2->3->4, we treat the expression in block    2 as not reaching.  The intent is to improve the probability of finding    only one reaching expression and to reduce register lifetimes by picking    the closest such expression.  */
end_comment

begin_function
specifier|static
name|int
name|pre_expr_reaches_here_p
parameter_list|(
name|occr_bb
parameter_list|,
name|expr
parameter_list|,
name|bb
parameter_list|,
name|check_pre_comp
parameter_list|,
name|visited
parameter_list|)
name|int
name|occr_bb
decl_stmt|;
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int
name|check_pre_comp
decl_stmt|;
name|char
modifier|*
name|visited
decl_stmt|;
block|{
name|int_list_ptr
name|pred
decl_stmt|;
if|if
condition|(
name|visited
operator|==
name|NULL
condition|)
block|{
name|visited
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|visited
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pred
operator|=
name|s_preds
index|[
name|bb
index|]
init|;
name|pred
operator|!=
name|NULL
condition|;
name|pred
operator|=
name|pred
operator|->
name|next
control|)
block|{
name|int
name|pred_bb
init|=
name|INT_LIST_VAL
argument_list|(
name|pred
argument_list|)
decl_stmt|;
if|if
condition|(
name|pred_bb
operator|==
name|ENTRY_BLOCK
comment|/* Has predecessor has already been visited?  */
operator|||
name|visited
index|[
name|pred_bb
index|]
condition|)
block|{
comment|/* Nothing to do.  */
block|}
comment|/* Does this predecessor generate this expression?  */
elseif|else
if|if
condition|(
operator|(
operator|!
name|check_pre_comp
operator|&&
name|occr_bb
operator|==
name|pred_bb
operator|)
operator|||
name|TEST_BIT
argument_list|(
name|comp
index|[
name|pred_bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
block|{
comment|/* Is this the occurrence we're looking for? 	     Note that there's only one generating occurrence per block 	     so we just need to check the block number.  */
if|if
condition|(
name|occr_bb
operator|==
name|pred_bb
condition|)
return|return
literal|1
return|;
name|visited
index|[
name|pred_bb
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Ignore this predecessor if it kills the expression.  */
elseif|else
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|transp
index|[
name|pred_bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
name|visited
index|[
name|pred_bb
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Neither gen nor kill.  */
else|else
block|{
name|visited
index|[
name|pred_bb
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pre_expr_reaches_here_p
argument_list|(
name|occr_bb
argument_list|,
name|expr
argument_list|,
name|pred_bb
argument_list|,
name|check_pre_comp
argument_list|,
name|visited
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
block|}
comment|/* All paths have been checked.  */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add EXPR to the end of basic block BB.     This is used by both the PRE and code hoisting.     For PRE, we want to verify that the expr is either transparent    or locally anticipatable in the target block.  This check makes    no sense for code hoisting.  */
end_comment

begin_function
specifier|static
name|void
name|insert_insn_end_bb
parameter_list|(
name|expr
parameter_list|,
name|bb
parameter_list|,
name|pre
parameter_list|)
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int
name|pre
decl_stmt|;
block|{
name|rtx
name|insn
init|=
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
name|rtx
name|new_insn
decl_stmt|;
name|rtx
name|reg
init|=
name|expr
operator|->
name|reaching_reg
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|rtx
name|pat
decl_stmt|,
name|copied_expr
decl_stmt|;
name|rtx
name|first_new_insn
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|copied_expr
operator|=
name|copy_rtx
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|reg
argument_list|,
name|copied_expr
argument_list|)
expr_stmt|;
name|first_new_insn
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|pat
operator|=
name|gen_sequence
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* If the last insn is a jump, insert EXPR in front [taking care to      handle cc0, etc. properly].  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
name|rtx
name|note
decl_stmt|;
endif|#
directive|endif
comment|/* If this is a jump table, then we can't insert stuff here.  Since 	 we know the previous real insn must be the tablejump, we insert 	 the new instruction just before the tablejump.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
name|insn
operator|=
name|prev_real_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* FIXME: 'twould be nice to call prev_cc0_setter here but it aborts 	 if cc0 isn't set.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_CC_SETTER
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|maybe_cc0_setter
init|=
name|prev_nonnote_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|maybe_cc0_setter
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|maybe_cc0_setter
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|sets_cc0_p
argument_list|(
name|PATTERN
argument_list|(
name|maybe_cc0_setter
argument_list|)
argument_list|)
condition|)
name|insn
operator|=
name|maybe_cc0_setter
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FIXME: What if something in cc0/jump uses value set in new insn?  */
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
operator|=
name|new_insn
expr_stmt|;
block|}
comment|/* Likewise if the last insn is a call, as will happen in the presence      of exception handling.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|HARD_REG_SET
name|parm_regs
decl_stmt|;
name|int
name|nparm_regs
decl_stmt|;
name|rtx
name|p
decl_stmt|;
comment|/* Keeping in mind SMALL_REGISTER_CLASSES and parameters in registers, 	 we search backward and place the instructions before the first 	 parameter is loaded.  Do this for everyone for consistency and a 	 presumtion that we'll get better code elsewhere as well.  */
comment|/* It should always be the case that we can put these instructions 	 anywhere in the basic block with performing PRE optimizations. 	 Check this.  */
if|if
condition|(
name|pre
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|antloc
index|[
name|bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
operator|&&
operator|!
name|TEST_BIT
argument_list|(
name|transp
index|[
name|bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Since different machines initialize their parameter registers 	 in different orders, assume nothing.  Collect the set of all 	 parameter registers.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|parm_regs
argument_list|)
expr_stmt|;
name|nparm_regs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|XEXP
argument_list|(
name|p
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_HARD_REG_BIT
argument_list|(
name|parm_regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|nparm_regs
operator|++
expr_stmt|;
block|}
comment|/* Search backward for the first set of a register in this set.  */
while|while
condition|(
name|nparm_regs
operator|&&
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
operator|!=
name|insn
condition|)
block|{
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|p
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|p
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|p
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|TEST_HARD_REG_BIT
argument_list|(
name|parm_regs
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|CLEAR_HARD_REG_BIT
argument_list|(
name|parm_regs
argument_list|,
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nparm_regs
operator|--
expr_stmt|;
block|}
block|}
comment|/* If we found all the parameter loads, then we want to insert 	 before the first parameter load.  	 If we did not find all the parameter loads, then we might have 	 stopped on the head of the block, which could be a CODE_LABEL. 	 If we inserted before the CODE_LABEL, then we would be putting 	 the insn in the wrong basic block.  In that case, put the insn 	 after the CODE_LABEL.  	 ?!? Do we need to account for NOTE_INSN_BASIC_BLOCK here?  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
block|{
name|new_insn
operator|=
name|emit_insn_before
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
operator|==
name|insn
condition|)
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
operator|=
name|new_insn
expr_stmt|;
block|}
else|else
block|{
name|new_insn
operator|=
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|new_insn
operator|=
name|emit_insn_after
argument_list|(
name|pat
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
operator|=
name|new_insn
expr_stmt|;
block|}
comment|/* Keep block number table up to date.      Note, PAT could be a multiple insn sequence, we have to make      sure that each insn in the sequence is handled.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|insn
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|set_block_num
argument_list|(
name|insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|add_label_notes
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
name|record_set_insn
operator|=
name|insn
expr_stmt|;
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|record_set_info
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|add_label_notes
argument_list|(
name|SET_SRC
argument_list|(
name|pat
argument_list|)
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
name|set_block_num
argument_list|(
name|new_insn
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* Keep register set table up to date.  */
name|record_one_set
argument_list|(
name|regno
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
block|}
name|gcse_create_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE/HOIST: end of bb %d, insn %d, copying expression %d to reg %d\n"
argument_list|,
name|bb
argument_list|,
name|INSN_UID
argument_list|(
name|new_insn
argument_list|)
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert partially redundant expressions at the ends of appropriate basic    blocks making them fully redundant.  */
end_comment

begin_function
specifier|static
name|void
name|pre_insert
parameter_list|(
name|index_map
parameter_list|)
name|struct
name|expr
modifier|*
modifier|*
name|index_map
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|i
decl_stmt|,
name|set_size
decl_stmt|;
name|sbitmap
modifier|*
name|inserted
decl_stmt|;
comment|/* Compute INSERT = PRE_OPTIMAL& ~PRE_REDUNDANT.       Where INSERT is nonzero, we add the expression at the end of the basic      block if it reaches any of the deleted expressions.  */
name|set_size
operator|=
name|pre_optimal
index|[
literal|0
index|]
operator|->
name|size
expr_stmt|;
name|inserted
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|inserted
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|int
name|indx
decl_stmt|;
comment|/* This computes the number of potential insertions we need.  */
name|sbitmap_not
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|pre_redundant
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|pre_optimal
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
comment|/* TEMP_BITMAP[bb] now contains a bitmap of the expressions that we need 	 to insert at the end of this basic block.  */
for|for
control|(
name|i
operator|=
name|indx
operator|=
literal|0
init|;
name|i
operator|<
name|set_size
condition|;
name|i
operator|++
operator|,
name|indx
operator|+=
name|SBITMAP_ELT_BITS
control|)
block|{
name|SBITMAP_ELT_TYPE
name|insert
init|=
name|temp_bitmap
index|[
name|bb
index|]
operator|->
name|elms
index|[
name|i
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|indx
init|;
name|insert
operator|&&
name|j
operator|<
name|n_exprs
condition|;
name|j
operator|++
operator|,
name|insert
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|insert
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|&&
name|index_map
index|[
name|j
index|]
operator|->
name|reaching_reg
operator|!=
name|NULL_RTX
condition|)
block|{
name|struct
name|expr
modifier|*
name|expr
init|=
name|index_map
index|[
name|j
index|]
decl_stmt|;
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
comment|/* Now look at each deleted occurence of this expression.  */
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|occr
operator|->
name|deleted_p
condition|)
continue|continue;
comment|/* Insert this expression at the end of BB if it would 			 reach the deleted occurence.  */
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|inserted
index|[
name|bb
index|]
argument_list|,
name|j
argument_list|)
operator|&&
name|pre_expr_reaches_here_p
argument_list|(
name|bb
argument_list|,
name|expr
argument_list|,
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|SET_BIT
argument_list|(
name|inserted
index|[
name|bb
index|]
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|insert_insn_end_bb
argument_list|(
name|index_map
index|[
name|j
index|]
argument_list|,
name|bb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Copy the result of INSN to REG.    INDX is the expression number.  */
end_comment

begin_function
specifier|static
name|void
name|pre_insert_copy_insn
parameter_list|(
name|expr
parameter_list|,
name|insn
parameter_list|)
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|reg
init|=
name|expr
operator|->
name|reaching_reg
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|int
name|indx
init|=
name|expr
operator|->
name|bitmap_index
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|new_insn
decl_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
name|abort
argument_list|()
expr_stmt|;
name|new_insn
operator|=
name|emit_insn_after
argument_list|(
name|gen_rtx_SET
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Keep block number table up to date.  */
name|set_block_num
argument_list|(
name|new_insn
argument_list|,
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep register set table up to date.  */
name|record_one_set
argument_list|(
name|regno
argument_list|,
name|new_insn
argument_list|)
expr_stmt|;
name|gcse_create_count
operator|++
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE: bb %d, insn %d, copying expression %d in insn %d to reg %d\n"
argument_list|,
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|new_insn
argument_list|)
argument_list|,
name|indx
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy available expressions that reach the redundant expression    to `reaching_reg'.  */
end_comment

begin_function
specifier|static
name|void
name|pre_insert_copies
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|bb
decl_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|sbitmap_a_and_b
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|pre_optimal
index|[
name|bb
index|]
argument_list|,
name|pre_redundant
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* For each available expression in the table, copy the result to      `reaching_reg' if the expression reaches a deleted one.       ??? The current algorithm is rather brute force.      Need to do some profiling.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
comment|/* If the basic block isn't reachable, PPOUT will be TRUE. 	     However, we don't want to insert a copy here because the 	     expression may not really be redundant.  So only insert 	     an insn if the expression was deleted. 	     This test also avoids further processing if the expression 	     wasn't deleted anywhere.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
name|struct
name|occr
modifier|*
name|avail
decl_stmt|;
if|if
condition|(
operator|!
name|occr
operator|->
name|deleted_p
condition|)
continue|continue;
for|for
control|(
name|avail
operator|=
name|expr
operator|->
name|avail_occr
init|;
name|avail
operator|!=
name|NULL
condition|;
name|avail
operator|=
name|avail
operator|->
name|next
control|)
block|{
name|rtx
name|insn
init|=
name|avail
operator|->
name|insn
decl_stmt|;
name|int
name|bb
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TEST_BIT
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
condition|)
continue|continue;
comment|/* No need to handle this one if handled already.  */
if|if
condition|(
name|avail
operator|->
name|copied_p
condition|)
continue|continue;
comment|/* Don't handle this one if it's a redundant one.  */
if|if
condition|(
name|TEST_BIT
argument_list|(
name|pre_redundant_insns
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Or if the expression doesn't reach the deleted one.  */
if|if
condition|(
operator|!
name|pre_expr_reaches_here_p
argument_list|(
name|BLOCK_NUM
argument_list|(
name|avail
operator|->
name|insn
argument_list|)
argument_list|,
name|expr
argument_list|,
name|BLOCK_NUM
argument_list|(
name|occr
operator|->
name|insn
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
condition|)
continue|continue;
comment|/* Copy the result of avail to reaching_reg.  */
name|pre_insert_copy_insn
argument_list|(
name|expr
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|avail
operator|->
name|copied_p
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete redundant computations.    Deletion is done by changing the insn to copy the `reaching_reg' of    the expression into the result of the SET.  It is left to later passes    (cprop, cse2, flow, combine, regmove) to propagate the copy or eliminate it.     Returns non-zero if a change is made.  */
end_comment

begin_function
specifier|static
name|int
name|pre_delete
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|bb
decl_stmt|,
name|changed
decl_stmt|;
comment|/* Compute the expressions which are redundant and need to be replaced by      copies from the reaching reg to the target reg.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|sbitmap_not
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|pre_optimal
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|sbitmap_a_and_b
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|pre_redundant
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
block|{
name|struct
name|occr
modifier|*
name|occr
decl_stmt|;
name|int
name|indx
init|=
name|expr
operator|->
name|bitmap_index
decl_stmt|;
comment|/* We only need to search antic_occr since we require 	     ANTLOC != 0.  */
for|for
control|(
name|occr
operator|=
name|expr
operator|->
name|antic_occr
init|;
name|occr
operator|!=
name|NULL
condition|;
name|occr
operator|=
name|occr
operator|->
name|next
control|)
block|{
name|rtx
name|insn
init|=
name|occr
operator|->
name|insn
decl_stmt|;
name|rtx
name|set
decl_stmt|;
name|int
name|bb
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|TEST_BIT
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|indx
argument_list|)
condition|)
block|{
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create a pseudo-reg to store the result of reaching 		     expressions into.  Get the mode for the new pseudo 		     from the mode of the original destination pseudo.  */
if|if
condition|(
name|expr
operator|->
name|reaching_reg
operator|==
name|NULL
condition|)
name|expr
operator|->
name|reaching_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In theory this should never fail since we're creating 		     a reg->reg copy.  		     However, on the x86 some of the movXX patterns actually 		     contain clobbers of scratch regs.  This may cause the 		     insn created by validate_change to not match any pattern 		     and thus cause validate_change to fail.   */
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|expr
operator|->
name|reaching_reg
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|occr
operator|->
name|deleted_p
operator|=
literal|1
expr_stmt|;
name|SET_BIT
argument_list|(
name|pre_redundant_insns
argument_list|,
name|INSN_CUID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
name|gcse_subst_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE: redundant insn %d (expression %d) in bb %d, reaching reg is %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|,
name|indx
argument_list|,
name|bb
argument_list|,
name|REGNO
argument_list|(
name|expr
operator|->
name|reaching_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Perform GCSE optimizations using PRE.    This is called by one_pre_gcse_pass after all the dataflow analysis    has been done.     This is based on the original Morel-Renvoise paper Fred Chow's thesis,    and lazy code motion from Knoop, Ruthing and Steffen as described in    Advanced Compiler Design and Implementation.     ??? A new pseudo reg is created to hold the reaching expression.    The nice thing about the classical approach is that it would try to    use an existing reg.  If the register can't be adequately optimized    [i.e. we introduce reload problems], one could add a pass here to    propagate the new register through the block.     ??? We don't handle single sets in PARALLELs because we're [currently]    not able to copy the rest of the parallel when we insert copies to create    full redundancies from partial redundancies.  However, there's no reason    why we can't handle PARALLELs in the cases where there are no partial    redundancies.  */
end_comment

begin_function
specifier|static
name|int
name|pre_gcse
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|struct
name|expr
modifier|*
modifier|*
name|index_map
decl_stmt|;
comment|/* Compute a mapping from expression number (`bitmap_index') to      hash table entry.  */
name|index_map
operator|=
operator|(
expr|struct
name|expr
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|n_exprs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|index_map
argument_list|,
name|n_exprs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
operator|!=
name|NULL
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
name|index_map
index|[
name|expr
operator|->
name|bitmap_index
index|]
operator|=
name|expr
expr_stmt|;
block|}
comment|/* Reset bitmap used to track which insns are redundant.  */
name|pre_redundant_insns
operator|=
name|sbitmap_alloc
argument_list|(
name|max_cuid
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|pre_redundant_insns
argument_list|)
expr_stmt|;
comment|/* Delete the redundant insns first so that      - we know what register to use for the new insns and for the other        ones with reaching expressions      - we know which insns are redundant when we go to create copies  */
name|changed
operator|=
name|pre_delete
argument_list|()
expr_stmt|;
comment|/* Insert insns in places that make partially redundant expressions      fully redundant.  */
name|pre_insert
argument_list|(
name|index_map
argument_list|)
expr_stmt|;
comment|/* In other places with reaching expressions, copy the expression to the      specially allocated pseudo-reg that reaches the redundant expression.  */
name|pre_insert_copies
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|pre_redundant_insns
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Top level routine to perform one PRE GCSE pass.     Return non-zero if a change was made.  */
end_comment

begin_function
specifier|static
name|int
name|one_pre_gcse_pass
parameter_list|(
name|pass
parameter_list|)
name|int
name|pass
decl_stmt|;
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|gcse_subst_count
operator|=
literal|0
expr_stmt|;
name|gcse_create_count
operator|=
literal|0
expr_stmt|;
name|alloc_expr_hash_table
argument_list|(
name|max_cuid
argument_list|)
expr_stmt|;
name|compute_expr_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
name|dump_hash_table
argument_list|(
name|gcse_file
argument_list|,
literal|"Expression"
argument_list|,
name|expr_hash_table
argument_list|,
name|expr_hash_table_size
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_exprs
operator|>
literal|0
condition|)
block|{
name|alloc_pre_mem
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_exprs
argument_list|)
expr_stmt|;
name|compute_pre_data
argument_list|()
expr_stmt|;
name|changed
operator||=
name|pre_gcse
argument_list|()
expr_stmt|;
name|free_pre_mem
argument_list|()
expr_stmt|;
block|}
name|free_expr_hash_table
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcse_file
condition|)
block|{
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|gcse_file
argument_list|,
literal|"PRE GCSE of %s, pass %d: %d bytes needed, %d substs, %d insns created\n"
argument_list|,
name|current_function_name
argument_list|,
name|pass
argument_list|,
name|bytes_used
argument_list|,
name|gcse_subst_count
argument_list|,
name|gcse_create_count
argument_list|)
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X contains any LABEL_REF's, add REG_LABEL notes for them to INSN.    We have to add REG_LABEL notes, because the following loop optimization    pass requires them.  */
end_comment

begin_comment
comment|/* ??? This is very similar to the loop.c add_label_notes function.  We    could probably share code here.  */
end_comment

begin_comment
comment|/* ??? If there was a jump optimization pass after gcse and before loop,    then we would not need to do this here, because jump would add the    necessary REG_LABEL notes.  */
end_comment

begin_function
specifier|static
name|void
name|add_label_notes
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
operator|&&
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* This code used to ignore labels that referred to dispatch tables to 	 avoid flow generating (slighly) worse code.  	 We no longer ignore such label references (see LABEL_REF handling in 	 mark_jump_label for additional information).  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_LABEL
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|add_label_notes
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|add_label_notes
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute transparent outgoing information for each block.     An expression is transparent to an edge unless it is killed by    the edge itself.  This can only happen with abnormal control flow,    when the edge is traversed through a call.  This happens with    non-local labels and exceptions.     This would not be necessary if we split the edge.  While this is    normally impossible for abnormal critical edges, with some effort    it should be possible with exception handling, since we still have    control over which handler should be invoked.  But due to increased    EH table sizes, this may not be worthwhile.  */
end_comment

begin_function
specifier|static
name|void
name|compute_transpout
parameter_list|()
block|{
name|int
name|bb
decl_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|transpout
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
operator|++
name|bb
control|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Note that flow inserted a nop a the end of basic blocks that 	 end in call instructions for reasons other than abnormal 	 control flow.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|!=
name|CALL_INSN
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|expr_hash_table_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|expr
modifier|*
name|expr
decl_stmt|;
for|for
control|(
name|expr
operator|=
name|expr_hash_table
index|[
name|i
index|]
init|;
name|expr
condition|;
name|expr
operator|=
name|expr
operator|->
name|next_same_hash
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
operator|->
name|expr
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|expr
operator|->
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|addr
argument_list|)
condition|)
continue|continue;
comment|/* ??? Optimally, we would use interprocedural alias 		   analysis to determine if this mem is actually killed 		   by this call.  */
name|RESET_BIT
argument_list|(
name|transpout
index|[
name|bb
index|]
argument_list|,
name|expr
operator|->
name|bitmap_index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

