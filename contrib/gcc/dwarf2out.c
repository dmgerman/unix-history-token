begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output Dwarf2 format symbol table information from GCC.    Copyright (C) 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,    2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Gary Funck (gary@intrepid.com).    Derived from DWARF 1 implementation of Ron Guilmette (rfg@monkeys.com).    Extensively modified by Jason Merrill (jason@cygnus.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* TODO: Emit .debug_line header even when there are no functions, since 	   the file numbers are used by .debug_info.  Alternately, leave 	   out locations for types and decls. 	 Avoid talking about ctors and op= for PODs. 	 Factor out common prologue sequences into multiple CIEs.  */
end_comment

begin_comment
comment|/* The first part of this file deals with the DWARF 2 frame unwind    information, which is also used by the GCC efficient exception handling    mechanism.  The second part, controlled only by an #ifdef    DWARF2_DEBUGGING_INFO, deals with the other DWARF 2 debugging    information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2asm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
end_ifdef

begin_function_decl
specifier|static
name|void
name|dwarf2out_source_line
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DWARF2 Abbreviation Glossary:    CFA = Canonical Frame Address 	   a fixed address on the stack which identifies a call frame. 	   We define it to be the value of SP just before the call insn. 	   The CFA register and offset, which may change during the course 	   of the function, are used to calculate its value at runtime.    CFI = Call Frame Instruction 	   an instruction for the DWARF2 abstract machine    CIE = Common Information Entry 	   information describing information common to one or more FDEs    DIE = Debugging Information Entry    FDE = Frame Description Entry 	   information describing the stack call frame, in particular, 	   how to restore registers     DW_CFA_... = DWARF2 CFA call frame instruction    DW_TAG_... = DWARF2 DIE tag */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_FRAME_INFO
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
end_ifdef

begin_define
define|#
directive|define
name|DWARF2_FRAME_INFO
define|\
value|(write_symbols == DWARF2_DEBUG || write_symbols == VMS_AND_DWARF2_DEBUG)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DWARF2_FRAME_INFO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Map register numbers held in the call frame info that gcc has    collected using DWARF_FRAME_REGNUM to those that should be output in    .debug_frame and .eh_frame.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_FRAME_REG_OUT
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_FRAME_REG_OUT
parameter_list|(
name|REGNO
parameter_list|,
name|FOR_EH
parameter_list|)
value|(REGNO)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Decide whether we want to emit frame unwind information for the current    translation unit.  */
end_comment

begin_function
name|int
name|dwarf2out_do_frame
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We want to emit correct CFA location expressions or lists, so we      have to return true if we're going to output debug info, even if      we're not going to output frame or unwind info.  */
return|return
operator|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
operator|||
name|DWARF2_FRAME_INFO
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
operator|||
operator|(
name|DWARF2_UNWIND_INFO
operator|&&
operator|(
name|flag_unwind_tables
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|)
operator|)
operator|)
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The size of the target's pointer type.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTR_SIZE
end_ifndef

begin_define
define|#
directive|define
name|PTR_SIZE
value|(POINTER_SIZE / BITS_PER_UNIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Array of RTXes referenced by the debugging information, which therefore    must be kept around forever.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|rtx
argument_list|,
name|gc
argument_list|)
operator|*
name|used_rtx_array
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A pointer to the base of a list of incomplete types which might be    completed at some later time.  incomplete_types_list needs to be a    VEC(tree,gc) because we want to tell the garbage collector about    it.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|incomplete_types
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A pointer to the base of a table of references to declaration    scopes.  This table is a display which tracks the nesting    of declaration scopes at the current scope and containing    scopes.  This table is used to find the proper place to    define type declaration DIE's.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|decl_scope_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Pointers to various DWARF2 sections.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|debug_info_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|debug_abbrev_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|debug_aranges_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|debug_macinfo_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|debug_line_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|debug_loc_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|debug_pubnames_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|debug_str_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|debug_ranges_section
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|section
operator|*
name|debug_frame_section
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|dw_cfi_struct
modifier|*
name|dw_cfi_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_fde_struct
modifier|*
name|dw_fde_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|union
name|dw_cfi_oprnd_struct
modifier|*
name|dw_cfi_oprnd_ref
typedef|;
end_typedef

begin_comment
comment|/* Call frames are described using a sequence of Call Frame    Information instructions.  The register number, offset    and address fields are provided as possible operands;    their use is selected by the opcode field.  */
end_comment

begin_enum
enum|enum
name|dw_cfi_oprnd_type
block|{
name|dw_cfi_oprnd_unused
block|,
name|dw_cfi_oprnd_reg_num
block|,
name|dw_cfi_oprnd_offset
block|,
name|dw_cfi_oprnd_addr
block|,
name|dw_cfi_oprnd_loc
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|union
name|dw_cfi_oprnd_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|unsigned
name|int
name|GTY
block|((
name|tag
block|("dw_cfi_oprnd_reg_num"))
typedef|) dw_cfi_reg_num;
end_typedef

begin_decl_stmt
name|HOST_WIDE_INT
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_cfi_oprnd_offset"
argument_list|)
operator|)
argument_list|)
name|dw_cfi_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_cfi_oprnd_addr"
argument_list|)
operator|)
argument_list|)
name|dw_cfi_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dw_loc_descr_struct
modifier|*
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_cfi_oprnd_loc"
argument_list|)
operator|)
argument_list|)
name|dw_cfi_loc
decl_stmt|;
end_decl_stmt

begin_empty_stmt
unit|} dw_cfi_oprnd
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|struct
name|dw_cfi_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|dw_cfi_ref
name|dw_cfi_next
block|;
name|enum
name|dwarf_call_frame_info
name|dw_cfi_opc
block|;
name|dw_cfi_oprnd
name|GTY
argument_list|(
operator|(
name|desc
argument_list|(
literal|"dw_cfi_oprnd1_desc (%1.dw_cfi_opc)"
argument_list|)
operator|)
argument_list|)
name|dw_cfi_oprnd1
block|;
name|dw_cfi_oprnd
name|GTY
argument_list|(
operator|(
name|desc
argument_list|(
literal|"dw_cfi_oprnd2_desc (%1.dw_cfi_opc)"
argument_list|)
operator|)
argument_list|)
name|dw_cfi_oprnd2
block|; }
end_typedef

begin_expr_stmt
name|dw_cfi_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This is how we define the location of the CFA. We use to handle it    as REG + OFFSET all the time,  but now it can be more complex.    It can now be either REG + CFA_OFFSET or *(REG + BASE_OFFSET) + CFA_OFFSET.    Instead of passing around REG and OFFSET, we pass a copy    of this structure.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|cfa_loc
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|HOST_WIDE_INT
name|offset
block|;
name|HOST_WIDE_INT
name|base_offset
block|;
name|unsigned
name|int
name|reg
block|;
name|int
name|indirect
block|;
comment|/* 1 if CFA is accessed via a dereference.  */
block|}
end_typedef

begin_expr_stmt
name|dw_cfa_location
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* All call frame descriptions (FDE's) in the GCC generated DWARF    refer to a single Common Information Entry (CIE), defined at    the beginning of the .debug_frame section.  This use of a single    CIE obviates the need to keep track of multiple CIE's    in the DWARF generation routines below.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_fde_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|tree
name|decl
block|;
specifier|const
name|char
modifier|*
name|dw_fde_begin
block|;
specifier|const
name|char
modifier|*
name|dw_fde_current_label
block|;
specifier|const
name|char
modifier|*
name|dw_fde_end
block|;
specifier|const
name|char
modifier|*
name|dw_fde_hot_section_label
block|;
specifier|const
name|char
modifier|*
name|dw_fde_hot_section_end_label
block|;
specifier|const
name|char
modifier|*
name|dw_fde_unlikely_section_label
block|;
specifier|const
name|char
modifier|*
name|dw_fde_unlikely_section_end_label
block|;
name|bool
name|dw_fde_switched_sections
block|;
name|dw_cfi_ref
name|dw_fde_cfi
block|;
name|unsigned
name|funcdef_number
block|;
name|unsigned
name|all_throwers_are_sibcalls
range|:
literal|1
block|;
name|unsigned
name|nothrow
range|:
literal|1
block|;
name|unsigned
name|uses_eh_lsda
range|:
literal|1
block|; }
end_typedef

begin_expr_stmt
name|dw_fde_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Maximum size (in bytes) of an artificially generated label.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ARTIFICIAL_LABEL_BYTES
value|30
end_define

begin_comment
comment|/* The size of addresses as they appear in the Dwarf 2 data.    Some architectures use word addresses to refer to code locations,    but Dwarf 2 info always uses byte addresses.  On such machines,    Dwarf 2 addresses need to be larger than the architecture's    pointers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_ADDR_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_ADDR_SIZE
value|(POINTER_SIZE / BITS_PER_UNIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The size in bytes of a DWARF field indicating an offset or length    relative to a debug info section, specified to be 4 bytes in the    DWARF-2 specification.  The SGI/MIPS ABI defines it to be the same    as PTR_SIZE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_OFFSET_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DWARF_OFFSET_SIZE
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* According to the (draft) DWARF 3 specification, the initial length    should either be 4 or 12 bytes.  When it's 12 bytes, the first 4    bytes are 0xffffffff, followed by the length stored in the next 8    bytes.     However, the SGI/MIPS ABI uses an initial length which is equal to    DWARF_OFFSET_SIZE.  It is defined (elsewhere) accordingly.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_INITIAL_LENGTH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DWARF_INITIAL_LENGTH_SIZE
value|(DWARF_OFFSET_SIZE == 4 ? 4 : 12)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DWARF_VERSION
value|2
end_define

begin_comment
comment|/* Round SIZE up to the nearest BOUNDARY.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_ROUND
parameter_list|(
name|SIZE
parameter_list|,
name|BOUNDARY
parameter_list|)
define|\
value|((((SIZE) + (BOUNDARY) - 1) / (BOUNDARY)) * (BOUNDARY))
end_define

begin_comment
comment|/* Offsets recorded in opcodes are a multiple of this alignment factor.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_CIE_DATA_ALIGNMENT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|DWARF_CIE_DATA_ALIGNMENT
value|(-((int) UNITS_PER_WORD))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DWARF_CIE_DATA_ALIGNMENT
value|((int) UNITS_PER_WORD)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CIE identifier.  */
end_comment

begin_if
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
end_if

begin_define
define|#
directive|define
name|DWARF_CIE_ID
define|\
value|(unsigned HOST_WIDE_INT) (DWARF_OFFSET_SIZE == 4 ? DW_CIE_ID : DW64_CIE_ID)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DWARF_CIE_ID
value|DW_CIE_ID
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A pointer to the base of a table that contains frame description    information for each routine.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(length (
literal|"fde_table_allocated"
argument|))
argument_list|)
name|dw_fde_ref
name|fde_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements currently allocated for fde_table.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|fde_table_allocated
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements in fde_table currently in use.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|fde_table_in_use
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    fde_table.  */
end_comment

begin_define
define|#
directive|define
name|FDE_TABLE_INCREMENT
value|256
end_define

begin_comment
comment|/* A list of call frame insns for the CIE.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|dw_cfi_ref
name|cie_cfi_head
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
end_if

begin_comment
comment|/* Some DWARF extensions (e.g., MIPS/SGI) implement a subprogram    attribute that accelerates the lookup of the FDE associated    with the subprogram.  This variable holds the table index of the FDE    associated with the current function (body) definition.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|current_funcdef_fde
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|indirect_string_node
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|int
name|refcount
decl_stmt|;
name|unsigned
name|int
name|form
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct indirect_string_node))
argument_list|)
name|htab_t
name|debug_str_hash
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|dw2_string_counter
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|long
name|dwarf2out_cfi_label_num
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
end_if

begin_comment
comment|/* Forward declarations for functions defined in this file.  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|stripattributes
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_cfi_name
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_cfi_ref
name|new_cfi
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_cfi
parameter_list|(
name|dw_cfi_ref
modifier|*
parameter_list|,
name|dw_cfi_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_fde_cfi
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|dw_cfi_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lookup_cfa_1
parameter_list|(
name|dw_cfi_ref
parameter_list|,
name|dw_cfa_location
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lookup_cfa
parameter_list|(
name|dw_cfa_location
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reg_save
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initial_return_save
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|stack_adjust_offset
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_cfi
parameter_list|(
name|dw_cfi_ref
parameter_list|,
name|dw_fde_ref
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_call_frame_info
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_stack_adjust
parameter_list|(
name|rtx
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flush_queued_reg_saves
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|clobbers_queued_reg_save
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_frame_debug_expr
parameter_list|(
name|rtx
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Support for complex CFA locations.  */
end_comment

begin_function_decl
specifier|static
name|void
name|output_cfa_loc
parameter_list|(
name|dw_cfi_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_cfa_from_loc_descr
parameter_list|(
name|dw_cfa_location
modifier|*
parameter_list|,
name|struct
name|dw_loc_descr_struct
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dw_loc_descr_struct
modifier|*
name|build_cfa_loc
parameter_list|(
name|dw_cfa_location
modifier|*
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|def_cfa_1
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|dw_cfa_location
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Data and reference forms for relocatable data.  */
end_comment

begin_define
define|#
directive|define
name|DW_FORM_data
value|(DWARF_OFFSET_SIZE == 8 ? DW_FORM_data8 : DW_FORM_data4)
end_define

begin_define
define|#
directive|define
name|DW_FORM_ref
value|(DWARF_OFFSET_SIZE == 8 ? DW_FORM_ref8 : DW_FORM_ref4)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_FRAME_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_FRAME_SECTION
value|".debug_frame"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FUNC_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|FUNC_BEGIN_LABEL
value|"LFB"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FUNC_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|FUNC_END_LABEL
value|"LFE"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FRAME_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|FRAME_BEGIN_LABEL
value|"Lframe"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CIE_AFTER_SIZE_LABEL
value|"LSCIE"
end_define

begin_define
define|#
directive|define
name|CIE_END_LABEL
value|"LECIE"
end_define

begin_define
define|#
directive|define
name|FDE_LABEL
value|"LSFDE"
end_define

begin_define
define|#
directive|define
name|FDE_AFTER_SIZE_LABEL
value|"LASFDE"
end_define

begin_define
define|#
directive|define
name|FDE_END_LABEL
value|"LEFDE"
end_define

begin_define
define|#
directive|define
name|LINE_NUMBER_BEGIN_LABEL
value|"LSLT"
end_define

begin_define
define|#
directive|define
name|LINE_NUMBER_END_LABEL
value|"LELT"
end_define

begin_define
define|#
directive|define
name|LN_PROLOG_AS_LABEL
value|"LASLTP"
end_define

begin_define
define|#
directive|define
name|LN_PROLOG_END_LABEL
value|"LELTP"
end_define

begin_define
define|#
directive|define
name|DIE_LABEL_PREFIX
value|"DW"
end_define

begin_comment
comment|/* The DWARF 2 CFA column which tracks the return address.  Normally this    is the column for PC, or the first column after all of the hard    registers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_FRAME_RETURN_COLUMN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PC_REGNUM
end_ifdef

begin_define
define|#
directive|define
name|DWARF_FRAME_RETURN_COLUMN
value|DWARF_FRAME_REGNUM (PC_REGNUM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DWARF_FRAME_RETURN_COLUMN
value|DWARF_FRAME_REGISTERS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The mapping from gcc register number to DWARF 2 CFA column number.  By    default, we just provide columns for all registers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_FRAME_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|DWARF_FRAME_REGNUM
parameter_list|(
name|REG
parameter_list|)
value|DBX_REGISTER_NUMBER (REG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Hook used by __throw.  */
end_comment

begin_function
name|rtx
name|expand_builtin_dwarf_sp_column
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|dwarf_regnum
init|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
decl_stmt|;
return|return
name|GEN_INT
argument_list|(
name|DWARF2_FRAME_REG_OUT
argument_list|(
name|dwarf_regnum
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a copy of the section string name S with all    attributes stripped off, and an asterisk prepended (for assemble_name).  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|stripattributes
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|stripped
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|stripped
decl_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'*'
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|','
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|stripped
return|;
block|}
end_function

begin_comment
comment|/* Generate code to initialize the register size table.  */
end_comment

begin_function
name|void
name|expand_builtin_init_dwarf_reg_sizes
parameter_list|(
name|tree
name|address
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|expand_normal
argument_list|(
name|address
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|bool
name|wrote_return_column
init|=
name|false
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rnum
init|=
name|DWARF2_FRAME_REG_OUT
argument_list|(
name|DWARF_FRAME_REGNUM
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|rnum
operator|<
name|DWARF_FRAME_REGISTERS
condition|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
name|rnum
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|save_mode
init|=
name|reg_raw_mode
index|[
name|i
index|]
decl_stmt|;
name|HOST_WIDE_INT
name|size
decl_stmt|;
if|if
condition|(
name|HARD_REGNO_CALL_PART_CLOBBERED
argument_list|(
name|i
argument_list|,
name|save_mode
argument_list|)
condition|)
name|save_mode
operator|=
name|choose_hard_reg_mode
argument_list|(
name|i
argument_list|,
literal|1
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|DWARF_FRAME_REGNUM
argument_list|(
name|i
argument_list|)
operator|==
name|DWARF_FRAME_RETURN_COLUMN
condition|)
block|{
if|if
condition|(
name|save_mode
operator|==
name|VOIDmode
condition|)
continue|continue;
name|wrote_return_column
operator|=
name|true
expr_stmt|;
block|}
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|save_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
continue|continue;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
argument_list|,
name|gen_int_mode
argument_list|(
name|size
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DWARF_ALT_FRAME_RETURN_COLUMN
name|gcc_assert
argument_list|(
name|wrote_return_column
argument_list|)
expr_stmt|;
name|i
operator|=
name|DWARF_ALT_FRAME_RETURN_COLUMN
expr_stmt|;
name|wrote_return_column
operator|=
name|false
expr_stmt|;
else|#
directive|else
name|i
operator|=
name|DWARF_FRAME_RETURN_COLUMN
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|wrote_return_column
condition|)
block|{
name|enum
name|machine_mode
name|save_mode
init|=
name|Pmode
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
name|i
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|save_mode
argument_list|)
decl_stmt|;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF call frame info. operation to its string name */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_cfi_name
parameter_list|(
name|unsigned
name|int
name|cfi_opc
parameter_list|)
block|{
switch|switch
condition|(
name|cfi_opc
condition|)
block|{
case|case
name|DW_CFA_advance_loc
case|:
return|return
literal|"DW_CFA_advance_loc"
return|;
case|case
name|DW_CFA_offset
case|:
return|return
literal|"DW_CFA_offset"
return|;
case|case
name|DW_CFA_restore
case|:
return|return
literal|"DW_CFA_restore"
return|;
case|case
name|DW_CFA_nop
case|:
return|return
literal|"DW_CFA_nop"
return|;
case|case
name|DW_CFA_set_loc
case|:
return|return
literal|"DW_CFA_set_loc"
return|;
case|case
name|DW_CFA_advance_loc1
case|:
return|return
literal|"DW_CFA_advance_loc1"
return|;
case|case
name|DW_CFA_advance_loc2
case|:
return|return
literal|"DW_CFA_advance_loc2"
return|;
case|case
name|DW_CFA_advance_loc4
case|:
return|return
literal|"DW_CFA_advance_loc4"
return|;
case|case
name|DW_CFA_offset_extended
case|:
return|return
literal|"DW_CFA_offset_extended"
return|;
case|case
name|DW_CFA_restore_extended
case|:
return|return
literal|"DW_CFA_restore_extended"
return|;
case|case
name|DW_CFA_undefined
case|:
return|return
literal|"DW_CFA_undefined"
return|;
case|case
name|DW_CFA_same_value
case|:
return|return
literal|"DW_CFA_same_value"
return|;
case|case
name|DW_CFA_register
case|:
return|return
literal|"DW_CFA_register"
return|;
case|case
name|DW_CFA_remember_state
case|:
return|return
literal|"DW_CFA_remember_state"
return|;
case|case
name|DW_CFA_restore_state
case|:
return|return
literal|"DW_CFA_restore_state"
return|;
case|case
name|DW_CFA_def_cfa
case|:
return|return
literal|"DW_CFA_def_cfa"
return|;
case|case
name|DW_CFA_def_cfa_register
case|:
return|return
literal|"DW_CFA_def_cfa_register"
return|;
case|case
name|DW_CFA_def_cfa_offset
case|:
return|return
literal|"DW_CFA_def_cfa_offset"
return|;
comment|/* DWARF 3 */
case|case
name|DW_CFA_def_cfa_expression
case|:
return|return
literal|"DW_CFA_def_cfa_expression"
return|;
case|case
name|DW_CFA_expression
case|:
return|return
literal|"DW_CFA_expression"
return|;
case|case
name|DW_CFA_offset_extended_sf
case|:
return|return
literal|"DW_CFA_offset_extended_sf"
return|;
case|case
name|DW_CFA_def_cfa_sf
case|:
return|return
literal|"DW_CFA_def_cfa_sf"
return|;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
return|return
literal|"DW_CFA_def_cfa_offset_sf"
return|;
comment|/* SGI/MIPS specific */
case|case
name|DW_CFA_MIPS_advance_loc8
case|:
return|return
literal|"DW_CFA_MIPS_advance_loc8"
return|;
comment|/* GNU extensions */
case|case
name|DW_CFA_GNU_window_save
case|:
return|return
literal|"DW_CFA_GNU_window_save"
return|;
case|case
name|DW_CFA_GNU_args_size
case|:
return|return
literal|"DW_CFA_GNU_args_size"
return|;
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
return|return
literal|"DW_CFA_GNU_negative_offset_extended"
return|;
default|default:
return|return
literal|"DW_CFA_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to a newly allocated Call Frame Instruction.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_cfi_ref
name|new_cfi
parameter_list|(
name|void
parameter_list|)
block|{
name|dw_cfi_ref
name|cfi
init|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_cfi_node
argument_list|)
argument_list|)
decl_stmt|;
name|cfi
operator|->
name|dw_cfi_next
operator|=
name|NULL
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
literal|0
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_reg_num
operator|=
literal|0
expr_stmt|;
return|return
name|cfi
return|;
block|}
end_function

begin_comment
comment|/* Add a Call Frame Instruction to list of instructions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_cfi
parameter_list|(
name|dw_cfi_ref
modifier|*
name|list_head
parameter_list|,
name|dw_cfi_ref
name|cfi
parameter_list|)
block|{
name|dw_cfi_ref
modifier|*
name|p
decl_stmt|;
comment|/* Find the end of the chain.  */
for|for
control|(
name|p
operator|=
name|list_head
init|;
operator|(
operator|*
name|p
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|dw_cfi_next
control|)
empty_stmt|;
operator|*
name|p
operator|=
name|cfi
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a new label for the CFI info to refer to.  */
end_comment

begin_function
name|char
modifier|*
name|dwarf2out_cfi_label
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|label
index|[
literal|20
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LCFI"
argument_list|,
name|dwarf2out_cfi_label_num
operator|++
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Add CFI to the current fde at the PC value indicated by LABEL if specified,    or to the CIE if LABEL is NULL.  */
end_comment

begin_function
specifier|static
name|void
name|add_fde_cfi
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|dw_cfi_ref
name|cfi
parameter_list|)
block|{
if|if
condition|(
name|label
condition|)
block|{
name|dw_fde_ref
name|fde
init|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|label
operator|==
literal|0
condition|)
name|label
operator|=
name|dwarf2out_cfi_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|fde
operator|->
name|dw_fde_current_label
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|label
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dw_cfi_ref
name|xcfi
decl_stmt|;
name|label
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* Set the location counter to the new label.  */
name|xcfi
operator|=
name|new_cfi
argument_list|()
expr_stmt|;
comment|/* If we have a current label, advance from there, otherwise 	     set the location directly using set_loc.  */
name|xcfi
operator|->
name|dw_cfi_opc
operator|=
name|fde
operator|->
name|dw_fde_current_label
condition|?
name|DW_CFA_advance_loc4
else|:
name|DW_CFA_set_loc
expr_stmt|;
name|xcfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
operator|=
name|label
expr_stmt|;
name|add_cfi
argument_list|(
operator|&
name|fde
operator|->
name|dw_fde_cfi
argument_list|,
name|xcfi
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|label
expr_stmt|;
block|}
name|add_cfi
argument_list|(
operator|&
name|fde
operator|->
name|dw_fde_cfi
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
else|else
name|add_cfi
argument_list|(
operator|&
name|cie_cfi_head
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of lookup_cfa.  */
end_comment

begin_function
specifier|static
name|void
name|lookup_cfa_1
parameter_list|(
name|dw_cfi_ref
name|cfi
parameter_list|,
name|dw_cfa_location
modifier|*
name|loc
parameter_list|)
block|{
switch|switch
condition|(
name|cfi
operator|->
name|dw_cfi_opc
condition|)
block|{
case|case
name|DW_CFA_def_cfa_offset
case|:
name|loc
operator|->
name|offset
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
name|loc
operator|->
name|offset
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
operator|*
name|DWARF_CIE_DATA_ALIGNMENT
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|loc
operator|->
name|reg
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|loc
operator|->
name|reg
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
expr_stmt|;
name|loc
operator|->
name|offset
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_sf
case|:
name|loc
operator|->
name|reg
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
expr_stmt|;
name|loc
operator|->
name|offset
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
operator|*
name|DWARF_CIE_DATA_ALIGNMENT
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_expression
case|:
name|get_cfa_from_loc_descr
argument_list|(
name|loc
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_loc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Find the previous value for the CFA.  */
end_comment

begin_function
specifier|static
name|void
name|lookup_cfa
parameter_list|(
name|dw_cfa_location
modifier|*
name|loc
parameter_list|)
block|{
name|dw_cfi_ref
name|cfi
decl_stmt|;
name|loc
operator|->
name|reg
operator|=
name|INVALID_REGNUM
expr_stmt|;
name|loc
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|loc
operator|->
name|indirect
operator|=
literal|0
expr_stmt|;
name|loc
operator|->
name|base_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cfi
operator|=
name|cie_cfi_head
init|;
name|cfi
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|lookup_cfa_1
argument_list|(
name|cfi
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde_table_in_use
condition|)
block|{
name|dw_fde_ref
name|fde
init|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|cfi
operator|=
name|fde
operator|->
name|dw_fde_cfi
init|;
name|cfi
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|lookup_cfa_1
argument_list|(
name|cfi
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The current rule for calculating the DWARF2 canonical frame address.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_cfa_location
name|cfa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The register used for saving registers to the stack, and its offset    from the CFA.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_cfa_location
name|cfa_store
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The running total of the size of arguments pushed onto the stack.  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last args_size we actually output.  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|old_args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entry point to update the canonical frame address (CFA).    LABEL is passed to add_fde_cfi.  The value of CFA is now to be    calculated from REG+OFFSET.  */
end_comment

begin_function
name|void
name|dwarf2out_def_cfa
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|dw_cfa_location
name|loc
decl_stmt|;
name|loc
operator|.
name|indirect
operator|=
literal|0
expr_stmt|;
name|loc
operator|.
name|base_offset
operator|=
literal|0
expr_stmt|;
name|loc
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine if two dw_cfa_location structures define the same data.  */
end_comment

begin_function
specifier|static
name|bool
name|cfa_equal_p
parameter_list|(
specifier|const
name|dw_cfa_location
modifier|*
name|loc1
parameter_list|,
specifier|const
name|dw_cfa_location
modifier|*
name|loc2
parameter_list|)
block|{
return|return
operator|(
name|loc1
operator|->
name|reg
operator|==
name|loc2
operator|->
name|reg
operator|&&
name|loc1
operator|->
name|offset
operator|==
name|loc2
operator|->
name|offset
operator|&&
name|loc1
operator|->
name|indirect
operator|==
name|loc2
operator|->
name|indirect
operator|&&
operator|(
name|loc1
operator|->
name|indirect
operator|==
literal|0
operator|||
name|loc1
operator|->
name|base_offset
operator|==
name|loc2
operator|->
name|base_offset
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This routine does the actual work.  The CFA is now calculated from    the dw_cfa_location structure.  */
end_comment

begin_function
specifier|static
name|void
name|def_cfa_1
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|dw_cfa_location
modifier|*
name|loc_p
parameter_list|)
block|{
name|dw_cfi_ref
name|cfi
decl_stmt|;
name|dw_cfa_location
name|old_cfa
decl_stmt|,
name|loc
decl_stmt|;
name|cfa
operator|=
operator|*
name|loc_p
expr_stmt|;
name|loc
operator|=
operator|*
name|loc_p
expr_stmt|;
if|if
condition|(
name|cfa_store
operator|.
name|reg
operator|==
name|loc
operator|.
name|reg
operator|&&
name|loc
operator|.
name|indirect
operator|==
literal|0
condition|)
name|cfa_store
operator|.
name|offset
operator|=
name|loc
operator|.
name|offset
expr_stmt|;
name|loc
operator|.
name|reg
operator|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|loc
operator|.
name|reg
argument_list|)
expr_stmt|;
name|lookup_cfa
argument_list|(
operator|&
name|old_cfa
argument_list|)
expr_stmt|;
comment|/* If nothing changed, no need to issue any call frame instructions.  */
if|if
condition|(
name|cfa_equal_p
argument_list|(
operator|&
name|loc
argument_list|,
operator|&
name|old_cfa
argument_list|)
condition|)
return|return;
name|cfi
operator|=
name|new_cfi
argument_list|()
expr_stmt|;
if|if
condition|(
name|loc
operator|.
name|reg
operator|==
name|old_cfa
operator|.
name|reg
operator|&&
operator|!
name|loc
operator|.
name|indirect
condition|)
block|{
comment|/* Construct a "DW_CFA_def_cfa_offset<offset>" instruction, indicating 	 the CFA register did not change but the offset did.  */
if|if
condition|(
name|loc
operator|.
name|offset
operator|<
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|f_offset
init|=
name|loc
operator|.
name|offset
operator|/
name|DWARF_CIE_DATA_ALIGNMENT
decl_stmt|;
name|gcc_assert
argument_list|(
name|f_offset
operator|*
name|DWARF_CIE_DATA_ALIGNMENT
operator|==
name|loc
operator|.
name|offset
argument_list|)
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa_offset_sf
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
operator|=
name|f_offset
expr_stmt|;
block|}
else|else
block|{
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa_offset
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
operator|=
name|loc
operator|.
name|offset
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
comment|/* SGI dbx thinks this means no offset.  */
elseif|else
if|if
condition|(
name|loc
operator|.
name|offset
operator|==
name|old_cfa
operator|.
name|offset
operator|&&
name|old_cfa
operator|.
name|reg
operator|!=
name|INVALID_REGNUM
operator|&&
operator|!
name|loc
operator|.
name|indirect
condition|)
block|{
comment|/* Construct a "DW_CFA_def_cfa_register<register>" instruction, 	 indicating the CFA register has changed to<register> but the 	 offset has not changed.  */
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa_register
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
name|loc
operator|.
name|reg
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|loc
operator|.
name|indirect
operator|==
literal|0
condition|)
block|{
comment|/* Construct a "DW_CFA_def_cfa<register><offset>" instruction, 	 indicating the CFA register has changed to<register> with 	 the specified offset.  */
if|if
condition|(
name|loc
operator|.
name|offset
operator|<
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|f_offset
init|=
name|loc
operator|.
name|offset
operator|/
name|DWARF_CIE_DATA_ALIGNMENT
decl_stmt|;
name|gcc_assert
argument_list|(
name|f_offset
operator|*
name|DWARF_CIE_DATA_ALIGNMENT
operator|==
name|loc
operator|.
name|offset
argument_list|)
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa_sf
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
name|loc
operator|.
name|reg
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
operator|=
name|f_offset
expr_stmt|;
block|}
else|else
block|{
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
name|loc
operator|.
name|reg
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
operator|=
name|loc
operator|.
name|offset
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Construct a DW_CFA_def_cfa_expression instruction to 	 calculate the CFA using a full location expression since no 	 register-offset pair is available.  */
name|struct
name|dw_loc_descr_struct
modifier|*
name|loc_list
decl_stmt|;
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa_expression
expr_stmt|;
name|loc_list
operator|=
name|build_cfa_loc
argument_list|(
operator|&
name|loc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_loc
operator|=
name|loc_list
expr_stmt|;
block|}
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the CFI for saving a register.  REG is the CFA column number.    LABEL is passed to add_fde_cfi.    If SREG is -1, the register is saved at OFFSET from the CFA;    otherwise it is saved in SREG.  */
end_comment

begin_function
specifier|static
name|void
name|reg_save
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|unsigned
name|int
name|sreg
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|dw_cfi_ref
name|cfi
init|=
name|new_cfi
argument_list|()
decl_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|sreg
operator|==
name|INVALID_REGNUM
condition|)
block|{
if|if
condition|(
name|reg
operator|&
operator|~
literal|0x3f
condition|)
comment|/* The register number won't fit in 6 bits, so we have to use 	   the long form.  */
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_offset_extended
expr_stmt|;
else|else
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
comment|/* If we get an offset that is not a multiple of 	   DWARF_CIE_DATA_ALIGNMENT, there is either a bug in the 	   definition of DWARF_CIE_DATA_ALIGNMENT, or a bug in the machine 	   description.  */
name|HOST_WIDE_INT
name|check_offset
init|=
name|offset
operator|/
name|DWARF_CIE_DATA_ALIGNMENT
decl_stmt|;
name|gcc_assert
argument_list|(
name|check_offset
operator|*
name|DWARF_CIE_DATA_ALIGNMENT
operator|==
name|offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|offset
operator|/=
name|DWARF_CIE_DATA_ALIGNMENT
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_offset_extended_sf
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
operator|=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sreg
operator|==
name|reg
condition|)
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_same_value
expr_stmt|;
else|else
block|{
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_register
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_reg_num
operator|=
name|sreg
expr_stmt|;
block|}
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the CFI for saving a register window.  LABEL is passed to reg_save.    This CFI tells the unwinder that it needs to restore the window registers    from the previous frame's window save area.     ??? Perhaps we should note in the CIE where windows are saved (instead of    assuming 0(cfa)) and what registers are in the window.  */
end_comment

begin_function
name|void
name|dwarf2out_window_save
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|dw_cfi_ref
name|cfi
init|=
name|new_cfi
argument_list|()
decl_stmt|;
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_GNU_window_save
expr_stmt|;
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a CFI to update the running total of the size of arguments    pushed onto the stack.  */
end_comment

begin_function
name|void
name|dwarf2out_args_size
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|HOST_WIDE_INT
name|size
parameter_list|)
block|{
name|dw_cfi_ref
name|cfi
decl_stmt|;
if|if
condition|(
name|size
operator|==
name|old_args_size
condition|)
return|return;
name|old_args_size
operator|=
name|size
expr_stmt|;
name|cfi
operator|=
name|new_cfi
argument_list|()
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_GNU_args_size
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
operator|=
name|size
expr_stmt|;
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point for saving a register to the stack.  REG is the GCC register    number.  LABEL and OFFSET are passed to reg_save.  */
end_comment

begin_function
name|void
name|dwarf2out_reg_save
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|unsigned
name|int
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|reg_save
argument_list|(
name|label
argument_list|,
name|DWARF_FRAME_REGNUM
argument_list|(
name|reg
argument_list|)
argument_list|,
name|INVALID_REGNUM
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point for saving the return address in the stack.    LABEL and OFFSET are passed to reg_save.  */
end_comment

begin_function
name|void
name|dwarf2out_return_save
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|reg_save
argument_list|(
name|label
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|,
name|INVALID_REGNUM
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point for saving the return address in a register.    LABEL and SREG are passed to reg_save.  */
end_comment

begin_function
name|void
name|dwarf2out_return_reg
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|unsigned
name|int
name|sreg
parameter_list|)
block|{
name|reg_save
argument_list|(
name|label
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|,
name|DWARF_FRAME_REGNUM
argument_list|(
name|sreg
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the initial position of the return address.  RTL is    INCOMING_RETURN_ADDR_RTX.  */
end_comment

begin_function
specifier|static
name|void
name|initial_return_save
parameter_list|(
name|rtx
name|rtl
parameter_list|)
block|{
name|unsigned
name|int
name|reg
init|=
name|INVALID_REGNUM
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
comment|/* RA is in a register.  */
name|reg
operator|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
comment|/* RA is on the stack.  */
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
comment|/* The return address is at some offset from any value we can 	 actually load.  For instance, on the SPARC it is in %i7+8. Just 	 ignore the offset for now; it doesn't matter for unwinding frames.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|initial_return_save
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reg
operator|!=
name|DWARF_FRAME_RETURN_COLUMN
condition|)
name|reg_save
argument_list|(
name|NULL
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|,
name|reg
argument_list|,
name|offset
operator|-
name|cfa
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a SET, calculate the amount of stack adjustment it    contains.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|stack_adjust_offset
parameter_list|(
name|rtx
name|pattern
parameter_list|)
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|stack_pointer_rtx
condition|)
block|{
comment|/* (set (reg sp) (plus (reg sp) (const_int))) */
name|code
operator|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|||
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|dest
argument_list|)
condition|)
block|{
comment|/* (set (mem (pre_dec (reg sp))) (foo)) */
name|src
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PRE_MODIFY
case|:
case|case
name|POST_MODIFY
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
name|rtx
name|val
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* We handle only adjustments by constant amount.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
case|case
name|PRE_DEC
case|:
case|case
name|POST_DEC
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
name|offset
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
case|case
name|PRE_INC
case|:
case|case
name|POST_INC
case|:
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
name|offset
operator|=
operator|-
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
else|else
return|return
literal|0
return|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Check INSN to see if it looks like a push or a stack adjustment, and    make a note of it if it does.  EH uses this information to find out how    much extra space it needs to pop off the stack.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_stack_adjust
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|bool
name|after_p
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Don't handle epilogues at all.  Certainly it would be wrong to do so      with this function.  Proper support would require all frame-related      insns to be marked, and to be able to handle saving state around      epilogues textually in the middle of the function.  */
if|if
condition|(
name|prologue_epilogue_contains
argument_list|(
name|insn
argument_list|)
operator|||
name|sibcall_epilogue_contains
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
comment|/* If only calls can throw, and we have a frame pointer,      save up adjustments until we see the CALL_INSN.  */
if|if
condition|(
operator|!
name|flag_asynchronous_unwind_tables
operator|&&
name|cfa
operator|.
name|reg
operator|!=
name|STACK_POINTER_REGNUM
condition|)
block|{
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|after_p
condition|)
block|{
comment|/* Extract the size of the args from the CALL rtx itself.  */
name|insn
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|PARALLEL
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|SET
condition|)
name|insn
operator|=
name|SET_SRC
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL
argument_list|)
expr_stmt|;
name|dwarf2out_args_size
argument_list|(
literal|""
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|CALL_P
argument_list|(
name|insn
argument_list|)
operator|&&
operator|!
name|after_p
condition|)
block|{
if|if
condition|(
operator|!
name|flag_asynchronous_unwind_tables
condition|)
name|dwarf2out_args_size
argument_list|(
literal|""
argument_list|,
name|args_size
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|BARRIER_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* When we see a BARRIER, we know to reset args_size to 0.  Usually 	 the compiler will have already emitted a stack adjustment, but 	 doesn't bother for calls to noreturn functions.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|offset
operator|=
operator|-
name|args_size
expr_stmt|;
else|#
directive|else
name|offset
operator|=
name|args_size
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|offset
operator|=
name|stack_adjust_offset
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* There may be stack adjustments inside compound insns.  Search 	 for them.  */
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|offset
operator|+=
name|stack_adjust_offset
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|cfa
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
endif|#
directive|endif
name|args_size
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|args_size
operator|<
literal|0
condition|)
name|args_size
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|dwarf2out_cfi_label
argument_list|()
expr_stmt|;
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|cfa
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_asynchronous_unwind_tables
condition|)
name|dwarf2out_args_size
argument_list|(
name|label
argument_list|,
name|args_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We delay emitting a register save until either (a) we reach the end    of the prologue or (b) the register is clobbered.  This clusters    register saves so that there are fewer pc advances.  */
end_comment

begin_decl_stmt
name|struct
name|queued_reg_save
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|queued_reg_save
modifier|*
name|next
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|HOST_WIDE_INT
name|cfa_offset
decl_stmt|;
name|rtx
name|saved_reg
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|queued_reg_save
operator|*
name|queued_reg_saves
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The caller's ORIG_REG is saved in SAVED_IN_REG.  */
end_comment

begin_decl_stmt
name|struct
name|reg_saved_in_data
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|rtx
name|orig_reg
decl_stmt|;
name|rtx
name|saved_in_reg
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* A list of registers saved in other registers.    The list intentionally has a small maximum capacity of 4; if your    port needs more than that, you might consider implementing a    more efficient data structure.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|reg_saved_in_data
name|regs_saved_in_regs
index|[
literal|4
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|size_t
name|num_regs_saved_in_regs
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|last_reg_save_label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add an entry to QUEUED_REG_SAVES saying that REG is now saved at    SREG, or if SREG is NULL then it is saved at OFFSET to the CFA.  */
end_comment

begin_function
specifier|static
name|void
name|queue_reg_save
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
name|sreg
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|struct
name|queued_reg_save
modifier|*
name|q
decl_stmt|;
comment|/* Duplicates waste space, but it's also necessary to remove them      for correctness, since the queue gets output in reverse      order.  */
for|for
control|(
name|q
operator|=
name|queued_reg_saves
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|q
operator|->
name|reg
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
break|break;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|q
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|next
operator|=
name|queued_reg_saves
expr_stmt|;
name|queued_reg_saves
operator|=
name|q
expr_stmt|;
block|}
name|q
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|q
operator|->
name|cfa_offset
operator|=
name|offset
expr_stmt|;
name|q
operator|->
name|saved_reg
operator|=
name|sreg
expr_stmt|;
name|last_reg_save_label
operator|=
name|label
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output all the entries in QUEUED_REG_SAVES.  */
end_comment

begin_function
specifier|static
name|void
name|flush_queued_reg_saves
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|queued_reg_save
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|queued_reg_saves
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
name|size_t
name|i
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|,
name|sreg
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_regs_saved_in_regs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|orig_reg
argument_list|)
operator|==
name|REGNO
argument_list|(
name|q
operator|->
name|reg
argument_list|)
condition|)
break|break;
if|if
condition|(
name|q
operator|->
name|saved_reg
operator|&&
name|i
operator|==
name|num_regs_saved_in_regs
condition|)
block|{
name|gcc_assert
argument_list|(
name|i
operator|!=
name|ARRAY_SIZE
argument_list|(
name|regs_saved_in_regs
argument_list|)
argument_list|)
expr_stmt|;
name|num_regs_saved_in_regs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|num_regs_saved_in_regs
condition|)
block|{
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|orig_reg
operator|=
name|q
operator|->
name|reg
expr_stmt|;
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|saved_in_reg
operator|=
name|q
operator|->
name|saved_reg
expr_stmt|;
block|}
name|reg
operator|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|q
operator|->
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|saved_reg
condition|)
name|sreg
operator|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|q
operator|->
name|saved_reg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sreg
operator|=
name|INVALID_REGNUM
expr_stmt|;
name|reg_save
argument_list|(
name|last_reg_save_label
argument_list|,
name|reg
argument_list|,
name|sreg
argument_list|,
name|q
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
block|}
name|queued_reg_saves
operator|=
name|NULL
expr_stmt|;
name|last_reg_save_label
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Does INSN clobber any register which QUEUED_REG_SAVES lists a saved    location for?  Or, does it clobber a register which we've previously    said that some other register is saved in, and for which we now    have a new location for?  */
end_comment

begin_function
specifier|static
name|bool
name|clobbers_queued_reg_save
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|struct
name|queued_reg_save
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|queued_reg_saves
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|modified_in_p
argument_list|(
name|q
operator|->
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_regs_saved_in_regs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|q
operator|->
name|reg
argument_list|)
operator|==
name|REGNO
argument_list|(
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|orig_reg
argument_list|)
operator|&&
name|modified_in_p
argument_list|(
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|saved_in_reg
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Entry point for saving the first register into the second.  */
end_comment

begin_function
name|void
name|dwarf2out_reg_save_reg
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
name|sreg
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|unsigned
name|int
name|regno
decl_stmt|,
name|sregno
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_regs_saved_in_regs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REGNO
argument_list|(
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|orig_reg
argument_list|)
operator|==
name|REGNO
argument_list|(
name|reg
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|num_regs_saved_in_regs
condition|)
block|{
name|gcc_assert
argument_list|(
name|i
operator|!=
name|ARRAY_SIZE
argument_list|(
name|regs_saved_in_regs
argument_list|)
argument_list|)
expr_stmt|;
name|num_regs_saved_in_regs
operator|++
expr_stmt|;
block|}
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|orig_reg
operator|=
name|reg
expr_stmt|;
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|saved_in_reg
operator|=
name|sreg
expr_stmt|;
name|regno
operator|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|sregno
operator|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|sreg
argument_list|)
argument_list|)
expr_stmt|;
name|reg_save
argument_list|(
name|label
argument_list|,
name|regno
argument_list|,
name|sregno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* What register, if any, is currently saved in REG?  */
end_comment

begin_function
specifier|static
name|rtx
name|reg_saved_in
parameter_list|(
name|rtx
name|reg
parameter_list|)
block|{
name|unsigned
name|int
name|regn
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|struct
name|queued_reg_save
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|queued_reg_saves
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|q
operator|->
name|saved_reg
operator|&&
name|regn
operator|==
name|REGNO
argument_list|(
name|q
operator|->
name|saved_reg
argument_list|)
condition|)
return|return
name|q
operator|->
name|reg
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_regs_saved_in_regs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|saved_in_reg
operator|&&
name|regn
operator|==
name|REGNO
argument_list|(
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|saved_in_reg
argument_list|)
condition|)
return|return
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|orig_reg
return|;
return|return
name|NULL_RTX
return|;
block|}
end_function

begin_comment
comment|/* A temporary register holding an integral value used in adjusting SP    or setting up the store_reg.  The "offset" field holds the integer    value, not an offset.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_cfa_location
name|cfa_temp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record call frame debugging information for an expression EXPR,    which either sets SP or FP (adjusting how we calculate the frame    address) or saves a register to the stack or another register.    LABEL indicates the address of EXPR.     This function encodes a state machine mapping rtxes to actions on    cfa, cfa_store, and cfa_temp.reg.  We describe these rules so    users need not read the source code.    The High-Level Picture    Changes in the register we use to calculate the CFA: Currently we   assume that if you copy the CFA register into another register, we   should take the other one as the new CFA register; this seems to   work pretty well.  If it's wrong for some target, it's simple   enough not to set RTX_FRAME_RELATED_P on the insn in question.    Changes in the register we use for saving registers to the stack:   This is usually SP, but not always.  Again, we deduce that if you   copy SP into another register (and SP is not the CFA register),   then the new register is the one we will be using for register   saves.  This also seems to work.    Register saves: There's not much guesswork about this one; if   RTX_FRAME_RELATED_P is set on an insn which modifies memory, it's a   register save, and the register used to calculate the destination   had better be the one we think we're using for this purpose.   It's also assumed that a copy from a call-saved register to another   register is saving that register if RTX_FRAME_RELATED_P is set on   that instruction.  If the copy is from a call-saved register to   the *same* register, that means that the register is now the same   value as in the caller.    Except: If the register being saved is the CFA register, and the   offset is nonzero, we are saving the CFA, so we assume we have to   use DW_CFA_def_cfa_expression.  If the offset is 0, we assume that   the intent is to save the value of SP from the previous frame.    In addition, if a register has previously been saved to a different   register,    Invariants / Summaries of Rules    cfa	       current rule for calculating the CFA.  It usually 	       consists of a register and an offset.   cfa_store    register used by prologue code to save things to the stack 	       cfa_store.offset is the offset from the value of 	       cfa_store.reg to the actual CFA   cfa_temp     register holding an integral value.  cfa_temp.offset 	       stores the value, which will be used to adjust the 	       stack pointer.  cfa_temp is also used like cfa_store, 	       to track stores to the stack via fp or a temp reg.    Rules  1- 4: Setting a register's value to cfa.reg or an expression 	       with cfa.reg as the first operand changes the cfa.reg and its 	       cfa.offset.  Rule 1 and 4 also set cfa_temp.reg and 	       cfa_temp.offset.    Rules  6- 9: Set a non-cfa.reg register value to a constant or an 	       expression yielding a constant.  This sets cfa_temp.reg 	       and cfa_temp.offset.    Rule 5:      Create a new register cfa_store used to save items to the 	       stack.    Rules 10-14: Save a register to the stack.  Define offset as the 	       difference of the original location and cfa_store's 	       location (or cfa_temp's location if cfa_temp is used).    The Rules    "{a,b}" indicates a choice of a xor b.   "<reg>:cfa.reg" indicates that<reg> must equal cfa.reg.    Rule 1:   (set<reg1><reg2>:cfa.reg)   effects: cfa.reg =<reg1> 	   cfa.offset unchanged 	   cfa_temp.reg =<reg1> 	   cfa_temp.offset = cfa.offset    Rule 2:   (set sp ({minus,plus,losum} {sp,fp}:cfa.reg 			      {<const_int>,<reg>:cfa_temp.reg}))   effects: cfa.reg = sp if fp used 	   cfa.offset += {+/-<const_int>, cfa_temp.offset} if cfa.reg==sp 	   cfa_store.offset += {+/-<const_int>, cfa_temp.offset} 	     if cfa_store.reg==sp    Rule 3:   (set fp ({minus,plus,losum}<reg>:cfa.reg<const_int>))   effects: cfa.reg = fp 	   cfa_offset += +/-<const_int>    Rule 4:   (set<reg1> ({plus,losum}<reg2>:cfa.reg<const_int>))   constraints:<reg1> != fp<reg1> != sp   effects: cfa.reg =<reg1> 	   cfa_temp.reg =<reg1> 	   cfa_temp.offset = cfa.offset    Rule 5:   (set<reg1> (plus<reg2>:cfa_temp.reg sp:cfa.reg))   constraints:<reg1> != fp<reg1> != sp   effects: cfa_store.reg =<reg1> 	   cfa_store.offset = cfa.offset - cfa_temp.offset    Rule 6:   (set<reg><const_int>)   effects: cfa_temp.reg =<reg> 	   cfa_temp.offset =<const_int>    Rule 7:   (set<reg1>:cfa_temp.reg (ior<reg2>:cfa_temp.reg<const_int>))   effects: cfa_temp.reg =<reg1> 	   cfa_temp.offset |=<const_int>    Rule 8:   (set<reg> (high<exp>))   effects: none    Rule 9:   (set<reg> (lo_sum<exp><const_int>))   effects: cfa_temp.reg =<reg> 	   cfa_temp.offset =<const_int>    Rule 10:   (set (mem (pre_modify sp:cfa_store (????<reg1><const_int>)))<reg2>)   effects: cfa_store.offset -=<const_int> 	   cfa.offset = cfa_store.offset if cfa.reg == sp 	   cfa.reg = sp 	   cfa.base_offset = -cfa_store.offset    Rule 11:   (set (mem ({pre_inc,pre_dec} sp:cfa_store.reg))<reg>)   effects: cfa_store.offset += -/+ mode_size(mem) 	   cfa.offset = cfa_store.offset if cfa.reg == sp 	   cfa.reg = sp 	   cfa.base_offset = -cfa_store.offset    Rule 12:   (set (mem ({minus,plus,losum}<reg1>:{cfa_store,cfa_temp}<const_int>))<reg2>)   effects: cfa.reg =<reg1> 	   cfa.base_offset = -/+<const_int> - {cfa_store,cfa_temp}.offset    Rule 13:   (set (mem<reg1>:{cfa_store,cfa_temp})<reg2>)   effects: cfa.reg =<reg1> 	   cfa.base_offset = -{cfa_store,cfa_temp}.offset    Rule 14:   (set (mem (postinc<reg1>:cfa_temp<const_int>))<reg2>)   effects: cfa.reg =<reg1> 	   cfa.base_offset = -cfa_temp.offset 	   cfa_temp.offset -= mode_size(mem)    Rule 15:   (set<reg> {unspec, unspec_volatile})   effects: target-dependent  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_frame_debug_expr
parameter_list|(
name|rtx
name|expr
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of      the PARALLEL independently. The first element is always processed if      it is a SET. This is for backward compatibility.   Other elements      are processed only if they are SETs and the RTX_FRAME_RELATED_P      flag is set in them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PARALLEL
operator|||
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|par_index
decl_stmt|;
name|int
name|limit
init|=
name|XVECLEN
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|par_index
operator|=
literal|0
init|;
name|par_index
operator|<
name|limit
condition|;
name|par_index
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|,
name|par_index
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|,
name|par_index
argument_list|)
argument_list|)
operator|||
name|par_index
operator|==
literal|0
operator|)
condition|)
name|dwarf2out_frame_debug_expr
argument_list|(
name|XVECEXP
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|,
name|par_index
argument_list|)
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SET
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|src
argument_list|)
condition|)
block|{
name|rtx
name|rsi
init|=
name|reg_saved_in
argument_list|(
name|src
argument_list|)
decl_stmt|;
if|if
condition|(
name|rsi
condition|)
name|src
operator|=
name|rsi
expr_stmt|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* Setting FP from SP.  */
case|case
name|REG
case|:
if|if
condition|(
name|cfa
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* Rule 1 */
comment|/* Update the CFA rule wrt SP or FP.  Make sure src is 		 relative to the current CFA register.  		 We used to require that dest be either SP or FP, but the 		 ARM copies SP to a temporary register, and from there to 		 FP.  So we just rely on the backends to only set 		 RTX_FRAME_RELATED_P on appropriate insns.  */
name|cfa
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_temp
operator|.
name|reg
operator|=
name|cfa
operator|.
name|reg
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|=
name|cfa
operator|.
name|offset
expr_stmt|;
block|}
else|else
block|{
comment|/* Saving a register in a register.  */
name|gcc_assert
argument_list|(
operator|!
name|fixed_regs
index|[
name|REGNO
argument_list|(
name|dest
argument_list|)
index|]
comment|/* For the SPARC and its register window.  */
operator|||
operator|(
name|DWARF_FRAME_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|)
operator|==
name|DWARF_FRAME_RETURN_COLUMN
operator|)
argument_list|)
expr_stmt|;
name|queue_reg_save
argument_list|(
name|label
argument_list|,
name|src
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|LO_SUM
case|:
if|if
condition|(
name|dest
operator|==
name|stack_pointer_rtx
condition|)
block|{
comment|/* Rule 2 */
comment|/* Adjusting SP.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
name|gcc_assert
argument_list|(
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|cfa_temp
operator|.
name|reg
argument_list|)
expr_stmt|;
name|offset
operator|=
name|cfa_temp
operator|.
name|offset
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|hard_frame_pointer_rtx
condition|)
block|{
comment|/* Restoring SP from FP in the epilogue.  */
name|gcc_assert
argument_list|(
name|cfa
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|cfa
operator|.
name|reg
operator|=
name|STACK_POINTER_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LO_SUM
condition|)
comment|/* Assume we've set the source reg of the LO_SUM from sp.  */
empty_stmt|;
else|else
name|gcc_assert
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MINUS
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|cfa
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|cfa_store
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa_store
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dest
operator|==
name|hard_frame_pointer_rtx
condition|)
block|{
comment|/* Rule 3 */
comment|/* Either setting the FP from an offset of the SP, 		 or adjusting the FP */
name|gcc_assert
argument_list|(
name|frame_pointer_needed
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|cfa
operator|.
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MINUS
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|cfa
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
name|cfa
operator|.
name|reg
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MINUS
argument_list|)
expr_stmt|;
comment|/* Rule 4 */
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|cfa
operator|.
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Setting a temporary CFA register that will be copied 		     into the FP later on.  */
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cfa
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
name|cfa
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* Or used to save regs to the stack.  */
name|cfa_temp
operator|.
name|reg
operator|=
name|cfa
operator|.
name|reg
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|=
name|cfa
operator|.
name|offset
expr_stmt|;
block|}
comment|/* Rule 5 */
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|cfa_temp
operator|.
name|reg
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
comment|/* Setting a scratch register that we will use instead 		     of SP for saving registers to the stack.  */
name|gcc_assert
argument_list|(
name|cfa
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|cfa_store
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_store
operator|.
name|offset
operator|=
name|cfa
operator|.
name|offset
operator|-
name|cfa_temp
operator|.
name|offset
expr_stmt|;
block|}
comment|/* Rule 9 */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|cfa_temp
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
break|break;
comment|/* Rule 6 */
case|case
name|CONST_INT
case|:
name|cfa_temp
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|src
argument_list|)
expr_stmt|;
break|break;
comment|/* Rule 7 */
case|case
name|IOR
case|:
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|cfa_temp
operator|.
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|!=
name|cfa_temp
operator|.
name|reg
condition|)
name|cfa_temp
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator||=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Skip over HIGH, assuming it will be followed by a LO_SUM, 	     which will fill in all of the bits.  */
comment|/* Rule 8 */
case|case
name|HIGH
case|:
break|break;
comment|/* Rule 15 */
case|case
name|UNSPEC
case|:
case|case
name|UNSPEC_VOLATILE
case|:
name|gcc_assert
argument_list|(
name|targetm
operator|.
name|dwarf_handle_frame_unspec
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|dwarf_handle_frame_unspec
argument_list|(
name|label
argument_list|,
name|expr
argument_list|,
name|XINT
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|cfa
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Saving a register to the stack.  Make sure dest is relative to the 	 CFA register.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Rule 10 */
comment|/* With a push.  */
case|case
name|PRE_MODIFY
case|:
comment|/* We can't handle variable size modifications.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|cfa_store
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|cfa_store
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|cfa
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa
operator|.
name|offset
operator|=
name|cfa_store
operator|.
name|offset
expr_stmt|;
name|offset
operator|=
operator|-
name|cfa_store
operator|.
name|offset
expr_stmt|;
break|break;
comment|/* Rule 11 */
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
name|offset
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|gcc_assert
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
operator|&&
name|cfa_store
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|cfa_store
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|cfa
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa
operator|.
name|offset
operator|=
name|cfa_store
operator|.
name|offset
expr_stmt|;
name|offset
operator|=
operator|-
name|cfa_store
operator|.
name|offset
expr_stmt|;
break|break;
comment|/* Rule 12 */
comment|/* With an offset.  */
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|LO_SUM
case|:
block|{
name|int
name|regno
decl_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfa_store
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|regno
condition|)
name|offset
operator|-=
name|cfa_store
operator|.
name|offset
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|cfa_temp
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|regno
argument_list|)
expr_stmt|;
name|offset
operator|-=
name|cfa_temp
operator|.
name|offset
expr_stmt|;
block|}
block|}
break|break;
comment|/* Rule 13 */
comment|/* Without an offset.  */
case|case
name|REG
case|:
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|cfa_store
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|regno
condition|)
name|offset
operator|=
operator|-
name|cfa_store
operator|.
name|offset
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|cfa_temp
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|regno
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
name|cfa_temp
operator|.
name|offset
expr_stmt|;
block|}
block|}
break|break;
comment|/* Rule 14 */
case|case
name|POST_INC
case|:
name|gcc_assert
argument_list|(
name|cfa_temp
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
name|cfa_temp
operator|.
name|offset
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|cfa
operator|.
name|reg
condition|)
block|{
comment|/* We're storing the current CFA reg into the stack.  */
if|if
condition|(
name|cfa
operator|.
name|offset
operator|==
literal|0
condition|)
block|{
comment|/* If the source register is exactly the CFA, assume 		 we're saving SP like any other register; this happens 		 on the ARM.  */
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|cfa
argument_list|)
expr_stmt|;
name|queue_reg_save
argument_list|(
name|label
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|NULL_RTX
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Otherwise, we'll need to look in the stack to 		 calculate the CFA.  */
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|REG_P
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|cfa
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|cfa
operator|.
name|base_offset
operator|=
name|offset
expr_stmt|;
name|cfa
operator|.
name|indirect
operator|=
literal|1
expr_stmt|;
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|cfa
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|cfa
argument_list|)
expr_stmt|;
name|queue_reg_save
argument_list|(
name|label
argument_list|,
name|src
argument_list|,
name|NULL_RTX
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record call frame debugging information for INSN, which either    sets SP or FP (adjusting how we calculate the frame address) or saves a    register to the stack.  If INSN is NULL_RTX, initialize our state.     If AFTER_P is false, we're being called before the insn is emitted,    otherwise after.  Call instructions get invoked twice.  */
end_comment

begin_function
name|void
name|dwarf2out_frame_debug
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|bool
name|after_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
condition|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* Flush any queued register saves.  */
name|flush_queued_reg_saves
argument_list|()
expr_stmt|;
comment|/* Set up state for generating call frame debug info.  */
name|lookup_cfa
argument_list|(
operator|&
name|cfa
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|cfa
operator|.
name|reg
operator|==
operator|(
name|unsigned
name|long
operator|)
name|DWARF_FRAME_REGNUM
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|cfa
operator|.
name|reg
operator|=
name|STACK_POINTER_REGNUM
expr_stmt|;
name|cfa_store
operator|=
name|cfa
expr_stmt|;
name|cfa_temp
operator|.
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_regs_saved_in_regs
condition|;
name|i
operator|++
control|)
block|{
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|orig_reg
operator|=
name|NULL_RTX
expr_stmt|;
name|regs_saved_in_regs
index|[
name|i
index|]
operator|.
name|saved_in_reg
operator|=
name|NULL_RTX
expr_stmt|;
block|}
name|num_regs_saved_in_regs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|NONJUMP_INSN_P
argument_list|(
name|insn
argument_list|)
operator|||
name|clobbers_queued_reg_save
argument_list|(
name|insn
argument_list|)
condition|)
name|flush_queued_reg_saves
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
condition|)
name|dwarf2out_stack_adjust
argument_list|(
name|insn
argument_list|,
name|after_p
argument_list|)
expr_stmt|;
return|return;
block|}
name|label
operator|=
name|dwarf2out_cfi_label
argument_list|()
expr_stmt|;
name|src
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dwarf2out_frame_debug_expr
argument_list|(
name|insn
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Describe for the GTY machinery what parts of dw_cfi_oprnd1 are used.  */
end_comment

begin_function_decl
specifier|static
name|enum
name|dw_cfi_oprnd_type
name|dw_cfi_oprnd1_desc
parameter_list|(
name|enum
name|dwarf_call_frame_info
name|cfi
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|enum
name|dw_cfi_oprnd_type
name|dw_cfi_oprnd1_desc
parameter_list|(
name|enum
name|dwarf_call_frame_info
name|cfi
parameter_list|)
block|{
switch|switch
condition|(
name|cfi
condition|)
block|{
case|case
name|DW_CFA_nop
case|:
case|case
name|DW_CFA_GNU_window_save
case|:
return|return
name|dw_cfi_oprnd_unused
return|;
case|case
name|DW_CFA_set_loc
case|:
case|case
name|DW_CFA_advance_loc1
case|:
case|case
name|DW_CFA_advance_loc2
case|:
case|case
name|DW_CFA_advance_loc4
case|:
case|case
name|DW_CFA_MIPS_advance_loc8
case|:
return|return
name|dw_cfi_oprnd_addr
return|;
case|case
name|DW_CFA_offset
case|:
case|case
name|DW_CFA_offset_extended
case|:
case|case
name|DW_CFA_def_cfa
case|:
case|case
name|DW_CFA_offset_extended_sf
case|:
case|case
name|DW_CFA_def_cfa_sf
case|:
case|case
name|DW_CFA_restore_extended
case|:
case|case
name|DW_CFA_undefined
case|:
case|case
name|DW_CFA_same_value
case|:
case|case
name|DW_CFA_def_cfa_register
case|:
case|case
name|DW_CFA_register
case|:
return|return
name|dw_cfi_oprnd_reg_num
return|;
case|case
name|DW_CFA_def_cfa_offset
case|:
case|case
name|DW_CFA_GNU_args_size
case|:
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
return|return
name|dw_cfi_oprnd_offset
return|;
case|case
name|DW_CFA_def_cfa_expression
case|:
case|case
name|DW_CFA_expression
case|:
return|return
name|dw_cfi_oprnd_loc
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Describe for the GTY machinery what parts of dw_cfi_oprnd2 are used.  */
end_comment

begin_function_decl
specifier|static
name|enum
name|dw_cfi_oprnd_type
name|dw_cfi_oprnd2_desc
parameter_list|(
name|enum
name|dwarf_call_frame_info
name|cfi
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|enum
name|dw_cfi_oprnd_type
name|dw_cfi_oprnd2_desc
parameter_list|(
name|enum
name|dwarf_call_frame_info
name|cfi
parameter_list|)
block|{
switch|switch
condition|(
name|cfi
condition|)
block|{
case|case
name|DW_CFA_def_cfa
case|:
case|case
name|DW_CFA_def_cfa_sf
case|:
case|case
name|DW_CFA_offset
case|:
case|case
name|DW_CFA_offset_extended_sf
case|:
case|case
name|DW_CFA_offset_extended
case|:
return|return
name|dw_cfi_oprnd_offset
return|;
case|case
name|DW_CFA_register
case|:
return|return
name|dw_cfi_oprnd_reg_num
return|;
default|default:
return|return
name|dw_cfi_oprnd_unused
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
end_if

begin_comment
comment|/* Switch to eh_frame_section.  If we don't have an eh_frame_section,    switch to the data section instead, and write out a synthetic label    for collect2.  */
end_comment

begin_function
specifier|static
name|void
name|switch_to_eh_frame_section
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|label
decl_stmt|;
ifdef|#
directive|ifdef
name|EH_FRAME_SECTION_NAME
if|if
condition|(
name|eh_frame_section
operator|==
literal|0
condition|)
block|{
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|EH_TABLES_CAN_BE_READ_ONLY
condition|)
block|{
name|int
name|fde_encoding
decl_stmt|;
name|int
name|per_encoding
decl_stmt|;
name|int
name|lsda_encoding
decl_stmt|;
name|fde_encoding
operator|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|1
argument_list|,
comment|/*global=*/
literal|0
argument_list|)
expr_stmt|;
name|per_encoding
operator|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|2
argument_list|,
comment|/*global=*/
literal|1
argument_list|)
expr_stmt|;
name|lsda_encoding
operator|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|0
argument_list|,
comment|/*global=*/
literal|0
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
operator|(
operator|!
name|flag_pic
operator|||
operator|(
operator|(
name|fde_encoding
operator|&
literal|0x70
operator|)
operator|!=
name|DW_EH_PE_absptr
operator|&&
operator|(
name|fde_encoding
operator|&
literal|0x70
operator|)
operator|!=
name|DW_EH_PE_aligned
operator|&&
operator|(
name|per_encoding
operator|&
literal|0x70
operator|)
operator|!=
name|DW_EH_PE_absptr
operator|&&
operator|(
name|per_encoding
operator|&
literal|0x70
operator|)
operator|!=
name|DW_EH_PE_aligned
operator|&&
operator|(
name|lsda_encoding
operator|&
literal|0x70
operator|)
operator|!=
name|DW_EH_PE_absptr
operator|&&
operator|(
name|lsda_encoding
operator|&
literal|0x70
operator|)
operator|!=
name|DW_EH_PE_aligned
operator|)
operator|)
condition|?
literal|0
else|:
name|SECTION_WRITE
operator|)
expr_stmt|;
block|}
else|else
name|flags
operator|=
name|SECTION_WRITE
expr_stmt|;
name|eh_frame_section
operator|=
name|get_section
argument_list|(
name|EH_FRAME_SECTION_NAME
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|eh_frame_section
condition|)
name|switch_to_section
argument_list|(
name|eh_frame_section
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We have no special eh_frame section.  Put the information in 	 the data section and emit special labels to guide collect2.  */
name|switch_to_section
argument_list|(
name|data_section
argument_list|)
expr_stmt|;
name|label
operator|=
name|get_file_function_name
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|PTR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a Call Frame Information opcode and its operand(s).  */
end_comment

begin_function
specifier|static
name|void
name|output_cfi
parameter_list|(
name|dw_cfi_ref
name|cfi
parameter_list|,
name|dw_fde_ref
name|fde
parameter_list|,
name|int
name|for_eh
parameter_list|)
block|{
name|unsigned
name|long
name|r
decl_stmt|;
if|if
condition|(
name|cfi
operator|->
name|dw_cfi_opc
operator|==
name|DW_CFA_advance_loc
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
operator|(
name|cfi
operator|->
name|dw_cfi_opc
operator||
operator|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
operator|&
literal|0x3f
operator|)
operator|)
argument_list|,
literal|"DW_CFA_advance_loc "
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cfi
operator|->
name|dw_cfi_opc
operator|==
name|DW_CFA_offset
condition|)
block|{
name|r
operator|=
name|DWARF2_FRAME_REG_OUT
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
operator|(
name|cfi
operator|->
name|dw_cfi_opc
operator||
operator|(
name|r
operator|&
literal|0x3f
operator|)
operator|)
argument_list|,
literal|"DW_CFA_offset, column 0x%lx"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfi
operator|->
name|dw_cfi_opc
operator|==
name|DW_CFA_restore
condition|)
block|{
name|r
operator|=
name|DWARF2_FRAME_REG_OUT
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
operator|(
name|cfi
operator|->
name|dw_cfi_opc
operator||
operator|(
name|r
operator|&
literal|0x3f
operator|)
operator|)
argument_list|,
literal|"DW_CFA_restore, column 0x%lx"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|cfi
operator|->
name|dw_cfi_opc
argument_list|,
literal|"%s"
argument_list|,
name|dwarf_cfi_name
argument_list|(
name|cfi
operator|->
name|dw_cfi_opc
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cfi
operator|->
name|dw_cfi_opc
condition|)
block|{
case|case
name|DW_CFA_set_loc
case|:
if|if
condition|(
name|for_eh
condition|)
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|1
argument_list|,
comment|/*global=*/
literal|0
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|)
argument_list|,
name|false
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
name|dw2_asm_output_delta
argument_list|(
literal|1
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
name|dw2_asm_output_delta
argument_list|(
literal|2
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
name|dw2_asm_output_delta
argument_list|(
literal|4
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_MIPS_advance_loc8
case|:
name|dw2_asm_output_delta
argument_list|(
literal|8
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended
case|:
case|case
name|DW_CFA_def_cfa
case|:
name|r
operator|=
name|DWARF2_FRAME_REG_OUT
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended_sf
case|:
case|case
name|DW_CFA_def_cfa_sf
case|:
name|r
operator|=
name|DWARF2_FRAME_REG_OUT
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_sleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
case|case
name|DW_CFA_undefined
case|:
case|case
name|DW_CFA_same_value
case|:
case|case
name|DW_CFA_def_cfa_register
case|:
name|r
operator|=
name|DWARF2_FRAME_REG_OUT
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_register
case|:
name|r
operator|=
name|DWARF2_FRAME_REG_OUT
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|r
operator|=
name|DWARF2_FRAME_REG_OUT
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_reg_num
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
case|case
name|DW_CFA_GNU_args_size
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
name|dw2_asm_output_data_sleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_window_save
case|:
break|break;
case|case
name|DW_CFA_def_cfa_expression
case|:
case|case
name|DW_CFA_expression
case|:
name|output_cfa_loc
argument_list|(
name|cfi
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
comment|/* Obsoleted by DW_CFA_offset_extended_sf.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output the call frame information used to record information    that relates to calculating the frame pointer, and records the    location of saved registers.  */
end_comment

begin_function
specifier|static
name|void
name|output_call_frame_info
parameter_list|(
name|int
name|for_eh
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|dw_fde_ref
name|fde
decl_stmt|;
name|dw_cfi_ref
name|cfi
decl_stmt|;
name|char
name|l1
index|[
literal|20
index|]
decl_stmt|,
name|l2
index|[
literal|20
index|]
decl_stmt|,
name|section_start_label
index|[
literal|20
index|]
decl_stmt|;
name|bool
name|any_lsda_needed
init|=
name|false
decl_stmt|;
name|char
name|augmentation
index|[
literal|6
index|]
decl_stmt|;
name|int
name|augmentation_size
decl_stmt|;
name|int
name|fde_encoding
init|=
name|DW_EH_PE_absptr
decl_stmt|;
name|int
name|per_encoding
init|=
name|DW_EH_PE_absptr
decl_stmt|;
name|int
name|lsda_encoding
init|=
name|DW_EH_PE_absptr
decl_stmt|;
name|int
name|return_reg
decl_stmt|;
comment|/* Don't emit a CIE if there won't be any FDEs.  */
if|if
condition|(
name|fde_table_in_use
operator|==
literal|0
condition|)
return|return;
comment|/* If we make FDEs linkonce, we may have to emit an empty label for      an FDE that wouldn't otherwise be emitted.  We want to avoid      having an FDE kept around when the function it refers to is      discarded.  Example where this matters: a primary function      template in C++ requires EH information, but an explicit      specialization doesn't.  */
if|if
condition|(
name|TARGET_USES_WEAK_UNWIND_INFO
operator|&&
operator|!
name|flag_asynchronous_unwind_tables
operator|&&
name|for_eh
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fde_table_in_use
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|fde_table
index|[
name|i
index|]
operator|.
name|nothrow
operator|||
name|fde_table
index|[
name|i
index|]
operator|.
name|all_throwers_are_sibcalls
operator|)
operator|&&
operator|!
name|fde_table
index|[
name|i
index|]
operator|.
name|uses_eh_lsda
operator|&&
operator|!
name|DECL_WEAK
argument_list|(
name|fde_table
index|[
name|i
index|]
operator|.
name|decl
argument_list|)
condition|)
name|targetm
operator|.
name|asm_out
operator|.
name|unwind_label
argument_list|(
name|asm_out_file
argument_list|,
name|fde_table
index|[
name|i
index|]
operator|.
name|decl
argument_list|,
name|for_eh
argument_list|,
comment|/* empty */
literal|1
argument_list|)
expr_stmt|;
comment|/* If we don't have any functions we'll want to unwind out of, don't      emit any EH unwind information.  Note that if exceptions aren't      enabled, we won't have collected nothrow information, and if we      asked for asynchronous tables, we always want this info.  */
if|if
condition|(
name|for_eh
condition|)
block|{
name|bool
name|any_eh_needed
init|=
operator|!
name|flag_exceptions
operator|||
name|flag_asynchronous_unwind_tables
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fde_table_in_use
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fde_table
index|[
name|i
index|]
operator|.
name|uses_eh_lsda
condition|)
name|any_eh_needed
operator|=
name|any_lsda_needed
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_USES_WEAK_UNWIND_INFO
operator|&&
name|DECL_WEAK
argument_list|(
name|fde_table
index|[
name|i
index|]
operator|.
name|decl
argument_list|)
condition|)
name|any_eh_needed
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|fde_table
index|[
name|i
index|]
operator|.
name|nothrow
operator|&&
operator|!
name|fde_table
index|[
name|i
index|]
operator|.
name|all_throwers_are_sibcalls
condition|)
name|any_eh_needed
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|any_eh_needed
condition|)
return|return;
block|}
comment|/* We're going to be generating comments, so turn on app.  */
if|if
condition|(
name|flag_debug_asm
condition|)
name|app_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
name|switch_to_eh_frame_section
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|debug_frame_section
condition|)
name|debug_frame_section
operator|=
name|get_section
argument_list|(
name|DEBUG_FRAME_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|debug_frame_section
argument_list|)
expr_stmt|;
block|}
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|section_start_label
argument_list|,
name|FRAME_BEGIN_LABEL
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|section_start_label
argument_list|)
expr_stmt|;
comment|/* Output the CIE.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
name|CIE_AFTER_SIZE_LABEL
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l2
argument_list|,
name|CIE_END_LABEL
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|DWARF_INITIAL_LENGTH_SIZE
operator|-
name|DWARF_OFFSET_SIZE
operator|==
literal|4
operator|&&
operator|!
name|for_eh
condition|)
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
literal|0xffffffff
argument_list|,
literal|"Initial length escape value indicating 64-bit DWARF extension"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|for_eh
condition|?
literal|4
else|:
name|DWARF_OFFSET_SIZE
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|,
literal|"Length of Common Information Entry"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l1
argument_list|)
expr_stmt|;
comment|/* Now that the CIE pointer is PC-relative for EH,      use 0 to identify the CIE.  */
name|dw2_asm_output_data
argument_list|(
operator|(
name|for_eh
condition|?
literal|4
else|:
name|DWARF_OFFSET_SIZE
operator|)
argument_list|,
operator|(
name|for_eh
condition|?
literal|0
else|:
name|DWARF_CIE_ID
operator|)
argument_list|,
literal|"CIE Identifier Tag"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_CIE_VERSION
argument_list|,
literal|"CIE Version"
argument_list|)
expr_stmt|;
name|augmentation
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|augmentation_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Augmentation: 	 z	Indicates that a uleb128 is present to size the 		augmentation section. 	 L	Indicates the encoding (and thus presence) of 		an LSDA pointer in the FDE augmentation. 	 R	Indicates a non-default pointer encoding for 		FDE code pointers. 	 P	Indicates the presence of an encoding + language 		personality routine in the CIE augmentation.  */
name|fde_encoding
operator|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|1
argument_list|,
comment|/*global=*/
literal|0
argument_list|)
expr_stmt|;
name|per_encoding
operator|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|2
argument_list|,
comment|/*global=*/
literal|1
argument_list|)
expr_stmt|;
name|lsda_encoding
operator|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|0
argument_list|,
comment|/*global=*/
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|augmentation
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|eh_personality_libfunc
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'P'
expr_stmt|;
name|augmentation_size
operator|+=
literal|1
operator|+
name|size_of_encoded_value
argument_list|(
name|per_encoding
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|any_lsda_needed
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
name|augmentation_size
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fde_encoding
operator|!=
name|DW_EH_PE_absptr
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'R'
expr_stmt|;
name|augmentation_size
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>
name|augmentation
operator|+
literal|1
condition|)
block|{
name|augmentation
index|[
literal|0
index|]
operator|=
literal|'z'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Ug.  Some platforms can't do unaligned dynamic relocations at all.  */
if|if
condition|(
name|eh_personality_libfunc
operator|&&
name|per_encoding
operator|==
name|DW_EH_PE_aligned
condition|)
block|{
name|int
name|offset
init|=
operator|(
literal|4
comment|/* Length */
operator|+
literal|4
comment|/* CIE Id */
operator|+
literal|1
comment|/* CIE version */
operator|+
name|strlen
argument_list|(
name|augmentation
argument_list|)
operator|+
literal|1
comment|/* Augmentation */
operator|+
name|size_of_uleb128
argument_list|(
literal|1
argument_list|)
comment|/* Code alignment */
operator|+
name|size_of_sleb128
argument_list|(
name|DWARF_CIE_DATA_ALIGNMENT
argument_list|)
operator|+
literal|1
comment|/* RA column */
operator|+
literal|1
comment|/* Augmentation size */
operator|+
literal|1
comment|/* Personality encoding */
operator|)
decl_stmt|;
name|int
name|pad
init|=
operator|-
name|offset
operator|&
operator|(
name|PTR_SIZE
operator|-
literal|1
operator|)
decl_stmt|;
name|augmentation_size
operator|+=
name|pad
expr_stmt|;
comment|/* Augmentations should be small, so there's scarce need to 	     iterate for a solution.  Die if we exceed one uleb128 byte.  */
name|gcc_assert
argument_list|(
name|size_of_uleb128
argument_list|(
name|augmentation_size
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|dw2_asm_output_nstring
argument_list|(
name|augmentation
argument_list|,
operator|-
literal|1
argument_list|,
literal|"CIE Augmentation"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
argument_list|,
literal|"CIE Code Alignment Factor"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_sleb128
argument_list|(
name|DWARF_CIE_DATA_ALIGNMENT
argument_list|,
literal|"CIE Data Alignment Factor"
argument_list|)
expr_stmt|;
name|return_reg
operator|=
name|DWARF2_FRAME_REG_OUT
argument_list|(
name|DWARF_FRAME_RETURN_COLUMN
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|DW_CIE_VERSION
operator|==
literal|1
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|return_reg
argument_list|,
literal|"CIE RA Column"
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_data_uleb128
argument_list|(
name|return_reg
argument_list|,
literal|"CIE RA Column"
argument_list|)
expr_stmt|;
if|if
condition|(
name|augmentation
index|[
literal|0
index|]
condition|)
block|{
name|dw2_asm_output_data_uleb128
argument_list|(
name|augmentation_size
argument_list|,
literal|"Augmentation size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_personality_libfunc
condition|)
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|per_encoding
argument_list|,
literal|"Personality (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|per_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|per_encoding
argument_list|,
name|eh_personality_libfunc
argument_list|,
name|true
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|any_lsda_needed
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|lsda_encoding
argument_list|,
literal|"LSDA Encoding (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|lsda_encoding
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde_encoding
operator|!=
name|DW_EH_PE_absptr
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|fde_encoding
argument_list|,
literal|"FDE Encoding (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|fde_encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cfi
operator|=
name|cie_cfi_head
init|;
name|cfi
operator|!=
name|NULL
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|output_cfi
argument_list|(
name|cfi
argument_list|,
name|NULL
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
comment|/* Pad the CIE out to an address sized boundary.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|for_eh
condition|?
name|PTR_SIZE
else|:
name|DWARF2_ADDR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|)
expr_stmt|;
comment|/* Loop through all of the FDE's.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fde_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|fde
operator|=
operator|&
name|fde_table
index|[
name|i
index|]
expr_stmt|;
comment|/* Don't emit EH unwind info for leaf functions that don't need it.  */
if|if
condition|(
name|for_eh
operator|&&
operator|!
name|flag_asynchronous_unwind_tables
operator|&&
name|flag_exceptions
operator|&&
operator|(
name|fde
operator|->
name|nothrow
operator|||
name|fde
operator|->
name|all_throwers_are_sibcalls
operator|)
operator|&&
operator|!
operator|(
name|TARGET_USES_WEAK_UNWIND_INFO
operator|&&
name|DECL_WEAK
argument_list|(
name|fde_table
index|[
name|i
index|]
operator|.
name|decl
argument_list|)
operator|)
operator|&&
operator|!
name|fde
operator|->
name|uses_eh_lsda
condition|)
continue|continue;
name|targetm
operator|.
name|asm_out
operator|.
name|unwind_label
argument_list|(
name|asm_out_file
argument_list|,
name|fde
operator|->
name|decl
argument_list|,
name|for_eh
argument_list|,
comment|/* empty */
literal|0
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
name|FDE_LABEL
argument_list|,
name|for_eh
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
name|FDE_AFTER_SIZE_LABEL
argument_list|,
name|for_eh
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l2
argument_list|,
name|FDE_END_LABEL
argument_list|,
name|for_eh
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|DWARF_INITIAL_LENGTH_SIZE
operator|-
name|DWARF_OFFSET_SIZE
operator|==
literal|4
operator|&&
operator|!
name|for_eh
condition|)
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
literal|0xffffffff
argument_list|,
literal|"Initial length escape value indicating 64-bit DWARF extension"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|for_eh
condition|?
literal|4
else|:
name|DWARF_OFFSET_SIZE
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|,
literal|"FDE Length"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
name|dw2_asm_output_delta
argument_list|(
literal|4
argument_list|,
name|l1
argument_list|,
name|section_start_label
argument_list|,
literal|"FDE CIE offset"
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|section_start_label
argument_list|,
name|debug_frame_section
argument_list|,
literal|"FDE CIE offset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
block|{
name|rtx
name|sym_ref
init|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|fde
operator|->
name|dw_fde_begin
argument_list|)
decl_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym_ref
argument_list|)
operator||=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|fde_encoding
argument_list|,
name|sym_ref
argument_list|,
name|false
argument_list|,
literal|"FDE initial location"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde
operator|->
name|dw_fde_switched_sections
condition|)
block|{
name|rtx
name|sym_ref2
init|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|fde
operator|->
name|dw_fde_unlikely_section_label
argument_list|)
decl_stmt|;
name|rtx
name|sym_ref3
init|=
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|fde
operator|->
name|dw_fde_hot_section_label
argument_list|)
decl_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym_ref2
argument_list|)
operator||=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|SYMBOL_REF_FLAGS
argument_list|(
name|sym_ref3
argument_list|)
operator||=
name|SYMBOL_FLAG_LOCAL
expr_stmt|;
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|fde_encoding
argument_list|,
name|sym_ref3
argument_list|,
name|false
argument_list|,
literal|"FDE initial location"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|size_of_encoded_value
argument_list|(
name|fde_encoding
argument_list|)
argument_list|,
name|fde
operator|->
name|dw_fde_hot_section_end_label
argument_list|,
name|fde
operator|->
name|dw_fde_hot_section_label
argument_list|,
literal|"FDE address range"
argument_list|)
expr_stmt|;
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|fde_encoding
argument_list|,
name|sym_ref2
argument_list|,
name|false
argument_list|,
literal|"FDE initial location"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|size_of_encoded_value
argument_list|(
name|fde_encoding
argument_list|)
argument_list|,
name|fde
operator|->
name|dw_fde_unlikely_section_end_label
argument_list|,
name|fde
operator|->
name|dw_fde_unlikely_section_label
argument_list|,
literal|"FDE address range"
argument_list|)
expr_stmt|;
block|}
else|else
name|dw2_asm_output_delta
argument_list|(
name|size_of_encoded_value
argument_list|(
name|fde_encoding
argument_list|)
argument_list|,
name|fde
operator|->
name|dw_fde_end
argument_list|,
name|fde
operator|->
name|dw_fde_begin
argument_list|,
literal|"FDE address range"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|fde
operator|->
name|dw_fde_begin
argument_list|,
literal|"FDE initial location"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde
operator|->
name|dw_fde_switched_sections
condition|)
block|{
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|fde
operator|->
name|dw_fde_hot_section_label
argument_list|,
literal|"FDE initial location"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|fde
operator|->
name|dw_fde_hot_section_end_label
argument_list|,
name|fde
operator|->
name|dw_fde_hot_section_label
argument_list|,
literal|"FDE address range"
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|fde
operator|->
name|dw_fde_unlikely_section_label
argument_list|,
literal|"FDE initial location"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|fde
operator|->
name|dw_fde_unlikely_section_end_label
argument_list|,
name|fde
operator|->
name|dw_fde_unlikely_section_label
argument_list|,
literal|"FDE address range"
argument_list|)
expr_stmt|;
block|}
else|else
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|fde
operator|->
name|dw_fde_end
argument_list|,
name|fde
operator|->
name|dw_fde_begin
argument_list|,
literal|"FDE address range"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|augmentation
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|any_lsda_needed
condition|)
block|{
name|int
name|size
init|=
name|size_of_encoded_value
argument_list|(
name|lsda_encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|lsda_encoding
operator|==
name|DW_EH_PE_aligned
condition|)
block|{
name|int
name|offset
init|=
operator|(
literal|4
comment|/* Length */
operator|+
literal|4
comment|/* CIE offset */
operator|+
literal|2
operator|*
name|size_of_encoded_value
argument_list|(
name|fde_encoding
argument_list|)
operator|+
literal|1
comment|/* Augmentation size */
operator|)
decl_stmt|;
name|int
name|pad
init|=
operator|-
name|offset
operator|&
operator|(
name|PTR_SIZE
operator|-
literal|1
operator|)
decl_stmt|;
name|size
operator|+=
name|pad
expr_stmt|;
name|gcc_assert
argument_list|(
name|size_of_uleb128
argument_list|(
name|size
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data_uleb128
argument_list|(
name|size
argument_list|,
literal|"Augmentation size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde
operator|->
name|uses_eh_lsda
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
literal|"LLSDA"
argument_list|,
name|fde
operator|->
name|funcdef_number
argument_list|)
expr_stmt|;
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|lsda_encoding
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|l1
argument_list|)
argument_list|,
name|false
argument_list|,
literal|"Language Specific Data Area"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lsda_encoding
operator|==
name|DW_EH_PE_aligned
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|PTR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|size_of_encoded_value
argument_list|(
name|lsda_encoding
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Language Specific Data Area (none)"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|dw2_asm_output_data_uleb128
argument_list|(
literal|0
argument_list|,
literal|"Augmentation size"
argument_list|)
expr_stmt|;
block|}
comment|/* Loop through the Call Frame Instructions associated with 	 this FDE.  */
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|fde
operator|->
name|dw_fde_begin
expr_stmt|;
for|for
control|(
name|cfi
operator|=
name|fde
operator|->
name|dw_fde_cfi
init|;
name|cfi
operator|!=
name|NULL
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|output_cfi
argument_list|(
name|cfi
argument_list|,
name|fde
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
comment|/* Pad the FDE out to an address sized boundary.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
operator|(
name|for_eh
condition|?
name|PTR_SIZE
else|:
name|DWARF2_ADDR_SIZE
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|for_eh
operator|&&
name|targetm
operator|.
name|terminate_dw2_eh_frame_info
condition|)
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"End of Table"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* Work around Irix 6 assembler bug whereby labels at the end of a section      get a value of 0.  Putting .align 0 after the label fixes it.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Turn off app to make assembly quicker.  */
if|if
condition|(
name|flag_debug_asm
condition|)
name|app_disable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the beginning of a function, before    the prologue.  */
end_comment

begin_function
name|void
name|dwarf2out_begin_prologue
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
modifier|*
name|dup_label
decl_stmt|;
name|dw_fde_ref
name|fde
decl_stmt|;
name|current_function_func_begin_label
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_UNWIND_INFO
comment|/* ??? current_function_func_begin_label is also used by except.c      for call-site information.  We must emit this label if it might      be used.  */
if|if
condition|(
operator|(
operator|!
name|flag_exceptions
operator|||
name|USING_SJLJ_EXCEPTIONS
operator|)
operator|&&
operator|!
name|dwarf2out_do_frame
argument_list|()
condition|)
return|return;
else|#
directive|else
if|if
condition|(
operator|!
name|dwarf2out_do_frame
argument_list|()
condition|)
return|return;
endif|#
directive|endif
name|switch_to_section
argument_list|(
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|FUNC_BEGIN_LABEL
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEBUG_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|FUNC_BEGIN_LABEL
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|dup_label
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|current_function_func_begin_label
operator|=
name|dup_label
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_UNWIND_INFO
comment|/* We can elide the fde allocation if we're not emitting debug info.  */
if|if
condition|(
operator|!
name|dwarf2out_do_frame
argument_list|()
condition|)
return|return;
endif|#
directive|endif
comment|/* Expand the fde table if necessary.  */
if|if
condition|(
name|fde_table_in_use
operator|==
name|fde_table_allocated
condition|)
block|{
name|fde_table_allocated
operator|+=
name|FDE_TABLE_INCREMENT
expr_stmt|;
name|fde_table
operator|=
name|ggc_realloc
argument_list|(
name|fde_table
argument_list|,
name|fde_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_fde_node
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fde_table
operator|+
name|fde_table_in_use
argument_list|,
literal|0
argument_list|,
name|FDE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_fde_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Record the FDE associated with this function.  */
name|current_funcdef_fde
operator|=
name|fde_table_in_use
expr_stmt|;
comment|/* Add the new FDE at the end of the fde_table.  */
name|fde
operator|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|++
index|]
expr_stmt|;
name|fde
operator|->
name|decl
operator|=
name|current_function_decl
expr_stmt|;
name|fde
operator|->
name|dw_fde_begin
operator|=
name|dup_label
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|dup_label
expr_stmt|;
name|fde
operator|->
name|dw_fde_hot_section_label
operator|=
name|NULL
expr_stmt|;
name|fde
operator|->
name|dw_fde_hot_section_end_label
operator|=
name|NULL
expr_stmt|;
name|fde
operator|->
name|dw_fde_unlikely_section_label
operator|=
name|NULL
expr_stmt|;
name|fde
operator|->
name|dw_fde_unlikely_section_end_label
operator|=
name|NULL
expr_stmt|;
name|fde
operator|->
name|dw_fde_switched_sections
operator|=
name|false
expr_stmt|;
name|fde
operator|->
name|dw_fde_end
operator|=
name|NULL
expr_stmt|;
name|fde
operator|->
name|dw_fde_cfi
operator|=
name|NULL
expr_stmt|;
name|fde
operator|->
name|funcdef_number
operator|=
name|current_function_funcdef_no
expr_stmt|;
name|fde
operator|->
name|nothrow
operator|=
name|TREE_NOTHROW
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|fde
operator|->
name|uses_eh_lsda
operator|=
name|cfun
operator|->
name|uses_eh_lsda
expr_stmt|;
name|fde
operator|->
name|all_throwers_are_sibcalls
operator|=
name|cfun
operator|->
name|all_throwers_are_sibcalls
expr_stmt|;
name|args_size
operator|=
name|old_args_size
operator|=
literal|0
expr_stmt|;
comment|/* We only want to output line number information for the genuine dwarf2      prologue case, not the eh frame case.  */
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|file
condition|)
name|dwarf2out_source_line
argument_list|(
name|line
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the absolute end of the generated code    for a function definition.  This gets called *after* the epilogue code has    been generated.  */
end_comment

begin_function
name|void
name|dwarf2out_end_epilogue
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|dw_fde_ref
name|fde
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* Output a label to mark the endpoint of the code generated for this      function.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fde
operator|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|-
literal|1
index|]
expr_stmt|;
name|fde
operator|->
name|dw_fde_end
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dwarf2out_frame_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Allocate the initial hunk of the fde_table.  */
name|fde_table
operator|=
name|ggc_alloc_cleared
argument_list|(
name|FDE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_fde_node
argument_list|)
argument_list|)
expr_stmt|;
name|fde_table_allocated
operator|=
name|FDE_TABLE_INCREMENT
expr_stmt|;
name|fde_table_in_use
operator|=
literal|0
expr_stmt|;
comment|/* Generate the CFA instructions common to all FDE's.  Do it now for the      sake of lookup_cfa.  */
comment|/* On entry, the Canonical Frame Address is at SP.  */
name|dwarf2out_def_cfa
argument_list|(
name|NULL
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|INCOMING_FRAME_SP_OFFSET
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
if|if
condition|(
name|DWARF2_UNWIND_INFO
condition|)
name|initial_return_save
argument_list|(
name|INCOMING_RETURN_ADDR_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|dwarf2out_frame_finish
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Output call frame information.  */
if|if
condition|(
name|DWARF2_FRAME_INFO
condition|)
name|output_call_frame_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TARGET_UNWIND_INFO
comment|/* Output another copy for the unwinder.  */
if|if
condition|(
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|&&
operator|(
name|flag_unwind_tables
operator|||
name|flag_exceptions
operator|)
condition|)
name|output_call_frame_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* And now, the subset of the debugging information support code necessary    for emitting location expressions.  */
end_comment

begin_comment
comment|/* Data about a single source file.  */
end_comment

begin_decl_stmt
name|struct
name|dwarf_file_data
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|emitted_number
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* We need some way to distinguish DW_OP_addr with a direct symbol    relocation from DW_OP_addr with a dtp-relative symbol relocation.  */
end_comment

begin_define
define|#
directive|define
name|INTERNAL_DW_OP_tls_addr
value|(0x100 + DW_OP_addr)
end_define

begin_typedef
typedef|typedef
name|struct
name|dw_val_struct
modifier|*
name|dw_val_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|die_struct
modifier|*
name|dw_die_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_loc_descr_struct
modifier|*
name|dw_loc_descr_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_loc_list_struct
modifier|*
name|dw_loc_list_ref
typedef|;
end_typedef

begin_comment
comment|/* Each DIE may have a series of attribute/value pairs.  Values    can take on several forms.  The forms that are used in this    implementation are listed below.  */
end_comment

begin_enum
enum|enum
name|dw_val_class
block|{
name|dw_val_class_addr
block|,
name|dw_val_class_offset
block|,
name|dw_val_class_loc
block|,
name|dw_val_class_loc_list
block|,
name|dw_val_class_range_list
block|,
name|dw_val_class_const
block|,
name|dw_val_class_unsigned_const
block|,
name|dw_val_class_long_long
block|,
name|dw_val_class_vec
block|,
name|dw_val_class_flag
block|,
name|dw_val_class_die_ref
block|,
name|dw_val_class_fde_ref
block|,
name|dw_val_class_lbl_id
block|,
name|dw_val_class_lineptr
block|,
name|dw_val_class_str
block|,
name|dw_val_class_macptr
block|,
name|dw_val_class_file
block|}
enum|;
end_enum

begin_comment
comment|/* Describe a double word constant value.  */
end_comment

begin_comment
comment|/* ??? Every instance of long_long in the code really means CONST_DOUBLE.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_long_long_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|unsigned
name|long
name|hi
block|;
name|unsigned
name|long
name|low
block|; }
end_typedef

begin_expr_stmt
name|dw_long_long_const
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Describe a floating point constant value, or a vector constant value.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_vec_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|unsigned
name|char
modifier|*
name|GTY
block|((
name|length
block|("%h.length"))
typedef|) array;
end_typedef

begin_decl_stmt
name|unsigned
name|length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|elt_size
decl_stmt|;
end_decl_stmt

begin_empty_stmt
unit|} dw_vec_const
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* The dw_val_node describes an attribute's value, as it is    represented internally.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_val_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|enum
name|dw_val_class
name|val_class
block|;
union|union
name|dw_val_struct_union
block|{
name|rtx
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_addr"
argument_list|)
operator|)
argument_list|)
name|val_addr
block|;
name|unsigned
name|HOST_WIDE_INT
name|GTY
block|((
name|tag
block|("dw_val_class_offset"))
block|)
name|val_offset
typedef|;
end_typedef

begin_decl_stmt
name|dw_loc_list_ref
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_loc_list"
argument_list|)
operator|)
argument_list|)
name|val_loc_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dw_loc_descr_ref
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_loc"
argument_list|)
operator|)
argument_list|)
name|val_loc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HOST_WIDE_INT
name|GTY
argument_list|(
operator|(
expr|default
operator|)
argument_list|)
name|val_int
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|HOST_WIDE_INT
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_unsigned_const"
argument_list|)
operator|)
argument_list|)
name|val_unsigned
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dw_long_long_const
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_long_long"
argument_list|)
operator|)
argument_list|)
name|val_long_long
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|dw_vec_const
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_vec"
argument_list|)
operator|)
argument_list|)
name|val_vec
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|dw_val_die_union
block|{
name|dw_die_ref
name|die
decl_stmt|;
name|int
name|external
decl_stmt|;
block|}
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_die_ref"
argument_list|)
operator|)
argument_list|)
name|val_die_ref
struct|;
end_struct

begin_decl_stmt
name|unsigned
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_fde_ref"
argument_list|)
operator|)
argument_list|)
name|val_fde_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|indirect_string_node
modifier|*
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_str"
argument_list|)
operator|)
argument_list|)
name|val_str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_lbl_id"
argument_list|)
operator|)
argument_list|)
name|val_lbl_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_flag"
argument_list|)
operator|)
argument_list|)
name|val_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dwarf_file_data
modifier|*
name|GTY
argument_list|(
operator|(
name|tag
argument_list|(
literal|"dw_val_class_file"
argument_list|)
operator|)
argument_list|)
name|val_file
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|}   GTY
operator|(
operator|(
name|desc
argument_list|(
literal|"%1.val_class"
argument_list|)
operator|)
operator|)
name|v
expr_stmt|;
end_expr_stmt

begin_empty_stmt
unit|} dw_val_node
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Locations in memory are described using a sequence of stack machine    operations.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_loc_descr_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|dw_loc_descr_ref
name|dw_loc_next
block|;
name|enum
name|dwarf_location_atom
name|dw_loc_opc
block|;
name|dw_val_node
name|dw_loc_oprnd1
block|;
name|dw_val_node
name|dw_loc_oprnd2
block|;
name|int
name|dw_loc_addr
block|; }
end_typedef

begin_expr_stmt
name|dw_loc_descr_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Location lists are ranges + location descriptions for that range,    so you can track variables that are in different places over    their entire life.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_loc_list_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|dw_loc_list_ref
name|dw_loc_next
block|;
specifier|const
name|char
modifier|*
name|begin
block|;
comment|/* Label for begin address of range */
specifier|const
name|char
modifier|*
name|end
block|;
comment|/* Label for end address of range */
name|char
modifier|*
name|ll_symbol
block|;
comment|/* Label for beginning of location list. 		      Only on head of list */
specifier|const
name|char
modifier|*
name|section
block|;
comment|/* Section this loclist is relative to */
name|dw_loc_descr_ref
name|expr
block|; }
end_typedef

begin_expr_stmt
name|dw_loc_list_node
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
end_if

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_stack_op_name
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_descr_ref
name|new_loc_descr
parameter_list|(
name|enum
name|dwarf_location_atom
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_loc_descr
parameter_list|(
name|dw_loc_descr_ref
modifier|*
parameter_list|,
name|dw_loc_descr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|size_of_loc_descr
parameter_list|(
name|dw_loc_descr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|size_of_locs
parameter_list|(
name|dw_loc_descr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_loc_operands
parameter_list|(
name|dw_loc_descr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_loc_sequence
parameter_list|(
name|dw_loc_descr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Convert a DWARF stack opcode into its string name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_stack_op_name
parameter_list|(
name|unsigned
name|int
name|op
parameter_list|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_addr
case|:
case|case
name|INTERNAL_DW_OP_tls_addr
case|:
return|return
literal|"DW_OP_addr"
return|;
case|case
name|DW_OP_deref
case|:
return|return
literal|"DW_OP_deref"
return|;
case|case
name|DW_OP_const1u
case|:
return|return
literal|"DW_OP_const1u"
return|;
case|case
name|DW_OP_const1s
case|:
return|return
literal|"DW_OP_const1s"
return|;
case|case
name|DW_OP_const2u
case|:
return|return
literal|"DW_OP_const2u"
return|;
case|case
name|DW_OP_const2s
case|:
return|return
literal|"DW_OP_const2s"
return|;
case|case
name|DW_OP_const4u
case|:
return|return
literal|"DW_OP_const4u"
return|;
case|case
name|DW_OP_const4s
case|:
return|return
literal|"DW_OP_const4s"
return|;
case|case
name|DW_OP_const8u
case|:
return|return
literal|"DW_OP_const8u"
return|;
case|case
name|DW_OP_const8s
case|:
return|return
literal|"DW_OP_const8s"
return|;
case|case
name|DW_OP_constu
case|:
return|return
literal|"DW_OP_constu"
return|;
case|case
name|DW_OP_consts
case|:
return|return
literal|"DW_OP_consts"
return|;
case|case
name|DW_OP_dup
case|:
return|return
literal|"DW_OP_dup"
return|;
case|case
name|DW_OP_drop
case|:
return|return
literal|"DW_OP_drop"
return|;
case|case
name|DW_OP_over
case|:
return|return
literal|"DW_OP_over"
return|;
case|case
name|DW_OP_pick
case|:
return|return
literal|"DW_OP_pick"
return|;
case|case
name|DW_OP_swap
case|:
return|return
literal|"DW_OP_swap"
return|;
case|case
name|DW_OP_rot
case|:
return|return
literal|"DW_OP_rot"
return|;
case|case
name|DW_OP_xderef
case|:
return|return
literal|"DW_OP_xderef"
return|;
case|case
name|DW_OP_abs
case|:
return|return
literal|"DW_OP_abs"
return|;
case|case
name|DW_OP_and
case|:
return|return
literal|"DW_OP_and"
return|;
case|case
name|DW_OP_div
case|:
return|return
literal|"DW_OP_div"
return|;
case|case
name|DW_OP_minus
case|:
return|return
literal|"DW_OP_minus"
return|;
case|case
name|DW_OP_mod
case|:
return|return
literal|"DW_OP_mod"
return|;
case|case
name|DW_OP_mul
case|:
return|return
literal|"DW_OP_mul"
return|;
case|case
name|DW_OP_neg
case|:
return|return
literal|"DW_OP_neg"
return|;
case|case
name|DW_OP_not
case|:
return|return
literal|"DW_OP_not"
return|;
case|case
name|DW_OP_or
case|:
return|return
literal|"DW_OP_or"
return|;
case|case
name|DW_OP_plus
case|:
return|return
literal|"DW_OP_plus"
return|;
case|case
name|DW_OP_plus_uconst
case|:
return|return
literal|"DW_OP_plus_uconst"
return|;
case|case
name|DW_OP_shl
case|:
return|return
literal|"DW_OP_shl"
return|;
case|case
name|DW_OP_shr
case|:
return|return
literal|"DW_OP_shr"
return|;
case|case
name|DW_OP_shra
case|:
return|return
literal|"DW_OP_shra"
return|;
case|case
name|DW_OP_xor
case|:
return|return
literal|"DW_OP_xor"
return|;
case|case
name|DW_OP_bra
case|:
return|return
literal|"DW_OP_bra"
return|;
case|case
name|DW_OP_eq
case|:
return|return
literal|"DW_OP_eq"
return|;
case|case
name|DW_OP_ge
case|:
return|return
literal|"DW_OP_ge"
return|;
case|case
name|DW_OP_gt
case|:
return|return
literal|"DW_OP_gt"
return|;
case|case
name|DW_OP_le
case|:
return|return
literal|"DW_OP_le"
return|;
case|case
name|DW_OP_lt
case|:
return|return
literal|"DW_OP_lt"
return|;
case|case
name|DW_OP_ne
case|:
return|return
literal|"DW_OP_ne"
return|;
case|case
name|DW_OP_skip
case|:
return|return
literal|"DW_OP_skip"
return|;
case|case
name|DW_OP_lit0
case|:
return|return
literal|"DW_OP_lit0"
return|;
case|case
name|DW_OP_lit1
case|:
return|return
literal|"DW_OP_lit1"
return|;
case|case
name|DW_OP_lit2
case|:
return|return
literal|"DW_OP_lit2"
return|;
case|case
name|DW_OP_lit3
case|:
return|return
literal|"DW_OP_lit3"
return|;
case|case
name|DW_OP_lit4
case|:
return|return
literal|"DW_OP_lit4"
return|;
case|case
name|DW_OP_lit5
case|:
return|return
literal|"DW_OP_lit5"
return|;
case|case
name|DW_OP_lit6
case|:
return|return
literal|"DW_OP_lit6"
return|;
case|case
name|DW_OP_lit7
case|:
return|return
literal|"DW_OP_lit7"
return|;
case|case
name|DW_OP_lit8
case|:
return|return
literal|"DW_OP_lit8"
return|;
case|case
name|DW_OP_lit9
case|:
return|return
literal|"DW_OP_lit9"
return|;
case|case
name|DW_OP_lit10
case|:
return|return
literal|"DW_OP_lit10"
return|;
case|case
name|DW_OP_lit11
case|:
return|return
literal|"DW_OP_lit11"
return|;
case|case
name|DW_OP_lit12
case|:
return|return
literal|"DW_OP_lit12"
return|;
case|case
name|DW_OP_lit13
case|:
return|return
literal|"DW_OP_lit13"
return|;
case|case
name|DW_OP_lit14
case|:
return|return
literal|"DW_OP_lit14"
return|;
case|case
name|DW_OP_lit15
case|:
return|return
literal|"DW_OP_lit15"
return|;
case|case
name|DW_OP_lit16
case|:
return|return
literal|"DW_OP_lit16"
return|;
case|case
name|DW_OP_lit17
case|:
return|return
literal|"DW_OP_lit17"
return|;
case|case
name|DW_OP_lit18
case|:
return|return
literal|"DW_OP_lit18"
return|;
case|case
name|DW_OP_lit19
case|:
return|return
literal|"DW_OP_lit19"
return|;
case|case
name|DW_OP_lit20
case|:
return|return
literal|"DW_OP_lit20"
return|;
case|case
name|DW_OP_lit21
case|:
return|return
literal|"DW_OP_lit21"
return|;
case|case
name|DW_OP_lit22
case|:
return|return
literal|"DW_OP_lit22"
return|;
case|case
name|DW_OP_lit23
case|:
return|return
literal|"DW_OP_lit23"
return|;
case|case
name|DW_OP_lit24
case|:
return|return
literal|"DW_OP_lit24"
return|;
case|case
name|DW_OP_lit25
case|:
return|return
literal|"DW_OP_lit25"
return|;
case|case
name|DW_OP_lit26
case|:
return|return
literal|"DW_OP_lit26"
return|;
case|case
name|DW_OP_lit27
case|:
return|return
literal|"DW_OP_lit27"
return|;
case|case
name|DW_OP_lit28
case|:
return|return
literal|"DW_OP_lit28"
return|;
case|case
name|DW_OP_lit29
case|:
return|return
literal|"DW_OP_lit29"
return|;
case|case
name|DW_OP_lit30
case|:
return|return
literal|"DW_OP_lit30"
return|;
case|case
name|DW_OP_lit31
case|:
return|return
literal|"DW_OP_lit31"
return|;
case|case
name|DW_OP_reg0
case|:
return|return
literal|"DW_OP_reg0"
return|;
case|case
name|DW_OP_reg1
case|:
return|return
literal|"DW_OP_reg1"
return|;
case|case
name|DW_OP_reg2
case|:
return|return
literal|"DW_OP_reg2"
return|;
case|case
name|DW_OP_reg3
case|:
return|return
literal|"DW_OP_reg3"
return|;
case|case
name|DW_OP_reg4
case|:
return|return
literal|"DW_OP_reg4"
return|;
case|case
name|DW_OP_reg5
case|:
return|return
literal|"DW_OP_reg5"
return|;
case|case
name|DW_OP_reg6
case|:
return|return
literal|"DW_OP_reg6"
return|;
case|case
name|DW_OP_reg7
case|:
return|return
literal|"DW_OP_reg7"
return|;
case|case
name|DW_OP_reg8
case|:
return|return
literal|"DW_OP_reg8"
return|;
case|case
name|DW_OP_reg9
case|:
return|return
literal|"DW_OP_reg9"
return|;
case|case
name|DW_OP_reg10
case|:
return|return
literal|"DW_OP_reg10"
return|;
case|case
name|DW_OP_reg11
case|:
return|return
literal|"DW_OP_reg11"
return|;
case|case
name|DW_OP_reg12
case|:
return|return
literal|"DW_OP_reg12"
return|;
case|case
name|DW_OP_reg13
case|:
return|return
literal|"DW_OP_reg13"
return|;
case|case
name|DW_OP_reg14
case|:
return|return
literal|"DW_OP_reg14"
return|;
case|case
name|DW_OP_reg15
case|:
return|return
literal|"DW_OP_reg15"
return|;
case|case
name|DW_OP_reg16
case|:
return|return
literal|"DW_OP_reg16"
return|;
case|case
name|DW_OP_reg17
case|:
return|return
literal|"DW_OP_reg17"
return|;
case|case
name|DW_OP_reg18
case|:
return|return
literal|"DW_OP_reg18"
return|;
case|case
name|DW_OP_reg19
case|:
return|return
literal|"DW_OP_reg19"
return|;
case|case
name|DW_OP_reg20
case|:
return|return
literal|"DW_OP_reg20"
return|;
case|case
name|DW_OP_reg21
case|:
return|return
literal|"DW_OP_reg21"
return|;
case|case
name|DW_OP_reg22
case|:
return|return
literal|"DW_OP_reg22"
return|;
case|case
name|DW_OP_reg23
case|:
return|return
literal|"DW_OP_reg23"
return|;
case|case
name|DW_OP_reg24
case|:
return|return
literal|"DW_OP_reg24"
return|;
case|case
name|DW_OP_reg25
case|:
return|return
literal|"DW_OP_reg25"
return|;
case|case
name|DW_OP_reg26
case|:
return|return
literal|"DW_OP_reg26"
return|;
case|case
name|DW_OP_reg27
case|:
return|return
literal|"DW_OP_reg27"
return|;
case|case
name|DW_OP_reg28
case|:
return|return
literal|"DW_OP_reg28"
return|;
case|case
name|DW_OP_reg29
case|:
return|return
literal|"DW_OP_reg29"
return|;
case|case
name|DW_OP_reg30
case|:
return|return
literal|"DW_OP_reg30"
return|;
case|case
name|DW_OP_reg31
case|:
return|return
literal|"DW_OP_reg31"
return|;
case|case
name|DW_OP_breg0
case|:
return|return
literal|"DW_OP_breg0"
return|;
case|case
name|DW_OP_breg1
case|:
return|return
literal|"DW_OP_breg1"
return|;
case|case
name|DW_OP_breg2
case|:
return|return
literal|"DW_OP_breg2"
return|;
case|case
name|DW_OP_breg3
case|:
return|return
literal|"DW_OP_breg3"
return|;
case|case
name|DW_OP_breg4
case|:
return|return
literal|"DW_OP_breg4"
return|;
case|case
name|DW_OP_breg5
case|:
return|return
literal|"DW_OP_breg5"
return|;
case|case
name|DW_OP_breg6
case|:
return|return
literal|"DW_OP_breg6"
return|;
case|case
name|DW_OP_breg7
case|:
return|return
literal|"DW_OP_breg7"
return|;
case|case
name|DW_OP_breg8
case|:
return|return
literal|"DW_OP_breg8"
return|;
case|case
name|DW_OP_breg9
case|:
return|return
literal|"DW_OP_breg9"
return|;
case|case
name|DW_OP_breg10
case|:
return|return
literal|"DW_OP_breg10"
return|;
case|case
name|DW_OP_breg11
case|:
return|return
literal|"DW_OP_breg11"
return|;
case|case
name|DW_OP_breg12
case|:
return|return
literal|"DW_OP_breg12"
return|;
case|case
name|DW_OP_breg13
case|:
return|return
literal|"DW_OP_breg13"
return|;
case|case
name|DW_OP_breg14
case|:
return|return
literal|"DW_OP_breg14"
return|;
case|case
name|DW_OP_breg15
case|:
return|return
literal|"DW_OP_breg15"
return|;
case|case
name|DW_OP_breg16
case|:
return|return
literal|"DW_OP_breg16"
return|;
case|case
name|DW_OP_breg17
case|:
return|return
literal|"DW_OP_breg17"
return|;
case|case
name|DW_OP_breg18
case|:
return|return
literal|"DW_OP_breg18"
return|;
case|case
name|DW_OP_breg19
case|:
return|return
literal|"DW_OP_breg19"
return|;
case|case
name|DW_OP_breg20
case|:
return|return
literal|"DW_OP_breg20"
return|;
case|case
name|DW_OP_breg21
case|:
return|return
literal|"DW_OP_breg21"
return|;
case|case
name|DW_OP_breg22
case|:
return|return
literal|"DW_OP_breg22"
return|;
case|case
name|DW_OP_breg23
case|:
return|return
literal|"DW_OP_breg23"
return|;
case|case
name|DW_OP_breg24
case|:
return|return
literal|"DW_OP_breg24"
return|;
case|case
name|DW_OP_breg25
case|:
return|return
literal|"DW_OP_breg25"
return|;
case|case
name|DW_OP_breg26
case|:
return|return
literal|"DW_OP_breg26"
return|;
case|case
name|DW_OP_breg27
case|:
return|return
literal|"DW_OP_breg27"
return|;
case|case
name|DW_OP_breg28
case|:
return|return
literal|"DW_OP_breg28"
return|;
case|case
name|DW_OP_breg29
case|:
return|return
literal|"DW_OP_breg29"
return|;
case|case
name|DW_OP_breg30
case|:
return|return
literal|"DW_OP_breg30"
return|;
case|case
name|DW_OP_breg31
case|:
return|return
literal|"DW_OP_breg31"
return|;
case|case
name|DW_OP_regx
case|:
return|return
literal|"DW_OP_regx"
return|;
case|case
name|DW_OP_fbreg
case|:
return|return
literal|"DW_OP_fbreg"
return|;
case|case
name|DW_OP_bregx
case|:
return|return
literal|"DW_OP_bregx"
return|;
case|case
name|DW_OP_piece
case|:
return|return
literal|"DW_OP_piece"
return|;
case|case
name|DW_OP_deref_size
case|:
return|return
literal|"DW_OP_deref_size"
return|;
case|case
name|DW_OP_xderef_size
case|:
return|return
literal|"DW_OP_xderef_size"
return|;
case|case
name|DW_OP_nop
case|:
return|return
literal|"DW_OP_nop"
return|;
case|case
name|DW_OP_push_object_address
case|:
return|return
literal|"DW_OP_push_object_address"
return|;
case|case
name|DW_OP_call2
case|:
return|return
literal|"DW_OP_call2"
return|;
case|case
name|DW_OP_call4
case|:
return|return
literal|"DW_OP_call4"
return|;
case|case
name|DW_OP_call_ref
case|:
return|return
literal|"DW_OP_call_ref"
return|;
case|case
name|DW_OP_GNU_push_tls_address
case|:
return|return
literal|"DW_OP_GNU_push_tls_address"
return|;
default|default:
return|return
literal|"OP_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to a newly allocated location description.  Location    descriptions are simple expression terms that can be strung    together to form more complicated location (address) descriptions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_loc_descr_ref
name|new_loc_descr
parameter_list|(
name|enum
name|dwarf_location_atom
name|op
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|oprnd1
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|oprnd2
parameter_list|)
block|{
name|dw_loc_descr_ref
name|descr
init|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_loc_descr_node
argument_list|)
argument_list|)
decl_stmt|;
name|descr
operator|->
name|dw_loc_opc
operator|=
name|op
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_unsigned_const
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
operator|=
name|oprnd1
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd2
operator|.
name|val_class
operator|=
name|dw_val_class_unsigned_const
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd2
operator|.
name|v
operator|.
name|val_unsigned
operator|=
name|oprnd2
expr_stmt|;
return|return
name|descr
return|;
block|}
end_function

begin_comment
comment|/* Add a location description term to a location description expression.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_loc_descr
parameter_list|(
name|dw_loc_descr_ref
modifier|*
name|list_head
parameter_list|,
name|dw_loc_descr_ref
name|descr
parameter_list|)
block|{
name|dw_loc_descr_ref
modifier|*
name|d
decl_stmt|;
comment|/* Find the end of the chain.  */
for|for
control|(
name|d
operator|=
name|list_head
init|;
operator|(
operator|*
name|d
operator|)
operator|!=
name|NULL
condition|;
name|d
operator|=
operator|&
operator|(
operator|*
name|d
operator|)
operator|->
name|dw_loc_next
control|)
empty_stmt|;
operator|*
name|d
operator|=
name|descr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the size of a location descriptor.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_loc_descr
parameter_list|(
name|dw_loc_descr_ref
name|loc
parameter_list|)
block|{
name|unsigned
name|long
name|size
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|loc
operator|->
name|dw_loc_opc
condition|)
block|{
case|case
name|DW_OP_addr
case|:
case|case
name|INTERNAL_DW_OP_tls_addr
case|:
name|size
operator|+=
name|DWARF2_ADDR_SIZE
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
case|case
name|DW_OP_const1s
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
case|case
name|DW_OP_const2s
case|:
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
case|case
name|DW_OP_const4s
case|:
name|size
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
case|case
name|DW_OP_const8s
case|:
name|size
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_pick
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_skip
case|:
case|case
name|DW_OP_bra
case|:
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_fbreg
case|:
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd2
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_piece
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_deref_size
case|:
case|case
name|DW_OP_xderef_size
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_call2
case|:
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_call4
case|:
name|size
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_call_ref
case|:
name|size
operator|+=
name|DWARF2_ADDR_SIZE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a series of location descriptors.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_locs
parameter_list|(
name|dw_loc_descr_ref
name|loc
parameter_list|)
block|{
name|dw_loc_descr_ref
name|l
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* If there are no skip or bra opcodes, don't fill in the dw_loc_addr      field, to avoid writing to a PCH file.  */
for|for
control|(
name|size
operator|=
literal|0
operator|,
name|l
operator|=
name|loc
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|dw_loc_next
control|)
block|{
if|if
condition|(
name|l
operator|->
name|dw_loc_opc
operator|==
name|DW_OP_skip
operator|||
name|l
operator|->
name|dw_loc_opc
operator|==
name|DW_OP_bra
condition|)
break|break;
name|size
operator|+=
name|size_of_loc_descr
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|l
condition|)
return|return
name|size
return|;
for|for
control|(
name|size
operator|=
literal|0
operator|,
name|l
operator|=
name|loc
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|dw_loc_next
control|)
block|{
name|l
operator|->
name|dw_loc_addr
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|size_of_loc_descr
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Output location description stack opcode's operands (if any).  */
end_comment

begin_function
specifier|static
name|void
name|output_loc_operands
parameter_list|(
name|dw_loc_descr_ref
name|loc
parameter_list|)
block|{
name|dw_val_ref
name|val1
init|=
operator|&
name|loc
operator|->
name|dw_loc_oprnd1
decl_stmt|;
name|dw_val_ref
name|val2
init|=
operator|&
name|loc
operator|->
name|dw_loc_oprnd2
decl_stmt|;
switch|switch
condition|(
name|loc
operator|->
name|dw_loc_opc
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
case|case
name|DW_OP_addr
case|:
name|dw2_asm_output_addr_rtx
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
case|case
name|DW_OP_const2s
case|:
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
case|case
name|DW_OP_const4s
case|:
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
case|case
name|DW_OP_const8s
case|:
name|gcc_assert
argument_list|(
name|HOST_BITS_PER_LONG
operator|>=
literal|64
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|8
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_skip
case|:
case|case
name|DW_OP_bra
case|:
block|{
name|int
name|offset
decl_stmt|;
name|gcc_assert
argument_list|(
name|val1
operator|->
name|val_class
operator|==
name|dw_val_class_loc
argument_list|)
expr_stmt|;
name|offset
operator|=
name|val1
operator|->
name|v
operator|.
name|val_loc
operator|->
name|dw_loc_addr
operator|-
operator|(
name|loc
operator|->
name|dw_loc_addr
operator|+
literal|3
operator|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
else|#
directive|else
case|case
name|DW_OP_addr
case|:
case|case
name|DW_OP_const2u
case|:
case|case
name|DW_OP_const2s
case|:
case|case
name|DW_OP_const4u
case|:
case|case
name|DW_OP_const4s
case|:
case|case
name|DW_OP_const8u
case|:
case|case
name|DW_OP_const8s
case|:
case|case
name|DW_OP_skip
case|:
case|case
name|DW_OP_bra
case|:
comment|/* We currently don't make any attempt to make sure these are 	 aligned properly like we do for the main unwind info, so 	 don't support emitting things larger than a byte if we're 	 only doing unwinding.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
endif|#
directive|endif
case|case
name|DW_OP_const1u
case|:
case|case
name|DW_OP_const1s
case|:
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|dw2_asm_output_data_sleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_pick
case|:
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|dw2_asm_output_data_sleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_fbreg
case|:
name|dw2_asm_output_data_sleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_sleb128
argument_list|(
name|val2
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_piece
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_deref_size
case|:
case|case
name|DW_OP_xderef_size
case|:
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTERNAL_DW_OP_tls_addr
case|:
if|if
condition|(
name|targetm
operator|.
name|asm_out
operator|.
name|output_dwarf_dtprel
condition|)
block|{
name|targetm
operator|.
name|asm_out
operator|.
name|output_dwarf_dtprel
argument_list|(
name|asm_out_file
argument_list|,
name|DWARF2_ADDR_SIZE
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_addr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
default|default:
comment|/* Other codes have no operands.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Output a sequence of location operations.  */
end_comment

begin_function
specifier|static
name|void
name|output_loc_sequence
parameter_list|(
name|dw_loc_descr_ref
name|loc
parameter_list|)
block|{
for|for
control|(
init|;
name|loc
operator|!=
name|NULL
condition|;
name|loc
operator|=
name|loc
operator|->
name|dw_loc_next
control|)
block|{
comment|/* Output the opcode.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|loc
operator|->
name|dw_loc_opc
argument_list|,
literal|"%s"
argument_list|,
name|dwarf_stack_op_name
argument_list|(
name|loc
operator|->
name|dw_loc_opc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the operand(s) (if any).  */
name|output_loc_operands
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine will generate the correct assembly data for a location    description based on a cfi entry with a complex address.  */
end_comment

begin_function
specifier|static
name|void
name|output_cfa_loc
parameter_list|(
name|dw_cfi_ref
name|cfi
parameter_list|)
block|{
name|dw_loc_descr_ref
name|loc
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* Output the size of the block.  */
name|loc
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_loc
expr_stmt|;
name|size
operator|=
name|size_of_locs
argument_list|(
name|loc
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now output the operations themselves.  */
name|output_loc_sequence
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function builds a dwarf location descriptor sequence from a    dw_cfa_location, adding the given OFFSET to the result of the    expression.  */
end_comment

begin_function
specifier|static
name|struct
name|dw_loc_descr_struct
modifier|*
name|build_cfa_loc
parameter_list|(
name|dw_cfa_location
modifier|*
name|cfa
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|struct
name|dw_loc_descr_struct
modifier|*
name|head
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|offset
operator|+=
name|cfa
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|cfa
operator|->
name|indirect
condition|)
block|{
if|if
condition|(
name|cfa
operator|->
name|base_offset
condition|)
block|{
if|if
condition|(
name|cfa
operator|->
name|reg
operator|<=
literal|31
condition|)
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_breg0
operator|+
name|cfa
operator|->
name|reg
argument_list|,
name|cfa
operator|->
name|base_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_bregx
argument_list|,
name|cfa
operator|->
name|reg
argument_list|,
name|cfa
operator|->
name|base_offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfa
operator|->
name|reg
operator|<=
literal|31
condition|)
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_reg0
operator|+
name|cfa
operator|->
name|reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_regx
argument_list|,
name|cfa
operator|->
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|head
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_const
expr_stmt|;
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_deref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|head
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_plus_uconst
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|head
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
if|if
condition|(
name|cfa
operator|->
name|reg
operator|<=
literal|31
condition|)
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_reg0
operator|+
name|cfa
operator|->
name|reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_regx
argument_list|,
name|cfa
operator|->
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cfa
operator|->
name|reg
operator|<=
literal|31
condition|)
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_breg0
operator|+
name|cfa
operator|->
name|reg
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_bregx
argument_list|,
name|cfa
operator|->
name|reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* This function fills in aa dw_cfa_location structure from a dwarf location    descriptor sequence.  */
end_comment

begin_function
specifier|static
name|void
name|get_cfa_from_loc_descr
parameter_list|(
name|dw_cfa_location
modifier|*
name|cfa
parameter_list|,
name|struct
name|dw_loc_descr_struct
modifier|*
name|loc
parameter_list|)
block|{
name|struct
name|dw_loc_descr_struct
modifier|*
name|ptr
decl_stmt|;
name|cfa
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|cfa
operator|->
name|base_offset
operator|=
literal|0
expr_stmt|;
name|cfa
operator|->
name|indirect
operator|=
literal|0
expr_stmt|;
name|cfa
operator|->
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|loc
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|dw_loc_next
control|)
block|{
name|enum
name|dwarf_location_atom
name|op
init|=
name|ptr
operator|->
name|dw_loc_opc
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_reg0
case|:
case|case
name|DW_OP_reg1
case|:
case|case
name|DW_OP_reg2
case|:
case|case
name|DW_OP_reg3
case|:
case|case
name|DW_OP_reg4
case|:
case|case
name|DW_OP_reg5
case|:
case|case
name|DW_OP_reg6
case|:
case|case
name|DW_OP_reg7
case|:
case|case
name|DW_OP_reg8
case|:
case|case
name|DW_OP_reg9
case|:
case|case
name|DW_OP_reg10
case|:
case|case
name|DW_OP_reg11
case|:
case|case
name|DW_OP_reg12
case|:
case|case
name|DW_OP_reg13
case|:
case|case
name|DW_OP_reg14
case|:
case|case
name|DW_OP_reg15
case|:
case|case
name|DW_OP_reg16
case|:
case|case
name|DW_OP_reg17
case|:
case|case
name|DW_OP_reg18
case|:
case|case
name|DW_OP_reg19
case|:
case|case
name|DW_OP_reg20
case|:
case|case
name|DW_OP_reg21
case|:
case|case
name|DW_OP_reg22
case|:
case|case
name|DW_OP_reg23
case|:
case|case
name|DW_OP_reg24
case|:
case|case
name|DW_OP_reg25
case|:
case|case
name|DW_OP_reg26
case|:
case|case
name|DW_OP_reg27
case|:
case|case
name|DW_OP_reg28
case|:
case|case
name|DW_OP_reg29
case|:
case|case
name|DW_OP_reg30
case|:
case|case
name|DW_OP_reg31
case|:
name|cfa
operator|->
name|reg
operator|=
name|op
operator|-
name|DW_OP_reg0
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|cfa
operator|->
name|reg
operator|=
name|ptr
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|cfa
operator|->
name|reg
operator|=
name|op
operator|-
name|DW_OP_breg0
expr_stmt|;
name|cfa
operator|->
name|base_offset
operator|=
name|ptr
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|cfa
operator|->
name|reg
operator|=
name|ptr
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
expr_stmt|;
name|cfa
operator|->
name|base_offset
operator|=
name|ptr
operator|->
name|dw_loc_oprnd2
operator|.
name|v
operator|.
name|val_int
expr_stmt|;
break|break;
case|case
name|DW_OP_deref
case|:
name|cfa
operator|->
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|cfa
operator|->
name|offset
operator|=
name|ptr
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
literal|"DW_LOC_OP %s not implemented"
argument_list|,
name|dwarf_stack_op_name
argument_list|(
name|ptr
operator|->
name|dw_loc_opc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* .debug_frame support */
end_comment

begin_escape
end_escape

begin_comment
comment|/* And now, the support for symbolic debugging information.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
end_ifdef

begin_comment
comment|/* .debug_str support.  */
end_comment

begin_function_decl
specifier|static
name|int
name|output_indirect_string
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_init
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_finish
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_define
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_undef
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_start_source_file
parameter_list|(
name|unsigned
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_end_source_file
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_begin_block
parameter_list|(
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_end_block
parameter_list|(
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|dwarf2out_ignore_block
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_global_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_type_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_imported_module_or_decl
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_abstract_function
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_var_location
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_begin_function
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dwarf2out_switch_text_section
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The debug hooks structure.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|gcc_debug_hooks
name|dwarf2_debug_hooks
init|=
block|{
name|dwarf2out_init
block|,
name|dwarf2out_finish
block|,
name|dwarf2out_define
block|,
name|dwarf2out_undef
block|,
name|dwarf2out_start_source_file
block|,
name|dwarf2out_end_source_file
block|,
name|dwarf2out_begin_block
block|,
name|dwarf2out_end_block
block|,
name|dwarf2out_ignore_block
block|,
name|dwarf2out_source_line
block|,
name|dwarf2out_begin_prologue
block|,
name|debug_nothing_int_charstar
block|,
comment|/* end_prologue */
name|dwarf2out_end_epilogue
block|,
name|dwarf2out_begin_function
block|,
name|debug_nothing_int
block|,
comment|/* end_function */
name|dwarf2out_decl
block|,
comment|/* function_decl */
name|dwarf2out_global_decl
block|,
name|dwarf2out_type_decl
block|,
comment|/* type_decl */
name|dwarf2out_imported_module_or_decl
block|,
name|debug_nothing_tree
block|,
comment|/* deferred_inline_function */
comment|/* The DWARF 2 backend tries to reduce debugging bloat by not      emitting the abstract description of inline functions until      something tries to reference them.  */
name|dwarf2out_abstract_function
block|,
comment|/* outlining_inline_function */
name|debug_nothing_rtx
block|,
comment|/* label */
name|debug_nothing_int
block|,
comment|/* handle_pch */
name|dwarf2out_var_location
block|,
name|dwarf2out_switch_text_section
block|,
literal|1
comment|/* start_end_main_source_file */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* NOTE: In the comments in this file, many references are made to    "Debugging Information Entries".  This term is abbreviated as `DIE'    throughout the remainder of this file.  */
end_comment

begin_comment
comment|/* An internal representation of the DWARF output is built, and then    walked to generate the DWARF debugging info.  The walk of the internal    representation is done after the entire program has been compiled.    The types below are used to describe the internal representation.  */
end_comment

begin_comment
comment|/* Various DIE's use offsets relative to the beginning of the    .debug_info section to refer to each other.  */
end_comment

begin_typedef
typedef|typedef
name|long
name|int
name|dw_offset
typedef|;
end_typedef

begin_comment
comment|/* Define typedefs here to avoid circular dependencies.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_attr_struct
modifier|*
name|dw_attr_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_line_info_struct
modifier|*
name|dw_line_info_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_separate_line_info_struct
modifier|*
name|dw_separate_line_info_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|pubname_struct
modifier|*
name|pubname_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_ranges_struct
modifier|*
name|dw_ranges_ref
typedef|;
end_typedef

begin_comment
comment|/* Each entry in the line_info_table maintains the file and    line number associated with the label generated for that    entry.  The label gives the PC value associated with    the line number entry.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_line_info_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|unsigned
name|long
name|dw_file_num
block|;
name|unsigned
name|long
name|dw_line_num
block|; }
end_typedef

begin_expr_stmt
name|dw_line_info_entry
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Line information for functions in separate sections; each one gets its    own sequence.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_separate_line_info_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|unsigned
name|long
name|dw_file_num
block|;
name|unsigned
name|long
name|dw_line_num
block|;
name|unsigned
name|long
name|function
block|; }
end_typedef

begin_expr_stmt
name|dw_separate_line_info_entry
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Each DIE attribute has a field specifying the attribute kind,    a link to the next attribute in the chain, and an attribute value.    Attributes are typically linked below the DIE they modify.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_attr_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|enum
name|dwarf_attribute
name|dw_attr
block|;
name|dw_val_node
name|dw_attr_val
block|; }
end_typedef

begin_expr_stmt
name|dw_attr_node
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_O
argument_list|(
name|dw_attr_node
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEF_VEC_ALLOC_O
argument_list|(
name|dw_attr_node
argument_list|,
name|gc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The Debugging Information Entry (DIE) structure.  DIEs form a tree.    The children of each node form a circular list linked by    die_sib.  die_child points to the node *before* the "first" child node.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|die_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|enum
name|dwarf_tag
name|die_tag
block|;
name|char
modifier|*
name|die_symbol
block|;
name|VEC
argument_list|(
name|dw_attr_node
argument_list|,
name|gc
argument_list|)
operator|*
name|die_attr
expr_stmt|;
name|dw_die_ref
name|die_parent
block|;
name|dw_die_ref
name|die_child
block|;
name|dw_die_ref
name|die_sib
block|;
name|dw_die_ref
name|die_definition
block|;
comment|/* ref from a specification to its definition */
name|dw_offset
name|die_offset
block|;
name|unsigned
name|long
name|die_abbrev
block|;
name|int
name|die_mark
block|;
comment|/* Die is used and must not be pruned as unused.  */
name|int
name|die_perennial_p
block|;
name|unsigned
name|int
name|decl_id
block|; }
end_typedef

begin_expr_stmt
name|die_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Evaluate 'expr' while 'c' is set to each child of DIE in order.  */
end_comment

begin_define
define|#
directive|define
name|FOR_EACH_CHILD
parameter_list|(
name|die
parameter_list|,
name|c
parameter_list|,
name|expr
parameter_list|)
value|do {	\   c = die->die_child;				\   if (c) do {					\     c = c->die_sib;				\     expr;					\   } while (c != die->die_child);		\ } while (0)
end_define

begin_comment
comment|/* The pubname structure */
end_comment

begin_typedef
typedef|typedef
name|struct
name|pubname_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|dw_die_ref
name|die
block|;
name|char
modifier|*
name|name
block|; }
end_typedef

begin_expr_stmt
name|pubname_entry
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|dw_ranges_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|int
name|block_num
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* The limbo die list structure.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|limbo_die_struct
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|dw_die_ref
name|die
block|;
name|tree
name|created_for
block|;
name|struct
name|limbo_die_struct
modifier|*
name|next
block|; }
end_typedef

begin_expr_stmt
name|limbo_die_node
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define a macro which returns nonzero for a TYPE_DECL which was    implicitly generated for a tagged type.     Note that unlike the gcc front end (which generates a NULL named    TYPE_DECL node for each complete tagged type, each array type, and    each function type node created) the g++ front end generates a    _named_ TYPE_DECL node for each tagged type node created.    These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to    generate a DW_TAG_typedef DIE for them.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_DECL_IS_STUB
parameter_list|(
name|decl
parameter_list|)
define|\
value|(DECL_NAME (decl) == NULL_TREE			\    || (DECL_ARTIFICIAL (decl)				\&& is_tagged_type (TREE_TYPE (decl))		\&& ((decl == TYPE_STUB_DECL (TREE_TYPE (decl)))	\
comment|/* This is necessary for stub decls that	\ 	      appear in nested inline functions.  */
value|\ 	   || (DECL_ABSTRACT_ORIGIN (decl) != NULL_TREE	\&& (decl_ultimate_origin (decl)		\ 		   == TYPE_STUB_DECL (TREE_TYPE (decl)))))))
end_define

begin_comment
comment|/* Information concerning the compilation unit's programming    language, and compiler version.  */
end_comment

begin_comment
comment|/* Fixed size portion of the DWARF compilation unit header.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_COMPILE_UNIT_HEADER_SIZE
define|\
value|(DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 3)
end_define

begin_comment
comment|/* Fixed size portion of public names info.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_PUBNAMES_HEADER_SIZE
value|(2 * DWARF_OFFSET_SIZE + 2)
end_define

begin_comment
comment|/* Fixed size portion of the address range info.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_ARANGES_HEADER_SIZE
define|\
value|(DWARF_ROUND (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4,	\                 DWARF2_ADDR_SIZE * 2)					\    - DWARF_INITIAL_LENGTH_SIZE)
end_define

begin_comment
comment|/* Size of padding portion in the address range info.  It must be    aligned to twice the pointer size.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_ARANGES_PAD_SIZE
define|\
value|(DWARF_ROUND (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4, \                 DWARF2_ADDR_SIZE * 2) \    - (DWARF_INITIAL_LENGTH_SIZE + DWARF_OFFSET_SIZE + 4))
end_define

begin_comment
comment|/* Use assembler line directives if available.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_ASM_LINE_DEBUG_INFO
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_DWARF2_DEBUG_LINE
end_ifdef

begin_define
define|#
directive|define
name|DWARF2_ASM_LINE_DEBUG_INFO
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DWARF2_ASM_LINE_DEBUG_INFO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Minimum line offset in a special line info. opcode.    This value was chosen to give a reasonable range of values.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_BASE
value|-10
end_define

begin_comment
comment|/* First special line opcode - leave room for the standard opcodes.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_OPCODE_BASE
value|10
end_define

begin_comment
comment|/* Range of line offsets in a special line info. opcode.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_RANGE
value|(254-DWARF_LINE_OPCODE_BASE+1)
end_define

begin_comment
comment|/* Flag that indicates the initial value of the is_stmt_start flag.    In the present implementation, we do not mark any lines as    the beginning of a source statement, because that information    is not made available by the GCC front-end.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_DEFAULT_IS_STMT_START
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
end_ifdef

begin_comment
comment|/* This location is used by calc_die_sizes() to keep track    the offset of each DIE within the .debug_info section.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|next_die_offset
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Record the root of the DIE's built for the current compilation unit.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|dw_die_ref
name|comp_unit_die
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A list of DIEs with a NULL parent waiting to be relocated.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|limbo_die_node
operator|*
name|limbo_die_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Filenames referenced by this compilation unit.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct dwarf_file_data))
argument_list|)
name|htab_t
name|file_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A hash table of references to DIE's that describe declarations.    The key is a DECL_UID() which is a unique number identifying each decl.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (struct die_struct))
argument_list|)
name|htab_t
name|decl_die_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Node of the variable location list.  */
end_comment

begin_decl_stmt
name|struct
name|var_loc_node
name|GTY
argument_list|(
operator|(
name|chain_next
argument_list|(
literal|"%h.next"
argument_list|)
operator|)
argument_list|)
block|{
name|rtx
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
name|var_loc_note
decl_stmt|;
specifier|const
name|char
modifier|*
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
name|label
decl_stmt|;
specifier|const
name|char
modifier|*
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
name|section_label
decl_stmt|;
name|struct
name|var_loc_node
modifier|*
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
name|next
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Variable location list.  */
end_comment

begin_decl_stmt
name|struct
name|var_loc_list_def
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|struct
name|var_loc_node
modifier|*
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
name|first
decl_stmt|;
comment|/* Do not mark the last element of the chained list because      it is marked through the chain.  */
name|struct
name|var_loc_node
modifier|*
name|GTY
argument_list|(
operator|(
name|skip
argument_list|(
literal|"%h"
argument_list|)
operator|)
argument_list|)
name|last
decl_stmt|;
comment|/* DECL_UID of the variable decl.  */
name|unsigned
name|int
name|decl_id
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|struct
name|var_loc_list_def
name|var_loc_list
typedef|;
end_typedef

begin_comment
comment|/* Table of decl location linked lists.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (var_loc_list))
argument_list|)
name|htab_t
name|decl_loc_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A pointer to the base of a list of references to DIE's that    are uniquely identified by their tag, presence/absence of    children DIE's, and list of attribute/value pairs.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(length (
literal|"abbrev_die_table_allocated"
argument|))
argument_list|)
name|dw_die_ref
operator|*
name|abbrev_die_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements currently allocated for abbrev_die_table.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|abbrev_die_table_allocated
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements in type_die_table currently in use.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|abbrev_die_table_in_use
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    abbrev_die_table.  */
end_comment

begin_define
define|#
directive|define
name|ABBREV_DIE_TABLE_INCREMENT
value|256
end_define

begin_comment
comment|/* A pointer to the base of a table that contains line information    for each source code line in .text in the compilation unit.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(length (
literal|"line_info_table_allocated"
argument|))
argument_list|)
name|dw_line_info_ref
name|line_info_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements currently allocated for line_info_table.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|line_info_table_allocated
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements in line_info_table currently in use.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|line_info_table_in_use
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* True if the compilation unit places functions in more than one section.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|bool
name|have_multiple_function_sections
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A pointer to the base of a table that contains line information    for each source code line outside of .text in the compilation unit.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(length (
literal|"separate_line_info_table_allocated"
argument|))
argument_list|)
name|dw_separate_line_info_ref
name|separate_line_info_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements currently allocated for separate_line_info_table.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|separate_line_info_table_allocated
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements in separate_line_info_table currently in use.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|separate_line_info_table_in_use
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    line_info_table.  */
end_comment

begin_define
define|#
directive|define
name|LINE_INFO_TABLE_INCREMENT
value|1024
end_define

begin_comment
comment|/* A pointer to the base of a table that contains a list of publicly    accessible names.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(length (
literal|"pubname_table_allocated"
argument|))
argument_list|)
name|pubname_ref
name|pubname_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements currently allocated for pubname_table.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|pubname_table_allocated
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements in pubname_table currently in use.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|pubname_table_in_use
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    pubname_table.  */
end_comment

begin_define
define|#
directive|define
name|PUBNAME_TABLE_INCREMENT
value|64
end_define

begin_comment
comment|/* Array of dies for which we should generate .debug_arange info.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(length (
literal|"arange_table_allocated"
argument|))
argument_list|)
name|dw_die_ref
operator|*
name|arange_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements currently allocated for arange_table.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|arange_table_allocated
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements in arange_table currently in use.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|arange_table_in_use
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    arange_table.  */
end_comment

begin_define
define|#
directive|define
name|ARANGE_TABLE_INCREMENT
value|64
end_define

begin_comment
comment|/* Array of dies for which we should generate .debug_ranges info.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(length (
literal|"ranges_table_allocated"
argument|))
argument_list|)
name|dw_ranges_ref
name|ranges_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements currently allocated for ranges_table.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|ranges_table_allocated
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements in ranges_table currently in use.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|ranges_table_in_use
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    ranges_table.  */
end_comment

begin_define
define|#
directive|define
name|RANGES_TABLE_INCREMENT
value|64
end_define

begin_comment
comment|/* Whether we have location lists that need outputting */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|bool
name|have_location_lists
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Unique label counter.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|int
name|loclabel_num
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
end_ifdef

begin_comment
comment|/* Record whether the function being analyzed contains inlined functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_function_has_inlines
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|MIPS_DEBUGGING_INFO
argument_list|)
end_if

begin_endif
unit|static int comp_unit_has_inlines;
endif|#
directive|endif
end_endif

begin_comment
comment|/* The last file entry emitted by maybe_emit_file().  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|dwarf_file_data
operator|*
name|last_emitted_file
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of internal labels generated by gen_internal_sym().  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|label_num
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Cached result of previous call to lookup_filename.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
expr|struct
name|dwarf_file_data
operator|*
name|file_table_last_lookup
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
end_ifdef

begin_comment
comment|/* Offset from the "steady-state frame pointer" to the frame base,    within the current function.  */
end_comment

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|frame_pointer_fb_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations for functions defined in this file.  */
end_comment

begin_function_decl
specifier|static
name|int
name|is_pseudo_reg
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|type_main_variant
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_tagged_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_tag_name
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_attr_name
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_form_name
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|decl_ultimate_origin
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|block_ultimate_origin
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|decl_class_context
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_dwarf_attr
parameter_list|(
name|dw_die_ref
parameter_list|,
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|enum
name|dw_val_class
name|AT_class
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_flag
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|unsigned
name|AT_flag
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_int
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|HOST_WIDE_INT
name|AT_int
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_unsigned
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|unsigned
name|HOST_WIDE_INT
name|AT_unsigned
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_long_long
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|add_AT_vec
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|debug_str_do_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_str_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_string
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|AT_string
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|AT_string_form
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_die_ref
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_specification
parameter_list|(
name|dw_die_ref
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|dw_die_ref
name|AT_ref
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|AT_ref_external
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|set_AT_ref_external
parameter_list|(
name|dw_attr_ref
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_fde_ref
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_loc
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|dw_loc_descr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|dw_loc_descr_ref
name|AT_loc
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_loc_list
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|dw_loc_list_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|dw_loc_list_ref
name|AT_loc_list
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_addr
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|rtx
name|AT_addr
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_lbl_id
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_lineptr
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_macptr
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_offset
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_range_list
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|AT_lbl
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_attr_ref
name|get_AT
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_AT_low_pc
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_AT_hi_pc
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_AT_string
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_AT_flag
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|get_AT_unsigned
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|dw_die_ref
name|get_AT_ref
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_c_family
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_cxx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_java
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_fortran
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_ada
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_AT
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_child_TAG
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_child_die
parameter_list|(
name|dw_die_ref
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|new_die
parameter_list|(
name|enum
name|dwarf_tag
parameter_list|,
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|lookup_type_die
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|equate_type_number_to_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|decl_die_table_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decl_die_table_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|lookup_decl_die
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|decl_loc_table_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decl_loc_table_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|var_loc_list
modifier|*
name|lookup_decl_loc
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|equate_decl_number_to_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_var_loc_to_decl
parameter_list|(
name|tree
parameter_list|,
name|struct
name|var_loc_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_spaces
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_die
parameter_list|(
name|dw_die_ref
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_dwarf_line_table
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|push_new_compile_unit
parameter_list|(
name|dw_die_ref
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|pop_compile_unit
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|loc_checksum
parameter_list|(
name|dw_loc_descr_ref
parameter_list|,
name|struct
name|md5_ctx
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|attr_checksum
parameter_list|(
name|dw_attr_ref
parameter_list|,
name|struct
name|md5_ctx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|die_checksum
parameter_list|(
name|dw_die_ref
parameter_list|,
name|struct
name|md5_ctx
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|same_loc_p
parameter_list|(
name|dw_loc_descr_ref
parameter_list|,
name|dw_loc_descr_ref
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|same_dw_val_p
parameter_list|(
name|dw_val_node
modifier|*
parameter_list|,
name|dw_val_node
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|same_attr_p
parameter_list|(
name|dw_attr_ref
parameter_list|,
name|dw_attr_ref
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|same_die_p
parameter_list|(
name|dw_die_ref
parameter_list|,
name|dw_die_ref
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|same_die_p_wrap
parameter_list|(
name|dw_die_ref
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_section_prefix
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_type_die
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_comdat_die
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_symbol_die
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|assign_symbol_names
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|break_out_includes
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hashval_t
name|htab_cu_hash
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|htab_cu_eq
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|htab_cu_del
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_duplicate_cu
parameter_list|(
name|dw_die_ref
parameter_list|,
name|htab_t
parameter_list|,
name|unsigned
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_comdat_symbol_number
parameter_list|(
name|dw_die_ref
parameter_list|,
name|htab_t
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_sibling_attributes
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_abbrev_table
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_location_lists
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|constant_size
parameter_list|(
name|long
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|size_of_die
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calc_die_sizes
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_dies
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unmark_dies
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unmark_all_dies
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|size_of_pubnames
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|size_of_aranges
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|dwarf_form
name|value_format
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_value_format
parameter_list|(
name|dw_attr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_abbrev_section
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_die_symbol
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_die
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_compilation_unit_header
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_comp_unit
parameter_list|(
name|dw_die_ref
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|dwarf2_name
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pubname
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_pubnames
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_arange
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_aranges
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|add_ranges
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_ranges
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_line_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_file_names
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|base_type_die
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|root_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_base_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|is_subrange_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|subrange_type_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|modified_type_die
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|type_is_enum
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|dbx_reg_number
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_loc_descr_op_piece
parameter_list|(
name|dw_loc_descr_ref
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_descr_ref
name|reg_loc_descriptor
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_descr_ref
name|one_reg_loc_descriptor
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_descr_ref
name|multiple_reg_loc_descriptor
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_descr_ref
name|int_loc_descriptor
parameter_list|(
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_descr_ref
name|based_loc_descr
parameter_list|(
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_based_loc
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_descr_ref
name|mem_loc_descriptor
parameter_list|(
name|rtx
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_descr_ref
name|concat_loc_descriptor
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_descr_ref
name|loc_descriptor
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_descr_ref
name|loc_descriptor_from_tree_1
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_descr_ref
name|loc_descriptor_from_tree
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|ceiling
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|field_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|simple_type_align_in_bits
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|simple_decl_align_in_bits
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|simple_type_size_in_bits
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|field_byte_offset
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_AT_location_description
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|dw_loc_descr_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_data_member_location_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_const_value_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_int
parameter_list|(
name|HOST_WIDE_INT
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|extract_int
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|insert_float
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|rtl_for_decl_location
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_location_or_const_value_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tree_add_const_value_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_name_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_comp_dir_attribute
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_bound_info
parameter_list|(
name|dw_die_ref
parameter_list|,
name|enum
name|dwarf_attribute
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_subscript_info
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_byte_size_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_bit_offset_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_bit_size_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_prototyped_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_abstract_origin_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pure_or_virtual_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_src_coords_attributes
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_name_and_src_coords_attributes
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_decl_scope
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pop_decl_scope
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|scope_die_for
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|local_scope_p
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|int
name|class_or_namespace_scope_p
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_type_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_calling_convention_attribute
parameter_list|(
name|dw_die_ref
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|type_tag
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|member_declared_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char *decl_start_label (tree);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|gen_array_type_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void gen_entry_point_die (tree, dw_die_ref);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|gen_inlined_enumeration_type_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_inlined_structure_type_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_inlined_union_type_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|gen_enumeration_type_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|gen_formal_parameter_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_unspecified_parameters_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_formal_types_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_subprogram_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_variable_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_label_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_lexical_block_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_inlined_subroutine_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_field_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_ptr_to_mbr_type_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|gen_compile_unit_die
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_inheritance_die
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_member_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_struct_or_union_type_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_subroutine_type_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_typedef_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_type_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_tagged_type_instantiation_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_block_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decls_for_scope
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_redundant_typedef
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_namespace_die
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_decl_die
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|force_decl_die
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|force_type_die
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_die_ref
name|setup_namespace_context
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|declare_in_namespace
parameter_list|(
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dwarf_file_data
modifier|*
name|lookup_filename
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|retry_incomplete_types
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gen_type_die_for_member
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|splice_child_die
parameter_list|(
name|dw_die_ref
parameter_list|,
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_info_cmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|dw_loc_list_ref
name|new_loc_list
parameter_list|(
name|dw_loc_descr_ref
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_loc_descr_to_loc_list
parameter_list|(
name|dw_loc_list_ref
modifier|*
parameter_list|,
name|dw_loc_descr_ref
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_loc_list
parameter_list|(
name|dw_loc_list_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|gen_internal_sym
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prune_unmark_dies
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prune_unused_types_mark
parameter_list|(
name|dw_die_ref
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prune_unused_types_walk
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prune_unused_types_walk_attribs
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prune_unused_types_prune
parameter_list|(
name|dw_die_ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prune_unused_types
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|maybe_emit_file
parameter_list|(
name|struct
name|dwarf_file_data
modifier|*
name|fd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Section names used to hold DWARF debugging information.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_INFO_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_INFO_SECTION
value|".debug_info"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_ABBREV_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_ABBREV_SECTION
value|".debug_abbrev"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_ARANGES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_ARANGES_SECTION
value|".debug_aranges"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_MACINFO_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_MACINFO_SECTION
value|".debug_macinfo"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_LINE_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_LINE_SECTION
value|".debug_line"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_LOC_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_LOC_SECTION
value|".debug_loc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_PUBNAMES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_PUBNAMES_SECTION
value|".debug_pubnames"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_STR_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_STR_SECTION
value|".debug_str"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_RANGES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_RANGES_SECTION
value|".debug_ranges"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Standard ELF section names for compiled code and data.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|TEXT_SECTION_NAME
value|".text"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Section flags for .debug_str section.  */
end_comment

begin_define
define|#
directive|define
name|DEBUG_STR_SECTION_FLAGS
define|\
value|(HAVE_GAS_SHF_MERGE&& flag_merge_constants			\    ? SECTION_DEBUG | SECTION_MERGE | SECTION_STRINGS | 1	\    : SECTION_DEBUG)
end_define

begin_comment
comment|/* Labels we insert at beginning sections we can reference instead of    the section names themselves.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TEXT_SECTION_LABEL
value|"Ltext"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COLD_TEXT_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|COLD_TEXT_SECTION_LABEL
value|"Ltext_cold"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_LINE_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_LINE_SECTION_LABEL
value|"Ldebug_line"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_INFO_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_INFO_SECTION_LABEL
value|"Ldebug_info"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_ABBREV_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_ABBREV_SECTION_LABEL
value|"Ldebug_abbrev"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_LOC_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_LOC_SECTION_LABEL
value|"Ldebug_loc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_RANGES_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_RANGES_SECTION_LABEL
value|"Ldebug_ranges"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_MACINFO_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_MACINFO_SECTION_LABEL
value|"Ldebug_macinfo"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Definitions of defaults for formats and names of various special    (artificial) labels which may be generated within this file (when the -g    options is used and DWARF2_DEBUGGING_INFO is in effect.    If necessary, these may be overridden from within the tm.h file, but    typically, overriding these defaults is unnecessary.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|text_end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|text_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cold_text_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cold_end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|abbrev_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|debug_info_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|debug_line_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|macinfo_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|loc_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ranges_section_label
index|[
literal|2
operator|*
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TEXT_END_LABEL
value|"Letext"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COLD_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|COLD_END_LABEL
value|"Letext_cold"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_BEGIN_LABEL
value|"LBB"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_END_LABEL
value|"LBE"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_CODE_LABEL
end_ifndef

begin_define
define|#
directive|define
name|LINE_CODE_LABEL
value|"LM"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEPARATE_LINE_CODE_LABEL
end_ifndef

begin_define
define|#
directive|define
name|SEPARATE_LINE_CODE_LABEL
value|"LSM"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* We allow a language front-end to designate a function that is to be    called to "demangle" any name before it is put into a DIE.  */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|demangle_name_func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dwarf2out_set_demangle_name_func
parameter_list|(
specifier|const
name|char
modifier|*
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
name|demangle_name_func
operator|=
name|func
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Test if rtl node points to a pseudo register.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_pseudo_reg
parameter_list|(
name|rtx
name|rtl
parameter_list|)
block|{
return|return
operator|(
operator|(
name|REG_P
argument_list|(
name|rtl
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|rtl
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a reference to a type, with its const and volatile qualifiers    removed.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|type_main_variant
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* ??? There really should be only one main variant among any group of      variants of a given type (and all of the MAIN_VARIANT values for all      members of the group should point to that one type) but sometimes the C      front-end messes this up for array types, so we work around that bug      here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
while|while
condition|(
name|type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the given type node represents a tagged type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_tagged_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|QUAL_UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a DIE tag into its string name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_tag_name
parameter_list|(
name|unsigned
name|int
name|tag
parameter_list|)
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DW_TAG_padding
case|:
return|return
literal|"DW_TAG_padding"
return|;
case|case
name|DW_TAG_array_type
case|:
return|return
literal|"DW_TAG_array_type"
return|;
case|case
name|DW_TAG_class_type
case|:
return|return
literal|"DW_TAG_class_type"
return|;
case|case
name|DW_TAG_entry_point
case|:
return|return
literal|"DW_TAG_entry_point"
return|;
case|case
name|DW_TAG_enumeration_type
case|:
return|return
literal|"DW_TAG_enumeration_type"
return|;
case|case
name|DW_TAG_formal_parameter
case|:
return|return
literal|"DW_TAG_formal_parameter"
return|;
case|case
name|DW_TAG_imported_declaration
case|:
return|return
literal|"DW_TAG_imported_declaration"
return|;
case|case
name|DW_TAG_label
case|:
return|return
literal|"DW_TAG_label"
return|;
case|case
name|DW_TAG_lexical_block
case|:
return|return
literal|"DW_TAG_lexical_block"
return|;
case|case
name|DW_TAG_member
case|:
return|return
literal|"DW_TAG_member"
return|;
case|case
name|DW_TAG_pointer_type
case|:
return|return
literal|"DW_TAG_pointer_type"
return|;
case|case
name|DW_TAG_reference_type
case|:
return|return
literal|"DW_TAG_reference_type"
return|;
case|case
name|DW_TAG_compile_unit
case|:
return|return
literal|"DW_TAG_compile_unit"
return|;
case|case
name|DW_TAG_string_type
case|:
return|return
literal|"DW_TAG_string_type"
return|;
case|case
name|DW_TAG_structure_type
case|:
return|return
literal|"DW_TAG_structure_type"
return|;
case|case
name|DW_TAG_subroutine_type
case|:
return|return
literal|"DW_TAG_subroutine_type"
return|;
case|case
name|DW_TAG_typedef
case|:
return|return
literal|"DW_TAG_typedef"
return|;
case|case
name|DW_TAG_union_type
case|:
return|return
literal|"DW_TAG_union_type"
return|;
case|case
name|DW_TAG_unspecified_parameters
case|:
return|return
literal|"DW_TAG_unspecified_parameters"
return|;
case|case
name|DW_TAG_variant
case|:
return|return
literal|"DW_TAG_variant"
return|;
case|case
name|DW_TAG_common_block
case|:
return|return
literal|"DW_TAG_common_block"
return|;
case|case
name|DW_TAG_common_inclusion
case|:
return|return
literal|"DW_TAG_common_inclusion"
return|;
case|case
name|DW_TAG_inheritance
case|:
return|return
literal|"DW_TAG_inheritance"
return|;
case|case
name|DW_TAG_inlined_subroutine
case|:
return|return
literal|"DW_TAG_inlined_subroutine"
return|;
case|case
name|DW_TAG_module
case|:
return|return
literal|"DW_TAG_module"
return|;
case|case
name|DW_TAG_ptr_to_member_type
case|:
return|return
literal|"DW_TAG_ptr_to_member_type"
return|;
case|case
name|DW_TAG_set_type
case|:
return|return
literal|"DW_TAG_set_type"
return|;
case|case
name|DW_TAG_subrange_type
case|:
return|return
literal|"DW_TAG_subrange_type"
return|;
case|case
name|DW_TAG_with_stmt
case|:
return|return
literal|"DW_TAG_with_stmt"
return|;
case|case
name|DW_TAG_access_declaration
case|:
return|return
literal|"DW_TAG_access_declaration"
return|;
case|case
name|DW_TAG_base_type
case|:
return|return
literal|"DW_TAG_base_type"
return|;
case|case
name|DW_TAG_catch_block
case|:
return|return
literal|"DW_TAG_catch_block"
return|;
case|case
name|DW_TAG_const_type
case|:
return|return
literal|"DW_TAG_const_type"
return|;
case|case
name|DW_TAG_constant
case|:
return|return
literal|"DW_TAG_constant"
return|;
case|case
name|DW_TAG_enumerator
case|:
return|return
literal|"DW_TAG_enumerator"
return|;
case|case
name|DW_TAG_file_type
case|:
return|return
literal|"DW_TAG_file_type"
return|;
case|case
name|DW_TAG_friend
case|:
return|return
literal|"DW_TAG_friend"
return|;
case|case
name|DW_TAG_namelist
case|:
return|return
literal|"DW_TAG_namelist"
return|;
case|case
name|DW_TAG_namelist_item
case|:
return|return
literal|"DW_TAG_namelist_item"
return|;
case|case
name|DW_TAG_namespace
case|:
return|return
literal|"DW_TAG_namespace"
return|;
case|case
name|DW_TAG_packed_type
case|:
return|return
literal|"DW_TAG_packed_type"
return|;
case|case
name|DW_TAG_subprogram
case|:
return|return
literal|"DW_TAG_subprogram"
return|;
case|case
name|DW_TAG_template_type_param
case|:
return|return
literal|"DW_TAG_template_type_param"
return|;
case|case
name|DW_TAG_template_value_param
case|:
return|return
literal|"DW_TAG_template_value_param"
return|;
case|case
name|DW_TAG_thrown_type
case|:
return|return
literal|"DW_TAG_thrown_type"
return|;
case|case
name|DW_TAG_try_block
case|:
return|return
literal|"DW_TAG_try_block"
return|;
case|case
name|DW_TAG_variant_part
case|:
return|return
literal|"DW_TAG_variant_part"
return|;
case|case
name|DW_TAG_variable
case|:
return|return
literal|"DW_TAG_variable"
return|;
case|case
name|DW_TAG_volatile_type
case|:
return|return
literal|"DW_TAG_volatile_type"
return|;
case|case
name|DW_TAG_imported_module
case|:
return|return
literal|"DW_TAG_imported_module"
return|;
case|case
name|DW_TAG_MIPS_loop
case|:
return|return
literal|"DW_TAG_MIPS_loop"
return|;
case|case
name|DW_TAG_format_label
case|:
return|return
literal|"DW_TAG_format_label"
return|;
case|case
name|DW_TAG_function_template
case|:
return|return
literal|"DW_TAG_function_template"
return|;
case|case
name|DW_TAG_class_template
case|:
return|return
literal|"DW_TAG_class_template"
return|;
case|case
name|DW_TAG_GNU_BINCL
case|:
return|return
literal|"DW_TAG_GNU_BINCL"
return|;
case|case
name|DW_TAG_GNU_EINCL
case|:
return|return
literal|"DW_TAG_GNU_EINCL"
return|;
default|default:
return|return
literal|"DW_TAG_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF attribute code into its string name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_attr_name
parameter_list|(
name|unsigned
name|int
name|attr
parameter_list|)
block|{
switch|switch
condition|(
name|attr
condition|)
block|{
case|case
name|DW_AT_sibling
case|:
return|return
literal|"DW_AT_sibling"
return|;
case|case
name|DW_AT_location
case|:
return|return
literal|"DW_AT_location"
return|;
case|case
name|DW_AT_name
case|:
return|return
literal|"DW_AT_name"
return|;
case|case
name|DW_AT_ordering
case|:
return|return
literal|"DW_AT_ordering"
return|;
case|case
name|DW_AT_subscr_data
case|:
return|return
literal|"DW_AT_subscr_data"
return|;
case|case
name|DW_AT_byte_size
case|:
return|return
literal|"DW_AT_byte_size"
return|;
case|case
name|DW_AT_bit_offset
case|:
return|return
literal|"DW_AT_bit_offset"
return|;
case|case
name|DW_AT_bit_size
case|:
return|return
literal|"DW_AT_bit_size"
return|;
case|case
name|DW_AT_element_list
case|:
return|return
literal|"DW_AT_element_list"
return|;
case|case
name|DW_AT_stmt_list
case|:
return|return
literal|"DW_AT_stmt_list"
return|;
case|case
name|DW_AT_low_pc
case|:
return|return
literal|"DW_AT_low_pc"
return|;
case|case
name|DW_AT_high_pc
case|:
return|return
literal|"DW_AT_high_pc"
return|;
case|case
name|DW_AT_language
case|:
return|return
literal|"DW_AT_language"
return|;
case|case
name|DW_AT_member
case|:
return|return
literal|"DW_AT_member"
return|;
case|case
name|DW_AT_discr
case|:
return|return
literal|"DW_AT_discr"
return|;
case|case
name|DW_AT_discr_value
case|:
return|return
literal|"DW_AT_discr_value"
return|;
case|case
name|DW_AT_visibility
case|:
return|return
literal|"DW_AT_visibility"
return|;
case|case
name|DW_AT_import
case|:
return|return
literal|"DW_AT_import"
return|;
case|case
name|DW_AT_string_length
case|:
return|return
literal|"DW_AT_string_length"
return|;
case|case
name|DW_AT_common_reference
case|:
return|return
literal|"DW_AT_common_reference"
return|;
case|case
name|DW_AT_comp_dir
case|:
return|return
literal|"DW_AT_comp_dir"
return|;
case|case
name|DW_AT_const_value
case|:
return|return
literal|"DW_AT_const_value"
return|;
case|case
name|DW_AT_containing_type
case|:
return|return
literal|"DW_AT_containing_type"
return|;
case|case
name|DW_AT_default_value
case|:
return|return
literal|"DW_AT_default_value"
return|;
case|case
name|DW_AT_inline
case|:
return|return
literal|"DW_AT_inline"
return|;
case|case
name|DW_AT_is_optional
case|:
return|return
literal|"DW_AT_is_optional"
return|;
case|case
name|DW_AT_lower_bound
case|:
return|return
literal|"DW_AT_lower_bound"
return|;
case|case
name|DW_AT_producer
case|:
return|return
literal|"DW_AT_producer"
return|;
case|case
name|DW_AT_prototyped
case|:
return|return
literal|"DW_AT_prototyped"
return|;
case|case
name|DW_AT_return_addr
case|:
return|return
literal|"DW_AT_return_addr"
return|;
case|case
name|DW_AT_start_scope
case|:
return|return
literal|"DW_AT_start_scope"
return|;
case|case
name|DW_AT_stride_size
case|:
return|return
literal|"DW_AT_stride_size"
return|;
case|case
name|DW_AT_upper_bound
case|:
return|return
literal|"DW_AT_upper_bound"
return|;
case|case
name|DW_AT_abstract_origin
case|:
return|return
literal|"DW_AT_abstract_origin"
return|;
case|case
name|DW_AT_accessibility
case|:
return|return
literal|"DW_AT_accessibility"
return|;
case|case
name|DW_AT_address_class
case|:
return|return
literal|"DW_AT_address_class"
return|;
case|case
name|DW_AT_artificial
case|:
return|return
literal|"DW_AT_artificial"
return|;
case|case
name|DW_AT_base_types
case|:
return|return
literal|"DW_AT_base_types"
return|;
case|case
name|DW_AT_calling_convention
case|:
return|return
literal|"DW_AT_calling_convention"
return|;
case|case
name|DW_AT_count
case|:
return|return
literal|"DW_AT_count"
return|;
case|case
name|DW_AT_data_member_location
case|:
return|return
literal|"DW_AT_data_member_location"
return|;
case|case
name|DW_AT_decl_column
case|:
return|return
literal|"DW_AT_decl_column"
return|;
case|case
name|DW_AT_decl_file
case|:
return|return
literal|"DW_AT_decl_file"
return|;
case|case
name|DW_AT_decl_line
case|:
return|return
literal|"DW_AT_decl_line"
return|;
case|case
name|DW_AT_declaration
case|:
return|return
literal|"DW_AT_declaration"
return|;
case|case
name|DW_AT_discr_list
case|:
return|return
literal|"DW_AT_discr_list"
return|;
case|case
name|DW_AT_encoding
case|:
return|return
literal|"DW_AT_encoding"
return|;
case|case
name|DW_AT_external
case|:
return|return
literal|"DW_AT_external"
return|;
case|case
name|DW_AT_frame_base
case|:
return|return
literal|"DW_AT_frame_base"
return|;
case|case
name|DW_AT_friend
case|:
return|return
literal|"DW_AT_friend"
return|;
case|case
name|DW_AT_identifier_case
case|:
return|return
literal|"DW_AT_identifier_case"
return|;
case|case
name|DW_AT_macro_info
case|:
return|return
literal|"DW_AT_macro_info"
return|;
case|case
name|DW_AT_namelist_items
case|:
return|return
literal|"DW_AT_namelist_items"
return|;
case|case
name|DW_AT_priority
case|:
return|return
literal|"DW_AT_priority"
return|;
case|case
name|DW_AT_segment
case|:
return|return
literal|"DW_AT_segment"
return|;
case|case
name|DW_AT_specification
case|:
return|return
literal|"DW_AT_specification"
return|;
case|case
name|DW_AT_static_link
case|:
return|return
literal|"DW_AT_static_link"
return|;
case|case
name|DW_AT_type
case|:
return|return
literal|"DW_AT_type"
return|;
case|case
name|DW_AT_use_location
case|:
return|return
literal|"DW_AT_use_location"
return|;
case|case
name|DW_AT_variable_parameter
case|:
return|return
literal|"DW_AT_variable_parameter"
return|;
case|case
name|DW_AT_virtuality
case|:
return|return
literal|"DW_AT_virtuality"
return|;
case|case
name|DW_AT_vtable_elem_location
case|:
return|return
literal|"DW_AT_vtable_elem_location"
return|;
case|case
name|DW_AT_allocated
case|:
return|return
literal|"DW_AT_allocated"
return|;
case|case
name|DW_AT_associated
case|:
return|return
literal|"DW_AT_associated"
return|;
case|case
name|DW_AT_data_location
case|:
return|return
literal|"DW_AT_data_location"
return|;
case|case
name|DW_AT_stride
case|:
return|return
literal|"DW_AT_stride"
return|;
case|case
name|DW_AT_entry_pc
case|:
return|return
literal|"DW_AT_entry_pc"
return|;
case|case
name|DW_AT_use_UTF8
case|:
return|return
literal|"DW_AT_use_UTF8"
return|;
case|case
name|DW_AT_extension
case|:
return|return
literal|"DW_AT_extension"
return|;
case|case
name|DW_AT_ranges
case|:
return|return
literal|"DW_AT_ranges"
return|;
case|case
name|DW_AT_trampoline
case|:
return|return
literal|"DW_AT_trampoline"
return|;
case|case
name|DW_AT_call_column
case|:
return|return
literal|"DW_AT_call_column"
return|;
case|case
name|DW_AT_call_file
case|:
return|return
literal|"DW_AT_call_file"
return|;
case|case
name|DW_AT_call_line
case|:
return|return
literal|"DW_AT_call_line"
return|;
case|case
name|DW_AT_MIPS_fde
case|:
return|return
literal|"DW_AT_MIPS_fde"
return|;
case|case
name|DW_AT_MIPS_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_loop_begin"
return|;
case|case
name|DW_AT_MIPS_tail_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_tail_loop_begin"
return|;
case|case
name|DW_AT_MIPS_epilog_begin
case|:
return|return
literal|"DW_AT_MIPS_epilog_begin"
return|;
case|case
name|DW_AT_MIPS_loop_unroll_factor
case|:
return|return
literal|"DW_AT_MIPS_loop_unroll_factor"
return|;
case|case
name|DW_AT_MIPS_software_pipeline_depth
case|:
return|return
literal|"DW_AT_MIPS_software_pipeline_depth"
return|;
case|case
name|DW_AT_MIPS_linkage_name
case|:
return|return
literal|"DW_AT_MIPS_linkage_name"
return|;
case|case
name|DW_AT_MIPS_stride
case|:
return|return
literal|"DW_AT_MIPS_stride"
return|;
case|case
name|DW_AT_MIPS_abstract_name
case|:
return|return
literal|"DW_AT_MIPS_abstract_name"
return|;
case|case
name|DW_AT_MIPS_clone_origin
case|:
return|return
literal|"DW_AT_MIPS_clone_origin"
return|;
case|case
name|DW_AT_MIPS_has_inlines
case|:
return|return
literal|"DW_AT_MIPS_has_inlines"
return|;
case|case
name|DW_AT_sf_names
case|:
return|return
literal|"DW_AT_sf_names"
return|;
case|case
name|DW_AT_src_info
case|:
return|return
literal|"DW_AT_src_info"
return|;
case|case
name|DW_AT_mac_info
case|:
return|return
literal|"DW_AT_mac_info"
return|;
case|case
name|DW_AT_src_coords
case|:
return|return
literal|"DW_AT_src_coords"
return|;
case|case
name|DW_AT_body_begin
case|:
return|return
literal|"DW_AT_body_begin"
return|;
case|case
name|DW_AT_body_end
case|:
return|return
literal|"DW_AT_body_end"
return|;
case|case
name|DW_AT_GNU_vector
case|:
return|return
literal|"DW_AT_GNU_vector"
return|;
case|case
name|DW_AT_VMS_rtnbeg_pd_address
case|:
return|return
literal|"DW_AT_VMS_rtnbeg_pd_address"
return|;
default|default:
return|return
literal|"DW_AT_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF value form code into its string name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_form_name
parameter_list|(
name|unsigned
name|int
name|form
parameter_list|)
block|{
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
return|return
literal|"DW_FORM_addr"
return|;
case|case
name|DW_FORM_block2
case|:
return|return
literal|"DW_FORM_block2"
return|;
case|case
name|DW_FORM_block4
case|:
return|return
literal|"DW_FORM_block4"
return|;
case|case
name|DW_FORM_data2
case|:
return|return
literal|"DW_FORM_data2"
return|;
case|case
name|DW_FORM_data4
case|:
return|return
literal|"DW_FORM_data4"
return|;
case|case
name|DW_FORM_data8
case|:
return|return
literal|"DW_FORM_data8"
return|;
case|case
name|DW_FORM_string
case|:
return|return
literal|"DW_FORM_string"
return|;
case|case
name|DW_FORM_block
case|:
return|return
literal|"DW_FORM_block"
return|;
case|case
name|DW_FORM_block1
case|:
return|return
literal|"DW_FORM_block1"
return|;
case|case
name|DW_FORM_data1
case|:
return|return
literal|"DW_FORM_data1"
return|;
case|case
name|DW_FORM_flag
case|:
return|return
literal|"DW_FORM_flag"
return|;
case|case
name|DW_FORM_sdata
case|:
return|return
literal|"DW_FORM_sdata"
return|;
case|case
name|DW_FORM_strp
case|:
return|return
literal|"DW_FORM_strp"
return|;
case|case
name|DW_FORM_udata
case|:
return|return
literal|"DW_FORM_udata"
return|;
case|case
name|DW_FORM_ref_addr
case|:
return|return
literal|"DW_FORM_ref_addr"
return|;
case|case
name|DW_FORM_ref1
case|:
return|return
literal|"DW_FORM_ref1"
return|;
case|case
name|DW_FORM_ref2
case|:
return|return
literal|"DW_FORM_ref2"
return|;
case|case
name|DW_FORM_ref4
case|:
return|return
literal|"DW_FORM_ref4"
return|;
case|case
name|DW_FORM_ref8
case|:
return|return
literal|"DW_FORM_ref8"
return|;
case|case
name|DW_FORM_ref_udata
case|:
return|return
literal|"DW_FORM_ref_udata"
return|;
case|case
name|DW_FORM_indirect
case|:
return|return
literal|"DW_FORM_indirect"
return|;
default|default:
return|return
literal|"DW_FORM_<unknown>"
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Determine the "ultimate origin" of a decl.  The decl may be an inlined    instance of an inlined instance of a decl which is local to an inline    function, so we have to trace all of the way back through the origin chain    to find out what sort of node actually served as the original seed for the    given block.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_ultimate_origin
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CODE_CONTAINS_STRUCT
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TS_DECL_COMMON
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* output_inline_function sets DECL_ABSTRACT_ORIGIN for all the      nodes in the function to point to themselves; ignore that if      we're trying to output the abstract instance of this function.  */
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|==
name|decl
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the      most distant ancestor, this should never happen.  */
name|gcc_assert
argument_list|(
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|DECL_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine the "ultimate origin" of a block.  The block may be an inlined    instance of an inlined instance of a block which is local to an inline    function, so we have to trace all of the way back through the origin chain    to find out what sort of node actually served as the original seed for the    given block.  */
end_comment

begin_function
specifier|static
name|tree
name|block_ultimate_origin
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|tree
name|immediate_origin
init|=
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|block
argument_list|)
decl_stmt|;
comment|/* output_inline_function sets BLOCK_ABSTRACT_ORIGIN for all the      nodes in the function to point to themselves; ignore that if      we're trying to output the abstract instance of this function.  */
if|if
condition|(
name|BLOCK_ABSTRACT
argument_list|(
name|block
argument_list|)
operator|&&
name|immediate_origin
operator|==
name|block
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|immediate_origin
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
else|else
block|{
name|tree
name|ret_val
decl_stmt|;
name|tree
name|lookahead
init|=
name|immediate_origin
decl_stmt|;
do|do
block|{
name|ret_val
operator|=
name|lookahead
expr_stmt|;
name|lookahead
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|ret_val
argument_list|)
operator|==
name|BLOCK
condition|?
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|ret_val
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|lookahead
operator|!=
name|NULL
operator|&&
name|lookahead
operator|!=
name|ret_val
condition|)
do|;
comment|/* The block's abstract origin chain may not be the *ultimate* origin of 	 the block. It could lead to a DECL that has an abstract origin set. 	 If so, we want that DECL's abstract origin (which is what DECL_ORIGIN 	 will give us if it has one).  Note that DECL's abstract origins are 	 supposed to be the most distant ancestor (or so decl_ultimate_origin 	 claims), so we don't need to loop following the DECL origins.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|ret_val
argument_list|)
condition|)
return|return
name|DECL_ORIGIN
argument_list|(
name|ret_val
argument_list|)
return|;
return|return
name|ret_val
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get the class to which DECL belongs, if any.  In g++, the DECL_CONTEXT    of a virtual function may refer to a base class, so we check the 'this'    parameter.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_class_context
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
operator|!
name|TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|context
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an attribute/value pair to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_dwarf_attr
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|dw_attr_ref
name|attr
parameter_list|)
block|{
comment|/* Maybe this should be an assert?  */
if|if
condition|(
name|die
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|die
operator|->
name|die_attr
operator|==
name|NULL
condition|)
name|die
operator|->
name|die_attr
operator|=
name|VEC_alloc
argument_list|(
name|dw_attr_node
argument_list|,
name|gc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|dw_attr_node
argument_list|,
name|gc
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|enum
name|dw_val_class
name|AT_class
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
return|;
block|}
end_function

begin_comment
comment|/* Add a flag value attribute to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_flag
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|unsigned
name|int
name|flag
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_flag
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_flag
operator|=
name|flag
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|AT_flag
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_flag
argument_list|)
expr_stmt|;
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_flag
return|;
block|}
end_function

begin_comment
comment|/* Add a signed integer attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_int
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|HOST_WIDE_INT
name|int_val
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_const
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_int
operator|=
name|int_val
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|HOST_WIDE_INT
name|AT_int
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_const
argument_list|)
expr_stmt|;
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_int
return|;
block|}
end_function

begin_comment
comment|/* Add an unsigned integer attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_unsigned
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|unsigned_val
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_unsigned_const
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
operator|=
name|unsigned_val
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|HOST_WIDE_INT
name|AT_unsigned
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_unsigned_const
argument_list|)
expr_stmt|;
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
return|;
block|}
end_function

begin_comment
comment|/* Add an unsigned double integer attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_long_long
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|long
name|unsigned
name|int
name|val_hi
parameter_list|,
name|long
name|unsigned
name|int
name|val_low
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_long_long
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
operator|=
name|val_hi
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
operator|=
name|val_low
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a floating point attribute value to a DIE and return it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_vec
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|unsigned
name|int
name|elt_size
parameter_list|,
name|unsigned
name|char
modifier|*
name|array
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_vec
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_vec
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_vec
operator|.
name|elt_size
operator|=
name|elt_size
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_vec
operator|.
name|array
operator|=
name|array
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hash and equality functions for debug_str_hash.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|debug_str_do_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
return|return
name|htab_hash_string
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|indirect_string_node
operator|*
operator|)
name|x
operator|)
operator|->
name|str
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_str_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|(
operator|(
specifier|const
expr|struct
name|indirect_string_node
operator|*
operator|)
name|x1
operator|)
operator|->
name|str
operator|)
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|x2
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a string attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_string
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|struct
name|indirect_string_node
modifier|*
name|node
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
if|if
condition|(
operator|!
name|debug_str_hash
condition|)
name|debug_str_hash
operator|=
name|htab_create_ggc
argument_list|(
literal|10
argument_list|,
name|debug_str_do_hash
argument_list|,
name|debug_str_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|debug_str_hash
argument_list|,
name|str
argument_list|,
name|htab_hash_string
argument_list|(
name|str
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
operator|*
name|slot
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|indirect_string_node
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
operator|(
expr|struct
name|indirect_string_node
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
name|node
operator|->
name|str
operator|=
name|ggc_strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|node
operator|->
name|refcount
operator|++
expr_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_str
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|=
name|node
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|AT_string
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_str
argument_list|)
expr_stmt|;
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|->
name|str
return|;
block|}
end_function

begin_comment
comment|/* Find out whether a string should be output inline in DIE    or out-of-line in .debug_str section.  */
end_comment

begin_function
specifier|static
name|int
name|AT_string_form
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|struct
name|indirect_string_node
modifier|*
name|node
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|char
name|label
index|[
literal|32
index|]
decl_stmt|;
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_str
argument_list|)
expr_stmt|;
name|node
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|form
condition|)
return|return
name|node
operator|->
name|form
return|;
name|len
operator|=
name|strlen
argument_list|(
name|node
operator|->
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* If the string is shorter or equal to the size of the reference, it is      always better to put it inline.  */
if|if
condition|(
name|len
operator|<=
name|DWARF_OFFSET_SIZE
operator|||
name|node
operator|->
name|refcount
operator|==
literal|0
condition|)
return|return
name|node
operator|->
name|form
operator|=
name|DW_FORM_string
return|;
comment|/* If we cannot expect the linker to merge strings in .debug_str      section, only put it into .debug_str if it is worth even in this      single module.  */
if|if
condition|(
operator|(
name|debug_str_section
operator|->
name|common
operator|.
name|flags
operator|&
name|SECTION_MERGE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|len
operator|-
name|DWARF_OFFSET_SIZE
operator|)
operator|*
name|node
operator|->
name|refcount
operator|<=
name|len
condition|)
return|return
name|node
operator|->
name|form
operator|=
name|DW_FORM_string
return|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LASF"
argument_list|,
name|dw2_string_counter
argument_list|)
expr_stmt|;
operator|++
name|dw2_string_counter
expr_stmt|;
name|node
operator|->
name|label
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|node
operator|->
name|form
operator|=
name|DW_FORM_strp
return|;
block|}
end_function

begin_comment
comment|/* Add a DIE reference attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_die_ref
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|dw_die_ref
name|targ_die
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_die_ref
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|.
name|die
operator|=
name|targ_die
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|.
name|external
operator|=
literal|0
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an AT_specification attribute to a DIE, and also make the back    pointer from the specification to the definition.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_specification
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|dw_die_ref
name|targ_die
parameter_list|)
block|{
name|add_AT_die_ref
argument_list|(
name|die
argument_list|,
name|DW_AT_specification
argument_list|,
name|targ_die
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|targ_die
operator|->
name|die_definition
argument_list|)
expr_stmt|;
name|targ_die
operator|->
name|die_definition
operator|=
name|die
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|AT_ref
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_die_ref
argument_list|)
expr_stmt|;
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|.
name|die
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|AT_ref_external
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_die_ref
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|.
name|external
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|set_AT_ref_external
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_die_ref
argument_list|)
expr_stmt|;
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|.
name|external
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an FDE reference attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_fde_ref
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|unsigned
name|int
name|targ_fde
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_fde_ref
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_fde_index
operator|=
name|targ_fde
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a location description attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_loc
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|dw_loc_descr_ref
name|loc
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_loc
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc
operator|=
name|loc
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dw_loc_descr_ref
name|AT_loc
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_loc
argument_list|)
expr_stmt|;
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_loc_list
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|dw_loc_list_ref
name|loc_list
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_loc_list
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc_list
operator|=
name|loc_list
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
name|have_location_lists
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dw_loc_list_ref
name|AT_loc_list
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_loc_list
argument_list|)
expr_stmt|;
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc_list
return|;
block|}
end_function

begin_comment
comment|/* Add an address constant attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_addr
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|rtx
name|addr
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_addr
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_addr
operator|=
name|addr
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the RTX from to an address DIE attribute.  */
end_comment

begin_function
specifier|static
specifier|inline
name|rtx
name|AT_addr
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_addr
argument_list|)
expr_stmt|;
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_addr
return|;
block|}
end_function

begin_comment
comment|/* Add a file attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_file
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|struct
name|dwarf_file_data
modifier|*
name|fd
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_file
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_file
operator|=
name|fd
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the dwarf_file_data from a file DIE attribute.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|dwarf_file_data
modifier|*
name|AT_file
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_file
argument_list|)
expr_stmt|;
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_file
return|;
block|}
end_function

begin_comment
comment|/* Add a label identifier attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_lbl_id
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
specifier|const
name|char
modifier|*
name|lbl_id
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_lbl_id
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
operator|=
name|xstrdup
argument_list|(
name|lbl_id
argument_list|)
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a section offset attribute value to a DIE, an offset into the    debug_line section.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_lineptr
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_lineptr
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a section offset attribute value to a DIE, an offset into the    debug_macinfo section.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_macptr
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_macptr
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an offset attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_offset
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_offset
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_offset
operator|=
name|offset
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an range_list attribute value to a DIE.  */
end_comment

begin_function
specifier|static
name|void
name|add_AT_range_list
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|long
name|unsigned
name|int
name|offset
parameter_list|)
block|{
name|dw_attr_node
name|attr
decl_stmt|;
name|attr
operator|.
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_range_list
expr_stmt|;
name|attr
operator|.
name|dw_attr_val
operator|.
name|v
operator|.
name|val_offset
operator|=
name|offset
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|AT_lbl
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|a
operator|&&
operator|(
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_lbl_id
operator|||
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_lineptr
operator|||
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_macptr
operator|)
argument_list|)
expr_stmt|;
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
return|;
block|}
end_function

begin_comment
comment|/* Get the attribute of type attr_kind.  */
end_comment

begin_function
specifier|static
name|dw_attr_ref
name|get_AT
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|)
block|{
name|dw_attr_ref
name|a
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|dw_die_ref
name|spec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|die
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a
argument_list|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|a
operator|->
name|dw_attr
operator|==
name|attr_kind
condition|)
return|return
name|a
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|dw_attr
operator|==
name|DW_AT_specification
operator|||
name|a
operator|->
name|dw_attr
operator|==
name|DW_AT_abstract_origin
condition|)
name|spec
operator|=
name|AT_ref
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
return|return
name|get_AT
argument_list|(
name|spec
argument_list|,
name|attr_kind
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the "low pc" attribute value, typically associated with a subprogram    DIE.  Return null if the "low pc" attribute is either not present, or if it    cannot be represented as an assembler label identifier.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|get_AT_low_pc
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_lbl
argument_list|(
name|a
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the "high pc" attribute value, typically associated with a subprogram    DIE.  Return null if the "high pc" attribute is either not present, or if it    cannot be represented as an assembler label identifier.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|get_AT_hi_pc
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|DW_AT_high_pc
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_lbl
argument_list|(
name|a
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the string attribute designated by ATTR_KIND, or    NULL if it is not present.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|get_AT_string
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|)
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_string
argument_list|(
name|a
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the flag attribute designated by ATTR_KIND, or -1    if it is not present.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|get_AT_flag
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|)
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_flag
argument_list|(
name|a
argument_list|)
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the unsigned attribute designated by ATTR_KIND, or 0    if it is not present.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|get_AT_unsigned
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|)
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_unsigned
argument_list|(
name|a
argument_list|)
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|get_AT_ref
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|)
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_ref
argument_list|(
name|a
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|dwarf_file_data
modifier|*
name|get_AT_file
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|)
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_file
argument_list|(
name|a
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the language is C or C++.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_c_family
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|lang
init|=
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
decl_stmt|;
return|return
operator|(
name|lang
operator|==
name|DW_LANG_C
operator|||
name|lang
operator|==
name|DW_LANG_C89
operator|||
name|lang
operator|==
name|DW_LANG_ObjC
operator|||
name|lang
operator|==
name|DW_LANG_C99
operator|||
name|lang
operator|==
name|DW_LANG_C_plus_plus
operator|||
name|lang
operator|==
name|DW_LANG_ObjC_plus_plus
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the language is C++.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_cxx
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|lang
init|=
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
decl_stmt|;
return|return
name|lang
operator|==
name|DW_LANG_C_plus_plus
operator|||
name|lang
operator|==
name|DW_LANG_ObjC_plus_plus
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the language is Fortran.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_fortran
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|lang
init|=
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
decl_stmt|;
return|return
operator|(
name|lang
operator|==
name|DW_LANG_Fortran77
operator|||
name|lang
operator|==
name|DW_LANG_Fortran90
operator|||
name|lang
operator|==
name|DW_LANG_Fortran95
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the language is Java.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_java
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|lang
init|=
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
decl_stmt|;
return|return
name|lang
operator|==
name|DW_LANG_Java
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the language is Ada.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_ada
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|lang
init|=
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
decl_stmt|;
return|return
name|lang
operator|==
name|DW_LANG_Ada95
operator|||
name|lang
operator|==
name|DW_LANG_Ada83
return|;
block|}
end_function

begin_comment
comment|/* Remove the specified attribute if present.  */
end_comment

begin_function
specifier|static
name|void
name|remove_AT
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|)
block|{
name|dw_attr_ref
name|a
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
if|if
condition|(
operator|!
name|die
condition|)
return|return;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a
argument_list|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|a
operator|->
name|dw_attr
operator|==
name|attr_kind
condition|)
block|{
if|if
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_str
condition|)
if|if
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|->
name|refcount
condition|)
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|->
name|refcount
operator|--
expr_stmt|;
comment|/* VEC_ordered_remove should help reduce the number of abbrevs 	   that are needed.  */
name|VEC_ordered_remove
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Remove CHILD from its parent.  PREV must have the property that    PREV->DIE_SIB == CHILD.  Does not alter CHILD.  */
end_comment

begin_function
specifier|static
name|void
name|remove_child_with_prev
parameter_list|(
name|dw_die_ref
name|child
parameter_list|,
name|dw_die_ref
name|prev
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|child
operator|->
name|die_parent
operator|==
name|prev
operator|->
name|die_parent
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|prev
operator|->
name|die_sib
operator|==
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|child
condition|)
block|{
name|gcc_assert
argument_list|(
name|child
operator|->
name|die_parent
operator|->
name|die_child
operator|==
name|child
argument_list|)
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|prev
operator|->
name|die_sib
operator|=
name|child
operator|->
name|die_sib
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|die_parent
operator|->
name|die_child
operator|==
name|child
condition|)
name|child
operator|->
name|die_parent
operator|->
name|die_child
operator|=
name|prev
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove child DIE whose die_tag is TAG.  Do nothing if no child    matches TAG.  */
end_comment

begin_function
specifier|static
name|void
name|remove_child_TAG
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_tag
name|tag
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|c
operator|=
name|die
operator|->
name|die_child
expr_stmt|;
if|if
condition|(
name|c
condition|)
do|do
block|{
name|dw_die_ref
name|prev
init|=
name|c
decl_stmt|;
name|c
operator|=
name|c
operator|->
name|die_sib
expr_stmt|;
while|while
condition|(
name|c
operator|->
name|die_tag
operator|==
name|tag
condition|)
block|{
name|remove_child_with_prev
argument_list|(
name|c
argument_list|,
name|prev
argument_list|)
expr_stmt|;
comment|/* Might have removed every child.  */
if|if
condition|(
name|c
operator|==
name|c
operator|->
name|die_sib
condition|)
return|return;
name|c
operator|=
name|c
operator|->
name|die_sib
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
name|die
operator|->
name|die_child
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Add a CHILD_DIE as the last child of DIE.  */
end_comment

begin_function
specifier|static
name|void
name|add_child_die
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|dw_die_ref
name|child_die
parameter_list|)
block|{
comment|/* FIXME this should probably be an assert.  */
if|if
condition|(
operator|!
name|die
operator|||
operator|!
name|child_die
condition|)
return|return;
name|gcc_assert
argument_list|(
name|die
operator|!=
name|child_die
argument_list|)
expr_stmt|;
name|child_die
operator|->
name|die_parent
operator|=
name|die
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_child
condition|)
block|{
name|child_die
operator|->
name|die_sib
operator|=
name|die
operator|->
name|die_child
operator|->
name|die_sib
expr_stmt|;
name|die
operator|->
name|die_child
operator|->
name|die_sib
operator|=
name|child_die
expr_stmt|;
block|}
else|else
name|child_die
operator|->
name|die_sib
operator|=
name|child_die
expr_stmt|;
name|die
operator|->
name|die_child
operator|=
name|child_die
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move CHILD, which must be a child of PARENT or the DIE for which PARENT    is the specification, to the end of PARENT's list of children.      This is done by removing and re-adding it.  */
end_comment

begin_function
specifier|static
name|void
name|splice_child_die
parameter_list|(
name|dw_die_ref
name|parent
parameter_list|,
name|dw_die_ref
name|child
parameter_list|)
block|{
name|dw_die_ref
name|p
decl_stmt|;
comment|/* We want the declaration DIE from inside the class, not the      specification DIE at toplevel.  */
if|if
condition|(
name|child
operator|->
name|die_parent
operator|!=
name|parent
condition|)
block|{
name|dw_die_ref
name|tmp
init|=
name|get_AT_ref
argument_list|(
name|child
argument_list|,
name|DW_AT_specification
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
name|child
operator|=
name|tmp
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|child
operator|->
name|die_parent
operator|==
name|parent
operator|||
operator|(
name|child
operator|->
name|die_parent
operator|==
name|get_AT_ref
argument_list|(
name|parent
argument_list|,
name|DW_AT_specification
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|child
operator|->
name|die_parent
operator|->
name|die_child
init|;
condition|;
name|p
operator|=
name|p
operator|->
name|die_sib
control|)
if|if
condition|(
name|p
operator|->
name|die_sib
operator|==
name|child
condition|)
block|{
name|remove_child_with_prev
argument_list|(
name|child
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|add_child_die
argument_list|(
name|parent
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a newly created DIE node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|new_die
parameter_list|(
name|enum
name|dwarf_tag
name|tag_value
parameter_list|,
name|dw_die_ref
name|parent_die
parameter_list|,
name|tree
name|t
parameter_list|)
block|{
name|dw_die_ref
name|die
init|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|die_node
argument_list|)
argument_list|)
decl_stmt|;
name|die
operator|->
name|die_tag
operator|=
name|tag_value
expr_stmt|;
if|if
condition|(
name|parent_die
operator|!=
name|NULL
condition|)
name|add_child_die
argument_list|(
name|parent_die
argument_list|,
name|die
argument_list|)
expr_stmt|;
else|else
block|{
name|limbo_die_node
modifier|*
name|limbo_node
decl_stmt|;
name|limbo_node
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|limbo_die_node
argument_list|)
argument_list|)
expr_stmt|;
name|limbo_node
operator|->
name|die
operator|=
name|die
expr_stmt|;
name|limbo_node
operator|->
name|created_for
operator|=
name|t
expr_stmt|;
name|limbo_node
operator|->
name|next
operator|=
name|limbo_die_list
expr_stmt|;
name|limbo_die_list
operator|=
name|limbo_node
expr_stmt|;
block|}
return|return
name|die
return|;
block|}
end_function

begin_comment
comment|/* Return the DIE associated with the given type specifier.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|lookup_type_die
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
name|TYPE_SYMTAB_DIE
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Equate a DIE to a given type specifier.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|equate_type_number_to_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|type_die
parameter_list|)
block|{
name|TYPE_SYMTAB_DIE
argument_list|(
name|type
argument_list|)
operator|=
name|type_die
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns a hash value for X (which really is a die_struct).  */
end_comment

begin_function
specifier|static
name|hashval_t
name|decl_die_table_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
return|return
call|(
name|hashval_t
call|)
argument_list|(
operator|(
specifier|const
name|dw_die_ref
operator|)
name|x
argument_list|)
operator|->
name|decl_id
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if decl_id of die_struct X is the same as UID of decl *Y.  */
end_comment

begin_function
specifier|static
name|int
name|decl_die_table_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
specifier|const
name|dw_die_ref
operator|)
name|x
operator|)
operator|->
name|decl_id
operator|==
name|DECL_UID
argument_list|(
operator|(
specifier|const
name|tree
operator|)
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the DIE associated with a given declaration.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|lookup_decl_die
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|htab_find_with_hash
argument_list|(
name|decl_die_table
argument_list|,
name|decl
argument_list|,
name|DECL_UID
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a hash value for X (which really is a var_loc_list).  */
end_comment

begin_function
specifier|static
name|hashval_t
name|decl_loc_table_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|)
block|{
return|return
call|(
name|hashval_t
call|)
argument_list|(
operator|(
specifier|const
name|var_loc_list
operator|*
operator|)
name|x
argument_list|)
operator|->
name|decl_id
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if decl_id of var_loc_list X is the same as    UID of decl *Y.  */
end_comment

begin_function
specifier|static
name|int
name|decl_loc_table_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|x
parameter_list|,
specifier|const
name|void
modifier|*
name|y
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
specifier|const
name|var_loc_list
operator|*
operator|)
name|x
operator|)
operator|->
name|decl_id
operator|==
name|DECL_UID
argument_list|(
operator|(
specifier|const
name|tree
operator|)
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the var_loc list associated with a given declaration.  */
end_comment

begin_function
specifier|static
specifier|inline
name|var_loc_list
modifier|*
name|lookup_decl_loc
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
name|htab_find_with_hash
argument_list|(
name|decl_loc_table
argument_list|,
name|decl
argument_list|,
name|DECL_UID
argument_list|(
name|decl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Equate a DIE to a particular declaration.  */
end_comment

begin_function
specifier|static
name|void
name|equate_decl_number_to_die
parameter_list|(
name|tree
name|decl
parameter_list|,
name|dw_die_ref
name|decl_die
parameter_list|)
block|{
name|unsigned
name|int
name|decl_id
init|=
name|DECL_UID
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|decl_die_table
argument_list|,
name|decl
argument_list|,
name|decl_id
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|decl_die
expr_stmt|;
name|decl_die
operator|->
name|decl_id
operator|=
name|decl_id
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a variable location node to the linked list for DECL.  */
end_comment

begin_function
specifier|static
name|void
name|add_var_loc_to_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|struct
name|var_loc_node
modifier|*
name|loc
parameter_list|)
block|{
name|unsigned
name|int
name|decl_id
init|=
name|DECL_UID
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|var_loc_list
modifier|*
name|temp
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|decl_loc_table
argument_list|,
name|decl
argument_list|,
name|decl_id
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
name|temp
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|var_loc_list
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|decl_id
operator|=
name|decl_id
expr_stmt|;
operator|*
name|slot
operator|=
name|temp
expr_stmt|;
block|}
else|else
name|temp
operator|=
operator|*
name|slot
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|last
condition|)
block|{
comment|/* If the current location is the same as the end of the list, 	 we have nothing to do.  */
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|NOTE_VAR_LOCATION_LOC
argument_list|(
name|temp
operator|->
name|last
operator|->
name|var_loc_note
argument_list|)
argument_list|,
name|NOTE_VAR_LOCATION_LOC
argument_list|(
name|loc
operator|->
name|var_loc_note
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Add LOC to the end of list and update LAST.  */
name|temp
operator|->
name|last
operator|->
name|next
operator|=
name|loc
expr_stmt|;
name|temp
operator|->
name|last
operator|=
name|loc
expr_stmt|;
block|}
block|}
comment|/* Do not add empty location to the beginning of the list.  */
elseif|else
if|if
condition|(
name|NOTE_VAR_LOCATION_LOC
argument_list|(
name|loc
operator|->
name|var_loc_note
argument_list|)
operator|!=
name|NULL_RTX
condition|)
block|{
name|temp
operator|->
name|first
operator|=
name|loc
expr_stmt|;
name|temp
operator|->
name|last
operator|=
name|loc
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keep track of the number of spaces used to indent the    output of the debugging routines that print the structure of    the DIE internal representation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_indent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indent the line the number of spaces given by print_indent.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|print_spaces
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%*s"
argument_list|,
name|print_indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the information associated with a given DIE, and its children.    This routine is a debugging aid only.  */
end_comment

begin_function
specifier|static
name|void
name|print_die
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|FILE
modifier|*
name|outfile
parameter_list|)
block|{
name|dw_attr_ref
name|a
decl_stmt|;
name|dw_die_ref
name|c
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|print_spaces
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"DIE %4lu: %s\n"
argument_list|,
name|die
operator|->
name|die_offset
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|die_tag
argument_list|)
argument_list|)
expr_stmt|;
name|print_spaces
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  abbrev id: %lu"
argument_list|,
name|die
operator|->
name|die_abbrev
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" offset: %lu\n"
argument_list|,
name|die
operator|->
name|die_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
name|print_spaces
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  %s: "
argument_list|,
name|dwarf_attr_name
argument_list|(
name|a
operator|->
name|dw_attr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_offset
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"offset"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"location descriptor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc_list
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"location list -> label:%s"
argument_list|,
name|AT_loc_list
argument_list|(
name|a
argument_list|)
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_range_list
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"range list"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_const
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|AT_int
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_unsigned_const
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|AT_unsigned
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_long_long
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"constant (%lu,%lu)"
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_vec
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"floating-point or vector constant"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_flag
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%u"
argument_list|,
name|AT_flag
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_die_ref
case|:
if|if
condition|(
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_symbol
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"die -> label: %s"
argument_list|,
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_symbol
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"die -> %lu"
argument_list|,
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"die -><null>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_lbl_id
case|:
case|case
name|dw_val_class_lineptr
case|:
case|case
name|dw_val_class_macptr
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"label: %s"
argument_list|,
name|AT_lbl
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_str
case|:
if|if
condition|(
name|AT_string
argument_list|(
name|a
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\"%s\""
argument_list|,
name|AT_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"<null>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_file
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\"%s\" (%d)"
argument_list|,
name|AT_file
argument_list|(
name|a
argument_list|)
operator|->
name|filename
argument_list|,
name|AT_file
argument_list|(
name|a
argument_list|)
operator|->
name|emitted_number
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
condition|)
block|{
name|print_indent
operator|+=
literal|4
expr_stmt|;
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|print_die
argument_list|(
name|c
argument_list|,
name|outfile
argument_list|)
argument_list|)
expr_stmt|;
name|print_indent
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|print_indent
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the contents of the source code line number correspondence table.    This routine is a debugging aid only.  */
end_comment

begin_function
specifier|static
name|void
name|print_dwarf_line_table
parameter_list|(
name|FILE
modifier|*
name|outfile
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|dw_line_info_ref
name|line_info
decl_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n\nDWARF source line information\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|line_info_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|line_info
operator|=
operator|&
name|line_info_table
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%5d: %4ld %6ld\n"
argument_list|,
name|i
argument_list|,
name|line_info
operator|->
name|dw_file_num
argument_list|,
name|line_info
operator|->
name|dw_line_num
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the information collected for a given DIE.  */
end_comment

begin_function
name|void
name|debug_dwarf_die
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|print_die
argument_list|(
name|die
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print all DWARF information collected for the compilation unit.    This routine is a debugging aid only.  */
end_comment

begin_function
name|void
name|debug_dwarf
parameter_list|(
name|void
parameter_list|)
block|{
name|print_indent
operator|=
literal|0
expr_stmt|;
name|print_die
argument_list|(
name|comp_unit_die
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DWARF2_ASM_LINE_DEBUG_INFO
condition|)
name|print_dwarf_line_table
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a new compilation unit DIE for an include file.  OLD_UNIT is the CU    for the enclosing include file, if any.  BINCL_DIE is the DW_TAG_GNU_BINCL    DIE that marks the start of the DIEs for this include file.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|push_new_compile_unit
parameter_list|(
name|dw_die_ref
name|old_unit
parameter_list|,
name|dw_die_ref
name|bincl_die
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|get_AT_string
argument_list|(
name|bincl_die
argument_list|,
name|DW_AT_name
argument_list|)
decl_stmt|;
name|dw_die_ref
name|new_unit
init|=
name|gen_compile_unit_die
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|new_unit
operator|->
name|die_sib
operator|=
name|old_unit
expr_stmt|;
return|return
name|new_unit
return|;
block|}
end_function

begin_comment
comment|/* Close an include-file CU and reopen the enclosing one.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|pop_compile_unit
parameter_list|(
name|dw_die_ref
name|old_unit
parameter_list|)
block|{
name|dw_die_ref
name|new_unit
init|=
name|old_unit
operator|->
name|die_sib
decl_stmt|;
name|old_unit
operator|->
name|die_sib
operator|=
name|NULL
expr_stmt|;
return|return
name|new_unit
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CHECKSUM
parameter_list|(
name|FOO
parameter_list|)
value|md5_process_bytes (&(FOO), sizeof (FOO), ctx)
end_define

begin_define
define|#
directive|define
name|CHECKSUM_STRING
parameter_list|(
name|FOO
parameter_list|)
value|md5_process_bytes ((FOO), strlen (FOO), ctx)
end_define

begin_comment
comment|/* Calculate the checksum of a location expression.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|loc_checksum
parameter_list|(
name|dw_loc_descr_ref
name|loc
parameter_list|,
name|struct
name|md5_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|CHECKSUM
argument_list|(
name|loc
operator|->
name|dw_loc_opc
argument_list|)
expr_stmt|;
name|CHECKSUM
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
argument_list|)
expr_stmt|;
name|CHECKSUM
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate the checksum of an attribute.  */
end_comment

begin_function
specifier|static
name|void
name|attr_checksum
parameter_list|(
name|dw_attr_ref
name|at
parameter_list|,
name|struct
name|md5_ctx
modifier|*
name|ctx
parameter_list|,
name|int
modifier|*
name|mark
parameter_list|)
block|{
name|dw_loc_descr_ref
name|loc
decl_stmt|;
name|rtx
name|r
decl_stmt|;
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr
argument_list|)
expr_stmt|;
comment|/* We don't care that this was compiled with a different compiler      snapshot; if the output is the same, that's what matters.  */
if|if
condition|(
name|at
operator|->
name|dw_attr
operator|==
name|DW_AT_producer
condition|)
return|return;
switch|switch
condition|(
name|AT_class
argument_list|(
name|at
argument_list|)
condition|)
block|{
case|case
name|dw_val_class_const
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_unsigned_const
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_long_long
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_vec
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_vec
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_flag
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_flag
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_str
case|:
name|CHECKSUM_STRING
argument_list|(
name|AT_string
argument_list|(
name|at
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_addr
case|:
name|r
operator|=
name|AT_addr
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|SYMBOL_REF
argument_list|)
expr_stmt|;
name|CHECKSUM_STRING
argument_list|(
name|XSTR
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_offset
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc
case|:
for|for
control|(
name|loc
operator|=
name|AT_loc
argument_list|(
name|at
argument_list|)
init|;
name|loc
condition|;
name|loc
operator|=
name|loc
operator|->
name|dw_loc_next
control|)
name|loc_checksum
argument_list|(
name|loc
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_die_ref
case|:
name|die_checksum
argument_list|(
name|AT_ref
argument_list|(
name|at
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|mark
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_fde_ref
case|:
case|case
name|dw_val_class_lbl_id
case|:
case|case
name|dw_val_class_lineptr
case|:
case|case
name|dw_val_class_macptr
case|:
break|break;
case|case
name|dw_val_class_file
case|:
name|CHECKSUM_STRING
argument_list|(
name|AT_file
argument_list|(
name|at
argument_list|)
operator|->
name|filename
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Calculate the checksum of a DIE.  */
end_comment

begin_function
specifier|static
name|void
name|die_checksum
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|struct
name|md5_ctx
modifier|*
name|ctx
parameter_list|,
name|int
modifier|*
name|mark
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|dw_attr_ref
name|a
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
comment|/* To avoid infinite recursion.  */
if|if
condition|(
name|die
operator|->
name|die_mark
condition|)
block|{
name|CHECKSUM
argument_list|(
name|die
operator|->
name|die_mark
argument_list|)
expr_stmt|;
return|return;
block|}
name|die
operator|->
name|die_mark
operator|=
operator|++
operator|(
operator|*
name|mark
operator|)
expr_stmt|;
name|CHECKSUM
argument_list|(
name|die
operator|->
name|die_tag
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a
argument_list|)
condition|;
name|ix
operator|++
control|)
name|attr_checksum
argument_list|(
name|a
argument_list|,
name|ctx
argument_list|,
name|mark
argument_list|)
expr_stmt|;
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|die_checksum
argument_list|(
name|c
argument_list|,
name|ctx
argument_list|,
name|mark
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|CHECKSUM
end_undef

begin_undef
undef|#
directive|undef
name|CHECKSUM_STRING
end_undef

begin_comment
comment|/* Do the location expressions look same?  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|same_loc_p
parameter_list|(
name|dw_loc_descr_ref
name|loc1
parameter_list|,
name|dw_loc_descr_ref
name|loc2
parameter_list|,
name|int
modifier|*
name|mark
parameter_list|)
block|{
return|return
name|loc1
operator|->
name|dw_loc_opc
operator|==
name|loc2
operator|->
name|dw_loc_opc
operator|&&
name|same_dw_val_p
argument_list|(
operator|&
name|loc1
operator|->
name|dw_loc_oprnd1
argument_list|,
operator|&
name|loc2
operator|->
name|dw_loc_oprnd1
argument_list|,
name|mark
argument_list|)
operator|&&
name|same_dw_val_p
argument_list|(
operator|&
name|loc1
operator|->
name|dw_loc_oprnd2
argument_list|,
operator|&
name|loc2
operator|->
name|dw_loc_oprnd2
argument_list|,
name|mark
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do the values look the same?  */
end_comment

begin_function
specifier|static
name|int
name|same_dw_val_p
parameter_list|(
name|dw_val_node
modifier|*
name|v1
parameter_list|,
name|dw_val_node
modifier|*
name|v2
parameter_list|,
name|int
modifier|*
name|mark
parameter_list|)
block|{
name|dw_loc_descr_ref
name|loc1
decl_stmt|,
name|loc2
decl_stmt|;
name|rtx
name|r1
decl_stmt|,
name|r2
decl_stmt|;
if|if
condition|(
name|v1
operator|->
name|val_class
operator|!=
name|v2
operator|->
name|val_class
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|v1
operator|->
name|val_class
condition|)
block|{
case|case
name|dw_val_class_const
case|:
return|return
name|v1
operator|->
name|v
operator|.
name|val_int
operator|==
name|v2
operator|->
name|v
operator|.
name|val_int
return|;
case|case
name|dw_val_class_unsigned_const
case|:
return|return
name|v1
operator|->
name|v
operator|.
name|val_unsigned
operator|==
name|v2
operator|->
name|v
operator|.
name|val_unsigned
return|;
case|case
name|dw_val_class_long_long
case|:
return|return
name|v1
operator|->
name|v
operator|.
name|val_long_long
operator|.
name|hi
operator|==
name|v2
operator|->
name|v
operator|.
name|val_long_long
operator|.
name|hi
operator|&&
name|v1
operator|->
name|v
operator|.
name|val_long_long
operator|.
name|low
operator|==
name|v2
operator|->
name|v
operator|.
name|val_long_long
operator|.
name|low
return|;
case|case
name|dw_val_class_vec
case|:
if|if
condition|(
name|v1
operator|->
name|v
operator|.
name|val_vec
operator|.
name|length
operator|!=
name|v2
operator|->
name|v
operator|.
name|val_vec
operator|.
name|length
operator|||
name|v1
operator|->
name|v
operator|.
name|val_vec
operator|.
name|elt_size
operator|!=
name|v2
operator|->
name|v
operator|.
name|val_vec
operator|.
name|elt_size
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|v1
operator|->
name|v
operator|.
name|val_vec
operator|.
name|array
argument_list|,
name|v2
operator|->
name|v
operator|.
name|val_vec
operator|.
name|array
argument_list|,
name|v1
operator|->
name|v
operator|.
name|val_vec
operator|.
name|length
operator|*
name|v1
operator|->
name|v
operator|.
name|val_vec
operator|.
name|elt_size
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
case|case
name|dw_val_class_flag
case|:
return|return
name|v1
operator|->
name|v
operator|.
name|val_flag
operator|==
name|v2
operator|->
name|v
operator|.
name|val_flag
return|;
case|case
name|dw_val_class_str
case|:
return|return
operator|!
name|strcmp
argument_list|(
name|v1
operator|->
name|v
operator|.
name|val_str
operator|->
name|str
argument_list|,
name|v2
operator|->
name|v
operator|.
name|val_str
operator|->
name|str
argument_list|)
return|;
case|case
name|dw_val_class_addr
case|:
name|r1
operator|=
name|v1
operator|->
name|v
operator|.
name|val_addr
expr_stmt|;
name|r2
operator|=
name|v2
operator|->
name|v
operator|.
name|val_addr
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|!=
name|GET_CODE
argument_list|(
name|r2
argument_list|)
condition|)
return|return
literal|0
return|;
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|r1
argument_list|)
operator|==
name|SYMBOL_REF
argument_list|)
expr_stmt|;
return|return
operator|!
name|strcmp
argument_list|(
name|XSTR
argument_list|(
name|r1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XSTR
argument_list|(
name|r2
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|dw_val_class_offset
case|:
return|return
name|v1
operator|->
name|v
operator|.
name|val_offset
operator|==
name|v2
operator|->
name|v
operator|.
name|val_offset
return|;
case|case
name|dw_val_class_loc
case|:
for|for
control|(
name|loc1
operator|=
name|v1
operator|->
name|v
operator|.
name|val_loc
operator|,
name|loc2
operator|=
name|v2
operator|->
name|v
operator|.
name|val_loc
init|;
name|loc1
operator|&&
name|loc2
condition|;
name|loc1
operator|=
name|loc1
operator|->
name|dw_loc_next
operator|,
name|loc2
operator|=
name|loc2
operator|->
name|dw_loc_next
control|)
if|if
condition|(
operator|!
name|same_loc_p
argument_list|(
name|loc1
argument_list|,
name|loc2
argument_list|,
name|mark
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|loc1
operator|&&
operator|!
name|loc2
return|;
case|case
name|dw_val_class_die_ref
case|:
return|return
name|same_die_p
argument_list|(
name|v1
operator|->
name|v
operator|.
name|val_die_ref
operator|.
name|die
argument_list|,
name|v2
operator|->
name|v
operator|.
name|val_die_ref
operator|.
name|die
argument_list|,
name|mark
argument_list|)
return|;
case|case
name|dw_val_class_fde_ref
case|:
case|case
name|dw_val_class_lbl_id
case|:
case|case
name|dw_val_class_lineptr
case|:
case|case
name|dw_val_class_macptr
case|:
return|return
literal|1
return|;
case|case
name|dw_val_class_file
case|:
return|return
name|v1
operator|->
name|v
operator|.
name|val_file
operator|==
name|v2
operator|->
name|v
operator|.
name|val_file
return|;
default|default:
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Do the attributes look the same?  */
end_comment

begin_function
specifier|static
name|int
name|same_attr_p
parameter_list|(
name|dw_attr_ref
name|at1
parameter_list|,
name|dw_attr_ref
name|at2
parameter_list|,
name|int
modifier|*
name|mark
parameter_list|)
block|{
if|if
condition|(
name|at1
operator|->
name|dw_attr
operator|!=
name|at2
operator|->
name|dw_attr
condition|)
return|return
literal|0
return|;
comment|/* We don't care that this was compiled with a different compiler      snapshot; if the output is the same, that's what matters. */
if|if
condition|(
name|at1
operator|->
name|dw_attr
operator|==
name|DW_AT_producer
condition|)
return|return
literal|1
return|;
return|return
name|same_dw_val_p
argument_list|(
operator|&
name|at1
operator|->
name|dw_attr_val
argument_list|,
operator|&
name|at2
operator|->
name|dw_attr_val
argument_list|,
name|mark
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do the dies look the same?  */
end_comment

begin_function
specifier|static
name|int
name|same_die_p
parameter_list|(
name|dw_die_ref
name|die1
parameter_list|,
name|dw_die_ref
name|die2
parameter_list|,
name|int
modifier|*
name|mark
parameter_list|)
block|{
name|dw_die_ref
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|dw_attr_ref
name|a1
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
comment|/* To avoid infinite recursion.  */
if|if
condition|(
name|die1
operator|->
name|die_mark
condition|)
return|return
name|die1
operator|->
name|die_mark
operator|==
name|die2
operator|->
name|die_mark
return|;
name|die1
operator|->
name|die_mark
operator|=
name|die2
operator|->
name|die_mark
operator|=
operator|++
operator|(
operator|*
name|mark
operator|)
expr_stmt|;
if|if
condition|(
name|die1
operator|->
name|die_tag
operator|!=
name|die2
operator|->
name|die_tag
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|VEC_length
argument_list|(
name|dw_attr_node
argument_list|,
name|die1
operator|->
name|die_attr
argument_list|)
operator|!=
name|VEC_length
argument_list|(
name|dw_attr_node
argument_list|,
name|die2
operator|->
name|die_attr
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die1
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a1
argument_list|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
operator|!
name|same_attr_p
argument_list|(
name|a1
argument_list|,
name|VEC_index
argument_list|(
name|dw_attr_node
argument_list|,
name|die2
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|)
argument_list|,
name|mark
argument_list|)
condition|)
return|return
literal|0
return|;
name|c1
operator|=
name|die1
operator|->
name|die_child
expr_stmt|;
name|c2
operator|=
name|die2
operator|->
name|die_child
expr_stmt|;
if|if
condition|(
operator|!
name|c1
condition|)
block|{
if|if
condition|(
name|c2
condition|)
return|return
literal|0
return|;
block|}
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|same_die_p
argument_list|(
name|c1
argument_list|,
name|c2
argument_list|,
name|mark
argument_list|)
condition|)
return|return
literal|0
return|;
name|c1
operator|=
name|c1
operator|->
name|die_sib
expr_stmt|;
name|c2
operator|=
name|c2
operator|->
name|die_sib
expr_stmt|;
if|if
condition|(
name|c1
operator|==
name|die1
operator|->
name|die_child
condition|)
block|{
if|if
condition|(
name|c2
operator|==
name|die2
operator|->
name|die_child
condition|)
break|break;
else|else
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Do the dies look the same?  Wrapper around same_die_p.  */
end_comment

begin_function
specifier|static
name|int
name|same_die_p_wrap
parameter_list|(
name|dw_die_ref
name|die1
parameter_list|,
name|dw_die_ref
name|die2
parameter_list|)
block|{
name|int
name|mark
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
name|same_die_p
argument_list|(
name|die1
argument_list|,
name|die2
argument_list|,
operator|&
name|mark
argument_list|)
decl_stmt|;
name|unmark_all_dies
argument_list|(
name|die1
argument_list|)
expr_stmt|;
name|unmark_all_dies
argument_list|(
name|die2
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* The prefix to attach to symbols on DIEs in the current comdat debug    info section.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|comdat_symbol_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index of the current symbol within the current comdat CU.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|comdat_symbol_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Calculate the MD5 checksum of the compilation unit DIE UNIT_DIE and its    children, and set comdat_symbol_id accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|compute_section_prefix
parameter_list|(
name|dw_die_ref
name|unit_die
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|die_name
init|=
name|get_AT_string
argument_list|(
name|unit_die
argument_list|,
name|DW_AT_name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|base
init|=
name|die_name
condition|?
name|lbasename
argument_list|(
name|die_name
argument_list|)
else|:
literal|"anonymous"
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|base
argument_list|)
operator|+
literal|64
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mark
decl_stmt|;
name|unsigned
name|char
name|checksum
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|md5_ctx
name|ctx
decl_stmt|;
comment|/* Compute the checksum of the DIE, then append part of it as hex digits to      the name filename of the unit.  */
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|mark
operator|=
literal|0
expr_stmt|;
name|die_checksum
argument_list|(
name|unit_die
argument_list|,
operator|&
name|ctx
argument_list|,
operator|&
name|mark
argument_list|)
expr_stmt|;
name|unmark_all_dies
argument_list|(
name|unit_die
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s."
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|clean_symbol_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%.2x"
argument_list|,
name|checksum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|comdat_symbol_id
operator|=
name|unit_die
operator|->
name|die_symbol
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|comdat_symbol_number
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if DIE represents a type, in the sense of TYPE_P.  */
end_comment

begin_function
specifier|static
name|int
name|is_type_die
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
switch|switch
condition|(
name|die
operator|->
name|die_tag
condition|)
block|{
case|case
name|DW_TAG_array_type
case|:
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_enumeration_type
case|:
case|case
name|DW_TAG_pointer_type
case|:
case|case
name|DW_TAG_reference_type
case|:
case|case
name|DW_TAG_string_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_subroutine_type
case|:
case|case
name|DW_TAG_union_type
case|:
case|case
name|DW_TAG_ptr_to_member_type
case|:
case|case
name|DW_TAG_set_type
case|:
case|case
name|DW_TAG_subrange_type
case|:
case|case
name|DW_TAG_base_type
case|:
case|case
name|DW_TAG_const_type
case|:
case|case
name|DW_TAG_file_type
case|:
case|case
name|DW_TAG_packed_type
case|:
case|case
name|DW_TAG_volatile_type
case|:
case|case
name|DW_TAG_typedef
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns 1 iff C is the sort of DIE that should go into a COMDAT CU.    Basically, we want to choose the bits that are likely to be shared between    compilations (types) and leave out the bits that are specific to individual    compilations (functions).  */
end_comment

begin_function
specifier|static
name|int
name|is_comdat_die
parameter_list|(
name|dw_die_ref
name|c
parameter_list|)
block|{
comment|/* I think we want to leave base types and __vtbl_ptr_type in the main CU, as      we do for stabs.  The advantage is a greater likelihood of sharing between      objects that don't include headers in the same order (and therefore would      put the base types in a different comdat).  jason 8/28/00 */
if|if
condition|(
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_base_type
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_pointer_type
operator|||
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_reference_type
operator|||
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_const_type
operator|||
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_volatile_type
condition|)
block|{
name|dw_die_ref
name|t
init|=
name|get_AT_ref
argument_list|(
name|c
argument_list|,
name|DW_AT_type
argument_list|)
decl_stmt|;
return|return
name|t
condition|?
name|is_comdat_die
argument_list|(
name|t
argument_list|)
else|:
literal|0
return|;
block|}
return|return
name|is_type_die
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 iff C is the sort of DIE that might be referred to from another    compilation unit.  */
end_comment

begin_function
specifier|static
name|int
name|is_symbol_die
parameter_list|(
name|dw_die_ref
name|c
parameter_list|)
block|{
return|return
operator|(
name|is_type_die
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|get_AT
argument_list|(
name|c
argument_list|,
name|DW_AT_declaration
argument_list|)
operator|&&
operator|!
name|get_AT
argument_list|(
name|c
argument_list|,
name|DW_AT_specification
argument_list|)
operator|)
operator|||
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_namespace
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|gen_internal_sym
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
name|prefix
argument_list|,
name|label_num
operator|++
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Assign symbols to all worthy DIEs under DIE.  */
end_comment

begin_function
specifier|static
name|void
name|assign_symbol_names
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
if|if
condition|(
name|is_symbol_die
argument_list|(
name|die
argument_list|)
condition|)
block|{
if|if
condition|(
name|comdat_symbol_id
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|comdat_symbol_id
argument_list|)
operator|+
literal|64
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s.%s.%x"
argument_list|,
name|DIE_LABEL_PREFIX
argument_list|,
name|comdat_symbol_id
argument_list|,
name|comdat_symbol_number
operator|++
argument_list|)
expr_stmt|;
name|die
operator|->
name|die_symbol
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|die
operator|->
name|die_symbol
operator|=
name|gen_internal_sym
argument_list|(
literal|"LDIE"
argument_list|)
expr_stmt|;
block|}
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|assign_symbol_names
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|cu_hash_table_entry
block|{
name|dw_die_ref
name|cu
decl_stmt|;
name|unsigned
name|min_comdat_num
decl_stmt|,
name|max_comdat_num
decl_stmt|;
name|struct
name|cu_hash_table_entry
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Routines to manipulate hash table of CUs.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|htab_cu_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|of
parameter_list|)
block|{
specifier|const
name|struct
name|cu_hash_table_entry
modifier|*
name|entry
init|=
name|of
decl_stmt|;
return|return
name|htab_hash_string
argument_list|(
name|entry
operator|->
name|cu
operator|->
name|die_symbol
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|htab_cu_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|of1
parameter_list|,
specifier|const
name|void
modifier|*
name|of2
parameter_list|)
block|{
specifier|const
name|struct
name|cu_hash_table_entry
modifier|*
name|entry1
init|=
name|of1
decl_stmt|;
specifier|const
name|struct
name|die_struct
modifier|*
name|entry2
init|=
name|of2
decl_stmt|;
return|return
operator|!
name|strcmp
argument_list|(
name|entry1
operator|->
name|cu
operator|->
name|die_symbol
argument_list|,
name|entry2
operator|->
name|die_symbol
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|htab_cu_del
parameter_list|(
name|void
modifier|*
name|what
parameter_list|)
block|{
name|struct
name|cu_hash_table_entry
modifier|*
name|next
decl_stmt|,
modifier|*
name|entry
init|=
name|what
decl_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
name|next
operator|=
name|entry
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check whether we have already seen this CU and set up SYM_NUM    accordingly.  */
end_comment

begin_function
specifier|static
name|int
name|check_duplicate_cu
parameter_list|(
name|dw_die_ref
name|cu
parameter_list|,
name|htab_t
name|htable
parameter_list|,
name|unsigned
name|int
modifier|*
name|sym_num
parameter_list|)
block|{
name|struct
name|cu_hash_table_entry
name|dummy
decl_stmt|;
name|struct
name|cu_hash_table_entry
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|entry
decl_stmt|,
modifier|*
name|last
init|=
operator|&
name|dummy
decl_stmt|;
name|dummy
operator|.
name|max_comdat_num
operator|=
literal|0
expr_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|cu_hash_table_entry
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|htable
argument_list|,
name|cu
argument_list|,
name|htab_hash_string
argument_list|(
name|cu
operator|->
name|die_symbol
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|*
name|slot
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|last
operator|=
name|entry
operator|,
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
if|if
condition|(
name|same_die_p_wrap
argument_list|(
name|cu
argument_list|,
name|entry
operator|->
name|cu
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|entry
condition|)
block|{
operator|*
name|sym_num
operator|=
name|entry
operator|->
name|min_comdat_num
expr_stmt|;
return|return
literal|1
return|;
block|}
name|entry
operator|=
name|XCNEW
argument_list|(
expr|struct
name|cu_hash_table_entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|cu
operator|=
name|cu
expr_stmt|;
name|entry
operator|->
name|min_comdat_num
operator|=
operator|*
name|sym_num
operator|=
name|last
operator|->
name|max_comdat_num
expr_stmt|;
name|entry
operator|->
name|next
operator|=
operator|*
name|slot
expr_stmt|;
operator|*
name|slot
operator|=
name|entry
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record SYM_NUM to record of CU in HTABLE.  */
end_comment

begin_function
specifier|static
name|void
name|record_comdat_symbol_number
parameter_list|(
name|dw_die_ref
name|cu
parameter_list|,
name|htab_t
name|htable
parameter_list|,
name|unsigned
name|int
name|sym_num
parameter_list|)
block|{
name|struct
name|cu_hash_table_entry
modifier|*
modifier|*
name|slot
decl_stmt|,
modifier|*
name|entry
decl_stmt|;
name|slot
operator|=
operator|(
expr|struct
name|cu_hash_table_entry
operator|*
operator|*
operator|)
name|htab_find_slot_with_hash
argument_list|(
name|htable
argument_list|,
name|cu
argument_list|,
name|htab_hash_string
argument_list|(
name|cu
operator|->
name|die_symbol
argument_list|)
argument_list|,
name|NO_INSERT
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|*
name|slot
expr_stmt|;
name|entry
operator|->
name|max_comdat_num
operator|=
name|sym_num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Traverse the DIE (which is always comp_unit_die), and set up    additional compilation units for each of the include files we see    bracketed by BINCL/EINCL.  */
end_comment

begin_function
specifier|static
name|void
name|break_out_includes
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|dw_die_ref
name|unit
init|=
name|NULL
decl_stmt|;
name|limbo_die_node
modifier|*
name|node
decl_stmt|,
modifier|*
modifier|*
name|pnode
decl_stmt|;
name|htab_t
name|cu_hash_table
decl_stmt|;
name|c
operator|=
name|die
operator|->
name|die_child
expr_stmt|;
if|if
condition|(
name|c
condition|)
do|do
block|{
name|dw_die_ref
name|prev
init|=
name|c
decl_stmt|;
name|c
operator|=
name|c
operator|->
name|die_sib
expr_stmt|;
while|while
condition|(
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_GNU_BINCL
operator|||
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_GNU_EINCL
operator|||
operator|(
name|unit
operator|&&
name|is_comdat_die
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|dw_die_ref
name|next
init|=
name|c
operator|->
name|die_sib
decl_stmt|;
comment|/* This DIE is for a secondary CU; remove it from the main one.  */
name|remove_child_with_prev
argument_list|(
name|c
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_GNU_BINCL
condition|)
name|unit
operator|=
name|push_new_compile_unit
argument_list|(
name|unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_GNU_EINCL
condition|)
name|unit
operator|=
name|pop_compile_unit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
else|else
name|add_child_die
argument_list|(
name|unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|die
operator|->
name|die_child
condition|)
break|break;
block|}
block|}
do|while
condition|(
name|c
operator|!=
name|die
operator|->
name|die_child
condition|)
do|;
if|#
directive|if
literal|0
comment|/* We can only use this in debugging, since the frontend doesn't check      to make sure that we leave every include file we enter.  */
block|gcc_assert (!unit);
endif|#
directive|endif
name|assign_symbol_names
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|cu_hash_table
operator|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|htab_cu_hash
argument_list|,
name|htab_cu_eq
argument_list|,
name|htab_cu_del
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|limbo_die_list
operator|,
name|pnode
operator|=
operator|&
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|int
name|is_dupl
decl_stmt|;
name|compute_section_prefix
argument_list|(
name|node
operator|->
name|die
argument_list|)
expr_stmt|;
name|is_dupl
operator|=
name|check_duplicate_cu
argument_list|(
name|node
operator|->
name|die
argument_list|,
name|cu_hash_table
argument_list|,
operator|&
name|comdat_symbol_number
argument_list|)
expr_stmt|;
name|assign_symbol_names
argument_list|(
name|node
operator|->
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_dupl
condition|)
operator|*
name|pnode
operator|=
name|node
operator|->
name|next
expr_stmt|;
else|else
block|{
name|pnode
operator|=
operator|&
name|node
operator|->
name|next
expr_stmt|;
name|record_comdat_symbol_number
argument_list|(
name|node
operator|->
name|die
argument_list|,
name|cu_hash_table
argument_list|,
name|comdat_symbol_number
argument_list|)
expr_stmt|;
block|}
block|}
name|htab_delete
argument_list|(
name|cu_hash_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Traverse the DIE and add a sibling attribute if it may have the    effect of speeding up access to siblings.  To save some space,    avoid generating sibling attributes for DIE's without children.  */
end_comment

begin_function
specifier|static
name|void
name|add_sibling_attributes
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|die
operator|->
name|die_child
condition|)
return|return;
if|if
condition|(
name|die
operator|->
name|die_parent
operator|&&
name|die
operator|!=
name|die
operator|->
name|die_parent
operator|->
name|die_child
condition|)
name|add_AT_die_ref
argument_list|(
name|die
argument_list|,
name|DW_AT_sibling
argument_list|,
name|die
operator|->
name|die_sib
argument_list|)
expr_stmt|;
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|add_sibling_attributes
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output all location lists for the DIE and its children.  */
end_comment

begin_function
specifier|static
name|void
name|output_location_lists
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|dw_attr_ref
name|a
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a
argument_list|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_loc_list
condition|)
name|output_loc_list
argument_list|(
name|AT_loc_list
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|output_location_lists
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The format of each DIE (and its attribute value pairs) is encoded in an    abbreviation table.  This routine builds the abbreviation table and assigns    a unique abbreviation id for each abbreviation entry.  The children of each    die are visited recursively.  */
end_comment

begin_function
specifier|static
name|void
name|build_abbrev_table
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|unsigned
name|long
name|abbrev_id
decl_stmt|;
name|unsigned
name|int
name|n_alloc
decl_stmt|;
name|dw_die_ref
name|c
decl_stmt|;
name|dw_attr_ref
name|a
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
comment|/* Scan the DIE references, and mark as external any that refer to      DIEs from other CUs (i.e. those which are not marked).  */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a
argument_list|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_die_ref
operator|&&
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_mark
operator|==
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_symbol
argument_list|)
expr_stmt|;
name|set_AT_ref_external
argument_list|(
name|a
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|abbrev_id
operator|=
literal|1
init|;
name|abbrev_id
operator|<
name|abbrev_die_table_in_use
condition|;
operator|++
name|abbrev_id
control|)
block|{
name|dw_die_ref
name|abbrev
init|=
name|abbrev_die_table
index|[
name|abbrev_id
index|]
decl_stmt|;
name|dw_attr_ref
name|die_a
decl_stmt|,
name|abbrev_a
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|bool
name|ok
init|=
name|true
decl_stmt|;
if|if
condition|(
name|abbrev
operator|->
name|die_tag
operator|!=
name|die
operator|->
name|die_tag
condition|)
continue|continue;
if|if
condition|(
operator|(
name|abbrev
operator|->
name|die_child
operator|!=
name|NULL
operator|)
operator|!=
operator|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|VEC_length
argument_list|(
name|dw_attr_node
argument_list|,
name|abbrev
operator|->
name|die_attr
argument_list|)
operator|!=
name|VEC_length
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|die_a
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
name|abbrev_a
operator|=
name|VEC_index
argument_list|(
name|dw_attr_node
argument_list|,
name|abbrev
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|abbrev_a
operator|->
name|dw_attr
operator|!=
name|die_a
operator|->
name|dw_attr
operator|)
operator|||
operator|(
name|value_format
argument_list|(
name|abbrev_a
argument_list|)
operator|!=
name|value_format
argument_list|(
name|die_a
argument_list|)
operator|)
condition|)
block|{
name|ok
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ok
condition|)
break|break;
block|}
if|if
condition|(
name|abbrev_id
operator|>=
name|abbrev_die_table_in_use
condition|)
block|{
if|if
condition|(
name|abbrev_die_table_in_use
operator|>=
name|abbrev_die_table_allocated
condition|)
block|{
name|n_alloc
operator|=
name|abbrev_die_table_allocated
operator|+
name|ABBREV_DIE_TABLE_INCREMENT
expr_stmt|;
name|abbrev_die_table
operator|=
name|ggc_realloc
argument_list|(
name|abbrev_die_table
argument_list|,
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
operator|*
name|n_alloc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|abbrev_die_table
index|[
name|abbrev_die_table_allocated
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|n_alloc
operator|-
name|abbrev_die_table_allocated
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|abbrev_die_table_allocated
operator|=
name|n_alloc
expr_stmt|;
block|}
operator|++
name|abbrev_die_table_in_use
expr_stmt|;
name|abbrev_die_table
index|[
name|abbrev_id
index|]
operator|=
name|die
expr_stmt|;
block|}
name|die
operator|->
name|die_abbrev
operator|=
name|abbrev_id
expr_stmt|;
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|build_abbrev_table
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the power-of-two number of bytes necessary to represent VALUE.  */
end_comment

begin_function
specifier|static
name|int
name|constant_size
parameter_list|(
name|long
name|unsigned
name|int
name|value
parameter_list|)
block|{
name|int
name|log
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|log
operator|=
literal|0
expr_stmt|;
else|else
name|log
operator|=
name|floor_log2
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|log
operator|=
name|log
operator|/
literal|8
expr_stmt|;
name|log
operator|=
literal|1
operator|<<
operator|(
name|floor_log2
argument_list|(
name|log
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a DIE as it is represented in the    .debug_info section.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_die
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|unsigned
name|long
name|size
init|=
literal|0
decl_stmt|;
name|dw_attr_ref
name|a
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|die
operator|->
name|die_abbrev
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
switch|switch
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
name|size
operator|+=
name|DWARF2_ADDR_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_offset
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc
case|:
block|{
name|unsigned
name|long
name|lsize
init|=
name|size_of_locs
argument_list|(
name|AT_loc
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Block length.  */
name|size
operator|+=
name|constant_size
argument_list|(
name|lsize
argument_list|)
expr_stmt|;
name|size
operator|+=
name|lsize
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_loc_list
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_range_list
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_const
case|:
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|AT_int
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_unsigned_const
case|:
name|size
operator|+=
name|constant_size
argument_list|(
name|AT_unsigned
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_long_long
case|:
name|size
operator|+=
literal|1
operator|+
literal|2
operator|*
name|HOST_BITS_PER_LONG
operator|/
name|HOST_BITS_PER_CHAR
expr_stmt|;
comment|/* block */
break|break;
case|case
name|dw_val_class_vec
case|:
name|size
operator|+=
literal|1
operator|+
operator|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_vec
operator|.
name|length
operator|*
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_vec
operator|.
name|elt_size
operator|)
expr_stmt|;
comment|/* block */
break|break;
case|case
name|dw_val_class_flag
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|dw_val_class_die_ref
case|:
if|if
condition|(
name|AT_ref_external
argument_list|(
name|a
argument_list|)
condition|)
name|size
operator|+=
name|DWARF2_ADDR_SIZE
expr_stmt|;
else|else
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_fde_ref
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_lbl_id
case|:
name|size
operator|+=
name|DWARF2_ADDR_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_lineptr
case|:
case|case
name|dw_val_class_macptr
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_str
case|:
if|if
condition|(
name|AT_string_form
argument_list|(
name|a
argument_list|)
operator|==
name|DW_FORM_strp
condition|)
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
else|else
name|size
operator|+=
name|strlen
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|->
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|dw_val_class_file
case|:
name|size
operator|+=
name|constant_size
argument_list|(
name|maybe_emit_file
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_file
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Size the debugging information associated with a given DIE.  Visits the    DIE's children recursively.  Updates the global variable next_die_offset, on    each time through.  Uses the current value of next_die_offset to update the    die_offset field in each DIE.  */
end_comment

begin_function
specifier|static
name|void
name|calc_die_sizes
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|die
operator|->
name|die_offset
operator|=
name|next_die_offset
expr_stmt|;
name|next_die_offset
operator|+=
name|size_of_die
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|calc_die_sizes
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
condition|)
comment|/* Count the null byte used to terminate sibling lists.  */
name|next_die_offset
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the marks for a die and its children.  We do this so    that we know whether or not a reference needs to use FORM_ref_addr; only    DIEs in the same CU will be marked.  We used to clear out the offset    and use that as the flag, but ran into ordering problems.  */
end_comment

begin_function
specifier|static
name|void
name|mark_dies
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|die
operator|->
name|die_mark
argument_list|)
expr_stmt|;
name|die
operator|->
name|die_mark
operator|=
literal|1
expr_stmt|;
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|mark_dies
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the marks for a die and its children.  */
end_comment

begin_function
specifier|static
name|void
name|unmark_dies
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|gcc_assert
argument_list|(
name|die
operator|->
name|die_mark
argument_list|)
expr_stmt|;
name|die
operator|->
name|die_mark
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|unmark_dies
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the marks for a die, its children and referred dies.  */
end_comment

begin_function
specifier|static
name|void
name|unmark_all_dies
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|dw_attr_ref
name|a
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
if|if
condition|(
operator|!
name|die
operator|->
name|die_mark
condition|)
return|return;
name|die
operator|->
name|die_mark
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|unmark_all_dies
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a
argument_list|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_die_ref
condition|)
name|unmark_all_dies
argument_list|(
name|AT_ref
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the size of the .debug_pubnames table  generated for the    compilation unit.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_pubnames
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|size
operator|=
name|DWARF_PUBNAMES_HEADER_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pubname_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|pubname_ref
name|p
init|=
operator|&
name|pubname_table
index|[
name|i
index|]
decl_stmt|;
name|size
operator|+=
name|DWARF_OFFSET_SIZE
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the information in the .debug_aranges section.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_aranges
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|size
operator|=
name|DWARF_ARANGES_HEADER_SIZE
expr_stmt|;
comment|/* Count the address/length pair for this compilation unit.  */
name|size
operator|+=
literal|2
operator|*
name|DWARF2_ADDR_SIZE
expr_stmt|;
name|size
operator|+=
literal|2
operator|*
name|DWARF2_ADDR_SIZE
operator|*
name|arange_table_in_use
expr_stmt|;
comment|/* Count the two zero words used to terminated the address range table.  */
name|size
operator|+=
literal|2
operator|*
name|DWARF2_ADDR_SIZE
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Select the encoding of an attribute value.  */
end_comment

begin_function
specifier|static
name|enum
name|dwarf_form
name|value_format
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
switch|switch
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
return|return
name|DW_FORM_addr
return|;
case|case
name|dw_val_class_range_list
case|:
case|case
name|dw_val_class_offset
case|:
case|case
name|dw_val_class_loc_list
case|:
switch|switch
condition|(
name|DWARF_OFFSET_SIZE
condition|)
block|{
case|case
literal|4
case|:
return|return
name|DW_FORM_data4
return|;
case|case
literal|8
case|:
return|return
name|DW_FORM_data8
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|dw_val_class_loc
case|:
switch|switch
condition|(
name|constant_size
argument_list|(
name|size_of_locs
argument_list|(
name|AT_loc
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|DW_FORM_block1
return|;
case|case
literal|2
case|:
return|return
name|DW_FORM_block2
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|dw_val_class_const
case|:
return|return
name|DW_FORM_sdata
return|;
case|case
name|dw_val_class_unsigned_const
case|:
switch|switch
condition|(
name|constant_size
argument_list|(
name|AT_unsigned
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|DW_FORM_data1
return|;
case|case
literal|2
case|:
return|return
name|DW_FORM_data2
return|;
case|case
literal|4
case|:
return|return
name|DW_FORM_data4
return|;
case|case
literal|8
case|:
return|return
name|DW_FORM_data8
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
case|case
name|dw_val_class_long_long
case|:
return|return
name|DW_FORM_block1
return|;
case|case
name|dw_val_class_vec
case|:
return|return
name|DW_FORM_block1
return|;
case|case
name|dw_val_class_flag
case|:
return|return
name|DW_FORM_flag
return|;
case|case
name|dw_val_class_die_ref
case|:
if|if
condition|(
name|AT_ref_external
argument_list|(
name|a
argument_list|)
condition|)
return|return
name|DW_FORM_ref_addr
return|;
else|else
return|return
name|DW_FORM_ref
return|;
case|case
name|dw_val_class_fde_ref
case|:
return|return
name|DW_FORM_data
return|;
case|case
name|dw_val_class_lbl_id
case|:
return|return
name|DW_FORM_addr
return|;
case|case
name|dw_val_class_lineptr
case|:
case|case
name|dw_val_class_macptr
case|:
return|return
name|DW_FORM_data
return|;
case|case
name|dw_val_class_str
case|:
return|return
name|AT_string_form
argument_list|(
name|a
argument_list|)
return|;
case|case
name|dw_val_class_file
case|:
switch|switch
condition|(
name|constant_size
argument_list|(
name|maybe_emit_file
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_file
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|DW_FORM_data1
return|;
case|case
literal|2
case|:
return|return
name|DW_FORM_data2
return|;
case|case
literal|4
case|:
return|return
name|DW_FORM_data4
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the encoding of an attribute value.  */
end_comment

begin_function
specifier|static
name|void
name|output_value_format
parameter_list|(
name|dw_attr_ref
name|a
parameter_list|)
block|{
name|enum
name|dwarf_form
name|form
init|=
name|value_format
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|form
argument_list|,
literal|"(%s)"
argument_list|,
name|dwarf_form_name
argument_list|(
name|form
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the .debug_abbrev section which defines the DIE abbreviation    table.  */
end_comment

begin_function
specifier|static
name|void
name|output_abbrev_section
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|abbrev_id
decl_stmt|;
for|for
control|(
name|abbrev_id
operator|=
literal|1
init|;
name|abbrev_id
operator|<
name|abbrev_die_table_in_use
condition|;
operator|++
name|abbrev_id
control|)
block|{
name|dw_die_ref
name|abbrev
init|=
name|abbrev_die_table
index|[
name|abbrev_id
index|]
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
name|dw_attr_ref
name|a_attr
decl_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|abbrev_id
argument_list|,
literal|"(abbrev code)"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|abbrev
operator|->
name|die_tag
argument_list|,
literal|"(TAG: %s)"
argument_list|,
name|dwarf_tag_name
argument_list|(
name|abbrev
operator|->
name|die_tag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abbrev
operator|->
name|die_child
operator|!=
name|NULL
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_children_yes
argument_list|,
literal|"DW_children_yes"
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_children_no
argument_list|,
literal|"DW_children_no"
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|abbrev
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a_attr
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
name|dw2_asm_output_data_uleb128
argument_list|(
name|a_attr
operator|->
name|dw_attr
argument_list|,
literal|"(%s)"
argument_list|,
name|dwarf_attr_name
argument_list|(
name|a_attr
operator|->
name|dw_attr
argument_list|)
argument_list|)
expr_stmt|;
name|output_value_format
argument_list|(
name|a_attr
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Terminate the table.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a symbol we can use to refer to this DIE from another CU.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|output_die_symbol
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|char
modifier|*
name|sym
init|=
name|die
operator|->
name|die_symbol
decl_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|strncmp
argument_list|(
name|sym
argument_list|,
name|DIE_LABEL_PREFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|DIE_LABEL_PREFIX
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* We make these global, not weak; if the target doesn't support        .linkonce, it doesn't support combining the sections, so debugging        will break.  */
name|targetm
operator|.
name|asm_out
operator|.
name|globalize_label
argument_list|(
name|asm_out_file
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a new location list, given the begin and end range, and the    expression. gensym tells us whether to generate a new internal symbol for    this location list node, which is done for the head of the list only.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_loc_list_ref
name|new_loc_list
parameter_list|(
name|dw_loc_descr_ref
name|expr
parameter_list|,
specifier|const
name|char
modifier|*
name|begin
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|,
name|unsigned
name|int
name|gensym
parameter_list|)
block|{
name|dw_loc_list_ref
name|retlist
init|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_loc_list_node
argument_list|)
argument_list|)
decl_stmt|;
name|retlist
operator|->
name|begin
operator|=
name|begin
expr_stmt|;
name|retlist
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|retlist
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|retlist
operator|->
name|section
operator|=
name|section
expr_stmt|;
if|if
condition|(
name|gensym
condition|)
name|retlist
operator|->
name|ll_symbol
operator|=
name|gen_internal_sym
argument_list|(
literal|"LLST"
argument_list|)
expr_stmt|;
return|return
name|retlist
return|;
block|}
end_function

begin_comment
comment|/* Add a location description expression to a location list.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_loc_descr_to_loc_list
parameter_list|(
name|dw_loc_list_ref
modifier|*
name|list_head
parameter_list|,
name|dw_loc_descr_ref
name|descr
parameter_list|,
specifier|const
name|char
modifier|*
name|begin
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|,
specifier|const
name|char
modifier|*
name|section
parameter_list|)
block|{
name|dw_loc_list_ref
modifier|*
name|d
decl_stmt|;
comment|/* Find the end of the chain.  */
for|for
control|(
name|d
operator|=
name|list_head
init|;
operator|(
operator|*
name|d
operator|)
operator|!=
name|NULL
condition|;
name|d
operator|=
operator|&
operator|(
operator|*
name|d
operator|)
operator|->
name|dw_loc_next
control|)
empty_stmt|;
comment|/* Add a new location list node to the list.  */
operator|*
name|d
operator|=
name|new_loc_list
argument_list|(
name|descr
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2out_switch_text_section
parameter_list|(
name|void
parameter_list|)
block|{
name|dw_fde_ref
name|fde
decl_stmt|;
name|gcc_assert
argument_list|(
name|cfun
argument_list|)
expr_stmt|;
name|fde
operator|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|-
literal|1
index|]
expr_stmt|;
name|fde
operator|->
name|dw_fde_switched_sections
operator|=
name|true
expr_stmt|;
name|fde
operator|->
name|dw_fde_hot_section_label
operator|=
name|cfun
operator|->
name|hot_section_label
expr_stmt|;
name|fde
operator|->
name|dw_fde_hot_section_end_label
operator|=
name|cfun
operator|->
name|hot_section_end_label
expr_stmt|;
name|fde
operator|->
name|dw_fde_unlikely_section_label
operator|=
name|cfun
operator|->
name|cold_section_label
expr_stmt|;
name|fde
operator|->
name|dw_fde_unlikely_section_end_label
operator|=
name|cfun
operator|->
name|cold_section_end_label
expr_stmt|;
name|have_multiple_function_sections
operator|=
name|true
expr_stmt|;
comment|/* Reset the current label on switching text sections, so that we      don't attempt to advance_loc4 between labels in different sections.  */
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the location list given to us.  */
end_comment

begin_function
specifier|static
name|void
name|output_loc_list
parameter_list|(
name|dw_loc_list_ref
name|list_head
parameter_list|)
block|{
name|dw_loc_list_ref
name|curr
init|=
name|list_head
decl_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
comment|/* Walk the location list, and output each range + expression.  */
for|for
control|(
name|curr
operator|=
name|list_head
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|curr
operator|->
name|dw_loc_next
control|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|have_multiple_function_sections
condition|)
block|{
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|curr
operator|->
name|begin
argument_list|,
name|curr
operator|->
name|section
argument_list|,
literal|"Location list begin address (%s)"
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|curr
operator|->
name|end
argument_list|,
name|curr
operator|->
name|section
argument_list|,
literal|"Location list end address (%s)"
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|curr
operator|->
name|begin
argument_list|,
literal|"Location list begin address (%s)"
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|curr
operator|->
name|end
argument_list|,
literal|"Location list end address (%s)"
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|size_of_locs
argument_list|(
name|curr
operator|->
name|expr
argument_list|)
expr_stmt|;
comment|/* Output the block length for this list of location operations.  */
name|gcc_assert
argument_list|(
name|size
operator|<=
literal|0xffff
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|size
argument_list|,
literal|"%s"
argument_list|,
literal|"Location expression size"
argument_list|)
expr_stmt|;
name|output_loc_sequence
argument_list|(
name|curr
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
literal|0
argument_list|,
literal|"Location list terminator begin (%s)"
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
literal|0
argument_list|,
literal|"Location list terminator end (%s)"
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the DIE and its attributes.  Called recursively to generate    the definitions of each child DIE.  */
end_comment

begin_function
specifier|static
name|void
name|output_die
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_attr_ref
name|a
decl_stmt|;
name|dw_die_ref
name|c
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
comment|/* If someone in another CU might refer to us, set up a symbol for      them to point to.  */
if|if
condition|(
name|die
operator|->
name|die_symbol
condition|)
name|output_die_symbol
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|die
operator|->
name|die_abbrev
argument_list|,
literal|"(DIE (0x%lx) %s)"
argument_list|,
name|die
operator|->
name|die_offset
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|die_tag
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|dwarf_attr_name
argument_list|(
name|a
operator|->
name|dw_attr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
name|dw2_asm_output_addr_rtx
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|AT_addr
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_offset
case|:
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_offset
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_range_list
case|:
block|{
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|ranges_section_label
argument_list|,
literal|'\0'
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"+"
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_offset
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|ranges_section_label
argument_list|,
name|debug_ranges_section
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_loc
case|:
name|size
operator|=
name|size_of_locs
argument_list|(
name|AT_loc
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the block length for this list of location operations.  */
name|dw2_asm_output_data
argument_list|(
name|constant_size
argument_list|(
name|size
argument_list|)
argument_list|,
name|size
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|output_loc_sequence
argument_list|(
name|AT_loc
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_const
case|:
comment|/* ??? It would be slightly more efficient to use a scheme like is 	     used for unsigned constants below, but gdb 4.x does not sign 	     extend.  Gdb 5.x does sign extend.  */
name|dw2_asm_output_data_sleb128
argument_list|(
name|AT_int
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_unsigned_const
case|:
name|dw2_asm_output_data
argument_list|(
name|constant_size
argument_list|(
name|AT_unsigned
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|,
name|AT_unsigned
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_long_long
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|first
decl_stmt|,
name|second
decl_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|2
operator|*
name|HOST_BITS_PER_LONG
operator|/
name|HOST_BITS_PER_CHAR
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|first
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
expr_stmt|;
name|second
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
expr_stmt|;
name|second
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
name|HOST_BITS_PER_LONG
operator|/
name|HOST_BITS_PER_CHAR
argument_list|,
name|first
argument_list|,
literal|"long long constant"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|HOST_BITS_PER_LONG
operator|/
name|HOST_BITS_PER_CHAR
argument_list|,
name|second
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_vec
case|:
block|{
name|unsigned
name|int
name|elt_size
init|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_vec
operator|.
name|elt_size
decl_stmt|;
name|unsigned
name|int
name|len
init|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_vec
operator|.
name|length
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|len
operator|*
name|elt_size
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt_size
operator|>
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
block|{
name|elt_size
operator|/=
literal|2
expr_stmt|;
name|len
operator|*=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_vec
operator|.
name|array
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
name|elt_size
control|)
name|dw2_asm_output_data
argument_list|(
name|elt_size
argument_list|,
name|extract_int
argument_list|(
name|p
argument_list|,
name|elt_size
argument_list|)
argument_list|,
literal|"fp or vector constant word %u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|dw_val_class_flag
case|:
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|AT_flag
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc_list
case|:
block|{
name|char
modifier|*
name|sym
init|=
name|AT_loc_list
argument_list|(
name|a
argument_list|)
operator|->
name|ll_symbol
decl_stmt|;
name|gcc_assert
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|sym
argument_list|,
name|debug_loc_section
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_die_ref
case|:
if|if
condition|(
name|AT_ref_external
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|char
modifier|*
name|sym
init|=
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_symbol
decl_stmt|;
name|gcc_assert
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|sym
argument_list|,
name|debug_info_section
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_offset
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_offset
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_fde_ref
case|:
block|{
name|char
name|l1
index|[
literal|20
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
name|FDE_LABEL
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_fde_index
operator|*
literal|2
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|l1
argument_list|,
name|debug_frame_section
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_lbl_id
case|:
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|AT_lbl
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_lineptr
case|:
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|AT_lbl
argument_list|(
name|a
argument_list|)
argument_list|,
name|debug_line_section
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_macptr
case|:
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|AT_lbl
argument_list|(
name|a
argument_list|)
argument_list|,
name|debug_macinfo_section
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_str
case|:
if|if
condition|(
name|AT_string_form
argument_list|(
name|a
argument_list|)
operator|==
name|DW_FORM_strp
condition|)
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|->
name|label
argument_list|,
name|debug_str_section
argument_list|,
literal|"%s: \"%s\""
argument_list|,
name|name
argument_list|,
name|AT_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_nstring
argument_list|(
name|AT_string
argument_list|(
name|a
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_file
case|:
block|{
name|int
name|f
init|=
name|maybe_emit_file
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_file
argument_list|)
decl_stmt|;
name|dw2_asm_output_data
argument_list|(
name|constant_size
argument_list|(
name|f
argument_list|)
argument_list|,
name|f
argument_list|,
literal|"%s (%s)"
argument_list|,
name|name
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_file
operator|->
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|output_die
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add null byte to terminate sibling list.  */
if|if
condition|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"end of children of DIE 0x%lx"
argument_list|,
name|die
operator|->
name|die_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the compilation unit that appears at the beginning of the    .debug_info section, and precedes the DIE descriptions.  */
end_comment

begin_function
specifier|static
name|void
name|output_compilation_unit_header
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|DWARF_INITIAL_LENGTH_SIZE
operator|-
name|DWARF_OFFSET_SIZE
operator|==
literal|4
condition|)
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
literal|0xffffffff
argument_list|,
literal|"Initial length escape value indicating 64-bit DWARF extension"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|next_die_offset
operator|-
name|DWARF_INITIAL_LENGTH_SIZE
argument_list|,
literal|"Length of Compilation Unit Info"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|DWARF_VERSION
argument_list|,
literal|"DWARF version number"
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|abbrev_section_label
argument_list|,
name|debug_abbrev_section
argument_list|,
literal|"Offset Into Abbrev. Section"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF2_ADDR_SIZE
argument_list|,
literal|"Pointer Size (in bytes)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the compilation unit DIE and its children.  */
end_comment

begin_function
specifier|static
name|void
name|output_comp_unit
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|int
name|output_if_empty
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
name|char
modifier|*
name|oldsym
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
comment|/* Unless we are outputting main CU, we may throw away empty ones.  */
if|if
condition|(
operator|!
name|output_if_empty
operator|&&
name|die
operator|->
name|die_child
operator|==
name|NULL
condition|)
return|return;
comment|/* Even if there are no children of this DIE, we must output the information      about the compilation unit.  Otherwise, on an empty translation unit, we      will generate a present, but empty, .debug_info section.  IRIX 6.5 `nm'      will then complain when examining the file.  First mark all the DIEs in      this CU so we know which get local refs.  */
name|mark_dies
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|build_abbrev_table
argument_list|(
name|die
argument_list|)
expr_stmt|;
comment|/* Initialize the beginning DIE offset - and calculate sizes/offsets.  */
name|next_die_offset
operator|=
name|DWARF_COMPILE_UNIT_HEADER_SIZE
expr_stmt|;
name|calc_die_sizes
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|oldsym
operator|=
name|die
operator|->
name|die_symbol
expr_stmt|;
if|if
condition|(
name|oldsym
condition|)
block|{
name|tmp
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|oldsym
argument_list|)
operator|+
literal|24
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|".gnu.linkonce.wi.%s"
argument_list|,
name|oldsym
argument_list|)
expr_stmt|;
name|secname
operator|=
name|tmp
expr_stmt|;
name|die
operator|->
name|die_symbol
operator|=
name|NULL
expr_stmt|;
name|switch_to_section
argument_list|(
name|get_section
argument_list|(
name|secname
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|switch_to_section
argument_list|(
name|debug_info_section
argument_list|)
expr_stmt|;
comment|/* Output debugging information.  */
name|output_compilation_unit_header
argument_list|()
expr_stmt|;
name|output_die
argument_list|(
name|die
argument_list|)
expr_stmt|;
comment|/* Leave the marks on the main CU, so we can check them in      output_pubnames.  */
if|if
condition|(
name|oldsym
condition|)
block|{
name|unmark_dies
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|die
operator|->
name|die_symbol
operator|=
name|oldsym
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the DWARF2/3 pubname associated with a decl.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf2_name
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|scope
parameter_list|)
block|{
return|return
name|lang_hooks
operator|.
name|dwarf_name
argument_list|(
name|decl
argument_list|,
name|scope
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a new entry to .debug_pubnames if appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|add_pubname
parameter_list|(
name|tree
name|decl
parameter_list|,
name|dw_die_ref
name|die
parameter_list|)
block|{
name|pubname_ref
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|pubname_table_in_use
operator|==
name|pubname_table_allocated
condition|)
block|{
name|pubname_table_allocated
operator|+=
name|PUBNAME_TABLE_INCREMENT
expr_stmt|;
name|pubname_table
operator|=
name|ggc_realloc
argument_list|(
name|pubname_table
argument_list|,
operator|(
name|pubname_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|pubname_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pubname_table
operator|+
name|pubname_table_in_use
argument_list|,
literal|0
argument_list|,
name|PUBNAME_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|pubname_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
operator|&
name|pubname_table
index|[
name|pubname_table_in_use
operator|++
index|]
expr_stmt|;
name|p
operator|->
name|die
operator|=
name|die
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|dwarf2_name
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the public names table used to speed up access to externally    visible names.  For now, only generate entries for externally    visible procedures.  */
end_comment

begin_function
specifier|static
name|void
name|output_pubnames
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|long
name|pubnames_length
init|=
name|size_of_pubnames
argument_list|()
decl_stmt|;
if|if
condition|(
name|DWARF_INITIAL_LENGTH_SIZE
operator|-
name|DWARF_OFFSET_SIZE
operator|==
literal|4
condition|)
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
literal|0xffffffff
argument_list|,
literal|"Initial length escape value indicating 64-bit DWARF extension"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|pubnames_length
argument_list|,
literal|"Length of Public Names Info"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|DWARF_VERSION
argument_list|,
literal|"DWARF Version"
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|debug_info_section_label
argument_list|,
name|debug_info_section
argument_list|,
literal|"Offset of Compilation Unit Info"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|next_die_offset
argument_list|,
literal|"Compilation Unit Length"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pubname_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|pubname_ref
name|pub
init|=
operator|&
name|pubname_table
index|[
name|i
index|]
decl_stmt|;
comment|/* We shouldn't see pubnames for DIEs outside of the main CU.  */
name|gcc_assert
argument_list|(
name|pub
operator|->
name|die
operator|->
name|die_mark
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|pub
operator|->
name|die
operator|->
name|die_offset
argument_list|,
literal|"DIE offset"
argument_list|)
expr_stmt|;
name|dw2_asm_output_nstring
argument_list|(
name|pub
operator|->
name|name
argument_list|,
operator|-
literal|1
argument_list|,
literal|"external name"
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new entry to .debug_aranges if appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|add_arange
parameter_list|(
name|tree
name|decl
parameter_list|,
name|dw_die_ref
name|die
parameter_list|)
block|{
if|if
condition|(
operator|!
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|arange_table_in_use
operator|==
name|arange_table_allocated
condition|)
block|{
name|arange_table_allocated
operator|+=
name|ARANGE_TABLE_INCREMENT
expr_stmt|;
name|arange_table
operator|=
name|ggc_realloc
argument_list|(
name|arange_table
argument_list|,
operator|(
name|arange_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|arange_table
operator|+
name|arange_table_in_use
argument_list|,
literal|0
argument_list|,
name|ARANGE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arange_table
index|[
name|arange_table_in_use
operator|++
index|]
operator|=
name|die
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the information that goes into the .debug_aranges table.    Namely, define the beginning and ending address range of the    text section generated for this compilation unit.  */
end_comment

begin_function
specifier|static
name|void
name|output_aranges
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|long
name|aranges_length
init|=
name|size_of_aranges
argument_list|()
decl_stmt|;
if|if
condition|(
name|DWARF_INITIAL_LENGTH_SIZE
operator|-
name|DWARF_OFFSET_SIZE
operator|==
literal|4
condition|)
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
literal|0xffffffff
argument_list|,
literal|"Initial length escape value indicating 64-bit DWARF extension"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|aranges_length
argument_list|,
literal|"Length of Address Ranges Info"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|DWARF_VERSION
argument_list|,
literal|"DWARF Version"
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|debug_info_section_label
argument_list|,
name|debug_info_section
argument_list|,
literal|"Offset of Compilation Unit Info"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF2_ADDR_SIZE
argument_list|,
literal|"Size of Address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Size of Segment Descriptor"
argument_list|)
expr_stmt|;
comment|/* We need to align to twice the pointer size here.  */
if|if
condition|(
name|DWARF_ARANGES_PAD_SIZE
condition|)
block|{
comment|/* Pad using a 2 byte words so that padding is correct for any 	 pointer size.  */
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Pad to %d byte boundary"
argument_list|,
literal|2
operator|*
name|DWARF2_ADDR_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|DWARF_ARANGES_PAD_SIZE
condition|;
name|i
operator|+=
literal|2
control|)
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|text_section_label
argument_list|,
literal|"Address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|text_end_label
argument_list|,
name|text_section_label
argument_list|,
literal|"Length"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
block|{
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|cold_text_section_label
argument_list|,
literal|"Address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|cold_end_label
argument_list|,
name|cold_text_section_label
argument_list|,
literal|"Length"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arange_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|dw_die_ref
name|die
init|=
name|arange_table
index|[
name|i
index|]
decl_stmt|;
comment|/* We shouldn't see aranges for DIEs outside of the main CU.  */
name|gcc_assert
argument_list|(
name|die
operator|->
name|die_mark
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|get_AT_low_pc
argument_list|(
name|die
argument_list|)
argument_list|,
literal|"Address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|get_AT_hi_pc
argument_list|(
name|die
argument_list|)
argument_list|,
name|get_AT_low_pc
argument_list|(
name|die
argument_list|)
argument_list|,
literal|"Length"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A static variable; extract the symbol from DW_AT_location. 	     Note that this code isn't currently hit, as we only emit 	     aranges for functions (jason 9/23/99).  */
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|DW_AT_location
argument_list|)
decl_stmt|;
name|dw_loc_descr_ref
name|loc
decl_stmt|;
name|gcc_assert
argument_list|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_loc
argument_list|)
expr_stmt|;
name|loc
operator|=
name|AT_loc
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|loc
operator|->
name|dw_loc_opc
operator|==
name|DW_OP_addr
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr_rtx
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_addr
argument_list|,
literal|"Address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|get_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|)
argument_list|,
literal|"Length"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output the terminator words.  */
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new entry to .debug_ranges.  Return the offset at which it    was placed.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|add_ranges
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|unsigned
name|int
name|in_use
init|=
name|ranges_table_in_use
decl_stmt|;
if|if
condition|(
name|in_use
operator|==
name|ranges_table_allocated
condition|)
block|{
name|ranges_table_allocated
operator|+=
name|RANGES_TABLE_INCREMENT
expr_stmt|;
name|ranges_table
operator|=
name|ggc_realloc
argument_list|(
name|ranges_table
argument_list|,
operator|(
name|ranges_table_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dw_ranges_struct
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ranges_table
operator|+
name|ranges_table_in_use
argument_list|,
literal|0
argument_list|,
name|RANGES_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dw_ranges_struct
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ranges_table
index|[
name|in_use
index|]
operator|.
name|block_num
operator|=
operator|(
name|block
condition|?
name|BLOCK_NUMBER
argument_list|(
name|block
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|ranges_table_in_use
operator|=
name|in_use
operator|+
literal|1
expr_stmt|;
return|return
name|in_use
operator|*
literal|2
operator|*
name|DWARF2_ADDR_SIZE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_ranges
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|start_fmt
init|=
literal|"Offset 0x%x"
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|start_fmt
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ranges_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|int
name|block_num
init|=
name|ranges_table
index|[
name|i
index|]
operator|.
name|block_num
decl_stmt|;
if|if
condition|(
name|block_num
condition|)
block|{
name|char
name|blabel
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|elabel
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|blabel
argument_list|,
name|BLOCK_BEGIN_LABEL
argument_list|,
name|block_num
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|elabel
argument_list|,
name|BLOCK_END_LABEL
argument_list|,
name|block_num
argument_list|)
expr_stmt|;
comment|/* If all code is in the text section, then the compilation 	     unit base address defaults to DW_AT_low_pc, which is the 	     base of the text section.  */
if|if
condition|(
operator|!
name|have_multiple_function_sections
condition|)
block|{
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|blabel
argument_list|,
name|text_section_label
argument_list|,
name|fmt
argument_list|,
name|i
operator|*
literal|2
operator|*
name|DWARF2_ADDR_SIZE
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|elabel
argument_list|,
name|text_section_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we add a DW_AT_entry_pc attribute to force the 	     compilation unit base address to zero, which allows us to 	     use absolute addresses, and not worry about whether the 	     target supports cross-section arithmetic.  */
else|else
block|{
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|blabel
argument_list|,
name|fmt
argument_list|,
name|i
operator|*
literal|2
operator|*
name|DWARF2_ADDR_SIZE
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|elabel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|fmt
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|start_fmt
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Data structure containing information about input files.  */
end_comment

begin_struct
struct|struct
name|file_info
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Complete file name.  */
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* File name part.  */
name|int
name|length
decl_stmt|;
comment|/* Length of entire string.  */
name|struct
name|dwarf_file_data
modifier|*
name|file_idx
decl_stmt|;
comment|/* Index in input file table.  */
name|int
name|dir_idx
decl_stmt|;
comment|/* Index in directory table.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Data structure containing information about directories with source    files.  */
end_comment

begin_struct
struct|struct
name|dir_info
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Path including directory name.  */
name|int
name|length
decl_stmt|;
comment|/* Path length.  */
name|int
name|prefix
decl_stmt|;
comment|/* Index of directory entry which is a prefix.  */
name|int
name|count
decl_stmt|;
comment|/* Number of files in this directory.  */
name|int
name|dir_idx
decl_stmt|;
comment|/* Index of directory used as base.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Callback function for file_info comparison.  We sort by looking at    the directories in the path.  */
end_comment

begin_function
specifier|static
name|int
name|file_info_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|file_info
modifier|*
name|s1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|file_info
modifier|*
name|s2
init|=
name|p2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cp1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cp2
decl_stmt|;
comment|/* Take care of file names without directories.  We need to make sure that      we return consistent values to qsort since some will get confused if      we return the same value when identical operands are passed in opposite      orders.  So if neither has a directory, return 0 and otherwise return      1 or -1 depending on which one has the directory.  */
if|if
condition|(
operator|(
name|s1
operator|->
name|path
operator|==
name|s1
operator|->
name|fname
operator|||
name|s2
operator|->
name|path
operator|==
name|s2
operator|->
name|fname
operator|)
condition|)
return|return
operator|(
name|s2
operator|->
name|path
operator|==
name|s2
operator|->
name|fname
operator|)
operator|-
operator|(
name|s1
operator|->
name|path
operator|==
name|s1
operator|->
name|fname
operator|)
return|;
name|cp1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s1
operator|->
name|path
expr_stmt|;
name|cp2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s2
operator|->
name|path
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|++
name|cp1
expr_stmt|;
operator|++
name|cp2
expr_stmt|;
comment|/* Reached the end of the first path?  If so, handle like above.  */
if|if
condition|(
operator|(
name|cp1
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s1
operator|->
name|fname
operator|)
operator|||
operator|(
name|cp2
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s2
operator|->
name|fname
operator|)
condition|)
return|return
operator|(
operator|(
name|cp2
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s2
operator|->
name|fname
operator|)
operator|-
operator|(
name|cp1
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s1
operator|->
name|fname
operator|)
operator|)
return|;
comment|/* Character of current path component the same?  */
elseif|else
if|if
condition|(
operator|*
name|cp1
operator|!=
operator|*
name|cp2
condition|)
return|return
operator|*
name|cp1
operator|-
operator|*
name|cp2
return|;
block|}
block|}
end_function

begin_struct
struct|struct
name|file_name_acquire_data
block|{
name|struct
name|file_info
modifier|*
name|files
decl_stmt|;
name|int
name|used_files
decl_stmt|;
name|int
name|max_files
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Traversal function for the hash table.  */
end_comment

begin_function
specifier|static
name|int
name|file_name_acquire
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|file_name_acquire_data
modifier|*
name|fnad
init|=
name|data
decl_stmt|;
name|struct
name|dwarf_file_data
modifier|*
name|d
init|=
operator|*
name|slot
decl_stmt|;
name|struct
name|file_info
modifier|*
name|fi
decl_stmt|;
specifier|const
name|char
modifier|*
name|f
decl_stmt|;
name|gcc_assert
argument_list|(
name|fnad
operator|->
name|max_files
operator|>=
name|d
operator|->
name|emitted_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|emitted_number
condition|)
return|return
literal|1
return|;
name|gcc_assert
argument_list|(
name|fnad
operator|->
name|max_files
operator|!=
name|fnad
operator|->
name|used_files
argument_list|)
expr_stmt|;
name|fi
operator|=
name|fnad
operator|->
name|files
operator|+
name|fnad
operator|->
name|used_files
operator|++
expr_stmt|;
comment|/* Skip all leading "./".  */
name|f
operator|=
name|d
operator|->
name|filename
expr_stmt|;
while|while
condition|(
name|f
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|f
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|f
operator|+=
literal|2
expr_stmt|;
comment|/* Create a new array entry.  */
name|fi
operator|->
name|path
operator|=
name|f
expr_stmt|;
name|fi
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|fi
operator|->
name|file_idx
operator|=
name|d
expr_stmt|;
comment|/* Search for the file name part.  */
name|f
operator|=
name|strrchr
argument_list|(
name|f
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|fi
operator|->
name|fname
operator|=
name|f
operator|==
name|NULL
condition|?
name|fi
operator|->
name|path
else|:
name|f
operator|+
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Output the directory table and the file name table.  We try to minimize    the total amount of memory needed.  A heuristic is used to avoid large    slowdowns with many input files.  */
end_comment

begin_function
specifier|static
name|void
name|output_file_names
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|file_name_acquire_data
name|fnad
decl_stmt|;
name|int
name|numfiles
decl_stmt|;
name|struct
name|file_info
modifier|*
name|files
decl_stmt|;
name|struct
name|dir_info
modifier|*
name|dirs
decl_stmt|;
name|int
modifier|*
name|saved
decl_stmt|;
name|int
modifier|*
name|savehere
decl_stmt|;
name|int
modifier|*
name|backmap
decl_stmt|;
name|int
name|ndirs
decl_stmt|;
name|int
name|idx_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|idx
decl_stmt|;
if|if
condition|(
operator|!
name|last_emitted_file
condition|)
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"End directory table"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"End file name table"
argument_list|)
expr_stmt|;
return|return;
block|}
name|numfiles
operator|=
name|last_emitted_file
operator|->
name|emitted_number
expr_stmt|;
comment|/* Allocate the various arrays we need.  */
name|files
operator|=
name|alloca
argument_list|(
name|numfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file_info
argument_list|)
argument_list|)
expr_stmt|;
name|dirs
operator|=
name|alloca
argument_list|(
name|numfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dir_info
argument_list|)
argument_list|)
expr_stmt|;
name|fnad
operator|.
name|files
operator|=
name|files
expr_stmt|;
name|fnad
operator|.
name|used_files
operator|=
literal|0
expr_stmt|;
name|fnad
operator|.
name|max_files
operator|=
name|numfiles
expr_stmt|;
name|htab_traverse
argument_list|(
name|file_table
argument_list|,
name|file_name_acquire
argument_list|,
operator|&
name|fnad
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|fnad
operator|.
name|used_files
operator|==
name|fnad
operator|.
name|max_files
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|files
argument_list|,
name|numfiles
argument_list|,
sizeof|sizeof
argument_list|(
name|files
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|file_info_cmp
argument_list|)
expr_stmt|;
comment|/* Find all the different directories used.  */
name|dirs
index|[
literal|0
index|]
operator|.
name|path
operator|=
name|files
index|[
literal|0
index|]
operator|.
name|path
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|files
index|[
literal|0
index|]
operator|.
name|fname
operator|-
name|files
index|[
literal|0
index|]
operator|.
name|path
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|.
name|prefix
operator|=
operator|-
literal|1
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|.
name|dir_idx
operator|=
literal|0
expr_stmt|;
name|files
index|[
literal|0
index|]
operator|.
name|dir_idx
operator|=
literal|0
expr_stmt|;
name|ndirs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numfiles
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|-
name|files
index|[
name|i
index|]
operator|.
name|path
operator|==
name|dirs
index|[
name|ndirs
operator|-
literal|1
index|]
operator|.
name|length
operator|&&
name|memcmp
argument_list|(
name|dirs
index|[
name|ndirs
operator|-
literal|1
index|]
operator|.
name|path
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|path
argument_list|,
name|dirs
index|[
name|ndirs
operator|-
literal|1
index|]
operator|.
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Same directory as last entry.  */
name|files
index|[
name|i
index|]
operator|.
name|dir_idx
operator|=
name|ndirs
operator|-
literal|1
expr_stmt|;
operator|++
name|dirs
index|[
name|ndirs
operator|-
literal|1
index|]
operator|.
name|count
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
comment|/* This is a new directory.  */
name|dirs
index|[
name|ndirs
index|]
operator|.
name|path
operator|=
name|files
index|[
name|i
index|]
operator|.
name|path
expr_stmt|;
name|dirs
index|[
name|ndirs
index|]
operator|.
name|length
operator|=
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|-
name|files
index|[
name|i
index|]
operator|.
name|path
expr_stmt|;
name|dirs
index|[
name|ndirs
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|dirs
index|[
name|ndirs
index|]
operator|.
name|dir_idx
operator|=
name|ndirs
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|dir_idx
operator|=
name|ndirs
expr_stmt|;
comment|/* Search for a prefix.  */
name|dirs
index|[
name|ndirs
index|]
operator|.
name|prefix
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ndirs
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|dirs
index|[
name|j
index|]
operator|.
name|length
operator|<
name|dirs
index|[
name|ndirs
index|]
operator|.
name|length
operator|&&
name|dirs
index|[
name|j
index|]
operator|.
name|length
operator|>
literal|1
operator|&&
operator|(
name|dirs
index|[
name|ndirs
index|]
operator|.
name|prefix
operator|==
operator|-
literal|1
operator|||
name|dirs
index|[
name|j
index|]
operator|.
name|length
operator|>
name|dirs
index|[
name|dirs
index|[
name|ndirs
index|]
operator|.
name|prefix
index|]
operator|.
name|length
operator|)
operator|&&
name|memcmp
argument_list|(
name|dirs
index|[
name|j
index|]
operator|.
name|path
argument_list|,
name|dirs
index|[
name|ndirs
index|]
operator|.
name|path
argument_list|,
name|dirs
index|[
name|j
index|]
operator|.
name|length
argument_list|)
operator|==
literal|0
condition|)
name|dirs
index|[
name|ndirs
index|]
operator|.
name|prefix
operator|=
name|j
expr_stmt|;
operator|++
name|ndirs
expr_stmt|;
block|}
comment|/* Now to the actual work.  We have to find a subset of the directories which      allow expressing the file name using references to the directory table      with the least amount of characters.  We do not do an exhaustive search      where we would have to check out every combination of every single      possible prefix.  Instead we use a heuristic which provides nearly optimal      results in most cases and never is much off.  */
name|saved
operator|=
name|alloca
argument_list|(
name|ndirs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|savehere
operator|=
name|alloca
argument_list|(
name|ndirs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|saved
argument_list|,
literal|'\0'
argument_list|,
name|ndirs
operator|*
sizeof|sizeof
argument_list|(
name|saved
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndirs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|total
decl_stmt|;
comment|/* We can always save some space for the current directory.  But this 	 does not mean it will be enough to justify adding the directory.  */
name|savehere
index|[
name|i
index|]
operator|=
name|dirs
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|total
operator|=
operator|(
name|savehere
index|[
name|i
index|]
operator|-
name|saved
index|[
name|i
index|]
operator|)
operator|*
name|dirs
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|ndirs
condition|;
name|j
operator|++
control|)
block|{
name|savehere
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|saved
index|[
name|j
index|]
operator|<
name|dirs
index|[
name|i
index|]
operator|.
name|length
condition|)
block|{
comment|/* Determine whether the dirs[i] path is a prefix of the 		 dirs[j] path.  */
name|int
name|k
decl_stmt|;
name|k
operator|=
name|dirs
index|[
name|j
index|]
operator|.
name|prefix
expr_stmt|;
while|while
condition|(
name|k
operator|!=
operator|-
literal|1
operator|&&
name|k
operator|!=
operator|(
name|int
operator|)
name|i
condition|)
name|k
operator|=
name|dirs
index|[
name|k
index|]
operator|.
name|prefix
expr_stmt|;
if|if
condition|(
name|k
operator|==
operator|(
name|int
operator|)
name|i
condition|)
block|{
comment|/* Yes it is.  We can possibly save some memory by 		     writing the filenames in dirs[j] relative to 		     dirs[i].  */
name|savehere
index|[
name|j
index|]
operator|=
name|dirs
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|total
operator|+=
operator|(
name|savehere
index|[
name|j
index|]
operator|-
name|saved
index|[
name|j
index|]
operator|)
operator|*
name|dirs
index|[
name|j
index|]
operator|.
name|count
expr_stmt|;
block|}
block|}
block|}
comment|/* Check whether we can save enough to justify adding the dirs[i] 	 directory.  */
if|if
condition|(
name|total
operator|>
name|dirs
index|[
name|i
index|]
operator|.
name|length
operator|+
literal|1
condition|)
block|{
comment|/* It's worthwhile adding.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|ndirs
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|savehere
index|[
name|j
index|]
operator|>
literal|0
condition|)
block|{
comment|/* Remember how much we saved for this directory so far.  */
name|saved
index|[
name|j
index|]
operator|=
name|savehere
index|[
name|j
index|]
expr_stmt|;
comment|/* Remember the prefix directory.  */
name|dirs
index|[
name|j
index|]
operator|.
name|dir_idx
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
comment|/* Emit the directory name table.  */
name|idx
operator|=
literal|1
expr_stmt|;
name|idx_offset
operator|=
name|dirs
index|[
literal|0
index|]
operator|.
name|length
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|-
name|idx_offset
init|;
name|i
operator|<
name|ndirs
condition|;
name|i
operator|++
control|)
name|dw2_asm_output_nstring
argument_list|(
name|dirs
index|[
name|i
index|]
operator|.
name|path
argument_list|,
name|dirs
index|[
name|i
index|]
operator|.
name|length
operator|-
literal|1
argument_list|,
literal|"Directory Entry: 0x%x"
argument_list|,
name|i
operator|+
name|idx_offset
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"End directory table"
argument_list|)
expr_stmt|;
comment|/* We have to emit them in the order of emitted_number since that's      used in the debug info generation.  To do this efficiently we      generate a back-mapping of the indices first.  */
name|backmap
operator|=
name|alloca
argument_list|(
name|numfiles
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numfiles
condition|;
name|i
operator|++
control|)
name|backmap
index|[
name|files
index|[
name|i
index|]
operator|.
name|file_idx
operator|->
name|emitted_number
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
comment|/* Now write all the file names.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numfiles
condition|;
name|i
operator|++
control|)
block|{
name|int
name|file_idx
init|=
name|backmap
index|[
name|i
index|]
decl_stmt|;
name|int
name|dir_idx
init|=
name|dirs
index|[
name|files
index|[
name|file_idx
index|]
operator|.
name|dir_idx
index|]
operator|.
name|dir_idx
decl_stmt|;
name|dw2_asm_output_nstring
argument_list|(
name|files
index|[
name|file_idx
index|]
operator|.
name|path
operator|+
name|dirs
index|[
name|dir_idx
index|]
operator|.
name|length
argument_list|,
operator|-
literal|1
argument_list|,
literal|"File Entry: 0x%x"
argument_list|,
operator|(
name|unsigned
operator|)
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Include directory index.  */
name|dw2_asm_output_data_uleb128
argument_list|(
name|dir_idx
operator|+
name|idx_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Modification time.  */
name|dw2_asm_output_data_uleb128
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* File length in bytes.  */
name|dw2_asm_output_data_uleb128
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"End file name table"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the source line number correspondence information.  This    information goes into the .debug_line section.  */
end_comment

begin_function
specifier|static
name|void
name|output_line_info
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|l1
index|[
literal|20
index|]
decl_stmt|,
name|l2
index|[
literal|20
index|]
decl_stmt|,
name|p1
index|[
literal|20
index|]
decl_stmt|,
name|p2
index|[
literal|20
index|]
decl_stmt|;
name|char
name|line_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|prev_line_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|unsigned
name|opc
decl_stmt|;
name|unsigned
name|n_op_args
decl_stmt|;
name|unsigned
name|long
name|lt_index
decl_stmt|;
name|unsigned
name|long
name|current_line
decl_stmt|;
name|long
name|line_offset
decl_stmt|;
name|long
name|line_delta
decl_stmt|;
name|unsigned
name|long
name|current_file
decl_stmt|;
name|unsigned
name|long
name|function
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
name|LINE_NUMBER_BEGIN_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l2
argument_list|,
name|LINE_NUMBER_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|p1
argument_list|,
name|LN_PROLOG_AS_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|p2
argument_list|,
name|LN_PROLOG_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DWARF_INITIAL_LENGTH_SIZE
operator|-
name|DWARF_OFFSET_SIZE
operator|==
literal|4
condition|)
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
literal|0xffffffff
argument_list|,
literal|"Initial length escape value indicating 64-bit DWARF extension"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|,
literal|"Length of Source Line Info"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|DWARF_VERSION
argument_list|,
literal|"DWARF Version"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|p2
argument_list|,
name|p1
argument_list|,
literal|"Prolog Length"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|p1
argument_list|)
expr_stmt|;
comment|/* Define the architecture-dependent minimum instruction length (in    bytes).  In this implementation of DWARF, this field is used for    information purposes only.  Since GCC generates assembly language,    we have no a priori knowledge of how many instruction bytes are    generated for each source line, and therefore can use only the    DW_LNE_set_address and DW_LNS_fixed_advance_pc line information    commands.  Accordingly, we fix this as `1', which is "correct    enough" for all architectures, and don't let the target override.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Minimum Instruction Length"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_DEFAULT_IS_STMT_START
argument_list|,
literal|"Default is_stmt_start flag"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_BASE
argument_list|,
literal|"Line Base Value (Special Opcodes)"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_RANGE
argument_list|,
literal|"Line Range Value (Special Opcodes)"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_OPCODE_BASE
argument_list|,
literal|"Special Opcode Base"
argument_list|)
expr_stmt|;
for|for
control|(
name|opc
operator|=
literal|1
init|;
name|opc
operator|<
name|DWARF_LINE_OPCODE_BASE
condition|;
name|opc
operator|++
control|)
block|{
switch|switch
condition|(
name|opc
condition|)
block|{
case|case
name|DW_LNS_advance_pc
case|:
case|case
name|DW_LNS_advance_line
case|:
case|case
name|DW_LNS_set_file
case|:
case|case
name|DW_LNS_set_column
case|:
case|case
name|DW_LNS_fixed_advance_pc
case|:
name|n_op_args
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|n_op_args
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|n_op_args
argument_list|,
literal|"opcode: 0x%x has %d args"
argument_list|,
name|opc
argument_list|,
name|n_op_args
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the information about the files we use.  */
name|output_file_names
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|p2
argument_list|)
expr_stmt|;
comment|/* We used to set the address register to the first location in the text      section here, but that didn't accomplish anything since we already      have a line note for the opening brace of the first function.  */
comment|/* Generate the line number to PC correspondence table, encoded as      a series of state machine operations.  */
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cfun
operator|&&
name|in_cold_section_p
condition|)
name|strcpy
argument_list|(
name|prev_line_label
argument_list|,
name|cfun
operator|->
name|cold_section_label
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|prev_line_label
argument_list|,
name|text_section_label
argument_list|)
expr_stmt|;
for|for
control|(
name|lt_index
operator|=
literal|1
init|;
name|lt_index
operator|<
name|line_info_table_in_use
condition|;
operator|++
name|lt_index
control|)
block|{
name|dw_line_info_ref
name|line_info
init|=
operator|&
name|line_info_table
index|[
name|lt_index
index|]
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Disable this optimization for now; GDB wants to see two line notes 	 at the beginning of a function so it can find the end of the 	 prologue.  */
comment|/* Don't emit anything for redundant notes.  Just updating the 	 address doesn't accomplish anything, because we already assume 	 that anything after the last address is this line.  */
block|if (line_info->dw_line_num == current_line&& line_info->dw_file_num == current_file) 	continue;
endif|#
directive|endif
comment|/* Emit debug info for the address of the current line.  	 Unfortunately, we have little choice here currently, and must always 	 use the most general form.  GCC does not know the address delta 	 itself, so we can't use DW_LNS_advance_pc.  Many ports do have length 	 attributes which will give an upper bound on the address range.  We 	 could perhaps use length attributes to determine when it is safe to 	 use DW_LNS_fixed_advance_pc.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|line_label
argument_list|,
name|LINE_CODE_LABEL
argument_list|,
name|lt_index
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
comment|/* This can handle deltas up to 0xffff.  This takes 3 bytes.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|,
literal|"DW_LNS_fixed_advance_pc"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
literal|2
argument_list|,
name|line_label
argument_list|,
name|prev_line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This can handle any delta.  This takes 	     4+DWARF2_ADDR_SIZE bytes.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_set_address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
operator|+
name|DWARF2_ADDR_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_set_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|prev_line_label
argument_list|,
name|line_label
argument_list|)
expr_stmt|;
comment|/* Emit debug info for the source file of the current line, if 	 different from the previous line.  */
if|if
condition|(
name|line_info
operator|->
name|dw_file_num
operator|!=
name|current_file
condition|)
block|{
name|current_file
operator|=
name|line_info
operator|->
name|dw_file_num
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_set_file
argument_list|,
literal|"DW_LNS_set_file"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|current_file
argument_list|,
literal|"%lu"
argument_list|,
name|current_file
argument_list|)
expr_stmt|;
block|}
comment|/* Emit debug info for the current line number, choosing the encoding 	 that uses the least amount of space.  */
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|!=
name|current_line
condition|)
block|{
name|line_offset
operator|=
name|line_info
operator|->
name|dw_line_num
operator|-
name|current_line
expr_stmt|;
name|line_delta
operator|=
name|line_offset
operator|-
name|DWARF_LINE_BASE
expr_stmt|;
name|current_line
operator|=
name|line_info
operator|->
name|dw_line_num
expr_stmt|;
if|if
condition|(
name|line_delta
operator|>=
literal|0
operator|&&
name|line_delta
operator|<
operator|(
name|DWARF_LINE_RANGE
operator|-
literal|1
operator|)
condition|)
comment|/* This can handle deltas from -10 to 234, using the current 	       definitions of DWARF_LINE_BASE and DWARF_LINE_RANGE.  This 	       takes 1 byte.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_OPCODE_BASE
operator|+
name|line_delta
argument_list|,
literal|"line %lu"
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This can handle any delta.  This takes at least 4 bytes, 		 depending on the value being encoded.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_advance_line
argument_list|,
literal|"advance to line %lu"
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_sleb128
argument_list|(
name|line_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_copy
argument_list|,
literal|"DW_LNS_copy"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* We still need to start a new row, so output a copy insn.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_copy
argument_list|,
literal|"DW_LNS_copy"
argument_list|)
expr_stmt|;
block|}
comment|/* Emit debug info for the address of the end of the function.  */
if|if
condition|(
literal|0
condition|)
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|,
literal|"DW_LNS_fixed_advance_pc"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
literal|2
argument_list|,
name|text_end_label
argument_list|,
name|prev_line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_set_address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
operator|+
name|DWARF2_ADDR_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_set_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|text_end_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_end_sequence"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_end_sequence
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|function
operator|=
literal|0
expr_stmt|;
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|lt_index
operator|=
literal|0
init|;
name|lt_index
operator|<
name|separate_line_info_table_in_use
condition|;
control|)
block|{
name|dw_separate_line_info_ref
name|line_info
init|=
operator|&
name|separate_line_info_table
index|[
name|lt_index
index|]
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Don't emit anything for redundant notes.  */
block|if (line_info->dw_line_num == current_line&& line_info->dw_file_num == current_file&& line_info->function == function) 	goto cont;
endif|#
directive|endif
comment|/* Emit debug info for the address of the current line.  If this is 	 a new function, or the first line of a function, then we need 	 to handle it differently.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|line_label
argument_list|,
name|SEPARATE_LINE_CODE_LABEL
argument_list|,
name|lt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|!=
name|line_info
operator|->
name|function
condition|)
block|{
name|function
operator|=
name|line_info
operator|->
name|function
expr_stmt|;
comment|/* Set the address register to the first line in the function.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_set_address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
operator|+
name|DWARF2_ADDR_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_set_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? See the DW_LNS_advance_pc comment above.  */
if|if
condition|(
literal|0
condition|)
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|,
literal|"DW_LNS_fixed_advance_pc"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
literal|2
argument_list|,
name|line_label
argument_list|,
name|prev_line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_set_address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
operator|+
name|DWARF2_ADDR_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_set_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|prev_line_label
argument_list|,
name|line_label
argument_list|)
expr_stmt|;
comment|/* Emit debug info for the source file of the current line, if 	 different from the previous line.  */
if|if
condition|(
name|line_info
operator|->
name|dw_file_num
operator|!=
name|current_file
condition|)
block|{
name|current_file
operator|=
name|line_info
operator|->
name|dw_file_num
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_set_file
argument_list|,
literal|"DW_LNS_set_file"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|current_file
argument_list|,
literal|"%lu"
argument_list|,
name|current_file
argument_list|)
expr_stmt|;
block|}
comment|/* Emit debug info for the current line number, choosing the encoding 	 that uses the least amount of space.  */
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|!=
name|current_line
condition|)
block|{
name|line_offset
operator|=
name|line_info
operator|->
name|dw_line_num
operator|-
name|current_line
expr_stmt|;
name|line_delta
operator|=
name|line_offset
operator|-
name|DWARF_LINE_BASE
expr_stmt|;
name|current_line
operator|=
name|line_info
operator|->
name|dw_line_num
expr_stmt|;
if|if
condition|(
name|line_delta
operator|>=
literal|0
operator|&&
name|line_delta
operator|<
operator|(
name|DWARF_LINE_RANGE
operator|-
literal|1
operator|)
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_OPCODE_BASE
operator|+
name|line_delta
argument_list|,
literal|"line %lu"
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
else|else
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_advance_line
argument_list|,
literal|"advance to line %lu"
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_sleb128
argument_list|(
name|line_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_copy
argument_list|,
literal|"DW_LNS_copy"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_copy
argument_list|,
literal|"DW_LNS_copy"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|cont:
endif|#
directive|endif
name|lt_index
operator|++
expr_stmt|;
comment|/* If we're done with a function, end its sequence.  */
if|if
condition|(
name|lt_index
operator|==
name|separate_line_info_table_in_use
operator|||
name|separate_line_info_table
index|[
name|lt_index
index|]
operator|.
name|function
operator|!=
name|function
condition|)
block|{
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
comment|/* Emit debug info for the address of the end of the function.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|line_label
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|,
literal|"DW_LNS_fixed_advance_pc"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
literal|2
argument_list|,
name|line_label
argument_list|,
name|prev_line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_set_address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
operator|+
name|DWARF2_ADDR_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_set_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Output the marker for the end of this sequence.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_end_sequence"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_end_sequence
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output the marker for the end of the line number info.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to a tree node for some base type, return a pointer to    a DIE that describes the given type.     This routine must only be called for GCC type nodes that correspond to    Dwarf base (fundamental) types.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|base_type_die
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|dw_die_ref
name|base_type_result
decl_stmt|;
name|enum
name|dwarf_type
name|encoding
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|encoding
operator|=
name|DW_ATE_unsigned_char
expr_stmt|;
else|else
name|encoding
operator|=
name|DW_ATE_signed_char
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|encoding
operator|=
name|DW_ATE_unsigned
expr_stmt|;
else|else
name|encoding
operator|=
name|DW_ATE_signed
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|encoding
operator|=
name|DW_ATE_decimal_float
expr_stmt|;
else|else
name|encoding
operator|=
name|DW_ATE_float
expr_stmt|;
break|break;
comment|/* Dwarf2 doesn't know anything about complex ints, so use 	 a user defined type for it.  */
case|case
name|COMPLEX_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|encoding
operator|=
name|DW_ATE_complex_float
expr_stmt|;
else|else
name|encoding
operator|=
name|DW_ATE_lo_user
expr_stmt|;
break|break;
case|case
name|BOOLEAN_TYPE
case|:
comment|/* GNU FORTRAN/Ada/C++ BOOLEAN type.  */
name|encoding
operator|=
name|DW_ATE_boolean
expr_stmt|;
break|break;
default|default:
comment|/* No other TREE_CODEs are Dwarf fundamental types.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|base_type_result
operator|=
name|new_die
argument_list|(
name|DW_TAG_base_type
argument_list|,
name|comp_unit_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* This probably indicates a bug.  */
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
name|add_name_attribute
argument_list|(
name|base_type_result
argument_list|,
literal|"__unknown__"
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|base_type_result
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|base_type_result
argument_list|,
name|DW_AT_encoding
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
return|return
name|base_type_result
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return a pointer to    the Dwarf "root" type for the given input type.  The Dwarf "root" type of    a given type is generally the same as the given type, except that if the    given type is a pointer or reference type, then the root type of the given    type is the root type of the "basis" type for the pointer or reference    type.  (This definition of the "root" type is recursive.) Also, the root    type of a `const' qualified type or a `volatile' qualified type is the    root type of the given type without the qualifiers.  */
end_comment

begin_function
specifier|static
name|tree
name|root_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|type_main_variant
argument_list|(
name|root_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|type_main_variant
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return nonzero if the    given input type is a Dwarf "fundamental" type.  Otherwise return null.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_base_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
return|return
literal|1
return|;
case|case
name|ARRAY_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|LANG_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
return|return
literal|0
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE    node, return the size in bits for the type if it is a constant, or else    return the alignment for the type if the type's size is not constant, or    else return BITS_PER_WORD if the type actually turns out to be an    ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|HOST_WIDE_INT
name|simple_type_size_in_bits
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|BITS_PER_WORD
return|;
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if the debug information for the given type should be    emitted as a subrange type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|is_subrange_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|subtype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Subrange types are identified by the fact that they are integer      types, and that they have a subtype which is either an integer type      or an enumeral type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|||
name|subtype
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|subtype
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|subtype
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TREE_CODE
argument_list|(
name|subtype
argument_list|)
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|==
name|int_size_in_bytes
argument_list|(
name|subtype
argument_list|)
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|subtype
argument_list|)
operator|!=
name|NULL
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|subtype
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|subtype
argument_list|)
operator|!=
name|NULL
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|subtype
argument_list|)
argument_list|)
condition|)
block|{
comment|/* The type and its subtype have the same representation.  If in          addition the two types also have the same name, then the given          type is not a subrange type, but rather a plain base type.  */
comment|/* FIXME: brobecker/2004-03-22:          Sizetype INTEGER_CSTs nodes are canonicalized.  It should          therefore be sufficient to check the TYPE_SIZE node pointers          rather than checking the actual size.  Unfortunately, we have          found some cases, such as in the Ada "integer" type, where          this is not the case.  Until this problem is solved, we need to          keep checking the actual size.  */
name|tree
name|type_name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|subtype_name
init|=
name|TYPE_NAME
argument_list|(
name|subtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|type_name
operator|!=
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|type_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|type_name
operator|=
name|DECL_NAME
argument_list|(
name|type_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype_name
operator|!=
name|NULL
operator|&&
name|TREE_CODE
argument_list|(
name|subtype_name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|subtype_name
operator|=
name|DECL_NAME
argument_list|(
name|subtype_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_name
operator|==
name|subtype_name
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  Given a pointer to a tree node for a subrange type, return a pointer     to a DIE that describes the given type.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|subrange_type_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|subrange_die
decl_stmt|;
specifier|const
name|HOST_WIDE_INT
name|size_in_bytes
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|context_die
operator|==
name|NULL
condition|)
name|context_die
operator|=
name|comp_unit_die
expr_stmt|;
name|subrange_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subrange_type
argument_list|,
name|context_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|size_in_bytes
condition|)
block|{
comment|/* The size of the subrange type and its base type do not match,          so we need to generate a size attribute for the subrange type.  */
name|add_AT_unsigned
argument_list|(
name|subrange_die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|size_in_bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
name|add_bound_info
argument_list|(
name|subrange_die
argument_list|,
name|DW_AT_lower_bound
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
name|add_bound_info
argument_list|(
name|subrange_die
argument_list|,
name|DW_AT_upper_bound
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|subrange_die
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return a debugging    entry that chains various modifiers in front of the given type.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|modified_type_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|is_const_type
parameter_list|,
name|int
name|is_volatile_type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|dw_die_ref
name|mod_type_die
decl_stmt|;
name|dw_die_ref
name|sub_die
init|=
name|NULL
decl_stmt|;
name|tree
name|item_type
init|=
name|NULL
decl_stmt|;
name|tree
name|qualified_type
decl_stmt|;
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return
name|NULL
return|;
comment|/* See if we already have the appropriately qualified variant of      this type.  */
name|qualified_type
operator|=
name|get_qualified_type
argument_list|(
name|type
argument_list|,
operator|(
operator|(
name|is_const_type
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|is_volatile_type
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If we do, then we can just use its DIE, if it exists.  */
if|if
condition|(
name|qualified_type
condition|)
block|{
name|mod_type_die
operator|=
name|lookup_type_die
argument_list|(
name|qualified_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_type_die
condition|)
return|return
name|mod_type_die
return|;
block|}
name|name
operator|=
name|qualified_type
condition|?
name|TYPE_NAME
argument_list|(
name|qualified_type
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* Handle C typedef types.  */
if|if
condition|(
name|name
operator|&&
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|tree
name|dtype
init|=
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|qualified_type
operator|==
name|dtype
condition|)
block|{
comment|/* For a named type, use the typedef.  */
name|gen_type_die
argument_list|(
name|qualified_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
return|return
name|lookup_type_die
argument_list|(
name|qualified_type
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|is_const_type
operator|<
name|TYPE_READONLY
argument_list|(
name|dtype
argument_list|)
operator|||
name|is_volatile_type
operator|<
name|TYPE_VOLATILE
argument_list|(
name|dtype
argument_list|)
operator|||
operator|(
name|is_const_type
operator|<=
name|TYPE_READONLY
argument_list|(
name|dtype
argument_list|)
operator|&&
name|is_volatile_type
operator|<=
name|TYPE_VOLATILE
argument_list|(
name|dtype
argument_list|)
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|name
argument_list|)
operator|!=
name|type
operator|)
condition|)
comment|/* cv-unqualified version of named type.  Just use the unnamed 	   type to which it refers.  */
return|return
name|modified_type_die
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|name
argument_list|)
argument_list|,
name|is_const_type
argument_list|,
name|is_volatile_type
argument_list|,
name|context_die
argument_list|)
return|;
comment|/* Else cv-qualified version of named type; fall through.  */
block|}
if|if
condition|(
name|is_const_type
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_const_type
argument_list|,
name|comp_unit_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|sub_die
operator|=
name|modified_type_die
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|is_volatile_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_volatile_type
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_volatile_type
argument_list|,
name|comp_unit_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|sub_die
operator|=
name|modified_type_die
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_pointer_type
argument_list|,
name|comp_unit_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|mod_type_die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|item_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_reference_type
argument_list|,
name|comp_unit_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|mod_type_die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|item_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_subrange_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|mod_type_die
operator|=
name|subrange_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|item_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_base_type
argument_list|(
name|type
argument_list|)
condition|)
name|mod_type_die
operator|=
name|base_type_die
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|gen_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* We have to get the type_main_variant here (and pass that to the 	 `lookup_type_die' routine) because the ..._TYPE node we have 	 might simply be a *copy* of some original type node (where the 	 copy was created to help us keep track of typedef names) and 	 that copy might have a different TYPE_UID from the original 	 ..._TYPE node.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VECTOR_TYPE
condition|)
return|return
name|lookup_type_die
argument_list|(
name|type_main_variant
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
else|else
comment|/* Vectors have the debugging information in the type, 	   not the main variant.  */
return|return
name|lookup_type_die
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/* Builtin types don't have a DECL_ORIGINAL_TYPE.  For those,      don't output a DW_TAG_typedef, since there isn't one in the      user's program; just attach a DW_AT_name to the type.  */
if|if
condition|(
name|name
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|!=
name|TYPE_DECL
operator|||
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
operator|==
name|qualified_type
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
comment|/* Could just call add_name_and_src_coords_attributes here, 	   but since this is a builtin type it doesn't have any 	   useful source coordinates anyway.  */
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|add_name_attribute
argument_list|(
name|mod_type_die
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qualified_type
condition|)
name|equate_type_number_to_die
argument_list|(
name|qualified_type
argument_list|,
name|mod_type_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|item_type
condition|)
comment|/* We must do this after the equate_type_number_to_die call, in case        this is a recursive type.  This ensures that the modified_type_die        recursion will terminate even if the type is recursive.  Recursive        types are possible in Ada.  */
name|sub_die
operator|=
name|modified_type_die
argument_list|(
name|item_type
argument_list|,
name|TYPE_READONLY
argument_list|(
name|item_type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|item_type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_die
operator|!=
name|NULL
condition|)
name|add_AT_die_ref
argument_list|(
name|mod_type_die
argument_list|,
name|DW_AT_type
argument_list|,
name|sub_die
argument_list|)
expr_stmt|;
return|return
name|mod_type_die
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return true if it is    an enumerated type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|type_is_enum
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
return|;
block|}
end_function

begin_comment
comment|/* Return the DBX register number described by a given RTL node.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|dbx_reg_number
parameter_list|(
name|rtx
name|rtl
parameter_list|)
block|{
name|unsigned
name|regno
init|=
name|REGNO
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
block|{
name|int
name|leaf_reg
init|=
name|LEAF_REG_REMAP
argument_list|(
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|leaf_reg
operator|!=
operator|-
literal|1
condition|)
name|regno
operator|=
operator|(
name|unsigned
operator|)
name|leaf_reg
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|DBX_REGISTER_NUMBER
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Optionally add a DW_OP_piece term to a location description expression.    DW_OP_piece is only added if the location description expression already    doesn't end with DW_OP_piece.  */
end_comment

begin_function
specifier|static
name|void
name|add_loc_descr_op_piece
parameter_list|(
name|dw_loc_descr_ref
modifier|*
name|list_head
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|dw_loc_descr_ref
name|loc
decl_stmt|;
if|if
condition|(
operator|*
name|list_head
operator|!=
name|NULL
condition|)
block|{
comment|/* Find the end of the chain.  */
for|for
control|(
name|loc
operator|=
operator|*
name|list_head
init|;
name|loc
operator|->
name|dw_loc_next
operator|!=
name|NULL
condition|;
name|loc
operator|=
name|loc
operator|->
name|dw_loc_next
control|)
empty_stmt|;
if|if
condition|(
name|loc
operator|->
name|dw_loc_opc
operator|!=
name|DW_OP_piece
condition|)
name|loc
operator|->
name|dw_loc_next
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_piece
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return a location descriptor that designates a machine register or    zero if there is none.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|reg_loc_descriptor
parameter_list|(
name|rtx
name|rtl
parameter_list|)
block|{
name|rtx
name|regs
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
name|regs
operator|=
name|targetm
operator|.
name|dwarf_register_span
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|hard_regno_nregs
index|[
name|REGNO
argument_list|(
name|rtl
argument_list|)
index|]
index|[
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
index|]
operator|>
literal|1
operator|||
name|regs
condition|)
return|return
name|multiple_reg_loc_descriptor
argument_list|(
name|rtl
argument_list|,
name|regs
argument_list|)
return|;
else|else
return|return
name|one_reg_loc_descriptor
argument_list|(
name|dbx_reg_number
argument_list|(
name|rtl
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a location descriptor that designates a machine register for    a given hard register number.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|one_reg_loc_descriptor
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|<=
literal|31
condition|)
return|return
name|new_loc_descr
argument_list|(
name|DW_OP_reg0
operator|+
name|regno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|new_loc_descr
argument_list|(
name|DW_OP_regx
argument_list|,
name|regno
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an RTL of a register, return a location descriptor that    designates a value that spans more than one register.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|multiple_reg_loc_descriptor
parameter_list|(
name|rtx
name|rtl
parameter_list|,
name|rtx
name|regs
parameter_list|)
block|{
name|int
name|nregs
decl_stmt|,
name|size
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|dw_loc_descr_ref
name|loc_result
init|=
name|NULL
decl_stmt|;
name|reg
operator|=
name|REGNO
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
block|{
name|int
name|leaf_reg
init|=
name|LEAF_REG_REMAP
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|leaf_reg
operator|!=
operator|-
literal|1
condition|)
name|reg
operator|=
operator|(
name|unsigned
operator|)
name|leaf_reg
expr_stmt|;
block|}
endif|#
directive|endif
name|gcc_assert
argument_list|(
operator|(
name|unsigned
operator|)
name|DBX_REGISTER_NUMBER
argument_list|(
name|reg
argument_list|)
operator|==
name|dbx_reg_number
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
name|nregs
operator|=
name|hard_regno_nregs
index|[
name|REGNO
argument_list|(
name|rtl
argument_list|)
index|]
index|[
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
index|]
expr_stmt|;
comment|/* Simple, contiguous registers.  */
if|if
condition|(
name|regs
operator|==
name|NULL_RTX
condition|)
block|{
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
argument_list|)
operator|/
name|nregs
expr_stmt|;
name|loc_result
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|nregs
operator|--
condition|)
block|{
name|dw_loc_descr_ref
name|t
decl_stmt|;
name|t
operator|=
name|one_reg_loc_descriptor
argument_list|(
name|DBX_REGISTER_NUMBER
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_result
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|add_loc_descr_op_piece
argument_list|(
operator|&
name|loc_result
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|++
name|reg
expr_stmt|;
block|}
return|return
name|loc_result
return|;
block|}
comment|/* Now onto stupid register sets in non contiguous locations.  */
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|regs
argument_list|)
operator|==
name|PARALLEL
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XVECEXP
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|loc_result
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|dw_loc_descr_ref
name|t
decl_stmt|;
name|t
operator|=
name|one_reg_loc_descriptor
argument_list|(
name|REGNO
argument_list|(
name|XVECEXP
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_result
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|XVECEXP
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr_op_piece
argument_list|(
operator|&
name|loc_result
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|loc_result
return|;
block|}
end_function

begin_comment
comment|/* Return a location descriptor that designates a constant.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|int_loc_descriptor
parameter_list|(
name|HOST_WIDE_INT
name|i
parameter_list|)
block|{
name|enum
name|dwarf_location_atom
name|op
decl_stmt|;
comment|/* Pick the smallest representation of a constant, rather than just      defaulting to the LEB encoding.  */
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|<=
literal|31
condition|)
name|op
operator|=
name|DW_OP_lit0
operator|+
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<=
literal|0xff
condition|)
name|op
operator|=
name|DW_OP_const1u
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<=
literal|0xffff
condition|)
name|op
operator|=
name|DW_OP_const2u
expr_stmt|;
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
operator|||
name|i
operator|<=
literal|0xffffffff
condition|)
name|op
operator|=
name|DW_OP_const4u
expr_stmt|;
else|else
name|op
operator|=
name|DW_OP_constu
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|>=
operator|-
literal|0x80
condition|)
name|op
operator|=
name|DW_OP_const1s
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>=
operator|-
literal|0x8000
condition|)
name|op
operator|=
name|DW_OP_const2s
expr_stmt|;
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
operator|||
name|i
operator|>=
operator|-
literal|0x80000000
condition|)
name|op
operator|=
name|DW_OP_const4s
expr_stmt|;
else|else
name|op
operator|=
name|DW_OP_consts
expr_stmt|;
block|}
return|return
name|new_loc_descr
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a location descriptor that designates a base+offset location.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|based_loc_descr
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|unsigned
name|int
name|regno
decl_stmt|;
comment|/* We only use "frame base" when we're sure we're talking about the      post-prologue local stack frame.  We do this by *not* running      register elimination until this point, and recognizing the special      argument pointer and soft frame pointer rtx's.  */
if|if
condition|(
name|reg
operator|==
name|arg_pointer_rtx
operator|||
name|reg
operator|==
name|frame_pointer_rtx
condition|)
block|{
name|rtx
name|elim
init|=
name|eliminate_regs
argument_list|(
name|reg
argument_list|,
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
if|if
condition|(
name|elim
operator|!=
name|reg
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|elim
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|elim
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|elim
operator|=
name|XEXP
argument_list|(
name|elim
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|elim
operator|==
operator|(
name|frame_pointer_needed
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|frame_pointer_fb_offset
expr_stmt|;
return|return
name|new_loc_descr
argument_list|(
name|DW_OP_fbreg
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
name|regno
operator|=
name|dbx_reg_number
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<=
literal|31
condition|)
return|return
name|new_loc_descr
argument_list|(
name|DW_OP_breg0
operator|+
name|regno
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
return|;
else|else
return|return
name|new_loc_descr
argument_list|(
name|DW_OP_bregx
argument_list|,
name|regno
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if this RTL expression describes a base+offset calculation.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_based_loc
parameter_list|(
name|rtx
name|rtl
parameter_list|)
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following routine converts the RTL for a variable or parameter    (resident in memory) into an equivalent Dwarf representation of a    mechanism for getting the address of that same variable onto the top of a    hypothetical "address evaluation" stack.     When creating memory location descriptors, we are effectively transforming    the RTL for a memory-resident object into its Dwarf postfix expression    equivalent.  This routine recursively descends an RTL tree, turning    it into Dwarf postfix code as it goes.     MODE is the mode of the memory reference, needed to handle some    autoincrement addressing modes.     CAN_USE_FBREG is a flag whether we can use DW_AT_frame_base in the    location list for RTL.     Return 0 if we can't represent the location.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|mem_loc_descriptor
parameter_list|(
name|rtx
name|rtl
parameter_list|,
name|enum
name|machine_mode
name|mode
parameter_list|)
block|{
name|dw_loc_descr_ref
name|mem_loc_result
init|=
name|NULL
decl_stmt|;
name|enum
name|dwarf_location_atom
name|op
decl_stmt|;
comment|/* Note that for a dynamically sized array, the location we will generate a      description of here will be the lowest numbered location which is      actually within the array.  That's *not* necessarily the same as the      zeroth element of the array.  */
name|rtl
operator|=
name|targetm
operator|.
name|delegitimize_address
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_MODIFY
case|:
comment|/* POST_INC and POST_DEC can be handled just like a SUBREG.  So we 	 just fall into the SUBREG code.  */
comment|/* ... fall through ...  */
case|case
name|SUBREG
case|:
comment|/* The case of a subreg may arise when we have a local (register) 	 variable or a formal (register) parameter which doesn't quite fill 	 up an entire register.  For now, just assume that it is 	 legitimate to make the Dwarf info refer to the whole register which 	 contains the given subreg.  */
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|REG
case|:
comment|/* Whenever a register number forms a part of the description of the 	 method for calculating the (dynamic) address of a memory resident 	 object, DWARF rules require the register number be referred to as 	 a "base register".  This distinction is not based in any way upon 	 what category of register the hardware believes the given register 	 belongs to.  This is strictly DWARF terminology we're dealing with 	 here. Note that in cases where the location of a memory-resident 	 data object could be expressed as: OP_ADD (OP_BASEREG (basereg), 	 OP_CONST (0)) the actual DWARF location descriptor that we generate 	 may just be OP_BASEREG (basereg).  This may look deceptively like 	 the object in question was allocated to a register (rather than in 	 memory) so DWARF consumers need to be aware of the subtle 	 distinction between OP_REG and OP_BASEREG.  */
if|if
condition|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|mem_loc_result
operator|=
name|based_loc_descr
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|mem_loc_result
operator|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_loc_result
operator|!=
literal|0
condition|)
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_deref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LO_SUM
case|:
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|LABEL_REF
case|:
comment|/* Some ports can transform a symbol ref into a label ref, because 	 the symbol ref is too far away and has to be dumped into a constant 	 pool.  */
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
comment|/* Alternatively, the symbol in the constant pool might be referenced 	 by a different symbol.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
name|bool
name|marked
decl_stmt|;
name|rtx
name|tmp
init|=
name|get_pool_constant_mark
argument_list|(
name|rtl
argument_list|,
operator|&
name|marked
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|rtl
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|get_pool_constant_mark
argument_list|(
name|tmp
argument_list|,
operator|&
name|marked
argument_list|)
expr_stmt|;
else|else
name|marked
operator|=
name|true
expr_stmt|;
block|}
comment|/* If all references to this pool constant were optimized away, 	     it was not output and thus we can't represent it. 	     FIXME: might try to use DW_OP_const_value here, though 	     DW_OP_piece complicates it.  */
if|if
condition|(
operator|!
name|marked
condition|)
return|return
literal|0
return|;
block|}
name|mem_loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem_loc_result
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_addr
expr_stmt|;
name|mem_loc_result
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_addr
operator|=
name|rtl
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|rtx
argument_list|,
name|gc
argument_list|,
name|used_rtx_array
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_MODIFY
case|:
comment|/* Extract the PLUS expression nested inside and fall into 	 PLUS code below.  */
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|plus
goto|;
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
comment|/* Turn these into a PLUS expression and fall into the PLUS code 	 below.  */
name|rtl
operator|=
name|gen_rtx_PLUS
argument_list|(
name|word_mode
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|PRE_INC
condition|?
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
else|:
operator|-
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|PLUS
case|:
name|plus
label|:
if|if
condition|(
name|is_based_loc
argument_list|(
name|rtl
argument_list|)
condition|)
name|mem_loc_result
operator|=
name|based_loc_descr
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|mem_loc_result
operator|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_loc_result
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus_uconst
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* If a pseudo-reg is optimized away, it is possible for it to        be replaced with a MEM containing a multiply or shift.  */
case|case
name|MULT
case|:
name|op
operator|=
name|DW_OP_mul
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|ASHIFT
case|:
name|op
operator|=
name|DW_OP_shl
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|ASHIFTRT
case|:
name|op
operator|=
name|DW_OP_shra
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|LSHIFTRT
case|:
name|op
operator|=
name|DW_OP_shr
expr_stmt|;
goto|goto
name|do_binop
goto|;
name|do_binop
label|:
block|{
name|dw_loc_descr_ref
name|op0
init|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|dw_loc_descr_ref
name|op1
init|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|==
literal|0
operator|||
name|op1
operator|==
literal|0
condition|)
break|break;
name|mem_loc_result
operator|=
name|op0
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CONST_INT
case|:
name|mem_loc_result
operator|=
name|int_loc_descriptor
argument_list|(
name|INTVAL
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|mem_loc_result
return|;
block|}
end_function

begin_comment
comment|/* Return a descriptor that describes the concatenation of two locations.    This is typically a complex variable.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|concat_loc_descriptor
parameter_list|(
name|rtx
name|x0
parameter_list|,
name|rtx
name|x1
parameter_list|)
block|{
name|dw_loc_descr_ref
name|cc_loc_result
init|=
name|NULL
decl_stmt|;
name|dw_loc_descr_ref
name|x0_ref
init|=
name|loc_descriptor
argument_list|(
name|x0
argument_list|)
decl_stmt|;
name|dw_loc_descr_ref
name|x1_ref
init|=
name|loc_descriptor
argument_list|(
name|x1
argument_list|)
decl_stmt|;
if|if
condition|(
name|x0_ref
operator|==
literal|0
operator|||
name|x1_ref
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|cc_loc_result
operator|=
name|x0_ref
expr_stmt|;
name|add_loc_descr_op_piece
argument_list|(
operator|&
name|cc_loc_result
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|cc_loc_result
argument_list|,
name|x1_ref
argument_list|)
expr_stmt|;
name|add_loc_descr_op_piece
argument_list|(
operator|&
name|cc_loc_result
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_loc_result
return|;
block|}
end_function

begin_comment
comment|/* Output a proper Dwarf location descriptor for a variable or parameter    which is either allocated in a register or in a memory location.  For a    register, we just generate an OP_REG and the register number.  For a    memory location we provide a Dwarf postfix expression describing how to    generate the (dynamic) address of the object onto the address stack.     If we don't know how to describe it, return 0.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|loc_descriptor
parameter_list|(
name|rtx
name|rtl
parameter_list|)
block|{
name|dw_loc_descr_ref
name|loc_result
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
comment|/* The case of a subreg may arise when we have a local (register) 	 variable or a formal (register) parameter which doesn't quite fill 	 up an entire register.  For now, just assume that it is 	 legitimate to make the Dwarf info refer to the whole register which 	 contains the given subreg.  */
name|rtl
operator|=
name|SUBREG_REG
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|REG
case|:
name|loc_result
operator|=
name|reg_loc_descriptor
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|loc_result
operator|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONCAT
case|:
name|loc_result
operator|=
name|concat_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_LOCATION
case|:
comment|/* Single part.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|PARALLEL
condition|)
block|{
name|loc_result
operator|=
name|loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|PARALLEL
case|:
block|{
name|rtvec
name|par_elems
init|=
name|XVEC
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|num_elem
init|=
name|GET_NUM_ELEM
argument_list|(
name|par_elems
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create the first one, so we have something to add to.  */
name|loc_result
operator|=
name|loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|par_elems
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|par_elems
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr_op_piece
argument_list|(
operator|&
name|loc_result
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_elem
condition|;
name|i
operator|++
control|)
block|{
name|dw_loc_descr_ref
name|temp
decl_stmt|;
name|temp
operator|=
name|loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|par_elems
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_result
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|par_elems
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr_op_piece
argument_list|(
operator|&
name|loc_result
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|loc_result
return|;
block|}
end_function

begin_comment
comment|/* Similar, but generate the descriptor from trees instead of rtl.  This comes    up particularly with variable length arrays.  WANT_ADDRESS is 2 if this is    a top-level invocation of loc_descriptor_from_tree; is 1 if this is not a    top-level invocation, and we require the address of LOC; is 0 if we require    the value of LOC.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|loc_descriptor_from_tree_1
parameter_list|(
name|tree
name|loc
parameter_list|,
name|int
name|want_address
parameter_list|)
block|{
name|dw_loc_descr_ref
name|ret
decl_stmt|,
name|ret1
decl_stmt|;
name|int
name|have_address
init|=
literal|0
decl_stmt|;
name|enum
name|dwarf_location_atom
name|op
decl_stmt|;
comment|/* ??? Most of the time we do not take proper care for sign/zero      extending the values properly.  Hopefully this won't be a real      problem...  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|loc
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
literal|0
return|;
case|case
name|PLACEHOLDER_EXPR
case|:
comment|/* This case involves extracting fields from an object to determine the 	 position of other fields.  We don't try to encode this here.  The 	 only user of this is Ada, which encodes the needed information using 	 the names of types.  */
return|return
literal|0
return|;
case|case
name|CALL_EXPR
case|:
return|return
literal|0
return|;
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
comment|/* There are no opcodes for these operations.  */
return|return
literal|0
return|;
case|case
name|ADDR_EXPR
case|:
comment|/* If we already want an address, there's nothing we can do.  */
if|if
condition|(
name|want_address
condition|)
return|return
literal|0
return|;
comment|/* Otherwise, process the argument and look for the address.  */
return|return
name|loc_descriptor_from_tree_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_THREAD_LOCAL_P
argument_list|(
name|loc
argument_list|)
condition|)
block|{
name|rtx
name|rtl
decl_stmt|;
comment|/* If this is not defined, we have no way to emit the data.  */
if|if
condition|(
operator|!
name|targetm
operator|.
name|asm_out
operator|.
name|output_dwarf_dtprel
condition|)
return|return
literal|0
return|;
comment|/* The way DW_OP_GNU_push_tls_address is specified, we can only 	     look up addresses of objects in the current module.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|loc
argument_list|)
condition|)
return|return
literal|0
return|;
name|rtl
operator|=
name|rtl_for_decl_location
argument_list|(
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|rtl
argument_list|)
condition|)
return|return
literal|0
return|;
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|rtl
argument_list|)
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|new_loc_descr
argument_list|(
name|INTERNAL_DW_OP_tls_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_addr
expr_stmt|;
name|ret
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_addr
operator|=
name|rtl
expr_stmt|;
name|ret1
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_GNU_push_tls_address
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|ret1
argument_list|)
expr_stmt|;
name|have_address
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|loc
argument_list|)
condition|)
return|return
name|loc_descriptor_from_tree_1
argument_list|(
name|DECL_VALUE_EXPR
argument_list|(
name|loc
argument_list|)
argument_list|,
name|want_address
argument_list|)
return|;
comment|/* FALLTHRU */
case|case
name|RESULT_DECL
case|:
case|case
name|FUNCTION_DECL
case|:
block|{
name|rtx
name|rtl
init|=
name|rtl_for_decl_location
argument_list|(
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|loc
argument_list|)
argument_list|)
condition|)
name|val
operator|&=
name|GET_MODE_MASK
argument_list|(
name|DECL_MODE
argument_list|(
name|loc
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|int_loc_descriptor
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|CONST_STRING
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
name|ret
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_addr
expr_stmt|;
name|ret
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_addr
operator|=
name|rtl
expr_stmt|;
block|}
else|else
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
comment|/* Certain constructs can only be represented at top-level.  */
if|if
condition|(
name|want_address
operator|==
literal|2
condition|)
return|return
name|loc_descriptor
argument_list|(
name|rtl
argument_list|)
return|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|MEM_P
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|have_address
operator|=
literal|1
expr_stmt|;
block|}
name|ret
operator|=
name|mem_loc_descriptor
argument_list|(
name|rtl
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|INDIRECT_REF
case|:
name|ret
operator|=
name|loc_descriptor_from_tree_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|have_address
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|loc_descriptor_from_tree_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
name|want_address
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
case|case
name|MODIFY_EXPR
case|:
return|return
name|loc_descriptor_from_tree_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|want_address
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
block|{
name|tree
name|obj
decl_stmt|,
name|offset
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|,
name|bytepos
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|loc
argument_list|)
argument_list|)
decl_stmt|;
name|obj
operator|=
name|get_inner_reference
argument_list|(
name|loc
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|loc
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|loc_descriptor_from_tree_1
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
operator|||
name|bitsize
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|offset
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Variable offset.  */
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|loc_descriptor_from_tree_1
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bytepos
operator|=
name|bitpos
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|bytepos
operator|>
literal|0
condition|)
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus_uconst
argument_list|,
name|bytepos
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bytepos
operator|<
literal|0
condition|)
block|{
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|int_loc_descriptor
argument_list|(
name|bytepos
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|have_address
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|host_integerp
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
condition|)
name|ret
operator|=
name|int_loc_descriptor
argument_list|(
name|tree_low_cst
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|CONSTRUCTOR
case|:
block|{
comment|/* Get an RTL for this, if something has been emitted.  */
name|rtx
name|rtl
init|=
name|lookup_constant_def
argument_list|(
name|loc
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
operator|!
name|rtl
operator|||
operator|!
name|MEM_P
argument_list|(
name|rtl
argument_list|)
condition|)
return|return
literal|0
return|;
name|mode
operator|=
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mem_loc_descriptor
argument_list|(
name|rtl
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|have_address
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
name|op
operator|=
name|DW_OP_and
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
name|op
operator|=
name|DW_OP_xor
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
name|op
operator|=
name|DW_OP_or
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
name|op
operator|=
name|DW_OP_div
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|MINUS_EXPR
case|:
name|op
operator|=
name|DW_OP_minus
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|FLOOR_MOD_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
case|case
name|TRUNC_MOD_EXPR
case|:
name|op
operator|=
name|DW_OP_mod
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|MULT_EXPR
case|:
name|op
operator|=
name|DW_OP_mul
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|LSHIFT_EXPR
case|:
name|op
operator|=
name|DW_OP_shl
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|RSHIFT_EXPR
case|:
name|op
operator|=
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|loc
argument_list|)
argument_list|)
condition|?
name|DW_OP_shr
else|:
name|DW_OP_shra
operator|)
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ret
operator|=
name|loc_descriptor_from_tree_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus_uconst
argument_list|,
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|op
operator|=
name|DW_OP_plus
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|LE_EXPR
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|DW_OP_le
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|DW_OP_ge
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|DW_OP_lt
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|DW_OP_gt
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|EQ_EXPR
case|:
name|op
operator|=
name|DW_OP_eq
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|NE_EXPR
case|:
name|op
operator|=
name|DW_OP_ne
expr_stmt|;
goto|goto
name|do_binop
goto|;
name|do_binop
label|:
name|ret
operator|=
name|loc_descriptor_from_tree_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret1
operator|=
name|loc_descriptor_from_tree_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|ret1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|ret1
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
name|op
operator|=
name|DW_OP_not
expr_stmt|;
goto|goto
name|do_unop
goto|;
case|case
name|ABS_EXPR
case|:
name|op
operator|=
name|DW_OP_abs
expr_stmt|;
goto|goto
name|do_unop
goto|;
case|case
name|NEGATE_EXPR
case|:
name|op
operator|=
name|DW_OP_neg
expr_stmt|;
goto|goto
name|do_unop
goto|;
name|do_unop
label|:
name|ret
operator|=
name|loc_descriptor_from_tree_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
block|{
specifier|const
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MIN_EXPR
condition|?
name|GT_EXPR
else|:
name|LT_EXPR
decl_stmt|;
name|loc
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|build2
argument_list|(
name|code
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ... fall through ...  */
case|case
name|COND_EXPR
case|:
block|{
name|dw_loc_descr_ref
name|lhs
init|=
name|loc_descriptor_from_tree_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|dw_loc_descr_ref
name|rhs
init|=
name|loc_descriptor_from_tree_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|dw_loc_descr_ref
name|bra_node
decl_stmt|,
name|jump_node
decl_stmt|,
name|tmp
decl_stmt|;
name|ret
operator|=
name|loc_descriptor_from_tree_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|lhs
operator|==
literal|0
operator|||
name|rhs
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|bra_node
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_bra
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|bra_node
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|jump_node
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_skip
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|jump_node
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|bra_node
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_loc
expr_stmt|;
name|bra_node
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_loc
operator|=
name|lhs
expr_stmt|;
comment|/* ??? Need a node to point the skip at.  Use a nop.  */
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_nop
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|jump_node
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_loc
expr_stmt|;
name|jump_node
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_loc
operator|=
name|tmp
expr_stmt|;
block|}
break|break;
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
return|return
literal|0
return|;
default|default:
comment|/* Leave front-end specific codes as simply unknown.  This comes 	 up, for instance, with the C STMT_EXPR.  */
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
name|TREE_CODE
argument_list|(
name|loc
argument_list|)
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
comment|/* Otherwise this is a generic code; we should just lists all of 	 these explicitly.  We forgot one.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* In a release build, we want to degrade gracefully: better to 	 generate incomplete debugging information than to crash.  */
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
comment|/* Show if we can't fill the request for an address.  */
if|if
condition|(
name|want_address
operator|&&
operator|!
name|have_address
condition|)
return|return
literal|0
return|;
comment|/* If we've got an address and don't want one, dereference.  */
if|if
condition|(
operator|!
name|want_address
operator|&&
name|have_address
operator|&&
name|ret
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|loc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|DWARF2_ADDR_SIZE
operator|||
name|size
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|size
operator|==
name|DWARF2_ADDR_SIZE
condition|)
name|op
operator|=
name|DW_OP_deref
expr_stmt|;
else|else
name|op
operator|=
name|DW_OP_deref_size
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|op
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dw_loc_descr_ref
name|loc_descriptor_from_tree
parameter_list|(
name|tree
name|loc
parameter_list|)
block|{
return|return
name|loc_descriptor_from_tree_1
argument_list|(
name|loc
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a value, round it up to the lowest multiple of `boundary'    which is not less than the value itself.  */
end_comment

begin_function
specifier|static
specifier|inline
name|HOST_WIDE_INT
name|ceiling
parameter_list|(
name|HOST_WIDE_INT
name|value
parameter_list|,
name|unsigned
name|int
name|boundary
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|value
operator|+
name|boundary
operator|-
literal|1
operator|)
operator|/
name|boundary
operator|)
operator|*
name|boundary
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to what is assumed to be a FIELD_DECL node, return a    pointer to the declared type for the relevant field variable, or return    `integer_type_node' if the given node turns out to be an    ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|field_type
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|integer_type_node
return|;
name|type
operator|=
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node, return the alignment in bits for    it, or else return BITS_PER_WORD if the node actually turns out to    be an ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|simple_type_align_in_bits
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|?
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
else|:
name|BITS_PER_WORD
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|simple_decl_align_in_bits
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|?
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
else|:
name|BITS_PER_WORD
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a FIELD_DECL, compute and return the byte offset of the    lowest addressed byte of the "containing object" for the given FIELD_DECL,    or return 0 if we are unable to determine what that offset is, either    because the argument turns out to be a pointer to an ERROR_MARK node, or    because the offset is actually variable.  (We can't handle the latter case    just yet).  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|field_byte_offset
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|unsigned
name|int
name|type_align_in_bits
decl_stmt|;
name|unsigned
name|int
name|decl_align_in_bits
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|type_size_in_bits
decl_stmt|;
name|HOST_WIDE_INT
name|object_offset_in_bits
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|field_size_tree
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos_int
decl_stmt|;
name|HOST_WIDE_INT
name|deepest_bitpos
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|field_size_in_bits
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
argument_list|)
expr_stmt|;
name|type
operator|=
name|field_type
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|field_size_tree
operator|=
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The size could be unspecified if there was an error, or for      a flexible array member.  */
if|if
condition|(
operator|!
name|field_size_tree
condition|)
name|field_size_tree
operator|=
name|bitsize_zero_node
expr_stmt|;
comment|/* We cannot yet cope with fields whose positions are variable, so      for now, when we see such things, we simply return 0.  Someday, we may      be able to handle such cases, but it will be damn difficult.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|bitpos_int
operator|=
name|int_bit_position
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If we don't know the size of the field, pretend it's a full word.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|field_size_tree
argument_list|,
literal|1
argument_list|)
condition|)
name|field_size_in_bits
operator|=
name|tree_low_cst
argument_list|(
name|field_size_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|field_size_in_bits
operator|=
name|BITS_PER_WORD
expr_stmt|;
name|type_size_in_bits
operator|=
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_align_in_bits
operator|=
name|simple_type_align_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl_align_in_bits
operator|=
name|simple_decl_align_in_bits
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The GCC front-end doesn't make any attempt to keep track of the starting      bit offset (relative to the start of the containing structure type) of the      hypothetical "containing object" for a bit-field.  Thus, when computing      the byte offset value for the start of the "containing object" of a      bit-field, we must deduce this information on our own. This can be rather      tricky to do in some cases.  For example, handling the following structure      type definition when compiling for an i386/i486 target (which only aligns      long long's to 32-bit boundaries) can be very tricky:  	 struct S { int field1; long long field2:31; };       Fortunately, there is a simple rule-of-thumb which can be used in such      cases.  When compiling for an i386/i486, GCC will allocate 8 bytes for the      structure shown above.  It decides to do this based upon one simple rule      for bit-field allocation.  GCC allocates each "containing object" for each      bit-field at the first (i.e. lowest addressed) legitimate alignment      boundary (based upon the required minimum alignment for the declared type      of the field) which it can possibly use, subject to the condition that      there is still enough available space remaining in the containing object      (when allocated at the selected point) to fully accommodate all of the      bits of the bit-field itself.       This simple rule makes it obvious why GCC allocates 8 bytes for each      object of the structure type shown above.  When looking for a place to      allocate the "containing object" for `field2', the compiler simply tries      to allocate a 64-bit "containing object" at each successive 32-bit      boundary (starting at zero) until it finds a place to allocate that 64-      bit field such that at least 31 contiguous (and previously unallocated)      bits remain within that selected 64 bit field.  (As it turns out, for the      example above, the compiler finds it is OK to allocate the "containing      object" 64-bit field at bit-offset zero within the structure type.)       Here we attempt to work backwards from the limited set of facts we're      given, and we try to deduce from those facts, where GCC must have believed      that the containing object started (within the structure type). The value      we deduce is then used (by the callers of this routine) to generate      DW_AT_location and DW_AT_bit_offset attributes for fields (both bit-fields      and, in the case of DW_AT_location, regular fields as well).  */
comment|/* Figure out the bit-distance from the start of the structure to the      "deepest" bit of the bit-field.  */
name|deepest_bitpos
operator|=
name|bitpos_int
operator|+
name|field_size_in_bits
expr_stmt|;
comment|/* This is the tricky part.  Use some fancy footwork to deduce where the      lowest addressed bit of the containing object must be.  */
name|object_offset_in_bits
operator|=
name|deepest_bitpos
operator|-
name|type_size_in_bits
expr_stmt|;
comment|/* Round up to type_align by default.  This works best for bitfields.  */
name|object_offset_in_bits
operator|+=
name|type_align_in_bits
operator|-
literal|1
expr_stmt|;
name|object_offset_in_bits
operator|/=
name|type_align_in_bits
expr_stmt|;
name|object_offset_in_bits
operator|*=
name|type_align_in_bits
expr_stmt|;
if|if
condition|(
name|object_offset_in_bits
operator|>
name|bitpos_int
condition|)
block|{
comment|/* Sigh, the decl must be packed.  */
name|object_offset_in_bits
operator|=
name|deepest_bitpos
operator|-
name|type_size_in_bits
expr_stmt|;
comment|/* Round up to decl_align instead.  */
name|object_offset_in_bits
operator|+=
name|decl_align_in_bits
operator|-
literal|1
expr_stmt|;
name|object_offset_in_bits
operator|/=
name|decl_align_in_bits
expr_stmt|;
name|object_offset_in_bits
operator|*=
name|decl_align_in_bits
expr_stmt|;
block|}
return|return
name|object_offset_in_bits
operator|/
name|BITS_PER_UNIT
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following routines define various Dwarf attributes and any data    associated with them.  */
end_comment

begin_comment
comment|/* Add a location description attribute value to a DIE.     This emits location attributes suitable for whole variables and    whole parameters.  Note that the location attributes for struct fields are    generated by the routine `data_member_location_attribute' below.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_location_description
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|enum
name|dwarf_attribute
name|attr_kind
parameter_list|,
name|dw_loc_descr_ref
name|descr
parameter_list|)
block|{
if|if
condition|(
name|descr
operator|!=
literal|0
condition|)
name|add_AT_loc
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|,
name|descr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach the specialized form of location attribute used for data members of    struct and union types.  In the special case of a FIELD_DECL node which    represents a bit-field, the "offset" part of this special location    descriptor must indicate the distance in bytes from the lowest-addressed    byte of the containing struct or union type to the lowest-addressed byte of    the "containing object" for the bit-field.  (See the `field_byte_offset'    function above).     For any given bit-field, the "containing object" is a hypothetical object    (of some integral or enum type) within which the given bit-field lives.  The    type of this hypothetical "containing object" is always the same as the    declared type of the individual bit-field itself (for GCC anyway... the    DWARF spec doesn't actually mandate this).  Note that it is the size (in    bytes) of the hypothetical "containing object" which will be given in the    DW_AT_byte_size attribute for this bit-field.  (See the    `byte_size_attribute' function below.)  It is also used when calculating the    value of the DW_AT_bit_offset attribute.  (See the `bit_offset_attribute'    function below.)  */
end_comment

begin_function
specifier|static
name|void
name|add_data_member_location_attribute
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
name|dw_loc_descr_ref
name|loc_descr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_BINFO
condition|)
block|{
comment|/* We're working on the TAG_inheritance for a base class.  */
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|is_cxx
argument_list|()
condition|)
block|{
comment|/* For C++ virtual bases we can't just use BINFO_OFFSET, as they 	     aren't at a fixed offset from all (sub)objects of the same 	     type.  We need to extract the appropriate offset from our 	     vtable.  The following dwarf expression means  	       BaseAddr = ObAddr + *((*ObAddr) - Offset)  	     This is specific to the V3 ABI, of course.  */
name|dw_loc_descr_ref
name|tmp
decl_stmt|;
comment|/* Make a copy of the object address.  */
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_dup
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Extract the vtable address.  */
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_deref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Calculate the address of the offset.  */
name|offset
operator|=
name|tree_low_cst
argument_list|(
name|BINFO_VPTR_FIELD
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|offset
operator|<
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|int_loc_descriptor
argument_list|(
operator|-
name|offset
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_minus
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Extract the offset.  */
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_deref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Add it to the object address.  */
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_plus
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|field_byte_offset
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loc_descr
condition|)
block|{
name|enum
name|dwarf_location_atom
name|op
decl_stmt|;
comment|/* The DWARF2 standard says that we should assume that the structure 	 address is already on the stack, so we can specify a structure field 	 address by using DW_OP_plus_uconst.  */
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* ??? The SGI dwarf reader does not handle the DW_OP_plus_uconst 	 operator correctly.  It works only if we leave the offset on the 	 stack.  */
name|op
operator|=
name|DW_OP_constu
expr_stmt|;
else|#
directive|else
name|op
operator|=
name|DW_OP_plus_uconst
expr_stmt|;
endif|#
directive|endif
name|loc_descr
operator|=
name|new_loc_descr
argument_list|(
name|op
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|add_AT_loc
argument_list|(
name|die
argument_list|,
name|DW_AT_data_member_location
argument_list|,
name|loc_descr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Writes integer values to dw_vec_const array.  */
end_comment

begin_function
specifier|static
name|void
name|insert_int
parameter_list|(
name|HOST_WIDE_INT
name|val
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|,
name|unsigned
name|char
modifier|*
name|dest
parameter_list|)
block|{
while|while
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
operator|*
name|dest
operator|++
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
operator|--
name|size
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reads integers from dw_vec_const array.  Inverse of insert_int.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|extract_int
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|src
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|HOST_WIDE_INT
name|val
init|=
literal|0
decl_stmt|;
name|src
operator|+=
name|size
expr_stmt|;
while|while
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|val
operator|<<=
literal|8
expr_stmt|;
name|val
operator||=
operator|*
operator|--
name|src
operator|&
literal|0xff
expr_stmt|;
operator|--
name|size
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Writes floating point values to dw_vec_const array.  */
end_comment

begin_function
specifier|static
name|void
name|insert_float
parameter_list|(
name|rtx
name|rtl
parameter_list|,
name|unsigned
name|char
modifier|*
name|array
parameter_list|)
block|{
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|long
name|val
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
name|real_to_target
argument_list|(
name|val
argument_list|,
operator|&
name|rv
argument_list|,
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* real_to_target puts 32-bit pieces in each long.  Pack them.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|insert_int
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
literal|4
argument_list|,
name|array
argument_list|)
expr_stmt|;
name|array
operator|+=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Attach a DW_AT_const_value attribute for a variable or a parameter which    does not have a "location" either in memory or in a register.  These    things can arise in GNU C when a constant is passed as an actual parameter    to an inlined function.  They can also arise in C++ where declared    constants do not necessarily get memory "homes".  */
end_comment

begin_function
specifier|static
name|void
name|add_const_value_attribute
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|rtx
name|rtl
parameter_list|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|add_AT_int
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST_DOUBLE
case|:
comment|/* Note that a CONST_DOUBLE rtx could represent either an integer or a 	 floating-point constant.  A CONST_DOUBLE is used whenever the 	 constant requires more than one word in order to be adequately 	 represented.  We output CONST_DOUBLEs as blocks.  */
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|length
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|array
init|=
name|ggc_alloc
argument_list|(
name|length
argument_list|)
decl_stmt|;
name|insert_float
argument_list|(
name|rtl
argument_list|,
name|array
argument_list|)
expr_stmt|;
name|add_AT_vec
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|length
operator|/
literal|4
argument_list|,
literal|4
argument_list|,
name|array
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? We really should be using HOST_WIDE_INT throughout.  */
name|gcc_assert
argument_list|(
name|HOST_BITS_PER_LONG
operator|==
name|HOST_BITS_PER_WIDE_INT
argument_list|)
expr_stmt|;
name|add_AT_long_long
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|rtl
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONST_VECTOR
case|:
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|elt_size
init|=
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|length
init|=
name|CONST_VECTOR_NUNITS
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|array
init|=
name|ggc_alloc
argument_list|(
name|length
operator|*
name|elt_size
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_VECTOR_INT
case|:
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|array
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
name|elt_size
control|)
block|{
name|rtx
name|elt
init|=
name|CONST_VECTOR_ELT
argument_list|(
name|rtl
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|lo
decl_stmt|,
name|hi
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|elt
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|lo
operator|=
name|INTVAL
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|hi
operator|=
operator|-
operator|(
name|lo
operator|<
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
name|lo
operator|=
name|CONST_DOUBLE_LOW
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|hi
operator|=
name|CONST_DOUBLE_HIGH
argument_list|(
name|elt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|elt_size
operator|<=
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
condition|)
name|insert_int
argument_list|(
name|lo
argument_list|,
name|elt_size
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|char
modifier|*
name|p0
init|=
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p1
init|=
name|p
operator|+
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|elt_size
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|p0
operator|=
name|p1
expr_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
block|}
name|insert_int
argument_list|(
name|lo
argument_list|,
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|,
name|p0
argument_list|)
expr_stmt|;
name|insert_int
argument_list|(
name|hi
argument_list|,
sizeof|sizeof
argument_list|(
name|HOST_WIDE_INT
argument_list|)
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MODE_VECTOR_FLOAT
case|:
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|array
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
name|elt_size
control|)
block|{
name|rtx
name|elt
init|=
name|CONST_VECTOR_ELT
argument_list|(
name|rtl
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|insert_float
argument_list|(
name|elt
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|add_AT_vec
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|length
argument_list|,
name|elt_size
argument_list|,
name|array
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST_STRING
case|:
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|XSTR
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
name|add_AT_addr
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|rtx
argument_list|,
name|gc
argument_list|,
name|used_rtx_array
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* In cases where an inlined instance of an inline function is passed 	 the address of an `auto' variable (which is local to the caller) we 	 can get a situation where the DECL_RTL of the artificial local 	 variable (for the inlining) which acts as a stand-in for the 	 corresponding formal parameter (of the inline function) will look 	 like (plus:SI (reg:SI FRAME_PTR) (const_int ...)).  This is not 	 exactly a compile-time constant expression, but it isn't the address 	 of the (artificial) local variable either.  Rather, it represents the 	 *value* which the artificial local variable always has during its 	 lifetime.  We currently have no way to represent such quasi-constant 	 values in Dwarf, so for now we just punt and generate nothing.  */
break|break;
default|default:
comment|/* No other kinds of rtx should be possible here.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine whether the evaluation of EXPR references any variables    or functions which aren't otherwise used (and therefore may not be    output).  */
end_comment

begin_function
specifier|static
name|tree
name|reference_to_unused
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
operator|!
name|EXPR_P
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
operator|!
name|CONSTANT_CLASS_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
return|return
operator|*
name|tp
return|;
elseif|else
if|if
condition|(
operator|!
name|flag_unit_at_a_time
condition|)
return|return
name|NULL_TREE
return|;
elseif|else
if|if
condition|(
operator|!
name|cgraph_global_info_ready
operator|&&
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
return|return
operator|*
name|tp
return|;
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|struct
name|cgraph_varpool_node
modifier|*
name|node
init|=
name|cgraph_varpool_node
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|needed
condition|)
return|return
operator|*
name|tp
return|;
block|}
elseif|else
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
operator|!
name|DECL_EXTERNAL
argument_list|(
operator|*
name|tp
argument_list|)
operator|||
name|DECL_DECLARED_INLINE_P
argument_list|(
operator|*
name|tp
argument_list|)
operator|)
condition|)
block|{
name|struct
name|cgraph_node
modifier|*
name|node
init|=
name|cgraph_node
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|node
operator|->
name|output
condition|)
return|return
operator|*
name|tp
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Generate an RTL constant from a decl initializer INIT with decl type TYPE,    for use in a later add_const_value_attribute call.  */
end_comment

begin_function
specifier|static
name|rtx
name|rtl_for_decl_init
parameter_list|(
name|tree
name|init
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|rtx
name|rtl
init|=
name|NULL_RTX
decl_stmt|;
comment|/* If a variable is initialized with a string constant without embedded      zeros, build CONST_STRING.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init
argument_list|)
operator|==
name|STRING_CST
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|enttype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|enttype
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|==
literal|1
operator|&&
name|domain
operator|&&
name|integer_zerop
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|&&
name|compare_tree_int
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
argument_list|,
name|TREE_STRING_LENGTH
argument_list|(
name|init
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|size_t
operator|)
name|TREE_STRING_LENGTH
argument_list|(
name|init
argument_list|)
operator|==
name|strlen
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|init
argument_list|)
argument_list|)
operator|+
literal|1
operator|)
condition|)
name|rtl
operator|=
name|gen_rtx_CONST_STRING
argument_list|(
name|VOIDmode
argument_list|,
name|ggc_strdup
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|init
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Other aggregates, and complex values, could be represented using      CONCAT: FIXME!  */
elseif|else
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
empty_stmt|;
comment|/* Vectors only work if their mode is supported by the target.        FIXME: generic vectors ought to work too.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|BLKmode
condition|)
empty_stmt|;
comment|/* If the initializer is something that we know will expand into an      immediate RTL constant, expand it now.  We must be careful not to      reference variables which won't be output.  */
elseif|else
if|if
condition|(
name|initializer_constant_valid_p
argument_list|(
name|init
argument_list|,
name|type
argument_list|)
operator|&&
operator|!
name|walk_tree
argument_list|(
operator|&
name|init
argument_list|,
name|reference_to_unused
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|rtl
operator|=
name|expand_expr
argument_list|(
name|init
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
expr_stmt|;
comment|/* If expand_expr returns a MEM, it wasn't immediate.  */
name|gcc_assert
argument_list|(
operator|!
name|rtl
operator|||
operator|!
name|MEM_P
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rtl
return|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the variable DECL to represent its location.  */
end_comment

begin_function
specifier|static
name|rtx
name|rtl_for_decl_location
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|rtx
name|rtl
decl_stmt|;
comment|/* Here we have to decide where we are going to say the parameter "lives"      (as far as the debugger is concerned).  We only have a couple of      choices.  GCC provides us with DECL_RTL and with DECL_INCOMING_RTL.       DECL_RTL normally indicates where the parameter lives during most of the      activation of the function.  If optimization is enabled however, this      could be either NULL or else a pseudo-reg.  Both of those cases indicate      that the parameter doesn't really live anywhere (as far as the code      generation parts of GCC are concerned) during most of the function's      activation.  That will happen (for example) if the parameter is never      referenced within the function.       We could just generate a location descriptor here for all non-NULL      non-pseudo values of DECL_RTL and ignore all of the rest, but we can be      a little nicer than that if we also consider DECL_INCOMING_RTL in cases      where DECL_RTL is NULL or is a pseudo-reg.       Note however that we can only get away with using DECL_INCOMING_RTL as      a backup substitute for DECL_RTL in certain limited cases.  In cases      where DECL_ARG_TYPE (decl) indicates the same type as TREE_TYPE (decl),      we can be sure that the parameter was passed using the same type as it is      declared to have within the function, and that its DECL_INCOMING_RTL      points us to a place where a value of that type is passed.       In cases where DECL_ARG_TYPE (decl) and TREE_TYPE (decl) are different,      we cannot (in general) use DECL_INCOMING_RTL as a substitute for DECL_RTL      because in these cases DECL_INCOMING_RTL points us to a value of some      type which is *different* from the type of the parameter itself.  Thus,      if we tried to use DECL_INCOMING_RTL to generate a location attribute in      such cases, the debugger would end up (for example) trying to fetch a      `float' from a place which actually contains the first part of a      `double'.  That would lead to really incorrect and confusing      output at debug-time.       So, in general, we *do not* use DECL_INCOMING_RTL as a backup for DECL_RTL      in cases where DECL_ARG_TYPE (decl) != TREE_TYPE (decl).  There      are a couple of exceptions however.  On little-endian machines we can      get away with using DECL_INCOMING_RTL even when DECL_ARG_TYPE (decl) is      not the same as TREE_TYPE (decl), but only when DECL_ARG_TYPE (decl) is      an integral type that is smaller than TREE_TYPE (decl). These cases arise      when (on a little-endian machine) a non-prototyped function has a      parameter declared to be of type `short' or `char'.  In such cases,      TREE_TYPE (decl) will be `short' or `char', DECL_ARG_TYPE (decl) will      be `int', and DECL_INCOMING_RTL will point to the lowest-order byte of the      passed `int' value.  If the debugger then uses that address to fetch      a `short' or a `char' (on a little-endian machine) the result will be      the correct data, so we allow for such exceptional cases below.       Note that our goal here is to describe the place where the given formal      parameter lives during most of the function's activation (i.e. between the      end of the prologue and the start of the epilogue).  We'll do that as best      as we can. Note however that if the given formal parameter is modified      sometime during the execution of the function, then a stack backtrace (at      debug-time) will show the function as having been called with the *new*      value rather than the value which was originally passed in.  This happens      rarely enough that it is not a major problem, but it *is* a problem, and      I'd like to fix it.       A future version of dwarf2out.c may generate two additional attributes for      any given DW_TAG_formal_parameter DIE which will describe the "passed      type" and the "passed location" for the given formal parameter in addition      to the attributes we now generate to indicate the "declared type" and the      "active location" for each parameter.  This additional set of attributes      could be used by debuggers for stack backtraces. Separately, note that      sometimes DECL_RTL can be NULL and DECL_INCOMING_RTL can be NULL also.      This happens (for example) for inlined-instances of inline function formal      parameters which are never referenced.  This really shouldn't be      happening.  All PARM_DECL nodes should get valid non-NULL      DECL_INCOMING_RTL values.  FIXME.  */
comment|/* Use DECL_RTL as the "location" unless we find something better.  */
name|rtl
operator|=
name|DECL_RTL_IF_SET
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* When generating abstract instances, ignore everything except      constants, symbols living in memory, and symbols living in      fixed registers.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
block|{
if|if
condition|(
name|rtl
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|rtl
argument_list|)
operator|||
operator|(
name|MEM_P
argument_list|(
name|rtl
argument_list|)
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|REG_P
argument_list|(
name|rtl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtl
operator|=
name|targetm
operator|.
name|delegitimize_address
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
return|return
name|rtl
return|;
block|}
name|rtl
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
operator|||
name|is_pseudo_reg
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
name|tree
name|declared_type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|passed_type
init|=
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|dmode
init|=
name|TYPE_MODE
argument_list|(
name|declared_type
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|pmode
init|=
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
decl_stmt|;
comment|/* This decl represents a formal parameter which was optimized out. 	     Note that DECL_INCOMING_RTL may be NULL in here, but we handle 	     all cases where (rtl == NULL_RTX) just below.  */
if|if
condition|(
name|dmode
operator|==
name|pmode
condition|)
name|rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SCALAR_INT_MODE_P
argument_list|(
name|dmode
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|dmode
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|pmode
argument_list|)
operator|&&
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|rtx
name|inc
init|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|inc
argument_list|)
condition|)
name|rtl
operator|=
name|inc
expr_stmt|;
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|inc
argument_list|)
condition|)
block|{
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|rtl
operator|=
name|adjust_address_nv
argument_list|(
name|inc
argument_list|,
name|dmode
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|pmode
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|dmode
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rtl
operator|=
name|inc
expr_stmt|;
block|}
block|}
block|}
comment|/* If the parm was passed in registers, but lives on the stack, then 	 make a big endian correction if the mode of the type of the 	 parameter is not the same as the mode of the rtl.  */
comment|/* ??? This is the same series of checks that are made in dbxout.c before 	 we reach the big endian correction code there.  It isn't clear if all 	 of these checks are necessary here, but keeping them all is the safe 	 thing to do.  */
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|rtl
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
operator|!=
name|const0_rtx
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* Not passed in memory.  */
operator|&&
operator|!
name|MEM_P
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* Not passed by invisible reference.  */
operator|&&
operator|(
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|)
comment|/* Big endian correction check.  */
operator|&&
name|BYTES_BIG_ENDIAN
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|)
condition|)
block|{
name|int
name|offset
init|=
operator|(
name|UNITS_PER_WORD
operator|-
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|rtl
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|rtl
operator|&&
name|MEM_P
argument_list|(
name|rtl
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
operator|!=
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|int
name|rsize
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|dsize
init|=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If a variable is declared "register" yet is smaller than 	 a register, then if we store the variable to memory, it 	 looks like we're storing a register-sized value, when in 	 fact we are not.  We need to adjust the offset of the 	 storage location to reflect the actual value's bytes, 	 else gdb will not be able to display it.  */
if|if
condition|(
name|rsize
operator|>
name|dsize
condition|)
name|rtl
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|rsize
operator|-
name|dsize
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,      and will have been substituted directly into all expressions that use it.      C does not have such a concept, but C++ and other languages do.  */
if|if
condition|(
operator|!
name|rtl
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|rtl
operator|=
name|rtl_for_decl_init
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl
condition|)
name|rtl
operator|=
name|targetm
operator|.
name|delegitimize_address
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
comment|/* If we don't look past the constant pool, we risk emitting a      reference to a constant pool entry that isn't referenced from      code, and thus is not emitted.  */
if|if
condition|(
name|rtl
condition|)
name|rtl
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
return|return
name|rtl
return|;
block|}
end_function

begin_comment
comment|/* We need to figure out what section we should use as the base for the    address ranges where a given location is valid.    1. If this particular DECL has a section associated with it, use that.    2. If this function has a section associated with it, use that.    3. Otherwise, use the text section.    XXX: If you split a variable across multiple sections, we won't notice.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|secname_for_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
if|if
condition|(
name|VAR_OR_FUNCTION_DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|sectree
init|=
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|secname
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|sectree
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|tree
name|sectree
init|=
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|secname
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|sectree
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfun
operator|&&
name|in_cold_section_p
condition|)
name|secname
operator|=
name|cfun
operator|->
name|cold_section_label
expr_stmt|;
else|else
name|secname
operator|=
name|text_section_label
expr_stmt|;
return|return
name|secname
return|;
block|}
end_function

begin_comment
comment|/* Generate *either* a DW_AT_location attribute or else a DW_AT_const_value    data attribute for a variable or a parameter.  We generate the    DW_AT_const_value attribute only in those cases where the given variable    or parameter does not have a true "location" either in memory or in a    register.  This can happen (for example) when a constant is passed as an    actual argument in a call to an inline function.  (It's possible that    these things can crop up in other ways also.)  Note that one type of    constant value which can be passed into an inlined function is a constant    pointer.  This can happen for example if an actual argument in an inlined    function call evaluates to a compile-time constant address.  */
end_comment

begin_function
specifier|static
name|void
name|add_location_or_const_value_attribute
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|tree
name|decl
parameter_list|,
name|enum
name|dwarf_attribute
name|attr
parameter_list|)
block|{
name|rtx
name|rtl
decl_stmt|;
name|dw_loc_descr_ref
name|descr
decl_stmt|;
name|var_loc_list
modifier|*
name|loc_list
decl_stmt|;
name|struct
name|var_loc_node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|RESULT_DECL
argument_list|)
expr_stmt|;
comment|/* See if we possibly have multiple locations for this variable.  */
name|loc_list
operator|=
name|lookup_decl_loc
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If it truly has multiple locations, the first and last node will      differ.  */
if|if
condition|(
name|loc_list
operator|&&
name|loc_list
operator|->
name|first
operator|!=
name|loc_list
operator|->
name|last
condition|)
block|{
specifier|const
name|char
modifier|*
name|endname
decl_stmt|,
modifier|*
name|secname
decl_stmt|;
name|dw_loc_list_ref
name|list
decl_stmt|;
name|rtx
name|varloc
decl_stmt|;
comment|/* Now that we know what section we are using for a base,          actually construct the list of locations. 	 The first location information is what is passed to the 	 function that creates the location list, and the remaining 	 locations just get added on to that list. 	 Note that we only know the start address for a location 	 (IE location changes), so to build the range, we use 	 the range [current location start, next location start]. 	 This means we have to special case the last node, and generate 	 a range of [last location start, end of function label].  */
name|node
operator|=
name|loc_list
operator|->
name|first
expr_stmt|;
name|varloc
operator|=
name|NOTE_VAR_LOCATION
argument_list|(
name|node
operator|->
name|var_loc_note
argument_list|)
expr_stmt|;
name|secname
operator|=
name|secname_for_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|list
operator|=
name|new_loc_list
argument_list|(
name|loc_descriptor
argument_list|(
name|varloc
argument_list|)
argument_list|,
name|node
operator|->
name|label
argument_list|,
name|node
operator|->
name|next
operator|->
name|label
argument_list|,
name|secname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
for|for
control|(
init|;
name|node
operator|->
name|next
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
if|if
condition|(
name|NOTE_VAR_LOCATION_LOC
argument_list|(
name|node
operator|->
name|var_loc_note
argument_list|)
operator|!=
name|NULL_RTX
condition|)
block|{
comment|/* The variable has a location between NODE->LABEL and 	       NODE->NEXT->LABEL.  */
name|varloc
operator|=
name|NOTE_VAR_LOCATION
argument_list|(
name|node
operator|->
name|var_loc_note
argument_list|)
expr_stmt|;
name|add_loc_descr_to_loc_list
argument_list|(
operator|&
name|list
argument_list|,
name|loc_descriptor
argument_list|(
name|varloc
argument_list|)
argument_list|,
name|node
operator|->
name|label
argument_list|,
name|node
operator|->
name|next
operator|->
name|label
argument_list|,
name|secname
argument_list|)
expr_stmt|;
block|}
comment|/* If the variable has a location at the last label 	 it keeps its location until the end of function.  */
if|if
condition|(
name|NOTE_VAR_LOCATION_LOC
argument_list|(
name|node
operator|->
name|var_loc_note
argument_list|)
operator|!=
name|NULL_RTX
condition|)
block|{
name|char
name|label_id
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|varloc
operator|=
name|NOTE_VAR_LOCATION
argument_list|(
name|node
operator|->
name|var_loc_note
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_function_decl
condition|)
name|endname
operator|=
name|text_end_label
expr_stmt|;
else|else
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label_id
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|endname
operator|=
name|ggc_strdup
argument_list|(
name|label_id
argument_list|)
expr_stmt|;
block|}
name|add_loc_descr_to_loc_list
argument_list|(
operator|&
name|list
argument_list|,
name|loc_descriptor
argument_list|(
name|varloc
argument_list|)
argument_list|,
name|node
operator|->
name|label
argument_list|,
name|endname
argument_list|,
name|secname
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, add the location list to the DIE, and we are done.  */
name|add_AT_loc_list
argument_list|(
name|die
argument_list|,
name|attr
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try to get some constant RTL for this decl, and use that as the value of      the location.  */
name|rtl
operator|=
name|rtl_for_decl_location
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|rtl
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|CONST_STRING
operator|)
condition|)
block|{
name|add_const_value_attribute
argument_list|(
name|die
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have tried to generate the location otherwise, and it      didn't work out (we wouldn't be here if we did), and we have a one entry      location list, try generating a location from that.  */
if|if
condition|(
name|loc_list
operator|&&
name|loc_list
operator|->
name|first
condition|)
block|{
name|node
operator|=
name|loc_list
operator|->
name|first
expr_stmt|;
name|descr
operator|=
name|loc_descriptor
argument_list|(
name|NOTE_VAR_LOCATION
argument_list|(
name|node
operator|->
name|var_loc_note
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
condition|)
block|{
name|add_AT_location_description
argument_list|(
name|die
argument_list|,
name|attr
argument_list|,
name|descr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* We couldn't get any rtl, so try directly generating the location      description from the tree.  */
name|descr
operator|=
name|loc_descriptor_from_tree
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|descr
condition|)
block|{
name|add_AT_location_description
argument_list|(
name|die
argument_list|,
name|attr
argument_list|,
name|descr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* None of that worked, so it must not really have a location;      try adding a constant value attribute from the DECL_INITIAL.  */
name|tree_add_const_value_attribute
argument_list|(
name|die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If we don't have a copy of this variable in memory for some reason (such    as a C++ member constant that doesn't have an out-of-line definition),    we should tell the debugger about the constant value.  */
end_comment

begin_function
specifier|static
name|void
name|tree_add_const_value_attribute
parameter_list|(
name|dw_die_ref
name|var_die
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|rtx
name|rtl
decl_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|init
condition|)
comment|/* OK */
empty_stmt|;
else|else
return|return;
name|rtl
operator|=
name|rtl_for_decl_init
argument_list|(
name|init
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl
condition|)
name|add_const_value_attribute
argument_list|(
name|var_die
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the CFI instructions for the current function into a    location list.  This is used for DW_AT_frame_base when we targeting    a dwarf2 consumer that does not support the dwarf3    DW_OP_call_frame_cfa.  OFFSET is a constant to be added to all CFA    expressions.  */
end_comment

begin_function
specifier|static
name|dw_loc_list_ref
name|convert_cfa_to_fb_loc_list
parameter_list|(
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|dw_fde_ref
name|fde
decl_stmt|;
name|dw_loc_list_ref
name|list
decl_stmt|,
modifier|*
name|list_tail
decl_stmt|;
name|dw_cfi_ref
name|cfi
decl_stmt|;
name|dw_cfa_location
name|last_cfa
decl_stmt|,
name|next_cfa
decl_stmt|;
specifier|const
name|char
modifier|*
name|start_label
decl_stmt|,
modifier|*
name|last_label
decl_stmt|,
modifier|*
name|section
decl_stmt|;
name|fde
operator|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|-
literal|1
index|]
expr_stmt|;
name|section
operator|=
name|secname_for_decl
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|list_tail
operator|=
operator|&
name|list
expr_stmt|;
name|list
operator|=
name|NULL
expr_stmt|;
name|next_cfa
operator|.
name|reg
operator|=
name|INVALID_REGNUM
expr_stmt|;
name|next_cfa
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|next_cfa
operator|.
name|indirect
operator|=
literal|0
expr_stmt|;
name|next_cfa
operator|.
name|base_offset
operator|=
literal|0
expr_stmt|;
name|start_label
operator|=
name|fde
operator|->
name|dw_fde_begin
expr_stmt|;
comment|/* ??? Bald assumption that the CIE opcode list does not contain      advance opcodes.  */
for|for
control|(
name|cfi
operator|=
name|cie_cfi_head
init|;
name|cfi
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|lookup_cfa_1
argument_list|(
name|cfi
argument_list|,
operator|&
name|next_cfa
argument_list|)
expr_stmt|;
name|last_cfa
operator|=
name|next_cfa
expr_stmt|;
name|last_label
operator|=
name|start_label
expr_stmt|;
for|for
control|(
name|cfi
operator|=
name|fde
operator|->
name|dw_fde_cfi
init|;
name|cfi
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
switch|switch
condition|(
name|cfi
operator|->
name|dw_cfi_opc
condition|)
block|{
case|case
name|DW_CFA_set_loc
case|:
case|case
name|DW_CFA_advance_loc1
case|:
case|case
name|DW_CFA_advance_loc2
case|:
case|case
name|DW_CFA_advance_loc4
case|:
if|if
condition|(
operator|!
name|cfa_equal_p
argument_list|(
operator|&
name|last_cfa
argument_list|,
operator|&
name|next_cfa
argument_list|)
condition|)
block|{
operator|*
name|list_tail
operator|=
name|new_loc_list
argument_list|(
name|build_cfa_loc
argument_list|(
operator|&
name|last_cfa
argument_list|,
name|offset
argument_list|)
argument_list|,
name|start_label
argument_list|,
name|last_label
argument_list|,
name|section
argument_list|,
name|list
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|list_tail
operator|=
operator|&
operator|(
operator|*
name|list_tail
operator|)
operator|->
name|dw_loc_next
expr_stmt|;
name|last_cfa
operator|=
name|next_cfa
expr_stmt|;
name|start_label
operator|=
name|last_label
expr_stmt|;
block|}
name|last_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc
case|:
comment|/* The encoding is complex enough that we should never emit this.  */
case|case
name|DW_CFA_remember_state
case|:
case|case
name|DW_CFA_restore_state
case|:
comment|/* We don't handle these two in this function.  It would be possible 	   if it were to be required.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
default|default:
name|lookup_cfa_1
argument_list|(
name|cfi
argument_list|,
operator|&
name|next_cfa
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|cfa_equal_p
argument_list|(
operator|&
name|last_cfa
argument_list|,
operator|&
name|next_cfa
argument_list|)
condition|)
block|{
operator|*
name|list_tail
operator|=
name|new_loc_list
argument_list|(
name|build_cfa_loc
argument_list|(
operator|&
name|last_cfa
argument_list|,
name|offset
argument_list|)
argument_list|,
name|start_label
argument_list|,
name|last_label
argument_list|,
name|section
argument_list|,
name|list
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|list_tail
operator|=
operator|&
operator|(
operator|*
name|list_tail
operator|)
operator|->
name|dw_loc_next
expr_stmt|;
name|start_label
operator|=
name|last_label
expr_stmt|;
block|}
operator|*
name|list_tail
operator|=
name|new_loc_list
argument_list|(
name|build_cfa_loc
argument_list|(
operator|&
name|next_cfa
argument_list|,
name|offset
argument_list|)
argument_list|,
name|start_label
argument_list|,
name|fde
operator|->
name|dw_fde_end
argument_list|,
name|section
argument_list|,
name|list
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Compute a displacement from the "steady-state frame pointer" to the    frame base (often the same as the CFA), and store it in    frame_pointer_fb_offset.  OFFSET is added to the displacement    before the latter is negated.  */
end_comment

begin_function
specifier|static
name|void
name|compute_frame_pointer_to_fb_displacement
parameter_list|(
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|,
name|elim
decl_stmt|;
ifdef|#
directive|ifdef
name|FRAME_POINTER_CFA_OFFSET
name|reg
operator|=
name|frame_pointer_rtx
expr_stmt|;
name|offset
operator|+=
name|FRAME_POINTER_CFA_OFFSET
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|reg
operator|=
name|arg_pointer_rtx
expr_stmt|;
name|offset
operator|+=
name|ARG_POINTER_CFA_OFFSET
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|elim
operator|=
name|eliminate_regs
argument_list|(
name|reg
argument_list|,
name|VOIDmode
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|elim
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|offset
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|elim
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|elim
operator|=
name|XEXP
argument_list|(
name|elim
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|elim
operator|==
operator|(
name|frame_pointer_needed
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
operator|)
argument_list|)
expr_stmt|;
name|frame_pointer_fb_offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DW_AT_name attribute given some string value to be included as    the value of the attribute.  */
end_comment

begin_function
specifier|static
name|void
name|add_name_attribute
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
specifier|const
name|char
modifier|*
name|name_string
parameter_list|)
block|{
if|if
condition|(
name|name_string
operator|!=
name|NULL
operator|&&
operator|*
name|name_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|demangle_name_func
condition|)
name|name_string
operator|=
call|(
modifier|*
name|demangle_name_func
call|)
argument_list|(
name|name_string
argument_list|)
expr_stmt|;
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|name_string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DW_AT_comp_dir attribute for DIE.  */
end_comment

begin_function
specifier|static
name|void
name|add_comp_dir_attribute
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|wd
init|=
name|get_src_pwd
argument_list|()
decl_stmt|;
if|if
condition|(
name|wd
operator|!=
name|NULL
condition|)
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_comp_dir
argument_list|,
name|wd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a tree node describing an array bound (either lower or upper) output    a representation for that bound.  */
end_comment

begin_function
specifier|static
name|void
name|add_bound_info
parameter_list|(
name|dw_die_ref
name|subrange_die
parameter_list|,
name|enum
name|dwarf_attribute
name|bound_attr
parameter_list|,
name|tree
name|bound
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|bound
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return;
comment|/* All fixed-bounds are represented by INTEGER_CST nodes.  */
case|case
name|INTEGER_CST
case|:
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|bound_attr
operator|==
name|DW_AT_lower_bound
operator|&&
operator|(
operator|(
operator|(
name|is_c_family
argument_list|()
operator|||
name|is_java
argument_list|()
operator|)
operator|&&
name|integer_zerop
argument_list|(
name|bound
argument_list|)
operator|)
operator|||
operator|(
name|is_fortran
argument_list|()
operator|&&
name|integer_onep
argument_list|(
name|bound
argument_list|)
operator|)
operator|)
operator|)
condition|)
comment|/* Use the default.  */
empty_stmt|;
else|else
name|add_AT_unsigned
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|tree_low_cst
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
name|add_bound_info
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|TREE_OPERAND
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVE_EXPR
case|:
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
case|case
name|RESULT_DECL
case|:
block|{
name|dw_die_ref
name|decl_die
init|=
name|lookup_decl_die
argument_list|(
name|bound
argument_list|)
decl_stmt|;
comment|/* ??? Can this happen, or should the variable have been bound 	   first?  Probably it can, since I imagine that we try to create 	   the types of parameters in the order in which they exist in 	   the list, and won't have created a forward reference to a 	   later parameter.  */
if|if
condition|(
name|decl_die
operator|!=
name|NULL
condition|)
name|add_AT_die_ref
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|decl_die
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
comment|/* Otherwise try to create a stack operation procedure to 	   evaluate the value of the array bound.  */
name|dw_die_ref
name|ctx
decl_stmt|,
name|decl_die
decl_stmt|;
name|dw_loc_descr_ref
name|loc
decl_stmt|;
name|loc
operator|=
name|loc_descriptor_from_tree
argument_list|(
name|bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
name|ctx
operator|=
name|comp_unit_die
expr_stmt|;
else|else
name|ctx
operator|=
name|lookup_decl_die
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|decl_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_variable
argument_list|,
name|ctx
argument_list|,
name|bound
argument_list|)
expr_stmt|;
name|add_AT_flag
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|decl_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|bound
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|add_AT_loc
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_location
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|decl_die
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Note that the block of subscript information for an array type also    includes information about the element type of type given array type.  */
end_comment

begin_function
specifier|static
name|void
name|add_subscript_info
parameter_list|(
name|dw_die_ref
name|type_die
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
name|unsigned
name|dimension_number
decl_stmt|;
endif|#
directive|endif
name|tree
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|dw_die_ref
name|subrange_die
decl_stmt|;
comment|/* The GNU compilers represent multidimensional array types as sequences of      one dimensional array types whose element types are themselves array      types.  Here we squish that down, so that each multidimensional array      type gets only one array_type DIE in the Dwarf debugging info. The draft      Dwarf specification say that we are allowed to do this kind of      compression in C (because there is no difference between an array or      arrays and a multidimensional array in C) but for other source languages      (e.g. Ada) we probably shouldn't do this.  */
comment|/* ??? The SGI dwarf reader fails for multidimensional arrays with a      const enum type.  E.g. const enum machine_mode insn_operand_mode[2][10].      We work around this by disabling this feature.  See also      gen_array_type_die.  */
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
for|for
control|(
name|dimension_number
operator|=
literal|0
init|;
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|,
name|dimension_number
operator|++
control|)
endif|#
directive|endif
block|{
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Arrays come in three flavors: Unspecified bounds, fixed bounds, 	 and (in GNU C only) variable bounds.  Handle all three forms 	 here.  */
name|subrange_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subrange_type
argument_list|,
name|type_die
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
condition|)
block|{
comment|/* We have an array type with specified bounds.  */
name|lower
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|upper
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
expr_stmt|;
comment|/* Define the index type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
condition|)
block|{
comment|/* ??? This is probably an Ada unnamed subrange type.  Ignore the 		 TREE_TYPE field.  We can't emit debug info for this 		 because it is an unnamed integral type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|domain
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|domain
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
empty_stmt|;
else|else
name|add_type_attribute
argument_list|(
name|subrange_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
comment|/* ??? If upper is NULL, the array has unspecified length, 	     but it does have a lower bound.  This happens with Fortran 	       dimension arr(N:*) 	     Since the debugger is definitely going to need to know N 	     to produce useful results, go ahead and output the lower 	     bound solo, and hope the debugger can cope.  */
name|add_bound_info
argument_list|(
name|subrange_die
argument_list|,
name|DW_AT_lower_bound
argument_list|,
name|lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper
condition|)
name|add_bound_info
argument_list|(
name|subrange_die
argument_list|,
name|DW_AT_upper_bound
argument_list|,
name|upper
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise we have an array type with an unspecified length.  The 	 DWARF-2 spec does not say how to handle this; let's just leave out the 	 bounds.  */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_byte_size_attribute
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|tree
name|tree_node
parameter_list|)
block|{
name|unsigned
name|size
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|tree_node
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|tree_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD_DECL
case|:
comment|/* For a data member of a struct or union, the DW_AT_byte_size is 	 generally given as the number of bytes normally allocated for an 	 object of the *declared* type of the member itself.  This is true 	 even for bit-fields.  */
name|size
operator|=
name|simple_type_size_in_bits
argument_list|(
name|field_type
argument_list|(
name|tree_node
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* Note that `size' might be -1 when we get to this point.  If it is, that      indicates that the byte size of the entity in question is variable.  We      have no good way of expressing this fact in Dwarf at the present time,      so just let the -1 pass on through.  */
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a FIELD_DECL node which represents a bit-field, output an attribute    which specifies the distance in bits from the highest order bit of the    "containing object" for the bit-field to the highest order bit of the    bit-field itself.     For any given bit-field, the "containing object" is a hypothetical object    (of some integral or enum type) within which the given bit-field lives.  The    type of this hypothetical "containing object" is always the same as the    declared type of the individual bit-field itself.  The determination of the    exact location of the "containing object" for a bit-field is rather    complicated.  It's handled by the `field_byte_offset' function (above).     Note that it is the size (in bytes) of the hypothetical "containing object"    which will be given in the DW_AT_byte_size attribute for this bit-field.    (See `byte_size_attribute' above).  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_bit_offset_attribute
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|HOST_WIDE_INT
name|object_offset_in_bytes
init|=
name|field_byte_offset
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos_int
decl_stmt|;
name|HOST_WIDE_INT
name|highest_order_object_bit_offset
decl_stmt|;
name|HOST_WIDE_INT
name|highest_order_field_bit_offset
decl_stmt|;
name|HOST_WIDE_INT
name|unsigned
name|bit_offset
decl_stmt|;
comment|/* Must be a field and a bit field.  */
name|gcc_assert
argument_list|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
argument_list|)
expr_stmt|;
comment|/* We can't yet handle bit-fields whose offsets are variable, so if we      encounter such things, just return without generating any attribute      whatsoever.  Likewise for variable or too large size.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|bitpos_int
operator|=
name|int_bit_position
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Note that the bit offset is always the distance (in bits) from the      highest-order bit of the "containing object" to the highest-order bit of      the bit-field itself.  Since the "high-order end" of any object or field      is different on big-endian and little-endian machines, the computation      below must take account of these differences.  */
name|highest_order_object_bit_offset
operator|=
name|object_offset_in_bytes
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|highest_order_field_bit_offset
operator|=
name|bitpos_int
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|highest_order_field_bit_offset
operator|+=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|highest_order_object_bit_offset
operator|+=
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|bit_offset
operator|=
operator|(
operator|!
name|BYTES_BIG_ENDIAN
condition|?
name|highest_order_object_bit_offset
operator|-
name|highest_order_field_bit_offset
else|:
name|highest_order_field_bit_offset
operator|-
name|highest_order_object_bit_offset
operator|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_bit_offset
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a FIELD_DECL node which represents a bit field, output an attribute    which specifies the length in bits of the given field.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_bit_size_attribute
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
comment|/* Must be a field and a bit field.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_bit_size
argument_list|,
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the compiled language is ANSI C, then add a 'prototyped'    attribute, if arg types are given for the parameters of a function.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_prototyped_attribute
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|tree
name|func_type
parameter_list|)
block|{
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
operator|==
name|DW_LANG_C89
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|func_type
argument_list|)
operator|!=
name|NULL
condition|)
name|add_AT_flag
argument_list|(
name|die
argument_list|,
name|DW_AT_prototyped
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an 'abstract_origin' attribute below a given DIE.  The DIE is found    by looking in either the type declaration or object declaration    equate table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_abstract_origin_attribute
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|tree
name|origin
parameter_list|)
block|{
name|dw_die_ref
name|origin_die
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
comment|/* We may have gotten separated from the block for the inlined 	 function, if we're in an exception handler or some such; make 	 sure that the abstract function has been written out.  	 Doing this for nested functions is wrong, however; functions are 	 distinct units, and our context might not even be inline.  */
name|tree
name|fn
init|=
name|origin
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fn
operator|=
name|decl_function_context
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
name|dwarf2out_abstract_function
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_P
argument_list|(
name|origin
argument_list|)
condition|)
name|origin_die
operator|=
name|lookup_decl_die
argument_list|(
name|origin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|origin
argument_list|)
condition|)
name|origin_die
operator|=
name|lookup_type_die
argument_list|(
name|origin
argument_list|)
expr_stmt|;
comment|/* XXX: Functions that are never lowered don't always have correct block      trees (in the case of java, they simply have no block tree, in some other      languages).  For these functions, there is nothing we can really do to      output correct debug info for inlined functions in all cases.  Rather      than die, we'll just produce deficient debug info now, in that we will      have variables without a proper abstract origin.  In the future, when all      functions are lowered, we should re-add a gcc_assert (origin_die)      here.  */
if|if
condition|(
name|origin_die
condition|)
name|add_AT_die_ref
argument_list|(
name|die
argument_list|,
name|DW_AT_abstract_origin
argument_list|,
name|origin_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We do not currently support the pure_virtual attribute.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_pure_or_virtual_attribute
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|tree
name|func_decl
parameter_list|)
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|func_decl
argument_list|)
condition|)
block|{
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_virtuality
argument_list|,
name|DW_VIRTUALITY_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|DECL_VINDEX
argument_list|(
name|func_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|add_AT_loc
argument_list|(
name|die
argument_list|,
name|DW_AT_vtable_elem_location
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_constu
argument_list|,
name|tree_low_cst
argument_list|(
name|DECL_VINDEX
argument_list|(
name|func_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* GNU extension: Record what type this method came from originally.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
name|add_AT_die_ref
argument_list|(
name|die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|lookup_type_die
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|func_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add source coordinate attributes for the given decl.  */
end_comment

begin_function
specifier|static
name|void
name|add_src_coords_attributes
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|expanded_location
name|s
init|=
name|expand_location
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|add_AT_file
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_file
argument_list|,
name|lookup_filename
argument_list|(
name|s
operator|.
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_line
argument_list|,
name|s
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a DW_AT_name attribute and source coordinate attribute for the    given decl, but only if it actually has a name.  */
end_comment

begin_function
specifier|static
name|void
name|add_name_and_src_coords_attributes
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|decl_name
decl_stmt|;
name|decl_name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_name
operator|!=
name|NULL
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|decl_name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|add_name_attribute
argument_list|(
name|die
argument_list|,
name|dwarf2_name
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|add_src_coords_attributes
argument_list|(
name|die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_MIPS_linkage_name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VMS_DEBUGGING_INFO
comment|/* Get the function's name, as described by its RTL.  This may be different      from the DECL_NAME name used in the source file.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|add_AT_addr
argument_list|(
name|die
argument_list|,
name|DW_AT_VMS_rtnbeg_pd_address
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|used_rtx_array
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Push a new declaration scope.  */
end_comment

begin_function
specifier|static
name|void
name|push_decl_scope
parameter_list|(
name|tree
name|scope
parameter_list|)
block|{
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|decl_scope_table
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a declaration scope.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pop_decl_scope
parameter_list|(
name|void
parameter_list|)
block|{
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|decl_scope_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the DIE for the scope that immediately contains this type.    Non-named types get global scope.  Named types nested in other    types get their containing scope if it's open, or global scope    otherwise.  All other types (i.e. function-local named types) get    the current active scope.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|scope_die_for
parameter_list|(
name|tree
name|t
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|scope_die
init|=
name|NULL
decl_stmt|;
name|tree
name|containing_scope
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Non-types always go in the current scope.  */
name|gcc_assert
argument_list|(
name|TYPE_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|containing_scope
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Use the containing namespace if it was passed in (for a declaration).  */
if|if
condition|(
name|containing_scope
operator|&&
name|TREE_CODE
argument_list|(
name|containing_scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
block|{
if|if
condition|(
name|context_die
operator|==
name|lookup_decl_die
argument_list|(
name|containing_scope
argument_list|)
condition|)
comment|/* OK */
empty_stmt|;
else|else
name|containing_scope
operator|=
name|NULL_TREE
expr_stmt|;
block|}
comment|/* Ignore function type "scopes" from the C frontend.  They mean that      a tagged type is local to a parmlist of a function declarator, but      that isn't useful to DWARF.  */
if|if
condition|(
name|containing_scope
operator|&&
name|TREE_CODE
argument_list|(
name|containing_scope
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|containing_scope
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|containing_scope
operator|==
name|NULL_TREE
condition|)
name|scope_die
operator|=
name|comp_unit_die
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|containing_scope
argument_list|)
condition|)
block|{
comment|/* For types, we can just look up the appropriate DIE.  But 	 first we check to see if we're in the middle of emitting it 	 so we know where the new DIE should go.  */
for|for
control|(
name|i
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|decl_scope_table
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|decl_scope_table
argument_list|,
name|i
argument_list|)
operator|==
name|containing_scope
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|gcc_assert
argument_list|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
operator|||
name|TREE_ASM_WRITTEN
argument_list|(
name|containing_scope
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If none of the current dies are suitable, we get file scope.  */
name|scope_die
operator|=
name|comp_unit_die
expr_stmt|;
block|}
else|else
name|scope_die
operator|=
name|lookup_type_die
argument_list|(
name|containing_scope
argument_list|)
expr_stmt|;
block|}
else|else
name|scope_die
operator|=
name|context_die
expr_stmt|;
return|return
name|scope_die
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if CONTEXT_DIE is internal to a function.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|local_scope_p
parameter_list|(
name|dw_die_ref
name|context_die
parameter_list|)
block|{
for|for
control|(
init|;
name|context_die
condition|;
name|context_die
operator|=
name|context_die
operator|->
name|die_parent
control|)
if|if
condition|(
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_inlined_subroutine
operator|||
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_subprogram
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if CONTEXT_DIE is a class or namespace, for deciding    whether or not to treat a DIE in this context as a declaration.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|class_or_namespace_scope_p
parameter_list|(
name|dw_die_ref
name|context_die
parameter_list|)
block|{
return|return
operator|(
name|context_die
operator|&&
operator|(
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_structure_type
operator|||
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_union_type
operator|||
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_namespace
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Many forms of DIEs require a "type description" attribute.  This    routine locates the proper "type descriptor" die for the type given    by 'type', and adds a DW_AT_type attribute below the given die.  */
end_comment

begin_function
specifier|static
name|void
name|add_type_attribute
parameter_list|(
name|dw_die_ref
name|object_die
parameter_list|,
name|tree
name|type
parameter_list|,
name|int
name|decl_const
parameter_list|,
name|int
name|decl_volatile
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|dw_die_ref
name|type_die
init|=
name|NULL
decl_stmt|;
comment|/* ??? If this type is an unnamed subrange type of an integral or      floating-point type, use the inner type.  This is because we have no      support for unnamed types in base_type_die.  This can happen if this is      an Ada subrange type.  Correct solution is emit a subrange type die.  */
if|if
condition|(
operator|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|,
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
comment|/* Handle a special case.  For functions whose return type is void, we 	 generate *no* type attribute.  (Note that no object may have type 	 `void', so this only applies to function return types).  */
operator|||
name|code
operator|==
name|VOID_TYPE
condition|)
return|return;
name|type_die
operator|=
name|modified_type_die
argument_list|(
name|type
argument_list|,
name|decl_const
operator|||
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|decl_volatile
operator|||
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_die
operator|!=
name|NULL
condition|)
name|add_AT_die_ref
argument_list|(
name|object_die
argument_list|,
name|DW_AT_type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an object die, add the calling convention attribute for the    function call type.  */
end_comment

begin_function
specifier|static
name|void
name|add_calling_convention_attribute
parameter_list|(
name|dw_die_ref
name|subr_die
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|enum
name|dwarf_calling_convention
name|value
init|=
name|DW_CC_normal
decl_stmt|;
name|value
operator|=
name|targetm
operator|.
name|dwarf_calling_convention
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Only add the attribute if the backend requests it, and      is not DW_CC_normal.  */
if|if
condition|(
name|value
operator|&&
operator|(
name|value
operator|!=
name|DW_CC_normal
operator|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_calling_convention
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a tree pointer to a struct, class, union, or enum type node, return    a pointer to the (string) tag name for the given type, or zero if the type    was declared without a tag.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|type_tag
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|t
init|=
literal|0
decl_stmt|;
comment|/* Find the IDENTIFIER_NODE for the type name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The g++ front end makes the TYPE_NAME of *each* tagged type point to 	 a TYPE_DECL node, regardless of whether or not a `typedef' was 	 involved.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now get the name as a string, or invent one.  */
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|==
literal|0
operator|||
operator|*
name|name
operator|==
literal|'\0'
operator|)
condition|?
literal|0
else|:
name|name
return|;
block|}
end_function

begin_comment
comment|/* Return the type associated with a data member, make a special check    for bit field types.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|member_declared_type
parameter_list|(
name|tree
name|member
parameter_list|)
block|{
return|return
operator|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|member
argument_list|)
condition|?
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|member
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the decl's label, as described by its RTL. This may be different    from the DECL_NAME name used in the source file.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char * decl_start_label (tree decl) {   rtx x;   const char *fnname;    x = DECL_RTL (decl);   gcc_assert (MEM_P (x));    x = XEXP (x, 0);   gcc_assert (GET_CODE (x) == SYMBOL_REF);    fnname = XSTR (x, 0);   return fnname; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* These routines generate the internal representation of the DIE's for    the compilation unit.  Debugging information is collected by walking    the declaration trees passed in from dwarf2out_decl().  */
end_comment

begin_function
specifier|static
name|void
name|gen_array_type_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|scope_die
init|=
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
decl_stmt|;
name|dw_die_ref
name|array_die
decl_stmt|;
name|tree
name|element_type
decl_stmt|;
comment|/* ??? The SGI dwarf reader fails for array of array of enum types unless      the inner array type comes before the outer array type.  Thus we must      call gen_type_die before we call new_die.  See below also.  */
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|array_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_array_type
argument_list|,
name|scope_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|add_name_attribute
argument_list|(
name|array_die
argument_list|,
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|array_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
comment|/* The frontend feeds us a representation for the vector as a struct 	 containing an array.  Pull out the array type.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_flag
argument_list|(
name|array_die
argument_list|,
name|DW_AT_GNU_vector
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* We default the array ordering.  SDB will probably do      the right things even if DW_AT_ordering is not present.  It's not even      an issue until we start to get into multidimensional arrays anyway.  If      SDB is ever caught doing the Wrong Thing for multi-dimensional arrays,      then we'll have to put the DW_AT_ordering attribute back in.  (But if      and when we find out that we need to put these in, we will only do so      for multidimensional arrays.  */
block|add_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_row_major);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* The SGI compilers handle arrays of unknown bound by setting      AT_declaration and not emitting any subrange DIEs.  */
if|if
condition|(
operator|!
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|array_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|add_subscript_info
argument_list|(
name|array_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Add representation of the type of the elements of this array type.  */
name|element_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* ??? The SGI dwarf reader fails for multidimensional arrays with a      const enum type.  E.g. const enum machine_mode insn_operand_mode[2][10].      We work around this by disabling this feature.  See also      add_subscript_info.  */
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
while|while
condition|(
name|TREE_CODE
argument_list|(
name|element_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|element_type
operator|=
name|TREE_TYPE
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|gen_type_die
argument_list|(
name|element_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_type_attribute
argument_list|(
name|array_die
argument_list|,
name|element_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void gen_entry_point_die (tree decl, dw_die_ref context_die) {   tree origin = decl_ultimate_origin (decl);   dw_die_ref decl_die = new_die (DW_TAG_entry_point, context_die, decl);    if (origin != NULL)     add_abstract_origin_attribute (decl_die, origin);   else     {       add_name_and_src_coords_attributes (decl_die, decl);       add_type_attribute (decl_die, TREE_TYPE (TREE_TYPE (decl)), 			  0, 0, context_die);     }    if (DECL_ABSTRACT (decl))     equate_decl_number_to_die (decl, decl_die);   else     add_AT_lbl_id (decl_die, DW_AT_low_pc, decl_start_label (decl)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Walk through the list of incomplete types again, trying once more to    emit full debugging info for them.  */
end_comment

begin_function
specifier|static
name|void
name|retry_incomplete_types
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|incomplete_types
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|gen_type_die
argument_list|(
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|incomplete_types
argument_list|,
name|i
argument_list|)
argument_list|,
name|comp_unit_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an inlined instance of an enumeration type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_enumeration_type_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_enumeration_type
argument_list|,
name|context_die
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may      be incomplete and such types are not marked.  */
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an inlined instance of a structure type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_structure_type_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_structure_type
argument_list|,
name|context_die
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may      be incomplete and such types are not marked.  */
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an inlined instance of a union type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_union_type_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_union_type
argument_list|,
name|context_die
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may      be incomplete and such types are not marked.  */
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an enumeration type.  Note that these DIEs    include all of the information about the enumeration values also. Each    enumerated type name/value is listed as a child of the enumerated type    DIE.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|gen_enumeration_type_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|type_die
init|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type_die
operator|==
name|NULL
condition|)
block|{
name|type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_enumeration_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|add_name_attribute
argument_list|(
name|type_die
argument_list|,
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|type_die
return|;
else|else
name|remove_AT
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|)
expr_stmt|;
comment|/* Handle a GNU C/C++ extension, i.e. incomplete enum types.  If the      given enum type is incomplete, do not generate the DW_AT_byte_size      attribute or the DW_AT_element_list attribute.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|link
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_byte_size_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|add_src_coords_attributes
argument_list|(
name|type_die
argument_list|,
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the first reference to this type was as the return type of an 	 inline function, then it may not have a parent.  Fix this now.  */
if|if
condition|(
name|type_die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
name|add_child_die
argument_list|(
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|link
operator|!=
name|NULL
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|dw_die_ref
name|enum_die
init|=
name|new_die
argument_list|(
name|DW_TAG_enumerator
argument_list|,
name|type_die
argument_list|,
name|link
argument_list|)
decl_stmt|;
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|add_name_attribute
argument_list|(
name|enum_die
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|value
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* DWARF2 does not provide a way of indicating whether or 	       not enumeration constants are signed or unsigned.  GDB 	       always assumes the values are signed, so we output all 	       values as if they were signed.  That means that 	       enumeration constants with very large unsigned values 	       will appear to have negative values in the debugger.  */
name|add_AT_int
argument_list|(
name|enum_die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|tree_low_cst
argument_list|(
name|value
argument_list|,
name|tree_int_cst_sgn
argument_list|(
name|value
argument_list|)
operator|>
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|add_AT_flag
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|type_die
return|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent either a real live formal parameter decl or to    represent just the type of some formal parameter position in some function    type.     Note that this routine is a bit unusual because its argument may be a    ..._DECL node (i.e. either a PARM_DECL or perhaps a VAR_DECL which    represents an inlining of some PARM_DECL) or else some sort of a ..._TYPE    node.  If it's the former then this function is being called to output a    DIE to represent a formal parameter object (or some inlining thereof).  If    it's the latter, then this function is only being called to output a    DW_TAG_formal_parameter DIE to stand as a placeholder for some formal    argument type of some subprogram type.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|gen_formal_parameter_die
parameter_list|(
name|tree
name|node
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|parm_die
init|=
name|new_die
argument_list|(
name|DW_TAG_formal_parameter
argument_list|,
name|context_die
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|tree
name|origin
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_declaration
case|:
name|origin
operator|=
name|decl_ultimate_origin
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|parm_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|add_name_and_src_coords_attributes
argument_list|(
name|parm_die
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|parm_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|node
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|node
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|parm_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|equate_decl_number_to_die
argument_list|(
name|node
argument_list|,
name|parm_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_ABSTRACT
argument_list|(
name|node
argument_list|)
condition|)
name|add_location_or_const_value_attribute
argument_list|(
name|parm_die
argument_list|,
name|node
argument_list|,
name|DW_AT_location
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_type
case|:
comment|/* We were called with some kind of a ..._TYPE node.  */
name|add_type_attribute
argument_list|(
name|parm_die
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|parm_die
return|;
block|}
end_function

begin_comment
comment|/* Generate a special type of DIE used as a stand-in for a trailing ellipsis    at the end of an (ANSI prototyped) formal parameters list.  */
end_comment

begin_function
specifier|static
name|void
name|gen_unspecified_parameters_die
parameter_list|(
name|tree
name|decl_or_type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|new_die
argument_list|(
name|DW_TAG_unspecified_parameters
argument_list|,
name|context_die
argument_list|,
name|decl_or_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a list of nameless DW_TAG_formal_parameter DIEs (and perhaps a    DW_TAG_unspecified_parameters DIE) to represent the types of the formal    parameters as specified in some function type specification (except for    those which appear as part of a function *definition*).  */
end_comment

begin_function
specifier|static
name|void
name|gen_formal_types_die
parameter_list|(
name|tree
name|function_or_method_type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|tree
name|link
decl_stmt|;
name|tree
name|formal_type
init|=
name|NULL
decl_stmt|;
name|tree
name|first_parm_type
decl_stmt|;
name|tree
name|arg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function_or_method_type
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|function_or_method_type
argument_list|)
expr_stmt|;
name|function_or_method_type
operator|=
name|TREE_TYPE
argument_list|(
name|function_or_method_type
argument_list|)
expr_stmt|;
block|}
else|else
name|arg
operator|=
name|NULL_TREE
expr_stmt|;
name|first_parm_type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|function_or_method_type
argument_list|)
expr_stmt|;
comment|/* Make our first pass over the list of formal parameter types and output a      DW_TAG_formal_parameter DIE for each one.  */
for|for
control|(
name|link
operator|=
name|first_parm_type
init|;
name|link
condition|;
control|)
block|{
name|dw_die_ref
name|parm_die
decl_stmt|;
name|formal_type
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|==
name|void_type_node
condition|)
break|break;
comment|/* Output a (nameless) DIE to represent the formal parameter itself.  */
name|parm_die
operator|=
name|gen_formal_parameter_die
argument_list|(
name|formal_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|function_or_method_type
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|link
operator|==
name|first_parm_type
operator|)
operator|||
operator|(
name|arg
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
name|add_AT_flag
argument_list|(
name|parm_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* If this function type has an ellipsis, add a      DW_TAG_unspecified_parameters DIE to the end of the parameter list.  */
if|if
condition|(
name|formal_type
operator|!=
name|void_type_node
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|function_or_method_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Make our second (and final) pass over the list of formal parameter types      and output DIEs to represent those types (as necessary).  */
for|for
control|(
name|link
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|function_or_method_type
argument_list|)
init|;
name|link
operator|&&
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|gen_type_die
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We want to generate the DIE for TYPE so that we can generate the    die for MEMBER, which has been defined; we will need to refer back    to the member declaration nested within TYPE.  If we're trying to    generate minimal debug info for TYPE, processing TYPE won't do the    trick; we need to attach the member declaration by hand.  */
end_comment

begin_function
specifier|static
name|void
name|gen_type_die_for_member
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|member
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|gen_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* If we're trying to avoid duplicate debug info, we may not have      emitted the member decl for this function.  Emit it now.  */
if|if
condition|(
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|lookup_decl_die
argument_list|(
name|member
argument_list|)
condition|)
block|{
name|dw_die_ref
name|type_die
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|decl_ultimate_origin
argument_list|(
name|member
argument_list|)
argument_list|)
expr_stmt|;
name|push_decl_scope
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_die
operator|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|gen_subprogram_die
argument_list|(
name|member
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
comment|/* Ignore the nameless fields that are used to skip bits but handle 	     C++ anonymous unions and structs.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|member
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|gen_type_die
argument_list|(
name|member_declared_type
argument_list|(
name|member
argument_list|)
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|gen_field_die
argument_list|(
name|member
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|gen_variable_die
argument_list|(
name|member
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|pop_decl_scope
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the DWARF2 info for the "abstract" instance of a function which we    may later generate inlined and/or out-of-line instances of.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_abstract_function
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|dw_die_ref
name|old_die
decl_stmt|;
name|tree
name|save_fn
decl_stmt|;
name|struct
name|function
modifier|*
name|save_cfun
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|int
name|was_abstract
init|=
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Make sure we have the actual abstract inline, not a clone.  */
name|decl
operator|=
name|DECL_ORIGIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|old_die
operator|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_die
operator|&&
name|get_AT
argument_list|(
name|old_die
argument_list|,
name|DW_AT_inline
argument_list|)
condition|)
comment|/* We've already generated the abstract instance.  */
return|return;
comment|/* Be sure we've emitted the in-class declaration DIE (if any) first, so      we don't get confused by DECL_ABSTRACT.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
block|{
name|context
operator|=
name|decl_class_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|gen_type_die_for_member
argument_list|(
name|context
argument_list|,
name|decl
argument_list|,
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|?
name|NULL
else|:
name|comp_unit_die
argument_list|)
expr_stmt|;
block|}
comment|/* Pretend we've just finished compiling this function.  */
name|save_fn
operator|=
name|current_function_decl
expr_stmt|;
name|save_cfun
operator|=
name|cfun
expr_stmt|;
name|current_function_decl
operator|=
name|decl
expr_stmt|;
name|cfun
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dwarf2out_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|was_abstract
condition|)
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|save_fn
expr_stmt|;
name|cfun
operator|=
name|save_cfun
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function of premark_used_types() which gets called through    htab_traverse_resize().     Marks the DIE of a given type in *SLOT as perennial, so it never gets    marked as unused by prune_unused_types.  */
end_comment

begin_function
specifier|static
name|int
name|premark_used_types_helper
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|die
decl_stmt|;
name|type
operator|=
operator|*
name|slot
expr_stmt|;
name|die
operator|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|!=
name|NULL
condition|)
name|die
operator|->
name|die_perennial_p
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Mark all members of used_types_hash as perennial.  */
end_comment

begin_function
specifier|static
name|void
name|premark_used_types
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cfun
operator|&&
name|cfun
operator|->
name|used_types_hash
condition|)
name|htab_traverse
argument_list|(
name|cfun
operator|->
name|used_types_hash
argument_list|,
name|premark_used_types_helper
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent a declared function (either file-scope or    block-local).  */
end_comment

begin_function
specifier|static
name|void
name|gen_subprogram_die
parameter_list|(
name|tree
name|decl
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|char
name|label_id
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|dw_die_ref
name|subr_die
decl_stmt|;
name|tree
name|fn_arg_types
decl_stmt|;
name|tree
name|outer_scope
decl_stmt|;
name|dw_die_ref
name|old_die
init|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|declaration
init|=
operator|(
name|current_function_decl
operator|!=
name|decl
operator|||
name|class_or_namespace_scope_p
argument_list|(
name|context_die
argument_list|)
operator|)
decl_stmt|;
name|premark_used_types
argument_list|()
expr_stmt|;
comment|/* It is possible to have both DECL_ABSTRACT and DECLARATION be true if we      started to generate the abstract instance of an inline, decided to output      its containing class, and proceeded to emit the declaration of the inline      from the member list for the class.  If so, DECLARATION takes priority;      we'll get back to the abstract instance when done with the class.  */
comment|/* The class-scope declaration DIE must be the primary DIE.  */
if|if
condition|(
name|origin
operator|&&
name|declaration
operator|&&
name|class_or_namespace_scope_p
argument_list|(
name|context_die
argument_list|)
condition|)
block|{
name|origin
operator|=
name|NULL
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|old_die
argument_list|)
expr_stmt|;
block|}
comment|/* Now that the C++ front end lazily declares artificial member fns, we      might need to retrofit the declaration into its class.  */
if|if
condition|(
operator|!
name|declaration
operator|&&
operator|!
name|origin
operator|&&
operator|!
name|old_die
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
operator|!
name|class_or_namespace_scope_p
argument_list|(
name|context_die
argument_list|)
operator|&&
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
name|old_die
operator|=
name|force_decl_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|declaration
operator|||
name|local_scope_p
argument_list|(
name|context_die
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fixup die_parent for the abstract instance of a nested 	 inline function.  */
if|if
condition|(
name|old_die
operator|&&
name|old_die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
name|add_child_die
argument_list|(
name|context_die
argument_list|,
name|old_die
argument_list|)
expr_stmt|;
name|subr_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subprogram
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_abstract_origin_attribute
argument_list|(
name|subr_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_die
condition|)
block|{
name|expanded_location
name|s
init|=
name|expand_location
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|dwarf_file_data
modifier|*
name|file_index
init|=
name|lookup_filename
argument_list|(
name|s
operator|.
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|get_AT_flag
argument_list|(
name|old_die
argument_list|,
name|DW_AT_declaration
argument_list|)
comment|/* We can have a normal definition following an inline one in the 	     case of redefinition of GNU C extern inlines. 	     It seems reasonable to use AT_specification in this case.  */
operator|&&
operator|!
name|get_AT
argument_list|(
name|old_die
argument_list|,
name|DW_AT_inline
argument_list|)
condition|)
block|{
comment|/* Detect and ignore this case, where we are trying to output 	     something we have already output.  */
return|return;
block|}
comment|/* If the definition comes from the same place as the declaration, 	 maybe use the old DIE.  We always want the DIE for this function 	 that has the *_pc attributes to be under comp_unit_die so the 	 debugger can find it.  We also need to do this for abstract 	 instances of inlines, since the spec requires the out-of-line copy 	 to have the same parent.  For local class methods, this doesn't 	 apply; we just use the old DIE.  */
if|if
condition|(
operator|(
name|old_die
operator|->
name|die_parent
operator|==
name|comp_unit_die
operator|||
name|context_die
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|get_AT_file
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_file
argument_list|)
operator|==
name|file_index
operator|&&
operator|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_line
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|s
operator|.
name|line
operator|)
operator|)
operator|)
condition|)
block|{
name|subr_die
operator|=
name|old_die
expr_stmt|;
comment|/* Clear out the declaration attribute and the formal parameters. 	     Do not remove all children, because it is possible that this 	     declaration die was forced using force_decl_die(). In such 	     cases die that forced declaration die (e.g. TAG_imported_module) 	     is one of the children that we do not want to remove.  */
name|remove_AT
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_declaration
argument_list|)
expr_stmt|;
name|remove_child_TAG
argument_list|(
name|subr_die
argument_list|,
name|DW_TAG_formal_parameter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subr_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subprogram
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_AT_specification
argument_list|(
name|subr_die
argument_list|,
name|old_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_AT_file
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_file
argument_list|)
operator|!=
name|file_index
condition|)
name|add_AT_file
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_decl_file
argument_list|,
name|file_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_line
argument_list|)
operator|!=
operator|(
name|unsigned
operator|)
name|s
operator|.
name|line
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_decl_line
argument_list|,
name|s
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|subr_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subprogram
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_external
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_name_and_src_coords_attributes
argument_list|(
name|subr_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
block|{
name|add_prototyped_attribute
argument_list|(
name|subr_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|subr_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
name|add_pure_or_virtual_attribute
argument_list|(
name|subr_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_private
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declaration
condition|)
block|{
if|if
condition|(
operator|!
name|old_die
operator|||
operator|!
name|get_AT
argument_list|(
name|old_die
argument_list|,
name|DW_AT_inline
argument_list|)
condition|)
block|{
name|add_AT_flag
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The first time we see a member function, it is in the context of 	     the class to which it belongs.  We make sure of this by emitting 	     the class first.  The next time is the definition, which is 	     handled above.  The two may come from the same source text.  	     Note that force_decl_die() forces function declaration die. It is 	     later reused to represent definition.  */
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_DECLARED_INLINE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|cgraph_function_possibly_inlined_p
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_inline
argument_list|,
name|DW_INL_declared_inlined
argument_list|)
expr_stmt|;
else|else
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_inline
argument_list|,
name|DW_INL_declared_not_inlined
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cgraph_function_possibly_inlined_p
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_inline
argument_list|,
name|DW_INL_inlined
argument_list|)
expr_stmt|;
else|else
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_inline
argument_list|,
name|DW_INL_not_inlined
argument_list|)
expr_stmt|;
block|}
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|HOST_WIDE_INT
name|cfa_fb_offset
decl_stmt|;
if|if
condition|(
operator|!
name|old_die
operator|||
operator|!
name|get_AT
argument_list|(
name|old_die
argument_list|,
name|DW_AT_inline
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_reorder_blocks_and_partition
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label_id
argument_list|,
name|FUNC_BEGIN_LABEL
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|label_id
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label_id
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|current_function_funcdef_no
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|label_id
argument_list|)
expr_stmt|;
name|add_pubname
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
name|add_arange
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Do nothing for now; maybe need to duplicate die, one for 	      hot section and ond for cold section, then use the hot/cold 	      section begin/end labels to generate the aranges...  */
comment|/* 	    add_AT_lbl_id (subr_die, DW_AT_low_pc, hot_section_label); 	    add_AT_lbl_id (subr_die, DW_AT_high_pc, hot_section_end_label); 	    add_AT_lbl_id (subr_die, DW_AT_lo_user, unlikely_section_label); 	    add_AT_lbl_id (subr_die, DW_AT_hi_user, cold_section_end_label);  	    add_pubname (decl, subr_die); 	    add_arange (decl, subr_die); 	    add_arange (decl, subr_die); 	   */
block|}
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* Add a reference to the FDE for this routine.  */
name|add_AT_fde_ref
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_MIPS_fde
argument_list|,
name|current_funcdef_fde
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cfa_fb_offset
operator|=
name|CFA_FRAME_BASE_OFFSET
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* We define the "frame base" as the function's CFA.  This is more 	 convenient for several reasons: (1) It's stable across the prologue 	 and epilogue, which makes it better than just a frame pointer, 	 (2) With dwarf3, there exists a one-byte encoding that allows us 	 to reference the .debug_frame data by proxy, but failing that, 	 (3) We can at least reuse the code inspection and interpretation 	 code that determines the CFA position at various points in the 	 function.  */
comment|/* ??? Use some command-line or configury switch to enable the use 	 of dwarf3 DW_OP_call_frame_cfa.  At present there are no dwarf 	 consumers that understand it; fall back to "pure" dwarf2 and 	 convert the CFA data into a location list.  */
block|{
name|dw_loc_list_ref
name|list
init|=
name|convert_cfa_to_fb_loc_list
argument_list|(
name|cfa_fb_offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|->
name|dw_loc_next
condition|)
name|add_AT_loc_list
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_frame_base
argument_list|,
name|list
argument_list|)
expr_stmt|;
else|else
name|add_AT_loc
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_frame_base
argument_list|,
name|list
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
comment|/* Compute a displacement from the "steady-state frame pointer" to 	 the CFA.  The former is what all stack slots and argument slots 	 will reference in the rtl; the later is what we've told the  	 debugger about.  We'll need to adjust all frame_base references 	 by this displacement.  */
name|compute_frame_pointer_to_fb_displacement
argument_list|(
name|cfa_fb_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|->
name|static_chain_decl
condition|)
name|add_AT_location_description
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_static_link
argument_list|,
name|loc_descriptor_from_tree
argument_list|(
name|cfun
operator|->
name|static_chain_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now output descriptions of the arguments for this function. This gets      (unnecessarily?) complex because of the fact that the DECL_ARGUMENT list      for a FUNCTION_DECL doesn't indicate cases where there was a trailing      `...' at the end of the formal parameter list.  In order to find out if      there was a trailing ellipsis or not, we must instead look at the type      associated with the FUNCTION_DECL.  This will be a node of type      FUNCTION_TYPE. If the chain of type nodes hanging off of this      FUNCTION_TYPE node ends with a void_type_node then there should *not* be      an ellipsis at the end.  */
comment|/* In the case where we are describing a mere function declaration, all we      need to do here (and all we *can* do here) is to describe the *types* of      its formal parameters.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|declaration
condition|)
name|gen_formal_types_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Generate DIEs to represent all known formal parameters.  */
name|tree
name|arg_decls
init|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|parm
decl_stmt|;
comment|/* When generating DIEs, generate the unspecified_parameters DIE 	 instead if we come across the arg "__builtin_va_alist" */
for|for
control|(
name|parm
operator|=
name|arg_decls
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|parm
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
else|else
name|gen_decl_die
argument_list|(
name|parm
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
comment|/* Decide whether we need an unspecified_parameters DIE at the end. 	 There are 2 more cases to do this for: 1) the ansi ... declaration - 	 this is detectable when the end of the arg list is not a 	 void_type_node 2) an unprototyped function declaration (not a 	 definition).  This just means that we have no info about the 	 parameters at all.  */
name|fn_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_arg_types
operator|!=
name|NULL
condition|)
block|{
comment|/* This is the prototyped case, check for....  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|fn_arg_types
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
comment|/* Output Dwarf info for all of the stuff within the body of the function      (if it has one - it may be just a declaration).  */
name|outer_scope
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* OUTER_SCOPE is a pointer to the outermost BLOCK node created to represent      a function.  This BLOCK actually represents the outermost binding contour      for the function, i.e. the contour in which the function's formal      parameters and labels get declared. Curiously, it appears that the front      end doesn't actually put the PARM_DECL nodes for the current function onto      the BLOCK_VARS list for this outer scope, but are strung off of the      DECL_ARGUMENTS list for the function instead.       The BLOCK_VARS list for the `outer_scope' does provide us with a list of      the LABEL_DECL nodes for the function however, and we output DWARF info      for those in decls_for_scope.  Just within the `outer_scope' there will be      a BLOCK node representing the function's outermost pair of curly braces,      and any blocks used for the base and member initializers of a C++      constructor function.  */
if|if
condition|(
operator|!
name|declaration
operator|&&
name|TREE_CODE
argument_list|(
name|outer_scope
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
comment|/* Emit a DW_TAG_variable DIE for a named return value.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|gen_decl_die
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
name|current_function_has_inlines
operator|=
literal|0
expr_stmt|;
name|decls_for_scope
argument_list|(
name|outer_scope
argument_list|,
name|subr_die
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|MIPS_DEBUGGING_INFO
argument_list|)
block|if (current_function_has_inlines) 	{ 	  add_AT_flag (subr_die, DW_AT_MIPS_has_inlines, 1); 	  if (! comp_unit_has_inlines) 	    { 	      add_AT_flag (comp_unit_die, DW_AT_MIPS_has_inlines, 1); 	      comp_unit_has_inlines = 1; 	    } 	}
endif|#
directive|endif
block|}
comment|/* Add the calling convention attribute if requested.  */
name|add_calling_convention_attribute
argument_list|(
name|subr_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent a declared data object.  */
end_comment

begin_function
specifier|static
name|void
name|gen_variable_die
parameter_list|(
name|tree
name|decl
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|dw_die_ref
name|var_die
init|=
name|new_die
argument_list|(
name|DW_TAG_variable
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
decl_stmt|;
name|dw_die_ref
name|old_die
init|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|declaration
init|=
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
comment|/* If DECL is COMDAT and has not actually been 			emitted, we cannot take its address; there 			might end up being no definition anywhere in 			the program.  For example, consider the C++ 			test case:                            template<class T>                           struct S { static const int i = 7; };                            template<class T>                           const int S<T>::i;                            int f() { return S<int>::i; } 			   			Here, S<int>::i is not DECL_EXTERNAL, but no 			definition is required, so the compiler will 			not emit a definition.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_COMDAT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|class_or_namespace_scope_p
argument_list|(
name|context_die
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|var_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
comment|/* Loop unrolling can create multiple blocks that refer to the same      static variable, so we must test for the DW_AT_declaration flag.       ??? Loop unrolling/reorder_blocks should perhaps be rewritten to      copy decls and set the DECL_ABSTRACT flag on them instead of      sharing them.       ??? Duplicated blocks have been rewritten to use .debug_ranges.       ??? The declare_in_namespace support causes us to get two DIEs for one      variable, both of which are declarations.  We want to avoid considering      one to be a specification, so we must test that this DIE is not a      declaration.  */
elseif|else
if|if
condition|(
name|old_die
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|declaration
operator|&&
name|get_AT_flag
argument_list|(
name|old_die
argument_list|,
name|DW_AT_declaration
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* This is a definition of a C++ class level static.  */
name|add_AT_specification
argument_list|(
name|var_die
argument_list|,
name|old_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|expanded_location
name|s
init|=
name|expand_location
argument_list|(
name|DECL_SOURCE_LOCATION
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|dwarf_file_data
modifier|*
name|file_index
init|=
name|lookup_filename
argument_list|(
name|s
operator|.
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_AT_file
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_file
argument_list|)
operator|!=
name|file_index
condition|)
name|add_AT_file
argument_list|(
name|var_die
argument_list|,
name|DW_AT_decl_file
argument_list|,
name|file_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_line
argument_list|)
operator|!=
operator|(
name|unsigned
operator|)
name|s
operator|.
name|line
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_decl_line
argument_list|,
name|s
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|add_name_and_src_coords_attributes
argument_list|(
name|var_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|var_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|var_die
argument_list|,
name|DW_AT_external
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|var_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_private
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declaration
condition|)
name|add_AT_flag
argument_list|(
name|var_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|||
name|declaration
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|var_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declaration
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|add_location_or_const_value_attribute
argument_list|(
name|var_die
argument_list|,
name|decl
argument_list|,
name|DW_AT_location
argument_list|)
expr_stmt|;
name|add_pubname
argument_list|(
name|decl
argument_list|,
name|var_die
argument_list|)
expr_stmt|;
block|}
else|else
name|tree_add_const_value_attribute
argument_list|(
name|var_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent a label identifier.  */
end_comment

begin_function
specifier|static
name|void
name|gen_label_die
parameter_list|(
name|tree
name|decl
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|dw_die_ref
name|lbl_die
init|=
name|new_die
argument_list|(
name|DW_TAG_label
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|lbl_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
name|add_name_and_src_coords_attributes
argument_list|(
name|lbl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|lbl_die
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|DECL_RTL_IF_SET
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Deleted labels are programmer specified labels which have been 	 eliminated because of various optimizations.  We still emit them 	 here so that it is possible to put breakpoints on them.  */
if|if
condition|(
name|insn
operator|&&
operator|(
name|LABEL_P
argument_list|(
name|insn
argument_list|)
operator|||
operator|(
operator|(
name|NOTE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* When optimization is enabled (via -O) some parts of the compiler 	     (e.g. jump.c and cse.c) may try to delete CODE_LABEL insns which 	     represent source-level labels which were explicitly declared by 	     the user.  This really shouldn't be happening though, so catch 	     it if it ever does happen.  */
name|gcc_assert
argument_list|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|lbl_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* A helper function for gen_inlined_subroutine_die.  Add source coordinate    attributes to the DIE for a block STMT, to describe where the inlined    function was called from.  This is similar to add_src_coords_attributes.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_call_src_coords_attributes
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|dw_die_ref
name|die
parameter_list|)
block|{
name|expanded_location
name|s
init|=
name|expand_location
argument_list|(
name|BLOCK_SOURCE_LOCATION
argument_list|(
name|stmt
argument_list|)
argument_list|)
decl_stmt|;
name|add_AT_file
argument_list|(
name|die
argument_list|,
name|DW_AT_call_file
argument_list|,
name|lookup_filename
argument_list|(
name|s
operator|.
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_call_line
argument_list|,
name|s
operator|.
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A helper function for gen_lexical_block_die and gen_inlined_subroutine_die.    Add low_pc and high_pc attributes to the DIE for a block STMT.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_high_low_attributes
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|dw_die_ref
name|die
parameter_list|)
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|tree
name|chain
decl_stmt|;
name|add_AT_range_list
argument_list|(
name|die
argument_list|,
name|DW_AT_ranges
argument_list|,
name|add_ranges
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
do|do
block|{
name|add_ranges
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|=
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chain
condition|)
do|;
name|add_ranges
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|BLOCK_BEGIN_LABEL
argument_list|,
name|BLOCK_NUMBER
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|BLOCK_END_LABEL
argument_list|,
name|BLOCK_NUMBER
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE for a lexical block.  */
end_comment

begin_function
specifier|static
name|void
name|gen_lexical_block_die
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|dw_die_ref
name|stmt_die
init|=
name|new_die
argument_list|(
name|DW_TAG_lexical_block
argument_list|,
name|context_die
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
name|add_high_low_attributes
argument_list|(
name|stmt
argument_list|,
name|stmt_die
argument_list|)
expr_stmt|;
name|decls_for_scope
argument_list|(
name|stmt
argument_list|,
name|stmt_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for an inlined subprogram.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_subroutine_die
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|tree
name|decl
init|=
name|block_ultimate_origin
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
comment|/* Emit info for the abstract instance first, if we haven't yet.  We      must emit this even if the block is abstract, otherwise when we      emit the block below (or elsewhere), we may end up trying to emit      a die whose origin die hasn't been emitted, and crashing.  */
name|dwarf2out_abstract_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|dw_die_ref
name|subr_die
init|=
name|new_die
argument_list|(
name|DW_TAG_inlined_subroutine
argument_list|,
name|context_die
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
name|add_abstract_origin_attribute
argument_list|(
name|subr_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_high_low_attributes
argument_list|(
name|stmt
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
name|add_call_src_coords_attributes
argument_list|(
name|stmt
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
name|decls_for_scope
argument_list|(
name|stmt
argument_list|,
name|subr_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|current_function_has_inlines
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* We may get here if we're the outer block of function A that was        inlined into function B that was inlined into function C.  When        generating debugging info for C, dwarf2out_abstract_function(B)        would mark all inlined blocks as abstract, including this one.        So, we wouldn't (and shouldn't) expect labels to be generated        for this one.  Instead, just emit debugging info for        declarations within the block.  This is particularly important        in the case of initializers of arguments passed from B to us:        if they're statement expressions containing declarations, we        wouldn't generate dies for their abstract variables, and then,        when generating dies for the real variables, we'd die (pun        intended :-)  */
name|gen_lexical_block_die
argument_list|(
name|stmt
argument_list|,
name|context_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a field in a record, or structure.  */
end_comment

begin_function
specifier|static
name|void
name|gen_field_die
parameter_list|(
name|tree
name|decl
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|decl_die
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
name|decl_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_member
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_name_and_src_coords_attributes
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|decl_die
argument_list|,
name|member_declared_type
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|add_byte_size_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_bit_size_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_bit_offset_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
name|add_data_member_location_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_private
argument_list|)
expr_stmt|;
comment|/* Equate decl number to die, so that we can look up this decl later on.  */
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|decl_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Don't generate either pointer_type DIEs or reference_type DIEs here.    Use modified_type_die instead.    We keep this code here just in case these types of DIEs may be needed to    represent certain things in other languages (e.g. Pascal) someday.  */
end_comment

begin_comment
unit|static void gen_pointer_type_die (tree type, dw_die_ref context_die) {   dw_die_ref ptr_die     = new_die (DW_TAG_pointer_type, scope_die_for (type, context_die), type);    equate_type_number_to_die (type, ptr_die);   add_type_attribute (ptr_die, TREE_TYPE (type), 0, 0, context_die);   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE); }
comment|/* Don't generate either pointer_type DIEs or reference_type DIEs here.    Use modified_type_die instead.    We keep this code here just in case these types of DIEs may be needed to    represent certain things in other languages (e.g. Pascal) someday.  */
end_comment

begin_endif
unit|static void gen_reference_type_die (tree type, dw_die_ref context_die) {   dw_die_ref ref_die     = new_die (DW_TAG_reference_type, scope_die_for (type, context_die), type);    equate_type_number_to_die (type, ref_die);   add_type_attribute (ref_die, TREE_TYPE (type), 0, 0, context_die);   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate a DIE for a pointer to a member type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_ptr_to_mbr_type_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|ptr_die
init|=
name|new_die
argument_list|(
name|DW_TAG_ptr_to_member_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|ptr_die
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|ptr_die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|lookup_type_die
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|ptr_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the DIE for the compilation unit.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|gen_compile_unit_die
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|dw_die_ref
name|die
decl_stmt|;
name|char
name|producer
index|[
literal|250
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|language_string
init|=
name|lang_hooks
operator|.
name|name
decl_stmt|;
name|int
name|language
decl_stmt|;
name|die
operator|=
name|new_die
argument_list|(
name|DW_TAG_compile_unit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
condition|)
block|{
name|add_name_attribute
argument_list|(
name|die
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Don't add cwd for<built-in>.  */
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
name|DIR_SEPARATOR
operator|&&
name|filename
index|[
literal|0
index|]
operator|!=
literal|'<'
condition|)
name|add_comp_dir_attribute
argument_list|(
name|die
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|producer
argument_list|,
literal|"%s %s"
argument_list|,
name|language_string
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* The MIPS/SGI compilers place the 'cc' command line options in the producer      string.  The SGI debugger looks for -g, -g1, -g2, or -g3; if they do      not appear in the producer string, the debugger reaches the conclusion      that the object file is stripped and has no debugging information.      To get the MIPS/SGI debugger to believe that there is debugging      information in the object file, we add a -g to the producer string.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
name|strcat
argument_list|(
name|producer
argument_list|,
literal|" -g"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_producer
argument_list|,
name|producer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_C_plus_plus
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Ada"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_Ada95
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F77"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_Fortran77
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F95"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_Fortran95
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Pascal"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_Pascal83
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Java"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_Java
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Objective-C"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_ObjC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Objective-C++"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_ObjC_plus_plus
expr_stmt|;
else|else
name|language
operator|=
name|DW_LANG_C89
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_language
argument_list|,
name|language
argument_list|)
expr_stmt|;
return|return
name|die
return|;
block|}
end_function

begin_comment
comment|/* Generate the DIE for a base class.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inheritance_die
parameter_list|(
name|tree
name|binfo
parameter_list|,
name|tree
name|access
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|die
init|=
name|new_die
argument_list|(
name|DW_TAG_inheritance
argument_list|,
name|context_die
argument_list|,
name|binfo
argument_list|)
decl_stmt|;
name|add_type_attribute
argument_list|(
name|die
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|add_data_member_location_attribute
argument_list|(
name|die
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|binfo
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_virtuality
argument_list|,
name|DW_VIRTUALITY_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
operator|==
name|access_public_node
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_public
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
name|access_protected_node
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a class member.  */
end_comment

begin_function
specifier|static
name|void
name|gen_member_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|tree
name|member
decl_stmt|;
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|dw_die_ref
name|child
decl_stmt|;
comment|/* If this is not an incomplete type, output descriptions of each of its      members. Note that as we output the DIEs necessary to represent the      members of this record or union type, we will also be trying to output      DIEs to represent the *types* of those members. However the `type'      function (above) will specifically avoid generating type DIEs for member      types *within* the list of member DIEs for this (containing) type except      for those types (of members) which are explicitly marked as also being      members of this (containing) type themselves.  The g++ front- end can      force any given type to be treated as a member of some other (containing)      type by setting the TYPE_CONTEXT of the given (member) type to point to      the TREE node representing the appropriate (containing) type.  */
comment|/* First output info about the base classes.  */
if|if
condition|(
name|binfo
condition|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|accesses
operator|=
name|BINFO_BASE_ACCESSES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|base
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|base
argument_list|)
condition|;
name|i
operator|++
control|)
name|gen_inheritance_die
argument_list|(
name|base
argument_list|,
operator|(
name|accesses
condition|?
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|accesses
argument_list|,
name|i
argument_list|)
else|:
name|access_public_node
operator|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
comment|/* Now output info about the data members and type members.  */
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
comment|/* If we thought we were generating minimal debug info for TYPE 	 and then changed our minds, some of the member declarations 	 may have already been defined.  Don't define them again, but 	 do put them in the right order.  */
name|child
operator|=
name|lookup_decl_die
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
condition|)
name|splice_child_die
argument_list|(
name|context_die
argument_list|,
name|child
argument_list|)
expr_stmt|;
else|else
name|gen_decl_die
argument_list|(
name|member
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
comment|/* Now output info about the function members (if any).  */
for|for
control|(
name|member
operator|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
comment|/* Don't include clones in the member list.  */
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|member
argument_list|)
condition|)
continue|continue;
name|child
operator|=
name|lookup_decl_die
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
condition|)
name|splice_child_die
argument_list|(
name|context_die
argument_list|,
name|child
argument_list|)
expr_stmt|;
else|else
name|gen_decl_die
argument_list|(
name|member
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE for a structure or union type.  If TYPE_DECL_SUPPRESS_DEBUG    is set, we pretend that the type was never defined, so we only get the    member DIEs needed by later specification DIEs.  */
end_comment

begin_function
specifier|static
name|void
name|gen_struct_or_union_type_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|type_die
init|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|dw_die_ref
name|scope_die
init|=
literal|0
decl_stmt|;
name|int
name|nested
init|=
literal|0
decl_stmt|;
name|int
name|complete
init|=
operator|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|!
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
decl_stmt|;
name|int
name|ns_decl
init|=
operator|(
name|context_die
operator|&&
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_namespace
operator|)
decl_stmt|;
if|if
condition|(
name|type_die
operator|&&
operator|!
name|complete
condition|)
return|return;
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|AGGREGATE_TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|)
condition|)
name|nested
operator|=
literal|1
expr_stmt|;
name|scope_die
operator|=
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_die
operator|||
operator|(
name|nested
operator|&&
name|scope_die
operator|==
name|comp_unit_die
operator|)
condition|)
comment|/* First occurrence of type or toplevel definition of nested class.  */
block|{
name|dw_die_ref
name|old_die
init|=
name|type_die
decl_stmt|;
name|type_die
operator|=
name|new_die
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|?
name|DW_TAG_structure_type
else|:
name|DW_TAG_union_type
argument_list|,
name|scope_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_die
condition|)
name|add_AT_specification
argument_list|(
name|type_die
argument_list|,
name|old_die
argument_list|)
expr_stmt|;
else|else
name|add_name_attribute
argument_list|(
name|type_die
argument_list|,
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|remove_AT
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|)
expr_stmt|;
comment|/* If this type has been completed, then give it a byte_size attribute and      then give a list of members.  */
if|if
condition|(
name|complete
operator|&&
operator|!
name|ns_decl
condition|)
block|{
comment|/* Prevent infinite recursion in cases where the type of some member of 	 this type is expressed in terms of this type itself.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_byte_size_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|add_src_coords_attributes
argument_list|(
name|type_die
argument_list|,
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the first reference to this type was as the return type of an 	 inline function, then it may not have a parent.  Fix this now.  */
if|if
condition|(
name|type_die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
name|add_child_die
argument_list|(
name|scope_die
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|push_decl_scope
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|gen_member_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|pop_decl_scope
argument_list|()
expr_stmt|;
comment|/* GNU extension: Record what type our vtable lives in.  */
if|if
condition|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|vtype
init|=
name|DECL_FCONTEXT
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|gen_type_die
argument_list|(
name|vtype
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|type_die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|lookup_type_die
argument_list|(
name|vtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|add_AT_flag
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We don't need to do this for function-local types.  */
if|if
condition|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|decl_function_context
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
name|incomplete_types
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE for a subroutine _type_.  */
end_comment

begin_function
specifier|static
name|void
name|gen_subroutine_type_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|dw_die_ref
name|subr_die
init|=
name|new_die
argument_list|(
name|DW_TAG_subroutine_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
name|add_prototyped_attribute
argument_list|(
name|subr_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|subr_die
argument_list|,
name|return_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_formal_types_die
argument_list|(
name|type
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a type definition.  */
end_comment

begin_function
specifier|static
name|void
name|gen_typedef_die
parameter_list|(
name|tree
name|decl
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|type_die
decl_stmt|;
name|tree
name|origin
decl_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_typedef
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|origin
operator|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|type
decl_stmt|;
name|add_name_and_src_coords_attributes
argument_list|(
name|type_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|type
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|type
operator|!=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|equate_type_number_to_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a type description DIE.  */
end_comment

begin_function
specifier|static
name|void
name|gen_type_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|int
name|need_pop
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
return|return;
comment|/* Prevent broken recursion; we can't hand off to the same type.  */
name|gcc_assert
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|type
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gen_decl_die
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We are going to output a DIE to represent the unqualified version      of this type (i.e. without any const or volatile qualifiers) so      get the main variant (i.e. the unqualified version) of this type      now.  (Vectors are special because the debugging info is in the      cloned type itself).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|VECTOR_TYPE
condition|)
name|type
operator|=
name|type_main_variant
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* We must set TREE_ASM_WRITTEN in case this is a recursive type.  This 	 ensures that the gen_type_die recursion will terminate even if the 	 type is recursive.  Recursive types are possible in Ada.  */
comment|/* ??? We could perhaps do this for all types before the switch 	 statement.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* For these types, all that is required is that we output a DIE (or a 	 set of DIEs) to represent the "basis" type.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
comment|/* This code is used for C++ pointer-to-data-member types. 	 Output a description of the relevant class type.  */
name|gen_type_die
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Output a description of the type of the object pointed to.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Now output a DIE to represent this pointer-to-data-member type 	 itself.  */
name|gen_ptr_to_mbr_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
comment|/* Force out return type (in case it wasn't forced out already).  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_subroutine_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
comment|/* Force out return type (in case it wasn't forced out already).  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_subroutine_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|gen_array_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_TYPE
case|:
name|gen_array_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
comment|/* If this is a nested type whose containing class hasn't been written 	 out yet, writing it out will cover this one, too.  This does not apply 	 to instantiations of member class templates; they need to be added to 	 the containing class as they are generated.  FIXME: This hurts the 	 idea of combining type decls from multiple TUs, since we can't predict 	 what set of template instantiations we'll get.  */
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|gen_type_die
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
return|return;
comment|/* If that failed, attach ourselves to the stub.  */
name|push_decl_scope
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|context_die
operator|=
name|lookup_type_die
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|need_pop
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|declare_in_namespace
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|need_pop
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
comment|/* This might have been written out by the call to 	     declare_in_namespace.  */
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
name|gen_enumeration_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
else|else
name|gen_struct_or_union_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_pop
condition|)
name|pop_decl_scope
argument_list|()
expr_stmt|;
comment|/* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix 	 it up if it is ever completed.  gen_*_type_die will set it for us 	 when appropriate.  */
return|return;
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
comment|/* No DIEs needed for fundamental types.  */
break|break;
case|case
name|LANG_TYPE
case|:
comment|/* No Dwarf representation currently defined.  */
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a tagged type instantiation.  */
end_comment

begin_function
specifier|static
name|void
name|gen_tagged_type_instantiation_die
parameter_list|(
name|tree
name|type
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* We are going to output a DIE to represent the unqualified version of      this type (i.e. without any const or volatile qualifiers) so make sure      that we have the main variant (i.e. the unqualified version) of this      type now.  */
name|gcc_assert
argument_list|(
name|type
operator|==
name|type_main_variant
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do not check TREE_ASM_WRITTEN (type) as it may not be set if this is      an instance of an unresolved type.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|gen_inlined_enumeration_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
name|gen_inlined_structure_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|gen_inlined_union_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DW_TAG_lexical_block DIE followed by DIEs to represent all of the    things which are local to the given block.  */
end_comment

begin_function
specifier|static
name|void
name|gen_block_die
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
name|must_output_die
init|=
literal|0
decl_stmt|;
name|tree
name|origin
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|enum
name|tree_code
name|origin_code
decl_stmt|;
comment|/* Ignore blocks that are NULL.  */
if|if
condition|(
name|stmt
operator|==
name|NULL_TREE
condition|)
return|return;
comment|/* If the block is one fragment of a non-contiguous block, do not      process the variables, since they will have been done by the      origin block.  Do process subblocks.  */
if|if
condition|(
name|BLOCK_FRAGMENT_ORIGIN
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|tree
name|sub
decl_stmt|;
for|for
control|(
name|sub
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|sub
condition|;
name|sub
operator|=
name|BLOCK_CHAIN
argument_list|(
name|sub
argument_list|)
control|)
name|gen_block_die
argument_list|(
name|sub
argument_list|,
name|context_die
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Determine the "ultimate origin" of this block.  This block may be an      inlined instance of an inlined instance of inline function, so we have      to trace all of the way back through the origin chain to find out what      sort of node actually served as the original seed for the creation of      the current block.  */
name|origin
operator|=
name|block_ultimate_origin
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|origin_code
operator|=
operator|(
name|origin
operator|!=
name|NULL
operator|)
condition|?
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
else|:
name|ERROR_MARK
expr_stmt|;
comment|/* Determine if we need to output any Dwarf DIEs at all to represent this      block.  */
if|if
condition|(
name|origin_code
operator|==
name|FUNCTION_DECL
condition|)
comment|/* The outer scopes for inlinings *must* always be represented.  We        generate DW_TAG_inlined_subroutine DIEs for them.  (See below.) */
name|must_output_die
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* In the case where the current block represents an inlining of the 	 "body block" of an inline function, we must *NOT* output any DIE for 	 this block because we have already output a DIE to represent the whole 	 inlined function scope and the "body block" of any function doesn't 	 really represent a different scope according to ANSI C rules.  So we 	 check here to make sure that this block does not represent a "body 	 block inlining" before trying to set the MUST_OUTPUT_DIE flag.  */
if|if
condition|(
operator|!
name|is_body_block
argument_list|(
name|origin
condition|?
name|origin
else|:
name|stmt
argument_list|)
condition|)
block|{
comment|/* Determine if this block directly contains any "significant" 	     local declarations which we will need to output DIEs for.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
comment|/* We are not in terse mode so *any* local declaration counts 	       as being a "significant" one.  */
name|must_output_die
operator|=
operator|(
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
operator|||
name|TREE_ASM_WRITTEN
argument_list|(
name|stmt
argument_list|)
operator|||
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
operator|)
operator|)
expr_stmt|;
else|else
comment|/* We are in terse mode, so only local (nested) function 	       definitions count as "significant" local declarations.  */
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|decl
operator|!=
name|NULL
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|must_output_die
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* It would be a waste of space to generate a Dwarf DW_TAG_lexical_block      DIE for any block which contains no significant local declarations at      all.  Rather, in such cases we just call `decls_for_scope' so that any      needed Dwarf info for any sub-blocks will get properly generated. Note      that in terse mode, our definition of what constitutes a "significant"      local declaration gets restricted to include only inlined function      instances and local (nested) function definitions.  */
if|if
condition|(
name|must_output_die
condition|)
block|{
if|if
condition|(
name|origin_code
operator|==
name|FUNCTION_DECL
condition|)
name|gen_inlined_subroutine_die
argument_list|(
name|stmt
argument_list|,
name|context_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
else|else
name|gen_lexical_block_die
argument_list|(
name|stmt
argument_list|,
name|context_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
else|else
name|decls_for_scope
argument_list|(
name|stmt
argument_list|,
name|context_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate all of the decls declared within a given scope and (recursively)    all of its sub-blocks.  */
end_comment

begin_function
specifier|static
name|void
name|decls_for_scope
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|subblocks
decl_stmt|;
comment|/* Ignore NULL blocks.  */
if|if
condition|(
name|stmt
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
comment|/* Output the DIEs to represent all of the data objects and typedefs 	 declared directly within this block but not within any nested 	 sub-blocks.  Also, nested function and tag DIEs have been 	 generated with a parent of NULL; fix that up now.  */
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|decl
operator|!=
name|NULL
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|dw_die_ref
name|die
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|die
operator|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
condition|)
name|die
operator|=
name|lookup_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|die
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|die
operator|!=
name|NULL
operator|&&
name|die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
name|add_child_die
argument_list|(
name|context_die
argument_list|,
name|die
argument_list|)
expr_stmt|;
comment|/* Do not produce debug information for static variables since 	     these might be optimized out.  We are called for these later 	     in cgraph_varpool_analyze_pending_decls. */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
empty_stmt|;
else|else
name|gen_decl_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we're at -g1, we're not interested in subblocks.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
comment|/* Output the DIEs to represent all sub-blocks (and the items declared      therein) of this block.  */
for|for
control|(
name|subblocks
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|subblocks
operator|!=
name|NULL
condition|;
name|subblocks
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblocks
argument_list|)
control|)
name|gen_block_die
argument_list|(
name|subblocks
argument_list|,
name|context_die
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Is this a typedef we can avoid emitting?  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_redundant_typedef
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|is_tagged_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* Also ignore the artificial member typedef for the class name.  */
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns the DIE for decl.  A DIE will always be returned.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|force_decl_die
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|dw_die_ref
name|decl_die
decl_stmt|;
name|unsigned
name|saved_external_flag
decl_stmt|;
name|tree
name|save_fn
init|=
name|NULL_TREE
decl_stmt|;
name|decl_die
operator|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl_die
condition|)
block|{
name|dw_die_ref
name|context_die
decl_stmt|;
name|tree
name|decl_context
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl_context
condition|)
block|{
comment|/* Find die that represents this context.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|decl_context
argument_list|)
condition|)
name|context_die
operator|=
name|force_type_die
argument_list|(
name|decl_context
argument_list|)
expr_stmt|;
else|else
name|context_die
operator|=
name|force_decl_die
argument_list|(
name|decl_context
argument_list|)
expr_stmt|;
block|}
else|else
name|context_die
operator|=
name|comp_unit_die
expr_stmt|;
name|decl_die
operator|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_die
condition|)
return|return
name|decl_die
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
comment|/* Clear current_function_decl, so that gen_subprogram_die thinks 	     that this is a declaration. At this point, we just want to force 	     declaration die.  */
name|save_fn
operator|=
name|current_function_decl
expr_stmt|;
name|current_function_decl
operator|=
name|NULL_TREE
expr_stmt|;
name|gen_subprogram_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|save_fn
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
comment|/* Set external flag to force declaration die. Restore it after 	   gen_decl_die() call.  */
name|saved_external_flag
operator|=
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gen_decl_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|saved_external_flag
expr_stmt|;
break|break;
case|case
name|NAMESPACE_DECL
case|:
name|dwarf2out_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* We should be able to find the DIE now.  */
if|if
condition|(
operator|!
name|decl_die
condition|)
name|decl_die
operator|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|decl_die
argument_list|)
expr_stmt|;
block|}
return|return
name|decl_die
return|;
block|}
end_function

begin_comment
comment|/* Returns the DIE for TYPE, that must not be a base type.  A DIE is    always returned.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|force_type_die
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|dw_die_ref
name|type_die
decl_stmt|;
name|type_die
operator|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_die
condition|)
block|{
name|dw_die_ref
name|context_die
decl_stmt|;
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|context_die
operator|=
name|force_type_die
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|context_die
operator|=
name|force_decl_die
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|context_die
operator|=
name|comp_unit_die
expr_stmt|;
name|type_die
operator|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_die
condition|)
return|return
name|type_die
return|;
name|gen_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|type_die
operator|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|type_die
argument_list|)
expr_stmt|;
block|}
return|return
name|type_die
return|;
block|}
end_function

begin_comment
comment|/* Force out any required namespaces to be able to output DECL,    and return the new context_die for it, if it's changed.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|setup_namespace_context
parameter_list|(
name|tree
name|thing
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|tree
name|context
init|=
operator|(
name|DECL_P
argument_list|(
name|thing
argument_list|)
condition|?
name|DECL_CONTEXT
argument_list|(
name|thing
argument_list|)
else|:
name|TYPE_CONTEXT
argument_list|(
name|thing
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|context
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
comment|/* Force out the namespace.  */
name|context_die
operator|=
name|force_decl_die
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|context_die
return|;
block|}
end_function

begin_comment
comment|/* Emit a declaration DIE for THING (which is either a DECL or a tagged    type) within its namespace, if appropriate.     For compatibility with older debuggers, namespace DIEs only contain    declarations; all definitions are emitted at CU scope.  */
end_comment

begin_function
specifier|static
name|void
name|declare_in_namespace
parameter_list|(
name|tree
name|thing
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|dw_die_ref
name|ns_context
decl_stmt|;
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
comment|/* If this decl is from an inlined function, then don't try to emit it in its      namespace, as we will get confused.  It would have already been emitted      when the abstract instance of the inline function was emitted anyways.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|thing
argument_list|)
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|thing
argument_list|)
condition|)
return|return;
name|ns_context
operator|=
name|setup_namespace_context
argument_list|(
name|thing
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_context
operator|!=
name|context_die
condition|)
block|{
if|if
condition|(
name|DECL_P
argument_list|(
name|thing
argument_list|)
condition|)
name|gen_decl_die
argument_list|(
name|thing
argument_list|,
name|ns_context
argument_list|)
expr_stmt|;
else|else
name|gen_type_die
argument_list|(
name|thing
argument_list|,
name|ns_context
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE for a namespace or namespace alias.  */
end_comment

begin_function
specifier|static
name|void
name|gen_namespace_die
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|dw_die_ref
name|context_die
init|=
name|setup_namespace_context
argument_list|(
name|decl
argument_list|,
name|comp_unit_die
argument_list|)
decl_stmt|;
comment|/* Namespace aliases have a DECL_ABSTRACT_ORIGIN of the namespace      they are an alias of.  */
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Output a real namespace.  */
name|dw_die_ref
name|namespace_die
init|=
name|new_die
argument_list|(
name|DW_TAG_namespace
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
decl_stmt|;
name|add_name_and_src_coords_attributes
argument_list|(
name|namespace_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|namespace_die
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output a namespace alias.  */
comment|/* Force out the namespace we are an alias of, if necessary.  */
name|dw_die_ref
name|origin_die
init|=
name|force_decl_die
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Now create the namespace alias DIE.  */
name|dw_die_ref
name|namespace_die
init|=
name|new_die
argument_list|(
name|DW_TAG_imported_declaration
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
decl_stmt|;
name|add_name_and_src_coords_attributes
argument_list|(
name|namespace_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|namespace_die
argument_list|,
name|DW_AT_import
argument_list|,
name|origin_die
argument_list|)
expr_stmt|;
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|namespace_die
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate Dwarf debug information for a decl described by DECL.  */
end_comment

begin_function
specifier|static
name|void
name|gen_decl_die
parameter_list|(
name|tree
name|decl
parameter_list|,
name|dw_die_ref
name|context_die
parameter_list|)
block|{
name|tree
name|origin
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|CONST_DECL
case|:
comment|/* The individual enumerators of an enum type get output when we output 	 the Dwarf representation of the relevant enum type itself.  */
break|break;
case|case
name|FUNCTION_DECL
case|:
comment|/* Don't output any DIEs to represent mere function declarations, 	 unless they are class members or explicit block externs.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|current_function_decl
operator|==
name|NULL_TREE
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
break|break;
if|#
directive|if
literal|0
comment|/* FIXME */
comment|/* This doesn't work because the C frontend sets DECL_ABSTRACT_ORIGIN 	 on local redeclarations of global functions.  That seems broken.  */
block|if (current_function_decl != decl)
comment|/* This is only a declaration.  */
block|;
endif|#
directive|endif
comment|/* If we're emitting a clone, emit info for the abstract instance.  */
if|if
condition|(
name|DECL_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
name|decl
condition|)
name|dwarf2out_abstract_function
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're emitting an out-of-line copy of an inline function, 	 emit info for the abstract instance and set up to refer to it.  */
elseif|else
if|if
condition|(
name|cgraph_function_possibly_inlined_p
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|class_or_namespace_scope_p
argument_list|(
name|context_die
argument_list|)
comment|/* dwarf2out_abstract_function won't emit a die if this is just 		  a declaration.  We must avoid setting DECL_ABSTRACT_ORIGIN in 		  that case, because that works only if we have a die.  */
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|dwarf2out_abstract_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|set_decl_origin_self
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise we're emitting the primary DIE for this decl.  */
elseif|else
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
block|{
comment|/* Before we describe the FUNCTION_DECL itself, make sure that we 	     have described its return type.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* And its virtual context.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|gen_type_die
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* And its containing type.  */
name|origin
operator|=
name|decl_class_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL_TREE
condition|)
name|gen_type_die_for_member
argument_list|(
name|origin
argument_list|,
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* And its containing namespace.  */
name|declare_in_namespace
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
comment|/* Now output a DIE to represent the function itself.  */
name|gen_subprogram_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* If we are in terse mode, don't generate any DIEs to represent any 	 actual typedefs.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
break|break;
comment|/* In the special case of a TYPE_DECL node representing the declaration 	 of some type tag, if the given TYPE_DECL is marked as having been 	 instantiated from some other (original) TYPE_DECL node (e.g. one which 	 was generated within the original definition of an inline function) we 	 have to generate a special (abbreviated) DW_TAG_structure_type, 	 DW_TAG_union_type, or DW_TAG_enumeration_type DIE here.  */
if|if
condition|(
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|gen_tagged_type_instantiation_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_redundant_typedef
argument_list|(
name|decl
argument_list|)
condition|)
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
else|else
comment|/* Output a DIE to represent the typedef itself.  */
name|gen_typedef_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
name|gen_label_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|RESULT_DECL
case|:
comment|/* If we are in terse mode, don't generate any DIEs to represent any 	 variable declarations or definitions.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
break|break;
comment|/* Output any DIEs that are needed to specify the type of this data 	 object.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* And its containing type.  */
name|origin
operator|=
name|decl_class_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL_TREE
condition|)
name|gen_type_die_for_member
argument_list|(
name|origin
argument_list|,
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* And its containing namespace.  */
name|declare_in_namespace
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Now output the DIE to represent the data object itself.  This gets 	 complicated because of the possibility that the VAR_DECL really 	 represents an inlined instance of a formal parameter for an inline 	 function.  */
name|origin
operator|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|gen_formal_parameter_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
else|else
name|gen_variable_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD_DECL
case|:
comment|/* Ignore the nameless fields that are used to skip bits but handle C++ 	 anonymous unions and structs.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
block|{
name|gen_type_die
argument_list|(
name|member_declared_type
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_field_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARM_DECL
case|:
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_formal_parameter_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAMESPACE_DECL
case|:
name|gen_namespace_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Probably some frontend-internal decl.  Assume we don't care.  */
name|gcc_assert
argument_list|(
operator|(
name|int
operator|)
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|>
name|NUM_TREE_CODES
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output debug information for global decl DECL.  Called from toplev.c after    compilation proper has finished.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_global_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
comment|/* Output DWARF2 information for file-scope tentative data object      declarations, file-scope (extern) function declarations (which had no      corresponding body) and file-scope tagged type declarations and      definitions which have not yet been forced out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|dwarf2out_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output debug information for type decl DECL.  Called from toplev.c    and from language front ends (to record built-in types).  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_type_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|local
parameter_list|)
block|{
if|if
condition|(
operator|!
name|local
condition|)
name|dwarf2out_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output debug information for imported module or decl.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_imported_module_or_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|context
parameter_list|)
block|{
name|dw_die_ref
name|imported_die
decl_stmt|,
name|at_import_die
decl_stmt|;
name|dw_die_ref
name|scope_die
decl_stmt|;
name|expanded_location
name|xloc
decl_stmt|;
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
name|gcc_assert
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* To emit DW_TAG_imported_module or DW_TAG_imported_decl, we need two DIEs.      We need decl DIE for reference and scope die. First, get DIE for the decl      itself.  */
comment|/* Get the scope die for decl context. Use comp_unit_die for global module      or decl. If die is not found for non globals, force new die.  */
if|if
condition|(
operator|!
name|context
condition|)
name|scope_die
operator|=
name|comp_unit_die
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|scope_die
operator|=
name|force_type_die
argument_list|(
name|context
argument_list|)
expr_stmt|;
else|else
name|scope_die
operator|=
name|force_decl_die
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* For TYPE_DECL or CONST_DECL, lookup TREE_TYPE.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|CONST_DECL
condition|)
block|{
if|if
condition|(
name|is_base_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|at_import_die
operator|=
name|base_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|at_import_die
operator|=
name|force_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|at_import_die
operator|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|at_import_die
condition|)
block|{
comment|/* If we're trying to avoid duplicate debug info, we may not have 	     emitted the member decl for this field.  Emit it now.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|tree
name|type
init|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|dw_die_ref
name|type_context_die
decl_stmt|;
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
condition|)
if|if
condition|(
name|TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|type_context_die
operator|=
name|force_type_die
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type_context_die
operator|=
name|force_decl_die
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type_context_die
operator|=
name|comp_unit_die
expr_stmt|;
name|gen_type_die_for_member
argument_list|(
name|type
argument_list|,
name|decl
argument_list|,
name|type_context_die
argument_list|)
expr_stmt|;
block|}
name|at_import_die
operator|=
name|force_decl_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* OK, now we have DIEs for decl as well as scope. Emit imported die.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|imported_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_imported_module
argument_list|,
name|scope_die
argument_list|,
name|context
argument_list|)
expr_stmt|;
else|else
name|imported_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_imported_declaration
argument_list|,
name|scope_die
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|xloc
operator|=
name|expand_location
argument_list|(
name|input_location
argument_list|)
expr_stmt|;
name|add_AT_file
argument_list|(
name|imported_die
argument_list|,
name|DW_AT_decl_file
argument_list|,
name|lookup_filename
argument_list|(
name|xloc
operator|.
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|imported_die
argument_list|,
name|DW_AT_decl_line
argument_list|,
name|xloc
operator|.
name|line
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|imported_die
argument_list|,
name|DW_AT_import
argument_list|,
name|at_import_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the debugging output for DECL.  */
end_comment

begin_function
name|void
name|dwarf2out_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|dw_die_ref
name|context_die
init|=
name|comp_unit_die
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return;
case|case
name|FUNCTION_DECL
case|:
comment|/* What we would really like to do here is to filter out all mere 	 file-scope declarations of file-scope functions which are never 	 referenced later within this translation unit (and keep all of ones 	 that *are* referenced later on) but we aren't clairvoyant, so we have 	 no idea which functions will be referenced in the future (i.e. later 	 on within the current translation unit). So here we just ignore all 	 file-scope function declarations which are not also definitions.  If 	 and when the debugger needs to know something about these functions, 	 it will have to hunt around and find the DWARF information associated 	 with the definition of the function.  	 We can't just check DECL_EXTERNAL to find out which FUNCTION_DECL 	 nodes represent definitions and which ones represent mere 	 declarations.  We have to check DECL_INITIAL instead. That's because 	 the C front-end supports some weird semantics for "extern inline" 	 function definitions.  These can get inlined within the current 	 translation unit (and thus, we need to generate Dwarf info for their 	 abstract instances so that the Dwarf info for the concrete inlined 	 instances can have something to refer to) but the compiler never 	 generates any out-of-lines instances of such things (despite the fact 	 that they *are* definitions).  	 The important point is that the C front-end marks these "extern 	 inline" functions as DECL_EXTERNAL, but we need to generate DWARF for 	 them anyway. Note that the C++ front-end also plays some similar games 	 for inline function definitions appearing within include files which 	 also contain `#pragma interface' pragmas.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
comment|/* If we're a nested function, initially use a parent of NULL; if we're 	 a plain function, this will be fixed up in decls_for_scope.  If 	 we're a method, it will be ignored, since we already have a DIE.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
comment|/* But if we're in terse mode, we don't care about scope.  */
operator|&&
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
name|context_die
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
comment|/* Ignore this VAR_DECL if it refers to a file-scope extern data object 	 declaration and if the declaration was never even referenced from 	 within this entire compilation unit.  We suppress these DIEs in 	 order to save space in the .debug section (by eliminating entries 	 which are probably useless).  Note that we must not suppress 	 block-local extern declarations (whether used or not) because that 	 would screw-up the debugger's name lookup mechanism and cause it to 	 miss things which really ought to be in scope at a given point.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* For local statics lookup proper context die.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|context_die
operator|=
name|lookup_decl_die
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are in terse mode, don't generate any DIEs to represent any 	 variable declarations or definitions.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
break|break;
case|case
name|NAMESPACE_DECL
case|:
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
if|if
condition|(
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* Don't emit stubs for types unless they are needed by other DIEs.  */
if|if
condition|(
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Don't bother trying to generate any DIEs to represent any of the 	 normal built-in types for the language we are compiling.  */
if|if
condition|(
name|DECL_IS_BUILTIN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* OK, we need to generate one for `bool' so GDB knows what type 	     comparisons have.  */
if|if
condition|(
name|is_cxx
argument_list|()
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
name|modified_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we are in terse mode, don't generate any DIEs for types.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
comment|/* If we're a function-scope tag, initially use a parent of NULL; 	 this will be fixed up in decls_for_scope.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|context_die
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|gen_decl_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the beginning of the generated code for    a lexical block.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_begin_block
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|blocknum
parameter_list|)
block|{
name|switch_to_section
argument_list|(
name|current_function_section
argument_list|()
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEBUG_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BLOCK_BEGIN_LABEL
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the end of the generated code for a    lexical block.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_end_block
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|blocknum
parameter_list|)
block|{
name|switch_to_section
argument_list|(
name|current_function_section
argument_list|()
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEBUG_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BLOCK_END_LABEL
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if it is appropriate not to emit any debugging    information for BLOCK, because it doesn't contain any instructions.     Don't allow this for blocks with nested functions or local classes    as we would end up with orphans, and in the presence of scheduling    we may end up calling them anyway.  */
end_comment

begin_function
specifier|static
name|bool
name|dwarf2out_ignore_block
parameter_list|(
name|tree
name|block
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Hash table routines for file_hash.  */
end_comment

begin_function
specifier|static
name|int
name|file_table_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1_p
parameter_list|,
specifier|const
name|void
modifier|*
name|p2_p
parameter_list|)
block|{
specifier|const
name|struct
name|dwarf_file_data
modifier|*
name|p1
init|=
name|p1_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|p2
init|=
name|p2_p
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|p1
operator|->
name|filename
argument_list|,
name|p2
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|file_table_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p_p
parameter_list|)
block|{
specifier|const
name|struct
name|dwarf_file_data
modifier|*
name|p
init|=
name|p_p
decl_stmt|;
return|return
name|htab_hash_string
argument_list|(
name|p
operator|->
name|filename
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup FILE_NAME (in the list of filenames that we know about here in    dwarf2out.c) and return its "index".  The index of each (known) filename is    just a unique number which is associated with only that one filename.  We    need such numbers for the sake of generating labels (in the .debug_sfnames    section) and references to those files numbers (in the .debug_srcinfo    and.debug_macinfo sections).  If the filename given as an argument is not    found in our current list, add it to the list and assign it the next    available unique index number.  In order to speed up searches, we remember    the index of the filename was looked up last.  This handles the majority of    all searches.  */
end_comment

begin_function
specifier|static
name|struct
name|dwarf_file_data
modifier|*
name|lookup_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|struct
name|dwarf_file_data
modifier|*
name|created
decl_stmt|;
comment|/* Check to see if the file name that was searched on the previous      call matches this file name.  If so, return the index.  */
if|if
condition|(
name|file_table_last_lookup
operator|&&
operator|(
name|file_name
operator|==
name|file_table_last_lookup
operator|->
name|filename
operator|||
name|strcmp
argument_list|(
name|file_table_last_lookup
operator|->
name|filename
argument_list|,
name|file_name
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|file_table_last_lookup
return|;
comment|/* Didn't match the previous lookup, search the table.  */
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|file_table
argument_list|,
name|file_name
argument_list|,
name|htab_hash_string
argument_list|(
name|file_name
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
condition|)
return|return
operator|*
name|slot
return|;
name|created
operator|=
name|ggc_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_file_data
argument_list|)
argument_list|)
expr_stmt|;
name|created
operator|->
name|filename
operator|=
name|file_name
expr_stmt|;
name|created
operator|->
name|emitted_number
operator|=
literal|0
expr_stmt|;
operator|*
name|slot
operator|=
name|created
expr_stmt|;
return|return
name|created
return|;
block|}
end_function

begin_comment
comment|/* If the assembler will construct the file table, then translate the compiler    internal file table number into the assembler file table number, and emit    a .file directive if we haven't already emitted one yet.  The file table    numbers are different because we prune debug info for unused variables and    types, which may include filenames.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_emit_file
parameter_list|(
name|struct
name|dwarf_file_data
modifier|*
name|fd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fd
operator|->
name|emitted_number
condition|)
block|{
if|if
condition|(
name|last_emitted_file
condition|)
name|fd
operator|->
name|emitted_number
operator|=
name|last_emitted_file
operator|->
name|emitted_number
operator|+
literal|1
expr_stmt|;
else|else
name|fd
operator|->
name|emitted_number
operator|=
literal|1
expr_stmt|;
name|last_emitted_file
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|DWARF2_ASM_LINE_DEBUG_INFO
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.file %u "
argument_list|,
name|fd
operator|->
name|emitted_number
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asm_out_file
argument_list|,
name|fd
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fd
operator|->
name|emitted_number
return|;
block|}
end_function

begin_comment
comment|/* Called by the final INSN scan whenever we see a var location.  We    use it to drop labels in the right places, and throw the location in    our lookup table.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_var_location
parameter_list|(
name|rtx
name|loc_note
parameter_list|)
block|{
name|char
name|loclabel
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|struct
name|var_loc_node
modifier|*
name|newloc
decl_stmt|;
name|rtx
name|prev_insn
decl_stmt|;
specifier|static
name|rtx
name|last_insn
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|last_label
decl_stmt|;
name|tree
name|decl
decl_stmt|;
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|NOTE_VAR_LOCATION_DECL
argument_list|(
name|loc_note
argument_list|)
argument_list|)
condition|)
return|return;
name|prev_insn
operator|=
name|PREV_INSN
argument_list|(
name|loc_note
argument_list|)
expr_stmt|;
name|newloc
operator|=
name|ggc_alloc_cleared
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|var_loc_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the insn we processed last time is the previous insn      and it is also a var location note, use the label we emitted      last time.  */
if|if
condition|(
name|last_insn
operator|!=
name|NULL_RTX
operator|&&
name|last_insn
operator|==
name|prev_insn
operator|&&
name|NOTE_P
argument_list|(
name|prev_insn
argument_list|)
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|prev_insn
argument_list|)
operator|==
name|NOTE_INSN_VAR_LOCATION
condition|)
block|{
name|newloc
operator|->
name|label
operator|=
name|last_label
expr_stmt|;
block|}
else|else
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|loclabel
argument_list|,
literal|"LVL"
argument_list|,
name|loclabel_num
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEBUG_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LVL"
argument_list|,
name|loclabel_num
argument_list|)
expr_stmt|;
name|loclabel_num
operator|++
expr_stmt|;
name|newloc
operator|->
name|label
operator|=
name|ggc_strdup
argument_list|(
name|loclabel
argument_list|)
expr_stmt|;
block|}
name|newloc
operator|->
name|var_loc_note
operator|=
name|loc_note
expr_stmt|;
name|newloc
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cfun
operator|&&
name|in_cold_section_p
condition|)
name|newloc
operator|->
name|section_label
operator|=
name|cfun
operator|->
name|cold_section_label
expr_stmt|;
else|else
name|newloc
operator|->
name|section_label
operator|=
name|text_section_label
expr_stmt|;
name|last_insn
operator|=
name|loc_note
expr_stmt|;
name|last_label
operator|=
name|newloc
operator|->
name|label
expr_stmt|;
name|decl
operator|=
name|NOTE_VAR_LOCATION_DECL
argument_list|(
name|loc_note
argument_list|)
expr_stmt|;
name|add_var_loc_to_decl
argument_list|(
name|decl
argument_list|,
name|newloc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We need to reset the locations at the beginning of each    function. We can't do this in the end_function hook, because the    declarations that use the locations won't have been output when    that hook is called.  Also compute have_multiple_function_sections here.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_begin_function
parameter_list|(
name|tree
name|fun
parameter_list|)
block|{
name|htab_empty
argument_list|(
name|decl_loc_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_section
argument_list|(
name|fun
argument_list|)
operator|!=
name|text_section
condition|)
name|have_multiple_function_sections
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a label to mark the beginning of a source code line entry    and record information relating to this source line, in    'line_info_table' for later output of the .debug_line section.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_source_line
parameter_list|(
name|unsigned
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
operator|&&
name|line
operator|!=
literal|0
condition|)
block|{
name|int
name|file_num
init|=
name|maybe_emit_file
argument_list|(
name|lookup_filename
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|switch_to_section
argument_list|(
name|current_function_section
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If requested, emit something human-readable.  */
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s:%d\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|DWARF2_ASM_LINE_DEBUG_INFO
condition|)
block|{
comment|/* Emit the .loc directive understood by GNU as.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.loc %d %d 0\n"
argument_list|,
name|file_num
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Indicate that line number info exists.  */
name|line_info_table_in_use
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|text_section
condition|)
block|{
name|dw_separate_line_info_ref
name|line_info
decl_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
name|SEPARATE_LINE_CODE_LABEL
argument_list|,
name|separate_line_info_table_in_use
argument_list|)
expr_stmt|;
comment|/* Expand the line info table if necessary.  */
if|if
condition|(
name|separate_line_info_table_in_use
operator|==
name|separate_line_info_table_allocated
condition|)
block|{
name|separate_line_info_table_allocated
operator|+=
name|LINE_INFO_TABLE_INCREMENT
expr_stmt|;
name|separate_line_info_table
operator|=
name|ggc_realloc
argument_list|(
name|separate_line_info_table
argument_list|,
name|separate_line_info_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_separate_line_info_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|separate_line_info_table
operator|+
name|separate_line_info_table_in_use
argument_list|,
literal|0
argument_list|,
operator|(
name|LINE_INFO_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_separate_line_info_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry at the end of the line_info_table.  */
name|line_info
operator|=
operator|&
name|separate_line_info_table
index|[
name|separate_line_info_table_in_use
operator|++
index|]
expr_stmt|;
name|line_info
operator|->
name|dw_file_num
operator|=
name|file_num
expr_stmt|;
name|line_info
operator|->
name|dw_line_num
operator|=
name|line
expr_stmt|;
name|line_info
operator|->
name|function
operator|=
name|current_function_funcdef_no
expr_stmt|;
block|}
else|else
block|{
name|dw_line_info_ref
name|line_info
decl_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_CODE_LABEL
argument_list|,
name|line_info_table_in_use
argument_list|)
expr_stmt|;
comment|/* Expand the line info table if necessary.  */
if|if
condition|(
name|line_info_table_in_use
operator|==
name|line_info_table_allocated
condition|)
block|{
name|line_info_table_allocated
operator|+=
name|LINE_INFO_TABLE_INCREMENT
expr_stmt|;
name|line_info_table
operator|=
name|ggc_realloc
argument_list|(
name|line_info_table
argument_list|,
operator|(
name|line_info_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_line_info_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|line_info_table
operator|+
name|line_info_table_in_use
argument_list|,
literal|0
argument_list|,
name|LINE_INFO_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_line_info_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry at the end of the line_info_table.  */
name|line_info
operator|=
operator|&
name|line_info_table
index|[
name|line_info_table_in_use
operator|++
index|]
expr_stmt|;
name|line_info
operator|->
name|dw_file_num
operator|=
name|file_num
expr_stmt|;
name|line_info
operator|->
name|dw_line_num
operator|=
name|line
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record the beginning of a new source file.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_start_source_file
parameter_list|(
name|unsigned
name|int
name|lineno
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|flag_eliminate_dwarf2_dups
condition|)
block|{
comment|/* Record the beginning of the file for break_out_includes.  */
name|dw_die_ref
name|bincl_die
decl_stmt|;
name|bincl_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_GNU_BINCL
argument_list|,
name|comp_unit_die
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_AT_string
argument_list|(
name|bincl_die
argument_list|,
name|DW_AT_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|int
name|file_num
init|=
name|maybe_emit_file
argument_list|(
name|lookup_filename
argument_list|(
name|filename
argument_list|)
argument_list|)
decl_stmt|;
name|switch_to_section
argument_list|(
name|debug_macinfo_section
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_MACINFO_start_file
argument_list|,
literal|"Start new file"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|lineno
argument_list|,
literal|"Included from line number %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|file_num
argument_list|,
literal|"file %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record the end of a source file.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_end_source_file
parameter_list|(
name|unsigned
name|int
name|lineno
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|flag_eliminate_dwarf2_dups
condition|)
comment|/* Record the end of the file for break_out_includes.  */
name|new_die
argument_list|(
name|DW_TAG_GNU_EINCL
argument_list|,
name|comp_unit_die
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|switch_to_section
argument_list|(
name|debug_macinfo_section
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_MACINFO_end_file
argument_list|,
literal|"End file"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from debug_define in toplev.c.  The `buffer' parameter contains    the tail part of the directive line, i.e. the part which is past the    initial whitespace, #, whitespace, directive-name, whitespace part.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_define
parameter_list|(
name|unsigned
name|int
name|lineno
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|switch_to_section
argument_list|(
name|debug_macinfo_section
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_MACINFO_define
argument_list|,
literal|"Define macro"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|lineno
argument_list|,
literal|"At line number %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|dw2_asm_output_nstring
argument_list|(
name|buffer
argument_list|,
operator|-
literal|1
argument_list|,
literal|"The macro"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from debug_undef in toplev.c.  The `buffer' parameter contains    the tail part of the directive line, i.e. the part which is past the    initial whitespace, #, whitespace, directive-name, whitespace part.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_undef
parameter_list|(
name|unsigned
name|int
name|lineno
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|switch_to_section
argument_list|(
name|debug_macinfo_section
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_MACINFO_undef
argument_list|,
literal|"Undefine macro"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|lineno
argument_list|,
literal|"At line number %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|dw2_asm_output_nstring
argument_list|(
name|buffer
argument_list|,
operator|-
literal|1
argument_list|,
literal|"The macro"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set up for Dwarf output at the start of compilation.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_init
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
comment|/* Allocate the file_table.  */
name|file_table
operator|=
name|htab_create_ggc
argument_list|(
literal|50
argument_list|,
name|file_table_hash
argument_list|,
name|file_table_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Allocate the decl_die_table.  */
name|decl_die_table
operator|=
name|htab_create_ggc
argument_list|(
literal|10
argument_list|,
name|decl_die_table_hash
argument_list|,
name|decl_die_table_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Allocate the decl_loc_table.  */
name|decl_loc_table
operator|=
name|htab_create_ggc
argument_list|(
literal|10
argument_list|,
name|decl_loc_table_hash
argument_list|,
name|decl_loc_table_eq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Allocate the initial hunk of the decl_scope_table.  */
name|decl_scope_table
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|256
argument_list|)
expr_stmt|;
comment|/* Allocate the initial hunk of the abbrev_die_table.  */
name|abbrev_die_table
operator|=
name|ggc_alloc_cleared
argument_list|(
name|ABBREV_DIE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|abbrev_die_table_allocated
operator|=
name|ABBREV_DIE_TABLE_INCREMENT
expr_stmt|;
comment|/* Zero-th entry is allocated, but unused.  */
name|abbrev_die_table_in_use
operator|=
literal|1
expr_stmt|;
comment|/* Allocate the initial hunk of the line_info_table.  */
name|line_info_table
operator|=
name|ggc_alloc_cleared
argument_list|(
name|LINE_INFO_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_line_info_entry
argument_list|)
argument_list|)
expr_stmt|;
name|line_info_table_allocated
operator|=
name|LINE_INFO_TABLE_INCREMENT
expr_stmt|;
comment|/* Zero-th entry is allocated, but unused.  */
name|line_info_table_in_use
operator|=
literal|1
expr_stmt|;
comment|/* Generate the initial DIE for the .debug section.  Note that the (string)      value given in the DW_AT_name attribute of the DW_TAG_compile_unit DIE      will (typically) be a relative pathname and that this pathname should be      taken as being relative to the directory from which the compiler was      invoked when the given (base) source file was compiled.  We will fill      in this value in dwarf2out_finish.  */
name|comp_unit_die
operator|=
name|gen_compile_unit_die
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|incomplete_types
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|used_rtx_array
operator|=
name|VEC_alloc
argument_list|(
name|rtx
argument_list|,
name|gc
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|debug_info_section
operator|=
name|get_section
argument_list|(
name|DEBUG_INFO_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug_abbrev_section
operator|=
name|get_section
argument_list|(
name|DEBUG_ABBREV_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug_aranges_section
operator|=
name|get_section
argument_list|(
name|DEBUG_ARANGES_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug_macinfo_section
operator|=
name|get_section
argument_list|(
name|DEBUG_MACINFO_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug_line_section
operator|=
name|get_section
argument_list|(
name|DEBUG_LINE_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug_loc_section
operator|=
name|get_section
argument_list|(
name|DEBUG_LOC_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug_pubnames_section
operator|=
name|get_section
argument_list|(
name|DEBUG_PUBNAMES_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug_str_section
operator|=
name|get_section
argument_list|(
name|DEBUG_STR_SECTION
argument_list|,
name|DEBUG_STR_SECTION_FLAGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug_ranges_section
operator|=
name|get_section
argument_list|(
name|DEBUG_RANGES_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|debug_frame_section
operator|=
name|get_section
argument_list|(
name|DEBUG_FRAME_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|text_end_label
argument_list|,
name|TEXT_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|abbrev_section_label
argument_list|,
name|DEBUG_ABBREV_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|text_section_label
argument_list|,
name|TEXT_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|cold_text_section_label
argument_list|,
name|COLD_TEXT_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|cold_end_label
argument_list|,
name|COLD_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|debug_info_section_label
argument_list|,
name|DEBUG_INFO_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|debug_line_section_label
argument_list|,
name|DEBUG_LINE_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ranges_section_label
argument_list|,
name|DEBUG_RANGES_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|debug_abbrev_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|abbrev_section_label
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|debug_info_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|debug_info_section_label
argument_list|)
expr_stmt|;
name|switch_to_section
argument_list|(
name|debug_line_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|debug_line_section_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|switch_to_section
argument_list|(
name|debug_macinfo_section
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|macinfo_section_label
argument_list|,
name|DEBUG_MACINFO_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|macinfo_section_label
argument_list|)
expr_stmt|;
block|}
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|text_section_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
block|{
name|switch_to_section
argument_list|(
name|unlikely_text_section
argument_list|()
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|cold_text_section_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A helper function for dwarf2out_finish called through    ht_forall.  Emit one queued .debug_str string.  */
end_comment

begin_function
specifier|static
name|int
name|output_indirect_string
parameter_list|(
name|void
modifier|*
modifier|*
name|h
parameter_list|,
name|void
modifier|*
name|v
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|indirect_string_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|indirect_string_node
operator|*
operator|)
operator|*
name|h
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|form
operator|==
name|DW_FORM_strp
condition|)
block|{
name|switch_to_section
argument_list|(
name|debug_str_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|node
operator|->
name|label
argument_list|)
expr_stmt|;
name|assemble_string
argument_list|(
name|node
operator|->
name|str
argument_list|,
name|strlen
argument_list|(
name|node
operator|->
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
name|ENABLE_ASSERT_CHECKING
end_if

begin_comment
comment|/* Verify that all marks are clear.  */
end_comment

begin_function
specifier|static
name|void
name|verify_marks_clear
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|die
operator|->
name|die_mark
argument_list|)
expr_stmt|;
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|verify_marks_clear
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ENABLE_ASSERT_CHECKING */
end_comment

begin_comment
comment|/* Clear the marks for a die and its children.    Be cool if the mark isn't set.  */
end_comment

begin_function
specifier|static
name|void
name|prune_unmark_dies
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|die_mark
condition|)
name|die
operator|->
name|die_mark
operator|=
literal|0
expr_stmt|;
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|prune_unmark_dies
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given DIE that we're marking as used, find any other dies    it references as attributes and mark them as used.  */
end_comment

begin_function
specifier|static
name|void
name|prune_unused_types_walk_attribs
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_attr_ref
name|a
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|==
name|dw_val_class_die_ref
condition|)
block|{
comment|/* A reference to another DIE. 	     Make sure that it will get emitted.  */
name|prune_unused_types_mark
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|.
name|die
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Set the string's refcount to 0 so that prune_unused_types_mark 	 accounts properly for it.  */
if|if
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_str
condition|)
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark DIE as being used.  If DOKIDS is true, then walk down    to DIE's children.  */
end_comment

begin_function
specifier|static
name|void
name|prune_unused_types_mark
parameter_list|(
name|dw_die_ref
name|die
parameter_list|,
name|int
name|dokids
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|die_mark
operator|==
literal|0
condition|)
block|{
comment|/* We haven't done this node yet.  Mark it as used.  */
name|die
operator|->
name|die_mark
operator|=
literal|1
expr_stmt|;
comment|/* We also have to mark its parents as used. 	 (But we don't want to mark our parents' kids due to this.)  */
if|if
condition|(
name|die
operator|->
name|die_parent
condition|)
name|prune_unused_types_mark
argument_list|(
name|die
operator|->
name|die_parent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mark any referenced nodes.  */
name|prune_unused_types_walk_attribs
argument_list|(
name|die
argument_list|)
expr_stmt|;
comment|/* If this node is a specification,          also mark the definition, if it exists.  */
if|if
condition|(
name|get_AT_flag
argument_list|(
name|die
argument_list|,
name|DW_AT_declaration
argument_list|)
operator|&&
name|die
operator|->
name|die_definition
condition|)
name|prune_unused_types_mark
argument_list|(
name|die
operator|->
name|die_definition
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dokids
operator|&&
name|die
operator|->
name|die_mark
operator|!=
literal|2
condition|)
block|{
comment|/* We need to walk the children, but haven't done so yet. 	 Remember that we've walked the kids.  */
name|die
operator|->
name|die_mark
operator|=
literal|2
expr_stmt|;
comment|/* If this is an array type, we need to make sure our 	 kids get marked, even if they're types.  */
if|if
condition|(
name|die
operator|->
name|die_tag
operator|==
name|DW_TAG_array_type
condition|)
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|prune_unused_types_mark
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|prune_unused_types_walk
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Walk the tree DIE and mark types that we actually use.  */
end_comment

begin_function
specifier|static
name|void
name|prune_unused_types_walk
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
comment|/* Don't do anything if this node is already marked.  */
if|if
condition|(
name|die
operator|->
name|die_mark
condition|)
return|return;
switch|switch
condition|(
name|die
operator|->
name|die_tag
condition|)
block|{
case|case
name|DW_TAG_const_type
case|:
case|case
name|DW_TAG_packed_type
case|:
case|case
name|DW_TAG_pointer_type
case|:
case|case
name|DW_TAG_reference_type
case|:
case|case
name|DW_TAG_volatile_type
case|:
case|case
name|DW_TAG_typedef
case|:
case|case
name|DW_TAG_array_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_union_type
case|:
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_friend
case|:
case|case
name|DW_TAG_variant_part
case|:
case|case
name|DW_TAG_enumeration_type
case|:
case|case
name|DW_TAG_subroutine_type
case|:
case|case
name|DW_TAG_string_type
case|:
case|case
name|DW_TAG_set_type
case|:
case|case
name|DW_TAG_subrange_type
case|:
case|case
name|DW_TAG_ptr_to_member_type
case|:
case|case
name|DW_TAG_file_type
case|:
if|if
condition|(
name|die
operator|->
name|die_perennial_p
condition|)
break|break;
comment|/* It's a type node --- don't mark it.  */
return|return;
default|default:
comment|/* Mark everything else.  */
break|break;
block|}
name|die
operator|->
name|die_mark
operator|=
literal|1
expr_stmt|;
comment|/* Now, mark any dies referenced from here.  */
name|prune_unused_types_walk_attribs
argument_list|(
name|die
argument_list|)
expr_stmt|;
comment|/* Mark children.  */
name|FOR_EACH_CHILD
argument_list|(
name|die
argument_list|,
name|c
argument_list|,
name|prune_unused_types_walk
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Increment the string counts on strings referred to from DIE's    attributes.  */
end_comment

begin_function
specifier|static
name|void
name|prune_unused_types_update_strings
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_attr_ref
name|a
decl_stmt|;
name|unsigned
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|dw_attr_node
argument_list|,
name|die
operator|->
name|die_attr
argument_list|,
name|ix
argument_list|,
name|a
argument_list|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_str
condition|)
block|{
name|struct
name|indirect_string_node
modifier|*
name|s
init|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
decl_stmt|;
name|s
operator|->
name|refcount
operator|++
expr_stmt|;
comment|/* Avoid unnecessarily putting strings that are used less than 	   twice in the hash table.  */
if|if
condition|(
name|s
operator|->
name|refcount
operator|==
operator|(
operator|(
name|DEBUG_STR_SECTION_FLAGS
operator|&
name|SECTION_MERGE
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
condition|)
block|{
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|htab_find_slot_with_hash
argument_list|(
name|debug_str_hash
argument_list|,
name|s
operator|->
name|str
argument_list|,
name|htab_hash_string
argument_list|(
name|s
operator|->
name|str
argument_list|)
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|*
name|slot
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Remove from the tree DIE any dies that aren't marked.  */
end_comment

begin_function
specifier|static
name|void
name|prune_unused_types_prune
parameter_list|(
name|dw_die_ref
name|die
parameter_list|)
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|gcc_assert
argument_list|(
name|die
operator|->
name|die_mark
argument_list|)
expr_stmt|;
name|prune_unused_types_update_strings
argument_list|(
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|die
operator|->
name|die_child
condition|)
return|return;
name|c
operator|=
name|die
operator|->
name|die_child
expr_stmt|;
do|do
block|{
name|dw_die_ref
name|prev
init|=
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|c
operator|->
name|die_sib
init|;
operator|!
name|c
operator|->
name|die_mark
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
if|if
condition|(
name|c
operator|==
name|die
operator|->
name|die_child
condition|)
block|{
comment|/* No marked children between 'prev' and the end of the list.  */
if|if
condition|(
name|prev
operator|==
name|c
condition|)
comment|/* No marked children at all.  */
name|die
operator|->
name|die_child
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|prev
operator|->
name|die_sib
operator|=
name|c
operator|->
name|die_sib
expr_stmt|;
name|die
operator|->
name|die_child
operator|=
name|prev
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|c
operator|!=
name|prev
operator|->
name|die_sib
condition|)
name|prev
operator|->
name|die_sib
operator|=
name|c
expr_stmt|;
name|prune_unused_types_prune
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
name|die
operator|->
name|die_child
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Remove dies representing declarations that we never use.  */
end_comment

begin_function
specifier|static
name|void
name|prune_unused_types
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|limbo_die_node
modifier|*
name|node
decl_stmt|;
if|#
directive|if
name|ENABLE_ASSERT_CHECKING
comment|/* All the marks should already be clear.  */
name|verify_marks_clear
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|verify_marks_clear
argument_list|(
name|node
operator|->
name|die
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ENABLE_ASSERT_CHECKING */
comment|/* Set the mark on nodes that are actually used.  */
name|prune_unused_types_walk
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|prune_unused_types_walk
argument_list|(
name|node
operator|->
name|die
argument_list|)
expr_stmt|;
comment|/* Also set the mark on nodes referenced from the      pubname_table or arange_table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pubname_table_in_use
condition|;
name|i
operator|++
control|)
name|prune_unused_types_mark
argument_list|(
name|pubname_table
index|[
name|i
index|]
operator|.
name|die
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arange_table_in_use
condition|;
name|i
operator|++
control|)
name|prune_unused_types_mark
argument_list|(
name|arange_table
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Get rid of nodes that aren't marked; and update the string counts.  */
if|if
condition|(
name|debug_str_hash
condition|)
name|htab_empty
argument_list|(
name|debug_str_hash
argument_list|)
expr_stmt|;
name|prune_unused_types_prune
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|prune_unused_types_prune
argument_list|(
name|node
operator|->
name|die
argument_list|)
expr_stmt|;
comment|/* Leave the marks clear.  */
name|prune_unmark_dies
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|prune_unmark_dies
argument_list|(
name|node
operator|->
name|die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the parameter to true if there are any relative pathnames in    the file table.  */
end_comment

begin_function
specifier|static
name|int
name|file_table_relative_p
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|param
parameter_list|)
block|{
name|bool
modifier|*
name|p
init|=
name|param
decl_stmt|;
name|struct
name|dwarf_file_data
modifier|*
name|d
init|=
operator|*
name|slot
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|emitted_number
operator|&&
name|d
operator|->
name|filename
index|[
literal|0
index|]
operator|!=
name|DIR_SEPARATOR
condition|)
block|{
operator|*
name|p
operator|=
name|true
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Output stuff that dwarf requires at the end of every file,    and generate the DWARF-2 debugging info.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_finish
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|limbo_die_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|next_node
decl_stmt|;
name|dw_die_ref
name|die
init|=
literal|0
decl_stmt|;
comment|/* Add the name for the main input file now.  We delayed this from      dwarf2out_init to avoid complications with PCH.  */
name|add_name_attribute
argument_list|(
name|comp_unit_die
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
name|DIR_SEPARATOR
condition|)
name|add_comp_dir_attribute
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|get_AT
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_comp_dir
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bool
name|p
init|=
name|false
decl_stmt|;
name|htab_traverse
argument_list|(
name|file_table
argument_list|,
name|file_table_relative_p
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|add_comp_dir_attribute
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
block|}
comment|/* Traverse the limbo die list, and add parent/child links.  The only      dies without parents that should be here are concrete instances of      inline functions, and the comp_unit_die.  We can ignore the comp_unit_die.      For concrete instances, we can get the parent die from the abstract      instance.  */
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|next_node
control|)
block|{
name|next_node
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|die
operator|=
name|node
operator|->
name|die
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
block|{
name|dw_die_ref
name|origin
init|=
name|get_AT_ref
argument_list|(
name|die
argument_list|,
name|DW_AT_abstract_origin
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin
condition|)
name|add_child_die
argument_list|(
name|origin
operator|->
name|die_parent
argument_list|,
name|die
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|die
operator|==
name|comp_unit_die
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|errorcount
operator|>
literal|0
operator|||
name|sorrycount
operator|>
literal|0
condition|)
comment|/* It's OK to be confused by errors in the input.  */
name|add_child_die
argument_list|(
name|comp_unit_die
argument_list|,
name|die
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* In certain situations, the lexical block containing a 		 nested function can be optimized away, which results 		 in the nested function die being orphaned.  Likewise 		 with the return type of that nested function.  Force 		 this to be a child of the containing function.  		 It may happen that even the containing function got fully 		 inlined and optimized out.  In that case we are lost and 		 assign the empty child.  This should not be big issue as 		 the function is likely unreachable too.  */
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
name|gcc_assert
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
condition|)
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|context
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|)
argument_list|)
expr_stmt|;
name|origin
operator|=
name|lookup_decl_die
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
condition|)
name|add_child_die
argument_list|(
name|origin
argument_list|,
name|die
argument_list|)
expr_stmt|;
else|else
name|add_child_die
argument_list|(
name|comp_unit_die
argument_list|,
name|die
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|limbo_die_list
operator|=
name|NULL
expr_stmt|;
comment|/* Walk through the list of incomplete types again, trying once more to      emit full debugging info for them.  */
name|retry_incomplete_types
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_eliminate_unused_debug_types
condition|)
name|prune_unused_types
argument_list|()
expr_stmt|;
comment|/* Generate separate CUs for each of the include files we've seen.      They will go into limbo_die_list.  */
if|if
condition|(
name|flag_eliminate_dwarf2_dups
condition|)
name|break_out_includes
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
comment|/* Traverse the DIE's and add add sibling attributes to those DIE's      that have children.  */
name|add_sibling_attributes
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|add_sibling_attributes
argument_list|(
name|node
operator|->
name|die
argument_list|)
expr_stmt|;
comment|/* Output a terminator label for the .text section.  */
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
block|{
name|switch_to_section
argument_list|(
name|unlikely_text_section
argument_list|()
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
name|COLD_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We can only use the low/high_pc attributes if all of the code was      in .text.  */
if|if
condition|(
operator|!
name|have_multiple_function_sections
condition|)
block|{
name|add_AT_lbl_id
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|text_section_label
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|text_end_label
argument_list|)
expr_stmt|;
block|}
comment|/* If it wasn't, we need to give .debug_loc and .debug_ranges an appropriate      "base address".  Use zero so that these addresses become absolute.  */
elseif|else
if|if
condition|(
name|have_location_lists
operator|||
name|ranges_table_in_use
condition|)
name|add_AT_addr
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_entry_pc
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
comment|/* Output location list section if necessary.  */
if|if
condition|(
name|have_location_lists
condition|)
block|{
comment|/* Output the location lists info.  */
name|switch_to_section
argument_list|(
name|debug_loc_section
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|loc_section_label
argument_list|,
name|DEBUG_LOC_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|loc_section_label
argument_list|)
expr_stmt|;
name|output_location_lists
argument_list|(
name|die
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
name|add_AT_lineptr
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_stmt_list
argument_list|,
name|debug_line_section_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
name|add_AT_macptr
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_macro_info
argument_list|,
name|macinfo_section_label
argument_list|)
expr_stmt|;
comment|/* Output all of the compilation units.  We put the main one last so that      the offsets are available to output_pubnames.  */
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|output_comp_unit
argument_list|(
name|node
operator|->
name|die
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|output_comp_unit
argument_list|(
name|comp_unit_die
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output the abbreviation table.  */
name|switch_to_section
argument_list|(
name|debug_abbrev_section
argument_list|)
expr_stmt|;
name|output_abbrev_section
argument_list|()
expr_stmt|;
comment|/* Output public names table if necessary.  */
if|if
condition|(
name|pubname_table_in_use
condition|)
block|{
name|switch_to_section
argument_list|(
name|debug_pubnames_section
argument_list|)
expr_stmt|;
name|output_pubnames
argument_list|()
expr_stmt|;
block|}
comment|/* Output the address range information.  We only put functions in the arange      table, so don't write it out if we don't have any.  */
if|if
condition|(
name|fde_table_in_use
condition|)
block|{
name|switch_to_section
argument_list|(
name|debug_aranges_section
argument_list|)
expr_stmt|;
name|output_aranges
argument_list|()
expr_stmt|;
block|}
comment|/* Output ranges section if necessary.  */
if|if
condition|(
name|ranges_table_in_use
condition|)
block|{
name|switch_to_section
argument_list|(
name|debug_ranges_section
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|ranges_section_label
argument_list|)
expr_stmt|;
name|output_ranges
argument_list|()
expr_stmt|;
block|}
comment|/* Output the source line correspondence table.  We must do this      even if there is no line information.  Otherwise, on an empty      translation unit, we will generate a present, but empty,      .debug_info section.  IRIX 6.5 `nm' will then complain when      examining the file.  This is done late so that any filenames      used by the debug_info section are marked as 'used'.  */
if|if
condition|(
operator|!
name|DWARF2_ASM_LINE_DEBUG_INFO
condition|)
block|{
name|switch_to_section
argument_list|(
name|debug_line_section
argument_list|)
expr_stmt|;
name|output_line_info
argument_list|()
expr_stmt|;
block|}
comment|/* Have to end the macro section.  */
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|switch_to_section
argument_list|(
name|debug_macinfo_section
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"End compilation unit"
argument_list|)
expr_stmt|;
block|}
comment|/* If we emitted any DW_FORM_strp form attribute, output the string      table too.  */
if|if
condition|(
name|debug_str_hash
condition|)
name|htab_traverse
argument_list|(
name|debug_str_hash
argument_list|,
name|output_indirect_string
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* This should never be used, but its address is needed for comparisons.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|gcc_debug_hooks
name|dwarf2_debug_hooks
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DWARF2_DEBUGGING_INFO */
end_comment

begin_include
include|#
directive|include
file|"gt-dwarf2out.h"
end_include

end_unit

