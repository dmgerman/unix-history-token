begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output Dwarf2 format symbol table information from the GNU C compiler.    Copyright (C) 1992, 93, 95-98, 1999 Free Software Foundation, Inc.    Contributed by Gary Funck (gary@intrepid.com).    Derived from DWARF 1 implementation of Ron Guilmette (rfg@monkeys.com).    Extensively modified by Jason Merrill (jason@cygnus.com).  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* The first part of this file deals with the DWARF 2 frame unwind    information, which is also used by the GCC efficient exception handling    mechanism.  The second part, controlled only by an #ifdef    DWARF2_DEBUGGING_INFO, deals with the other DWARF 2 debugging    information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"dyn-string.h"
end_include

begin_comment
comment|/* We cannot use<assert.h> in GCC source, since that would include    GCC's assert.h, which may not be compatible with the host compiler.  */
end_comment

begin_undef
undef|#
directive|undef
name|assert
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|NDEBUG
end_ifdef

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|e
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|e
parameter_list|)
value|do { if (! (e)) abort (); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Decide whether we want to emit frame unwind information for the current    translation unit.  */
end_comment

begin_function
name|int
name|dwarf2out_do_frame
parameter_list|()
block|{
return|return
operator|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
ifdef|#
directive|ifdef
name|DWARF2_FRAME_INFO
operator|||
name|DWARF2_FRAME_INFO
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|exceptions_via_longjmp
operator|)
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
end_if

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|dw_cfi_struct
modifier|*
name|dw_cfi_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_fde_struct
modifier|*
name|dw_fde_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|union
name|dw_cfi_oprnd_struct
modifier|*
name|dw_cfi_oprnd_ref
typedef|;
end_typedef

begin_comment
comment|/* Call frames are described using a sequence of Call Frame    Information instructions.  The register number, offset    and address fields are provided as possible operands;    their use is selected by the opcode field.  */
end_comment

begin_typedef
typedef|typedef
union|union
name|dw_cfi_oprnd_struct
block|{
name|unsigned
name|long
name|dw_cfi_reg_num
decl_stmt|;
name|long
name|int
name|dw_cfi_offset
decl_stmt|;
name|char
modifier|*
name|dw_cfi_addr
decl_stmt|;
block|}
name|dw_cfi_oprnd
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|dw_cfi_struct
block|{
name|dw_cfi_ref
name|dw_cfi_next
decl_stmt|;
name|enum
name|dwarf_call_frame_info
name|dw_cfi_opc
decl_stmt|;
name|dw_cfi_oprnd
name|dw_cfi_oprnd1
decl_stmt|;
name|dw_cfi_oprnd
name|dw_cfi_oprnd2
decl_stmt|;
block|}
name|dw_cfi_node
typedef|;
end_typedef

begin_comment
comment|/* All call frame descriptions (FDE's) in the GCC generated DWARF    refer to a single Common Information Entry (CIE), defined at    the beginning of the .debug_frame section.  This used of a single    CIE obviates the need to keep track of multiple CIE's    in the DWARF generation routines below.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_fde_struct
block|{
name|char
modifier|*
name|dw_fde_begin
decl_stmt|;
name|char
modifier|*
name|dw_fde_current_label
decl_stmt|;
name|char
modifier|*
name|dw_fde_end
decl_stmt|;
name|dw_cfi_ref
name|dw_fde_cfi
decl_stmt|;
block|}
name|dw_fde_node
typedef|;
end_typedef

begin_comment
comment|/* Maximum size (in bytes) of an artificially generated label.   */
end_comment

begin_define
define|#
directive|define
name|MAX_ARTIFICIAL_LABEL_BYTES
value|30
end_define

begin_comment
comment|/* Make sure we know the sizes of the various types dwarf can describe. These    are only defaults.  If the sizes are different for your target, you should    override these values by defining the appropriate symbols in your tm.h    file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTR_SIZE
end_ifndef

begin_define
define|#
directive|define
name|PTR_SIZE
value|(POINTER_SIZE / BITS_PER_UNIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The size in bytes of a DWARF field indicating an offset or length    relative to a debug info section, specified to be 4 bytes in the DWARF-2    specification.  The SGI/MIPS ABI defines it to be the same as PTR_SIZE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_OFFSET_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DWARF_OFFSET_SIZE
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DWARF_VERSION
value|2
end_define

begin_comment
comment|/* Round SIZE up to the nearest BOUNDARY.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_ROUND
parameter_list|(
name|SIZE
parameter_list|,
name|BOUNDARY
parameter_list|)
define|\
value|(((SIZE) + (BOUNDARY) - 1)& ~((BOUNDARY) - 1))
end_define

begin_comment
comment|/* Offsets recorded in opcodes are a multiple of this alignment factor.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|DWARF_CIE_DATA_ALIGNMENT
value|(-UNITS_PER_WORD)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DWARF_CIE_DATA_ALIGNMENT
value|UNITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A pointer to the base of a table that contains frame description    information for each routine.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_fde_ref
name|fde_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for fde_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|fde_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in fde_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|fde_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    fde_table.  */
end_comment

begin_define
define|#
directive|define
name|FDE_TABLE_INCREMENT
value|256
end_define

begin_comment
comment|/* A list of call frame insns for the CIE.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_cfi_ref
name|cie_cfi_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of the current function definition for which debugging    information is being generated.  These numbers range from 1 up to the    maximum number of function definitions contained within the current    compilation unit.  These numbers are used to create unique label id's    unique to each function definition.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|current_funcdef_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some DWARF extensions (e.g., MIPS/SGI) implement a subprogram    attribute that accelerates the lookup of the FDE associated    with the subprogram.  This variable holds the table index of the FDE     associated with the current function (body) definition.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|current_funcdef_fde
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations for functions defined in this file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stripattributes
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_cfi_name
name|PROTO
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_cfi_ref
name|new_cfi
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_cfi
name|PROTO
argument_list|(
operator|(
name|dw_cfi_ref
operator|*
operator|,
name|dw_cfi_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_uleb128
name|PROTO
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_sleb128
name|PROTO
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_uleb128
name|PROTO
argument_list|(
operator|(
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_sleb128
name|PROTO
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_fde_cfi
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|dw_cfi_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lookup_cfa_1
name|PROTO
argument_list|(
operator|(
name|dw_cfi_ref
operator|,
name|unsigned
name|long
operator|*
operator|,
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lookup_cfa
name|PROTO
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|,
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_save
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initial_return_save
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_cfi
name|PROTO
argument_list|(
operator|(
name|dw_cfi_ref
operator|,
name|dw_fde_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_call_frame_info
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|reg_number
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_stack_adjust
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Definitions of defaults for assembler-dependent names of various    pseudo-ops and section names.    Theses may be overridden in the tm.h file (if necessary) for a particular    assembler.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJECT_FORMAT_ELF
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|UNALIGNED_SHORT_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|UNALIGNED_SHORT_ASM_OP
value|".2byte"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UNALIGNED_INT_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|UNALIGNED_INT_ASM_OP
value|".4byte"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UNALIGNED_DOUBLE_INT_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|UNALIGNED_DOUBLE_INT_ASM_OP
value|".8byte"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJECT_FORMAT_ELF */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_BYTE_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_BYTE_OP
value|".byte"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Data and reference forms for relocatable data.  */
end_comment

begin_define
define|#
directive|define
name|DW_FORM_data
value|(DWARF_OFFSET_SIZE == 8 ? DW_FORM_data8 : DW_FORM_data4)
end_define

begin_define
define|#
directive|define
name|DW_FORM_ref
value|(DWARF_OFFSET_SIZE == 8 ? DW_FORM_ref8 : DW_FORM_ref4)
end_define

begin_comment
comment|/* Pseudo-op for defining a new section.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SECTION_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|SECTION_ASM_OP
value|".section"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The default format used by the ASM_OUTPUT_SECTION macro (see below) to    print the SECTION_ASM_OP and the section name.  The default here works for    almost all svr4 assemblers, except for the sparc, where the section name    must be enclosed in double quotes.  (See sparcv4.h).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SECTION_FORMAT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PUSHSECTION_FORMAT
end_ifdef

begin_define
define|#
directive|define
name|SECTION_FORMAT
value|PUSHSECTION_FORMAT
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SECTION_FORMAT
value|"\t%s\t%s\n"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FRAME_SECTION
end_ifndef

begin_define
define|#
directive|define
name|FRAME_SECTION
value|".debug_frame"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FUNC_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|FUNC_BEGIN_LABEL
value|"LFB"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FUNC_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|FUNC_END_LABEL
value|"LFE"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CIE_AFTER_SIZE_LABEL
value|"LSCIE"
end_define

begin_define
define|#
directive|define
name|CIE_END_LABEL
value|"LECIE"
end_define

begin_define
define|#
directive|define
name|CIE_LENGTH_LABEL
value|"LLCIE"
end_define

begin_define
define|#
directive|define
name|FDE_AFTER_SIZE_LABEL
value|"LSFDE"
end_define

begin_define
define|#
directive|define
name|FDE_END_LABEL
value|"LEFDE"
end_define

begin_define
define|#
directive|define
name|FDE_LENGTH_LABEL
value|"LLFDE"
end_define

begin_comment
comment|/* Definitions of defaults for various types of primitive assembly language    output operations.  These may be overridden from within the tm.h file,    but typically, that is unnecessary.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_SECTION
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_SECTION
parameter_list|(
name|FILE
parameter_list|,
name|SECTION
parameter_list|)
define|\
value|fprintf ((FILE), SECTION_FORMAT, SECTION_ASM_OP, SECTION)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA1
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA1
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%x", ASM_BYTE_OP, (unsigned) (VALUE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DELTA1
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DELTA1
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", ASM_BYTE_OP);			\ 	assemble_name (FILE, LABEL1);					\ 	fprintf (FILE, "-");						\ 	assemble_name (FILE, LABEL2);					\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNALIGNED_INT_ASM_OP
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|UNALIGNED_OFFSET_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|UNALIGNED_OFFSET_ASM_OP
define|\
value|(DWARF_OFFSET_SIZE == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP : UNALIGNED_INT_ASM_OP)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UNALIGNED_WORD_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|UNALIGNED_WORD_ASM_OP
define|\
value|(PTR_SIZE == 8 ? UNALIGNED_DOUBLE_INT_ASM_OP : UNALIGNED_INT_ASM_OP)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DELTA2
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DELTA2
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", UNALIGNED_SHORT_ASM_OP);		\ 	assemble_name (FILE, LABEL1);					\ 	fprintf (FILE, "-");						\ 	assemble_name (FILE, LABEL2);					\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DELTA4
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DELTA4
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", UNALIGNED_INT_ASM_OP);		\ 	assemble_name (FILE, LABEL1);					\ 	fprintf (FILE, "-");						\ 	assemble_name (FILE, LABEL2);					\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DELTA
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DELTA
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", UNALIGNED_OFFSET_ASM_OP);		\ 	assemble_name (FILE, LABEL1);					\ 	fprintf (FILE, "-");						\ 	assemble_name (FILE, LABEL2);					\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_ADDR_DELTA
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ADDR_DELTA
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", UNALIGNED_WORD_ASM_OP);		\ 	assemble_name (FILE, LABEL1);					\ 	fprintf (FILE, "-");						\ 	assemble_name (FILE, LABEL2);					\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_ADDR
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ADDR
parameter_list|(
name|FILE
parameter_list|,
name|LABEL
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", UNALIGNED_WORD_ASM_OP);		\ 	assemble_name (FILE, LABEL);					\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ??? This macro takes an RTX in dwarfout.c and a string in dwarf2out.c.    We resolve the conflict by creating a new macro ASM_OUTPUT_DWARF2_ADDR_CONST    for ports that want to support both DWARF1 and DWARF2.  This needs a better    solution.  See also the comments in sparc/sp64-elf.h.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DWARF2_ADDR_CONST
end_ifdef

begin_undef
undef|#
directive|undef
name|ASM_OUTPUT_DWARF_ADDR_CONST
end_undef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ADDR_CONST
parameter_list|(
name|FILE
parameter_list|,
name|ADDR
parameter_list|)
define|\
value|ASM_OUTPUT_DWARF2_ADDR_CONST (FILE, ADDR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_ADDR_CONST
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ADDR_CONST
parameter_list|(
name|FILE
parameter_list|,
name|ADDR
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t%s", UNALIGNED_WORD_ASM_OP, (ADDR))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_OFFSET4
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_OFFSET4
parameter_list|(
name|FILE
parameter_list|,
name|LABEL
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", UNALIGNED_INT_ASM_OP);		\ 	assemble_name (FILE, LABEL);					\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_OFFSET
parameter_list|(
name|FILE
parameter_list|,
name|LABEL
parameter_list|)
define|\
value|do {	fprintf ((FILE), "\t%s\t", UNALIGNED_OFFSET_ASM_OP);		\ 	assemble_name (FILE, LABEL);					\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA2
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA2
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%x", UNALIGNED_SHORT_ASM_OP, (unsigned) (VALUE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA4
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA4
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%x", UNALIGNED_INT_ASM_OP, (unsigned) (VALUE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%lx", UNALIGNED_OFFSET_ASM_OP, \ 	   (unsigned long) (VALUE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_ADDR_DATA
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ADDR_DATA
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|fprintf ((FILE), "\t%s\t0x%lx", UNALIGNED_WORD_ASM_OP, \ 	   (unsigned long) (VALUE))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_DATA8
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA8
parameter_list|(
name|FILE
parameter_list|,
name|HIGH_VALUE
parameter_list|,
name|LOW_VALUE
parameter_list|)
define|\
value|do {									\     if (WORDS_BIG_ENDIAN)						\       {									\ 	fprintf ((FILE), "\t%s\t0x%lx\n", UNALIGNED_INT_ASM_OP, (HIGH_VALUE));\ 	fprintf ((FILE), "\t%s\t0x%lx", UNALIGNED_INT_ASM_OP, (LOW_VALUE));\       }									\     else								\       {									\ 	fprintf ((FILE), "\t%s\t0x%lx\n", UNALIGNED_INT_ASM_OP, (LOW_VALUE)); \ 	fprintf ((FILE), "\t%s\t0x%lx", UNALIGNED_INT_ASM_OP, (HIGH_VALUE)); \       }									\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* UNALIGNED_INT_ASM_OP */
end_comment

begin_comment
comment|/* We don't have unaligned support, let's hope the normal output works for    .debug_frame.  */
end_comment

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ADDR
parameter_list|(
name|FILE
parameter_list|,
name|LABEL
parameter_list|)
define|\
value|assemble_integer (gen_rtx_SYMBOL_REF (Pmode, LABEL), PTR_SIZE, 1)
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_OFFSET4
parameter_list|(
name|FILE
parameter_list|,
name|LABEL
parameter_list|)
define|\
value|assemble_integer (gen_rtx_SYMBOL_REF (SImode, LABEL), 4, 1)
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_OFFSET
parameter_list|(
name|FILE
parameter_list|,
name|LABEL
parameter_list|)
define|\
value|assemble_integer (gen_rtx_SYMBOL_REF (SImode, LABEL), 4, 1)
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DELTA2
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|assemble_integer (gen_rtx_MINUS (HImode,			      	\ 			     gen_rtx_SYMBOL_REF (Pmode, LABEL1),   	\ 			     gen_rtx_SYMBOL_REF (Pmode, LABEL2)),	\ 		    2, 1)
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DELTA4
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|assemble_integer (gen_rtx_MINUS (SImode,			      	\ 			     gen_rtx_SYMBOL_REF (Pmode, LABEL1),   	\ 			     gen_rtx_SYMBOL_REF (Pmode, LABEL2)),	\ 		    4, 1)
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_ADDR_DELTA
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|assemble_integer (gen_rtx_MINUS (Pmode,				\ 			     gen_rtx_SYMBOL_REF (Pmode, LABEL1),	\ 			     gen_rtx_SYMBOL_REF (Pmode, LABEL2)),	\ 		    PTR_SIZE, 1)
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DELTA
parameter_list|(
name|FILE
parameter_list|,
name|LABEL1
parameter_list|,
name|LABEL2
parameter_list|)
define|\
value|ASM_OUTPUT_DWARF_DELTA4 (FILE,LABEL1,LABEL2)
end_define

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_DATA4
parameter_list|(
name|FILE
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|assemble_integer (GEN_INT (VALUE), 4, 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNALIGNED_INT_ASM_OP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SET_ASM_OP
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL
parameter_list|(
name|FILE
parameter_list|,
name|SY
parameter_list|,
name|HI
parameter_list|,
name|LO
parameter_list|)
define|\
value|do {									\   fprintf (FILE, "\t%s\t", SET_ASM_OP);					\   assemble_name (FILE, SY);						\   fputc (',', FILE);							\   assemble_name (FILE, HI);						\   fputc ('-', FILE);							\   assemble_name (FILE, LO);						\  } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SET_ASM_OP */
end_comment

begin_comment
comment|/* This is similar to the default ASM_OUTPUT_ASCII, except that no trailing    newline is produced.  When flag_debug_asm is asserted, we add commentary    at the end of the line, so we must avoid output of a newline here.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DWARF_STRING
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DWARF_STRING
parameter_list|(
name|FILE
parameter_list|,
name|P
parameter_list|)
define|\
value|do {									      \     register int slen = strlen(P);                                            \     register char *p = (P);  	                                              \     register int i;					                      \     fprintf (FILE, "\t.ascii \"");				              \     for (i = 0; i< slen; i++)					              \       {								              \ 	  register int c = p[i];					      \ 	  if (c == '\"' || c == '\\')					      \ 	    putc ('\\', FILE);					              \ 	  if (c>= ' '&& c< 0177)					      \ 	    putc (c, FILE);					              \ 	  else								      \ 	    {								      \ 	      fprintf (FILE, "\\%o", c);			              \ 	    }							 	      \       }								              \     fprintf (FILE, "\\0\"");					              \   }									      \   while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The DWARF 2 CFA column which tracks the return address.  Normally this    is the column for PC, or the first column after all of the hard    registers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_FRAME_RETURN_COLUMN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PC_REGNUM
end_ifdef

begin_define
define|#
directive|define
name|DWARF_FRAME_RETURN_COLUMN
value|DWARF_FRAME_REGNUM (PC_REGNUM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DWARF_FRAME_RETURN_COLUMN
value|FIRST_PSEUDO_REGISTER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The mapping from gcc register number to DWARF 2 CFA column number.  By    default, we just provide columns for all registers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_FRAME_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|DWARF_FRAME_REGNUM
parameter_list|(
name|REG
parameter_list|)
value|DBX_REGISTER_NUMBER (REG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hook used by __throw.  */
end_comment

begin_function
name|rtx
name|expand_builtin_dwarf_fp_regnum
parameter_list|()
block|{
return|return
name|GEN_INT
argument_list|(
name|DWARF_FRAME_REGNUM
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The offset from the incoming value of %sp to the top of the stack frame    for the current function.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INCOMING_FRAME_SP_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|INCOMING_FRAME_SP_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a pointer to a copy of the section string name S with all    attributes stripped off, and an asterisk prepended (for assemble_name).  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|stripattributes
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|stripped
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|stripped
decl_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'*'
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|','
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|stripped
return|;
block|}
end_function

begin_comment
comment|/* Return the register number described by a given RTL node.  */
end_comment

begin_function
specifier|static
name|unsigned
name|reg_number
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
specifier|register
name|unsigned
name|regno
init|=
name|REGNO
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|warning
argument_list|(
literal|"internal regno botch: regno = %d\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|regno
operator|=
literal|0
expr_stmt|;
block|}
name|regno
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return
name|regno
return|;
block|}
end_function

begin_struct
struct|struct
name|reg_size_range
block|{
name|int
name|beg
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Given a register number in REG_TREE, return an rtx for its size in bytes.    We do this in kind of a roundabout way, by building up a list of    register size ranges and seeing where our register falls in one of those    ranges.  We need to do it this way because REG_TREE is not a constant,    and the target macros were not designed to make this task easy.  */
end_comment

begin_function
name|rtx
name|expand_builtin_dwarf_reg_size
parameter_list|(
name|reg_tree
parameter_list|,
name|target
parameter_list|)
name|tree
name|reg_tree
decl_stmt|;
name|rtx
name|target
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|reg_size_range
name|ranges
index|[
literal|5
index|]
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|n_ranges
init|=
literal|0
decl_stmt|;
name|int
name|last_size
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
block|{
comment|/* The return address is out of order on the MIPS, and we don't use 	 copy_reg for it anyway, so we don't care here how large it is.  */
if|if
condition|(
name|DWARF_FRAME_REGNUM
argument_list|(
name|i
argument_list|)
operator|==
name|DWARF_FRAME_RETURN_COLUMN
condition|)
continue|continue;
name|mode
operator|=
name|reg_raw_mode
index|[
name|i
index|]
expr_stmt|;
comment|/* CCmode is arbitrarily given a size of 4 bytes.  It is more useful 	 to use the same size as word_mode, since that reduces the number 	 of ranges we need.  It should not matter, since the result should 	 never be used for a condition code register anyways.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_CC
condition|)
name|mode
operator|=
name|word_mode
expr_stmt|;
name|size
operator|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* If this register is not valid in the specified mode and 	 we have a previous size, use that for the size of this 	 register to avoid making junk tiny ranges.  */
if|if
condition|(
operator|!
name|HARD_REGNO_MODE_OK
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|&&
name|last_size
operator|!=
operator|-
literal|1
condition|)
name|size
operator|=
name|last_size
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|last_size
condition|)
block|{
name|ranges
index|[
name|n_ranges
index|]
operator|.
name|beg
operator|=
name|i
expr_stmt|;
name|ranges
index|[
name|n_ranges
index|]
operator|.
name|size
operator|=
name|last_size
operator|=
name|size
expr_stmt|;
operator|++
name|n_ranges
expr_stmt|;
if|if
condition|(
name|n_ranges
operator|>=
literal|5
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|ranges
index|[
name|n_ranges
operator|-
literal|1
index|]
operator|.
name|end
operator|=
name|i
expr_stmt|;
block|}
comment|/* The usual case: fp regs surrounded by general regs.  */
if|if
condition|(
name|n_ranges
operator|==
literal|3
operator|&&
name|ranges
index|[
literal|0
index|]
operator|.
name|size
operator|==
name|ranges
index|[
literal|2
index|]
operator|.
name|size
condition|)
block|{
if|if
condition|(
operator|(
name|DWARF_FRAME_REGNUM
argument_list|(
name|ranges
index|[
literal|1
index|]
operator|.
name|end
argument_list|)
operator|-
name|DWARF_FRAME_REGNUM
argument_list|(
name|ranges
index|[
literal|1
index|]
operator|.
name|beg
argument_list|)
operator|)
operator|!=
name|ranges
index|[
literal|1
index|]
operator|.
name|end
operator|-
name|ranges
index|[
literal|1
index|]
operator|.
name|beg
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|GE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|reg_tree
argument_list|,
name|build_int_2
argument_list|(
name|DWARF_FRAME_REGNUM
argument_list|(
name|ranges
index|[
literal|1
index|]
operator|.
name|beg
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t2
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|reg_tree
argument_list|,
name|build_int_2
argument_list|(
name|DWARF_FRAME_REGNUM
argument_list|(
name|ranges
index|[
literal|1
index|]
operator|.
name|end
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|TRUTH_ANDIF_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|t
argument_list|,
name|t2
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|t
argument_list|,
name|build_int_2
argument_list|(
name|ranges
index|[
literal|1
index|]
operator|.
name|size
argument_list|,
literal|0
argument_list|)
argument_list|,
name|build_int_2
argument_list|(
name|ranges
index|[
literal|0
index|]
operator|.
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Initialize last_end to be larger than any possible 	 DWARF_FRAME_REGNUM.  */
name|int
name|last_end
init|=
literal|0x7fffffff
decl_stmt|;
operator|--
name|n_ranges
expr_stmt|;
name|t
operator|=
name|build_int_2
argument_list|(
name|ranges
index|[
name|n_ranges
index|]
operator|.
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|beg
init|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|ranges
index|[
name|n_ranges
index|]
operator|.
name|beg
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|ranges
index|[
name|n_ranges
index|]
operator|.
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|beg
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|end
operator|>=
name|last_end
condition|)
name|abort
argument_list|()
expr_stmt|;
name|last_end
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|beg
operator|!=
name|ranges
index|[
name|n_ranges
index|]
operator|.
name|end
operator|-
name|ranges
index|[
name|n_ranges
index|]
operator|.
name|beg
condition|)
name|abort
argument_list|()
expr_stmt|;
name|t2
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|LE_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|reg_tree
argument_list|,
name|build_int_2
argument_list|(
name|end
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|t2
argument_list|,
name|build_int_2
argument_list|(
name|ranges
index|[
name|n_ranges
index|]
operator|.
name|size
argument_list|,
literal|0
argument_list|)
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n_ranges
operator|>=
literal|0
condition|)
do|;
block|}
return|return
name|expand_expr
argument_list|(
name|t
argument_list|,
name|target
argument_list|,
name|Pmode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a DWARF call frame info. operation to its string name */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_cfi_name
parameter_list|(
name|cfi_opc
parameter_list|)
specifier|register
name|unsigned
name|cfi_opc
decl_stmt|;
block|{
switch|switch
condition|(
name|cfi_opc
condition|)
block|{
case|case
name|DW_CFA_advance_loc
case|:
return|return
literal|"DW_CFA_advance_loc"
return|;
case|case
name|DW_CFA_offset
case|:
return|return
literal|"DW_CFA_offset"
return|;
case|case
name|DW_CFA_restore
case|:
return|return
literal|"DW_CFA_restore"
return|;
case|case
name|DW_CFA_nop
case|:
return|return
literal|"DW_CFA_nop"
return|;
case|case
name|DW_CFA_set_loc
case|:
return|return
literal|"DW_CFA_set_loc"
return|;
case|case
name|DW_CFA_advance_loc1
case|:
return|return
literal|"DW_CFA_advance_loc1"
return|;
case|case
name|DW_CFA_advance_loc2
case|:
return|return
literal|"DW_CFA_advance_loc2"
return|;
case|case
name|DW_CFA_advance_loc4
case|:
return|return
literal|"DW_CFA_advance_loc4"
return|;
case|case
name|DW_CFA_offset_extended
case|:
return|return
literal|"DW_CFA_offset_extended"
return|;
case|case
name|DW_CFA_restore_extended
case|:
return|return
literal|"DW_CFA_restore_extended"
return|;
case|case
name|DW_CFA_undefined
case|:
return|return
literal|"DW_CFA_undefined"
return|;
case|case
name|DW_CFA_same_value
case|:
return|return
literal|"DW_CFA_same_value"
return|;
case|case
name|DW_CFA_register
case|:
return|return
literal|"DW_CFA_register"
return|;
case|case
name|DW_CFA_remember_state
case|:
return|return
literal|"DW_CFA_remember_state"
return|;
case|case
name|DW_CFA_restore_state
case|:
return|return
literal|"DW_CFA_restore_state"
return|;
case|case
name|DW_CFA_def_cfa
case|:
return|return
literal|"DW_CFA_def_cfa"
return|;
case|case
name|DW_CFA_def_cfa_register
case|:
return|return
literal|"DW_CFA_def_cfa_register"
return|;
case|case
name|DW_CFA_def_cfa_offset
case|:
return|return
literal|"DW_CFA_def_cfa_offset"
return|;
comment|/* SGI/MIPS specific */
case|case
name|DW_CFA_MIPS_advance_loc8
case|:
return|return
literal|"DW_CFA_MIPS_advance_loc8"
return|;
comment|/* GNU extensions */
case|case
name|DW_CFA_GNU_window_save
case|:
return|return
literal|"DW_CFA_GNU_window_save"
return|;
case|case
name|DW_CFA_GNU_args_size
case|:
return|return
literal|"DW_CFA_GNU_args_size"
return|;
default|default:
return|return
literal|"DW_CFA_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to a newly allocated Call Frame Instruction.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_cfi_ref
name|new_cfi
parameter_list|()
block|{
specifier|register
name|dw_cfi_ref
name|cfi
init|=
operator|(
name|dw_cfi_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_cfi_node
argument_list|)
argument_list|)
decl_stmt|;
name|cfi
operator|->
name|dw_cfi_next
operator|=
name|NULL
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
literal|0
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_reg_num
operator|=
literal|0
expr_stmt|;
return|return
name|cfi
return|;
block|}
end_function

begin_comment
comment|/* Add a Call Frame Instruction to list of instructions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_cfi
parameter_list|(
name|list_head
parameter_list|,
name|cfi
parameter_list|)
specifier|register
name|dw_cfi_ref
modifier|*
name|list_head
decl_stmt|;
specifier|register
name|dw_cfi_ref
name|cfi
decl_stmt|;
block|{
specifier|register
name|dw_cfi_ref
modifier|*
name|p
decl_stmt|;
comment|/* Find the end of the chain.  */
for|for
control|(
name|p
operator|=
name|list_head
init|;
operator|(
operator|*
name|p
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|dw_cfi_next
control|)
empty_stmt|;
operator|*
name|p
operator|=
name|cfi
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a new label for the CFI info to refer to.  */
end_comment

begin_function
name|char
modifier|*
name|dwarf2out_cfi_label
parameter_list|()
block|{
specifier|static
name|char
name|label
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|unsigned
name|long
name|label_num
init|=
literal|0
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LCFI"
argument_list|,
name|label_num
operator|++
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Add CFI to the current fde at the PC value indicated by LABEL if specified,    or to the CIE if LABEL is NULL.  */
end_comment

begin_function
specifier|static
name|void
name|add_fde_cfi
parameter_list|(
name|label
parameter_list|,
name|cfi
parameter_list|)
specifier|register
name|char
modifier|*
name|label
decl_stmt|;
specifier|register
name|dw_cfi_ref
name|cfi
decl_stmt|;
block|{
if|if
condition|(
name|label
condition|)
block|{
specifier|register
name|dw_fde_ref
name|fde
init|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|label
operator|==
literal|0
condition|)
name|label
operator|=
name|dwarf2out_cfi_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|fde
operator|->
name|dw_fde_current_label
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|label
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|dw_cfi_ref
name|xcfi
decl_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|label
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* Set the location counter to the new label.  */
name|xcfi
operator|=
name|new_cfi
argument_list|()
expr_stmt|;
name|xcfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_advance_loc4
expr_stmt|;
name|xcfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
operator|=
name|label
expr_stmt|;
name|add_cfi
argument_list|(
operator|&
name|fde
operator|->
name|dw_fde_cfi
argument_list|,
name|xcfi
argument_list|)
expr_stmt|;
block|}
name|add_cfi
argument_list|(
operator|&
name|fde
operator|->
name|dw_fde_cfi
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
else|else
name|add_cfi
argument_list|(
operator|&
name|cie_cfi_head
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of lookup_cfa.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lookup_cfa_1
parameter_list|(
name|cfi
parameter_list|,
name|regp
parameter_list|,
name|offsetp
parameter_list|)
specifier|register
name|dw_cfi_ref
name|cfi
decl_stmt|;
specifier|register
name|unsigned
name|long
modifier|*
name|regp
decl_stmt|;
specifier|register
name|long
modifier|*
name|offsetp
decl_stmt|;
block|{
switch|switch
condition|(
name|cfi
operator|->
name|dw_cfi_opc
condition|)
block|{
case|case
name|DW_CFA_def_cfa_offset
case|:
operator|*
name|offsetp
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
operator|*
name|regp
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa
case|:
operator|*
name|regp
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
expr_stmt|;
operator|*
name|offsetp
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Find the previous value for the CFA.  */
end_comment

begin_function
specifier|static
name|void
name|lookup_cfa
parameter_list|(
name|regp
parameter_list|,
name|offsetp
parameter_list|)
specifier|register
name|unsigned
name|long
modifier|*
name|regp
decl_stmt|;
specifier|register
name|long
modifier|*
name|offsetp
decl_stmt|;
block|{
specifier|register
name|dw_cfi_ref
name|cfi
decl_stmt|;
operator|*
name|regp
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
expr_stmt|;
operator|*
name|offsetp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cfi
operator|=
name|cie_cfi_head
init|;
name|cfi
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|lookup_cfa_1
argument_list|(
name|cfi
argument_list|,
name|regp
argument_list|,
name|offsetp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde_table_in_use
condition|)
block|{
specifier|register
name|dw_fde_ref
name|fde
init|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|cfi
operator|=
name|fde
operator|->
name|dw_fde_cfi
init|;
name|cfi
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|lookup_cfa_1
argument_list|(
name|cfi
argument_list|,
name|regp
argument_list|,
name|offsetp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The current rule for calculating the DWARF2 canonical frame address.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cfa_reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|cfa_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The register used for saving registers to the stack, and its offset    from the CFA.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|cfa_store_reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|cfa_store_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The running total of the size of arguments pushed onto the stack.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last args_size we actually output.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|old_args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entry point to update the canonical frame address (CFA).    LABEL is passed to add_fde_cfi.  The value of CFA is now to be    calculated from REG+OFFSET.  */
end_comment

begin_function
name|void
name|dwarf2out_def_cfa
parameter_list|(
name|label
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|char
modifier|*
name|label
decl_stmt|;
specifier|register
name|unsigned
name|reg
decl_stmt|;
specifier|register
name|long
name|offset
decl_stmt|;
block|{
specifier|register
name|dw_cfi_ref
name|cfi
decl_stmt|;
name|unsigned
name|long
name|old_reg
decl_stmt|;
name|long
name|old_offset
decl_stmt|;
name|cfa_reg
operator|=
name|reg
expr_stmt|;
name|cfa_offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|cfa_store_reg
operator|==
name|reg
condition|)
name|cfa_store_offset
operator|=
name|offset
expr_stmt|;
name|reg
operator|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|lookup_cfa
argument_list|(
operator|&
name|old_reg
argument_list|,
operator|&
name|old_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|old_reg
operator|&&
name|offset
operator|==
name|old_offset
condition|)
return|return;
name|cfi
operator|=
name|new_cfi
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|old_reg
condition|)
block|{
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa_offset
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
operator|=
name|offset
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
comment|/* SGI dbx thinks this means no offset.  */
elseif|else
if|if
condition|(
name|offset
operator|==
name|old_offset
operator|&&
name|old_reg
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
condition|)
block|{
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa_register
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
name|reg
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
name|reg
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
operator|=
name|offset
expr_stmt|;
block|}
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the CFI for saving a register.  REG is the CFA column number.    LABEL is passed to add_fde_cfi.    If SREG is -1, the register is saved at OFFSET from the CFA;    otherwise it is saved in SREG.  */
end_comment

begin_function
specifier|static
name|void
name|reg_save
parameter_list|(
name|label
parameter_list|,
name|reg
parameter_list|,
name|sreg
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|char
modifier|*
name|label
decl_stmt|;
specifier|register
name|unsigned
name|reg
decl_stmt|;
specifier|register
name|unsigned
name|sreg
decl_stmt|;
specifier|register
name|long
name|offset
decl_stmt|;
block|{
specifier|register
name|dw_cfi_ref
name|cfi
init|=
name|new_cfi
argument_list|()
decl_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
name|reg
expr_stmt|;
comment|/* The following comparison is correct. -1 is used to indicate that      the value isn't a register number.  */
if|if
condition|(
name|sreg
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|reg
operator|&
operator|~
literal|0x3f
condition|)
comment|/* The register number won't fit in 6 bits, so we have to use 	   the long form.  */
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_offset_extended
expr_stmt|;
else|else
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_offset
expr_stmt|;
name|offset
operator|/=
name|DWARF_CIE_DATA_ALIGNMENT
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
operator|=
name|offset
expr_stmt|;
block|}
else|else
block|{
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_register
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_reg_num
operator|=
name|sreg
expr_stmt|;
block|}
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the CFI for saving a register window.  LABEL is passed to reg_save.    This CFI tells the unwinder that it needs to restore the window registers    from the previous frame's window save area.        ??? Perhaps we should note in the CIE where windows are saved (instead of    assuming 0(cfa)) and what registers are in the window.  */
end_comment

begin_function
name|void
name|dwarf2out_window_save
parameter_list|(
name|label
parameter_list|)
specifier|register
name|char
modifier|*
name|label
decl_stmt|;
block|{
specifier|register
name|dw_cfi_ref
name|cfi
init|=
name|new_cfi
argument_list|()
decl_stmt|;
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_GNU_window_save
expr_stmt|;
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a CFI to update the running total of the size of arguments    pushed onto the stack.  */
end_comment

begin_function
name|void
name|dwarf2out_args_size
parameter_list|(
name|label
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|label
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|dw_cfi_ref
name|cfi
decl_stmt|;
if|if
condition|(
name|size
operator|==
name|old_args_size
condition|)
return|return;
name|old_args_size
operator|=
name|size
expr_stmt|;
name|cfi
operator|=
name|new_cfi
argument_list|()
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_GNU_args_size
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
operator|=
name|size
expr_stmt|;
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point for saving a register to the stack.  REG is the GCC register    number.  LABEL and OFFSET are passed to reg_save.  */
end_comment

begin_function
name|void
name|dwarf2out_reg_save
parameter_list|(
name|label
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|char
modifier|*
name|label
decl_stmt|;
specifier|register
name|unsigned
name|reg
decl_stmt|;
specifier|register
name|long
name|offset
decl_stmt|;
block|{
name|reg_save
argument_list|(
name|label
argument_list|,
name|DWARF_FRAME_REGNUM
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point for saving the return address in the stack.    LABEL and OFFSET are passed to reg_save.  */
end_comment

begin_function
name|void
name|dwarf2out_return_save
parameter_list|(
name|label
parameter_list|,
name|offset
parameter_list|)
specifier|register
name|char
modifier|*
name|label
decl_stmt|;
specifier|register
name|long
name|offset
decl_stmt|;
block|{
name|reg_save
argument_list|(
name|label
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|,
operator|-
literal|1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point for saving the return address in a register.    LABEL and SREG are passed to reg_save.  */
end_comment

begin_function
name|void
name|dwarf2out_return_reg
parameter_list|(
name|label
parameter_list|,
name|sreg
parameter_list|)
specifier|register
name|char
modifier|*
name|label
decl_stmt|;
specifier|register
name|unsigned
name|sreg
decl_stmt|;
block|{
name|reg_save
argument_list|(
name|label
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the initial position of the return address.  RTL is    INCOMING_RETURN_ADDR_RTX.  */
end_comment

begin_function
specifier|static
name|void
name|initial_return_save
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
name|unsigned
name|int
name|reg
init|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
decl_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
comment|/* RA is in a register.  */
name|reg
operator|=
name|reg_number
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
comment|/* RA is on the stack.  */
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
comment|/* The return address is at some offset from any value we can 	 actually load.  For instance, on the SPARC it is in %i7+8. Just 	 ignore the offset for now; it doesn't matter for unwinding frames.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|initial_return_save
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|reg_save
argument_list|(
name|NULL
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|,
name|reg
argument_list|,
name|offset
operator|-
name|cfa_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check INSN to see if it looks like a push or a stack adjustment, and    make a note of it if it does.  EH uses this information to find out how    much extra space it needs to pop off the stack.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_stack_adjust
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
if|if
condition|(
operator|!
name|asynchronous_exceptions
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* Extract the size of the args from the CALL rtx itself.  */
name|insn
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|PARALLEL
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|SET
condition|)
name|insn
operator|=
name|SET_SRC
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL
argument_list|)
expr_stmt|;
name|dwarf2out_args_size
argument_list|(
literal|""
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If only calls can throw, and we have a frame pointer,      save up adjustments until we see the CALL_INSN.  */
elseif|else
if|if
condition|(
operator|!
name|asynchronous_exceptions
operator|&&
name|cfa_reg
operator|!=
name|STACK_POINTER_REGNUM
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
comment|/* When we see a BARRIER, we know to reset args_size to 0.  Usually 	 the compiler will have already emitted a stack adjustment, but 	 doesn't bother for calls to noreturn functions.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|offset
operator|=
operator|-
name|args_size
expr_stmt|;
else|#
directive|else
name|offset
operator|=
name|args_size
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
block|{
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|insn
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|stack_pointer_rtx
condition|)
block|{
comment|/* (set (reg sp) (plus (reg sp) (const_int))) */
name|code
operator|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|||
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* (set (mem (pre_dec (reg sp))) (foo)) */
name|src
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|code
operator|==
name|PRE_DEC
operator|||
name|code
operator|==
name|PRE_INC
operator|)
operator|||
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
return|return;
name|offset
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|PRE_INC
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|cfa_reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa_offset
operator|+=
name|offset
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
endif|#
directive|endif
name|args_size
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|args_size
operator|<
literal|0
condition|)
name|args_size
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|dwarf2out_cfi_label
argument_list|()
expr_stmt|;
name|dwarf2out_def_cfa
argument_list|(
name|label
argument_list|,
name|cfa_reg
argument_list|,
name|cfa_offset
argument_list|)
expr_stmt|;
name|dwarf2out_args_size
argument_list|(
name|label
argument_list|,
name|args_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A temporary register used in adjusting SP or setting up the store_reg.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|cfa_temp_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A temporary value used in adjusting SP or setting up the store_reg.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cfa_temp_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record call frame debugging information for an expression, which either    sets SP or FP (adjusting how we calculate the frame address) or saves a    register to the stack. */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_frame_debug_expr
parameter_list|(
name|expr
parameter_list|,
name|label
parameter_list|)
name|rtx
name|expr
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
block|{
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|long
name|offset
decl_stmt|;
comment|/* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of       the PARALLEL independantly. The first element is always processed if       it is a SET. This is for backward compatability.   Other elements       are processed only if they are SETs and the RTX_FRAME_RELATED_P       flag is set in them. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|par_index
decl_stmt|;
name|int
name|limit
init|=
name|XVECLEN
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|par_index
operator|=
literal|0
init|;
name|par_index
operator|<
name|limit
condition|;
name|par_index
operator|++
control|)
block|{
name|rtx
name|x
init|=
name|XVECEXP
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|,
name|par_index
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|RTX_FRAME_RELATED_P
argument_list|(
name|x
argument_list|)
operator|||
name|par_index
operator|==
literal|0
operator|)
condition|)
name|dwarf2out_frame_debug_expr
argument_list|(
name|x
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|expr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
comment|/* Update the CFA rule wrt SP or FP.  Make sure src is          relative to the current CFA register.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* Setting FP from SP.  */
case|case
name|REG
case|:
if|if
condition|(
name|cfa_reg
operator|!=
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|src
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|frame_pointer_needed
operator|&&
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa_reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
if|if
condition|(
name|dest
operator|==
name|stack_pointer_rtx
condition|)
block|{
comment|/* Adjusting SP.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|cfa_temp_reg
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
name|cfa_temp_value
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|hard_frame_pointer_rtx
condition|)
block|{
comment|/* Restoring SP from FP in the epilogue.  */
if|if
condition|(
name|cfa_reg
operator|!=
operator|(
name|unsigned
operator|)
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa_reg
operator|=
name|STACK_POINTER_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|cfa_reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa_offset
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|cfa_store_reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa_store_offset
operator|+=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dest
operator|==
name|hard_frame_pointer_rtx
condition|)
block|{
comment|/* Either setting the FP from an offset of the SP,       	   or adjusting the FP */
if|if
condition|(
operator|!
name|frame_pointer_needed
operator|||
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|cfa_reg
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|cfa_offset
operator|+=
name|offset
expr_stmt|;
name|cfa_reg
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|hard_frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|cfa_reg
operator|!=
operator|(
name|unsigned
operator|)
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|PLUS
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|cfa_offset
operator|+=
name|offset
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PLUS
operator|||
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|cfa_temp_reg
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cfa_reg
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa_store_reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_store_offset
operator|=
name|cfa_offset
operator|-
name|cfa_temp_value
expr_stmt|;
block|}
break|break;
case|case
name|CONST_INT
case|:
name|cfa_temp_reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_temp_value
operator|=
name|INTVAL
argument_list|(
name|src
argument_list|)
expr_stmt|;
break|break;
case|case
name|IOR
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|cfa_temp_reg
operator|||
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|!=
name|cfa_temp_reg
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa_temp_value
operator||=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|dwarf2out_def_cfa
argument_list|(
name|label
argument_list|,
name|cfa_reg
argument_list|,
name|cfa_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
comment|/* Saving a register to the stack.  Make sure dest is relative to the        CFA register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* With a push.  */
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
name|offset
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|||
name|cfa_store_reg
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa_store_offset
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|cfa_reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa_offset
operator|=
name|cfa_store_offset
expr_stmt|;
name|offset
operator|=
operator|-
name|cfa_store_offset
expr_stmt|;
break|break;
comment|/* With an offset.  */
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|cfa_store_reg
operator|!=
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|-=
name|cfa_store_offset
expr_stmt|;
break|break;
comment|/* Without an offset.  */
case|case
name|REG
case|:
if|if
condition|(
name|cfa_store_reg
operator|!=
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
operator|-
name|cfa_store_offset
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|dwarf2out_def_cfa
argument_list|(
name|label
argument_list|,
name|cfa_reg
argument_list|,
name|cfa_offset
argument_list|)
expr_stmt|;
name|dwarf2out_reg_save
argument_list|(
name|label
argument_list|,
name|REGNO
argument_list|(
name|src
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record call frame debugging information for INSN, which either    sets SP or FP (adjusting how we calculate the frame address) or saves a    register to the stack.  If INSN is NULL_RTX, initialize our state.  */
end_comment

begin_function
name|void
name|dwarf2out_frame_debug
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
condition|)
block|{
comment|/* Set up state for generating call frame debug info.  */
name|lookup_cfa
argument_list|(
operator|&
name|cfa_reg
argument_list|,
operator|&
name|cfa_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfa_reg
operator|!=
name|DWARF_FRAME_REGNUM
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa_reg
operator|=
name|STACK_POINTER_REGNUM
expr_stmt|;
name|cfa_store_reg
operator|=
name|cfa_reg
expr_stmt|;
name|cfa_store_offset
operator|=
name|cfa_offset
expr_stmt|;
name|cfa_temp_reg
operator|=
operator|-
literal|1
expr_stmt|;
name|cfa_temp_value
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|dwarf2out_stack_adjust
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
name|label
operator|=
name|dwarf2out_cfi_label
argument_list|()
expr_stmt|;
name|src
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dwarf2out_frame_debug_expr
argument_list|(
name|insn
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the size of an unsigned LEB128 quantity.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|size_of_uleb128
parameter_list|(
name|value
parameter_list|)
specifier|register
name|unsigned
name|long
name|value
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|size
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|byte
decl_stmt|;
do|do
block|{
name|byte
operator|=
operator|(
name|value
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
name|size
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|!=
literal|0
condition|)
do|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a signed LEB128 quantity.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|size_of_sleb128
parameter_list|(
name|value
parameter_list|)
specifier|register
name|long
name|value
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|size
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|byte
decl_stmt|;
do|do
block|{
name|byte
operator|=
operator|(
name|value
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
name|size
operator|+=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
operator|(
operator|(
name|value
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|value
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
do|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Output an unsigned LEB128 quantity.  */
end_comment

begin_function
specifier|static
name|void
name|output_uleb128
parameter_list|(
name|value
parameter_list|)
specifier|register
name|unsigned
name|long
name|value
decl_stmt|;
block|{
name|unsigned
name|long
name|save_value
init|=
name|value
decl_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t"
argument_list|,
name|ASM_BYTE_OP
argument_list|)
expr_stmt|;
do|do
block|{
specifier|register
name|unsigned
name|byte
init|=
operator|(
name|value
operator|&
literal|0x7f
operator|)
decl_stmt|;
name|value
operator|>>=
literal|7
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
comment|/* More bytes to follow.  */
name|byte
operator||=
literal|0x80
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"0x%x"
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|value
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s ULEB128 0x%lx"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|save_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output an signed LEB128 quantity.  */
end_comment

begin_function
specifier|static
name|void
name|output_sleb128
parameter_list|(
name|value
parameter_list|)
specifier|register
name|long
name|value
decl_stmt|;
block|{
specifier|register
name|int
name|more
decl_stmt|;
specifier|register
name|unsigned
name|byte
decl_stmt|;
name|long
name|save_value
init|=
name|value
decl_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t"
argument_list|,
name|ASM_BYTE_OP
argument_list|)
expr_stmt|;
do|do
block|{
name|byte
operator|=
operator|(
name|value
operator|&
literal|0x7f
operator|)
expr_stmt|;
comment|/* arithmetic shift */
name|value
operator|>>=
literal|7
expr_stmt|;
name|more
operator|=
operator|!
operator|(
operator|(
operator|(
operator|(
name|value
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|value
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|byte
operator|&
literal|0x40
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|byte
operator||=
literal|0x80
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"0x%x"
argument_list|,
name|byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|more
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|more
condition|)
do|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s SLEB128 %ld"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|save_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a Call Frame Information opcode and its operand(s).  */
end_comment

begin_function
specifier|static
name|void
name|output_cfi
parameter_list|(
name|cfi
parameter_list|,
name|fde
parameter_list|)
specifier|register
name|dw_cfi_ref
name|cfi
decl_stmt|;
specifier|register
name|dw_fde_ref
name|fde
decl_stmt|;
block|{
if|if
condition|(
name|cfi
operator|->
name|dw_cfi_opc
operator|==
name|DW_CFA_advance_loc
condition|)
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|cfi
operator|->
name|dw_cfi_opc
operator||
operator|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
operator|&
literal|0x3f
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_CFA_advance_loc 0x%lx"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfi
operator|->
name|dw_cfi_opc
operator|==
name|DW_CFA_offset
condition|)
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|cfi
operator|->
name|dw_cfi_opc
operator||
operator|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|&
literal|0x3f
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_CFA_offset, column 0x%lx"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfi
operator|->
name|dw_cfi_opc
operator|==
name|DW_CFA_restore
condition|)
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|cfi
operator|->
name|dw_cfi_opc
operator||
operator|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|&
literal|0x3f
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_CFA_restore, column 0x%lx"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|cfi
operator|->
name|dw_cfi_opc
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|dwarf_cfi_name
argument_list|(
name|cfi
operator|->
name|dw_cfi_opc
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cfi
operator|->
name|dw_cfi_opc
condition|)
block|{
case|case
name|DW_CFA_set_loc
case|:
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
name|ASM_OUTPUT_DWARF_DELTA1
argument_list|(
name|asm_out_file
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
case|case
name|DW_CFA_MIPS_advance_loc8
case|:
comment|/* TODO: not currently implemented.  */
name|abort
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|DW_CFA_offset_extended
case|:
case|case
name|DW_CFA_def_cfa
case|:
name|output_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
case|case
name|DW_CFA_undefined
case|:
name|output_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_same_value
case|:
case|case
name|DW_CFA_def_cfa_register
case|:
name|output_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_register
case|:
name|output_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_reg_num
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|output_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_window_save
case|:
break|break;
case|case
name|DW_CFA_GNU_args_size
case|:
name|output_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EH_FRAME_SECTION
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|EH_FRAME_SECTION_ASM_OP
argument_list|)
end_if

begin_define
define|#
directive|define
name|EH_FRAME_SECTION
parameter_list|()
value|eh_frame_section();
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ASM_OUTPUT_SECTION_NAME
argument_list|)
end_if

begin_define
define|#
directive|define
name|EH_FRAME_SECTION
parameter_list|()
define|\
value|do {							\       named_section (NULL_TREE, ".eh_frame", 0);	\   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If we aren't using crtstuff to run ctors, don't use it for EH.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_INIT_SECTION
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|INIT_SECTION_ASM_OP
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|EH_FRAME_SECTION
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Output the call frame information used to used to record information    that relates to calculating the frame pointer, and records the    location of saved registers.  */
end_comment

begin_function
specifier|static
name|void
name|output_call_frame_info
parameter_list|(
name|for_eh
parameter_list|)
name|int
name|for_eh
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|i
decl_stmt|;
specifier|register
name|dw_fde_ref
name|fde
decl_stmt|;
specifier|register
name|dw_cfi_ref
name|cfi
decl_stmt|;
name|char
name|l1
index|[
literal|20
index|]
decl_stmt|,
name|l2
index|[
literal|20
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL
name|char
name|ld
index|[
literal|20
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* Do we want to include a pointer to the exception table?  */
name|int
name|eh_ptr
init|=
name|for_eh
operator|&&
name|exception_table_p
argument_list|()
decl_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* We're going to be generating comments, so turn on app.  */
if|if
condition|(
name|flag_debug_asm
condition|)
name|app_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
block|{
ifdef|#
directive|ifdef
name|EH_FRAME_SECTION
name|EH_FRAME_SECTION
argument_list|()
expr_stmt|;
else|#
directive|else
name|tree
name|label
init|=
name|get_file_function_name
argument_list|(
literal|'F'
argument_list|)
decl_stmt|;
name|force_data_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|PTR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assemble_label
argument_list|(
literal|"__FRAME_BEGIN__"
argument_list|)
expr_stmt|;
block|}
else|else
name|ASM_OUTPUT_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|FRAME_SECTION
argument_list|)
expr_stmt|;
comment|/* Output the CIE. */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
name|CIE_AFTER_SIZE_LABEL
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l2
argument_list|,
name|CIE_END_LABEL
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ld
argument_list|,
name|CIE_LENGTH_LABEL
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
name|ASM_OUTPUT_DWARF_OFFSET4
argument_list|(
name|asm_out_file
argument_list|,
name|ld
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_DWARF_OFFSET
argument_list|(
name|asm_out_file
argument_list|,
name|ld
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|for_eh
condition|)
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_DWARF_DELTA
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Length of Common Information Entry"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
comment|/* Now that the CIE pointer is PC-relative for EH,        use 0 to identify the CIE.  */
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|DW_CIE_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s CIE Identifier Tag"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|for_eh
operator|&&
name|DWARF_OFFSET_SIZE
operator|==
literal|8
condition|)
block|{
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|DW_CIE_ID
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_CIE_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s CIE Version"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_ptr
condition|)
block|{
comment|/* The CIE contains a pointer to the exception region info for the          frame.  Make the augmentation string three bytes (including the          trailing null) so the pointer is 4-byte aligned.  The Solaris ld          can't handle unaligned relocs.  */
if|if
condition|(
name|flag_debug_asm
condition|)
block|{
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
literal|"eh"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s CIE Augmentation"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_OUTPUT_ASCII
argument_list|(
name|asm_out_file
argument_list|,
literal|"eh"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
literal|"__EXCEPTION_TABLE__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s pointer to exception region info"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s CIE Augmentation (none)"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" (CIE Code Alignment Factor)"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_sleb128
argument_list|(
name|DWARF_CIE_DATA_ALIGNMENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" (CIE Data Alignment Factor)"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s CIE RA Column"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
for|for
control|(
name|cfi
operator|=
name|cie_cfi_head
init|;
name|cfi
operator|!=
name|NULL
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|output_cfi
argument_list|(
name|cfi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Pad the CIE out to an address sized boundary.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|PTR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL
name|ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL
argument_list|(
name|asm_out_file
argument_list|,
name|ld
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s CIE Length Symbol"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Loop through all of the FDE's.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fde_table_in_use
condition|;
operator|++
name|i
control|)
block|{
name|fde
operator|=
operator|&
name|fde_table
index|[
name|i
index|]
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
name|FDE_AFTER_SIZE_LABEL
argument_list|,
name|for_eh
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l2
argument_list|,
name|FDE_END_LABEL
argument_list|,
name|for_eh
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ld
argument_list|,
name|FDE_LENGTH_LABEL
argument_list|,
name|for_eh
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
name|ASM_OUTPUT_DWARF_OFFSET4
argument_list|(
name|asm_out_file
argument_list|,
name|ld
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_DWARF_OFFSET
argument_list|(
name|asm_out_file
argument_list|,
name|ld
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|for_eh
condition|)
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_DWARF_DELTA
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s FDE Length"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l1
argument_list|)
expr_stmt|;
comment|/* ??? This always emits a 4 byte offset when for_eh is true, but it 	 emits a target dependent sized offset when for_eh is not true. 	 This inconsistency may confuse gdb.  The only case where we need a 	 non-4 byte offset is for the Irix6 N64 ABI, so we may lose SGI 	 compatibility if we emit a 4 byte offset.  We need a 4 byte offset 	 though in order to be compatible with the dwarf_fde struct in frame.c. 	 If the for_eh case is changed, then the struct in frame.c has 	 to be adjusted appropriately.  */
if|if
condition|(
name|for_eh
condition|)
name|ASM_OUTPUT_DWARF_DELTA4
argument_list|(
name|asm_out_file
argument_list|,
name|l1
argument_list|,
literal|"__FRAME_BEGIN__"
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_DWARF_OFFSET
argument_list|(
name|asm_out_file
argument_list|,
name|stripattributes
argument_list|(
name|FRAME_SECTION
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s FDE CIE offset"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|fde
operator|->
name|dw_fde_begin
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s FDE initial location"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR_DELTA
argument_list|(
name|asm_out_file
argument_list|,
name|fde
operator|->
name|dw_fde_end
argument_list|,
name|fde
operator|->
name|dw_fde_begin
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s FDE address range"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Loop through the Call Frame Instructions associated with 	 this FDE.  */
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|fde
operator|->
name|dw_fde_begin
expr_stmt|;
for|for
control|(
name|cfi
operator|=
name|fde
operator|->
name|dw_fde_cfi
init|;
name|cfi
operator|!=
name|NULL
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|output_cfi
argument_list|(
name|cfi
argument_list|,
name|fde
argument_list|)
expr_stmt|;
comment|/* Pad the FDE out to an address sized boundary.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|PTR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL
name|ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL
argument_list|(
name|asm_out_file
argument_list|,
name|ld
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s FDE Length Symbol"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|EH_FRAME_SECTION
if|if
condition|(
name|for_eh
condition|)
block|{
comment|/* Emit terminating zero for table.  */
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* Work around Irix 6 assembler bug whereby labels at the end of a section      get a value of 0.  Putting .align 0 after the label fixes it.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Turn off app to make assembly quicker.  */
if|if
condition|(
name|flag_debug_asm
condition|)
name|app_disable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the beginning of a function, before    the prologue.  */
end_comment

begin_function
name|void
name|dwarf2out_begin_prologue
parameter_list|()
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
specifier|register
name|dw_fde_ref
name|fde
decl_stmt|;
operator|++
name|current_funcdef_number
expr_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|FUNC_BEGIN_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* Expand the fde table if necessary.  */
if|if
condition|(
name|fde_table_in_use
operator|==
name|fde_table_allocated
condition|)
block|{
name|fde_table_allocated
operator|+=
name|FDE_TABLE_INCREMENT
expr_stmt|;
name|fde_table
operator|=
operator|(
name|dw_fde_ref
operator|)
name|xrealloc
argument_list|(
name|fde_table
argument_list|,
name|fde_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_fde_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Record the FDE associated with this function.  */
name|current_funcdef_fde
operator|=
name|fde_table_in_use
expr_stmt|;
comment|/* Add the new FDE at the end of the fde_table.  */
name|fde
operator|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|++
index|]
expr_stmt|;
name|fde
operator|->
name|dw_fde_begin
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|NULL
expr_stmt|;
name|fde
operator|->
name|dw_fde_end
operator|=
name|NULL
expr_stmt|;
name|fde
operator|->
name|dw_fde_cfi
operator|=
name|NULL
expr_stmt|;
name|args_size
operator|=
name|old_args_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the absolute end of the generated code    for a function definition.  This gets called *after* the epilogue code has    been generated.  */
end_comment

begin_function
name|void
name|dwarf2out_end_epilogue
parameter_list|()
block|{
name|dw_fde_ref
name|fde
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* Output a label to mark the endpoint of the code generated for this      function.        */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fde
operator|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|-
literal|1
index|]
expr_stmt|;
name|fde
operator|->
name|dw_fde_end
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dwarf2out_frame_init
parameter_list|()
block|{
comment|/* Allocate the initial hunk of the fde_table.  */
name|fde_table
operator|=
operator|(
name|dw_fde_ref
operator|)
name|xmalloc
argument_list|(
name|FDE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_fde_node
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fde_table
argument_list|,
name|FDE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_fde_node
argument_list|)
argument_list|)
expr_stmt|;
name|fde_table_allocated
operator|=
name|FDE_TABLE_INCREMENT
expr_stmt|;
name|fde_table_in_use
operator|=
literal|0
expr_stmt|;
comment|/* Generate the CFA instructions common to all FDE's.  Do it now for the      sake of lookup_cfa.  */
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
comment|/* On entry, the Canonical Frame Address is at SP.  */
name|dwarf2out_def_cfa
argument_list|(
name|NULL
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|INCOMING_FRAME_SP_OFFSET
argument_list|)
expr_stmt|;
name|initial_return_save
argument_list|(
name|INCOMING_RETURN_ADDR_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|dwarf2out_frame_finish
parameter_list|()
block|{
comment|/* Output call frame information.  */
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
condition|)
name|output_call_frame_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_exceptions
operator|&&
operator|!
name|exceptions_via_longjmp
condition|)
name|output_call_frame_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|exceptions_via_longjmp
operator|)
condition|)
name|output_call_frame_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* .debug_frame support */
end_comment

begin_comment
comment|/* And now, the support for symbolic debugging information.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|getpwd
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NOTE: In the comments in this file, many references are made to    "Debugging Information Entries".  This term is abbreviated as `DIE'    throughout the remainder of this file.  */
end_comment

begin_comment
comment|/* An internal representation of the DWARF output is built, and then    walked to generate the DWARF debugging info.  The walk of the internal    representation is done after the entire program has been compiled.    The types below are used to describe the internal representation.  */
end_comment

begin_comment
comment|/* Each DIE may have a series of attribute/value pairs.  Values    can take on several forms.  The forms that are used in this    implementation are listed below.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|dw_val_class_addr
block|,
name|dw_val_class_loc
block|,
name|dw_val_class_const
block|,
name|dw_val_class_unsigned_const
block|,
name|dw_val_class_long_long
block|,
name|dw_val_class_float
block|,
name|dw_val_class_flag
block|,
name|dw_val_class_die_ref
block|,
name|dw_val_class_fde_ref
block|,
name|dw_val_class_lbl_id
block|,
name|dw_val_class_lbl_offset
block|,
name|dw_val_class_str
block|}
name|dw_val_class
typedef|;
end_typedef

begin_comment
comment|/* Various DIE's use offsets relative to the beginning of the    .debug_info section to refer to each other.  */
end_comment

begin_typedef
typedef|typedef
name|long
name|int
name|dw_offset
typedef|;
end_typedef

begin_comment
comment|/* Define typedefs here to avoid circular dependencies.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|die_struct
modifier|*
name|dw_die_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_attr_struct
modifier|*
name|dw_attr_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_val_struct
modifier|*
name|dw_val_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_line_info_struct
modifier|*
name|dw_line_info_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_separate_line_info_struct
modifier|*
name|dw_separate_line_info_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_loc_descr_struct
modifier|*
name|dw_loc_descr_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|pubname_struct
modifier|*
name|pubname_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|dw_die_ref
modifier|*
name|arange_ref
typedef|;
end_typedef

begin_comment
comment|/* Describe a double word constant value.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_long_long_struct
block|{
name|unsigned
name|long
name|hi
decl_stmt|;
name|unsigned
name|long
name|low
decl_stmt|;
block|}
name|dw_long_long_const
typedef|;
end_typedef

begin_comment
comment|/* Describe a floating point constant value.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_fp_struct
block|{
name|long
modifier|*
name|array
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
block|}
name|dw_float_const
typedef|;
end_typedef

begin_comment
comment|/* Each entry in the line_info_table maintains the file and    line number associated with the label generated for that    entry.  The label gives the PC value associated with    the line number entry.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_line_info_struct
block|{
name|unsigned
name|long
name|dw_file_num
decl_stmt|;
name|unsigned
name|long
name|dw_line_num
decl_stmt|;
block|}
name|dw_line_info_entry
typedef|;
end_typedef

begin_comment
comment|/* Line information for functions in separate sections; each one gets its    own sequence.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_separate_line_info_struct
block|{
name|unsigned
name|long
name|dw_file_num
decl_stmt|;
name|unsigned
name|long
name|dw_line_num
decl_stmt|;
name|unsigned
name|long
name|function
decl_stmt|;
block|}
name|dw_separate_line_info_entry
typedef|;
end_typedef

begin_comment
comment|/* The dw_val_node describes an attribute's value, as it is    represented internally.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_val_struct
block|{
name|dw_val_class
name|val_class
decl_stmt|;
union|union
block|{
name|char
modifier|*
name|val_addr
decl_stmt|;
name|dw_loc_descr_ref
name|val_loc
decl_stmt|;
name|long
name|int
name|val_int
decl_stmt|;
name|long
name|unsigned
name|val_unsigned
decl_stmt|;
name|dw_long_long_const
name|val_long_long
decl_stmt|;
name|dw_float_const
name|val_float
decl_stmt|;
name|dw_die_ref
name|val_die_ref
decl_stmt|;
name|unsigned
name|val_fde_index
decl_stmt|;
name|char
modifier|*
name|val_str
decl_stmt|;
name|char
modifier|*
name|val_lbl_id
decl_stmt|;
name|unsigned
name|char
name|val_flag
decl_stmt|;
block|}
name|v
union|;
block|}
name|dw_val_node
typedef|;
end_typedef

begin_comment
comment|/* Locations in memory are described using a sequence of stack machine    operations.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_loc_descr_struct
block|{
name|dw_loc_descr_ref
name|dw_loc_next
decl_stmt|;
name|enum
name|dwarf_location_atom
name|dw_loc_opc
decl_stmt|;
name|dw_val_node
name|dw_loc_oprnd1
decl_stmt|;
name|dw_val_node
name|dw_loc_oprnd2
decl_stmt|;
block|}
name|dw_loc_descr_node
typedef|;
end_typedef

begin_comment
comment|/* Each DIE attribute has a field specifying the attribute kind,    a link to the next attribute in the chain, and an attribute value.    Attributes are typically linked below the DIE they modify.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_attr_struct
block|{
name|enum
name|dwarf_attribute
name|dw_attr
decl_stmt|;
name|dw_attr_ref
name|dw_attr_next
decl_stmt|;
name|dw_val_node
name|dw_attr_val
decl_stmt|;
block|}
name|dw_attr_node
typedef|;
end_typedef

begin_comment
comment|/* The Debugging Information Entry (DIE) structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|die_struct
block|{
name|enum
name|dwarf_tag
name|die_tag
decl_stmt|;
name|dw_attr_ref
name|die_attr
decl_stmt|;
name|dw_attr_ref
name|die_attr_last
decl_stmt|;
name|dw_die_ref
name|die_parent
decl_stmt|;
name|dw_die_ref
name|die_child
decl_stmt|;
name|dw_die_ref
name|die_child_last
decl_stmt|;
name|dw_die_ref
name|die_sib
decl_stmt|;
name|dw_offset
name|die_offset
decl_stmt|;
name|unsigned
name|long
name|die_abbrev
decl_stmt|;
block|}
name|die_node
typedef|;
end_typedef

begin_comment
comment|/* The pubname structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pubname_struct
block|{
name|dw_die_ref
name|die
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|pubname_entry
typedef|;
end_typedef

begin_comment
comment|/* The limbo die list structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|limbo_die_struct
block|{
name|dw_die_ref
name|die
decl_stmt|;
name|struct
name|limbo_die_struct
modifier|*
name|next
decl_stmt|;
block|}
name|limbo_die_node
typedef|;
end_typedef

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define a macro which returns non-zero for a TYPE_DECL which was    implicitly generated for a tagged type.     Note that unlike the gcc front end (which generates a NULL named    TYPE_DECL node for each complete tagged type, each array type, and    each function type node created) the g++ front end generates a    _named_ TYPE_DECL node for each tagged type node created.    These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to    generate a DW_TAG_typedef DIE for them.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_DECL_IS_STUB
parameter_list|(
name|decl
parameter_list|)
define|\
value|(DECL_NAME (decl) == NULL_TREE			\    || (DECL_ARTIFICIAL (decl)				\&& is_tagged_type (TREE_TYPE (decl))		\&& ((decl == TYPE_STUB_DECL (TREE_TYPE (decl)))	\
comment|/* This is necessary for stub decls that	\ 	      appear in nested inline functions.  */
value|\ 	   || (DECL_ABSTRACT_ORIGIN (decl) != NULL_TREE	\&& (decl_ultimate_origin (decl)		\ 		   == TYPE_STUB_DECL (TREE_TYPE (decl)))))))
end_define

begin_comment
comment|/* Information concerning the compilation unit's programming    language, and compiler version.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_traditional
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|language_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fixed size portion of the DWARF compilation unit header.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_COMPILE_UNIT_HEADER_SIZE
value|(2 * DWARF_OFFSET_SIZE + 3)
end_define

begin_comment
comment|/* Fixed size portion of debugging line information prolog.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_PROLOG_HEADER_SIZE
value|5
end_define

begin_comment
comment|/* Fixed size portion of public names info.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_PUBNAMES_HEADER_SIZE
value|(2 * DWARF_OFFSET_SIZE + 2)
end_define

begin_comment
comment|/* Fixed size portion of the address range info.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_ARANGES_HEADER_SIZE
define|\
value|(DWARF_ROUND (2 * DWARF_OFFSET_SIZE + 4, PTR_SIZE * 2) - DWARF_OFFSET_SIZE)
end_define

begin_comment
comment|/* Define the architecture-dependent minimum instruction length (in bytes).    In this implementation of DWARF, this field is used for information    purposes only.  Since GCC generates assembly language, we have    no a priori knowledge of how many instruction bytes are generated    for each source line, and therefore can use only the  DW_LNE_set_address    and DW_LNS_fixed_advance_pc line information commands.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_LINE_MIN_INSTR_LENGTH
end_ifndef

begin_define
define|#
directive|define
name|DWARF_LINE_MIN_INSTR_LENGTH
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Minimum line offset in a special line info. opcode.    This value was chosen to give a reasonable range of values.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_BASE
value|-10
end_define

begin_comment
comment|/* First special line opcde - leave room for the standard opcodes.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_OPCODE_BASE
value|10
end_define

begin_comment
comment|/* Range of line offsets in a special line info. opcode.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_RANGE
value|(254-DWARF_LINE_OPCODE_BASE+1)
end_define

begin_comment
comment|/* Flag that indicates the initial value of the is_stmt_start flag.    In the present implementation, we do not mark any lines as    the beginning of a source statement, because that information    is not made available by the GCC front-end.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_DEFAULT_IS_STMT_START
value|1
end_define

begin_comment
comment|/* This location is used by calc_die_sizes() to keep track    the offset of each DIE within the .debug_info section.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|next_die_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the root of the DIE's built for the current compilation unit.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_die_ref
name|comp_unit_die
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of DIEs with a NULL parent waiting to be relocated.  */
end_comment

begin_decl_stmt
specifier|static
name|limbo_die_node
modifier|*
name|limbo_die_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to an array of filenames referenced by this compilation unit.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|file_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of entries in the table (i.e. array) pointed to by    `file_table'.  This is the *total* and includes both used and unused    slots.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|file_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries in the file_table which are actually in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|file_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the filename    table.  */
end_comment

begin_define
define|#
directive|define
name|FILE_TABLE_INCREMENT
value|64
end_define

begin_comment
comment|/* Local pointer to the name of the main input file.  Initialized in    dwarf2out_init.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|primary_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For Dwarf output, we must assign lexical-blocks id numbers in the order in    which their beginnings are encountered. We output Dwarf debugging info    that refers to the beginnings and ends of the ranges of code for each    lexical block.  The labels themselves are generated in final.c, which    assigns numbers to the blocks in the same way.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|next_block_number
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the base of a table of references to DIE's that describe    declarations.  The table is indexed by DECL_UID() which is a unique    number identifying each decl.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_die_ref
modifier|*
name|decl_die_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for the decl_die_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|decl_die_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in decl_die_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|decl_die_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    decl_die_table.  */
end_comment

begin_define
define|#
directive|define
name|DECL_DIE_TABLE_INCREMENT
value|256
end_define

begin_comment
comment|/* Structure used for the decl_scope table.  scope is the current declaration    scope, and previous is the entry that is the parent of this scope.  This    is usually but not always the immediately preceeding entry.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|decl_scope_struct
block|{
name|tree
name|scope
decl_stmt|;
name|int
name|previous
decl_stmt|;
block|}
name|decl_scope_node
typedef|;
end_typedef

begin_comment
comment|/* A pointer to the base of a table of references to declaration    scopes.  This table is a display which tracks the nesting    of declaration scopes at the current scope and containing    scopes.  This table is used to find the proper place to    define type declaration DIE's.  */
end_comment

begin_decl_stmt
specifier|static
name|decl_scope_node
modifier|*
name|decl_scope_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for the decl_scope_table.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|decl_scope_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current level of nesting of declaration scopes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|decl_scope_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    decl_scope_table.  */
end_comment

begin_define
define|#
directive|define
name|DECL_SCOPE_TABLE_INCREMENT
value|64
end_define

begin_comment
comment|/* A pointer to the base of a list of references to DIE's that    are uniquely identified by their tag, presence/absence of    children DIE's, and list of attribute/value pairs.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_die_ref
modifier|*
name|abbrev_die_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for abbrev_die_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|abbrev_die_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in type_die_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|abbrev_die_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    abbrev_die_table.  */
end_comment

begin_define
define|#
directive|define
name|ABBREV_DIE_TABLE_INCREMENT
value|256
end_define

begin_comment
comment|/* A pointer to the base of a table that contains line information    for each source code line in .text in the compilation unit.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_line_info_ref
name|line_info_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for line_info_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|line_info_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in separate_line_info_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|separate_line_info_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the base of a table that contains line information    for each source code line outside of .text in the compilation unit.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_separate_line_info_ref
name|separate_line_info_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for separate_line_info_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|separate_line_info_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in line_info_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|line_info_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    line_info_table.  */
end_comment

begin_define
define|#
directive|define
name|LINE_INFO_TABLE_INCREMENT
value|1024
end_define

begin_comment
comment|/* A pointer to the base of a table that contains a list of publicly    accessible names.  */
end_comment

begin_decl_stmt
specifier|static
name|pubname_ref
name|pubname_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for pubname_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pubname_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in pubname_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pubname_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    pubname_table.  */
end_comment

begin_define
define|#
directive|define
name|PUBNAME_TABLE_INCREMENT
value|64
end_define

begin_comment
comment|/* A pointer to the base of a table that contains a list of publicly    accessible names.  */
end_comment

begin_decl_stmt
specifier|static
name|arange_ref
name|arange_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for arange_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|arange_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in arange_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|arange_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    arange_table.  */
end_comment

begin_define
define|#
directive|define
name|ARANGE_TABLE_INCREMENT
value|64
end_define

begin_comment
comment|/* A pointer to the base of a list of pending types which we haven't    generated DIEs for yet, but which we will have to come back to    later on.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|pending_types_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for the pending_types_list.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pending_types_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements of pending_types_list currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pending_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the pending    types list.  Actually, a single hunk of space of this size should    be enough for most typical programs.	 */
end_comment

begin_define
define|#
directive|define
name|PENDING_TYPES_INCREMENT
value|64
end_define

begin_comment
comment|/* A pointer to the base of a list of incomplete types which might be    completed at some later time.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|incomplete_types_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for the incomplete_types_list.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|incomplete_types_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements of incomplete_types_list currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|incomplete_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the incomplete    types list.  Actually, a single hunk of space of this size should    be enough for most typical programs.	 */
end_comment

begin_define
define|#
directive|define
name|INCOMPLETE_TYPES_INCREMENT
value|64
end_define

begin_comment
comment|/* Record whether the function being analyzed contains inlined functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_function_has_inlines
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|MIPS_DEBUGGING_INFO
argument_list|)
end_if

begin_endif
unit|static int comp_unit_has_inlines;
endif|#
directive|endif
end_endif

begin_comment
comment|/* A pointer to the ..._DECL node which we have most recently been working    on.  We keep this around just in case something about it looks screwy and    we want to tell the user what the source coordinates for the actual    declaration are.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|dwarf_last_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations for functions defined in this file.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|addr_const_to_string
name|PROTO
argument_list|(
operator|(
name|dyn_string_t
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|addr_to_string
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_pseudo_reg
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|type_main_variant
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_tagged_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_tag_name
name|PROTO
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_attr_name
name|PROTO
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_form_name
name|PROTO
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_stack_op_name
name|PROTO
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char *dwarf_type_encoding_name	PROTO((unsigned));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|tree
name|decl_ultimate_origin
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|block_ultimate_origin
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|decl_class_context
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_dwarf_attr
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_flag
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_int
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_unsigned
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_long_long
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_float
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
operator|,
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_string
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_die_ref
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_fde_ref
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_loc
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|dw_loc_descr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_addr
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_lbl_id
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_lbl_offset
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_extern_subr_die
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_attr_ref
name|get_AT
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_AT_low_pc
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_AT_hi_pc
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_AT_string
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_AT_flag
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|get_AT_unsigned
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_c_family
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_fortran
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_AT
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_children
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_child_die
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|new_die
name|PROTO
argument_list|(
operator|(
expr|enum
name|dwarf_tag
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|lookup_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|equate_type_number_to_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|lookup_decl_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|equate_decl_number_to_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|new_loc_descr
name|PROTO
argument_list|(
operator|(
expr|enum
name|dwarf_location_atom
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_loc_descr
name|PROTO
argument_list|(
operator|(
name|dw_loc_descr_ref
operator|*
operator|,
name|dw_loc_descr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_spaces
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_die
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_dwarf_line_table
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_sibling_attributes
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_abbrev_table
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_string
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_loc_descr
name|PROTO
argument_list|(
operator|(
name|dw_loc_descr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_locs
name|PROTO
argument_list|(
operator|(
name|dw_loc_descr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|constant_size
name|PROTO
argument_list|(
operator|(
name|long
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_die
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|calc_die_sizes
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_line_prolog
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_line_info
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_pubnames
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_aranges
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|dwarf_form
name|value_format
name|PROTO
argument_list|(
operator|(
name|dw_val_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_value_format
name|PROTO
argument_list|(
operator|(
name|dw_val_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_abbrev_section
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_loc_operands
name|PROTO
argument_list|(
operator|(
name|dw_loc_descr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|sibling_offset
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_die
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_compilation_unit_header
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf2_name
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_pubname
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_pubnames
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_arange
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_aranges
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_line_info
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_body_block
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|base_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|root_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_base_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|modified_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type_is_enum
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|reg_loc_descriptor
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|based_loc_descr
name|PROTO
argument_list|(
operator|(
name|unsigned
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_based_loc
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|mem_loc_descriptor
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|concat_loc_descriptor
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|loc_descriptor
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|ceiling
name|PROTO
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|field_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|simple_type_align_in_bits
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|simple_type_size_in_bits
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|field_byte_offset
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_location_description
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_data_member_location_attribute
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_const_value_attribute
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_location_or_const_value_attribute
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_name_attribute
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_bound_info
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_subscript_info
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_byte_size_attribute
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_bit_offset_attribute
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_bit_size_attribute
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_prototyped_attribute
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_abstract_origin_attribute
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_pure_or_virtual_attribute
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_src_coords_attributes
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_name_and_src_coords_attributes
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_decl_scope
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|scope_die_for
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_decl_scope
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_type_attribute
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|type_tag
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|member_declared_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char *decl_start_label		PROTO((tree));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|gen_array_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_set_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void gen_entry_point_die		PROTO((tree, dw_die_ref));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|pend_type
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_pending_types_for_scope
name|PROTO
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_inlined_enumeration_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_inlined_structure_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_inlined_union_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_enumeration_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|gen_formal_parameter_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_unspecified_parameters_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_formal_types_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_subprogram_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_variable_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_label_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_lexical_block_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_inlined_subroutine_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_field_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_ptr_to_mbr_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_compile_unit_die
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_string_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_inheritance_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_member_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_struct_or_union_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_subroutine_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_typedef_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_type_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_tagged_type_instantiation_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_block_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decls_for_scope
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_redundant_typedef
name|PROTO
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_decl_die
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|lookup_filename
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Section names used to hold DWARF debugging information.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_INFO_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_INFO_SECTION
value|".debug_info"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ABBREV_SECTION
end_ifndef

begin_define
define|#
directive|define
name|ABBREV_SECTION
value|".debug_abbrev"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ARANGES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|ARANGES_SECTION
value|".debug_aranges"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DW_MACINFO_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DW_MACINFO_SECTION
value|".debug_macinfo"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_LINE_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_LINE_SECTION
value|".debug_line"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOC_SECTION
end_ifndef

begin_define
define|#
directive|define
name|LOC_SECTION
value|".debug_loc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PUBNAMES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|PUBNAMES_SECTION
value|".debug_pubnames"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STR_SECTION
end_ifndef

begin_define
define|#
directive|define
name|STR_SECTION
value|".debug_str"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Standard ELF section names for compiled code and data.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_SECTION
end_ifndef

begin_define
define|#
directive|define
name|TEXT_SECTION
value|".text"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DATA_SECTION
value|".data"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BSS_SECTION
end_ifndef

begin_define
define|#
directive|define
name|BSS_SECTION
value|".bss"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Labels we insert at beginning sections we can reference instead of    the section names themselves. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TEXT_SECTION_LABEL
value|"Ltext"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_LINE_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_LINE_SECTION_LABEL
value|"Ldebug_line"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_INFO_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_INFO_SECTION_LABEL
value|"Ldebug_info"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ABBREV_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|ABBREV_SECTION_LABEL
value|"Ldebug_abbrev"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Definitions of defaults for formats and names of various special    (artificial) labels which may be generated within this file (when the -g    options is used and DWARF_DEBUGGING_INFO is in effect.    If necessary, these may be overridden from within the tm.h file, but    typically, overriding these defaults is unnecessary.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|text_end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|text_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|abbrev_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|debug_info_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|debug_line_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TEXT_END_LABEL
value|"Letext"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DATA_END_LABEL
value|"Ledata"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BSS_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BSS_END_LABEL
value|"Lebss"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INSN_LABEL_FMT
end_ifndef

begin_define
define|#
directive|define
name|INSN_LABEL_FMT
value|"LI%u_"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_BEGIN_LABEL
value|"LBB"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_END_LABEL
value|"LBE"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BODY_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BODY_BEGIN_LABEL
value|"Lbb"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BODY_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BODY_END_LABEL
value|"Lbe"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_CODE_LABEL
end_ifndef

begin_define
define|#
directive|define
name|LINE_CODE_LABEL
value|"LM"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEPARATE_LINE_CODE_LABEL
end_ifndef

begin_define
define|#
directive|define
name|SEPARATE_LINE_CODE_LABEL
value|"LSM"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Convert a reference to the assembler name of a C-level name.  This    macro has the same effect as ASM_OUTPUT_LABELREF, but copies to    a string rather than writing to a file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_NAME_TO_STRING
end_ifndef

begin_define
define|#
directive|define
name|ASM_NAME_TO_STRING
parameter_list|(
name|STR
parameter_list|,
name|NAME
parameter_list|)
define|\
value|do {							\       if ((NAME)[0] == '*')				\ 	dyn_string_append (STR, NAME + 1);		\       else						\ 	{						\ 	  char *newstr;					\ 	  STRIP_NAME_ENCODING (newstr, NAME);		\ 	  dyn_string_append (STR, user_label_prefix);	\ 	  dyn_string_append (STR, newstr);		\ 	}						\   }							\   while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Convert an integer constant expression into assembler syntax.  Addition    and subtraction are the only arithmetic that may appear in these    expressions.   This is an adaptation of output_addr_const in final.c.    Here, the target of the conversion is a string buffer.  We can't use    output_addr_const directly, because it writes to a file.  */
end_comment

begin_function
specifier|static
name|void
name|addr_const_to_string
parameter_list|(
name|str
parameter_list|,
name|x
parameter_list|)
name|dyn_string_t
name|str
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|char
name|buf1
index|[
literal|256
index|]
decl_stmt|;
name|restart
label|:
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|PC
case|:
if|if
condition|(
name|flag_pic
condition|)
name|dyn_string_append
argument_list|(
name|str
argument_list|,
literal|","
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|ASM_NAME_TO_STRING
argument_list|(
name|str
argument_list|,
name|XSTR
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf1
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_NAME_TO_STRING
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CODE_LABEL
case|:
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf1
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_NAME_TO_STRING
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|sprintf
argument_list|(
name|buf1
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
comment|/* This used to output parentheses around the expression, but that does           not work on the 386 (either ATT or BSD assembler).  */
name|addr_const_to_string
argument_list|(
name|str
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
comment|/* We can use %d if the number is one word and positive.  */
if|if
condition|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf1
argument_list|,
name|HOST_WIDE_INT_PRINT_DOUBLE_HEX
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|buf1
argument_list|,
name|HOST_WIDE_INT_PRINT_HEX
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf1
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|str
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't handle floating point constants; PRINT_OPERAND must 	   handle them.  */
name|output_operand_lossage
argument_list|(
literal|"floating constant misused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* Some assemblers need integer constants to appear last (eg masm).  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|addr_const_to_string
argument_list|(
name|str
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|dyn_string_append
argument_list|(
name|str
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|addr_const_to_string
argument_list|(
name|str
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_const_to_string
argument_list|(
name|str
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|dyn_string_append
argument_list|(
name|str
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|addr_const_to_string
argument_list|(
name|str
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MINUS
case|:
comment|/* Avoid outputting things like x-x or x+5-x, since some assemblers          can't handle that.  */
name|x
operator|=
name|simplify_subtraction
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MINUS
condition|)
goto|goto
name|restart
goto|;
name|addr_const_to_string
argument_list|(
name|str
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|str
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dyn_string_append
argument_list|(
name|str
argument_list|,
name|ASM_OPEN_PAREN
argument_list|)
expr_stmt|;
name|addr_const_to_string
argument_list|(
name|str
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dyn_string_append
argument_list|(
name|str
argument_list|,
name|ASM_CLOSE_PAREN
argument_list|)
expr_stmt|;
block|}
else|else
name|addr_const_to_string
argument_list|(
name|str
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZERO_EXTEND
case|:
case|case
name|SIGN_EXTEND
case|:
name|addr_const_to_string
argument_list|(
name|str
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|output_operand_lossage
argument_list|(
literal|"invalid expression as operand"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert an address constant to a string, and return a pointer to    a copy of the result, located on the heap.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|addr_to_string
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
name|dyn_string_t
name|ds
init|=
name|dyn_string_new
argument_list|(
literal|256
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|addr_const_to_string
argument_list|(
name|ds
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Return the dynamically allocated string, but free the      dyn_string_t itself.  */
name|s
operator|=
name|ds
operator|->
name|s
expr_stmt|;
name|free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Test if rtl node points to a pseudo register.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_pseudo_reg
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|REG
operator|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a reference to a type, with its const and volatile qualifiers    removed.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|type_main_variant
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* There really should be only one main variant among any group of variants       of a given type (and all of the MAIN_VARIANT values for all members of      the group should point to that one type) but sometimes the C front-end      messes this up for array types, so we work around that bug here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
while|while
condition|(
name|type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the given type node represents a tagged type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_tagged_type
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|QUAL_UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a DIE tag into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_tag_name
parameter_list|(
name|tag
parameter_list|)
specifier|register
name|unsigned
name|tag
decl_stmt|;
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DW_TAG_padding
case|:
return|return
literal|"DW_TAG_padding"
return|;
case|case
name|DW_TAG_array_type
case|:
return|return
literal|"DW_TAG_array_type"
return|;
case|case
name|DW_TAG_class_type
case|:
return|return
literal|"DW_TAG_class_type"
return|;
case|case
name|DW_TAG_entry_point
case|:
return|return
literal|"DW_TAG_entry_point"
return|;
case|case
name|DW_TAG_enumeration_type
case|:
return|return
literal|"DW_TAG_enumeration_type"
return|;
case|case
name|DW_TAG_formal_parameter
case|:
return|return
literal|"DW_TAG_formal_parameter"
return|;
case|case
name|DW_TAG_imported_declaration
case|:
return|return
literal|"DW_TAG_imported_declaration"
return|;
case|case
name|DW_TAG_label
case|:
return|return
literal|"DW_TAG_label"
return|;
case|case
name|DW_TAG_lexical_block
case|:
return|return
literal|"DW_TAG_lexical_block"
return|;
case|case
name|DW_TAG_member
case|:
return|return
literal|"DW_TAG_member"
return|;
case|case
name|DW_TAG_pointer_type
case|:
return|return
literal|"DW_TAG_pointer_type"
return|;
case|case
name|DW_TAG_reference_type
case|:
return|return
literal|"DW_TAG_reference_type"
return|;
case|case
name|DW_TAG_compile_unit
case|:
return|return
literal|"DW_TAG_compile_unit"
return|;
case|case
name|DW_TAG_string_type
case|:
return|return
literal|"DW_TAG_string_type"
return|;
case|case
name|DW_TAG_structure_type
case|:
return|return
literal|"DW_TAG_structure_type"
return|;
case|case
name|DW_TAG_subroutine_type
case|:
return|return
literal|"DW_TAG_subroutine_type"
return|;
case|case
name|DW_TAG_typedef
case|:
return|return
literal|"DW_TAG_typedef"
return|;
case|case
name|DW_TAG_union_type
case|:
return|return
literal|"DW_TAG_union_type"
return|;
case|case
name|DW_TAG_unspecified_parameters
case|:
return|return
literal|"DW_TAG_unspecified_parameters"
return|;
case|case
name|DW_TAG_variant
case|:
return|return
literal|"DW_TAG_variant"
return|;
case|case
name|DW_TAG_common_block
case|:
return|return
literal|"DW_TAG_common_block"
return|;
case|case
name|DW_TAG_common_inclusion
case|:
return|return
literal|"DW_TAG_common_inclusion"
return|;
case|case
name|DW_TAG_inheritance
case|:
return|return
literal|"DW_TAG_inheritance"
return|;
case|case
name|DW_TAG_inlined_subroutine
case|:
return|return
literal|"DW_TAG_inlined_subroutine"
return|;
case|case
name|DW_TAG_module
case|:
return|return
literal|"DW_TAG_module"
return|;
case|case
name|DW_TAG_ptr_to_member_type
case|:
return|return
literal|"DW_TAG_ptr_to_member_type"
return|;
case|case
name|DW_TAG_set_type
case|:
return|return
literal|"DW_TAG_set_type"
return|;
case|case
name|DW_TAG_subrange_type
case|:
return|return
literal|"DW_TAG_subrange_type"
return|;
case|case
name|DW_TAG_with_stmt
case|:
return|return
literal|"DW_TAG_with_stmt"
return|;
case|case
name|DW_TAG_access_declaration
case|:
return|return
literal|"DW_TAG_access_declaration"
return|;
case|case
name|DW_TAG_base_type
case|:
return|return
literal|"DW_TAG_base_type"
return|;
case|case
name|DW_TAG_catch_block
case|:
return|return
literal|"DW_TAG_catch_block"
return|;
case|case
name|DW_TAG_const_type
case|:
return|return
literal|"DW_TAG_const_type"
return|;
case|case
name|DW_TAG_constant
case|:
return|return
literal|"DW_TAG_constant"
return|;
case|case
name|DW_TAG_enumerator
case|:
return|return
literal|"DW_TAG_enumerator"
return|;
case|case
name|DW_TAG_file_type
case|:
return|return
literal|"DW_TAG_file_type"
return|;
case|case
name|DW_TAG_friend
case|:
return|return
literal|"DW_TAG_friend"
return|;
case|case
name|DW_TAG_namelist
case|:
return|return
literal|"DW_TAG_namelist"
return|;
case|case
name|DW_TAG_namelist_item
case|:
return|return
literal|"DW_TAG_namelist_item"
return|;
case|case
name|DW_TAG_packed_type
case|:
return|return
literal|"DW_TAG_packed_type"
return|;
case|case
name|DW_TAG_subprogram
case|:
return|return
literal|"DW_TAG_subprogram"
return|;
case|case
name|DW_TAG_template_type_param
case|:
return|return
literal|"DW_TAG_template_type_param"
return|;
case|case
name|DW_TAG_template_value_param
case|:
return|return
literal|"DW_TAG_template_value_param"
return|;
case|case
name|DW_TAG_thrown_type
case|:
return|return
literal|"DW_TAG_thrown_type"
return|;
case|case
name|DW_TAG_try_block
case|:
return|return
literal|"DW_TAG_try_block"
return|;
case|case
name|DW_TAG_variant_part
case|:
return|return
literal|"DW_TAG_variant_part"
return|;
case|case
name|DW_TAG_variable
case|:
return|return
literal|"DW_TAG_variable"
return|;
case|case
name|DW_TAG_volatile_type
case|:
return|return
literal|"DW_TAG_volatile_type"
return|;
case|case
name|DW_TAG_MIPS_loop
case|:
return|return
literal|"DW_TAG_MIPS_loop"
return|;
case|case
name|DW_TAG_format_label
case|:
return|return
literal|"DW_TAG_format_label"
return|;
case|case
name|DW_TAG_function_template
case|:
return|return
literal|"DW_TAG_function_template"
return|;
case|case
name|DW_TAG_class_template
case|:
return|return
literal|"DW_TAG_class_template"
return|;
default|default:
return|return
literal|"DW_TAG_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF attribute code into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_attr_name
parameter_list|(
name|attr
parameter_list|)
specifier|register
name|unsigned
name|attr
decl_stmt|;
block|{
switch|switch
condition|(
name|attr
condition|)
block|{
case|case
name|DW_AT_sibling
case|:
return|return
literal|"DW_AT_sibling"
return|;
case|case
name|DW_AT_location
case|:
return|return
literal|"DW_AT_location"
return|;
case|case
name|DW_AT_name
case|:
return|return
literal|"DW_AT_name"
return|;
case|case
name|DW_AT_ordering
case|:
return|return
literal|"DW_AT_ordering"
return|;
case|case
name|DW_AT_subscr_data
case|:
return|return
literal|"DW_AT_subscr_data"
return|;
case|case
name|DW_AT_byte_size
case|:
return|return
literal|"DW_AT_byte_size"
return|;
case|case
name|DW_AT_bit_offset
case|:
return|return
literal|"DW_AT_bit_offset"
return|;
case|case
name|DW_AT_bit_size
case|:
return|return
literal|"DW_AT_bit_size"
return|;
case|case
name|DW_AT_element_list
case|:
return|return
literal|"DW_AT_element_list"
return|;
case|case
name|DW_AT_stmt_list
case|:
return|return
literal|"DW_AT_stmt_list"
return|;
case|case
name|DW_AT_low_pc
case|:
return|return
literal|"DW_AT_low_pc"
return|;
case|case
name|DW_AT_high_pc
case|:
return|return
literal|"DW_AT_high_pc"
return|;
case|case
name|DW_AT_language
case|:
return|return
literal|"DW_AT_language"
return|;
case|case
name|DW_AT_member
case|:
return|return
literal|"DW_AT_member"
return|;
case|case
name|DW_AT_discr
case|:
return|return
literal|"DW_AT_discr"
return|;
case|case
name|DW_AT_discr_value
case|:
return|return
literal|"DW_AT_discr_value"
return|;
case|case
name|DW_AT_visibility
case|:
return|return
literal|"DW_AT_visibility"
return|;
case|case
name|DW_AT_import
case|:
return|return
literal|"DW_AT_import"
return|;
case|case
name|DW_AT_string_length
case|:
return|return
literal|"DW_AT_string_length"
return|;
case|case
name|DW_AT_common_reference
case|:
return|return
literal|"DW_AT_common_reference"
return|;
case|case
name|DW_AT_comp_dir
case|:
return|return
literal|"DW_AT_comp_dir"
return|;
case|case
name|DW_AT_const_value
case|:
return|return
literal|"DW_AT_const_value"
return|;
case|case
name|DW_AT_containing_type
case|:
return|return
literal|"DW_AT_containing_type"
return|;
case|case
name|DW_AT_default_value
case|:
return|return
literal|"DW_AT_default_value"
return|;
case|case
name|DW_AT_inline
case|:
return|return
literal|"DW_AT_inline"
return|;
case|case
name|DW_AT_is_optional
case|:
return|return
literal|"DW_AT_is_optional"
return|;
case|case
name|DW_AT_lower_bound
case|:
return|return
literal|"DW_AT_lower_bound"
return|;
case|case
name|DW_AT_producer
case|:
return|return
literal|"DW_AT_producer"
return|;
case|case
name|DW_AT_prototyped
case|:
return|return
literal|"DW_AT_prototyped"
return|;
case|case
name|DW_AT_return_addr
case|:
return|return
literal|"DW_AT_return_addr"
return|;
case|case
name|DW_AT_start_scope
case|:
return|return
literal|"DW_AT_start_scope"
return|;
case|case
name|DW_AT_stride_size
case|:
return|return
literal|"DW_AT_stride_size"
return|;
case|case
name|DW_AT_upper_bound
case|:
return|return
literal|"DW_AT_upper_bound"
return|;
case|case
name|DW_AT_abstract_origin
case|:
return|return
literal|"DW_AT_abstract_origin"
return|;
case|case
name|DW_AT_accessibility
case|:
return|return
literal|"DW_AT_accessibility"
return|;
case|case
name|DW_AT_address_class
case|:
return|return
literal|"DW_AT_address_class"
return|;
case|case
name|DW_AT_artificial
case|:
return|return
literal|"DW_AT_artificial"
return|;
case|case
name|DW_AT_base_types
case|:
return|return
literal|"DW_AT_base_types"
return|;
case|case
name|DW_AT_calling_convention
case|:
return|return
literal|"DW_AT_calling_convention"
return|;
case|case
name|DW_AT_count
case|:
return|return
literal|"DW_AT_count"
return|;
case|case
name|DW_AT_data_member_location
case|:
return|return
literal|"DW_AT_data_member_location"
return|;
case|case
name|DW_AT_decl_column
case|:
return|return
literal|"DW_AT_decl_column"
return|;
case|case
name|DW_AT_decl_file
case|:
return|return
literal|"DW_AT_decl_file"
return|;
case|case
name|DW_AT_decl_line
case|:
return|return
literal|"DW_AT_decl_line"
return|;
case|case
name|DW_AT_declaration
case|:
return|return
literal|"DW_AT_declaration"
return|;
case|case
name|DW_AT_discr_list
case|:
return|return
literal|"DW_AT_discr_list"
return|;
case|case
name|DW_AT_encoding
case|:
return|return
literal|"DW_AT_encoding"
return|;
case|case
name|DW_AT_external
case|:
return|return
literal|"DW_AT_external"
return|;
case|case
name|DW_AT_frame_base
case|:
return|return
literal|"DW_AT_frame_base"
return|;
case|case
name|DW_AT_friend
case|:
return|return
literal|"DW_AT_friend"
return|;
case|case
name|DW_AT_identifier_case
case|:
return|return
literal|"DW_AT_identifier_case"
return|;
case|case
name|DW_AT_macro_info
case|:
return|return
literal|"DW_AT_macro_info"
return|;
case|case
name|DW_AT_namelist_items
case|:
return|return
literal|"DW_AT_namelist_items"
return|;
case|case
name|DW_AT_priority
case|:
return|return
literal|"DW_AT_priority"
return|;
case|case
name|DW_AT_segment
case|:
return|return
literal|"DW_AT_segment"
return|;
case|case
name|DW_AT_specification
case|:
return|return
literal|"DW_AT_specification"
return|;
case|case
name|DW_AT_static_link
case|:
return|return
literal|"DW_AT_static_link"
return|;
case|case
name|DW_AT_type
case|:
return|return
literal|"DW_AT_type"
return|;
case|case
name|DW_AT_use_location
case|:
return|return
literal|"DW_AT_use_location"
return|;
case|case
name|DW_AT_variable_parameter
case|:
return|return
literal|"DW_AT_variable_parameter"
return|;
case|case
name|DW_AT_virtuality
case|:
return|return
literal|"DW_AT_virtuality"
return|;
case|case
name|DW_AT_vtable_elem_location
case|:
return|return
literal|"DW_AT_vtable_elem_location"
return|;
case|case
name|DW_AT_MIPS_fde
case|:
return|return
literal|"DW_AT_MIPS_fde"
return|;
case|case
name|DW_AT_MIPS_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_loop_begin"
return|;
case|case
name|DW_AT_MIPS_tail_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_tail_loop_begin"
return|;
case|case
name|DW_AT_MIPS_epilog_begin
case|:
return|return
literal|"DW_AT_MIPS_epilog_begin"
return|;
case|case
name|DW_AT_MIPS_loop_unroll_factor
case|:
return|return
literal|"DW_AT_MIPS_loop_unroll_factor"
return|;
case|case
name|DW_AT_MIPS_software_pipeline_depth
case|:
return|return
literal|"DW_AT_MIPS_software_pipeline_depth"
return|;
case|case
name|DW_AT_MIPS_linkage_name
case|:
return|return
literal|"DW_AT_MIPS_linkage_name"
return|;
case|case
name|DW_AT_MIPS_stride
case|:
return|return
literal|"DW_AT_MIPS_stride"
return|;
case|case
name|DW_AT_MIPS_abstract_name
case|:
return|return
literal|"DW_AT_MIPS_abstract_name"
return|;
case|case
name|DW_AT_MIPS_clone_origin
case|:
return|return
literal|"DW_AT_MIPS_clone_origin"
return|;
case|case
name|DW_AT_MIPS_has_inlines
case|:
return|return
literal|"DW_AT_MIPS_has_inlines"
return|;
case|case
name|DW_AT_sf_names
case|:
return|return
literal|"DW_AT_sf_names"
return|;
case|case
name|DW_AT_src_info
case|:
return|return
literal|"DW_AT_src_info"
return|;
case|case
name|DW_AT_mac_info
case|:
return|return
literal|"DW_AT_mac_info"
return|;
case|case
name|DW_AT_src_coords
case|:
return|return
literal|"DW_AT_src_coords"
return|;
case|case
name|DW_AT_body_begin
case|:
return|return
literal|"DW_AT_body_begin"
return|;
case|case
name|DW_AT_body_end
case|:
return|return
literal|"DW_AT_body_end"
return|;
default|default:
return|return
literal|"DW_AT_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF value form code into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_form_name
parameter_list|(
name|form
parameter_list|)
specifier|register
name|unsigned
name|form
decl_stmt|;
block|{
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
return|return
literal|"DW_FORM_addr"
return|;
case|case
name|DW_FORM_block2
case|:
return|return
literal|"DW_FORM_block2"
return|;
case|case
name|DW_FORM_block4
case|:
return|return
literal|"DW_FORM_block4"
return|;
case|case
name|DW_FORM_data2
case|:
return|return
literal|"DW_FORM_data2"
return|;
case|case
name|DW_FORM_data4
case|:
return|return
literal|"DW_FORM_data4"
return|;
case|case
name|DW_FORM_data8
case|:
return|return
literal|"DW_FORM_data8"
return|;
case|case
name|DW_FORM_string
case|:
return|return
literal|"DW_FORM_string"
return|;
case|case
name|DW_FORM_block
case|:
return|return
literal|"DW_FORM_block"
return|;
case|case
name|DW_FORM_block1
case|:
return|return
literal|"DW_FORM_block1"
return|;
case|case
name|DW_FORM_data1
case|:
return|return
literal|"DW_FORM_data1"
return|;
case|case
name|DW_FORM_flag
case|:
return|return
literal|"DW_FORM_flag"
return|;
case|case
name|DW_FORM_sdata
case|:
return|return
literal|"DW_FORM_sdata"
return|;
case|case
name|DW_FORM_strp
case|:
return|return
literal|"DW_FORM_strp"
return|;
case|case
name|DW_FORM_udata
case|:
return|return
literal|"DW_FORM_udata"
return|;
case|case
name|DW_FORM_ref_addr
case|:
return|return
literal|"DW_FORM_ref_addr"
return|;
case|case
name|DW_FORM_ref1
case|:
return|return
literal|"DW_FORM_ref1"
return|;
case|case
name|DW_FORM_ref2
case|:
return|return
literal|"DW_FORM_ref2"
return|;
case|case
name|DW_FORM_ref4
case|:
return|return
literal|"DW_FORM_ref4"
return|;
case|case
name|DW_FORM_ref8
case|:
return|return
literal|"DW_FORM_ref8"
return|;
case|case
name|DW_FORM_ref_udata
case|:
return|return
literal|"DW_FORM_ref_udata"
return|;
case|case
name|DW_FORM_indirect
case|:
return|return
literal|"DW_FORM_indirect"
return|;
default|default:
return|return
literal|"DW_FORM_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF stack opcode into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_stack_op_name
parameter_list|(
name|op
parameter_list|)
specifier|register
name|unsigned
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_addr
case|:
return|return
literal|"DW_OP_addr"
return|;
case|case
name|DW_OP_deref
case|:
return|return
literal|"DW_OP_deref"
return|;
case|case
name|DW_OP_const1u
case|:
return|return
literal|"DW_OP_const1u"
return|;
case|case
name|DW_OP_const1s
case|:
return|return
literal|"DW_OP_const1s"
return|;
case|case
name|DW_OP_const2u
case|:
return|return
literal|"DW_OP_const2u"
return|;
case|case
name|DW_OP_const2s
case|:
return|return
literal|"DW_OP_const2s"
return|;
case|case
name|DW_OP_const4u
case|:
return|return
literal|"DW_OP_const4u"
return|;
case|case
name|DW_OP_const4s
case|:
return|return
literal|"DW_OP_const4s"
return|;
case|case
name|DW_OP_const8u
case|:
return|return
literal|"DW_OP_const8u"
return|;
case|case
name|DW_OP_const8s
case|:
return|return
literal|"DW_OP_const8s"
return|;
case|case
name|DW_OP_constu
case|:
return|return
literal|"DW_OP_constu"
return|;
case|case
name|DW_OP_consts
case|:
return|return
literal|"DW_OP_consts"
return|;
case|case
name|DW_OP_dup
case|:
return|return
literal|"DW_OP_dup"
return|;
case|case
name|DW_OP_drop
case|:
return|return
literal|"DW_OP_drop"
return|;
case|case
name|DW_OP_over
case|:
return|return
literal|"DW_OP_over"
return|;
case|case
name|DW_OP_pick
case|:
return|return
literal|"DW_OP_pick"
return|;
case|case
name|DW_OP_swap
case|:
return|return
literal|"DW_OP_swap"
return|;
case|case
name|DW_OP_rot
case|:
return|return
literal|"DW_OP_rot"
return|;
case|case
name|DW_OP_xderef
case|:
return|return
literal|"DW_OP_xderef"
return|;
case|case
name|DW_OP_abs
case|:
return|return
literal|"DW_OP_abs"
return|;
case|case
name|DW_OP_and
case|:
return|return
literal|"DW_OP_and"
return|;
case|case
name|DW_OP_div
case|:
return|return
literal|"DW_OP_div"
return|;
case|case
name|DW_OP_minus
case|:
return|return
literal|"DW_OP_minus"
return|;
case|case
name|DW_OP_mod
case|:
return|return
literal|"DW_OP_mod"
return|;
case|case
name|DW_OP_mul
case|:
return|return
literal|"DW_OP_mul"
return|;
case|case
name|DW_OP_neg
case|:
return|return
literal|"DW_OP_neg"
return|;
case|case
name|DW_OP_not
case|:
return|return
literal|"DW_OP_not"
return|;
case|case
name|DW_OP_or
case|:
return|return
literal|"DW_OP_or"
return|;
case|case
name|DW_OP_plus
case|:
return|return
literal|"DW_OP_plus"
return|;
case|case
name|DW_OP_plus_uconst
case|:
return|return
literal|"DW_OP_plus_uconst"
return|;
case|case
name|DW_OP_shl
case|:
return|return
literal|"DW_OP_shl"
return|;
case|case
name|DW_OP_shr
case|:
return|return
literal|"DW_OP_shr"
return|;
case|case
name|DW_OP_shra
case|:
return|return
literal|"DW_OP_shra"
return|;
case|case
name|DW_OP_xor
case|:
return|return
literal|"DW_OP_xor"
return|;
case|case
name|DW_OP_bra
case|:
return|return
literal|"DW_OP_bra"
return|;
case|case
name|DW_OP_eq
case|:
return|return
literal|"DW_OP_eq"
return|;
case|case
name|DW_OP_ge
case|:
return|return
literal|"DW_OP_ge"
return|;
case|case
name|DW_OP_gt
case|:
return|return
literal|"DW_OP_gt"
return|;
case|case
name|DW_OP_le
case|:
return|return
literal|"DW_OP_le"
return|;
case|case
name|DW_OP_lt
case|:
return|return
literal|"DW_OP_lt"
return|;
case|case
name|DW_OP_ne
case|:
return|return
literal|"DW_OP_ne"
return|;
case|case
name|DW_OP_skip
case|:
return|return
literal|"DW_OP_skip"
return|;
case|case
name|DW_OP_lit0
case|:
return|return
literal|"DW_OP_lit0"
return|;
case|case
name|DW_OP_lit1
case|:
return|return
literal|"DW_OP_lit1"
return|;
case|case
name|DW_OP_lit2
case|:
return|return
literal|"DW_OP_lit2"
return|;
case|case
name|DW_OP_lit3
case|:
return|return
literal|"DW_OP_lit3"
return|;
case|case
name|DW_OP_lit4
case|:
return|return
literal|"DW_OP_lit4"
return|;
case|case
name|DW_OP_lit5
case|:
return|return
literal|"DW_OP_lit5"
return|;
case|case
name|DW_OP_lit6
case|:
return|return
literal|"DW_OP_lit6"
return|;
case|case
name|DW_OP_lit7
case|:
return|return
literal|"DW_OP_lit7"
return|;
case|case
name|DW_OP_lit8
case|:
return|return
literal|"DW_OP_lit8"
return|;
case|case
name|DW_OP_lit9
case|:
return|return
literal|"DW_OP_lit9"
return|;
case|case
name|DW_OP_lit10
case|:
return|return
literal|"DW_OP_lit10"
return|;
case|case
name|DW_OP_lit11
case|:
return|return
literal|"DW_OP_lit11"
return|;
case|case
name|DW_OP_lit12
case|:
return|return
literal|"DW_OP_lit12"
return|;
case|case
name|DW_OP_lit13
case|:
return|return
literal|"DW_OP_lit13"
return|;
case|case
name|DW_OP_lit14
case|:
return|return
literal|"DW_OP_lit14"
return|;
case|case
name|DW_OP_lit15
case|:
return|return
literal|"DW_OP_lit15"
return|;
case|case
name|DW_OP_lit16
case|:
return|return
literal|"DW_OP_lit16"
return|;
case|case
name|DW_OP_lit17
case|:
return|return
literal|"DW_OP_lit17"
return|;
case|case
name|DW_OP_lit18
case|:
return|return
literal|"DW_OP_lit18"
return|;
case|case
name|DW_OP_lit19
case|:
return|return
literal|"DW_OP_lit19"
return|;
case|case
name|DW_OP_lit20
case|:
return|return
literal|"DW_OP_lit20"
return|;
case|case
name|DW_OP_lit21
case|:
return|return
literal|"DW_OP_lit21"
return|;
case|case
name|DW_OP_lit22
case|:
return|return
literal|"DW_OP_lit22"
return|;
case|case
name|DW_OP_lit23
case|:
return|return
literal|"DW_OP_lit23"
return|;
case|case
name|DW_OP_lit24
case|:
return|return
literal|"DW_OP_lit24"
return|;
case|case
name|DW_OP_lit25
case|:
return|return
literal|"DW_OP_lit25"
return|;
case|case
name|DW_OP_lit26
case|:
return|return
literal|"DW_OP_lit26"
return|;
case|case
name|DW_OP_lit27
case|:
return|return
literal|"DW_OP_lit27"
return|;
case|case
name|DW_OP_lit28
case|:
return|return
literal|"DW_OP_lit28"
return|;
case|case
name|DW_OP_lit29
case|:
return|return
literal|"DW_OP_lit29"
return|;
case|case
name|DW_OP_lit30
case|:
return|return
literal|"DW_OP_lit30"
return|;
case|case
name|DW_OP_lit31
case|:
return|return
literal|"DW_OP_lit31"
return|;
case|case
name|DW_OP_reg0
case|:
return|return
literal|"DW_OP_reg0"
return|;
case|case
name|DW_OP_reg1
case|:
return|return
literal|"DW_OP_reg1"
return|;
case|case
name|DW_OP_reg2
case|:
return|return
literal|"DW_OP_reg2"
return|;
case|case
name|DW_OP_reg3
case|:
return|return
literal|"DW_OP_reg3"
return|;
case|case
name|DW_OP_reg4
case|:
return|return
literal|"DW_OP_reg4"
return|;
case|case
name|DW_OP_reg5
case|:
return|return
literal|"DW_OP_reg5"
return|;
case|case
name|DW_OP_reg6
case|:
return|return
literal|"DW_OP_reg6"
return|;
case|case
name|DW_OP_reg7
case|:
return|return
literal|"DW_OP_reg7"
return|;
case|case
name|DW_OP_reg8
case|:
return|return
literal|"DW_OP_reg8"
return|;
case|case
name|DW_OP_reg9
case|:
return|return
literal|"DW_OP_reg9"
return|;
case|case
name|DW_OP_reg10
case|:
return|return
literal|"DW_OP_reg10"
return|;
case|case
name|DW_OP_reg11
case|:
return|return
literal|"DW_OP_reg11"
return|;
case|case
name|DW_OP_reg12
case|:
return|return
literal|"DW_OP_reg12"
return|;
case|case
name|DW_OP_reg13
case|:
return|return
literal|"DW_OP_reg13"
return|;
case|case
name|DW_OP_reg14
case|:
return|return
literal|"DW_OP_reg14"
return|;
case|case
name|DW_OP_reg15
case|:
return|return
literal|"DW_OP_reg15"
return|;
case|case
name|DW_OP_reg16
case|:
return|return
literal|"DW_OP_reg16"
return|;
case|case
name|DW_OP_reg17
case|:
return|return
literal|"DW_OP_reg17"
return|;
case|case
name|DW_OP_reg18
case|:
return|return
literal|"DW_OP_reg18"
return|;
case|case
name|DW_OP_reg19
case|:
return|return
literal|"DW_OP_reg19"
return|;
case|case
name|DW_OP_reg20
case|:
return|return
literal|"DW_OP_reg20"
return|;
case|case
name|DW_OP_reg21
case|:
return|return
literal|"DW_OP_reg21"
return|;
case|case
name|DW_OP_reg22
case|:
return|return
literal|"DW_OP_reg22"
return|;
case|case
name|DW_OP_reg23
case|:
return|return
literal|"DW_OP_reg23"
return|;
case|case
name|DW_OP_reg24
case|:
return|return
literal|"DW_OP_reg24"
return|;
case|case
name|DW_OP_reg25
case|:
return|return
literal|"DW_OP_reg25"
return|;
case|case
name|DW_OP_reg26
case|:
return|return
literal|"DW_OP_reg26"
return|;
case|case
name|DW_OP_reg27
case|:
return|return
literal|"DW_OP_reg27"
return|;
case|case
name|DW_OP_reg28
case|:
return|return
literal|"DW_OP_reg28"
return|;
case|case
name|DW_OP_reg29
case|:
return|return
literal|"DW_OP_reg29"
return|;
case|case
name|DW_OP_reg30
case|:
return|return
literal|"DW_OP_reg30"
return|;
case|case
name|DW_OP_reg31
case|:
return|return
literal|"DW_OP_reg31"
return|;
case|case
name|DW_OP_breg0
case|:
return|return
literal|"DW_OP_breg0"
return|;
case|case
name|DW_OP_breg1
case|:
return|return
literal|"DW_OP_breg1"
return|;
case|case
name|DW_OP_breg2
case|:
return|return
literal|"DW_OP_breg2"
return|;
case|case
name|DW_OP_breg3
case|:
return|return
literal|"DW_OP_breg3"
return|;
case|case
name|DW_OP_breg4
case|:
return|return
literal|"DW_OP_breg4"
return|;
case|case
name|DW_OP_breg5
case|:
return|return
literal|"DW_OP_breg5"
return|;
case|case
name|DW_OP_breg6
case|:
return|return
literal|"DW_OP_breg6"
return|;
case|case
name|DW_OP_breg7
case|:
return|return
literal|"DW_OP_breg7"
return|;
case|case
name|DW_OP_breg8
case|:
return|return
literal|"DW_OP_breg8"
return|;
case|case
name|DW_OP_breg9
case|:
return|return
literal|"DW_OP_breg9"
return|;
case|case
name|DW_OP_breg10
case|:
return|return
literal|"DW_OP_breg10"
return|;
case|case
name|DW_OP_breg11
case|:
return|return
literal|"DW_OP_breg11"
return|;
case|case
name|DW_OP_breg12
case|:
return|return
literal|"DW_OP_breg12"
return|;
case|case
name|DW_OP_breg13
case|:
return|return
literal|"DW_OP_breg13"
return|;
case|case
name|DW_OP_breg14
case|:
return|return
literal|"DW_OP_breg14"
return|;
case|case
name|DW_OP_breg15
case|:
return|return
literal|"DW_OP_breg15"
return|;
case|case
name|DW_OP_breg16
case|:
return|return
literal|"DW_OP_breg16"
return|;
case|case
name|DW_OP_breg17
case|:
return|return
literal|"DW_OP_breg17"
return|;
case|case
name|DW_OP_breg18
case|:
return|return
literal|"DW_OP_breg18"
return|;
case|case
name|DW_OP_breg19
case|:
return|return
literal|"DW_OP_breg19"
return|;
case|case
name|DW_OP_breg20
case|:
return|return
literal|"DW_OP_breg20"
return|;
case|case
name|DW_OP_breg21
case|:
return|return
literal|"DW_OP_breg21"
return|;
case|case
name|DW_OP_breg22
case|:
return|return
literal|"DW_OP_breg22"
return|;
case|case
name|DW_OP_breg23
case|:
return|return
literal|"DW_OP_breg23"
return|;
case|case
name|DW_OP_breg24
case|:
return|return
literal|"DW_OP_breg24"
return|;
case|case
name|DW_OP_breg25
case|:
return|return
literal|"DW_OP_breg25"
return|;
case|case
name|DW_OP_breg26
case|:
return|return
literal|"DW_OP_breg26"
return|;
case|case
name|DW_OP_breg27
case|:
return|return
literal|"DW_OP_breg27"
return|;
case|case
name|DW_OP_breg28
case|:
return|return
literal|"DW_OP_breg28"
return|;
case|case
name|DW_OP_breg29
case|:
return|return
literal|"DW_OP_breg29"
return|;
case|case
name|DW_OP_breg30
case|:
return|return
literal|"DW_OP_breg30"
return|;
case|case
name|DW_OP_breg31
case|:
return|return
literal|"DW_OP_breg31"
return|;
case|case
name|DW_OP_regx
case|:
return|return
literal|"DW_OP_regx"
return|;
case|case
name|DW_OP_fbreg
case|:
return|return
literal|"DW_OP_fbreg"
return|;
case|case
name|DW_OP_bregx
case|:
return|return
literal|"DW_OP_bregx"
return|;
case|case
name|DW_OP_piece
case|:
return|return
literal|"DW_OP_piece"
return|;
case|case
name|DW_OP_deref_size
case|:
return|return
literal|"DW_OP_deref_size"
return|;
case|case
name|DW_OP_xderef_size
case|:
return|return
literal|"DW_OP_xderef_size"
return|;
case|case
name|DW_OP_nop
case|:
return|return
literal|"DW_OP_nop"
return|;
default|default:
return|return
literal|"OP_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF type code into its string name.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char * dwarf_type_encoding_name (enc)      register unsigned enc; {   switch (enc)     {     case DW_ATE_address:       return "DW_ATE_address";     case DW_ATE_boolean:       return "DW_ATE_boolean";     case DW_ATE_complex_float:       return "DW_ATE_complex_float";     case DW_ATE_float:       return "DW_ATE_float";     case DW_ATE_signed:       return "DW_ATE_signed";     case DW_ATE_signed_char:       return "DW_ATE_signed_char";     case DW_ATE_unsigned:       return "DW_ATE_unsigned";     case DW_ATE_unsigned_char:       return "DW_ATE_unsigned_char";     default:       return "DW_ATE_<unknown>";     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Determine the "ultimate origin" of a decl.  The decl may be an inlined    instance of an inlined instance of a decl which is local to an inline    function, so we have to trace all of the way back through the origin chain    to find out what sort of node actually served as the original seed for the    given block.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_ultimate_origin
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|DECL_FROM_INLINE
argument_list|(
name|DECL_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
comment|/* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the        most distant ancestor, this should never happen.  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine the "ultimate origin" of a block.  The block may be an inlined    instance of an inlined instance of a block which is local to an inline    function, so we have to trace all of the way back through the origin chain    to find out what sort of node actually served as the original seed for the    given block.  */
end_comment

begin_function
specifier|static
name|tree
name|block_ultimate_origin
parameter_list|(
name|block
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
block|{
specifier|register
name|tree
name|immediate_origin
init|=
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|immediate_origin
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
else|else
block|{
specifier|register
name|tree
name|ret_val
decl_stmt|;
specifier|register
name|tree
name|lookahead
init|=
name|immediate_origin
decl_stmt|;
do|do
block|{
name|ret_val
operator|=
name|lookahead
expr_stmt|;
name|lookahead
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|ret_val
argument_list|)
operator|==
name|BLOCK
operator|)
condition|?
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|ret_val
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|lookahead
operator|!=
name|NULL
operator|&&
name|lookahead
operator|!=
name|ret_val
condition|)
do|;
return|return
name|ret_val
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get the class to which DECL belongs, if any.  In g++, the DECL_CONTEXT    of a virtual function may refer to a base class, so we check the 'this'    parameter.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_class_context
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|context
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|context
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an attribute/value pair to a DIE */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_dwarf_attr
parameter_list|(
name|die
parameter_list|,
name|attr
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|dw_attr_ref
name|attr
decl_stmt|;
block|{
if|if
condition|(
name|die
operator|!=
name|NULL
operator|&&
name|attr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|die
operator|->
name|die_attr
operator|==
name|NULL
condition|)
block|{
name|die
operator|->
name|die_attr
operator|=
name|attr
expr_stmt|;
name|die
operator|->
name|die_attr_last
operator|=
name|attr
expr_stmt|;
block|}
else|else
block|{
name|die
operator|->
name|die_attr_last
operator|->
name|dw_attr_next
operator|=
name|attr
expr_stmt|;
name|die
operator|->
name|die_attr_last
operator|=
name|attr
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add a flag value attribute to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_flag
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|unsigned
name|flag
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_flag
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_flag
operator|=
name|flag
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a signed integer attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_int
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|int_val
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|long
name|int
name|int_val
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_const
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_int
operator|=
name|int_val
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an unsigned integer attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_unsigned
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|unsigned_val
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|unsigned
name|long
name|unsigned_val
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_unsigned_const
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
operator|=
name|unsigned_val
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an unsigned double integer attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_long_long
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|val_hi
parameter_list|,
name|val_low
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|unsigned
name|long
name|val_hi
decl_stmt|;
specifier|register
name|unsigned
name|long
name|val_low
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_long_long
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
operator|=
name|val_hi
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
operator|=
name|val_low
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a floating point attribute value to a DIE and return it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_float
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|length
parameter_list|,
name|array
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|unsigned
name|length
decl_stmt|;
specifier|register
name|long
modifier|*
name|array
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_float
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|array
operator|=
name|array
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a string attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_string
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|str
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_str
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|=
name|xstrdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a DIE reference attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_die_ref
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|targ_die
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|dw_die_ref
name|targ_die
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_die_ref
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|=
name|targ_die
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an FDE reference attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_fde_ref
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|targ_fde
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|unsigned
name|targ_fde
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_fde_ref
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_fde_index
operator|=
name|targ_fde
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a location description attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_loc
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|loc
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|dw_loc_descr_ref
name|loc
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_loc
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc
operator|=
name|loc
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an address constant attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_addr
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|addr
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_addr
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_addr
operator|=
name|addr
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a label identifier attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_lbl_id
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|lbl_id
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|char
modifier|*
name|lbl_id
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_lbl_id
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
operator|=
name|xstrdup
argument_list|(
name|lbl_id
argument_list|)
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a section offset attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_lbl_offset
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|label
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|char
modifier|*
name|label
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_lbl_offset
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
operator|=
name|label
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Test if die refers to an external subroutine.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_extern_subr_die
parameter_list|(
name|die
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|a
decl_stmt|;
specifier|register
name|int
name|is_subr
init|=
name|FALSE
decl_stmt|;
specifier|register
name|int
name|is_extern
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|die
operator|!=
name|NULL
operator|&&
name|die
operator|->
name|die_tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
name|is_subr
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
control|)
block|{
if|if
condition|(
name|a
operator|->
name|dw_attr
operator|==
name|DW_AT_external
operator|&&
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|==
name|dw_val_class_flag
operator|&&
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_flag
operator|!=
literal|0
condition|)
block|{
name|is_extern
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|is_subr
operator|&&
name|is_extern
return|;
block|}
end_function

begin_comment
comment|/* Get the attribute of type attr_kind.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_attr_ref
name|get_AT
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|a
decl_stmt|;
specifier|register
name|dw_die_ref
name|spec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|die
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
control|)
block|{
if|if
condition|(
name|a
operator|->
name|dw_attr
operator|==
name|attr_kind
condition|)
return|return
name|a
return|;
if|if
condition|(
name|a
operator|->
name|dw_attr
operator|==
name|DW_AT_specification
operator|||
name|a
operator|->
name|dw_attr
operator|==
name|DW_AT_abstract_origin
condition|)
name|spec
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
expr_stmt|;
block|}
if|if
condition|(
name|spec
condition|)
return|return
name|get_AT
argument_list|(
name|spec
argument_list|,
name|attr_kind
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the "low pc" attribute value, typically associated with    a subprogram DIE.  Return null if the "low pc" attribute is    either not prsent, or if it cannot be represented as an    assembler label identifier.  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|get_AT_low_pc
parameter_list|(
name|die
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|&&
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|==
name|dw_val_class_lbl_id
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the "high pc" attribute value, typically associated with    a subprogram DIE.  Return null if the "high pc" attribute is    either not prsent, or if it cannot be represented as an    assembler label identifier.  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|get_AT_hi_pc
parameter_list|(
name|die
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|DW_AT_high_pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|&&
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|==
name|dw_val_class_lbl_id
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the string attribute designated by ATTR_KIND, or    NULL if it is not present.  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|get_AT_string
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|&&
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|==
name|dw_val_class_str
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the flag attribute designated by ATTR_KIND, or -1    if it is not present.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|get_AT_flag
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|&&
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|==
name|dw_val_class_flag
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_flag
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the unsigned attribute designated by ATTR_KIND, or 0    if it is not present.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|get_AT_unsigned
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|&&
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|==
name|dw_val_class_unsigned_const
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_c_family
parameter_list|()
block|{
specifier|register
name|unsigned
name|lang
init|=
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
decl_stmt|;
return|return
operator|(
name|lang
operator|==
name|DW_LANG_C
operator|||
name|lang
operator|==
name|DW_LANG_C89
operator|||
name|lang
operator|==
name|DW_LANG_C_plus_plus
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_fortran
parameter_list|()
block|{
specifier|register
name|unsigned
name|lang
init|=
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
decl_stmt|;
return|return
operator|(
name|lang
operator|==
name|DW_LANG_Fortran77
operator|||
name|lang
operator|==
name|DW_LANG_Fortran90
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove the specified attribute if present.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|remove_AT
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|a
decl_stmt|;
specifier|register
name|dw_attr_ref
name|removed
init|=
name|NULL
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|die
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|die
operator|->
name|die_attr
operator|->
name|dw_attr
operator|==
name|attr_kind
condition|)
block|{
name|removed
operator|=
name|die
operator|->
name|die_attr
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_attr_last
operator|==
name|die
operator|->
name|die_attr
condition|)
name|die
operator|->
name|die_attr_last
operator|=
name|NULL
expr_stmt|;
name|die
operator|->
name|die_attr
operator|=
name|die
operator|->
name|die_attr
operator|->
name|dw_attr_next
expr_stmt|;
block|}
else|else
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
init|;
name|a
operator|->
name|dw_attr_next
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
control|)
if|if
condition|(
name|a
operator|->
name|dw_attr_next
operator|->
name|dw_attr
operator|==
name|attr_kind
condition|)
block|{
name|removed
operator|=
name|a
operator|->
name|dw_attr_next
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_attr_last
operator|==
name|a
operator|->
name|dw_attr_next
condition|)
name|die
operator|->
name|die_attr_last
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|dw_attr_next
operator|=
name|a
operator|->
name|dw_attr_next
operator|->
name|dw_attr_next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|removed
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|removed
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Discard the children of this DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|remove_children
parameter_list|(
name|die
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|child_die
init|=
name|die
operator|->
name|die_child
decl_stmt|;
name|die
operator|->
name|die_child
operator|=
name|NULL
expr_stmt|;
name|die
operator|->
name|die_child_last
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|child_die
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|dw_die_ref
name|tmp_die
init|=
name|child_die
decl_stmt|;
specifier|register
name|dw_attr_ref
name|a
decl_stmt|;
name|child_die
operator|=
name|child_die
operator|->
name|die_sib
expr_stmt|;
for|for
control|(
name|a
operator|=
name|tmp_die
operator|->
name|die_attr
init|;
name|a
operator|!=
name|NULL
condition|;
control|)
block|{
specifier|register
name|dw_attr_ref
name|tmp_a
init|=
name|a
decl_stmt|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
expr_stmt|;
name|free
argument_list|(
name|tmp_a
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tmp_die
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a child DIE below its parent.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_child_die
parameter_list|(
name|die
parameter_list|,
name|child_die
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|dw_die_ref
name|child_die
decl_stmt|;
block|{
if|if
condition|(
name|die
operator|!=
name|NULL
operator|&&
name|child_die
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|die
operator|==
name|child_die
condition|)
name|abort
argument_list|()
expr_stmt|;
name|child_die
operator|->
name|die_parent
operator|=
name|die
expr_stmt|;
name|child_die
operator|->
name|die_sib
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_child
operator|==
name|NULL
condition|)
block|{
name|die
operator|->
name|die_child
operator|=
name|child_die
expr_stmt|;
name|die
operator|->
name|die_child_last
operator|=
name|child_die
expr_stmt|;
block|}
else|else
block|{
name|die
operator|->
name|die_child_last
operator|->
name|die_sib
operator|=
name|child_die
expr_stmt|;
name|die
operator|->
name|die_child_last
operator|=
name|child_die
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to a newly created DIE node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|new_die
parameter_list|(
name|tag_value
parameter_list|,
name|parent_die
parameter_list|)
specifier|register
name|enum
name|dwarf_tag
name|tag_value
decl_stmt|;
specifier|register
name|dw_die_ref
name|parent_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|die
init|=
operator|(
name|dw_die_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|die_node
argument_list|)
argument_list|)
decl_stmt|;
name|die
operator|->
name|die_tag
operator|=
name|tag_value
expr_stmt|;
name|die
operator|->
name|die_abbrev
operator|=
literal|0
expr_stmt|;
name|die
operator|->
name|die_offset
operator|=
literal|0
expr_stmt|;
name|die
operator|->
name|die_child
operator|=
name|NULL
expr_stmt|;
name|die
operator|->
name|die_parent
operator|=
name|NULL
expr_stmt|;
name|die
operator|->
name|die_sib
operator|=
name|NULL
expr_stmt|;
name|die
operator|->
name|die_child_last
operator|=
name|NULL
expr_stmt|;
name|die
operator|->
name|die_attr
operator|=
name|NULL
expr_stmt|;
name|die
operator|->
name|die_attr_last
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|parent_die
operator|!=
name|NULL
condition|)
name|add_child_die
argument_list|(
name|parent_die
argument_list|,
name|die
argument_list|)
expr_stmt|;
else|else
block|{
name|limbo_die_node
modifier|*
name|limbo_node
decl_stmt|;
name|limbo_node
operator|=
operator|(
name|limbo_die_node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|limbo_die_node
argument_list|)
argument_list|)
expr_stmt|;
name|limbo_node
operator|->
name|die
operator|=
name|die
expr_stmt|;
name|limbo_node
operator|->
name|next
operator|=
name|limbo_die_list
expr_stmt|;
name|limbo_die_list
operator|=
name|limbo_node
expr_stmt|;
block|}
return|return
name|die
return|;
block|}
end_function

begin_comment
comment|/* Return the DIE associated with the given type specifier.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|lookup_type_die
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
return|return
operator|(
name|dw_die_ref
operator|)
name|TYPE_SYMTAB_POINTER
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Equate a DIE to a given type specifier.  */
end_comment

begin_function
specifier|static
name|void
name|equate_type_number_to_die
parameter_list|(
name|type
parameter_list|,
name|type_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|type_die
decl_stmt|;
block|{
name|TYPE_SYMTAB_POINTER
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|type_die
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the DIE associated with a given declaration.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|lookup_decl_die
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|unsigned
name|decl_id
init|=
name|DECL_UID
argument_list|(
name|decl
argument_list|)
decl_stmt|;
return|return
operator|(
name|decl_id
operator|<
name|decl_die_table_in_use
condition|?
name|decl_die_table
index|[
name|decl_id
index|]
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Equate a DIE to a particular declaration.  */
end_comment

begin_function
specifier|static
name|void
name|equate_decl_number_to_die
parameter_list|(
name|decl
parameter_list|,
name|decl_die
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|dw_die_ref
name|decl_die
decl_stmt|;
block|{
specifier|register
name|unsigned
name|decl_id
init|=
name|DECL_UID
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|num_allocated
decl_stmt|;
if|if
condition|(
name|decl_id
operator|>=
name|decl_die_table_allocated
condition|)
block|{
name|num_allocated
operator|=
operator|(
operator|(
name|decl_id
operator|+
literal|1
operator|+
name|DECL_DIE_TABLE_INCREMENT
operator|-
literal|1
operator|)
operator|/
name|DECL_DIE_TABLE_INCREMENT
operator|)
operator|*
name|DECL_DIE_TABLE_INCREMENT
expr_stmt|;
name|decl_die_table
operator|=
operator|(
name|dw_die_ref
operator|*
operator|)
name|xrealloc
argument_list|(
name|decl_die_table
argument_list|,
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
operator|*
name|num_allocated
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|decl_die_table
index|[
name|decl_die_table_allocated
index|]
argument_list|,
operator|(
name|num_allocated
operator|-
name|decl_die_table_allocated
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|decl_die_table_allocated
operator|=
name|num_allocated
expr_stmt|;
block|}
if|if
condition|(
name|decl_id
operator|>=
name|decl_die_table_in_use
condition|)
name|decl_die_table_in_use
operator|=
operator|(
name|decl_id
operator|+
literal|1
operator|)
expr_stmt|;
name|decl_die_table
index|[
name|decl_id
index|]
operator|=
name|decl_die
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a newly allocated location description.  Location    descriptions are simple expression terms that can be strung    together to form more complicated location (address) descriptions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_loc_descr_ref
name|new_loc_descr
parameter_list|(
name|op
parameter_list|,
name|oprnd1
parameter_list|,
name|oprnd2
parameter_list|)
specifier|register
name|enum
name|dwarf_location_atom
name|op
decl_stmt|;
specifier|register
name|unsigned
name|long
name|oprnd1
decl_stmt|;
specifier|register
name|unsigned
name|long
name|oprnd2
decl_stmt|;
block|{
specifier|register
name|dw_loc_descr_ref
name|descr
init|=
operator|(
name|dw_loc_descr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_loc_descr_node
argument_list|)
argument_list|)
decl_stmt|;
name|descr
operator|->
name|dw_loc_next
operator|=
name|NULL
expr_stmt|;
name|descr
operator|->
name|dw_loc_opc
operator|=
name|op
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_unsigned_const
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
operator|=
name|oprnd1
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd2
operator|.
name|val_class
operator|=
name|dw_val_class_unsigned_const
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd2
operator|.
name|v
operator|.
name|val_unsigned
operator|=
name|oprnd2
expr_stmt|;
return|return
name|descr
return|;
block|}
end_function

begin_comment
comment|/* Add a location description term to a location description expression.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_loc_descr
parameter_list|(
name|list_head
parameter_list|,
name|descr
parameter_list|)
specifier|register
name|dw_loc_descr_ref
modifier|*
name|list_head
decl_stmt|;
specifier|register
name|dw_loc_descr_ref
name|descr
decl_stmt|;
block|{
specifier|register
name|dw_loc_descr_ref
modifier|*
name|d
decl_stmt|;
comment|/* Find the end of the chain.  */
for|for
control|(
name|d
operator|=
name|list_head
init|;
operator|(
operator|*
name|d
operator|)
operator|!=
name|NULL
condition|;
name|d
operator|=
operator|&
operator|(
operator|*
name|d
operator|)
operator|->
name|dw_loc_next
control|)
empty_stmt|;
operator|*
name|d
operator|=
name|descr
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keep track of the number of spaces used to indent the    output of the debugging routines that print the structure of    the DIE internal representation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_indent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indent the line the number of spaces given by print_indent.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|print_spaces
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%*s"
argument_list|,
name|print_indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the information associated with a given DIE, and its children.    This routine is a debugging aid only.  */
end_comment

begin_function
specifier|static
name|void
name|print_die
parameter_list|(
name|die
parameter_list|,
name|outfile
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|a
decl_stmt|;
specifier|register
name|dw_die_ref
name|c
decl_stmt|;
name|print_spaces
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"DIE %4lu: %s\n"
argument_list|,
name|die
operator|->
name|die_offset
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|die_tag
argument_list|)
argument_list|)
expr_stmt|;
name|print_spaces
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  abbrev id: %lu"
argument_list|,
name|die
operator|->
name|die_abbrev
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" offset: %lu\n"
argument_list|,
name|die
operator|->
name|die_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
control|)
block|{
name|print_spaces
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  %s: "
argument_list|,
name|dwarf_attr_name
argument_list|(
name|a
operator|->
name|dw_attr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"location descriptor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_const
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%ld"
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_unsigned_const
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%lu"
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_long_long
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"constant (%lu,%lu)"
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_float
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"floating-point constant"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_flag
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%u"
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_flag
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_die_ref
case|:
if|if
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"die -> %lu"
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|->
name|die_offset
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"die -><null>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_lbl_id
case|:
case|case
name|dw_val_class_lbl_offset
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"label: %s"
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_str
case|:
if|if
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\"%s\""
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"<null>"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
condition|)
block|{
name|print_indent
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|print_die
argument_list|(
name|c
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_indent
operator|-=
literal|4
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the contents of the source code line number correspondence table.    This routine is a debugging aid only.  */
end_comment

begin_function
specifier|static
name|void
name|print_dwarf_line_table
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
specifier|register
name|unsigned
name|i
decl_stmt|;
specifier|register
name|dw_line_info_ref
name|line_info
decl_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n\nDWARF source line information\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|line_info_table_in_use
condition|;
operator|++
name|i
control|)
block|{
name|line_info
operator|=
operator|&
name|line_info_table
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%5d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%-20s"
argument_list|,
name|file_table
index|[
name|line_info
operator|->
name|dw_file_num
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%6ld"
argument_list|,
name|line_info
operator|->
name|dw_line_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the information collected for a given DIE.  */
end_comment

begin_function
name|void
name|debug_dwarf_die
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|print_die
argument_list|(
name|die
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print all DWARF information collected for the compilation unit.    This routine is a debugging aid only.  */
end_comment

begin_function
name|void
name|debug_dwarf
parameter_list|()
block|{
name|print_indent
operator|=
literal|0
expr_stmt|;
name|print_die
argument_list|(
name|comp_unit_die
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|print_dwarf_line_table
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Traverse the DIE, and add a sibling attribute if it may have the    effect of speeding up access to siblings.  To save some space,    avoid generating sibling attributes for DIE's without children.  */
end_comment

begin_function
specifier|static
name|void
name|add_sibling_attributes
parameter_list|(
name|die
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|c
decl_stmt|;
specifier|register
name|dw_attr_ref
name|attr
decl_stmt|;
if|if
condition|(
name|die
operator|!=
name|comp_unit_die
operator|&&
name|die
operator|->
name|die_child
operator|!=
name|NULL
condition|)
block|{
name|attr
operator|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|DW_AT_sibling
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_die_ref
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|=
name|die
operator|->
name|die_sib
expr_stmt|;
comment|/* Add the sibling link to the front of the attribute list.  */
name|attr
operator|->
name|dw_attr_next
operator|=
name|die
operator|->
name|die_attr
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_attr
operator|==
name|NULL
condition|)
name|die
operator|->
name|die_attr_last
operator|=
name|attr
expr_stmt|;
name|die
operator|->
name|die_attr
operator|=
name|attr
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|add_sibling_attributes
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The format of each DIE (and its attribute value pairs)    is encoded in an abbreviation table.  This routine builds the    abbreviation table and assigns a unique abbreviation id for    each abbreviation entry.  The children of each die are visited    recursively.  */
end_comment

begin_function
specifier|static
name|void
name|build_abbrev_table
parameter_list|(
name|die
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|abbrev_id
decl_stmt|;
specifier|register
name|unsigned
name|long
name|n_alloc
decl_stmt|;
specifier|register
name|dw_die_ref
name|c
decl_stmt|;
specifier|register
name|dw_attr_ref
name|d_attr
decl_stmt|,
name|a_attr
decl_stmt|;
for|for
control|(
name|abbrev_id
operator|=
literal|1
init|;
name|abbrev_id
operator|<
name|abbrev_die_table_in_use
condition|;
operator|++
name|abbrev_id
control|)
block|{
specifier|register
name|dw_die_ref
name|abbrev
init|=
name|abbrev_die_table
index|[
name|abbrev_id
index|]
decl_stmt|;
if|if
condition|(
name|abbrev
operator|->
name|die_tag
operator|==
name|die
operator|->
name|die_tag
condition|)
block|{
if|if
condition|(
operator|(
name|abbrev
operator|->
name|die_child
operator|!=
name|NULL
operator|)
operator|==
operator|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
operator|)
condition|)
block|{
name|a_attr
operator|=
name|abbrev
operator|->
name|die_attr
expr_stmt|;
name|d_attr
operator|=
name|die
operator|->
name|die_attr
expr_stmt|;
while|while
condition|(
name|a_attr
operator|!=
name|NULL
operator|&&
name|d_attr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|a_attr
operator|->
name|dw_attr
operator|!=
name|d_attr
operator|->
name|dw_attr
operator|)
operator|||
operator|(
name|value_format
argument_list|(
operator|&
name|a_attr
operator|->
name|dw_attr_val
argument_list|)
operator|!=
name|value_format
argument_list|(
operator|&
name|d_attr
operator|->
name|dw_attr_val
argument_list|)
operator|)
condition|)
break|break;
name|a_attr
operator|=
name|a_attr
operator|->
name|dw_attr_next
expr_stmt|;
name|d_attr
operator|=
name|d_attr
operator|->
name|dw_attr_next
expr_stmt|;
block|}
if|if
condition|(
name|a_attr
operator|==
name|NULL
operator|&&
name|d_attr
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|abbrev_id
operator|>=
name|abbrev_die_table_in_use
condition|)
block|{
if|if
condition|(
name|abbrev_die_table_in_use
operator|>=
name|abbrev_die_table_allocated
condition|)
block|{
name|n_alloc
operator|=
name|abbrev_die_table_allocated
operator|+
name|ABBREV_DIE_TABLE_INCREMENT
expr_stmt|;
name|abbrev_die_table
operator|=
operator|(
name|dw_die_ref
operator|*
operator|)
name|xrealloc
argument_list|(
name|abbrev_die_table
argument_list|,
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
operator|*
name|n_alloc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|abbrev_die_table
index|[
name|abbrev_die_table_allocated
index|]
argument_list|,
operator|(
name|n_alloc
operator|-
name|abbrev_die_table_allocated
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|abbrev_die_table_allocated
operator|=
name|n_alloc
expr_stmt|;
block|}
operator|++
name|abbrev_die_table_in_use
expr_stmt|;
name|abbrev_die_table
index|[
name|abbrev_id
index|]
operator|=
name|die
expr_stmt|;
block|}
name|die
operator|->
name|die_abbrev
operator|=
name|abbrev_id
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|build_abbrev_table
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the size of a string, including the null byte.     This used to treat backslashes as escapes, and hence they were not included    in the count.  However, that conflicts with what ASM_OUTPUT_ASCII does,    which treats a backslash as a backslash, escaping it if necessary, and hence    we must include them in the count.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_string
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a location descriptor.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_loc_descr
parameter_list|(
name|loc
parameter_list|)
specifier|register
name|dw_loc_descr_ref
name|loc
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|size
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|loc
operator|->
name|dw_loc_opc
condition|)
block|{
case|case
name|DW_OP_addr
case|:
name|size
operator|+=
name|PTR_SIZE
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
case|case
name|DW_OP_const1s
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
case|case
name|DW_OP_const2s
case|:
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
case|case
name|DW_OP_const4s
case|:
name|size
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
case|case
name|DW_OP_const8s
case|:
name|size
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_pick
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_skip
case|:
case|case
name|DW_OP_bra
case|:
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_fbreg
case|:
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd2
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_piece
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_deref_size
case|:
case|case
name|DW_OP_xderef_size
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a series of location descriptors.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_locs
parameter_list|(
name|loc
parameter_list|)
specifier|register
name|dw_loc_descr_ref
name|loc
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|loc
operator|!=
name|NULL
condition|;
name|loc
operator|=
name|loc
operator|->
name|dw_loc_next
control|)
name|size
operator|+=
name|size_of_loc_descr
argument_list|(
name|loc
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the power-of-two number of bytes necessary to represent VALUE.  */
end_comment

begin_function
specifier|static
name|int
name|constant_size
parameter_list|(
name|value
parameter_list|)
name|long
name|unsigned
name|value
decl_stmt|;
block|{
name|int
name|log
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|log
operator|=
literal|0
expr_stmt|;
else|else
name|log
operator|=
name|floor_log2
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|log
operator|=
name|log
operator|/
literal|8
expr_stmt|;
name|log
operator|=
literal|1
operator|<<
operator|(
name|floor_log2
argument_list|(
name|log
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a DIE, as it is represented in the    .debug_info section.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_die
parameter_list|(
name|die
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|size
init|=
literal|0
decl_stmt|;
specifier|register
name|dw_attr_ref
name|a
decl_stmt|;
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|die
operator|->
name|die_abbrev
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
control|)
block|{
switch|switch
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
name|size
operator|+=
name|PTR_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc
case|:
block|{
specifier|register
name|unsigned
name|long
name|lsize
init|=
name|size_of_locs
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc
argument_list|)
decl_stmt|;
comment|/* Block length.  */
name|size
operator|+=
name|constant_size
argument_list|(
name|lsize
argument_list|)
expr_stmt|;
name|size
operator|+=
name|lsize
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_const
case|:
name|size
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|dw_val_class_unsigned_const
case|:
name|size
operator|+=
name|constant_size
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_long_long
case|:
name|size
operator|+=
literal|1
operator|+
literal|8
expr_stmt|;
comment|/* block */
break|break;
case|case
name|dw_val_class_float
case|:
name|size
operator|+=
literal|1
operator|+
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|length
operator|*
literal|4
expr_stmt|;
comment|/* block */
break|break;
case|case
name|dw_val_class_flag
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|dw_val_class_die_ref
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_fde_ref
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_lbl_id
case|:
name|size
operator|+=
name|PTR_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_lbl_offset
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_str
case|:
name|size
operator|+=
name|size_of_string
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Size the debugging information associated with a given DIE.    Visits the DIE's children recursively.  Updates the global    variable next_die_offset, on each time through.  Uses the    current value of next_die_offset to update the die_offset    field in each DIE.  */
end_comment

begin_function
specifier|static
name|void
name|calc_die_sizes
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|c
decl_stmt|;
name|die
operator|->
name|die_offset
operator|=
name|next_die_offset
expr_stmt|;
name|next_die_offset
operator|+=
name|size_of_die
argument_list|(
name|die
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|calc_die_sizes
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
condition|)
comment|/* Count the null byte used to terminate sibling lists.  */
name|next_die_offset
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the size of the line information prolog generated for the    compilation unit.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_line_prolog
parameter_list|()
block|{
specifier|register
name|unsigned
name|long
name|size
decl_stmt|;
specifier|register
name|unsigned
name|long
name|ft_index
decl_stmt|;
name|size
operator|=
name|DWARF_LINE_PROLOG_HEADER_SIZE
expr_stmt|;
comment|/* Count the size of the table giving number of args for each      standard opcode.  */
name|size
operator|+=
name|DWARF_LINE_OPCODE_BASE
operator|-
literal|1
expr_stmt|;
comment|/* Include directory table is empty (at present).  Count only the      null byte used to terminate the table.  */
name|size
operator|+=
literal|1
expr_stmt|;
for|for
control|(
name|ft_index
operator|=
literal|1
init|;
name|ft_index
operator|<
name|file_table_in_use
condition|;
operator|++
name|ft_index
control|)
block|{
comment|/* File name entry.  */
name|size
operator|+=
name|size_of_string
argument_list|(
name|file_table
index|[
name|ft_index
index|]
argument_list|)
expr_stmt|;
comment|/* Include directory index.  */
name|size
operator|+=
name|size_of_uleb128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Modification time.  */
name|size
operator|+=
name|size_of_uleb128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* File length in bytes.  */
name|size
operator|+=
name|size_of_uleb128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Count the file table terminator.  */
name|size
operator|+=
literal|1
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the line information generated for this    compilation unit.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_line_info
parameter_list|()
block|{
specifier|register
name|unsigned
name|long
name|size
decl_stmt|;
specifier|register
name|unsigned
name|long
name|lt_index
decl_stmt|;
specifier|register
name|unsigned
name|long
name|current_line
decl_stmt|;
specifier|register
name|long
name|line_offset
decl_stmt|;
specifier|register
name|long
name|line_delta
decl_stmt|;
specifier|register
name|unsigned
name|long
name|current_file
decl_stmt|;
specifier|register
name|unsigned
name|long
name|function
decl_stmt|;
name|unsigned
name|long
name|size_of_set_address
decl_stmt|;
comment|/* Size of a DW_LNE_set_address instruction.  */
name|size_of_set_address
operator|=
literal|1
operator|+
name|size_of_uleb128
argument_list|(
literal|1
operator|+
name|PTR_SIZE
argument_list|)
operator|+
literal|1
operator|+
name|PTR_SIZE
expr_stmt|;
comment|/* Version number.  */
name|size
operator|=
literal|2
expr_stmt|;
comment|/* Prolog length specifier.  */
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
comment|/* Prolog.  */
name|size
operator|+=
name|size_of_line_prolog
argument_list|()
expr_stmt|;
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|lt_index
operator|=
literal|1
init|;
name|lt_index
operator|<
name|line_info_table_in_use
condition|;
operator|++
name|lt_index
control|)
block|{
specifier|register
name|dw_line_info_ref
name|line_info
init|=
operator|&
name|line_info_table
index|[
name|lt_index
index|]
decl_stmt|;
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|==
name|current_line
operator|&&
name|line_info
operator|->
name|dw_file_num
operator|==
name|current_file
condition|)
continue|continue;
comment|/* Advance pc instruction.  */
comment|/* ??? See the DW_LNS_advance_pc comment in output_line_info.  */
if|if
condition|(
literal|0
condition|)
name|size
operator|+=
literal|1
operator|+
literal|2
expr_stmt|;
else|else
name|size
operator|+=
name|size_of_set_address
expr_stmt|;
if|if
condition|(
name|line_info
operator|->
name|dw_file_num
operator|!=
name|current_file
condition|)
block|{
comment|/* Set file number instruction.  */
name|size
operator|+=
literal|1
expr_stmt|;
name|current_file
operator|=
name|line_info
operator|->
name|dw_file_num
expr_stmt|;
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|current_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|!=
name|current_line
condition|)
block|{
name|line_offset
operator|=
name|line_info
operator|->
name|dw_line_num
operator|-
name|current_line
expr_stmt|;
name|line_delta
operator|=
name|line_offset
operator|-
name|DWARF_LINE_BASE
expr_stmt|;
name|current_line
operator|=
name|line_info
operator|->
name|dw_line_num
expr_stmt|;
if|if
condition|(
name|line_delta
operator|>=
literal|0
operator|&&
name|line_delta
operator|<
operator|(
name|DWARF_LINE_RANGE
operator|-
literal|1
operator|)
condition|)
comment|/* 1-byte special line number instruction.  */
name|size
operator|+=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Advance line instruction.  */
name|size
operator|+=
literal|1
expr_stmt|;
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|line_offset
argument_list|)
expr_stmt|;
comment|/* Generate line entry instruction.  */
name|size
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Advance pc instruction.  */
if|if
condition|(
literal|0
condition|)
name|size
operator|+=
literal|1
operator|+
literal|2
expr_stmt|;
else|else
name|size
operator|+=
name|size_of_set_address
expr_stmt|;
comment|/* End of line number info. marker.  */
name|size
operator|+=
literal|1
operator|+
name|size_of_uleb128
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|function
operator|=
literal|0
expr_stmt|;
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|lt_index
operator|=
literal|0
init|;
name|lt_index
operator|<
name|separate_line_info_table_in_use
condition|;
control|)
block|{
specifier|register
name|dw_separate_line_info_ref
name|line_info
init|=
operator|&
name|separate_line_info_table
index|[
name|lt_index
index|]
decl_stmt|;
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|==
name|current_line
operator|&&
name|line_info
operator|->
name|dw_file_num
operator|==
name|current_file
operator|&&
name|line_info
operator|->
name|function
operator|==
name|function
condition|)
goto|goto
name|cont
goto|;
if|if
condition|(
name|function
operator|!=
name|line_info
operator|->
name|function
condition|)
block|{
name|function
operator|=
name|line_info
operator|->
name|function
expr_stmt|;
comment|/* Set address register instruction.  */
name|size
operator|+=
name|size_of_set_address
expr_stmt|;
block|}
else|else
block|{
comment|/* Advance pc instruction.  */
if|if
condition|(
literal|0
condition|)
name|size
operator|+=
literal|1
operator|+
literal|2
expr_stmt|;
else|else
name|size
operator|+=
name|size_of_set_address
expr_stmt|;
block|}
if|if
condition|(
name|line_info
operator|->
name|dw_file_num
operator|!=
name|current_file
condition|)
block|{
comment|/* Set file number instruction.  */
name|size
operator|+=
literal|1
expr_stmt|;
name|current_file
operator|=
name|line_info
operator|->
name|dw_file_num
expr_stmt|;
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|current_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|!=
name|current_line
condition|)
block|{
name|line_offset
operator|=
name|line_info
operator|->
name|dw_line_num
operator|-
name|current_line
expr_stmt|;
name|line_delta
operator|=
name|line_offset
operator|-
name|DWARF_LINE_BASE
expr_stmt|;
name|current_line
operator|=
name|line_info
operator|->
name|dw_line_num
expr_stmt|;
if|if
condition|(
name|line_delta
operator|>=
literal|0
operator|&&
name|line_delta
operator|<
operator|(
name|DWARF_LINE_RANGE
operator|-
literal|1
operator|)
condition|)
comment|/* 1-byte special line number instruction.  */
name|size
operator|+=
literal|1
expr_stmt|;
else|else
block|{
comment|/* Advance line instruction.  */
name|size
operator|+=
literal|1
expr_stmt|;
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|line_offset
argument_list|)
expr_stmt|;
comment|/* Generate line entry instruction.  */
name|size
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|cont
label|:
operator|++
name|lt_index
expr_stmt|;
comment|/* If we're done with a function, end its sequence.  */
if|if
condition|(
name|lt_index
operator|==
name|separate_line_info_table_in_use
operator|||
name|separate_line_info_table
index|[
name|lt_index
index|]
operator|.
name|function
operator|!=
name|function
condition|)
block|{
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
comment|/* Advance pc instruction.  */
if|if
condition|(
literal|0
condition|)
name|size
operator|+=
literal|1
operator|+
literal|2
expr_stmt|;
else|else
name|size
operator|+=
name|size_of_set_address
expr_stmt|;
comment|/* End of line number info. marker.  */
name|size
operator|+=
literal|1
operator|+
name|size_of_uleb128
argument_list|(
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the .debug_pubnames table  generated for the    compilation unit.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_pubnames
parameter_list|()
block|{
specifier|register
name|unsigned
name|long
name|size
decl_stmt|;
specifier|register
name|unsigned
name|i
decl_stmt|;
name|size
operator|=
name|DWARF_PUBNAMES_HEADER_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pubname_table_in_use
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|pubname_ref
name|p
init|=
operator|&
name|pubname_table
index|[
name|i
index|]
decl_stmt|;
name|size
operator|+=
name|DWARF_OFFSET_SIZE
operator|+
name|size_of_string
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the information in the .debug_aranges section.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_aranges
parameter_list|()
block|{
specifier|register
name|unsigned
name|long
name|size
decl_stmt|;
name|size
operator|=
name|DWARF_ARANGES_HEADER_SIZE
expr_stmt|;
comment|/* Count the address/length pair for this compilation unit.  */
name|size
operator|+=
literal|2
operator|*
name|PTR_SIZE
expr_stmt|;
name|size
operator|+=
literal|2
operator|*
name|PTR_SIZE
operator|*
name|arange_table_in_use
expr_stmt|;
comment|/* Count the two zero words used to terminated the address range table.  */
name|size
operator|+=
literal|2
operator|*
name|PTR_SIZE
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Select the encoding of an attribute value.  */
end_comment

begin_function
specifier|static
name|enum
name|dwarf_form
name|value_format
parameter_list|(
name|v
parameter_list|)
name|dw_val_ref
name|v
decl_stmt|;
block|{
switch|switch
condition|(
name|v
operator|->
name|val_class
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
return|return
name|DW_FORM_addr
return|;
case|case
name|dw_val_class_loc
case|:
switch|switch
condition|(
name|constant_size
argument_list|(
name|size_of_locs
argument_list|(
name|v
operator|->
name|v
operator|.
name|val_loc
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|DW_FORM_block1
return|;
case|case
literal|2
case|:
return|return
name|DW_FORM_block2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|dw_val_class_const
case|:
return|return
name|DW_FORM_data4
return|;
case|case
name|dw_val_class_unsigned_const
case|:
switch|switch
condition|(
name|constant_size
argument_list|(
name|v
operator|->
name|v
operator|.
name|val_unsigned
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|DW_FORM_data1
return|;
case|case
literal|2
case|:
return|return
name|DW_FORM_data2
return|;
case|case
literal|4
case|:
return|return
name|DW_FORM_data4
return|;
case|case
literal|8
case|:
return|return
name|DW_FORM_data8
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|dw_val_class_long_long
case|:
return|return
name|DW_FORM_block1
return|;
case|case
name|dw_val_class_float
case|:
return|return
name|DW_FORM_block1
return|;
case|case
name|dw_val_class_flag
case|:
return|return
name|DW_FORM_flag
return|;
case|case
name|dw_val_class_die_ref
case|:
return|return
name|DW_FORM_ref
return|;
case|case
name|dw_val_class_fde_ref
case|:
return|return
name|DW_FORM_data
return|;
case|case
name|dw_val_class_lbl_id
case|:
return|return
name|DW_FORM_addr
return|;
case|case
name|dw_val_class_lbl_offset
case|:
return|return
name|DW_FORM_data
return|;
case|case
name|dw_val_class_str
case|:
return|return
name|DW_FORM_string
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the encoding of an attribute value.  */
end_comment

begin_function
specifier|static
name|void
name|output_value_format
parameter_list|(
name|v
parameter_list|)
name|dw_val_ref
name|v
decl_stmt|;
block|{
name|enum
name|dwarf_form
name|form
init|=
name|value_format
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|output_uleb128
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" (%s)"
argument_list|,
name|dwarf_form_name
argument_list|(
name|form
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the .debug_abbrev section which defines the DIE abbreviation    table.  */
end_comment

begin_function
specifier|static
name|void
name|output_abbrev_section
parameter_list|()
block|{
name|unsigned
name|long
name|abbrev_id
decl_stmt|;
name|dw_attr_ref
name|a_attr
decl_stmt|;
for|for
control|(
name|abbrev_id
operator|=
literal|1
init|;
name|abbrev_id
operator|<
name|abbrev_die_table_in_use
condition|;
operator|++
name|abbrev_id
control|)
block|{
specifier|register
name|dw_die_ref
name|abbrev
init|=
name|abbrev_die_table
index|[
name|abbrev_id
index|]
decl_stmt|;
name|output_uleb128
argument_list|(
name|abbrev_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" (abbrev code)"
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
name|abbrev
operator|->
name|die_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" (TAG: %s)"
argument_list|,
name|dwarf_tag_name
argument_list|(
name|abbrev
operator|->
name|die_tag
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t0x%x"
argument_list|,
name|ASM_BYTE_OP
argument_list|,
name|abbrev
operator|->
name|die_child
operator|!=
name|NULL
condition|?
name|DW_children_yes
else|:
name|DW_children_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
operator|(
name|abbrev
operator|->
name|die_child
operator|!=
name|NULL
condition|?
literal|"DW_children_yes"
else|:
literal|"DW_children_no"
operator|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
for|for
control|(
name|a_attr
operator|=
name|abbrev
operator|->
name|die_attr
init|;
name|a_attr
operator|!=
name|NULL
condition|;
name|a_attr
operator|=
name|a_attr
operator|->
name|dw_attr_next
control|)
block|{
name|output_uleb128
argument_list|(
name|a_attr
operator|->
name|dw_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" (%s)"
argument_list|,
name|dwarf_attr_name
argument_list|(
name|a_attr
operator|->
name|dw_attr
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_value_format
argument_list|(
operator|&
name|a_attr
operator|->
name|dw_attr_val
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t0,0\n"
argument_list|,
name|ASM_BYTE_OP
argument_list|)
expr_stmt|;
block|}
comment|/* We need to properly terminate the abbrev table for this      compilation unit, as per the standard, and not rely on      workarounds in e.g. gdb.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t0\n"
argument_list|,
name|ASM_BYTE_OP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output location description stack opcode's operands (if any).  */
end_comment

begin_function
specifier|static
name|void
name|output_loc_operands
parameter_list|(
name|loc
parameter_list|)
specifier|register
name|dw_loc_descr_ref
name|loc
decl_stmt|;
block|{
specifier|register
name|dw_val_ref
name|val1
init|=
operator|&
name|loc
operator|->
name|dw_loc_oprnd1
decl_stmt|;
specifier|register
name|dw_val_ref
name|val2
init|=
operator|&
name|loc
operator|->
name|dw_loc_oprnd2
decl_stmt|;
switch|switch
condition|(
name|loc
operator|->
name|dw_loc_opc
condition|)
block|{
case|case
name|DW_OP_addr
case|:
name|ASM_OUTPUT_DWARF_ADDR_CONST
argument_list|(
name|asm_out_file
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_addr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
case|case
name|DW_OP_const1s
case|:
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_flag
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
case|case
name|DW_OP_const2s
case|:
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
case|case
name|DW_OP_const4s
case|:
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
case|case
name|DW_OP_const8s
case|:
name|abort
argument_list|()
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|output_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|output_sleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_pick
case|:
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|output_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_skip
case|:
case|case
name|DW_OP_bra
case|:
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|output_sleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|output_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_fbreg
case|:
name|output_sleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|output_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_sleb128
argument_list|(
name|val2
operator|->
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_piece
case|:
name|output_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_deref_size
case|:
case|case
name|DW_OP_xderef_size
case|:
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_flag
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Compute the offset of a sibling.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|sibling_offset
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|unsigned
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|die_child_last
operator|==
name|NULL
condition|)
name|offset
operator|=
name|die
operator|->
name|die_offset
operator|+
name|size_of_die
argument_list|(
name|die
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|sibling_offset
argument_list|(
name|die
operator|->
name|die_child_last
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Output the DIE and its attributes.  Called recursively to generate    the definitions of each child DIE.  */
end_comment

begin_function
specifier|static
name|void
name|output_die
parameter_list|(
name|die
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
block|{
specifier|register
name|dw_attr_ref
name|a
decl_stmt|;
specifier|register
name|dw_die_ref
name|c
decl_stmt|;
specifier|register
name|unsigned
name|long
name|ref_offset
decl_stmt|;
specifier|register
name|unsigned
name|long
name|size
decl_stmt|;
specifier|register
name|dw_loc_descr_ref
name|loc
decl_stmt|;
name|output_uleb128
argument_list|(
name|die
operator|->
name|die_abbrev
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" (DIE (0x%lx) %s)"
argument_list|,
name|die
operator|->
name|die_offset
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|die_tag
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
control|)
block|{
switch|switch
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
name|ASM_OUTPUT_DWARF_ADDR_CONST
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc
case|:
name|size
operator|=
name|size_of_locs
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc
argument_list|)
expr_stmt|;
comment|/* Output the block length for this list of location operations.  */
switch|switch
condition|(
name|constant_size
argument_list|(
name|size
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|dwarf_attr_name
argument_list|(
name|a
operator|->
name|dw_attr
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
for|for
control|(
name|loc
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc
init|;
name|loc
operator|!=
name|NULL
condition|;
name|loc
operator|=
name|loc
operator|->
name|dw_loc_next
control|)
block|{
comment|/* Output the opcode.  */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|loc
operator|->
name|dw_loc_opc
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|dwarf_stack_op_name
argument_list|(
name|loc
operator|->
name|dw_loc_opc
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Output the operand(s) (if any).  */
name|output_loc_operands
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_const
case|:
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_unsigned_const
case|:
switch|switch
condition|(
name|constant_size
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|ASM_OUTPUT_DWARF_DATA8
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_long_long
case|:
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|dwarf_attr_name
argument_list|(
name|a
operator|->
name|dw_attr
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA8
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s long long constant"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_float
case|:
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|length
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|dwarf_attr_name
argument_list|(
name|a
operator|->
name|dw_attr
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|length
condition|;
operator|++
name|i
control|)
block|{
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s fp constant word %u"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|dw_val_class_flag
case|:
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_flag
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_die_ref
case|:
if|if
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|!=
name|NULL
condition|)
name|ref_offset
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|->
name|die_offset
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|dw_attr
operator|==
name|DW_AT_sibling
condition|)
name|ref_offset
operator|=
name|sibling_offset
argument_list|(
name|die
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA
argument_list|(
name|asm_out_file
argument_list|,
name|ref_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_fde_ref
case|:
block|{
name|char
name|l1
index|[
literal|20
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
name|FDE_AFTER_SIZE_LABEL
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_fde_index
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_OFFSET
argument_list|(
name|asm_out_file
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" - %d"
argument_list|,
name|DWARF_OFFSET_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_lbl_id
case|:
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_lbl_offset
case|:
name|ASM_OUTPUT_DWARF_OFFSET
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_str
case|:
if|if
condition|(
name|flag_debug_asm
condition|)
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_ASCII
argument_list|(
name|asm_out_file
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|!=
name|dw_val_class_loc
operator|&&
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|!=
name|dw_val_class_long_long
operator|&&
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|!=
name|dw_val_class_float
condition|)
block|{
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|dwarf_attr_name
argument_list|(
name|a
operator|->
name|dw_attr
argument_list|)
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|output_die
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
condition|)
block|{
comment|/* Add null byte to terminate sibling list. */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s end of children of DIE 0x%lx"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|die
operator|->
name|die_offset
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the compilation unit that appears at the beginning of the    .debug_info section, and precedes the DIE descriptions.  */
end_comment

begin_function
specifier|static
name|void
name|output_compilation_unit_header
parameter_list|()
block|{
name|ASM_OUTPUT_DWARF_DATA
argument_list|(
name|asm_out_file
argument_list|,
name|next_die_offset
operator|-
name|DWARF_OFFSET_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Length of Compilation Unit Info."
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|DWARF_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DWARF version number"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_OFFSET
argument_list|(
name|asm_out_file
argument_list|,
name|abbrev_section_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Offset Into Abbrev. Section"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|PTR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Pointer Size (in bytes)"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The DWARF2 pubname for a nested thingy looks like "A::f".  The output    of decl_printable_name for C++ looks like "A::f(int)".  Let's drop the    argument list, and maybe the scope.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf2_name
parameter_list|(
name|decl
parameter_list|,
name|scope
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|scope
decl_stmt|;
block|{
return|return
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
name|scope
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a new entry to .debug_pubnames if appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|add_pubname
parameter_list|(
name|decl
parameter_list|,
name|die
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|pubname_ref
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|pubname_table_in_use
operator|==
name|pubname_table_allocated
condition|)
block|{
name|pubname_table_allocated
operator|+=
name|PUBNAME_TABLE_INCREMENT
expr_stmt|;
name|pubname_table
operator|=
operator|(
name|pubname_ref
operator|)
name|xrealloc
argument_list|(
name|pubname_table
argument_list|,
name|pubname_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|pubname_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
operator|&
name|pubname_table
index|[
name|pubname_table_in_use
operator|++
index|]
expr_stmt|;
name|p
operator|->
name|die
operator|=
name|die
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|dwarf2_name
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the public names table used to speed up access to externally    visible names.  For now, only generate entries for externally    visible procedures.  */
end_comment

begin_function
specifier|static
name|void
name|output_pubnames
parameter_list|()
block|{
specifier|register
name|unsigned
name|i
decl_stmt|;
specifier|register
name|unsigned
name|long
name|pubnames_length
init|=
name|size_of_pubnames
argument_list|()
decl_stmt|;
name|ASM_OUTPUT_DWARF_DATA
argument_list|(
name|asm_out_file
argument_list|,
name|pubnames_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Length of Public Names Info."
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|DWARF_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DWARF Version"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_OFFSET
argument_list|(
name|asm_out_file
argument_list|,
name|debug_info_section_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Offset of Compilation Unit Info."
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA
argument_list|(
name|asm_out_file
argument_list|,
name|next_die_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Compilation Unit Length"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pubname_table_in_use
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|pubname_ref
name|pub
init|=
operator|&
name|pubname_table
index|[
name|i
index|]
decl_stmt|;
name|ASM_OUTPUT_DWARF_DATA
argument_list|(
name|asm_out_file
argument_list|,
name|pub
operator|->
name|die
operator|->
name|die_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DIE offset"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
block|{
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|pub
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s external name"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_OUTPUT_ASCII
argument_list|(
name|asm_out_file
argument_list|,
name|pub
operator|->
name|name
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|pub
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|ASM_OUTPUT_DWARF_DATA
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new entry to .debug_aranges if appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|add_arange
parameter_list|(
name|decl
parameter_list|,
name|die
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|dw_die_ref
name|die
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|arange_table_in_use
operator|==
name|arange_table_allocated
condition|)
block|{
name|arange_table_allocated
operator|+=
name|ARANGE_TABLE_INCREMENT
expr_stmt|;
name|arange_table
operator|=
operator|(
name|arange_ref
operator|)
name|xrealloc
argument_list|(
name|arange_table
argument_list|,
name|arange_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arange_table
index|[
name|arange_table_in_use
operator|++
index|]
operator|=
name|die
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the information that goes into the .debug_aranges table.    Namely, define the beginning and ending address range of the    text section generated for this compilation unit.  */
end_comment

begin_function
specifier|static
name|void
name|output_aranges
parameter_list|()
block|{
specifier|register
name|unsigned
name|i
decl_stmt|;
specifier|register
name|unsigned
name|long
name|aranges_length
init|=
name|size_of_aranges
argument_list|()
decl_stmt|;
name|ASM_OUTPUT_DWARF_DATA
argument_list|(
name|asm_out_file
argument_list|,
name|aranges_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Length of Address Ranges Info."
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|DWARF_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DWARF Version"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_OFFSET
argument_list|(
name|asm_out_file
argument_list|,
name|debug_info_section_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Offset of Compilation Unit Info."
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|PTR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Size of Address"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Size of Segment Descriptor"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA4
argument_list|(
name|asm_out_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|PTR_SIZE
operator|==
literal|8
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|",0,0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Pad to %d byte boundary"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
literal|2
operator|*
name|PTR_SIZE
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|text_section_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Address"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR_DELTA
argument_list|(
name|asm_out_file
argument_list|,
name|text_end_label
argument_list|,
name|text_section_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s Length"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arange_table_in_use
condition|;
operator|++
name|i
control|)
block|{
name|dw_die_ref
name|a
init|=
name|arange_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|die_tag
operator|==
name|DW_TAG_subprogram
condition|)
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|get_AT_low_pc
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|name
init|=
name|get_AT_string
argument_list|(
name|a
argument_list|,
name|DW_AT_MIPS_linkage_name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
name|get_AT_string
argument_list|(
name|a
argument_list|,
name|DW_AT_name
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Address"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|die_tag
operator|==
name|DW_TAG_subprogram
condition|)
name|ASM_OUTPUT_DWARF_ADDR_DELTA
argument_list|(
name|asm_out_file
argument_list|,
name|get_AT_hi_pc
argument_list|(
name|a
argument_list|)
argument_list|,
name|get_AT_low_pc
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_DWARF_ADDR_DATA
argument_list|(
name|asm_out_file
argument_list|,
name|get_AT_unsigned
argument_list|(
name|a
argument_list|,
name|DW_AT_byte_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s Length"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Output the terminator words.  */
name|ASM_OUTPUT_DWARF_ADDR_DATA
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR_DATA
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the source line number correspondence information.  This    information goes into the .debug_line section.     If the format of this data changes, then the function size_of_line_info    must also be adjusted the same way.  */
end_comment

begin_function
specifier|static
name|void
name|output_line_info
parameter_list|()
block|{
name|char
name|line_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|prev_line_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
specifier|register
name|unsigned
name|opc
decl_stmt|;
specifier|register
name|unsigned
name|n_op_args
decl_stmt|;
specifier|register
name|unsigned
name|long
name|ft_index
decl_stmt|;
specifier|register
name|unsigned
name|long
name|lt_index
decl_stmt|;
specifier|register
name|unsigned
name|long
name|current_line
decl_stmt|;
specifier|register
name|long
name|line_offset
decl_stmt|;
specifier|register
name|long
name|line_delta
decl_stmt|;
specifier|register
name|unsigned
name|long
name|current_file
decl_stmt|;
specifier|register
name|unsigned
name|long
name|function
decl_stmt|;
name|ASM_OUTPUT_DWARF_DATA
argument_list|(
name|asm_out_file
argument_list|,
name|size_of_line_info
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Length of Source Line Info."
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA2
argument_list|(
name|asm_out_file
argument_list|,
name|DWARF_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DWARF Version"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA
argument_list|(
name|asm_out_file
argument_list|,
name|size_of_line_prolog
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Prolog Length"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DWARF_LINE_MIN_INSTR_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Minimum Instruction Length"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DWARF_LINE_DEFAULT_IS_STMT_START
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Default is_stmt_start flag"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t%d"
argument_list|,
name|ASM_BYTE_OP
argument_list|,
name|DWARF_LINE_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Line Base Value (Special Opcodes)"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t%u"
argument_list|,
name|ASM_BYTE_OP
argument_list|,
name|DWARF_LINE_RANGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Line Range Value (Special Opcodes)"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\t%u"
argument_list|,
name|ASM_BYTE_OP
argument_list|,
name|DWARF_LINE_OPCODE_BASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s Special Opcode Base"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
for|for
control|(
name|opc
operator|=
literal|1
init|;
name|opc
operator|<
name|DWARF_LINE_OPCODE_BASE
condition|;
operator|++
name|opc
control|)
block|{
switch|switch
condition|(
name|opc
condition|)
block|{
case|case
name|DW_LNS_advance_pc
case|:
case|case
name|DW_LNS_advance_line
case|:
case|case
name|DW_LNS_set_file
case|:
case|case
name|DW_LNS_set_column
case|:
case|case
name|DW_LNS_fixed_advance_pc
case|:
name|n_op_args
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|n_op_args
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|n_op_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s opcode: 0x%x has %d args"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|opc
argument_list|,
name|n_op_args
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s Include Directory Table\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
comment|/* Include directory table is empty, at present */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s File Name Table\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
for|for
control|(
name|ft_index
operator|=
literal|1
init|;
name|ft_index
operator|<
name|file_table_in_use
condition|;
operator|++
name|ft_index
control|)
block|{
if|if
condition|(
name|flag_debug_asm
condition|)
block|{
name|ASM_OUTPUT_DWARF_STRING
argument_list|(
name|asm_out_file
argument_list|,
name|file_table
index|[
name|ft_index
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s File Entry: 0x%lx"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|ft_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_OUTPUT_ASCII
argument_list|(
name|asm_out_file
argument_list|,
name|file_table
index|[
name|ft_index
index|]
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|file_table
index|[
name|ft_index
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Include directory index */
name|output_uleb128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Modification time */
name|output_uleb128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* File length in bytes */
name|output_uleb128
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Terminate the file name table */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* We used to set the address register to the first location in the text      section here, but that didn't accomplish anything since we already      have a line note for the opening brace of the first function.  */
comment|/* Generate the line number to PC correspondence table, encoded as      a series of state machine operations.  */
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|prev_line_label
argument_list|,
name|text_section_label
argument_list|)
expr_stmt|;
for|for
control|(
name|lt_index
operator|=
literal|1
init|;
name|lt_index
operator|<
name|line_info_table_in_use
condition|;
operator|++
name|lt_index
control|)
block|{
specifier|register
name|dw_line_info_ref
name|line_info
init|=
operator|&
name|line_info_table
index|[
name|lt_index
index|]
decl_stmt|;
comment|/* Don't emit anything for redundant notes.  Just updating the          address doesn't accomplish anything, because we already assume          that anything after the last address is this line.  */
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|==
name|current_line
operator|&&
name|line_info
operator|->
name|dw_file_num
operator|==
name|current_file
condition|)
continue|continue;
comment|/* Emit debug info for the address of the current line, choosing 	 the encoding that uses the least amount of space.  */
comment|/* ??? Unfortunately, we have little choice here currently, and must 	 always use the most general form.  Gcc does not know the address 	 delta itself, so we can't use DW_LNS_advance_pc.  There are no known 	 dwarf2 aware assemblers at this time, so we can't use any special 	 pseudo ops that would allow the assembler to optimally encode this for 	 us.  Many ports do have length attributes which will give an upper 	 bound on the address range.  We could perhaps use length attributes 	 to determine when it is safe to use DW_LNS_fixed_advance_pc.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|line_label
argument_list|,
name|LINE_CODE_LABEL
argument_list|,
name|lt_index
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
comment|/* This can handle deltas up to 0xffff.  This takes 3 bytes.  */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNS_fixed_advance_pc"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|line_label
argument_list|,
name|prev_line_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This can handle any delta.  This takes 4+PTR_SIZE bytes.  */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNE_set_address"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
literal|1
operator|+
name|PTR_SIZE
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNE_set_address
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|line_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|prev_line_label
argument_list|,
name|line_label
argument_list|)
expr_stmt|;
comment|/* Emit debug info for the source file of the current line, if 	 different from the previous line.  */
if|if
condition|(
name|line_info
operator|->
name|dw_file_num
operator|!=
name|current_file
condition|)
block|{
name|current_file
operator|=
name|line_info
operator|->
name|dw_file_num
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_set_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNS_set_file"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
name|current_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" (\"%s\")"
argument_list|,
name|file_table
index|[
name|current_file
index|]
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Emit debug info for the current line number, choosing the encoding 	 that uses the least amount of space.  */
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|!=
name|current_line
condition|)
block|{
name|line_offset
operator|=
name|line_info
operator|->
name|dw_line_num
operator|-
name|current_line
expr_stmt|;
name|line_delta
operator|=
name|line_offset
operator|-
name|DWARF_LINE_BASE
expr_stmt|;
name|current_line
operator|=
name|line_info
operator|->
name|dw_line_num
expr_stmt|;
if|if
condition|(
name|line_delta
operator|>=
literal|0
operator|&&
name|line_delta
operator|<
operator|(
name|DWARF_LINE_RANGE
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* This can handle deltas from -10 to 234, using the current 		 definitions of DWARF_LINE_BASE and DWARF_LINE_RANGE.  This 		 takes 1 byte.  */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DWARF_LINE_OPCODE_BASE
operator|+
name|line_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s line %ld"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This can handle any delta.  This takes at least 4 bytes, 		 depending on the value being encoded.  */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_advance_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s advance to line %ld"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_sleb128
argument_list|(
name|line_offset
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNS_copy"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We still need to start a new row, so output a copy insn.  */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNS_copy"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Emit debug info for the address of the end of the function.  */
if|if
condition|(
literal|0
condition|)
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNS_fixed_advance_pc"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|text_end_label
argument_list|,
name|prev_line_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNE_set_address"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
literal|1
operator|+
name|PTR_SIZE
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNE_set_address
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|text_end_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Output the marker for the end of the line number info.  */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNE_end_sequence"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNE_end_sequence
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|function
operator|=
literal|0
expr_stmt|;
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|lt_index
operator|=
literal|0
init|;
name|lt_index
operator|<
name|separate_line_info_table_in_use
condition|;
control|)
block|{
specifier|register
name|dw_separate_line_info_ref
name|line_info
init|=
operator|&
name|separate_line_info_table
index|[
name|lt_index
index|]
decl_stmt|;
comment|/* Don't emit anything for redundant notes.  */
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|==
name|current_line
operator|&&
name|line_info
operator|->
name|dw_file_num
operator|==
name|current_file
operator|&&
name|line_info
operator|->
name|function
operator|==
name|function
condition|)
goto|goto
name|cont
goto|;
comment|/* Emit debug info for the address of the current line.  If this is 	 a new function, or the first line of a function, then we need 	 to handle it differently.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|line_label
argument_list|,
name|SEPARATE_LINE_CODE_LABEL
argument_list|,
name|lt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|!=
name|line_info
operator|->
name|function
condition|)
block|{
name|function
operator|=
name|line_info
operator|->
name|function
expr_stmt|;
comment|/* Set the address register to the first line in the function */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNE_set_address"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
literal|1
operator|+
name|PTR_SIZE
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNE_set_address
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|line_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? See the DW_LNS_advance_pc comment above.  */
if|if
condition|(
literal|0
condition|)
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNS_fixed_advance_pc"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|line_label
argument_list|,
name|prev_line_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNE_set_address"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
literal|1
operator|+
name|PTR_SIZE
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNE_set_address
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|line_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|prev_line_label
argument_list|,
name|line_label
argument_list|)
expr_stmt|;
comment|/* Emit debug info for the source file of the current line, if 	 different from the previous line.  */
if|if
condition|(
name|line_info
operator|->
name|dw_file_num
operator|!=
name|current_file
condition|)
block|{
name|current_file
operator|=
name|line_info
operator|->
name|dw_file_num
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_set_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNS_set_file"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
name|current_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|" (\"%s\")"
argument_list|,
name|file_table
index|[
name|current_file
index|]
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Emit debug info for the current line number, choosing the encoding 	 that uses the least amount of space.  */
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|!=
name|current_line
condition|)
block|{
name|line_offset
operator|=
name|line_info
operator|->
name|dw_line_num
operator|-
name|current_line
expr_stmt|;
name|line_delta
operator|=
name|line_offset
operator|-
name|DWARF_LINE_BASE
expr_stmt|;
name|current_line
operator|=
name|line_info
operator|->
name|dw_line_num
expr_stmt|;
if|if
condition|(
name|line_delta
operator|>=
literal|0
operator|&&
name|line_delta
operator|<
operator|(
name|DWARF_LINE_RANGE
operator|-
literal|1
operator|)
condition|)
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DWARF_LINE_OPCODE_BASE
operator|+
name|line_delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s line %ld"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_advance_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s advance to line %ld"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_sleb128
argument_list|(
name|line_offset
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNS_copy"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We still need to start a new row, so output a copy insn.  */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNS_copy"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|cont
label|:
operator|++
name|lt_index
expr_stmt|;
comment|/* If we're done with a function, end its sequence.  */
if|if
condition|(
name|lt_index
operator|==
name|separate_line_info_table_in_use
operator|||
name|separate_line_info_table
index|[
name|lt_index
index|]
operator|.
name|function
operator|!=
name|function
condition|)
block|{
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
comment|/* Emit debug info for the address of the end of the function.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|line_label
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNS_fixed_advance_pc"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DELTA2
argument_list|(
name|asm_out_file
argument_list|,
name|line_label
argument_list|,
name|prev_line_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNE_set_address"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
literal|1
operator|+
name|PTR_SIZE
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNE_set_address
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_ADDR
argument_list|(
name|asm_out_file
argument_list|,
name|line_label
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
comment|/* Output the marker for the end of this sequence.  */
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s DW_LNE_end_sequence"
argument_list|,
name|ASM_COMMENT_START
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_uleb128
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DWARF_DATA1
argument_list|(
name|asm_out_file
argument_list|,
name|DW_LNE_end_sequence
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to a BLOCK node return non-zero if (and only if) the node    in question represents the outermost pair of curly braces (i.e. the "body    block") of a function or method.     For any BLOCK node representing a "body block" of a function or method, the    BLOCK_SUPERCONTEXT of the node will point to another BLOCK node which    represents the outermost (function) scope for the function or method (i.e.    the one which includes the formal parameters).  The BLOCK_SUPERCONTEXT of    *that* node in turn will point to the relevant FUNCTION_DECL node. */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_body_block
parameter_list|(
name|stmt
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|BLOCK
condition|)
block|{
specifier|register
name|tree
name|parent
init|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parent
argument_list|)
operator|==
name|BLOCK
condition|)
block|{
specifier|register
name|tree
name|grandparent
init|=
name|BLOCK_SUPERCONTEXT
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|grandparent
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node for some base type, return a pointer to    a DIE that describes the given type.     This routine must only be called for GCC type nodes that correspond to    Dwarf base (fundamental) types.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|base_type_die
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|base_type_result
decl_stmt|;
specifier|register
name|char
modifier|*
name|type_name
decl_stmt|;
specifier|register
name|enum
name|dwarf_type
name|encoding
decl_stmt|;
specifier|register
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|type_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
comment|/* Carefully distinguish the C character types, without messing          up if the language is not C. Note that we check only for the names          that contain spaces; other names might occur by coincidence in other           languages.  */
if|if
condition|(
operator|!
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|CHAR_TYPE_SIZE
operator|&&
operator|(
name|type
operator|==
name|char_type_node
operator|||
operator|!
name|strcmp
argument_list|(
name|type_name
argument_list|,
literal|"signed char"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|type_name
argument_list|,
literal|"unsigned char"
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|encoding
operator|=
name|DW_ATE_unsigned
expr_stmt|;
else|else
name|encoding
operator|=
name|DW_ATE_signed
expr_stmt|;
break|break;
block|}
comment|/* else fall through */
case|case
name|CHAR_TYPE
case|:
comment|/* GNU Pascal/Ada CHAR type.  Not used in C.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|encoding
operator|=
name|DW_ATE_unsigned_char
expr_stmt|;
else|else
name|encoding
operator|=
name|DW_ATE_signed_char
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|encoding
operator|=
name|DW_ATE_float
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|encoding
operator|=
name|DW_ATE_complex_float
expr_stmt|;
break|break;
case|case
name|BOOLEAN_TYPE
case|:
comment|/* GNU FORTRAN/Ada/C++ BOOLEAN type.  */
name|encoding
operator|=
name|DW_ATE_boolean
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* No other TREE_CODEs are Dwarf fundamental types.  */
block|}
name|base_type_result
operator|=
name|new_die
argument_list|(
name|DW_TAG_base_type
argument_list|,
name|comp_unit_die
argument_list|)
expr_stmt|;
name|add_AT_string
argument_list|(
name|base_type_result
argument_list|,
name|DW_AT_name
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|base_type_result
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|base_type_result
argument_list|,
name|DW_AT_encoding
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
return|return
name|base_type_result
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return a pointer to    the Dwarf "root" type for the given input type.  The Dwarf "root" type of    a given type is generally the same as the given type, except that if the    given type is a pointer or reference type, then the root type of the given    type is the root type of the "basis" type for the pointer or reference    type.  (This definition of the "root" type is recursive.) Also, the root    type of a `const' qualified type or a `volatile' qualified type is the    root type of the given type without the qualifiers.  */
end_comment

begin_function
specifier|static
name|tree
name|root_type
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|type_main_variant
argument_list|(
name|root_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|type_main_variant
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return non-zero if the    given input type is a Dwarf "fundamental" type.  Otherwise return null.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_base_type
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
return|return
literal|1
return|;
case|case
name|SET_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|FILE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|LANG_TYPE
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return a debugging    entry that chains various modifiers in front of the given type.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|modified_type_die
parameter_list|(
name|type
parameter_list|,
name|is_const_type
parameter_list|,
name|is_volatile_type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|int
name|is_const_type
decl_stmt|;
specifier|register
name|int
name|is_volatile_type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|dw_die_ref
name|mod_type_die
init|=
name|NULL
decl_stmt|;
specifier|register
name|dw_die_ref
name|sub_die
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|item_type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|ERROR_MARK
condition|)
block|{
name|type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|is_const_type
argument_list|,
name|is_volatile_type
argument_list|)
expr_stmt|;
name|mod_type_die
operator|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_type_die
condition|)
return|return
name|mod_type_die
return|;
comment|/* Handle C typedef types. */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|dtype
init|=
name|TREE_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|dtype
condition|)
block|{
comment|/* For a named type, use the typedef.  */
name|gen_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|mod_type_die
operator|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_const_type
operator|<
name|TYPE_READONLY
argument_list|(
name|dtype
argument_list|)
operator|||
name|is_volatile_type
operator|<
name|TYPE_VOLATILE
argument_list|(
name|dtype
argument_list|)
condition|)
comment|/* cv-unqualified version of named type.  Just use the unnamed 	       type to which it refers.  */
name|mod_type_die
operator|=
name|modified_type_die
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|is_const_type
argument_list|,
name|is_volatile_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Else cv-qualified version of named type; fall through.  */
block|}
if|if
condition|(
name|mod_type_die
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|is_const_type
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_const_type
argument_list|,
name|comp_unit_die
argument_list|)
expr_stmt|;
name|sub_die
operator|=
name|modified_type_die
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|is_volatile_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_volatile_type
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_volatile_type
argument_list|,
name|comp_unit_die
argument_list|)
expr_stmt|;
name|sub_die
operator|=
name|modified_type_die
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_pointer_type
argument_list|,
name|comp_unit_die
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|mod_type_die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|PTR_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);
endif|#
directive|endif
name|item_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_reference_type
argument_list|,
name|comp_unit_die
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|mod_type_die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|PTR_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);
endif|#
directive|endif
name|item_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_base_type
argument_list|(
name|type
argument_list|)
condition|)
name|mod_type_die
operator|=
name|base_type_die
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|gen_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* We have to get the type_main_variant here (and pass that to the 	     `lookup_type_die' routine) because the ..._TYPE node we have 	     might simply be a *copy* of some original type node (where the 	     copy was created to help us keep track of typedef names) and 	     that copy might have a different TYPE_UID from the original 	     ..._TYPE node.  */
name|mod_type_die
operator|=
name|lookup_type_die
argument_list|(
name|type_main_variant
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_type_die
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|mod_type_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|item_type
condition|)
comment|/* We must do this after the equate_type_number_to_die call, in case        this is a recursive type.  This ensures that the modified_type_die        recursion will terminate even if the type is recursive.  Recursive        types are possible in Ada.  */
name|sub_die
operator|=
name|modified_type_die
argument_list|(
name|item_type
argument_list|,
name|TYPE_READONLY
argument_list|(
name|item_type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|item_type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_die
operator|!=
name|NULL
condition|)
name|add_AT_die_ref
argument_list|(
name|mod_type_die
argument_list|,
name|DW_AT_type
argument_list|,
name|sub_die
argument_list|)
expr_stmt|;
return|return
name|mod_type_die
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return true if it is    an enumerated type.   */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|type_is_enum
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
return|return
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
return|;
block|}
end_function

begin_comment
comment|/* Return a location descriptor that designates a machine register.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|reg_loc_descriptor
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
specifier|register
name|dw_loc_descr_ref
name|loc_result
init|=
name|NULL
decl_stmt|;
specifier|register
name|unsigned
name|reg
init|=
name|reg_number
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|<=
literal|31
condition|)
name|loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_reg0
operator|+
name|reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_regx
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|loc_result
return|;
block|}
end_function

begin_comment
comment|/* Return a location descriptor that designates a base+offset location.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|based_loc_descr
parameter_list|(
name|reg
parameter_list|,
name|offset
parameter_list|)
name|unsigned
name|reg
decl_stmt|;
name|long
name|int
name|offset
decl_stmt|;
block|{
specifier|register
name|dw_loc_descr_ref
name|loc_result
decl_stmt|;
comment|/* For the "frame base", we use the frame pointer or stack pointer      registers, since the RTL for local variables is relative to one of      them.  */
specifier|register
name|unsigned
name|fp_reg
init|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|frame_pointer_needed
condition|?
name|HARD_FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|fp_reg
condition|)
name|loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_fbreg
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|<=
literal|31
condition|)
name|loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_breg0
operator|+
name|reg
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_bregx
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|loc_result
return|;
block|}
end_function

begin_comment
comment|/* Return true if this RTL expression describes a base+offset calculation.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_based_loc
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following routine converts the RTL for a variable or parameter    (resident in memory) into an equivalent Dwarf representation of a    mechanism for getting the address of that same variable onto the top of a    hypothetical "address evaluation" stack.     When creating memory location descriptors, we are effectively transforming    the RTL for a memory-resident object into its Dwarf postfix expression    equivalent.  This routine recursively descends an RTL tree, turning    it into Dwarf postfix code as it goes.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|mem_loc_descriptor
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|mem_loc_result
init|=
name|NULL
decl_stmt|;
comment|/* Note that for a dynamically sized array, the location we will generate a       description of here will be the lowest numbered location which is      actually within the array.  That's *not* necessarily the same as the      zeroth element of the array.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
comment|/* The case of a subreg may arise when we have a local (register)          variable or a formal (register) parameter which doesn't quite fill          up an entire register.  For now, just assume that it is          legitimate to make the Dwarf info refer to the whole register which          contains the given subreg.  */
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... fall through ... */
case|case
name|REG
case|:
comment|/* Whenever a register number forms a part of the description of the          method for calculating the (dynamic) address of a memory resident          object, DWARF rules require the register number be referred to as           a "base register".  This distinction is not based in any way upon          what category of register the hardware believes the given register          belongs to.  This is strictly DWARF terminology we're dealing with          here. Note that in cases where the location of a memory-resident          data object could be expressed as: OP_ADD (OP_BASEREG (basereg),          OP_CONST (0)) the actual DWARF location descriptor that we generate          may just be OP_BASEREG (basereg).  This may look deceptively like          the object in question was allocated to a register (rather than in          memory) so DWARF consumers need to be aware of the subtle          distinction between OP_REG and OP_BASEREG.  */
name|mem_loc_result
operator|=
name|based_loc_descr
argument_list|(
name|reg_number
argument_list|(
name|rtl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|mem_loc_result
operator|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_deref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
name|mem_loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem_loc_result
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_addr
expr_stmt|;
name|mem_loc_result
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_addr
operator|=
name|addr_to_string
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
if|if
condition|(
name|is_based_loc
argument_list|(
name|rtl
argument_list|)
condition|)
name|mem_loc_result
operator|=
name|based_loc_descr
argument_list|(
name|reg_number
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MULT
case|:
comment|/* If a pseudo-reg is optimized away, it is possible for it to 	 be replaced with a MEM containing a multiply.  */
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_mul
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|mem_loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_constu
argument_list|,
name|INTVAL
argument_list|(
name|rtl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|mem_loc_result
return|;
block|}
end_function

begin_comment
comment|/* Return a descriptor that describes the concatenation of two locations.    This is typically a complex variable.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|concat_loc_descriptor
parameter_list|(
name|x0
parameter_list|,
name|x1
parameter_list|)
specifier|register
name|rtx
name|x0
decl_stmt|,
name|x1
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|cc_loc_result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|is_pseudo_reg
argument_list|(
name|x0
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x0
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|is_pseudo_reg
argument_list|(
name|XEXP
argument_list|(
name|x0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|add_loc_descr
argument_list|(
operator|&
name|cc_loc_result
argument_list|,
name|loc_descriptor
argument_list|(
name|x0
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|cc_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_piece
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_pseudo_reg
argument_list|(
name|x1
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|x1
argument_list|)
operator|!=
name|MEM
operator|||
operator|!
name|is_pseudo_reg
argument_list|(
name|XEXP
argument_list|(
name|x1
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
name|add_loc_descr
argument_list|(
operator|&
name|cc_loc_result
argument_list|,
name|loc_descriptor
argument_list|(
name|x1
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|cc_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_piece
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_loc_result
return|;
block|}
end_function

begin_comment
comment|/* Output a proper Dwarf location descriptor for a variable or parameter    which is either allocated in a register or in a memory location.  For a    register, we just generate an OP_REG and the register number.  For a    memory location we provide a Dwarf postfix expression describing how to    generate the (dynamic) address of the object onto the address stack.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|loc_descriptor
parameter_list|(
name|rtl
parameter_list|)
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|loc_result
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
comment|/* The case of a subreg may arise when we have a local (register)          variable or a formal (register) parameter which doesn't quite fill          up an entire register.  For now, just assume that it is          legitimate to make the Dwarf info refer to the whole register which          contains the given subreg.  */
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ... fall through ... */
case|case
name|REG
case|:
name|loc_result
operator|=
name|reg_loc_descriptor
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|loc_result
operator|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONCAT
case|:
name|loc_result
operator|=
name|concat_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|loc_result
return|;
block|}
end_function

begin_comment
comment|/* Given an unsigned value, round it up to the lowest multiple of `boundary'    which is not less than the value itself.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|ceiling
parameter_list|(
name|value
parameter_list|,
name|boundary
parameter_list|)
specifier|register
name|unsigned
name|value
decl_stmt|;
specifier|register
name|unsigned
name|boundary
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|value
operator|+
name|boundary
operator|-
literal|1
operator|)
operator|/
name|boundary
operator|)
operator|*
name|boundary
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to what is assumed to be a FIELD_DECL node, return a    pointer to the declared type for the relevant field variable, or return    `integer_type_node' if the given node turns out to be an    ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|field_type
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|integer_type_node
return|;
name|type
operator|=
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE    node, return the alignment in bits for the type, or else return    BITS_PER_WORD if the node actually turns out to be an    ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|simple_type_align_in_bits
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|?
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
else|:
name|BITS_PER_WORD
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE    node, return the size in bits for the type if it is a constant, or else    return the alignment for the type if the type's size is not constant, or    else return BITS_PER_WORD if the type actually turns out to be an    ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|simple_type_size_in_bits
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|BITS_PER_WORD
return|;
else|else
block|{
specifier|register
name|tree
name|type_size_tree
init|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type_size_tree
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
return|;
return|return
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|type_size_tree
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to what is assumed to be a FIELD_DECL node, compute and    return the byte offset of the lowest addressed byte of the "containing    object" for the given FIELD_DECL, or return 0 if we are unable to    determine what that offset is, either because the argument turns out to    be a pointer to an ERROR_MARK node, or because the offset is actually    variable.  (We can't handle the latter case just yet).  */
end_comment

begin_function
specifier|static
name|unsigned
name|field_byte_offset
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|unsigned
name|type_align_in_bytes
decl_stmt|;
specifier|register
name|unsigned
name|type_align_in_bits
decl_stmt|;
specifier|register
name|unsigned
name|type_size_in_bits
decl_stmt|;
specifier|register
name|unsigned
name|object_offset_in_align_units
decl_stmt|;
specifier|register
name|unsigned
name|object_offset_in_bits
decl_stmt|;
specifier|register
name|unsigned
name|object_offset_in_bytes
decl_stmt|;
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|tree
name|bitpos_tree
decl_stmt|;
specifier|register
name|tree
name|field_size_tree
decl_stmt|;
specifier|register
name|unsigned
name|bitpos_int
decl_stmt|;
specifier|register
name|unsigned
name|deepest_bitpos
decl_stmt|;
specifier|register
name|unsigned
name|field_size_in_bits
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|type
operator|=
name|field_type
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|bitpos_tree
operator|=
name|DECL_FIELD_BITPOS
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|field_size_tree
operator|=
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* We cannot yet cope with fields whose positions or sizes are variable, so       for now, when we see such things, we simply return 0.  Someday, we may      be able to handle such cases, but it will be damn difficult.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bitpos_tree
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|bitpos_int
operator|=
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|bitpos_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field_size_tree
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
literal|0
return|;
name|field_size_in_bits
operator|=
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|field_size_tree
argument_list|)
expr_stmt|;
name|type_size_in_bits
operator|=
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_align_in_bits
operator|=
name|simple_type_align_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_align_in_bytes
operator|=
name|type_align_in_bits
operator|/
name|BITS_PER_UNIT
expr_stmt|;
comment|/* Note that the GCC front-end doesn't make any attempt to keep track of      the starting bit offset (relative to the start of the containing      structure type) of the hypothetical "containing object" for a bit-      field.  Thus, when computing the byte offset value for the start of the      "containing object" of a bit-field, we must deduce this information on       our own. This can be rather tricky to do in some cases.  For example,      handling the following structure type definition when compiling for an      i386/i486 target (which only aligns long long's to 32-bit boundaries)      can be very tricky:  	 struct S { int field1; long long field2:31; };       Fortunately, there is a simple rule-of-thumb which can be      used in such cases.  When compiling for an i386/i486, GCC will allocate      8 bytes for the structure shown above.  It decides to do this based upon       one simple rule for bit-field allocation.  Quite simply, GCC allocates      each "containing object" for each bit-field at the first (i.e. lowest      addressed) legitimate alignment boundary (based upon the required      minimum alignment for the declared type of the field) which it can      possibly use, subject to the condition that there is still enough      available space remaining in the containing object (when allocated at      the selected point) to fully accommodate all of the bits of the      bit-field itself.  This simple rule makes it obvious why GCC allocates      8 bytes for each object of the structure type shown above.  When looking      for a place to allocate the "containing object" for `field2', the      compiler simply tries to allocate a 64-bit "containing object" at each      successive 32-bit boundary (starting at zero) until it finds a place to      allocate that 64- bit field such that at least 31 contiguous (and      previously unallocated) bits remain within that selected 64 bit field.      (As it turns out, for the example above, the compiler finds that it is      OK to allocate the "containing object" 64-bit field at bit-offset zero      within the structure type.) Here we attempt to work backwards from the      limited set of facts we're given, and we try to deduce from those facts,       where GCC must have believed that the containing object started (within      the structure type). The value we deduce is then used (by the callers of       this routine) to generate DW_AT_location and DW_AT_bit_offset attributes       for fields (both bit-fields and, in the case of DW_AT_location, regular      fields as well).  */
comment|/* Figure out the bit-distance from the start of the structure to the      "deepest" bit of the bit-field.  */
name|deepest_bitpos
operator|=
name|bitpos_int
operator|+
name|field_size_in_bits
expr_stmt|;
comment|/* This is the tricky part.  Use some fancy footwork to deduce where the      lowest addressed bit of the containing object must be.  */
name|object_offset_in_bits
operator|=
name|ceiling
argument_list|(
name|deepest_bitpos
argument_list|,
name|type_align_in_bits
argument_list|)
operator|-
name|type_size_in_bits
expr_stmt|;
comment|/* Compute the offset of the containing object in "alignment units".  */
name|object_offset_in_align_units
operator|=
name|object_offset_in_bits
operator|/
name|type_align_in_bits
expr_stmt|;
comment|/* Compute the offset of the containing object in bytes.  */
name|object_offset_in_bytes
operator|=
name|object_offset_in_align_units
operator|*
name|type_align_in_bytes
expr_stmt|;
return|return
name|object_offset_in_bytes
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following routines define various Dwarf attributes and any data    associated with them.  */
end_comment

begin_comment
comment|/* Add a location description attribute value to a DIE.     This emits location attributes suitable for whole variables and    whole parameters.  Note that the location attributes for struct fields are    generated by the routine `data_member_location_attribute' below.  */
end_comment

begin_function
specifier|static
name|void
name|add_AT_location_description
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|rtl
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
comment|/* Handle a special case.  If we are about to output a location descriptor      for a variable or parameter which has been optimized out of existence,      don't do that.  A variable which has been optimized out      of existence will have a DECL_RTL value which denotes a pseudo-reg.      Currently, in some rare cases, variables can have DECL_RTL values which      look like (MEM (REG pseudo-reg#)).  These cases are due to bugs      elsewhere in the compiler.  We treat such cases as if the variable(s) in       question had been optimized out of existence.  */
if|if
condition|(
name|is_pseudo_reg
argument_list|(
name|rtl
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|is_pseudo_reg
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|CONCAT
operator|&&
name|is_pseudo_reg
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|is_pseudo_reg
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return;
name|add_AT_loc
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|,
name|loc_descriptor
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach the specialized form of location attribute used for data    members of struct and union types.  In the special case of a    FIELD_DECL node which represents a bit-field, the "offset" part    of this special location descriptor must indicate the distance    in bytes from the lowest-addressed byte of the containing struct    or union type to the lowest-addressed byte of the "containing    object" for the bit-field.  (See the `field_byte_offset' function    above).. For any given bit-field, the "containing object" is a    hypothetical object (of some integral or enum type) within which    the given bit-field lives.  The type of this hypothetical    "containing object" is always the same as the declared type of    the individual bit-field itself (for GCC anyway... the DWARF    spec doesn't actually mandate this).  Note that it is the size    (in bytes) of the hypothetical "containing object" which will    be given in the DW_AT_byte_size attribute for this bit-field.    (See the `byte_size_attribute' function below.)  It is also used    when calculating the value of the DW_AT_bit_offset attribute.    (See the `bit_offset_attribute' function below).  */
end_comment

begin_function
specifier|static
name|void
name|add_data_member_location_attribute
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|offset
decl_stmt|;
specifier|register
name|dw_loc_descr_ref
name|loc_descr
decl_stmt|;
specifier|register
name|enum
name|dwarf_location_atom
name|op
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_VEC
condition|)
name|offset
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|offset
operator|=
name|field_byte_offset
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The DWARF2 standard says that we should assume that the structure address      is already on the stack, so we can specify a structure field address      by using DW_OP_plus_uconst.  */
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* ??? The SGI dwarf reader does not handle the DW_OP_plus_uconst operator      correctly.  It works only if we leave the offset on the stack.  */
name|op
operator|=
name|DW_OP_constu
expr_stmt|;
else|#
directive|else
name|op
operator|=
name|DW_OP_plus_uconst
expr_stmt|;
endif|#
directive|endif
name|loc_descr
operator|=
name|new_loc_descr
argument_list|(
name|op
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_AT_loc
argument_list|(
name|die
argument_list|,
name|DW_AT_data_member_location
argument_list|,
name|loc_descr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach an DW_AT_const_value attribute for a variable or a parameter which    does not have a "location" either in memory or in a register.  These    things can arise in GNU C when a constant is passed as an actual parameter    to an inlined function.  They can also arise in C++ where declared    constants do not necessarily get memory "homes".  */
end_comment

begin_function
specifier|static
name|void
name|add_const_value_attribute
parameter_list|(
name|die
parameter_list|,
name|rtl
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|rtx
name|rtl
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* Note that a CONST_INT rtx could represent either an integer or a          floating-point constant.  A CONST_INT is used whenever the constant          will fit into a single word.  In all such cases, the original mode          of the constant value is wiped out, and the CONST_INT rtx is          assigned VOIDmode.  */
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
operator|(
name|unsigned
operator|)
name|INTVAL
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_DOUBLE
case|:
comment|/* Note that a CONST_DOUBLE rtx could represent either an integer or a          floating-point constant.  A CONST_DOUBLE is used whenever the          constant requires more than one word in order to be adequately          represented.  We output CONST_DOUBLEs as blocks.  */
block|{
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
specifier|register
name|unsigned
name|length
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
decl_stmt|;
name|long
name|array
index|[
literal|4
index|]
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|array
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
case|case
name|TFmode
case|:
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|rv
argument_list|,
name|array
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|add_AT_float
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|length
argument_list|,
name|array
argument_list|)
expr_stmt|;
block|}
else|else
name|add_AT_long_long
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|rtl
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CONST_STRING
case|:
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|XSTR
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
name|add_AT_addr
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|addr_to_string
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* In cases where an inlined instance of an inline function is passed          the address of an `auto' variable (which is local to the caller) we          can get a situation where the DECL_RTL of the artificial local          variable (for the inlining) which acts as a stand-in for the          corresponding formal parameter (of the inline function) will look          like (plus:SI (reg:SI FRAME_PTR) (const_int ...)).  This is not          exactly a compile-time constant expression, but it isn't the address           of the (artificial) local variable either.  Rather, it represents the           *value* which the artificial local variable always has during its          lifetime.  We currently have no way to represent such quasi-constant           values in Dwarf, so for now we just punt and generate nothing.  */
break|break;
default|default:
comment|/* No other kinds of rtx should be possible here.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate *either* an DW_AT_location attribute or else an DW_AT_const_value    data attribute for a variable or a parameter.  We generate the    DW_AT_const_value attribute only in those cases where the given variable    or parameter does not have a true "location" either in memory or in a    register.  This can happen (for example) when a constant is passed as an    actual argument in a call to an inline function.  (It's possible that    these things can crop up in other ways also.)  Note that one type of    constant value which can be passed into an inlined function is a constant    pointer.  This can happen for example if an actual argument in an inlined    function call evaluates to a compile-time constant address.  */
end_comment

begin_function
specifier|static
name|void
name|add_location_or_const_value_attribute
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|rtx
name|rtl
decl_stmt|;
specifier|register
name|tree
name|declared_type
decl_stmt|;
specifier|register
name|tree
name|passed_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Here we have to decide where we are going to say the parameter "lives"      (as far as the debugger is concerned).  We only have a couple of      choices.  GCC provides us with DECL_RTL and with DECL_INCOMING_RTL.       DECL_RTL normally indicates where the parameter lives during most of the       activation of the function.  If optimization is enabled however, this      could be either NULL or else a pseudo-reg.  Both of those cases indicate       that the parameter doesn't really live anywhere (as far as the code      generation parts of GCC are concerned) during most of the function's      activation.  That will happen (for example) if the parameter is never      referenced within the function.       We could just generate a location descriptor here for all non-NULL      non-pseudo values of DECL_RTL and ignore all of the rest, but we can be      a little nicer than that if we also consider DECL_INCOMING_RTL in cases      where DECL_RTL is NULL or is a pseudo-reg.       Note however that we can only get away with using DECL_INCOMING_RTL as      a backup substitute for DECL_RTL in certain limited cases.  In cases      where DECL_ARG_TYPE (decl) indicates the same type as TREE_TYPE (decl),      we can be sure that the parameter was passed using the same type as it is      declared to have within the function, and that its DECL_INCOMING_RTL      points us to a place where a value of that type is passed.       In cases where DECL_ARG_TYPE (decl) and TREE_TYPE (decl) are different,      we cannot (in general) use DECL_INCOMING_RTL as a substitute for DECL_RTL      because in these cases DECL_INCOMING_RTL points us to a value of some      type which is *different* from the type of the parameter itself.  Thus,      if we tried to use DECL_INCOMING_RTL to generate a location attribute in      such cases, the debugger would end up (for example) trying to fetch a      `float' from a place which actually contains the first part of a      `double'.  That would lead to really incorrect and confusing      output at debug-time.       So, in general, we *do not* use DECL_INCOMING_RTL as a backup for DECL_RTL      in cases where DECL_ARG_TYPE (decl) != TREE_TYPE (decl).  There      are a couple of exceptions however.  On little-endian machines we can      get away with using DECL_INCOMING_RTL even when DECL_ARG_TYPE (decl) is      not the same as TREE_TYPE (decl), but only when DECL_ARG_TYPE (decl) is      an integral type that is smaller than TREE_TYPE (decl). These cases arise      when (on a little-endian machine) a non-prototyped function has a      parameter declared to be of type `short' or `char'.  In such cases,      TREE_TYPE (decl) will be `short' or `char', DECL_ARG_TYPE (decl) will      be `int', and DECL_INCOMING_RTL will point to the lowest-order byte of the      passed `int' value.  If the debugger then uses that address to fetch      a `short' or a `char' (on a little-endian machine) the result will be      the correct data, so we allow for such exceptional cases below.       Note that our goal here is to describe the place where the given formal      parameter lives during most of the function's activation (i.e. between      the end of the prologue and the start of the epilogue).  We'll do that      as best as we can. Note however that if the given formal parameter is      modified sometime during the execution of the function, then a stack      backtrace (at debug-time) will show the function as having been      called with the *new* value rather than the value which was      originally passed in.  This happens rarely enough that it is not      a major problem, but it *is* a problem, and I'd like to fix it.       A future version of dwarf2out.c may generate two additional      attributes for any given DW_TAG_formal_parameter DIE which will      describe the "passed type" and the "passed location" for the      given formal parameter in addition to the attributes we now      generate to indicate the "declared type" and the "active      location" for each parameter.  This additional set of attributes      could be used by debuggers for stack backtraces. Separately, note      that sometimes DECL_RTL can be NULL and DECL_INCOMING_RTL can be      NULL also.  This happens (for example) for inlined-instances of      inline function formal parameters which are never referenced.      This really shouldn't be happening.  All PARM_DECL nodes should      get valid non-NULL DECL_INCOMING_RTL values, but integrate.c      doesn't currently generate these values for inlined instances of      inline function parameters, so when we see such cases, we are      just out-of-luck for the time being (until integrate.c      gets fixed).  */
comment|/* Use DECL_RTL as the "location" unless we find something better.  */
name|rtl
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
operator|||
name|is_pseudo_reg
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
name|declared_type
operator|=
name|type_main_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|passed_type
operator|=
name|type_main_variant
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This decl represents a formal parameter which was optimized out. 	     Note that DECL_INCOMING_RTL may be NULL in here, but we handle 	     all* cases where (rtl == NULL_RTX) just below.  */
if|if
condition|(
name|declared_type
operator|==
name|passed_type
condition|)
name|rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|TREE_CODE
argument_list|(
name|declared_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|declared_type
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
operator|)
condition|)
name|rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* If the parm was passed in registers, but lives on the stack, then 	 make a big endian correction if the mode of the type of the 	 parameter is not the same as the mode of the rtl.  */
comment|/* ??? This is the same series of checks that are made in dbxout.c before 	 we reach the big endian correction code there.  It isn't clear if all 	 of these checks are necessary here, but keeping them all is the safe 	 thing to do.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
operator|!=
name|const0_rtx
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* Not passed in memory.  */
operator|&&
name|GET_CODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
comment|/* Not passed by invisible reference.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|)
comment|/* Big endian correction check.  */
operator|&&
name|BYTES_BIG_ENDIAN
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|)
condition|)
block|{
name|int
name|offset
init|=
operator|(
name|UNITS_PER_WORD
operator|-
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|rtl
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
condition|)
return|return;
name|rtl
operator|=
name|eliminate_regs
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|ADDRESSOF
case|:
comment|/* The address of a variable that was optimized away; don't emit 	 anything.  */
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_STRING
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|PLUS
case|:
comment|/* DECL_RTL could be (plus (reg ...) (const_int ...)) */
name|add_const_value_attribute
argument_list|(
name|die
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
case|case
name|CONCAT
case|:
name|add_AT_location_description
argument_list|(
name|die
argument_list|,
name|DW_AT_location
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate an DW_AT_name attribute given some string value to be included as    the value of the attribute.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_name_attribute
parameter_list|(
name|die
parameter_list|,
name|name_string
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|char
modifier|*
name|name_string
decl_stmt|;
block|{
if|if
condition|(
name|name_string
operator|!=
name|NULL
operator|&&
operator|*
name|name_string
operator|!=
literal|0
condition|)
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|name_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a tree node describing an array bound (either lower or upper) output    a representation for that bound.  */
end_comment

begin_function
specifier|static
name|void
name|add_bound_info
parameter_list|(
name|subrange_die
parameter_list|,
name|bound_attr
parameter_list|,
name|bound
parameter_list|)
specifier|register
name|dw_die_ref
name|subrange_die
decl_stmt|;
specifier|register
name|enum
name|dwarf_attribute
name|bound_attr
decl_stmt|;
specifier|register
name|tree
name|bound
decl_stmt|;
block|{
specifier|register
name|unsigned
name|bound_value
init|=
literal|0
decl_stmt|;
comment|/* If this is an Ada unconstrained array type, then don't emit any debug      info because the array bounds are unknown.  They are parameterized when      the type is instantiated.  */
if|if
condition|(
name|contains_placeholder_p
argument_list|(
name|bound
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|bound
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return;
comment|/* All fixed-bounds are represented by INTEGER_CST nodes.        */
case|case
name|INTEGER_CST
case|:
name|bound_value
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|bound_attr
operator|==
name|DW_AT_lower_bound
operator|&&
operator|(
operator|(
name|is_c_family
argument_list|()
operator|&&
name|bound_value
operator|==
literal|0
operator|)
operator|||
operator|(
name|is_fortran
argument_list|()
operator|&&
name|bound_value
operator|==
literal|1
operator|)
operator|)
condition|)
comment|/* use the default */
empty_stmt|;
else|else
name|add_AT_unsigned
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|bound_value
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|add_bound_info
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|TREE_OPERAND
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVE_EXPR
case|:
comment|/* If optimization is turned on, the SAVE_EXPRs that describe how to          access the upper bound values may be bogus.  If they refer to a          register, they may only describe how to get at these values at the          points in the generated code right after they have just been          computed.  Worse yet, in the typical case, the upper bound values          will not even *be* computed in the optimized code (though the          number of elements will), so these SAVE_EXPRs are entirely          bogus. In order to compensate for this fact, we check here to see          if optimization is enabled, and if so, we don't add an attribute          for the (unknown and unknowable) upper bound.  This should not          cause too much trouble for existing (stupid?)  debuggers because          they have to deal with empty upper bounds location descriptions          anyway in order to be able to deal with incomplete array types.          Of course an intelligent debugger (GDB?)  should be able to          comprehend that a missing upper bound specification in a array          type used for a storage class `auto' local array variable          indicates that the upper bound is both unknown (at compile- time)          and unknowable (at run-time) due to optimization.  	 We assume that a MEM rtx is safe because gcc wouldn't put the 	 value there unless it was going to be used repeatedly in the 	 function, i.e. for cleanups.  */
if|if
condition|(
operator|!
name|optimize
operator|||
name|GET_CODE
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|bound
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
specifier|register
name|dw_die_ref
name|ctx
init|=
name|lookup_decl_die
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
specifier|register
name|dw_die_ref
name|decl_die
init|=
name|new_die
argument_list|(
name|DW_TAG_variable
argument_list|,
name|ctx
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|loc
init|=
name|SAVE_EXPR_RTL
argument_list|(
name|bound
argument_list|)
decl_stmt|;
comment|/* If the RTL for the SAVE_EXPR is memory, handle the case where 	     it references an outer function's frame.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|new_addr
init|=
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bound
argument_list|)
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
operator|!=
name|new_addr
condition|)
name|loc
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|new_addr
argument_list|)
expr_stmt|;
block|}
name|add_AT_flag
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|decl_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|bound
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|add_AT_location_description
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_location
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|decl_die
argument_list|)
expr_stmt|;
block|}
comment|/* Else leave out the attribute.  */
break|break;
case|case
name|MAX_EXPR
case|:
case|case
name|VAR_DECL
case|:
case|case
name|COMPONENT_REF
case|:
comment|/* ??? These types of bounds can be created by the Ada front end, 	 and it isn't clear how to emit debug info for them.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Note that the block of subscript information for an array type also    includes information about the element type of type given array type.  */
end_comment

begin_function
specifier|static
name|void
name|add_subscript_info
parameter_list|(
name|type_die
parameter_list|,
name|type
parameter_list|)
specifier|register
name|dw_die_ref
name|type_die
decl_stmt|;
specifier|register
name|tree
name|type
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
specifier|register
name|unsigned
name|dimension_number
decl_stmt|;
endif|#
directive|endif
specifier|register
name|tree
name|lower
decl_stmt|,
name|upper
decl_stmt|;
specifier|register
name|dw_die_ref
name|subrange_die
decl_stmt|;
comment|/* The GNU compilers represent multidimensional array types as sequences of       one dimensional array types whose element types are themselves array      types.  Here we squish that down, so that each multidimensional array      type gets only one array_type DIE in the Dwarf debugging info. The draft       Dwarf specification say that we are allowed to do this kind of      compression in C (because there is no difference between an array or      arrays and a multidimensional array in C) but for other source languages       (e.g. Ada) we probably shouldn't do this.  */
comment|/* ??? The SGI dwarf reader fails for multidimensional arrays with a      const enum type.  E.g. const enum machine_mode insn_operand_mode[2][10].      We work around this by disabling this feature.  See also      gen_array_type_die.  */
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
for|for
control|(
name|dimension_number
operator|=
literal|0
init|;
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|,
name|dimension_number
operator|++
control|)
block|{
endif|#
directive|endif
specifier|register
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Arrays come in three flavors: Unspecified bounds, fixed bounds, 	 and (in GNU C only) variable bounds.  Handle all three forms           here.  */
name|subrange_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subrange_type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
condition|)
block|{
comment|/* We have an array type with specified bounds.  */
name|lower
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|upper
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
expr_stmt|;
comment|/* define the index type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
condition|)
block|{
comment|/* ??? This is probably an Ada unnamed subrange type.  Ignore the 		 TREE_TYPE field.  We can't emit debug info for this 		 because it is an unnamed integral type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|domain
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|domain
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
empty_stmt|;
else|else
name|add_type_attribute
argument_list|(
name|subrange_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
comment|/* ??? If upper is NULL, the array has unspecified length, 	     but it does have a lower bound.  This happens with Fortran 	       dimension arr(N:*)        	     Since the debugger is definitely going to need to know N 	     to produce useful results, go ahead and output the lower 	     bound solo, and hope the debugger can cope.  */
name|add_bound_info
argument_list|(
name|subrange_die
argument_list|,
name|DW_AT_lower_bound
argument_list|,
name|lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper
condition|)
name|add_bound_info
argument_list|(
name|subrange_die
argument_list|,
name|DW_AT_upper_bound
argument_list|,
name|upper
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We have an array type with an unspecified length.  The DWARF-2 	     spec does not say how to handle this; let's just leave out the 	     bounds.  */
block|{
empty_stmt|;
block|}
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|add_byte_size_attribute
parameter_list|(
name|die
parameter_list|,
name|tree_node
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|tree
name|tree_node
decl_stmt|;
block|{
specifier|register
name|unsigned
name|size
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|tree_node
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|tree_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD_DECL
case|:
comment|/* For a data member of a struct or union, the DW_AT_byte_size is          generally given as the number of bytes normally allocated for an          object of the *declared* type of the member itself.  This is true          even for bit-fields.  */
name|size
operator|=
name|simple_type_size_in_bits
argument_list|(
name|field_type
argument_list|(
name|tree_node
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Note that `size' might be -1 when we get to this point.  If it is, that      indicates that the byte size of the entity in question is variable.  We      have no good way of expressing this fact in Dwarf at the present time,      so just let the -1 pass on through.  */
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a FIELD_DECL node which represents a bit-field, output an attribute    which specifies the distance in bits from the highest order bit of the    "containing object" for the bit-field to the highest order bit of the    bit-field itself.     For any given bit-field, the "containing object" is a hypothetical    object (of some integral or enum type) within which the given bit-field    lives.  The type of this hypothetical "containing object" is always the    same as the declared type of the individual bit-field itself.  The    determination of the exact location of the "containing object" for a    bit-field is rather complicated.  It's handled by the    `field_byte_offset' function (above).     Note that it is the size (in bytes) of the hypothetical "containing object"    which will be given in the DW_AT_byte_size attribute for this bit-field.    (See `byte_size_attribute' above).  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_bit_offset_attribute
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|unsigned
name|object_offset_in_bytes
init|=
name|field_byte_offset
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|type
init|=
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|bitpos_tree
init|=
name|DECL_FIELD_BITPOS
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|bitpos_int
decl_stmt|;
specifier|register
name|unsigned
name|highest_order_object_bit_offset
decl_stmt|;
specifier|register
name|unsigned
name|highest_order_field_bit_offset
decl_stmt|;
specifier|register
name|unsigned
name|bit_offset
decl_stmt|;
comment|/* Must be a field and a bit field.  */
if|if
condition|(
operator|!
name|type
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We can't yet handle bit-fields whose offsets are variable, so if we      encounter such things, just return without generating any attribute      whatsoever.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bitpos_tree
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return;
name|bitpos_int
operator|=
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|bitpos_tree
argument_list|)
expr_stmt|;
comment|/* Note that the bit offset is always the distance (in bits) from the      highest-order bit of the "containing object" to the highest-order bit of       the bit-field itself.  Since the "high-order end" of any object or field       is different on big-endian and little-endian machines, the computation      below must take account of these differences.  */
name|highest_order_object_bit_offset
operator|=
name|object_offset_in_bytes
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|highest_order_field_bit_offset
operator|=
name|bitpos_int
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|highest_order_field_bit_offset
operator|+=
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|highest_order_object_bit_offset
operator|+=
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|bit_offset
operator|=
operator|(
operator|!
name|BYTES_BIG_ENDIAN
condition|?
name|highest_order_object_bit_offset
operator|-
name|highest_order_field_bit_offset
else|:
name|highest_order_field_bit_offset
operator|-
name|highest_order_object_bit_offset
operator|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_bit_offset
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a FIELD_DECL node which represents a bit field, output an attribute    which specifies the length in bits of the given field.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_bit_size_attribute
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
comment|/* Must be a field and a bit field.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
operator|!
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_bit_size
argument_list|,
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the compiled language is ANSI C, then add a 'prototyped'    attribute, if arg types are given for the parameters of a function.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_prototyped_attribute
parameter_list|(
name|die
parameter_list|,
name|func_type
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|tree
name|func_type
decl_stmt|;
block|{
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
operator|==
name|DW_LANG_C89
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|func_type
argument_list|)
operator|!=
name|NULL
condition|)
name|add_AT_flag
argument_list|(
name|die
argument_list|,
name|DW_AT_prototyped
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an 'abstract_origin' attribute below a given DIE.  The DIE is found    by looking in either the type declaration or object declaration    equate table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_abstract_origin_attribute
parameter_list|(
name|die
parameter_list|,
name|origin
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|tree
name|origin
decl_stmt|;
block|{
name|dw_die_ref
name|origin_die
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
name|origin_die
operator|=
name|lookup_decl_die
argument_list|(
name|origin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|origin_die
operator|=
name|lookup_type_die
argument_list|(
name|origin
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|die
argument_list|,
name|DW_AT_abstract_origin
argument_list|,
name|origin_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We do not currently support the pure_virtual attribute.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_pure_or_virtual_attribute
parameter_list|(
name|die
parameter_list|,
name|func_decl
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|tree
name|func_decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|func_decl
argument_list|)
condition|)
block|{
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_virtuality
argument_list|,
name|DW_VIRTUALITY_virtual
argument_list|)
expr_stmt|;
name|add_AT_loc
argument_list|(
name|die
argument_list|,
name|DW_AT_vtable_elem_location
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_constu
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|func_decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* GNU extension: Record what type this method came from originally.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
name|add_AT_die_ref
argument_list|(
name|die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|lookup_type_die
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|func_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add source coordinate attributes for the given decl.  */
end_comment

begin_function
specifier|static
name|void
name|add_src_coords_attributes
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|unsigned
name|file_index
init|=
name|lookup_filename
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_file
argument_list|,
name|file_index
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_line
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an DW_AT_name attribute and source coordinate attribute for the    given decl, but only if it actually has a name.  */
end_comment

begin_function
specifier|static
name|void
name|add_name_and_src_coords_attributes
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|tree
name|decl_name
decl_stmt|;
name|decl_name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_name
operator|!=
name|NULL
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|decl_name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|add_name_attribute
argument_list|(
name|die
argument_list|,
name|dwarf2_name
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_src_coords_attributes
argument_list|(
name|die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_MIPS_linkage_name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Push a new declaration scope. */
end_comment

begin_function
specifier|static
name|void
name|push_decl_scope
parameter_list|(
name|scope
parameter_list|)
name|tree
name|scope
decl_stmt|;
block|{
name|tree
name|containing_scope
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Make room in the decl_scope_table, if necessary.  */
if|if
condition|(
name|decl_scope_table_allocated
operator|==
name|decl_scope_depth
condition|)
block|{
name|decl_scope_table_allocated
operator|+=
name|DECL_SCOPE_TABLE_INCREMENT
expr_stmt|;
name|decl_scope_table
operator|=
operator|(
name|decl_scope_node
operator|*
operator|)
name|xrealloc
argument_list|(
name|decl_scope_table
argument_list|,
operator|(
name|decl_scope_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|decl_scope_node
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|decl_scope_table
index|[
name|decl_scope_depth
index|]
operator|.
name|scope
operator|=
name|scope
expr_stmt|;
comment|/* Sometimes, while recursively emitting subtypes within a class type,      we end up recuring on a subtype at a higher level then the current      subtype.  In such a case, we need to search the decl_scope_table to      find the parent of this subtype.  */
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|scope
argument_list|)
condition|)
name|containing_scope
operator|=
name|TYPE_CONTEXT
argument_list|(
name|scope
argument_list|)
expr_stmt|;
else|else
name|containing_scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* The normal case.  */
if|if
condition|(
name|decl_scope_depth
operator|==
literal|0
operator|||
name|containing_scope
operator|==
name|NULL_TREE
comment|/* Ignore namespaces for the moment.  */
operator|||
name|TREE_CODE
argument_list|(
name|containing_scope
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|||
name|containing_scope
operator|==
name|decl_scope_table
index|[
name|decl_scope_depth
operator|-
literal|1
index|]
operator|.
name|scope
condition|)
name|decl_scope_table
index|[
name|decl_scope_depth
index|]
operator|.
name|previous
operator|=
name|decl_scope_depth
operator|-
literal|1
expr_stmt|;
else|else
block|{
comment|/* We need to search for the containing_scope.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|decl_scope_depth
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|decl_scope_table
index|[
name|i
index|]
operator|.
name|scope
operator|==
name|containing_scope
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|decl_scope_depth
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|decl_scope_table
index|[
name|decl_scope_depth
index|]
operator|.
name|previous
operator|=
name|i
expr_stmt|;
block|}
name|decl_scope_depth
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the DIE for the scope that immediately contains this declaration.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|scope_die_for
parameter_list|(
name|t
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|scope_die
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|containing_scope
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Walk back up the declaration tree looking for a place to define      this type.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|containing_scope
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_VINDEX
argument_list|(
name|t
argument_list|)
condition|)
name|containing_scope
operator|=
name|decl_class_context
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
name|containing_scope
operator|=
name|DECL_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Ignore namespaces for the moment.  */
if|if
condition|(
name|containing_scope
operator|&&
name|TREE_CODE
argument_list|(
name|containing_scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|containing_scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Ignore function type "scopes" from the C frontend.  They mean that      a tagged type is local to a parmlist of a function declarator, but      that isn't useful to DWARF.  */
if|if
condition|(
name|containing_scope
operator|&&
name|TREE_CODE
argument_list|(
name|containing_scope
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|containing_scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Function-local tags and functions get stuck in limbo until they are      fixed up by decls_for_scope.  */
if|if
condition|(
name|context_die
operator|==
name|NULL
operator|&&
name|containing_scope
operator|!=
name|NULL_TREE
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|is_tagged_type
argument_list|(
name|t
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|containing_scope
operator|==
name|NULL_TREE
condition|)
name|scope_die
operator|=
name|comp_unit_die
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
name|decl_scope_depth
operator|-
literal|1
operator|,
name|scope_die
operator|=
name|context_die
init|;
name|i
operator|>=
literal|0
operator|&&
name|decl_scope_table
index|[
name|i
index|]
operator|.
name|scope
operator|!=
name|containing_scope
condition|;
operator|(
name|scope_die
operator|=
name|scope_die
operator|->
name|die_parent
operator|,
name|i
operator|=
name|decl_scope_table
index|[
name|i
index|]
operator|.
name|previous
operator|)
control|)
empty_stmt|;
comment|/* ??? Integrate_decl_tree does not handle BLOCK_TYPE_TAGS, nor 	 does it try to handle types defined by TYPE_DECLs.  Such types 	 thus have an incorrect TYPE_CONTEXT, which points to the block 	 they were originally defined in, instead of the current block 	 created by function inlining.  We try to detect that here and 	 work around it.  */
if|if
condition|(
name|i
operator|<
literal|0
operator|&&
name|scope_die
operator|==
name|comp_unit_die
operator|&&
name|TREE_CODE
argument_list|(
name|containing_scope
argument_list|)
operator|==
name|BLOCK
operator|&&
name|is_tagged_type
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|block_ultimate_origin
argument_list|(
name|decl_scope_table
index|[
name|decl_scope_depth
operator|-
literal|1
index|]
operator|.
name|scope
argument_list|)
operator|==
name|containing_scope
operator|)
condition|)
block|{
name|scope_die
operator|=
name|context_die
expr_stmt|;
comment|/* Since the checks below are no longer applicable.  */
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|containing_scope
argument_list|)
argument_list|)
operator|!=
literal|'t'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|containing_scope
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If none of the current dies are suitable, we get file scope.  */
name|scope_die
operator|=
name|comp_unit_die
expr_stmt|;
block|}
block|}
return|return
name|scope_die
return|;
block|}
end_function

begin_comment
comment|/* Pop a declaration scope.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pop_decl_scope
parameter_list|()
block|{
if|if
condition|(
name|decl_scope_depth
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
operator|--
name|decl_scope_depth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Many forms of DIEs require a "type description" attribute.  This    routine locates the proper "type descriptor" die for the type given    by 'type', and adds an DW_AT_type attribute below the given die.  */
end_comment

begin_function
specifier|static
name|void
name|add_type_attribute
parameter_list|(
name|object_die
parameter_list|,
name|type
parameter_list|,
name|decl_const
parameter_list|,
name|decl_volatile
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|dw_die_ref
name|object_die
decl_stmt|;
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|int
name|decl_const
decl_stmt|;
specifier|register
name|int
name|decl_volatile
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|dw_die_ref
name|type_die
init|=
name|NULL
decl_stmt|;
comment|/* ??? If this type is an unnamed subrange type of an integral or      floating-point type, use the inner type.  This is because we have no      support for unnamed types in base_type_die.  This can happen if this is      an Ada subrange type.  Correct solution is emit a subrange type die.  */
if|if
condition|(
operator|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|,
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* Handle a special case.  For functions whose return type is void, we      generate *no* type attribute.  (Note that no object may have type      `void', so this only applies to function return types).  */
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
condition|)
return|return;
name|type_die
operator|=
name|modified_type_die
argument_list|(
name|type
argument_list|,
name|decl_const
operator|||
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|decl_volatile
operator|||
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_die
operator|!=
name|NULL
condition|)
name|add_AT_die_ref
argument_list|(
name|object_die
argument_list|,
name|DW_AT_type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a tree pointer to a struct, class, union, or enum type node, return    a pointer to the (string) tag name for the given type, or zero if the type    was declared without a tag.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|type_tag
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|tree
name|t
init|=
literal|0
decl_stmt|;
comment|/* Find the IDENTIFIER_NODE for the type name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The g++ front end makes the TYPE_NAME of *each* tagged type point to           a TYPE_DECL node, regardless of whether or not a `typedef' was          involved.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now get the name as a string, or invent one.  */
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|==
literal|0
operator|||
operator|*
name|name
operator|==
literal|'\0'
operator|)
condition|?
literal|0
else|:
name|name
return|;
block|}
end_function

begin_comment
comment|/* Return the type associated with a data member, make a special check    for bit field types.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|member_declared_type
parameter_list|(
name|member
parameter_list|)
specifier|register
name|tree
name|member
decl_stmt|;
block|{
return|return
operator|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|member
argument_list|)
condition|?
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|member
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the decl's label, as described by its RTL. This may be different    from the DECL_NAME name used in the source file.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char * decl_start_label (decl)      register tree decl; {   rtx x;   char *fnname;   x = DECL_RTL (decl);   if (GET_CODE (x) != MEM)     abort ();    x = XEXP (x, 0);   if (GET_CODE (x) != SYMBOL_REF)     abort ();    fnname = XSTR (x, 0);   return fnname; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* These routines generate the internal representation of the DIE's for    the compilation unit.  Debugging information is collected by walking    the declaration trees passed in from dwarf2out_decl().  */
end_comment

begin_function
specifier|static
name|void
name|gen_array_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|scope_die
init|=
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
decl_stmt|;
specifier|register
name|dw_die_ref
name|array_die
decl_stmt|;
specifier|register
name|tree
name|element_type
decl_stmt|;
comment|/* ??? The SGI dwarf reader fails for array of array of enum types unless      the inner array type comes before the outer array type.  Thus we must      call gen_type_die before we call new_die.  See below also.  */
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|array_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_array_type
argument_list|,
name|scope_die
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We default the array ordering.  SDB will probably do      the right things even if DW_AT_ordering is not present.  It's not even      an issue until we start to get into multidimensional arrays anyway.  If      SDB is ever caught doing the Wrong Thing for multi-dimensional arrays,      then we'll have to put the DW_AT_ordering attribute back in.  (But if      and when we find out that we need to put these in, we will only do so      for multidimensional arrays.  */
block|add_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_row_major);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* The SGI compilers handle arrays of unknown bound by setting      AT_declaration and not emitting any subrange DIEs.  */
if|if
condition|(
operator|!
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|array_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|add_subscript_info
argument_list|(
name|array_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|array_die
argument_list|)
expr_stmt|;
comment|/* Add representation of the type of the elements of this array type.  */
name|element_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* ??? The SGI dwarf reader fails for multidimensional arrays with a      const enum type.  E.g. const enum machine_mode insn_operand_mode[2][10].      We work around this by disabling this feature.  See also      add_subscript_info.  */
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
while|while
condition|(
name|TREE_CODE
argument_list|(
name|element_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|element_type
operator|=
name|TREE_TYPE
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|gen_type_die
argument_list|(
name|element_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_type_attribute
argument_list|(
name|array_die
argument_list|,
name|element_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_set_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_set_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|)
decl_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|type_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void gen_entry_point_die (decl, context_die)      register tree decl;      register dw_die_ref context_die; {   register tree origin = decl_ultimate_origin (decl);   register dw_die_ref decl_die = new_die (DW_TAG_entry_point, context_die);   if (origin != NULL)     add_abstract_origin_attribute (decl_die, origin);   else     {       add_name_and_src_coords_attributes (decl_die, decl);       add_type_attribute (decl_die, TREE_TYPE (TREE_TYPE (decl)), 			  0, 0, context_die);     }    if (DECL_ABSTRACT (decl))     equate_decl_number_to_die (decl, decl_die);   else     add_AT_lbl_id (decl_die, DW_AT_low_pc, decl_start_label (decl)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Remember a type in the pending_types_list.  */
end_comment

begin_function
specifier|static
name|void
name|pend_type
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|pending_types
operator|==
name|pending_types_allocated
condition|)
block|{
name|pending_types_allocated
operator|+=
name|PENDING_TYPES_INCREMENT
expr_stmt|;
name|pending_types_list
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|pending_types_list
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|pending_types_allocated
argument_list|)
expr_stmt|;
block|}
name|pending_types_list
index|[
name|pending_types
operator|++
index|]
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output any pending types (from the pending_types list) which we can output    now (taking into account the scope that we are working on now).     For each type output, remove the given type from the pending_types_list    *before* we try to output it.  */
end_comment

begin_function
specifier|static
name|void
name|output_pending_types_for_scope
parameter_list|(
name|context_die
parameter_list|)
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|tree
name|type
decl_stmt|;
while|while
condition|(
name|pending_types
condition|)
block|{
operator|--
name|pending_types
expr_stmt|;
name|type
operator|=
name|pending_types_list
index|[
name|pending_types
index|]
expr_stmt|;
name|gen_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remember a type in the incomplete_types_list.  */
end_comment

begin_function
specifier|static
name|void
name|add_incomplete_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|incomplete_types
operator|==
name|incomplete_types_allocated
condition|)
block|{
name|incomplete_types_allocated
operator|+=
name|INCOMPLETE_TYPES_INCREMENT
expr_stmt|;
name|incomplete_types_list
operator|=
operator|(
name|tree
operator|*
operator|)
name|xrealloc
argument_list|(
name|incomplete_types_list
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
operator|*
name|incomplete_types_allocated
argument_list|)
expr_stmt|;
block|}
name|incomplete_types_list
index|[
name|incomplete_types
operator|++
index|]
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Walk through the list of incomplete types again, trying once more to    emit full debugging info for them.  */
end_comment

begin_function
specifier|static
name|void
name|retry_incomplete_types
parameter_list|()
block|{
specifier|register
name|tree
name|type
decl_stmt|;
while|while
condition|(
name|incomplete_types
condition|)
block|{
operator|--
name|incomplete_types
expr_stmt|;
name|type
operator|=
name|incomplete_types_list
index|[
name|incomplete_types
index|]
expr_stmt|;
name|gen_type_die
argument_list|(
name|type
argument_list|,
name|comp_unit_die
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an inlined instance of an enumeration type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_enumeration_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_enumeration_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an inlined instance of a structure type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_structure_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_structure_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an inlined instance of a union type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_union_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_union_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an enumeration type.  Note that these DIEs    include all of the information about the enumeration values also. Each    enumerated type name/value is listed as a child of the enumerated type    DIE.  */
end_comment

begin_function
specifier|static
name|void
name|gen_enumeration_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|type_die
init|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type_die
operator|==
name|NULL
condition|)
block|{
name|type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_enumeration_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|)
expr_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|add_name_attribute
argument_list|(
name|type_die
argument_list|,
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
return|return;
else|else
name|remove_AT
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|)
expr_stmt|;
comment|/* Handle a GNU C/C++ extension, i.e. incomplete enum types.  If the      given enum type is incomplete, do not generate the DW_AT_byte_size      attribute or the DW_AT_element_list attribute.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|link
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_byte_size_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|add_src_coords_attributes
argument_list|(
name|type_die
argument_list|,
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the first reference to this type was as the return type of an 	 inline function, then it may not have a parent.  Fix this now.  */
if|if
condition|(
name|type_die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
name|add_child_die
argument_list|(
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|link
operator|!=
name|NULL
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|dw_die_ref
name|enum_die
init|=
name|new_die
argument_list|(
name|DW_TAG_enumerator
argument_list|,
name|type_die
argument_list|)
decl_stmt|;
name|add_name_attribute
argument_list|(
name|enum_die
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|enum_die
argument_list|,
name|DW_AT_const_value
argument_list|,
operator|(
name|unsigned
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|add_AT_flag
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent either a real live formal parameter decl or to    represent just the type of some formal parameter position in some function    type.     Note that this routine is a bit unusual because its argument may be a    ..._DECL node (i.e. either a PARM_DECL or perhaps a VAR_DECL which    represents an inlining of some PARM_DECL) or else some sort of a ..._TYPE    node.  If it's the former then this function is being called to output a    DIE to represent a formal parameter object (or some inlining thereof).  If    it's the latter, then this function is only being called to output a    DW_TAG_formal_parameter DIE to stand as a placeholder for some formal    argument type of some subprogram type.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|gen_formal_parameter_die
parameter_list|(
name|node
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|node
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|parm_die
init|=
name|new_die
argument_list|(
name|DW_TAG_formal_parameter
argument_list|,
name|context_die
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|origin
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
name|origin
operator|=
name|decl_ultimate_origin
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|parm_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|add_name_and_src_coords_attributes
argument_list|(
name|parm_die
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|parm_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|node
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|node
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|parm_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|equate_decl_number_to_die
argument_list|(
name|node
argument_list|,
name|parm_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_ABSTRACT
argument_list|(
name|node
argument_list|)
condition|)
name|add_location_or_const_value_attribute
argument_list|(
name|parm_die
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* We were called with some kind of a ..._TYPE node.  */
name|add_type_attribute
argument_list|(
name|parm_die
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|parm_die
return|;
block|}
end_function

begin_comment
comment|/* Generate a special type of DIE used as a stand-in for a trailing ellipsis    at the end of an (ANSI prototyped) formal parameters list.  */
end_comment

begin_function
specifier|static
name|void
name|gen_unspecified_parameters_die
parameter_list|(
name|decl_or_type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|decl_or_type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|new_die
argument_list|(
name|DW_TAG_unspecified_parameters
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a list of nameless DW_TAG_formal_parameter DIEs (and perhaps a    DW_TAG_unspecified_parameters DIE) to represent the types of the formal    parameters as specified in some function type specification (except for    those which appear as part of a function *definition*).     Note we must be careful here to output all of the parameter DIEs before*    we output any DIEs needed to represent the types of the formal parameters.    This keeps svr4 SDB happy because it (incorrectly) thinks that the first    non-parameter DIE it sees ends the formal parameter list.  */
end_comment

begin_function
specifier|static
name|void
name|gen_formal_types_die
parameter_list|(
name|function_or_method_type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|function_or_method_type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
specifier|register
name|tree
name|formal_type
init|=
name|NULL
decl_stmt|;
specifier|register
name|tree
name|first_parm_type
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|function_or_method_type
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* In the case where we are generating a formal types list for a C++      non-static member function type, skip over the first thing on the      TYPE_ARG_TYPES list because it only represents the type of the hidden      `this pointer'.  The debugger should be able to figure out (without      being explicitly told) that this non-static member function type takes a       `this pointer' and should be able to figure what the type of that hidden       parameter is from the DW_AT_member attribute of the parent      DW_TAG_subroutine_type DIE.  */
block|if (TREE_CODE (function_or_method_type) == METHOD_TYPE)     first_parm_type = TREE_CHAIN (first_parm_type);
endif|#
directive|endif
comment|/* Make our first pass over the list of formal parameter types and output a       DW_TAG_formal_parameter DIE for each one.  */
for|for
control|(
name|link
operator|=
name|first_parm_type
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|dw_die_ref
name|parm_die
decl_stmt|;
name|formal_type
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|==
name|void_type_node
condition|)
break|break;
comment|/* Output a (nameless) DIE to represent the formal parameter itself.  */
name|parm_die
operator|=
name|gen_formal_parameter_die
argument_list|(
name|formal_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function_or_method_type
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|link
operator|==
name|first_parm_type
condition|)
name|add_AT_flag
argument_list|(
name|parm_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If this function type has an ellipsis, add a      DW_TAG_unspecified_parameters DIE to the end of the parameter list.  */
if|if
condition|(
name|formal_type
operator|!=
name|void_type_node
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|function_or_method_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Make our second (and final) pass over the list of formal parameter types       and output DIEs to represent those types (as necessary).  */
for|for
control|(
name|link
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|function_or_method_type
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|formal_type
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|==
name|void_type_node
condition|)
break|break;
name|gen_type_die
argument_list|(
name|formal_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent a declared function (either file-scope or    block-local).  */
end_comment

begin_function
specifier|static
name|void
name|gen_subprogram_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|char
name|label_id
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|dw_die_ref
name|subr_die
decl_stmt|;
specifier|register
name|rtx
name|fp_reg
decl_stmt|;
specifier|register
name|tree
name|fn_arg_types
decl_stmt|;
specifier|register
name|tree
name|outer_scope
decl_stmt|;
specifier|register
name|dw_die_ref
name|old_die
init|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|int
name|declaration
init|=
operator|(
name|current_function_decl
operator|!=
name|decl
operator|||
operator|(
name|context_die
operator|&&
operator|(
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_structure_type
operator|||
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_union_type
operator|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
block|{
name|subr_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subprogram
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|add_abstract_origin_attribute
argument_list|(
name|subr_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_die
operator|&&
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|&&
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_inline
argument_list|)
condition|)
block|{
comment|/* This must be a redefinition of an extern inline function. 	 We can just reuse the old die here.  */
name|subr_die
operator|=
name|old_die
expr_stmt|;
comment|/* Clear out the inlined attribute and parm types.  */
name|remove_AT
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_inline
argument_list|)
expr_stmt|;
name|remove_children
argument_list|(
name|subr_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_die
condition|)
block|{
specifier|register
name|unsigned
name|file_index
init|=
name|lookup_filename
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_AT_flag
argument_list|(
name|old_die
argument_list|,
name|DW_AT_declaration
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* ??? This can happen if there is a bug in the program, for 	     instance, if it has duplicate function definitions.  Ideally, 	     we should detect this case and ignore it.  For now, if we have 	     already reported an error, any error at all, then assume that 	     we got here because of a input error, not a dwarf2 bug.  */
specifier|extern
name|int
name|errorcount
decl_stmt|;
if|if
condition|(
name|errorcount
condition|)
return|return;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If the definition comes from the same place as the declaration, 	 maybe use the old DIE.  We always want the DIE for this function 	 that has the *_pc attributes to be under comp_unit_die so the 	 debugger can find it.  For inlines, that is the concrete instance, 	 so we can use the old DIE here.  For non-inline methods, we want a 	 specification DIE at toplevel, so we need a new DIE.  For local 	 class methods, this does not apply.  */
if|if
condition|(
operator|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|||
name|old_die
operator|->
name|die_parent
operator|==
name|comp_unit_die
operator|||
name|context_die
operator|==
name|NULL
operator|)
operator|&&
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_file
argument_list|)
operator|==
name|file_index
operator|&&
operator|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_line
argument_list|)
operator|==
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|subr_die
operator|=
name|old_die
expr_stmt|;
comment|/* Clear out the declaration attribute and the parm types.  */
name|remove_AT
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_declaration
argument_list|)
expr_stmt|;
name|remove_children
argument_list|(
name|subr_die
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subr_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subprogram
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_specification
argument_list|,
name|old_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_file
argument_list|)
operator|!=
name|file_index
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_decl_file
argument_list|,
name|file_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_line
argument_list|)
operator|!=
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_decl_line
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|dw_die_ref
name|scope_die
decl_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
name|scope_die
operator|=
name|scope_die_for
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
else|else
comment|/* Don't put block extern declarations under comp_unit_die.  */
name|scope_die
operator|=
name|context_die
expr_stmt|;
name|subr_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subprogram
argument_list|,
name|scope_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_external
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_name_and_src_coords_attributes
argument_list|(
name|subr_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|add_prototyped_attribute
argument_list|(
name|subr_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|subr_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
name|add_pure_or_virtual_attribute
argument_list|(
name|subr_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_private
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declaration
condition|)
block|{
name|add_AT_flag
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The first time we see a member function, it is in the context of          the class to which it belongs.  We make sure of this by emitting          the class first.  The next time is the definition, which is          handled above.  The two may come from the same source text.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* ??? Checking DECL_DEFER_OUTPUT is correct for static inline functions, 	 but not for extern inline functions.  We can't get this completely 	 correct because information about whether the function was declared 	 inline is not saved anywhere.  */
if|if
condition|(
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_inline
argument_list|,
name|DW_INL_declared_inlined
argument_list|)
expr_stmt|;
else|else
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_inline
argument_list|,
name|DW_INL_declared_not_inlined
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_inline
argument_list|,
name|DW_INL_inlined
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|origin
operator|==
name|NULL_TREE
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label_id
argument_list|,
name|FUNC_BEGIN_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|label_id
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label_id
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|label_id
argument_list|)
expr_stmt|;
name|add_pubname
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
name|add_arange
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* Add a reference to the FDE for this routine.  */
name|add_AT_fde_ref
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_MIPS_fde
argument_list|,
name|current_funcdef_fde
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Define the "frame base" location for this routine.  We use the          frame pointer or stack pointer registers, since the RTL for local          variables is relative to one of them.  */
name|fp_reg
operator|=
name|frame_pointer_needed
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
expr_stmt|;
name|add_AT_loc
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_frame_base
argument_list|,
name|reg_loc_descriptor
argument_list|(
name|fp_reg
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ??? This fails for nested inline functions, because context_display 	 is not part of the state saved/restored for inline functions.  */
block|if (current_function_needs_context) 	add_AT_location_description (subr_die, DW_AT_static_link, 				     lookup_static_chain (decl));
endif|#
directive|endif
block|}
comment|/* Now output descriptions of the arguments for this function. This gets      (unnecessarily?) complex because of the fact that the DECL_ARGUMENT list       for a FUNCTION_DECL doesn't indicate cases where there was a trailing      `...' at the end of the formal parameter list.  In order to find out if      there was a trailing ellipsis or not, we must instead look at the type      associated with the FUNCTION_DECL.  This will be a node of type      FUNCTION_TYPE. If the chain of type nodes hanging off of this      FUNCTION_TYPE node ends with a void_type_node then there should *not* be       an ellipsis at the end.  */
name|push_decl_scope
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* In the case where we are describing a mere function declaration, all we      need to do here (and all we *can* do here) is to describe the *types* of       its formal parameters.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|declaration
condition|)
name|gen_formal_types_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Generate DIEs to represent all known formal parameters */
specifier|register
name|tree
name|arg_decls
init|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
comment|/* When generating DIEs, generate the unspecified_parameters DIE          instead if we come across the arg "__builtin_va_alist" */
for|for
control|(
name|parm
operator|=
name|arg_decls
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|parm
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
else|else
name|gen_decl_die
argument_list|(
name|parm
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
comment|/* Decide whether we need a unspecified_parameters DIE at the end.          There are 2 more cases to do this for: 1) the ansi ... declaration -           this is detectable when the end of the arg list is not a          void_type_node 2) an unprototyped function declaration (not a          definition).  This just means that we have no info about the          parameters at all.  */
name|fn_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_arg_types
operator|!=
name|NULL
condition|)
block|{
comment|/* this is the prototyped case, check for ...  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|fn_arg_types
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
comment|/* Output Dwarf info for all of the stuff within the body of the function      (if it has one - it may be just a declaration).  */
name|outer_scope
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Note that here, `outer_scope' is a pointer to the outermost BLOCK      node created to represent a function. This outermost BLOCK actually      represents the outermost binding contour for the function, i.e. the      contour in which the function's formal parameters and labels get      declared. Curiously, it appears that the front end doesn't actually      put the PARM_DECL nodes for the current function onto the BLOCK_VARS      list for this outer scope.  (They are strung off of the DECL_ARGUMENTS      list for the function instead.) The BLOCK_VARS list for the      `outer_scope' does provide us with a list of the LABEL_DECL nodes for      the function however, and we output DWARF info for those in      decls_for_scope.  Just within the `outer_scope' there will be a BLOCK      node representing the function's outermost pair of curly braces, and      any blocks used for the base and member initializers of a C++      constructor function.  */
if|if
condition|(
operator|!
name|declaration
operator|&&
name|TREE_CODE
argument_list|(
name|outer_scope
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
name|current_function_has_inlines
operator|=
literal|0
expr_stmt|;
name|decls_for_scope
argument_list|(
name|outer_scope
argument_list|,
name|subr_die
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|MIPS_DEBUGGING_INFO
argument_list|)
block|if (current_function_has_inlines) 	{ 	  add_AT_flag (subr_die, DW_AT_MIPS_has_inlines, 1); 	  if (! comp_unit_has_inlines) 	    { 	      add_AT_flag (comp_unit_die, DW_AT_MIPS_has_inlines, 1); 	      comp_unit_has_inlines = 1; 	    } 	}
endif|#
directive|endif
block|}
name|pop_decl_scope
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent a declared data object.  */
end_comment

begin_function
specifier|static
name|void
name|gen_variable_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|dw_die_ref
name|var_die
init|=
name|new_die
argument_list|(
name|DW_TAG_variable
argument_list|,
name|context_die
argument_list|)
decl_stmt|;
name|dw_die_ref
name|old_die
init|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|declaration
init|=
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|current_function_decl
operator|!=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|||
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_structure_type
operator|||
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_union_type
operator|)
decl_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|var_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
comment|/* Loop unrolling can create multiple blocks that refer to the same      static variable, so we must test for the DW_AT_declaration flag.  */
comment|/* ??? Loop unrolling/reorder_blocks should perhaps be rewritten to      copy decls and set the DECL_ABSTRACT flag on them instead of      sharing them.  */
elseif|else
if|if
condition|(
name|old_die
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|get_AT_flag
argument_list|(
name|old_die
argument_list|,
name|DW_AT_declaration
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* ??? This is an instantiation of a C++ class level static.  */
name|add_AT_die_ref
argument_list|(
name|var_die
argument_list|,
name|DW_AT_specification
argument_list|,
name|old_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|register
name|unsigned
name|file_index
init|=
name|lookup_filename
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_file
argument_list|)
operator|!=
name|file_index
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_decl_file
argument_list|,
name|file_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_line
argument_list|)
operator|!=
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_decl_line
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|add_name_and_src_coords_attributes
argument_list|(
name|var_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|var_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|var_die
argument_list|,
name|DW_AT_external
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|var_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_private
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declaration
condition|)
name|add_AT_flag
argument_list|(
name|var_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|declaration
operator|&&
name|decl_class_context
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|var_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declaration
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|var_die
argument_list|)
expr_stmt|;
name|add_location_or_const_value_attribute
argument_list|(
name|var_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_pubname
argument_list|(
name|decl
argument_list|,
name|var_die
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent a label identifier.  */
end_comment

begin_function
specifier|static
name|void
name|gen_label_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
specifier|register
name|dw_die_ref
name|lbl_die
init|=
name|new_die
argument_list|(
name|DW_TAG_label
argument_list|,
name|context_die
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|insn
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|label2
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|lbl_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
name|add_name_and_src_coords_attributes
argument_list|(
name|lbl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|lbl_die
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Deleted labels are programmer specified labels which have been 	 eliminated because of various optimisations.  We still emit them 	 here so that it is possible to put breakpoints on them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|)
operator|)
condition|)
block|{
comment|/* When optimization is enabled (via -O) some parts of the compiler  	     (e.g. jump.c and cse.c) may try to delete CODE_LABEL insns which  	     represent source-level labels which were explicitly declared by 	     the user.  This really shouldn't be happening though, so catch 	     it if it ever does happen.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|label2
argument_list|,
name|INSN_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|label2
argument_list|,
operator|(
name|unsigned
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|lbl_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE for a lexical block.  */
end_comment

begin_function
specifier|static
name|void
name|gen_lexical_block_die
parameter_list|(
name|stmt
parameter_list|,
name|context_die
parameter_list|,
name|depth
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|stmt_die
init|=
name|new_die
argument_list|(
name|DW_TAG_lexical_block
argument_list|,
name|context_die
argument_list|)
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|BLOCK_BEGIN_LABEL
argument_list|,
name|next_block_number
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|stmt_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|BLOCK_END_LABEL
argument_list|,
name|next_block_number
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|stmt_die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
name|push_decl_scope
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|decls_for_scope
argument_list|(
name|stmt
argument_list|,
name|stmt_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|pop_decl_scope
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for an inlined subprogram.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_subroutine_die
parameter_list|(
name|stmt
parameter_list|,
name|context_die
parameter_list|,
name|depth
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
specifier|register
name|dw_die_ref
name|subr_die
init|=
name|new_die
argument_list|(
name|DW_TAG_inlined_subroutine
argument_list|,
name|context_die
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|decl
init|=
name|block_ultimate_origin
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|add_abstract_origin_attribute
argument_list|(
name|subr_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|BLOCK_BEGIN_LABEL
argument_list|,
name|next_block_number
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|BLOCK_END_LABEL
argument_list|,
name|next_block_number
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|push_decl_scope
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decls_for_scope
argument_list|(
name|stmt
argument_list|,
name|subr_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|pop_decl_scope
argument_list|()
expr_stmt|;
name|current_function_has_inlines
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE for a field in a record, or structure.  */
end_comment

begin_function
specifier|static
name|void
name|gen_field_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|decl_die
init|=
name|new_die
argument_list|(
name|DW_TAG_member
argument_list|,
name|context_die
argument_list|)
decl_stmt|;
name|add_name_and_src_coords_attributes
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|decl_die
argument_list|,
name|member_declared_type
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* If this is a bit field...  */
if|if
condition|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|add_byte_size_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_bit_size_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_bit_offset_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
name|add_data_member_location_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_private
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Don't generate either pointer_type DIEs or reference_type DIEs here.    Use modified_type_die instead.    We keep this code here just in case these types of DIEs may be needed to    represent certain things in other languages (e.g. Pascal) someday.  */
end_comment

begin_comment
unit|static void gen_pointer_type_die (type, context_die)      register tree type;      register dw_die_ref context_die; {   register dw_die_ref ptr_die     = new_die (DW_TAG_pointer_type, scope_die_for (type, context_die));    equate_type_number_to_die (type, ptr_die);   add_type_attribute (ptr_die, TREE_TYPE (type), 0, 0, context_die);   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE); }
comment|/* Don't generate either pointer_type DIEs or reference_type DIEs here.    Use modified_type_die instead.    We keep this code here just in case these types of DIEs may be needed to    represent certain things in other languages (e.g. Pascal) someday.  */
end_comment

begin_endif
unit|static void gen_reference_type_die (type, context_die)      register tree type;      register dw_die_ref context_die; {   register dw_die_ref ref_die     = new_die (DW_TAG_reference_type, scope_die_for (type, context_die));    equate_type_number_to_die (type, ref_die);   add_type_attribute (ref_die, TREE_TYPE (type), 0, 0, context_die);   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate a DIE for a pointer to a member type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_ptr_to_mbr_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|ptr_die
init|=
name|new_die
argument_list|(
name|DW_TAG_ptr_to_member_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|)
decl_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|ptr_die
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|ptr_die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|lookup_type_die
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|ptr_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the DIE for the compilation unit.  */
end_comment

begin_function
specifier|static
name|void
name|gen_compile_unit_die
parameter_list|(
name|main_input_filename
parameter_list|)
specifier|register
name|char
modifier|*
name|main_input_filename
decl_stmt|;
block|{
name|char
name|producer
index|[
literal|250
index|]
decl_stmt|;
name|char
modifier|*
name|wd
init|=
name|getpwd
argument_list|()
decl_stmt|;
name|comp_unit_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_compile_unit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_name_attribute
argument_list|(
name|comp_unit_die
argument_list|,
name|main_input_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|wd
operator|!=
name|NULL
condition|)
name|add_AT_string
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_comp_dir
argument_list|,
name|wd
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|producer
argument_list|,
literal|"%s %s"
argument_list|,
name|language_string
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* The MIPS/SGI compilers place the 'cc' command line options in the producer      string.  The SGI debugger looks for -g, -g1, -g2, or -g3; if they do      not appear in the producer string, the debugger reaches the conclusion      that the object file is stripped and has no debugging information.      To get the MIPS/SGI debugger to believe that there is debugging      information in the object file, we add a -g to the producer string.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
name|strcat
argument_list|(
name|producer
argument_list|,
literal|" -g"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_AT_string
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_producer
argument_list|,
name|producer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
condition|)
name|add_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|,
name|DW_LANG_C_plus_plus
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Ada"
argument_list|)
operator|==
literal|0
condition|)
name|add_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|,
name|DW_LANG_Ada83
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F77"
argument_list|)
operator|==
literal|0
condition|)
name|add_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|,
name|DW_LANG_Fortran77
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Pascal"
argument_list|)
operator|==
literal|0
condition|)
name|add_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|,
name|DW_LANG_Pascal83
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_traditional
condition|)
name|add_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|,
name|DW_LANG_C
argument_list|)
expr_stmt|;
else|else
name|add_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|,
name|DW_LANG_C89
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* unimplemented */
block|if (debug_info_level>= DINFO_LEVEL_VERBOSE)     add_AT_unsigned (comp_unit_die, DW_AT_macro_info, 0);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Generate a DIE for a string type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_string_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_string_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|)
decl_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
comment|/* Fudge the string length attribute for now.  */
comment|/* TODO: add string length info.    string_length_attribute (TYPE_MAX_VALUE (TYPE_DOMAIN (type))); 			      bound_representation (upper_bound, 0, 'u'); */
block|}
end_function

begin_comment
comment|/* Generate the DIE for a base class.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inheritance_die
parameter_list|(
name|binfo
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|binfo
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|die
init|=
name|new_die
argument_list|(
name|DW_TAG_inheritance
argument_list|,
name|context_die
argument_list|)
decl_stmt|;
name|add_type_attribute
argument_list|(
name|die
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|add_data_member_location_attribute
argument_list|(
name|die
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_virtuality
argument_list|,
name|DW_VIRTUALITY_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|binfo
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_public
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|binfo
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a class member.  */
end_comment

begin_function
specifier|static
name|void
name|gen_member_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|tree
name|member
decl_stmt|;
comment|/* If this is not an incomplete type, output descriptions of each of its      members. Note that as we output the DIEs necessary to represent the      members of this record or union type, we will also be trying to output      DIEs to represent the *types* of those members. However the `type'      function (above) will specifically avoid generating type DIEs for member       types *within* the list of member DIEs for this (containing) type execpt       for those types (of members) which are explicitly marked as also being      members of this (containing) type themselves.  The g++ front- end can      force any given type to be treated as a member of some other      (containing) type by setting the TYPE_CONTEXT of the given (member) type       to point to the TREE node representing the appropriate (containing)      type.  */
comment|/* First output info about the base classes.  */
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|bases
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|int
name|n_bases
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|bases
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
name|i
operator|++
control|)
name|gen_inheritance_die
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|bases
argument_list|,
name|i
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
comment|/* Now output info about the data members and type members.  */
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
name|gen_decl_die
argument_list|(
name|member
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Now output info about the function members (if any).  */
for|for
control|(
name|member
operator|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
name|gen_decl_die
argument_list|(
name|member
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a structure or union type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_struct_or_union_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|type_die
init|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|dw_die_ref
name|scope_die
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|nested
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type_die
operator|&&
operator|!
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|nested
operator|=
literal|1
expr_stmt|;
name|scope_die
operator|=
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_die
operator|||
operator|(
name|nested
operator|&&
name|scope_die
operator|==
name|comp_unit_die
operator|)
condition|)
comment|/* First occurrence of type or toplevel definition of nested class.  */
block|{
specifier|register
name|dw_die_ref
name|old_die
init|=
name|type_die
decl_stmt|;
name|type_die
operator|=
name|new_die
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|?
name|DW_TAG_structure_type
else|:
name|DW_TAG_union_type
argument_list|,
name|scope_die
argument_list|)
expr_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|add_name_attribute
argument_list|(
name|type_die
argument_list|,
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_die
condition|)
name|add_AT_die_ref
argument_list|(
name|type_die
argument_list|,
name|DW_AT_specification
argument_list|,
name|old_die
argument_list|)
expr_stmt|;
block|}
else|else
name|remove_AT
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|)
expr_stmt|;
comment|/* If we're not in the right context to be defining this type, defer to      avoid tricky recursion.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|decl_scope_depth
operator|>
literal|0
operator|&&
name|scope_die
operator|==
name|comp_unit_die
condition|)
block|{
name|add_AT_flag
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pend_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* If this type has been completed, then give it a byte_size attribute and      then give a list of members.  */
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Prevent infinite recursion in cases where the type of some member of           this type is expressed in terms of this type itself.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_byte_size_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|add_src_coords_attributes
argument_list|(
name|type_die
argument_list|,
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the first reference to this type was as the return type of an 	 inline function, then it may not have a parent.  Fix this now.  */
if|if
condition|(
name|type_die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
name|add_child_die
argument_list|(
name|scope_die
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|push_decl_scope
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|gen_member_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|pop_decl_scope
argument_list|()
expr_stmt|;
comment|/* GNU extension: Record what type our vtable lives in.  */
if|if
condition|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|vtype
init|=
name|DECL_FCONTEXT
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|gen_type_die
argument_list|(
name|vtype
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|type_die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|lookup_type_die
argument_list|(
name|vtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|add_AT_flag
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We can't do this for function-local types, and we don't need to.  */
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
condition|)
name|add_incomplete_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE for a subroutine _type_.  */
end_comment

begin_function
specifier|static
name|void
name|gen_subroutine_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|dw_die_ref
name|subr_die
init|=
name|new_die
argument_list|(
name|DW_TAG_subroutine_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|)
decl_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
name|add_prototyped_attribute
argument_list|(
name|subr_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|subr_die
argument_list|,
name|return_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_formal_types_die
argument_list|(
name|type
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a type definition */
end_comment

begin_function
specifier|static
name|void
name|gen_typedef_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|type_die
decl_stmt|;
specifier|register
name|tree
name|origin
decl_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_typedef
argument_list|,
name|scope_die_for
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
argument_list|)
expr_stmt|;
name|origin
operator|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|tree
name|type
decl_stmt|;
name|add_name_and_src_coords_attributes
argument_list|(
name|type_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|type
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|equate_type_number_to_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a type description DIE.  */
end_comment

begin_function
specifier|static
name|void
name|gen_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* We are going to output a DIE to represent the unqualified version of      this type (i.e. without any const or volatile qualifiers) so get the      main variant (i.e. the unqualified version) of this type now.  */
name|type
operator|=
name|type_main_variant
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gen_decl_die
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* We must set TREE_ASM_WRITTEN in case this is a recursive type.  This 	 ensures that the gen_type_die recursion will terminate even if the 	 type is recursive.  Recursive types are possible in Ada.  */
comment|/* ??? We could perhaps do this for all types before the switch 	 statement.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* For these types, all that is required is that we output a DIE (or a          set of DIEs) to represent the "basis" type.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
comment|/* This code is used for C++ pointer-to-data-member types.  	 Output a description of the relevant class type.  */
name|gen_type_die
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Output a description of the type of the object pointed to.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Now output a DIE to represent this pointer-to-data-member type          itself.  */
name|gen_ptr_to_mbr_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET_TYPE
case|:
name|gen_type_die
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_set_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_TYPE
case|:
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* No way to represent these in Dwarf yet!  */
break|break;
case|case
name|FUNCTION_TYPE
case|:
comment|/* Force out return type (in case it wasn't forced out already).  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_subroutine_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
comment|/* Force out return type (in case it wasn't forced out already).  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_subroutine_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|CHAR_TYPE
condition|)
block|{
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_string_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
else|else
name|gen_array_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
comment|/* If this is a nested type whose containing class hasn't been 	 written out yet, writing it out will cover this one, too.  */
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|gen_type_die
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* If that failed, attach ourselves to the stub.  */
name|push_decl_scope
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|context_die
operator|=
name|lookup_type_die
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|gen_enumeration_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
else|else
name|gen_struct_or_union_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|pop_decl_scope
argument_list|()
expr_stmt|;
comment|/* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix 	 it up if it is ever completed.  gen_*_type_die will set it for us 	 when appropriate.  */
return|return;
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
comment|/* No DIEs needed for fundamental types.  */
break|break;
case|case
name|LANG_TYPE
case|:
comment|/* No Dwarf representation currently defined.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a tagged type instantiation.  */
end_comment

begin_function
specifier|static
name|void
name|gen_tagged_type_instantiation_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* We are going to output a DIE to represent the unqualified version of      this type (i.e. without any const or volatile qualifiers) so make sure      that we have the main variant (i.e. the unqualified version) of this      type now.  */
if|if
condition|(
name|type
operator|!=
name|type_main_variant
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|gen_inlined_enumeration_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
name|gen_inlined_structure_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|gen_inlined_union_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DW_TAG_lexical_block DIE followed by DIEs to represent all of the    things which are local to the given block.  */
end_comment

begin_function
specifier|static
name|void
name|gen_block_die
parameter_list|(
name|stmt
parameter_list|,
name|context_die
parameter_list|,
name|depth
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
specifier|register
name|int
name|must_output_die
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|origin
decl_stmt|;
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|origin_code
decl_stmt|;
comment|/* Ignore blocks never really used to make RTL.  */
if|if
condition|(
name|stmt
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
comment|/* Determine the "ultimate origin" of this block.  This block may be an      inlined instance of an inlined instance of inline function, so we have      to trace all of the way back through the origin chain to find out what      sort of node actually served as the original seed for the creation of      the current block.  */
name|origin
operator|=
name|block_ultimate_origin
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|origin_code
operator|=
operator|(
name|origin
operator|!=
name|NULL
operator|)
condition|?
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
else|:
name|ERROR_MARK
expr_stmt|;
comment|/* Determine if we need to output any Dwarf DIEs at all to represent this      block.  */
if|if
condition|(
name|origin_code
operator|==
name|FUNCTION_DECL
condition|)
comment|/* The outer scopes for inlinings *must* always be represented.  We        generate DW_TAG_inlined_subroutine DIEs for them.  (See below.) */
name|must_output_die
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* In the case where the current block represents an inlining of the          "body block" of an inline function, we must *NOT* output any DIE for           this block because we have already output a DIE to represent the          whole inlined function scope and the "body block" of any function          doesn't really represent a different scope according to ANSI C          rules.  So we check here to make sure that this block does not          represent a "body block inlining" before trying to set the          `must_output_die' flag.  */
if|if
condition|(
operator|!
name|is_body_block
argument_list|(
name|origin
condition|?
name|origin
else|:
name|stmt
argument_list|)
condition|)
block|{
comment|/* Determine if this block directly contains any "significant" 	     local declarations which we will need to output DIEs for.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
comment|/* We are not in terse mode so *any* local declaration counts 	       as being a "significant" one.  */
name|must_output_die
operator|=
operator|(
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
else|else
comment|/* We are in terse mode, so only local (nested) function 	       definitions count as "significant" local declarations.  */
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|decl
operator|!=
name|NULL
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|must_output_die
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* It would be a waste of space to generate a Dwarf DW_TAG_lexical_block      DIE for any block which contains no significant local declarations at      all.  Rather, in such cases we just call `decls_for_scope' so that any      needed Dwarf info for any sub-blocks will get properly generated. Note      that in terse mode, our definition of what constitutes a "significant"      local declaration gets restricted to include only inlined function      instances and local (nested) function definitions.  */
if|if
condition|(
name|must_output_die
condition|)
block|{
if|if
condition|(
name|origin_code
operator|==
name|FUNCTION_DECL
condition|)
name|gen_inlined_subroutine_die
argument_list|(
name|stmt
argument_list|,
name|context_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
else|else
name|gen_lexical_block_die
argument_list|(
name|stmt
argument_list|,
name|context_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
else|else
name|decls_for_scope
argument_list|(
name|stmt
argument_list|,
name|context_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate all of the decls declared within a given scope and (recursively)    all of its sub-blocks.  */
end_comment

begin_function
specifier|static
name|void
name|decls_for_scope
parameter_list|(
name|stmt
parameter_list|,
name|context_die
parameter_list|,
name|depth
parameter_list|)
specifier|register
name|tree
name|stmt
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|tree
name|subblocks
decl_stmt|;
comment|/* Ignore blocks never really used to make RTL.  */
if|if
condition|(
name|stmt
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
operator|&&
name|depth
operator|>
literal|0
condition|)
name|next_block_number
operator|++
expr_stmt|;
comment|/* Output the DIEs to represent all of the data objects and typedefs      declared directly within this block but not within any nested      sub-blocks.  Also, nested function and tag DIEs have been      generated with a parent of NULL; fix that up now.  */
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|decl
operator|!=
name|NULL
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
specifier|register
name|dw_die_ref
name|die
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|die
operator|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
condition|)
name|die
operator|=
name|lookup_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|die
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|die
operator|!=
name|NULL
operator|&&
name|die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
name|add_child_die
argument_list|(
name|context_die
argument_list|,
name|die
argument_list|)
expr_stmt|;
else|else
name|gen_decl_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
comment|/* Output the DIEs to represent all sub-blocks (and the items declared      therein) of this block.  */
for|for
control|(
name|subblocks
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|subblocks
operator|!=
name|NULL
condition|;
name|subblocks
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblocks
argument_list|)
control|)
name|gen_block_die
argument_list|(
name|subblocks
argument_list|,
name|context_die
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Is this a typedef we can avoid emitting?  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_redundant_typedef
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|is_tagged_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* Also ignore the artificial member typedef for the class name.  */
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate Dwarf debug information for a decl described by DECL.  */
end_comment

begin_function
specifier|static
name|void
name|gen_decl_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
specifier|register
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
specifier|register
name|tree
name|origin
decl_stmt|;
comment|/* Make a note of the decl node we are going to be working on.  We may need       to give the user the source coordinates of where it appeared in case we      notice (later on) that something about it looks screwy.  */
name|dwarf_last_decl
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* If this ..._DECL node is marked to be ignored, then ignore it. But don't       ignore a function definition, since that would screw up our count of      blocks, and that in turn will completely screw up the labels we will       reference in subsequent DW_AT_low_pc and DW_AT_high_pc attributes (for      subsequent blocks).  */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|CONST_DECL
case|:
comment|/* The individual enumerators of an enum type get output when we output           the Dwarf representation of the relevant enum type itself.  */
break|break;
case|case
name|FUNCTION_DECL
case|:
comment|/* Don't output any DIEs to represent mere function declarations, 	 unless they are class members or explicit block externs.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|current_function_decl
operator|==
name|NULL_TREE
operator|||
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
block|{
comment|/* Before we describe the FUNCTION_DECL itself, make sure that we 	     have described its return type.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* And its containing type.  */
name|origin
operator|=
name|decl_class_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL_TREE
condition|)
name|gen_type_die
argument_list|(
name|origin
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* And its virtual context.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|gen_type_die
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
comment|/* Now output a DIE to represent the function itself.  */
name|gen_subprogram_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* If we are in terse mode, don't generate any DIEs to represent any          actual typedefs.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
break|break;
comment|/* In the special case of a TYPE_DECL node representing the           declaration of some type tag, if the given TYPE_DECL is marked as          having been instantiated from some other (original) TYPE_DECL node          (e.g. one which was generated within the original definition of an          inline function) we have to generate a special (abbreviated)          DW_TAG_structure_type, DW_TAG_union_type, or DW_TAG_enumeration_type           DIE here.  */
if|if
condition|(
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|gen_tagged_type_instantiation_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_redundant_typedef
argument_list|(
name|decl
argument_list|)
condition|)
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
else|else
comment|/* Output a DIE to represent the typedef itself.  */
name|gen_typedef_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
name|gen_label_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
comment|/* If we are in terse mode, don't generate any DIEs to represent any          variable declarations or definitions.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
break|break;
comment|/* Output any DIEs that are needed to specify the type of this data          object.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* And its containing type.  */
name|origin
operator|=
name|decl_class_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL_TREE
condition|)
name|gen_type_die
argument_list|(
name|origin
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Now output the DIE to represent the data object itself.  This gets          complicated because of the possibility that the VAR_DECL really          represents an inlined instance of a formal parameter for an inline          function.  */
name|origin
operator|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|gen_formal_parameter_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
else|else
name|gen_variable_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD_DECL
case|:
comment|/* Ignore the nameless fields that are used to skip bits, but 	 handle C++ anonymous unions.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|gen_type_die
argument_list|(
name|member_declared_type
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_field_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARM_DECL
case|:
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_formal_parameter_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write the debugging output for DECL.  */
end_comment

begin_function
name|void
name|dwarf2out_decl
parameter_list|(
name|decl
parameter_list|)
specifier|register
name|tree
name|decl
decl_stmt|;
block|{
specifier|register
name|dw_die_ref
name|context_die
init|=
name|comp_unit_die
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
comment|/* If this ..._DECL node is marked to be ignored, then ignore it.  We gotta       hope that the node in question doesn't represent a function definition.      If it does, then totally ignoring it is bound to screw up our count of      blocks, and that in turn will completely screw up the labels we will       reference in subsequent DW_AT_low_pc and DW_AT_high_pc attributes (for      subsequent blocks).  (It's too bad that BLOCK nodes don't carry their      own sequence numbers with them!) */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|FUNCTION_DECL
case|:
comment|/* Ignore this FUNCTION_DECL if it refers to a builtin declaration of a           builtin function.  Explicit programmer-supplied declarations of          these same functions should NOT be ignored however.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* What we would really like to do here is to filter out all mere          file-scope declarations of file-scope functions which are never          referenced later within this translation unit (and keep all of ones          that *are* referenced later on) but we aren't clairvoyant, so we have           no idea which functions will be referenced in the future (i.e. later           on within the current translation unit). So here we just ignore all          file-scope function declarations which are not also definitions.  If           and when the debugger needs to know something about these functions,          it wil have to hunt around and find the DWARF information associated           with the definition of the function. Note that we can't just check          `DECL_EXTERNAL' to find out which FUNCTION_DECL nodes represent          definitions and which ones represent mere declarations.  We have to          check `DECL_INITIAL' instead. That's because the C front-end          supports some weird semantics for "extern inline" function          definitions.  These can get inlined within the current translation          unit (an thus, we need to generate DWARF info for their abstract          instances so that the DWARF info for the concrete inlined instances          can have something to refer to) but the compiler never generates any           out-of-lines instances of such things (despite the fact that they          *are* definitions).  The important point is that the C front-end          marks these "extern inline" functions as DECL_EXTERNAL, but we need          to generate DWARF for them anyway. Note that the C++ front-end also          plays some similar games for inline function definitions appearing          within include files which also contain  	 `#pragma interface' pragmas.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
comment|/* If we're a nested function, initially use a parent of NULL; if we're 	 a plain function, this will be fixed up in decls_for_scope.  If 	 we're a method, it will be ignored, since we already have a DIE.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|context_die
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
comment|/* Ignore this VAR_DECL if it refers to a file-scope extern data object           declaration and if the declaration was never even referenced from          within this entire compilation unit.  We suppress these DIEs in          order to save space in the .debug section (by eliminating entries          which are probably useless).  Note that we must not suppress          block-local extern declarations (whether used or not) because that          would screw-up the debugger's name lookup mechanism and cause it to          miss things which really ought to be in scope at a given point.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* If we are in terse mode, don't generate any DIEs to represent any          variable declarations or definitions.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* Don't bother trying to generate any DIEs to represent any of the          normal built-in types for the language we are compiling.  */
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* OK, we need to generate one for `bool' so GDB knows what type              comparisons have.  */
if|if
condition|(
operator|(
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
operator|==
name|DW_LANG_C_plus_plus
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
name|modified_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we are in terse mode, don't generate any DIEs for types.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
comment|/* If we're a function-scope tag, initially use a parent of NULL; 	 this will be fixed up in decls_for_scope.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|context_die
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|gen_decl_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|output_pending_types_for_scope
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the beginning of the generated code for    a lexical block.  */
end_comment

begin_function
name|void
name|dwarf2out_begin_block
parameter_list|(
name|blocknum
parameter_list|)
specifier|register
name|unsigned
name|blocknum
decl_stmt|;
block|{
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BLOCK_BEGIN_LABEL
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the end of the generated code for a    lexical block.  */
end_comment

begin_function
name|void
name|dwarf2out_end_block
parameter_list|(
name|blocknum
parameter_list|)
specifier|register
name|unsigned
name|blocknum
decl_stmt|;
block|{
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BLOCK_END_LABEL
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) at a point in the assembly code which    corresponds to a given source level label.  */
end_comment

begin_function
name|void
name|dwarf2out_label
parameter_list|(
name|insn
parameter_list|)
specifier|register
name|rtx
name|insn
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|label
argument_list|,
name|INSN_LABEL_FMT
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|,
operator|(
name|unsigned
operator|)
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Lookup a filename (in the list of filenames that we know about here in    dwarf2out.c) and return its "index".  The index of each (known) filename is    just a unique number which is associated with only that one filename.    We need such numbers for the sake of generating labels    (in the .debug_sfnames section) and references to those    files  numbers (in the .debug_srcinfo and.debug_macinfo sections).    If the filename given as an argument is not found in our current list,    add it to the list and assign it the next available unique index number.    In order to speed up searches, we remember the index of the filename    was looked up last.  This handles the majority of all searches.  */
end_comment

begin_function
specifier|static
name|unsigned
name|lookup_filename
parameter_list|(
name|file_name
parameter_list|)
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
specifier|static
name|unsigned
name|last_file_lookup_index
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|i
decl_stmt|;
comment|/* Check to see if the file name that was searched on the previous call      matches this file name. If so, return the index.  */
if|if
condition|(
name|last_file_lookup_index
operator|!=
literal|0
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|file_name
argument_list|,
name|file_table
index|[
name|last_file_lookup_index
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|last_file_lookup_index
return|;
comment|/* Didn't match the previous lookup, search the table */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|file_table_in_use
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|file_name
argument_list|,
name|file_table
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|last_file_lookup_index
operator|=
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/* Prepare to add a new table entry by making sure there is enough space in       the table to do so.  If not, expand the current table.  */
if|if
condition|(
name|file_table_in_use
operator|==
name|file_table_allocated
condition|)
block|{
name|file_table_allocated
operator|+=
name|FILE_TABLE_INCREMENT
expr_stmt|;
name|file_table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|file_table
argument_list|,
name|file_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry to the end of the filename table.  */
name|file_table
index|[
name|file_table_in_use
index|]
operator|=
name|xstrdup
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|last_file_lookup_index
operator|=
name|file_table_in_use
operator|++
expr_stmt|;
return|return
name|last_file_lookup_index
return|;
block|}
end_function

begin_comment
comment|/* Output a label to mark the beginning of a source code line entry    and record information relating to this source line, in    'line_info_table' for later output of the .debug_line section.  */
end_comment

begin_function
name|void
name|dwarf2out_line
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|)
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
specifier|register
name|unsigned
name|line
decl_stmt|;
block|{
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
specifier|register
name|dw_separate_line_info_ref
name|line_info
decl_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|SEPARATE_LINE_CODE_LABEL
argument_list|,
name|separate_line_info_table_in_use
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* expand the line info table if necessary */
if|if
condition|(
name|separate_line_info_table_in_use
operator|==
name|separate_line_info_table_allocated
condition|)
block|{
name|separate_line_info_table_allocated
operator|+=
name|LINE_INFO_TABLE_INCREMENT
expr_stmt|;
name|separate_line_info_table
operator|=
operator|(
name|dw_separate_line_info_ref
operator|)
name|xrealloc
argument_list|(
name|separate_line_info_table
argument_list|,
name|separate_line_info_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_separate_line_info_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry at the end of the line_info_table.  */
name|line_info
operator|=
operator|&
name|separate_line_info_table
index|[
name|separate_line_info_table_in_use
operator|++
index|]
expr_stmt|;
name|line_info
operator|->
name|dw_file_num
operator|=
name|lookup_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|line_info
operator|->
name|dw_line_num
operator|=
name|line
expr_stmt|;
name|line_info
operator|->
name|function
operator|=
name|current_funcdef_number
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|dw_line_info_ref
name|line_info
decl_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_CODE_LABEL
argument_list|,
name|line_info_table_in_use
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Expand the line info table if necessary.  */
if|if
condition|(
name|line_info_table_in_use
operator|==
name|line_info_table_allocated
condition|)
block|{
name|line_info_table_allocated
operator|+=
name|LINE_INFO_TABLE_INCREMENT
expr_stmt|;
name|line_info_table
operator|=
operator|(
name|dw_line_info_ref
operator|)
name|xrealloc
argument_list|(
name|line_info_table
argument_list|,
operator|(
name|line_info_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_line_info_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry at the end of the line_info_table.  */
name|line_info
operator|=
operator|&
name|line_info_table
index|[
name|line_info_table_in_use
operator|++
index|]
expr_stmt|;
name|line_info
operator|->
name|dw_file_num
operator|=
name|lookup_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|line_info
operator|->
name|dw_line_num
operator|=
name|line
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record the beginning of a new source file, for later output    of the .debug_macinfo section.  At present, unimplemented.  */
end_comment

begin_function
name|void
name|dwarf2out_start_source_file
parameter_list|(
name|filename
parameter_list|)
specifier|register
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Record the end of a source file, for later output    of the .debug_macinfo section.  At present, unimplemented.  */
end_comment

begin_function
name|void
name|dwarf2out_end_source_file
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Called from check_newline in c-parse.y.  The `buffer' parameter contains    the tail part of the directive line, i.e. the part which is past the    initial whitespace, #, whitespace, directive-name, whitespace part.  */
end_comment

begin_function
name|void
name|dwarf2out_define
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
specifier|register
name|unsigned
name|lineno
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|dwarf2out_start_source_file
argument_list|(
name|primary_filename
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from check_newline in c-parse.y.  The `buffer' parameter contains    the tail part of the directive line, i.e. the part which is past the    initial whitespace, #, whitespace, directive-name, whitespace part.  */
end_comment

begin_function
name|void
name|dwarf2out_undef
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
specifier|register
name|unsigned
name|lineno
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Set up for Dwarf output at the start of compilation.  */
end_comment

begin_function
name|void
name|dwarf2out_init
parameter_list|(
name|asm_out_file
parameter_list|,
name|main_input_filename
parameter_list|)
specifier|register
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
specifier|register
name|char
modifier|*
name|main_input_filename
decl_stmt|;
block|{
comment|/* Remember the name of the primary input file.  */
name|primary_filename
operator|=
name|main_input_filename
expr_stmt|;
comment|/* Allocate the initial hunk of the file_table.  */
name|file_table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|FILE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|file_table
argument_list|,
name|FILE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|file_table_allocated
operator|=
name|FILE_TABLE_INCREMENT
expr_stmt|;
comment|/* Skip the first entry - file numbers begin at 1.  */
name|file_table_in_use
operator|=
literal|1
expr_stmt|;
comment|/* Allocate the initial hunk of the decl_die_table.  */
name|decl_die_table
operator|=
operator|(
name|dw_die_ref
operator|*
operator|)
name|xmalloc
argument_list|(
name|DECL_DIE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|decl_die_table
argument_list|,
name|DECL_DIE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|decl_die_table_allocated
operator|=
name|DECL_DIE_TABLE_INCREMENT
expr_stmt|;
name|decl_die_table_in_use
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the initial hunk of the decl_scope_table.  */
name|decl_scope_table
operator|=
operator|(
name|decl_scope_node
operator|*
operator|)
name|xmalloc
argument_list|(
name|DECL_SCOPE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|decl_scope_node
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|decl_scope_table
argument_list|,
name|DECL_SCOPE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|decl_scope_node
argument_list|)
argument_list|)
expr_stmt|;
name|decl_scope_table_allocated
operator|=
name|DECL_SCOPE_TABLE_INCREMENT
expr_stmt|;
name|decl_scope_depth
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the initial hunk of the abbrev_die_table.  */
name|abbrev_die_table
operator|=
operator|(
name|dw_die_ref
operator|*
operator|)
name|xmalloc
argument_list|(
name|ABBREV_DIE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|abbrev_die_table
argument_list|,
name|ABBREV_DIE_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|abbrev_die_table_allocated
operator|=
name|ABBREV_DIE_TABLE_INCREMENT
expr_stmt|;
comment|/* Zero-th entry is allocated, but unused */
name|abbrev_die_table_in_use
operator|=
literal|1
expr_stmt|;
comment|/* Allocate the initial hunk of the line_info_table.  */
name|line_info_table
operator|=
operator|(
name|dw_line_info_ref
operator|)
name|xmalloc
argument_list|(
name|LINE_INFO_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_line_info_entry
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line_info_table
argument_list|,
name|LINE_INFO_TABLE_INCREMENT
operator|*
sizeof|sizeof
argument_list|(
name|dw_line_info_entry
argument_list|)
argument_list|)
expr_stmt|;
name|line_info_table_allocated
operator|=
name|LINE_INFO_TABLE_INCREMENT
expr_stmt|;
comment|/* Zero-th entry is allocated, but unused */
name|line_info_table_in_use
operator|=
literal|1
expr_stmt|;
comment|/* Generate the initial DIE for the .debug section.  Note that the (string)       value given in the DW_AT_name attribute of the DW_TAG_compile_unit DIE      will (typically) be a relative pathname and that this pathname should be       taken as being relative to the directory from which the compiler was      invoked when the given (base) source file was compiled.  */
name|gen_compile_unit_die
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|text_end_label
argument_list|,
name|TEXT_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|abbrev_section_label
argument_list|,
name|ABBREV_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|text_section_label
argument_list|,
name|TEXT_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|debug_info_section_label
argument_list|,
name|DEBUG_INFO_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|debug_line_section_label
argument_list|,
name|DEBUG_LINE_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|ABBREV_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|abbrev_section_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|text_section_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_INFO_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|debug_info_section_label
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_LINE_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|debug_line_section_label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output stuff that dwarf requires at the end of every file,    and generate the DWARF-2 debugging info.  */
end_comment

begin_function
name|void
name|dwarf2out_finish
parameter_list|()
block|{
name|limbo_die_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|next_node
decl_stmt|;
name|dw_die_ref
name|die
decl_stmt|;
name|dw_attr_ref
name|a
decl_stmt|;
comment|/* Traverse the limbo die list, and add parent/child links.  The only      dies without parents that should be here are concrete instances of      inline functions, and the comp_unit_die.  We can ignore the comp_unit_die.      For concrete instances, we can get the parent die from the abstract      instance.  */
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|next_node
control|)
block|{
name|next_node
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|die
operator|=
name|node
operator|->
name|die
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
block|{
name|a
operator|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|DW_AT_abstract_origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
condition|)
name|add_child_die
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|->
name|die_parent
argument_list|,
name|die
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|die
operator|==
name|comp_unit_die
condition|)
empty_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* Walk through the list of incomplete types again, trying once more to      emit full debugging info for them.  */
name|retry_incomplete_types
argument_list|()
expr_stmt|;
comment|/* Traverse the DIE tree and add sibling attributes to those DIE's      that have children.  */
name|add_sibling_attributes
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
comment|/* Output a terminator label for the .text section.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_SECTION
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Output a terminator label for the .data section.  */
block|fputc ('\n', asm_out_file);   ASM_OUTPUT_SECTION (asm_out_file, DATA_SECTION);   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, DATA_END_LABEL, 0);
comment|/* Output a terminator label for the .bss section.  */
block|fputc ('\n', asm_out_file);   ASM_OUTPUT_SECTION (asm_out_file, BSS_SECTION);   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, BSS_END_LABEL, 0);
endif|#
directive|endif
comment|/* Output the source line correspondence table.  */
if|if
condition|(
name|line_info_table_in_use
operator|>
literal|1
operator|||
name|separate_line_info_table_in_use
condition|)
block|{
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_LINE_SECTION
argument_list|)
expr_stmt|;
name|output_line_info
argument_list|()
expr_stmt|;
comment|/* We can only use the low/high_pc attributes if all of the code 	 was in .text.  */
if|if
condition|(
name|separate_line_info_table_in_use
operator|==
literal|0
condition|)
block|{
name|add_AT_lbl_id
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|text_section_label
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|text_end_label
argument_list|)
expr_stmt|;
block|}
name|add_AT_lbl_offset
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_stmt_list
argument_list|,
name|debug_line_section_label
argument_list|)
expr_stmt|;
block|}
comment|/* Output the abbreviation table.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|ABBREV_SECTION
argument_list|)
expr_stmt|;
name|build_abbrev_table
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
name|output_abbrev_section
argument_list|()
expr_stmt|;
comment|/* Initialize the beginning DIE offset - and calculate sizes/offsets.   */
name|next_die_offset
operator|=
name|DWARF_COMPILE_UNIT_HEADER_SIZE
expr_stmt|;
name|calc_die_sizes
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
comment|/* Output debugging information.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|DEBUG_INFO_SECTION
argument_list|)
expr_stmt|;
name|output_compilation_unit_header
argument_list|()
expr_stmt|;
name|output_die
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|pubname_table_in_use
condition|)
block|{
comment|/* Output public names table.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|PUBNAMES_SECTION
argument_list|)
expr_stmt|;
name|output_pubnames
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fde_table_in_use
condition|)
block|{
comment|/* Output the address range information.  */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_SECTION
argument_list|(
name|asm_out_file
argument_list|,
name|ARANGES_SECTION
argument_list|)
expr_stmt|;
name|output_aranges
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DWARF2_DEBUGGING_INFO */
end_comment

end_unit

