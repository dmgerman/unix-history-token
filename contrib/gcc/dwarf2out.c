begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output Dwarf2 format symbol table information from the GNU C compiler.    Copyright (C) 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.    Contributed by Gary Funck (gary@intrepid.com).    Derived from DWARF 1 implementation of Ron Guilmette (rfg@monkeys.com).    Extensively modified by Jason Merrill (jason@cygnus.com).  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* TODO: Emit .debug_line header even when there are no functions, since 	   the file numbers are used by .debug_info.  Alternately, leave 	   out locations for types and decls. 	 Avoid talking about ctors and op= for PODs. 	 Factor out common prologue sequences into multiple CIEs.  */
end_comment

begin_comment
comment|/* The first part of this file deals with the DWARF 2 frame unwind    information, which is also used by the GCC efficient exception handling    mechanism.  The second part, controlled only by an #ifdef    DWARF2_DEBUGGING_INFO, deals with the other DWARF 2 debugging    information.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"libfuncs.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2out.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2asm.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"hashtable.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_source_line
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DWARF2 Abbreviation Glossary:    CFA = Canonical Frame Address 	   a fixed address on the stack which identifies a call frame. 	   We define it to be the value of SP just before the call insn. 	   The CFA register and offset, which may change during the course 	   of the function, are used to calculate its value at runtime.    CFI = Call Frame Instruction 	   an instruction for the DWARF2 abstract machine    CIE = Common Information Entry 	   information describing information common to one or more FDEs    DIE = Debugging Information Entry    FDE = Frame Description Entry 	   information describing the stack call frame, in particular, 	   how to restore registers     DW_CFA_... = DWARF2 CFA call frame instruction    DW_TAG_... = DWARF2 DIE tag */
end_comment

begin_comment
comment|/* Decide whether we want to emit frame unwind information for the current    translation unit.  */
end_comment

begin_function
name|int
name|dwarf2out_do_frame
parameter_list|()
block|{
return|return
operator|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
ifdef|#
directive|ifdef
name|DWARF2_FRAME_INFO
operator|||
name|DWARF2_FRAME_INFO
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
operator|||
name|flag_unwind_tables
operator|||
operator|(
name|flag_exceptions
operator|&&
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|)
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The number of the current function definition for which debugging    information is being generated.  These numbers range from 1 up to the    maximum number of function definitions contained within the current    compilation unit.  These numbers are used to create unique label id's    unique to each function definition.  */
end_comment

begin_decl_stmt
name|unsigned
name|current_funcdef_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of the target's pointer type.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTR_SIZE
end_ifndef

begin_define
define|#
directive|define
name|PTR_SIZE
value|(POINTER_SIZE / BITS_PER_UNIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default version of targetm.eh_frame_section.  Note this must appear    outside the DWARF2_DEBUGGING_INFO || DWARF2_UNWIND_INFO macro    guards.  */
end_comment

begin_function
name|void
name|default_eh_frame_section
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|EH_FRAME_SECTION_NAME
name|named_section_flags
argument_list|(
name|EH_FRAME_SECTION_NAME
argument_list|,
name|SECTION_WRITE
argument_list|)
expr_stmt|;
else|#
directive|else
name|tree
name|label
init|=
name|get_file_function_name
argument_list|(
literal|'F'
argument_list|)
decl_stmt|;
name|data_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|PTR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DWARF2_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|DWARF2_UNWIND_INFO
argument_list|)
end_if

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|struct
name|dw_cfi_struct
modifier|*
name|dw_cfi_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_fde_struct
modifier|*
name|dw_fde_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|union
name|dw_cfi_oprnd_struct
modifier|*
name|dw_cfi_oprnd_ref
typedef|;
end_typedef

begin_comment
comment|/* Call frames are described using a sequence of Call Frame    Information instructions.  The register number, offset    and address fields are provided as possible operands;    their use is selected by the opcode field.  */
end_comment

begin_typedef
typedef|typedef
union|union
name|dw_cfi_oprnd_struct
block|{
name|unsigned
name|long
name|dw_cfi_reg_num
decl_stmt|;
name|long
name|int
name|dw_cfi_offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|dw_cfi_addr
decl_stmt|;
name|struct
name|dw_loc_descr_struct
modifier|*
name|dw_cfi_loc
decl_stmt|;
block|}
name|dw_cfi_oprnd
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|dw_cfi_struct
block|{
name|dw_cfi_ref
name|dw_cfi_next
decl_stmt|;
name|enum
name|dwarf_call_frame_info
name|dw_cfi_opc
decl_stmt|;
name|dw_cfi_oprnd
name|dw_cfi_oprnd1
decl_stmt|;
name|dw_cfi_oprnd
name|dw_cfi_oprnd2
decl_stmt|;
block|}
name|dw_cfi_node
typedef|;
end_typedef

begin_comment
comment|/* This is how we define the location of the CFA. We use to handle it    as REG + OFFSET all the time,  but now it can be more complex.    It can now be either REG + CFA_OFFSET or *(REG + BASE_OFFSET) + CFA_OFFSET.    Instead of passing around REG and OFFSET, we pass a copy    of this structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cfa_loc
block|{
name|unsigned
name|long
name|reg
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|long
name|base_offset
decl_stmt|;
name|int
name|indirect
decl_stmt|;
comment|/* 1 if CFA is accessed via a dereference.  */
block|}
name|dw_cfa_location
typedef|;
end_typedef

begin_comment
comment|/* All call frame descriptions (FDE's) in the GCC generated DWARF    refer to a single Common Information Entry (CIE), defined at    the beginning of the .debug_frame section.  This use of a single    CIE obviates the need to keep track of multiple CIE's    in the DWARF generation routines below.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_fde_struct
block|{
specifier|const
name|char
modifier|*
name|dw_fde_begin
decl_stmt|;
specifier|const
name|char
modifier|*
name|dw_fde_current_label
decl_stmt|;
specifier|const
name|char
modifier|*
name|dw_fde_end
decl_stmt|;
name|dw_cfi_ref
name|dw_fde_cfi
decl_stmt|;
name|unsigned
name|funcdef_number
decl_stmt|;
name|unsigned
name|nothrow
range|:
literal|1
decl_stmt|;
name|unsigned
name|uses_eh_lsda
range|:
literal|1
decl_stmt|;
block|}
name|dw_fde_node
typedef|;
end_typedef

begin_comment
comment|/* Maximum size (in bytes) of an artificially generated label.  */
end_comment

begin_define
define|#
directive|define
name|MAX_ARTIFICIAL_LABEL_BYTES
value|30
end_define

begin_comment
comment|/* The size of addresses as they appear in the Dwarf 2 data.    Some architectures use word addresses to refer to code locations,    but Dwarf 2 info always uses byte addresses.  On such machines,    Dwarf 2 addresses need to be larger than the architecture's    pointers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_ADDR_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DWARF2_ADDR_SIZE
value|(POINTER_SIZE / BITS_PER_UNIT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The size in bytes of a DWARF field indicating an offset or length    relative to a debug info section, specified to be 4 bytes in the    DWARF-2 specification.  The SGI/MIPS ABI defines it to be the same    as PTR_SIZE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_OFFSET_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DWARF_OFFSET_SIZE
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DWARF_VERSION
value|2
end_define

begin_comment
comment|/* Round SIZE up to the nearest BOUNDARY.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_ROUND
parameter_list|(
name|SIZE
parameter_list|,
name|BOUNDARY
parameter_list|)
define|\
value|((((SIZE) + (BOUNDARY) - 1) / (BOUNDARY)) * (BOUNDARY))
end_define

begin_comment
comment|/* Offsets recorded in opcodes are a multiple of this alignment factor.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_CIE_DATA_ALIGNMENT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
end_ifdef

begin_define
define|#
directive|define
name|DWARF_CIE_DATA_ALIGNMENT
value|(-((int) UNITS_PER_WORD))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DWARF_CIE_DATA_ALIGNMENT
value|((int) UNITS_PER_WORD)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A pointer to the base of a table that contains frame description    information for each routine.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_fde_ref
name|fde_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for fde_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|fde_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in fde_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|fde_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    fde_table.  */
end_comment

begin_define
define|#
directive|define
name|FDE_TABLE_INCREMENT
value|256
end_define

begin_comment
comment|/* A list of call frame insns for the CIE.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_cfi_ref
name|cie_cfi_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some DWARF extensions (e.g., MIPS/SGI) implement a subprogram    attribute that accelerates the lookup of the FDE associated    with the subprogram.  This variable holds the table index of the FDE    associated with the current function (body) definition.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|current_funcdef_fde
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ht
modifier|*
name|debug_str_hash
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|indirect_string_node
block|{
name|struct
name|ht_identifier
name|id
decl_stmt|;
name|unsigned
name|int
name|refcount
decl_stmt|;
name|unsigned
name|int
name|form
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declarations for functions defined in this file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stripattributes
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_cfi_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_cfi_ref
name|new_cfi
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_cfi
name|PARAMS
argument_list|(
operator|(
name|dw_cfi_ref
operator|*
operator|,
name|dw_cfi_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_fde_cfi
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|dw_cfi_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lookup_cfa_1
name|PARAMS
argument_list|(
operator|(
name|dw_cfi_ref
operator|,
name|dw_cfa_location
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lookup_cfa
name|PARAMS
argument_list|(
operator|(
name|dw_cfa_location
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reg_save
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|initial_return_save
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|stack_adjust_offset
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_cfi
name|PARAMS
argument_list|(
operator|(
name|dw_cfi_ref
operator|,
name|dw_fde_ref
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_call_frame_info
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_stack_adjust
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|queue_reg_save
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|rtx
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|flush_queued_reg_saves
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|clobbers_queued_reg_save
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_frame_debug_expr
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Support for complex CFA locations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|output_cfa_loc
name|PARAMS
argument_list|(
operator|(
name|dw_cfi_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_cfa_from_loc_descr
name|PARAMS
argument_list|(
operator|(
name|dw_cfa_location
operator|*
operator|,
expr|struct
name|dw_loc_descr_struct
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dw_loc_descr_struct
modifier|*
name|build_cfa_loc
name|PARAMS
argument_list|(
operator|(
name|dw_cfa_location
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|def_cfa_1
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|dw_cfa_location
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Data and reference forms for relocatable data.  */
end_comment

begin_define
define|#
directive|define
name|DW_FORM_data
value|(DWARF_OFFSET_SIZE == 8 ? DW_FORM_data8 : DW_FORM_data4)
end_define

begin_define
define|#
directive|define
name|DW_FORM_ref
value|(DWARF_OFFSET_SIZE == 8 ? DW_FORM_ref8 : DW_FORM_ref4)
end_define

begin_comment
comment|/* Pseudo-op for defining a new section.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SECTION_ASM_OP
end_ifndef

begin_define
define|#
directive|define
name|SECTION_ASM_OP
value|"\t.section\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_FRAME_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_FRAME_SECTION
value|".debug_frame"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FUNC_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|FUNC_BEGIN_LABEL
value|"LFB"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FUNC_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|FUNC_END_LABEL
value|"LFE"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FRAME_BEGIN_LABEL
value|"Lframe"
end_define

begin_define
define|#
directive|define
name|CIE_AFTER_SIZE_LABEL
value|"LSCIE"
end_define

begin_define
define|#
directive|define
name|CIE_END_LABEL
value|"LECIE"
end_define

begin_define
define|#
directive|define
name|CIE_LENGTH_LABEL
value|"LLCIE"
end_define

begin_define
define|#
directive|define
name|FDE_LABEL
value|"LSFDE"
end_define

begin_define
define|#
directive|define
name|FDE_AFTER_SIZE_LABEL
value|"LASFDE"
end_define

begin_define
define|#
directive|define
name|FDE_END_LABEL
value|"LEFDE"
end_define

begin_define
define|#
directive|define
name|FDE_LENGTH_LABEL
value|"LLFDE"
end_define

begin_define
define|#
directive|define
name|LINE_NUMBER_BEGIN_LABEL
value|"LSLT"
end_define

begin_define
define|#
directive|define
name|LINE_NUMBER_END_LABEL
value|"LELT"
end_define

begin_define
define|#
directive|define
name|LN_PROLOG_AS_LABEL
value|"LASLTP"
end_define

begin_define
define|#
directive|define
name|LN_PROLOG_END_LABEL
value|"LELTP"
end_define

begin_define
define|#
directive|define
name|DIE_LABEL_PREFIX
value|"DW"
end_define

begin_comment
comment|/* Definitions of defaults for various types of primitive assembly language    output operations.  These may be overridden from within the tm.h file,    but typically, that is unnecessary.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SET_ASM_OP
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL
end_ifndef

begin_define
define|#
directive|define
name|ASM_OUTPUT_DEFINE_LABEL_DIFFERENCE_SYMBOL
parameter_list|(
name|FILE
parameter_list|,
name|SY
parameter_list|,
name|HI
parameter_list|,
name|LO
parameter_list|)
define|\
value|do {									\   fprintf (FILE, "%s", SET_ASM_OP);					\   assemble_name (FILE, SY);						\   fputc (',', FILE);							\   assemble_name (FILE, HI);						\   fputc ('-', FILE);							\   assemble_name (FILE, LO);						\  } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The DWARF 2 CFA column which tracks the return address.  Normally this    is the column for PC, or the first column after all of the hard    registers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_FRAME_RETURN_COLUMN
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|PC_REGNUM
end_ifdef

begin_define
define|#
directive|define
name|DWARF_FRAME_RETURN_COLUMN
value|DWARF_FRAME_REGNUM (PC_REGNUM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DWARF_FRAME_RETURN_COLUMN
value|DWARF_FRAME_REGISTERS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The mapping from gcc register number to DWARF 2 CFA column number.  By    default, we just provide columns for all registers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_FRAME_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|DWARF_FRAME_REGNUM
parameter_list|(
name|REG
parameter_list|)
value|DBX_REGISTER_NUMBER (REG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The offset from the incoming value of %sp to the top of the stack frame    for the current function.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INCOMING_FRAME_SP_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|INCOMING_FRAME_SP_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Hook used by __throw.  */
end_comment

begin_function
name|rtx
name|expand_builtin_dwarf_fp_regnum
parameter_list|()
block|{
return|return
name|GEN_INT
argument_list|(
name|DWARF_FRAME_REGNUM
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a copy of the section string name S with all    attributes stripped off, and an asterisk prepended (for assemble_name).  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|stripattributes
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|stripped
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|stripped
decl_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'*'
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|','
condition|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|stripped
return|;
block|}
end_function

begin_comment
comment|/* Generate code to initialize the register size table.  */
end_comment

begin_function
name|void
name|expand_builtin_init_dwarf_reg_sizes
parameter_list|(
name|address
parameter_list|)
name|tree
name|address
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|rtx
name|addr
init|=
name|expand_expr
argument_list|(
name|address
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|mem
init|=
name|gen_rtx_MEM
argument_list|(
name|BLKmode
argument_list|,
name|addr
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DWARF_FRAME_REGISTERS
condition|;
name|i
operator|++
control|)
block|{
name|HOST_WIDE_INT
name|offset
init|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|i
argument_list|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|reg_raw_mode
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
continue|continue;
name|emit_move_insn
argument_list|(
name|adjust_address
argument_list|(
name|mem
argument_list|,
name|mode
argument_list|,
name|offset
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF call frame info. operation to its string name */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_cfi_name
parameter_list|(
name|cfi_opc
parameter_list|)
name|unsigned
name|cfi_opc
decl_stmt|;
block|{
switch|switch
condition|(
name|cfi_opc
condition|)
block|{
case|case
name|DW_CFA_advance_loc
case|:
return|return
literal|"DW_CFA_advance_loc"
return|;
case|case
name|DW_CFA_offset
case|:
return|return
literal|"DW_CFA_offset"
return|;
case|case
name|DW_CFA_restore
case|:
return|return
literal|"DW_CFA_restore"
return|;
case|case
name|DW_CFA_nop
case|:
return|return
literal|"DW_CFA_nop"
return|;
case|case
name|DW_CFA_set_loc
case|:
return|return
literal|"DW_CFA_set_loc"
return|;
case|case
name|DW_CFA_advance_loc1
case|:
return|return
literal|"DW_CFA_advance_loc1"
return|;
case|case
name|DW_CFA_advance_loc2
case|:
return|return
literal|"DW_CFA_advance_loc2"
return|;
case|case
name|DW_CFA_advance_loc4
case|:
return|return
literal|"DW_CFA_advance_loc4"
return|;
case|case
name|DW_CFA_offset_extended
case|:
return|return
literal|"DW_CFA_offset_extended"
return|;
case|case
name|DW_CFA_restore_extended
case|:
return|return
literal|"DW_CFA_restore_extended"
return|;
case|case
name|DW_CFA_undefined
case|:
return|return
literal|"DW_CFA_undefined"
return|;
case|case
name|DW_CFA_same_value
case|:
return|return
literal|"DW_CFA_same_value"
return|;
case|case
name|DW_CFA_register
case|:
return|return
literal|"DW_CFA_register"
return|;
case|case
name|DW_CFA_remember_state
case|:
return|return
literal|"DW_CFA_remember_state"
return|;
case|case
name|DW_CFA_restore_state
case|:
return|return
literal|"DW_CFA_restore_state"
return|;
case|case
name|DW_CFA_def_cfa
case|:
return|return
literal|"DW_CFA_def_cfa"
return|;
case|case
name|DW_CFA_def_cfa_register
case|:
return|return
literal|"DW_CFA_def_cfa_register"
return|;
case|case
name|DW_CFA_def_cfa_offset
case|:
return|return
literal|"DW_CFA_def_cfa_offset"
return|;
comment|/* DWARF 3 */
case|case
name|DW_CFA_def_cfa_expression
case|:
return|return
literal|"DW_CFA_def_cfa_expression"
return|;
case|case
name|DW_CFA_expression
case|:
return|return
literal|"DW_CFA_expression"
return|;
case|case
name|DW_CFA_offset_extended_sf
case|:
return|return
literal|"DW_CFA_offset_extended_sf"
return|;
case|case
name|DW_CFA_def_cfa_sf
case|:
return|return
literal|"DW_CFA_def_cfa_sf"
return|;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
return|return
literal|"DW_CFA_def_cfa_offset_sf"
return|;
comment|/* SGI/MIPS specific */
case|case
name|DW_CFA_MIPS_advance_loc8
case|:
return|return
literal|"DW_CFA_MIPS_advance_loc8"
return|;
comment|/* GNU extensions */
case|case
name|DW_CFA_GNU_window_save
case|:
return|return
literal|"DW_CFA_GNU_window_save"
return|;
case|case
name|DW_CFA_GNU_args_size
case|:
return|return
literal|"DW_CFA_GNU_args_size"
return|;
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
return|return
literal|"DW_CFA_GNU_negative_offset_extended"
return|;
default|default:
return|return
literal|"DW_CFA_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to a newly allocated Call Frame Instruction.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_cfi_ref
name|new_cfi
parameter_list|()
block|{
name|dw_cfi_ref
name|cfi
init|=
operator|(
name|dw_cfi_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_cfi_node
argument_list|)
argument_list|)
decl_stmt|;
name|cfi
operator|->
name|dw_cfi_next
operator|=
name|NULL
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
literal|0
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_reg_num
operator|=
literal|0
expr_stmt|;
return|return
name|cfi
return|;
block|}
end_function

begin_comment
comment|/* Add a Call Frame Instruction to list of instructions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_cfi
parameter_list|(
name|list_head
parameter_list|,
name|cfi
parameter_list|)
name|dw_cfi_ref
modifier|*
name|list_head
decl_stmt|;
name|dw_cfi_ref
name|cfi
decl_stmt|;
block|{
name|dw_cfi_ref
modifier|*
name|p
decl_stmt|;
comment|/* Find the end of the chain.  */
for|for
control|(
name|p
operator|=
name|list_head
init|;
operator|(
operator|*
name|p
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|dw_cfi_next
control|)
empty_stmt|;
operator|*
name|p
operator|=
name|cfi
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a new label for the CFI info to refer to.  */
end_comment

begin_function
name|char
modifier|*
name|dwarf2out_cfi_label
parameter_list|()
block|{
specifier|static
name|char
name|label
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|unsigned
name|long
name|label_num
init|=
literal|0
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LCFI"
argument_list|,
name|label_num
operator|++
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return
name|label
return|;
block|}
end_function

begin_comment
comment|/* Add CFI to the current fde at the PC value indicated by LABEL if specified,    or to the CIE if LABEL is NULL.  */
end_comment

begin_function
specifier|static
name|void
name|add_fde_cfi
parameter_list|(
name|label
parameter_list|,
name|cfi
parameter_list|)
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|dw_cfi_ref
name|cfi
decl_stmt|;
block|{
if|if
condition|(
name|label
condition|)
block|{
name|dw_fde_ref
name|fde
init|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|label
operator|==
literal|0
condition|)
name|label
operator|=
name|dwarf2out_cfi_label
argument_list|()
expr_stmt|;
if|if
condition|(
name|fde
operator|->
name|dw_fde_current_label
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|label
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dw_cfi_ref
name|xcfi
decl_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|label
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* Set the location counter to the new label.  */
name|xcfi
operator|=
name|new_cfi
argument_list|()
expr_stmt|;
name|xcfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_advance_loc4
expr_stmt|;
name|xcfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
operator|=
name|label
expr_stmt|;
name|add_cfi
argument_list|(
operator|&
name|fde
operator|->
name|dw_fde_cfi
argument_list|,
name|xcfi
argument_list|)
expr_stmt|;
block|}
name|add_cfi
argument_list|(
operator|&
name|fde
operator|->
name|dw_fde_cfi
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
else|else
name|add_cfi
argument_list|(
operator|&
name|cie_cfi_head
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of lookup_cfa.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|lookup_cfa_1
parameter_list|(
name|cfi
parameter_list|,
name|loc
parameter_list|)
name|dw_cfi_ref
name|cfi
decl_stmt|;
name|dw_cfa_location
modifier|*
name|loc
decl_stmt|;
block|{
switch|switch
condition|(
name|cfi
operator|->
name|dw_cfi_opc
condition|)
block|{
case|case
name|DW_CFA_def_cfa_offset
case|:
name|loc
operator|->
name|offset
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|loc
operator|->
name|reg
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|loc
operator|->
name|reg
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
expr_stmt|;
name|loc
operator|->
name|offset
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_expression
case|:
name|get_cfa_from_loc_descr
argument_list|(
name|loc
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_loc
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Find the previous value for the CFA.  */
end_comment

begin_function
specifier|static
name|void
name|lookup_cfa
parameter_list|(
name|loc
parameter_list|)
name|dw_cfa_location
modifier|*
name|loc
decl_stmt|;
block|{
name|dw_cfi_ref
name|cfi
decl_stmt|;
name|loc
operator|->
name|reg
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
expr_stmt|;
name|loc
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|loc
operator|->
name|indirect
operator|=
literal|0
expr_stmt|;
name|loc
operator|->
name|base_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cfi
operator|=
name|cie_cfi_head
init|;
name|cfi
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|lookup_cfa_1
argument_list|(
name|cfi
argument_list|,
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde_table_in_use
condition|)
block|{
name|dw_fde_ref
name|fde
init|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|-
literal|1
index|]
decl_stmt|;
for|for
control|(
name|cfi
operator|=
name|fde
operator|->
name|dw_fde_cfi
init|;
name|cfi
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|lookup_cfa_1
argument_list|(
name|cfi
argument_list|,
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The current rule for calculating the DWARF2 canonical frame address.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_cfa_location
name|cfa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The register used for saving registers to the stack, and its offset    from the CFA.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_cfa_location
name|cfa_store
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The running total of the size of arguments pushed onto the stack.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last args_size we actually output.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|old_args_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entry point to update the canonical frame address (CFA).    LABEL is passed to add_fde_cfi.  The value of CFA is now to be    calculated from REG+OFFSET.  */
end_comment

begin_function
name|void
name|dwarf2out_def_cfa
parameter_list|(
name|label
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|)
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|long
name|offset
decl_stmt|;
block|{
name|dw_cfa_location
name|loc
decl_stmt|;
name|loc
operator|.
name|indirect
operator|=
literal|0
expr_stmt|;
name|loc
operator|.
name|base_offset
operator|=
literal|0
expr_stmt|;
name|loc
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This routine does the actual work.  The CFA is now calculated from    the dw_cfa_location structure.  */
end_comment

begin_function
specifier|static
name|void
name|def_cfa_1
parameter_list|(
name|label
parameter_list|,
name|loc_p
parameter_list|)
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|dw_cfa_location
modifier|*
name|loc_p
decl_stmt|;
block|{
name|dw_cfi_ref
name|cfi
decl_stmt|;
name|dw_cfa_location
name|old_cfa
decl_stmt|,
name|loc
decl_stmt|;
name|cfa
operator|=
operator|*
name|loc_p
expr_stmt|;
name|loc
operator|=
operator|*
name|loc_p
expr_stmt|;
if|if
condition|(
name|cfa_store
operator|.
name|reg
operator|==
name|loc
operator|.
name|reg
operator|&&
name|loc
operator|.
name|indirect
operator|==
literal|0
condition|)
name|cfa_store
operator|.
name|offset
operator|=
name|loc
operator|.
name|offset
expr_stmt|;
name|loc
operator|.
name|reg
operator|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|loc
operator|.
name|reg
argument_list|)
expr_stmt|;
name|lookup_cfa
argument_list|(
operator|&
name|old_cfa
argument_list|)
expr_stmt|;
comment|/* If nothing changed, no need to issue any call frame instructions.  */
if|if
condition|(
name|loc
operator|.
name|reg
operator|==
name|old_cfa
operator|.
name|reg
operator|&&
name|loc
operator|.
name|offset
operator|==
name|old_cfa
operator|.
name|offset
operator|&&
name|loc
operator|.
name|indirect
operator|==
name|old_cfa
operator|.
name|indirect
operator|&&
operator|(
name|loc
operator|.
name|indirect
operator|==
literal|0
operator|||
name|loc
operator|.
name|base_offset
operator|==
name|old_cfa
operator|.
name|base_offset
operator|)
condition|)
return|return;
name|cfi
operator|=
name|new_cfi
argument_list|()
expr_stmt|;
if|if
condition|(
name|loc
operator|.
name|reg
operator|==
name|old_cfa
operator|.
name|reg
operator|&&
operator|!
name|loc
operator|.
name|indirect
condition|)
block|{
comment|/* Construct a "DW_CFA_def_cfa_offset<offset>" instruction, 	 indicating the CFA register did not change but the offset 	 did.  */
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa_offset
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
operator|=
name|loc
operator|.
name|offset
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
comment|/* SGI dbx thinks this means no offset.  */
elseif|else
if|if
condition|(
name|loc
operator|.
name|offset
operator|==
name|old_cfa
operator|.
name|offset
operator|&&
name|old_cfa
operator|.
name|reg
operator|!=
operator|(
name|unsigned
name|long
operator|)
operator|-
literal|1
operator|&&
operator|!
name|loc
operator|.
name|indirect
condition|)
block|{
comment|/* Construct a "DW_CFA_def_cfa_register<register>" instruction, 	 indicating the CFA register has changed to<register> but the 	 offset has not changed.  */
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa_register
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
name|loc
operator|.
name|reg
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|loc
operator|.
name|indirect
operator|==
literal|0
condition|)
block|{
comment|/* Construct a "DW_CFA_def_cfa<register><offset>" instruction, 	 indicating the CFA register has changed to<register> with 	 the specified offset.  */
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
name|loc
operator|.
name|reg
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
operator|=
name|loc
operator|.
name|offset
expr_stmt|;
block|}
else|else
block|{
comment|/* Construct a DW_CFA_def_cfa_expression instruction to 	 calculate the CFA using a full location expression since no 	 register-offset pair is available.  */
name|struct
name|dw_loc_descr_struct
modifier|*
name|loc_list
decl_stmt|;
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_def_cfa_expression
expr_stmt|;
name|loc_list
operator|=
name|build_cfa_loc
argument_list|(
operator|&
name|loc
argument_list|)
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_loc
operator|=
name|loc_list
expr_stmt|;
block|}
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the CFI for saving a register.  REG is the CFA column number.    LABEL is passed to add_fde_cfi.    If SREG is -1, the register is saved at OFFSET from the CFA;    otherwise it is saved in SREG.  */
end_comment

begin_function
specifier|static
name|void
name|reg_save
parameter_list|(
name|label
parameter_list|,
name|reg
parameter_list|,
name|sreg
parameter_list|,
name|offset
parameter_list|)
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|unsigned
name|sreg
decl_stmt|;
name|long
name|offset
decl_stmt|;
block|{
name|dw_cfi_ref
name|cfi
init|=
name|new_cfi
argument_list|()
decl_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|=
name|reg
expr_stmt|;
comment|/* The following comparison is correct. -1 is used to indicate that      the value isn't a register number.  */
if|if
condition|(
name|sreg
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|reg
operator|&
operator|~
literal|0x3f
condition|)
comment|/* The register number won't fit in 6 bits, so we have to use 	   the long form.  */
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_offset_extended
expr_stmt|;
else|else
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
block|{
comment|/* If we get an offset that is not a multiple of 	   DWARF_CIE_DATA_ALIGNMENT, there is either a bug in the 	   definition of DWARF_CIE_DATA_ALIGNMENT, or a bug in the machine 	   description.  */
name|long
name|check_offset
init|=
name|offset
operator|/
name|DWARF_CIE_DATA_ALIGNMENT
decl_stmt|;
if|if
condition|(
name|check_offset
operator|*
name|DWARF_CIE_DATA_ALIGNMENT
operator|!=
name|offset
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|offset
operator|/=
name|DWARF_CIE_DATA_ALIGNMENT
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_offset_extended_sf
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
operator|=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sreg
operator|==
name|reg
condition|)
comment|/* We could emit a DW_CFA_same_value in this case, but don't bother.  */
return|return;
else|else
block|{
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_register
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_reg_num
operator|=
name|sreg
expr_stmt|;
block|}
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the CFI for saving a register window.  LABEL is passed to reg_save.    This CFI tells the unwinder that it needs to restore the window registers    from the previous frame's window save area.     ??? Perhaps we should note in the CIE where windows are saved (instead of    assuming 0(cfa)) and what registers are in the window.  */
end_comment

begin_function
name|void
name|dwarf2out_window_save
parameter_list|(
name|label
parameter_list|)
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
block|{
name|dw_cfi_ref
name|cfi
init|=
name|new_cfi
argument_list|()
decl_stmt|;
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_GNU_window_save
expr_stmt|;
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a CFI to update the running total of the size of arguments    pushed onto the stack.  */
end_comment

begin_function
name|void
name|dwarf2out_args_size
parameter_list|(
name|label
parameter_list|,
name|size
parameter_list|)
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
name|dw_cfi_ref
name|cfi
decl_stmt|;
if|if
condition|(
name|size
operator|==
name|old_args_size
condition|)
return|return;
name|old_args_size
operator|=
name|size
expr_stmt|;
name|cfi
operator|=
name|new_cfi
argument_list|()
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_opc
operator|=
name|DW_CFA_GNU_args_size
expr_stmt|;
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
operator|=
name|size
expr_stmt|;
name|add_fde_cfi
argument_list|(
name|label
argument_list|,
name|cfi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point for saving a register to the stack.  REG is the GCC register    number.  LABEL and OFFSET are passed to reg_save.  */
end_comment

begin_function
name|void
name|dwarf2out_reg_save
parameter_list|(
name|label
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|)
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
name|long
name|offset
decl_stmt|;
block|{
name|reg_save
argument_list|(
name|label
argument_list|,
name|DWARF_FRAME_REGNUM
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point for saving the return address in the stack.    LABEL and OFFSET are passed to reg_save.  */
end_comment

begin_function
name|void
name|dwarf2out_return_save
parameter_list|(
name|label
parameter_list|,
name|offset
parameter_list|)
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|long
name|offset
decl_stmt|;
block|{
name|reg_save
argument_list|(
name|label
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|,
operator|-
literal|1
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point for saving the return address in a register.    LABEL and SREG are passed to reg_save.  */
end_comment

begin_function
name|void
name|dwarf2out_return_reg
parameter_list|(
name|label
parameter_list|,
name|sreg
parameter_list|)
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|unsigned
name|sreg
decl_stmt|;
block|{
name|reg_save
argument_list|(
name|label
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|,
name|sreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the initial position of the return address.  RTL is    INCOMING_RETURN_ADDR_RTX.  */
end_comment

begin_function
specifier|static
name|void
name|initial_return_save
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
name|unsigned
name|int
name|reg
init|=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
comment|/* RA is in a register.  */
name|reg
operator|=
name|DWARF_FRAME_REGNUM
argument_list|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
comment|/* RA is on the stack.  */
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
comment|/* The return address is at some offset from any value we can 	 actually load.  For instance, on the SPARC it is in %i7+8. Just 	 ignore the offset for now; it doesn't matter for unwinding frames.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|initial_return_save
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|reg_save
argument_list|(
name|NULL
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|,
name|reg
argument_list|,
name|offset
operator|-
name|cfa
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a SET, calculate the amount of stack adjustment it    contains.  */
end_comment

begin_function
specifier|static
name|long
name|stack_adjust_offset
parameter_list|(
name|pattern
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|rtx
name|dest
init|=
name|SET_DEST
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|stack_pointer_rtx
condition|)
block|{
comment|/* (set (reg sp) (plus (reg sp) (const_int))) */
name|code
operator|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|MINUS
operator|)
operator|||
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
return|return
literal|0
return|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* (set (mem (pre_dec (reg sp))) (foo)) */
name|src
operator|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|!=
name|PRE_DEC
operator|&&
name|code
operator|!=
name|PRE_INC
operator|&&
name|code
operator|!=
name|PRE_MODIFY
operator|)
operator|||
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|PRE_MODIFY
condition|)
block|{
name|rtx
name|val
init|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* We handle only adjustments by constant amount.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|PLUS
operator|||
name|code
operator|==
name|PRE_INC
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
return|return
name|offset
return|;
block|}
end_function

begin_comment
comment|/* Check INSN to see if it looks like a push or a stack adjustment, and    make a note of it if it does.  EH uses this information to find out how    much extra space it needs to pop off the stack.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_stack_adjust
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|flag_asynchronous_unwind_tables
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* Extract the size of the args from the CALL rtx itself.  */
name|insn
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|PARALLEL
condition|)
name|insn
operator|=
name|XVECEXP
argument_list|(
name|insn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|SET
condition|)
name|insn
operator|=
name|SET_SRC
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|CALL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dwarf2out_args_size
argument_list|(
literal|""
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|insn
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If only calls can throw, and we have a frame pointer,      save up adjustments until we see the CALL_INSN.  */
elseif|else
if|if
condition|(
operator|!
name|flag_asynchronous_unwind_tables
operator|&&
name|cfa
operator|.
name|reg
operator|!=
name|STACK_POINTER_REGNUM
condition|)
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
comment|/* When we see a BARRIER, we know to reset args_size to 0.  Usually 	 the compiler will have already emitted a stack adjustment, but 	 doesn't bother for calls to noreturn functions.  */
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|offset
operator|=
operator|-
name|args_size
expr_stmt|;
else|#
directive|else
name|offset
operator|=
name|args_size
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|offset
operator|=
name|stack_adjust_offset
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
comment|/* There may be stack adjustments inside compound insns.  Search 	 for them.  */
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|i
operator|=
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
condition|)
name|offset
operator|+=
name|stack_adjust_offset
argument_list|(
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|cfa
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
ifndef|#
directive|ifndef
name|STACK_GROWS_DOWNWARD
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
endif|#
directive|endif
name|args_size
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|args_size
operator|<
literal|0
condition|)
name|args_size
operator|=
literal|0
expr_stmt|;
name|label
operator|=
name|dwarf2out_cfi_label
argument_list|()
expr_stmt|;
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|cfa
argument_list|)
expr_stmt|;
name|dwarf2out_args_size
argument_list|(
name|label
argument_list|,
name|args_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We delay emitting a register save until either (a) we reach the end    of the prologue or (b) the register is clobbered.  This clusters    register saves so that there are fewer pc advances.  */
end_comment

begin_struct
struct|struct
name|queued_reg_save
block|{
name|struct
name|queued_reg_save
modifier|*
name|next
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|long
name|cfa_offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|queued_reg_save
modifier|*
name|queued_reg_saves
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|last_reg_save_label
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|queue_reg_save
parameter_list|(
name|label
parameter_list|,
name|reg
parameter_list|,
name|offset
parameter_list|)
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|long
name|offset
decl_stmt|;
block|{
name|struct
name|queued_reg_save
modifier|*
name|q
init|=
operator|(
expr|struct
name|queued_reg_save
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|)
decl_stmt|;
name|q
operator|->
name|next
operator|=
name|queued_reg_saves
expr_stmt|;
name|q
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|q
operator|->
name|cfa_offset
operator|=
name|offset
expr_stmt|;
name|queued_reg_saves
operator|=
name|q
expr_stmt|;
name|last_reg_save_label
operator|=
name|label
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_queued_reg_saves
parameter_list|()
block|{
name|struct
name|queued_reg_save
modifier|*
name|q
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|q
operator|=
name|queued_reg_saves
init|;
name|q
condition|;
name|q
operator|=
name|next
control|)
block|{
name|dwarf2out_reg_save
argument_list|(
name|last_reg_save_label
argument_list|,
name|REGNO
argument_list|(
name|q
operator|->
name|reg
argument_list|)
argument_list|,
name|q
operator|->
name|cfa_offset
argument_list|)
expr_stmt|;
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|queued_reg_saves
operator|=
name|NULL
expr_stmt|;
name|last_reg_save_label
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|clobbers_queued_reg_save
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|struct
name|queued_reg_save
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|queued_reg_saves
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
if|if
condition|(
name|modified_in_p
argument_list|(
name|q
operator|->
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A temporary register holding an integral value used in adjusting SP    or setting up the store_reg.  The "offset" field holds the integer    value, not an offset.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_cfa_location
name|cfa_temp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record call frame debugging information for an expression EXPR,    which either sets SP or FP (adjusting how we calculate the frame    address) or saves a register to the stack.  LABEL indicates the    address of EXPR.     This function encodes a state machine mapping rtxes to actions on    cfa, cfa_store, and cfa_temp.reg.  We describe these rules so    users need not read the source code.    The High-Level Picture    Changes in the register we use to calculate the CFA: Currently we   assume that if you copy the CFA register into another register, we   should take the other one as the new CFA register; this seems to   work pretty well.  If it's wrong for some target, it's simple   enough not to set RTX_FRAME_RELATED_P on the insn in question.    Changes in the register we use for saving registers to the stack:   This is usually SP, but not always.  Again, we deduce that if you   copy SP into another register (and SP is not the CFA register),   then the new register is the one we will be using for register   saves.  This also seems to work.    Register saves: There's not much guesswork about this one; if   RTX_FRAME_RELATED_P is set on an insn which modifies memory, it's a   register save, and the register used to calculate the destination   had better be the one we think we're using for this purpose.    Except: If the register being saved is the CFA register, and the   offset is non-zero, we are saving the CFA, so we assume we have to   use DW_CFA_def_cfa_expression.  If the offset is 0, we assume that   the intent is to save the value of SP from the previous frame.    Invariants / Summaries of Rules    cfa	       current rule for calculating the CFA.  It usually 	       consists of a register and an offset.   cfa_store    register used by prologue code to save things to the stack 	       cfa_store.offset is the offset from the value of 	       cfa_store.reg to the actual CFA   cfa_temp     register holding an integral value.  cfa_temp.offset 	       stores the value, which will be used to adjust the 	       stack pointer.  cfa_temp is also used like cfa_store, 	       to track stores to the stack via fp or a temp reg.     Rules  1- 4: Setting a register's value to cfa.reg or an expression   	       with cfa.reg as the first operand changes the cfa.reg and its 	       cfa.offset.  Rule 1 and 4 also set cfa_temp.reg and 	       cfa_temp.offset.    Rules  6- 9: Set a non-cfa.reg register value to a constant or an 	       expression yielding a constant.  This sets cfa_temp.reg 	       and cfa_temp.offset.    Rule 5:      Create a new register cfa_store used to save items to the 	       stack.    Rules 10-14: Save a register to the stack.  Define offset as the 	       difference of the original location and cfa_store's 	       location (or cfa_temp's location if cfa_temp is used).    The Rules    "{a,b}" indicates a choice of a xor b.   "<reg>:cfa.reg" indicates that<reg> must equal cfa.reg.    Rule 1:   (set<reg1><reg2>:cfa.reg)   effects: cfa.reg =<reg1>            cfa.offset unchanged 	   cfa_temp.reg =<reg1> 	   cfa_temp.offset = cfa.offset    Rule 2:   (set sp ({minus,plus,losum} {sp,fp}:cfa.reg 			      {<const_int>,<reg>:cfa_temp.reg}))   effects: cfa.reg = sp if fp used  	   cfa.offset += {+/-<const_int>, cfa_temp.offset} if cfa.reg==sp 	   cfa_store.offset += {+/-<const_int>, cfa_temp.offset} 	     if cfa_store.reg==sp    Rule 3:   (set fp ({minus,plus,losum}<reg>:cfa.reg<const_int>))   effects: cfa.reg = fp   	   cfa_offset += +/-<const_int>    Rule 4:   (set<reg1> ({plus,losum}<reg2>:cfa.reg<const_int>))   constraints:<reg1> != fp<reg1> != sp   effects: cfa.reg =<reg1> 	   cfa_temp.reg =<reg1> 	   cfa_temp.offset = cfa.offset    Rule 5:   (set<reg1> (plus<reg2>:cfa_temp.reg sp:cfa.reg))   constraints:<reg1> != fp<reg1> != sp   effects: cfa_store.reg =<reg1>   	   cfa_store.offset = cfa.offset - cfa_temp.offset    Rule 6:   (set<reg><const_int>)   effects: cfa_temp.reg =<reg>   	   cfa_temp.offset =<const_int>    Rule 7:   (set<reg1>:cfa_temp.reg (ior<reg2>:cfa_temp.reg<const_int>))   effects: cfa_temp.reg =<reg1> 	   cfa_temp.offset |=<const_int>    Rule 8:   (set<reg> (high<exp>))   effects: none    Rule 9:   (set<reg> (lo_sum<exp><const_int>))   effects: cfa_temp.reg =<reg>   	   cfa_temp.offset =<const_int>    Rule 10:   (set (mem (pre_modify sp:cfa_store (????<reg1><const_int>)))<reg2>)   effects: cfa_store.offset -=<const_int> 	   cfa.offset = cfa_store.offset if cfa.reg == sp 	   cfa.reg = sp 	   cfa.base_offset = -cfa_store.offset    Rule 11:   (set (mem ({pre_inc,pre_dec} sp:cfa_store.reg))<reg>)   effects: cfa_store.offset += -/+ mode_size(mem) 	   cfa.offset = cfa_store.offset if cfa.reg == sp 	   cfa.reg = sp 	   cfa.base_offset = -cfa_store.offset    Rule 12:   (set (mem ({minus,plus,losum}<reg1>:{cfa_store,cfa_temp}<const_int>))<reg2>)   effects: cfa.reg =<reg1> 	   cfa.base_offset = -/+<const_int> - {cfa_store,cfa_temp}.offset    Rule 13:   (set (mem<reg1>:{cfa_store,cfa_temp})<reg2>)   effects: cfa.reg =<reg1> 	   cfa.base_offset = -{cfa_store,cfa_temp}.offset    Rule 14:   (set (mem (postinc<reg1>:cfa_temp<const_int>))<reg2>)   effects: cfa.reg =<reg1> 	   cfa.base_offset = -cfa_temp.offset 	   cfa_temp.offset -= mode_size(mem)  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_frame_debug_expr
parameter_list|(
name|expr
parameter_list|,
name|label
parameter_list|)
name|rtx
name|expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
block|{
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|HOST_WIDE_INT
name|offset
decl_stmt|;
comment|/* If RTX_FRAME_RELATED_P is set on a PARALLEL, process each member of      the PARALLEL independently. The first element is always processed if      it is a SET. This is for backward compatibility.   Other elements      are processed only if they are SETs and the RTX_FRAME_RELATED_P      flag is set in them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|PARALLEL
operator|||
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|SEQUENCE
condition|)
block|{
name|int
name|par_index
decl_stmt|;
name|int
name|limit
init|=
name|XVECLEN
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|par_index
operator|=
literal|0
init|;
name|par_index
operator|<
name|limit
condition|;
name|par_index
operator|++
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|,
name|par_index
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
operator|(
name|RTX_FRAME_RELATED_P
argument_list|(
name|XVECEXP
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|,
name|par_index
argument_list|)
argument_list|)
operator|||
name|par_index
operator|==
literal|0
operator|)
condition|)
name|dwarf2out_frame_debug_expr
argument_list|(
name|XVECEXP
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|,
name|par_index
argument_list|)
argument_list|,
name|label
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|SET
condition|)
name|abort
argument_list|()
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|expr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
condition|)
block|{
case|case
name|REG
case|:
comment|/* Rule 1 */
comment|/* Update the CFA rule wrt SP or FP.  Make sure src is          relative to the current CFA register.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
condition|)
block|{
comment|/* Setting FP from SP.  */
case|case
name|REG
case|:
if|if
condition|(
name|cfa
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|src
argument_list|)
condition|)
comment|/* OK.  */
empty_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* We used to require that dest be either SP or FP, but the 	     ARM copies SP to a temporary register, and from there to 	     FP.  So we just rely on the backends to only set 	     RTX_FRAME_RELATED_P on appropriate insns.  */
name|cfa
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_temp
operator|.
name|reg
operator|=
name|cfa
operator|.
name|reg
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|=
name|cfa
operator|.
name|offset
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|LO_SUM
case|:
if|if
condition|(
name|dest
operator|==
name|stack_pointer_rtx
condition|)
block|{
comment|/* Rule 2 */
comment|/* Adjusting SP.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|cfa_temp
operator|.
name|reg
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
name|cfa_temp
operator|.
name|offset
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|==
name|hard_frame_pointer_rtx
condition|)
block|{
comment|/* Restoring SP from FP in the epilogue.  */
if|if
condition|(
name|cfa
operator|.
name|reg
operator|!=
operator|(
name|unsigned
operator|)
name|HARD_FRAME_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa
operator|.
name|reg
operator|=
name|STACK_POINTER_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LO_SUM
condition|)
comment|/* Assume we've set the source reg of the LO_SUM from sp.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
operator|!=
name|stack_pointer_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MINUS
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|cfa
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|cfa_store
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa_store
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dest
operator|==
name|hard_frame_pointer_rtx
condition|)
block|{
comment|/* Rule 3 */
comment|/* Either setting the FP from an offset of the SP, 		 or adjusting the FP */
if|if
condition|(
operator|!
name|frame_pointer_needed
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|cfa
operator|.
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MINUS
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|cfa
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
name|cfa
operator|.
name|reg
operator|=
name|HARD_FRAME_POINTER_REGNUM
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|MINUS
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Rule 4 */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|cfa
operator|.
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
comment|/* Setting a temporary CFA register that will be copied 		     into the FP later on.  */
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|cfa
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
name|cfa
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* Or used to save regs to the stack.  */
name|cfa_temp
operator|.
name|reg
operator|=
name|cfa
operator|.
name|reg
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|=
name|cfa
operator|.
name|offset
expr_stmt|;
block|}
comment|/* Rule 5 */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|cfa_temp
operator|.
name|reg
operator|&&
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
block|{
comment|/* Setting a scratch register that we will use instead 		     of SP for saving registers to the stack.  */
if|if
condition|(
name|cfa
operator|.
name|reg
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa_store
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_store
operator|.
name|offset
operator|=
name|cfa
operator|.
name|offset
operator|-
name|cfa_temp
operator|.
name|offset
expr_stmt|;
block|}
comment|/* Rule 9 */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|LO_SUM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|cfa_temp
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
comment|/* Rule 6 */
case|case
name|CONST_INT
case|:
name|cfa_temp
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|src
argument_list|)
expr_stmt|;
break|break;
comment|/* Rule 7 */
case|case
name|IOR
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|cfa_temp
operator|.
name|reg
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|dest
argument_list|)
operator|!=
name|cfa_temp
operator|.
name|reg
condition|)
name|cfa_temp
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator||=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Skip over HIGH, assuming it will be followed by a LO_SUM, 	     which will fill in all of the bits.  */
comment|/* Rule 8 */
case|case
name|HIGH
case|:
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|cfa
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Saving a register to the stack.  Make sure dest is relative to the 	 CFA register.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Rule 10 */
comment|/* With a push.  */
case|case
name|PRE_MODIFY
case|:
comment|/* We can't handle variable size modifications.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|||
name|cfa_store
operator|.
name|reg
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa_store
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|cfa
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa
operator|.
name|offset
operator|=
name|cfa_store
operator|.
name|offset
expr_stmt|;
name|offset
operator|=
operator|-
name|cfa_store
operator|.
name|offset
expr_stmt|;
break|break;
comment|/* Rule 11 */
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
name|offset
operator|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|||
name|cfa_store
operator|.
name|reg
operator|!=
name|STACK_POINTER_REGNUM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa_store
operator|.
name|offset
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|cfa
operator|.
name|reg
operator|==
name|STACK_POINTER_REGNUM
condition|)
name|cfa
operator|.
name|offset
operator|=
name|cfa_store
operator|.
name|offset
expr_stmt|;
name|offset
operator|=
operator|-
name|cfa_store
operator|.
name|offset
expr_stmt|;
break|break;
comment|/* Rule 12 */
comment|/* With an offset.  */
case|case
name|PLUS
case|:
case|case
name|MINUS
case|:
case|case
name|LO_SUM
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MINUS
condition|)
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|cfa_store
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|offset
operator|-=
name|cfa_store
operator|.
name|offset
expr_stmt|;
elseif|else
if|if
condition|(
name|cfa_temp
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|offset
operator|-=
name|cfa_temp
operator|.
name|offset
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
comment|/* Rule 13 */
comment|/* Without an offset.  */
case|case
name|REG
case|:
if|if
condition|(
name|cfa_store
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|offset
operator|=
operator|-
name|cfa_store
operator|.
name|offset
expr_stmt|;
elseif|else
if|if
condition|(
name|cfa_temp
operator|.
name|reg
operator|==
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|offset
operator|=
operator|-
name|cfa_temp
operator|.
name|offset
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
comment|/* Rule 14 */
case|case
name|POST_INC
case|:
if|if
condition|(
name|cfa_temp
operator|.
name|reg
operator|!=
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|=
operator|-
name|cfa_temp
operator|.
name|offset
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|dest
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|REGNO
argument_list|(
name|src
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
name|unsigned
operator|)
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|cfa
operator|.
name|reg
condition|)
block|{
comment|/* We're storing the current CFA reg into the stack.  */
if|if
condition|(
name|cfa
operator|.
name|offset
operator|==
literal|0
condition|)
block|{
comment|/* If the source register is exactly the CFA, assume 		 we're saving SP like any other register; this happens 		 on the ARM.  */
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|cfa
argument_list|)
expr_stmt|;
name|queue_reg_save
argument_list|(
name|label
argument_list|,
name|stack_pointer_rtx
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Otherwise, we'll need to look in the stack to                  calculate the CFA.  */
name|rtx
name|x
init|=
name|XEXP
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa
operator|.
name|reg
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|cfa
operator|.
name|base_offset
operator|=
name|offset
expr_stmt|;
name|cfa
operator|.
name|indirect
operator|=
literal|1
expr_stmt|;
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|cfa
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|def_cfa_1
argument_list|(
name|label
argument_list|,
operator|&
name|cfa
argument_list|)
expr_stmt|;
name|queue_reg_save
argument_list|(
name|label
argument_list|,
name|src
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record call frame debugging information for INSN, which either    sets SP or FP (adjusting how we calculate the frame address) or saves a    register to the stack.  If INSN is NULL_RTX, initialize our state.  */
end_comment

begin_function
name|void
name|dwarf2out_frame_debug
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
name|rtx
name|src
decl_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
condition|)
block|{
comment|/* Flush any queued register saves.  */
name|flush_queued_reg_saves
argument_list|()
expr_stmt|;
comment|/* Set up state for generating call frame debug info.  */
name|lookup_cfa
argument_list|(
operator|&
name|cfa
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfa
operator|.
name|reg
operator|!=
operator|(
name|unsigned
name|long
operator|)
name|DWARF_FRAME_REGNUM
argument_list|(
name|STACK_POINTER_REGNUM
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cfa
operator|.
name|reg
operator|=
name|STACK_POINTER_REGNUM
expr_stmt|;
name|cfa_store
operator|=
name|cfa
expr_stmt|;
name|cfa_temp
operator|.
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
name|cfa_temp
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|INSN
operator|||
name|clobbers_queued_reg_save
argument_list|(
name|insn
argument_list|)
condition|)
name|flush_queued_reg_saves
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|RTX_FRAME_RELATED_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ACCUMULATE_OUTGOING_ARGS
condition|)
name|dwarf2out_stack_adjust
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
name|label
operator|=
name|dwarf2out_cfi_label
argument_list|()
expr_stmt|;
name|src
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_FRAME_RELATED_EXPR
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
condition|)
name|insn
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|dwarf2out_frame_debug_expr
argument_list|(
name|insn
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a Call Frame Information opcode and its operand(s).  */
end_comment

begin_function
specifier|static
name|void
name|output_cfi
parameter_list|(
name|cfi
parameter_list|,
name|fde
parameter_list|,
name|for_eh
parameter_list|)
name|dw_cfi_ref
name|cfi
decl_stmt|;
name|dw_fde_ref
name|fde
decl_stmt|;
name|int
name|for_eh
decl_stmt|;
block|{
if|if
condition|(
name|cfi
operator|->
name|dw_cfi_opc
operator|==
name|DW_CFA_advance_loc
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
operator|(
name|cfi
operator|->
name|dw_cfi_opc
operator||
operator|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
operator|&
literal|0x3f
operator|)
operator|)
argument_list|,
literal|"DW_CFA_advance_loc 0x%lx"
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cfi
operator|->
name|dw_cfi_opc
operator|==
name|DW_CFA_offset
condition|)
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
operator|(
name|cfi
operator|->
name|dw_cfi_opc
operator||
operator|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|&
literal|0x3f
operator|)
operator|)
argument_list|,
literal|"DW_CFA_offset, column 0x%lx"
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfi
operator|->
name|dw_cfi_opc
operator|==
name|DW_CFA_restore
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
operator|(
name|cfi
operator|->
name|dw_cfi_opc
operator||
operator|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
operator|&
literal|0x3f
operator|)
operator|)
argument_list|,
literal|"DW_CFA_restore, column 0x%lx"
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|)
expr_stmt|;
else|else
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|cfi
operator|->
name|dw_cfi_opc
argument_list|,
literal|"%s"
argument_list|,
name|dwarf_cfi_name
argument_list|(
name|cfi
operator|->
name|dw_cfi_opc
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cfi
operator|->
name|dw_cfi_opc
condition|)
block|{
case|case
name|DW_CFA_set_loc
case|:
if|if
condition|(
name|for_eh
condition|)
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|1
argument_list|,
comment|/*global=*/
literal|0
argument_list|)
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
name|dw2_asm_output_delta
argument_list|(
literal|1
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
name|dw2_asm_output_delta
argument_list|(
literal|2
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
name|dw2_asm_output_delta
argument_list|(
literal|4
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_MIPS_advance_loc8
case|:
name|dw2_asm_output_delta
argument_list|(
literal|8
argument_list|,
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
argument_list|,
name|fde
operator|->
name|dw_fde_current_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_addr
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended
case|:
case|case
name|DW_CFA_def_cfa
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended_sf
case|:
case|case
name|DW_CFA_def_cfa_sf
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_sleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
case|case
name|DW_CFA_undefined
case|:
case|case
name|DW_CFA_same_value
case|:
case|case
name|DW_CFA_def_cfa_register
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_register
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_reg_num
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd2
operator|.
name|dw_cfi_reg_num
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
case|case
name|DW_CFA_GNU_args_size
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
name|dw2_asm_output_data_sleb128
argument_list|(
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_window_save
case|:
break|break;
case|case
name|DW_CFA_def_cfa_expression
case|:
case|case
name|DW_CFA_expression
case|:
name|output_cfa_loc
argument_list|(
name|cfi
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
comment|/* Obsoleted by DW_CFA_offset_extended_sf.  */
name|abort
argument_list|()
expr_stmt|;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output the call frame information used to used to record information    that relates to calculating the frame pointer, and records the    location of saved registers.  */
end_comment

begin_function
specifier|static
name|void
name|output_call_frame_info
parameter_list|(
name|for_eh
parameter_list|)
name|int
name|for_eh
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|dw_fde_ref
name|fde
decl_stmt|;
name|dw_cfi_ref
name|cfi
decl_stmt|;
name|char
name|l1
index|[
literal|20
index|]
decl_stmt|,
name|l2
index|[
literal|20
index|]
decl_stmt|,
name|section_start_label
index|[
literal|20
index|]
decl_stmt|;
name|int
name|any_lsda_needed
init|=
literal|0
decl_stmt|;
name|char
name|augmentation
index|[
literal|6
index|]
decl_stmt|;
name|int
name|augmentation_size
decl_stmt|;
name|int
name|fde_encoding
init|=
name|DW_EH_PE_absptr
decl_stmt|;
name|int
name|per_encoding
init|=
name|DW_EH_PE_absptr
decl_stmt|;
name|int
name|lsda_encoding
init|=
name|DW_EH_PE_absptr
decl_stmt|;
comment|/* If we don't have any functions we'll want to unwind out of, don't emit any      EH unwind information.  */
if|if
condition|(
name|for_eh
condition|)
block|{
name|int
name|any_eh_needed
init|=
name|flag_asynchronous_unwind_tables
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fde_table_in_use
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fde_table
index|[
name|i
index|]
operator|.
name|uses_eh_lsda
condition|)
name|any_eh_needed
operator|=
name|any_lsda_needed
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|fde_table
index|[
name|i
index|]
operator|.
name|nothrow
condition|)
name|any_eh_needed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|any_eh_needed
condition|)
return|return;
block|}
comment|/* We're going to be generating comments, so turn on app.  */
if|if
condition|(
name|flag_debug_asm
condition|)
name|app_enable
argument_list|()
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
call|(
modifier|*
name|targetm
operator|.
name|asm_out
operator|.
name|eh_frame_section
call|)
argument_list|()
expr_stmt|;
else|else
name|named_section_flags
argument_list|(
name|DEBUG_FRAME_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|section_start_label
argument_list|,
name|FRAME_BEGIN_LABEL
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|section_start_label
argument_list|)
expr_stmt|;
comment|/* Output the CIE.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
name|CIE_AFTER_SIZE_LABEL
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l2
argument_list|,
name|CIE_END_LABEL
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|for_eh
condition|?
literal|4
else|:
name|DWARF_OFFSET_SIZE
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|,
literal|"Length of Common Information Entry"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l1
argument_list|)
expr_stmt|;
comment|/* Now that the CIE pointer is PC-relative for EH,      use 0 to identify the CIE.  */
name|dw2_asm_output_data
argument_list|(
operator|(
name|for_eh
condition|?
literal|4
else|:
name|DWARF_OFFSET_SIZE
operator|)
argument_list|,
operator|(
name|for_eh
condition|?
literal|0
else|:
name|DW_CIE_ID
operator|)
argument_list|,
literal|"CIE Identifier Tag"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_CIE_VERSION
argument_list|,
literal|"CIE Version"
argument_list|)
expr_stmt|;
name|augmentation
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|augmentation_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Augmentation: 	 z	Indicates that a uleb128 is present to size the 	 	augmentation section. 	 L	Indicates the encoding (and thus presence) of 		an LSDA pointer in the FDE augmentation. 	 R	Indicates a non-default pointer encoding for 		FDE code pointers. 	 P	Indicates the presence of an encoding + language 		personality routine in the CIE augmentation.  */
name|fde_encoding
operator|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|1
argument_list|,
comment|/*global=*/
literal|0
argument_list|)
expr_stmt|;
name|per_encoding
operator|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|2
argument_list|,
comment|/*global=*/
literal|1
argument_list|)
expr_stmt|;
name|lsda_encoding
operator|=
name|ASM_PREFERRED_EH_DATA_FORMAT
argument_list|(
comment|/*code=*/
literal|0
argument_list|,
comment|/*global=*/
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|augmentation
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|eh_personality_libfunc
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'P'
expr_stmt|;
name|augmentation_size
operator|+=
literal|1
operator|+
name|size_of_encoded_value
argument_list|(
name|per_encoding
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|any_lsda_needed
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
name|augmentation_size
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fde_encoding
operator|!=
name|DW_EH_PE_absptr
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'R'
expr_stmt|;
name|augmentation_size
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|>
name|augmentation
operator|+
literal|1
condition|)
block|{
name|augmentation
index|[
literal|0
index|]
operator|=
literal|'z'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Ug.  Some platforms can't do unaligned dynamic relocations at all.  */
if|if
condition|(
name|eh_personality_libfunc
operator|&&
name|per_encoding
operator|==
name|DW_EH_PE_aligned
condition|)
block|{
name|int
name|offset
init|=
operator|(
literal|4
comment|/* Length */
operator|+
literal|4
comment|/* CIE Id */
operator|+
literal|1
comment|/* CIE version */
operator|+
name|strlen
argument_list|(
name|augmentation
argument_list|)
operator|+
literal|1
comment|/* Augmentation */
operator|+
name|size_of_uleb128
argument_list|(
literal|1
argument_list|)
comment|/* Code alignment */
operator|+
name|size_of_sleb128
argument_list|(
name|DWARF_CIE_DATA_ALIGNMENT
argument_list|)
operator|+
literal|1
comment|/* RA column */
operator|+
literal|1
comment|/* Augmentation size */
operator|+
literal|1
comment|/* Personality encoding */
operator|)
decl_stmt|;
name|int
name|pad
init|=
operator|-
name|offset
operator|&
operator|(
name|PTR_SIZE
operator|-
literal|1
operator|)
decl_stmt|;
name|augmentation_size
operator|+=
name|pad
expr_stmt|;
comment|/* Augmentations should be small, so there's scarce need to 	     iterate for a solution.  Die if we exceed one uleb128 byte.  */
if|if
condition|(
name|size_of_uleb128
argument_list|(
name|augmentation_size
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
name|dw2_asm_output_nstring
argument_list|(
name|augmentation
argument_list|,
operator|-
literal|1
argument_list|,
literal|"CIE Augmentation"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
argument_list|,
literal|"CIE Code Alignment Factor"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_sleb128
argument_list|(
name|DWARF_CIE_DATA_ALIGNMENT
argument_list|,
literal|"CIE Data Alignment Factor"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_FRAME_RETURN_COLUMN
argument_list|,
literal|"CIE RA Column"
argument_list|)
expr_stmt|;
if|if
condition|(
name|augmentation
index|[
literal|0
index|]
condition|)
block|{
name|dw2_asm_output_data_uleb128
argument_list|(
name|augmentation_size
argument_list|,
literal|"Augmentation size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh_personality_libfunc
condition|)
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|per_encoding
argument_list|,
literal|"Personality (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|per_encoding
argument_list|)
argument_list|)
expr_stmt|;
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|per_encoding
argument_list|,
name|eh_personality_libfunc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|any_lsda_needed
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|lsda_encoding
argument_list|,
literal|"LSDA Encoding (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|lsda_encoding
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde_encoding
operator|!=
name|DW_EH_PE_absptr
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|fde_encoding
argument_list|,
literal|"FDE Encoding (%s)"
argument_list|,
name|eh_data_format_name
argument_list|(
name|fde_encoding
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cfi
operator|=
name|cie_cfi_head
init|;
name|cfi
operator|!=
name|NULL
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|output_cfi
argument_list|(
name|cfi
argument_list|,
name|NULL
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
comment|/* Pad the CIE out to an address sized boundary.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|for_eh
condition|?
name|PTR_SIZE
else|:
name|DWARF2_ADDR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|)
expr_stmt|;
comment|/* Loop through all of the FDE's.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fde_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|fde
operator|=
operator|&
name|fde_table
index|[
name|i
index|]
expr_stmt|;
comment|/* Don't emit EH unwind info for leaf functions that don't need it.  */
if|if
condition|(
name|for_eh
operator|&&
name|fde
operator|->
name|nothrow
operator|&&
operator|!
name|fde
operator|->
name|uses_eh_lsda
condition|)
continue|continue;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|FDE_LABEL
argument_list|,
name|for_eh
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
name|FDE_AFTER_SIZE_LABEL
argument_list|,
name|for_eh
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l2
argument_list|,
name|FDE_END_LABEL
argument_list|,
name|for_eh
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|for_eh
condition|?
literal|4
else|:
name|DWARF_OFFSET_SIZE
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|,
literal|"FDE Length"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
name|dw2_asm_output_delta
argument_list|(
literal|4
argument_list|,
name|l1
argument_list|,
name|section_start_label
argument_list|,
literal|"FDE CIE offset"
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|section_start_label
argument_list|,
literal|"FDE CIE offset"
argument_list|)
expr_stmt|;
if|if
condition|(
name|for_eh
condition|)
block|{
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|fde_encoding
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|fde
operator|->
name|dw_fde_begin
argument_list|)
argument_list|,
literal|"FDE initial location"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|size_of_encoded_value
argument_list|(
name|fde_encoding
argument_list|)
argument_list|,
name|fde
operator|->
name|dw_fde_end
argument_list|,
name|fde
operator|->
name|dw_fde_begin
argument_list|,
literal|"FDE address range"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|fde
operator|->
name|dw_fde_begin
argument_list|,
literal|"FDE initial location"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|fde
operator|->
name|dw_fde_end
argument_list|,
name|fde
operator|->
name|dw_fde_begin
argument_list|,
literal|"FDE address range"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|augmentation
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|any_lsda_needed
condition|)
block|{
name|int
name|size
init|=
name|size_of_encoded_value
argument_list|(
name|lsda_encoding
argument_list|)
decl_stmt|;
if|if
condition|(
name|lsda_encoding
operator|==
name|DW_EH_PE_aligned
condition|)
block|{
name|int
name|offset
init|=
operator|(
literal|4
comment|/* Length */
operator|+
literal|4
comment|/* CIE offset */
operator|+
literal|2
operator|*
name|size_of_encoded_value
argument_list|(
name|fde_encoding
argument_list|)
operator|+
literal|1
comment|/* Augmentation size */
operator|)
decl_stmt|;
name|int
name|pad
init|=
operator|-
name|offset
operator|&
operator|(
name|PTR_SIZE
operator|-
literal|1
operator|)
decl_stmt|;
name|size
operator|+=
name|pad
expr_stmt|;
if|if
condition|(
name|size_of_uleb128
argument_list|(
name|size
argument_list|)
operator|!=
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|dw2_asm_output_data_uleb128
argument_list|(
name|size
argument_list|,
literal|"Augmentation size"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde
operator|->
name|uses_eh_lsda
condition|)
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
literal|"LLSDA"
argument_list|,
name|fde
operator|->
name|funcdef_number
argument_list|)
expr_stmt|;
name|dw2_asm_output_encoded_addr_rtx
argument_list|(
name|lsda_encoding
argument_list|,
name|gen_rtx_SYMBOL_REF
argument_list|(
name|Pmode
argument_list|,
name|l1
argument_list|)
argument_list|,
literal|"Language Specific Data Area"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lsda_encoding
operator|==
name|DW_EH_PE_aligned
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
name|PTR_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|size_of_encoded_value
argument_list|(
name|lsda_encoding
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Language Specific Data Area (none)"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|dw2_asm_output_data_uleb128
argument_list|(
literal|0
argument_list|,
literal|"Augmentation size"
argument_list|)
expr_stmt|;
block|}
comment|/* Loop through the Call Frame Instructions associated with 	 this FDE.  */
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|fde
operator|->
name|dw_fde_begin
expr_stmt|;
for|for
control|(
name|cfi
operator|=
name|fde
operator|->
name|dw_fde_cfi
init|;
name|cfi
operator|!=
name|NULL
condition|;
name|cfi
operator|=
name|cfi
operator|->
name|dw_cfi_next
control|)
name|output_cfi
argument_list|(
name|cfi
argument_list|,
name|fde
argument_list|,
name|for_eh
argument_list|)
expr_stmt|;
comment|/* Pad the FDE out to an address sized boundary.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|floor_log2
argument_list|(
operator|(
name|for_eh
condition|?
name|PTR_SIZE
else|:
name|DWARF2_ADDR_SIZE
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|EH_FRAME_SECTION_NAME
if|if
condition|(
name|for_eh
condition|)
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|,
literal|"End of Table"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* Work around Irix 6 assembler bug whereby labels at the end of a section      get a value of 0.  Putting .align 0 after the label fixes it.  */
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Turn off app to make assembly quicker.  */
if|if
condition|(
name|flag_debug_asm
condition|)
name|app_disable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the beginning of a function, before    the prologue.  */
end_comment

begin_function
name|void
name|dwarf2out_begin_prologue
parameter_list|(
name|line
parameter_list|,
name|file
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|dw_fde_ref
name|fde
decl_stmt|;
name|current_function_func_begin_label
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IA64_UNWIND_INFO
comment|/* ??? current_function_func_begin_label is also used by except.c      for call-site information.  We must emit this label if it might      be used.  */
if|if
condition|(
operator|(
operator|!
name|flag_exceptions
operator|||
name|USING_SJLJ_EXCEPTIONS
operator|)
operator|&&
operator|!
name|dwarf2out_do_frame
argument_list|()
condition|)
return|return;
else|#
directive|else
if|if
condition|(
operator|!
name|dwarf2out_do_frame
argument_list|()
condition|)
return|return;
endif|#
directive|endif
name|current_funcdef_number
operator|++
expr_stmt|;
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|FUNC_BEGIN_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEBUG_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|FUNC_BEGIN_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|current_function_func_begin_label
operator|=
name|get_identifier
argument_list|(
name|label
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IA64_UNWIND_INFO
comment|/* We can elide the fde allocation if we're not emitting debug info.  */
if|if
condition|(
operator|!
name|dwarf2out_do_frame
argument_list|()
condition|)
return|return;
endif|#
directive|endif
comment|/* Expand the fde table if necessary.  */
if|if
condition|(
name|fde_table_in_use
operator|==
name|fde_table_allocated
condition|)
block|{
name|fde_table_allocated
operator|+=
name|FDE_TABLE_INCREMENT
expr_stmt|;
name|fde_table
operator|=
operator|(
name|dw_fde_ref
operator|)
name|xrealloc
argument_list|(
name|fde_table
argument_list|,
name|fde_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_fde_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Record the FDE associated with this function.  */
name|current_funcdef_fde
operator|=
name|fde_table_in_use
expr_stmt|;
comment|/* Add the new FDE at the end of the fde_table.  */
name|fde
operator|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|++
index|]
expr_stmt|;
name|fde
operator|->
name|dw_fde_begin
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|fde
operator|->
name|dw_fde_current_label
operator|=
name|NULL
expr_stmt|;
name|fde
operator|->
name|dw_fde_end
operator|=
name|NULL
expr_stmt|;
name|fde
operator|->
name|dw_fde_cfi
operator|=
name|NULL
expr_stmt|;
name|fde
operator|->
name|funcdef_number
operator|=
name|current_funcdef_number
expr_stmt|;
name|fde
operator|->
name|nothrow
operator|=
name|current_function_nothrow
expr_stmt|;
name|fde
operator|->
name|uses_eh_lsda
operator|=
name|cfun
operator|->
name|uses_eh_lsda
expr_stmt|;
name|args_size
operator|=
name|old_args_size
operator|=
literal|0
expr_stmt|;
comment|/* We only want to output line number information for the genuine dwarf2      prologue case, not the eh frame case.  */
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
if|if
condition|(
name|file
condition|)
name|dwarf2out_source_line
argument_list|(
name|line
argument_list|,
name|file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the absolute end of the generated code    for a function definition.  This gets called *after* the epilogue code has    been generated.  */
end_comment

begin_function
name|void
name|dwarf2out_end_epilogue
parameter_list|()
block|{
name|dw_fde_ref
name|fde
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* Output a label to mark the endpoint of the code generated for this      function.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|fde
operator|=
operator|&
name|fde_table
index|[
name|fde_table_in_use
operator|-
literal|1
index|]
expr_stmt|;
name|fde
operator|->
name|dw_fde_end
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dwarf2out_frame_init
parameter_list|()
block|{
comment|/* Allocate the initial hunk of the fde_table.  */
name|fde_table
operator|=
operator|(
name|dw_fde_ref
operator|)
name|xcalloc
argument_list|(
name|FDE_TABLE_INCREMENT
argument_list|,
sizeof|sizeof
argument_list|(
name|dw_fde_node
argument_list|)
argument_list|)
expr_stmt|;
name|fde_table_allocated
operator|=
name|FDE_TABLE_INCREMENT
expr_stmt|;
name|fde_table_in_use
operator|=
literal|0
expr_stmt|;
comment|/* Generate the CFA instructions common to all FDE's.  Do it now for the      sake of lookup_cfa.  */
ifdef|#
directive|ifdef
name|DWARF2_UNWIND_INFO
comment|/* On entry, the Canonical Frame Address is at SP.  */
name|dwarf2out_def_cfa
argument_list|(
name|NULL
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|,
name|INCOMING_FRAME_SP_OFFSET
argument_list|)
expr_stmt|;
name|initial_return_save
argument_list|(
name|INCOMING_RETURN_ADDR_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|dwarf2out_frame_finish
parameter_list|()
block|{
comment|/* Output call frame information.  */
if|if
condition|(
name|write_symbols
operator|==
name|DWARF2_DEBUG
operator|||
name|write_symbols
operator|==
name|VMS_AND_DWARF2_DEBUG
condition|)
name|output_call_frame_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|USING_SJLJ_EXCEPTIONS
operator|&&
operator|(
name|flag_unwind_tables
operator|||
name|flag_exceptions
operator|)
condition|)
name|output_call_frame_info
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* And now, the subset of the debugging information support code necessary    for emitting location expressions.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_val_struct
modifier|*
name|dw_val_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|die_struct
modifier|*
name|dw_die_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_loc_descr_struct
modifier|*
name|dw_loc_descr_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_loc_list_struct
modifier|*
name|dw_loc_list_ref
typedef|;
end_typedef

begin_comment
comment|/* Each DIE may have a series of attribute/value pairs.  Values    can take on several forms.  The forms that are used in this    implementation are listed below.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|dw_val_class_addr
block|,
name|dw_val_class_offset
block|,
name|dw_val_class_loc
block|,
name|dw_val_class_loc_list
block|,
name|dw_val_class_range_list
block|,
name|dw_val_class_const
block|,
name|dw_val_class_unsigned_const
block|,
name|dw_val_class_long_long
block|,
name|dw_val_class_float
block|,
name|dw_val_class_flag
block|,
name|dw_val_class_die_ref
block|,
name|dw_val_class_fde_ref
block|,
name|dw_val_class_lbl_id
block|,
name|dw_val_class_lbl_offset
block|,
name|dw_val_class_str
block|}
name|dw_val_class
typedef|;
end_typedef

begin_comment
comment|/* Describe a double word constant value.  */
end_comment

begin_comment
comment|/* ??? Every instance of long_long in the code really means CONST_DOUBLE.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_long_long_struct
block|{
name|unsigned
name|long
name|hi
decl_stmt|;
name|unsigned
name|long
name|low
decl_stmt|;
block|}
name|dw_long_long_const
typedef|;
end_typedef

begin_comment
comment|/* Describe a floating point constant value.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_fp_struct
block|{
name|long
modifier|*
name|array
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
block|}
name|dw_float_const
typedef|;
end_typedef

begin_comment
comment|/* The dw_val_node describes an attribute's value, as it is    represented internally.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_val_struct
block|{
name|dw_val_class
name|val_class
decl_stmt|;
union|union
block|{
name|rtx
name|val_addr
decl_stmt|;
name|long
name|unsigned
name|val_offset
decl_stmt|;
name|dw_loc_list_ref
name|val_loc_list
decl_stmt|;
name|dw_loc_descr_ref
name|val_loc
decl_stmt|;
name|long
name|int
name|val_int
decl_stmt|;
name|long
name|unsigned
name|val_unsigned
decl_stmt|;
name|dw_long_long_const
name|val_long_long
decl_stmt|;
name|dw_float_const
name|val_float
decl_stmt|;
struct|struct
block|{
name|dw_die_ref
name|die
decl_stmt|;
name|int
name|external
decl_stmt|;
block|}
name|val_die_ref
struct|;
name|unsigned
name|val_fde_index
decl_stmt|;
name|struct
name|indirect_string_node
modifier|*
name|val_str
decl_stmt|;
name|char
modifier|*
name|val_lbl_id
decl_stmt|;
name|unsigned
name|char
name|val_flag
decl_stmt|;
block|}
name|v
union|;
block|}
name|dw_val_node
typedef|;
end_typedef

begin_comment
comment|/* Locations in memory are described using a sequence of stack machine    operations.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_loc_descr_struct
block|{
name|dw_loc_descr_ref
name|dw_loc_next
decl_stmt|;
name|enum
name|dwarf_location_atom
name|dw_loc_opc
decl_stmt|;
name|dw_val_node
name|dw_loc_oprnd1
decl_stmt|;
name|dw_val_node
name|dw_loc_oprnd2
decl_stmt|;
name|int
name|dw_loc_addr
decl_stmt|;
block|}
name|dw_loc_descr_node
typedef|;
end_typedef

begin_comment
comment|/* Location lists are ranges + location descriptions for that range,    so you can track variables that are in different places over    their entire life.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_loc_list_struct
block|{
name|dw_loc_list_ref
name|dw_loc_next
decl_stmt|;
specifier|const
name|char
modifier|*
name|begin
decl_stmt|;
comment|/* Label for begin address of range */
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Label for end address of range */
name|char
modifier|*
name|ll_symbol
decl_stmt|;
comment|/* Label for beginning of location list. 		      Only on head of list */
specifier|const
name|char
modifier|*
name|section
decl_stmt|;
comment|/* Section this loclist is relative to */
name|dw_loc_descr_ref
name|expr
decl_stmt|;
block|}
name|dw_loc_list_node
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_stack_op_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|new_loc_descr
name|PARAMS
argument_list|(
operator|(
expr|enum
name|dwarf_location_atom
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_loc_descr
name|PARAMS
argument_list|(
operator|(
name|dw_loc_descr_ref
operator|*
operator|,
name|dw_loc_descr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_loc_descr
name|PARAMS
argument_list|(
operator|(
name|dw_loc_descr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_locs
name|PARAMS
argument_list|(
operator|(
name|dw_loc_descr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_loc_operands
name|PARAMS
argument_list|(
operator|(
name|dw_loc_descr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_loc_sequence
name|PARAMS
argument_list|(
operator|(
name|dw_loc_descr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert a DWARF stack opcode into its string name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_stack_op_name
parameter_list|(
name|op
parameter_list|)
name|unsigned
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_addr
case|:
return|return
literal|"DW_OP_addr"
return|;
case|case
name|DW_OP_deref
case|:
return|return
literal|"DW_OP_deref"
return|;
case|case
name|DW_OP_const1u
case|:
return|return
literal|"DW_OP_const1u"
return|;
case|case
name|DW_OP_const1s
case|:
return|return
literal|"DW_OP_const1s"
return|;
case|case
name|DW_OP_const2u
case|:
return|return
literal|"DW_OP_const2u"
return|;
case|case
name|DW_OP_const2s
case|:
return|return
literal|"DW_OP_const2s"
return|;
case|case
name|DW_OP_const4u
case|:
return|return
literal|"DW_OP_const4u"
return|;
case|case
name|DW_OP_const4s
case|:
return|return
literal|"DW_OP_const4s"
return|;
case|case
name|DW_OP_const8u
case|:
return|return
literal|"DW_OP_const8u"
return|;
case|case
name|DW_OP_const8s
case|:
return|return
literal|"DW_OP_const8s"
return|;
case|case
name|DW_OP_constu
case|:
return|return
literal|"DW_OP_constu"
return|;
case|case
name|DW_OP_consts
case|:
return|return
literal|"DW_OP_consts"
return|;
case|case
name|DW_OP_dup
case|:
return|return
literal|"DW_OP_dup"
return|;
case|case
name|DW_OP_drop
case|:
return|return
literal|"DW_OP_drop"
return|;
case|case
name|DW_OP_over
case|:
return|return
literal|"DW_OP_over"
return|;
case|case
name|DW_OP_pick
case|:
return|return
literal|"DW_OP_pick"
return|;
case|case
name|DW_OP_swap
case|:
return|return
literal|"DW_OP_swap"
return|;
case|case
name|DW_OP_rot
case|:
return|return
literal|"DW_OP_rot"
return|;
case|case
name|DW_OP_xderef
case|:
return|return
literal|"DW_OP_xderef"
return|;
case|case
name|DW_OP_abs
case|:
return|return
literal|"DW_OP_abs"
return|;
case|case
name|DW_OP_and
case|:
return|return
literal|"DW_OP_and"
return|;
case|case
name|DW_OP_div
case|:
return|return
literal|"DW_OP_div"
return|;
case|case
name|DW_OP_minus
case|:
return|return
literal|"DW_OP_minus"
return|;
case|case
name|DW_OP_mod
case|:
return|return
literal|"DW_OP_mod"
return|;
case|case
name|DW_OP_mul
case|:
return|return
literal|"DW_OP_mul"
return|;
case|case
name|DW_OP_neg
case|:
return|return
literal|"DW_OP_neg"
return|;
case|case
name|DW_OP_not
case|:
return|return
literal|"DW_OP_not"
return|;
case|case
name|DW_OP_or
case|:
return|return
literal|"DW_OP_or"
return|;
case|case
name|DW_OP_plus
case|:
return|return
literal|"DW_OP_plus"
return|;
case|case
name|DW_OP_plus_uconst
case|:
return|return
literal|"DW_OP_plus_uconst"
return|;
case|case
name|DW_OP_shl
case|:
return|return
literal|"DW_OP_shl"
return|;
case|case
name|DW_OP_shr
case|:
return|return
literal|"DW_OP_shr"
return|;
case|case
name|DW_OP_shra
case|:
return|return
literal|"DW_OP_shra"
return|;
case|case
name|DW_OP_xor
case|:
return|return
literal|"DW_OP_xor"
return|;
case|case
name|DW_OP_bra
case|:
return|return
literal|"DW_OP_bra"
return|;
case|case
name|DW_OP_eq
case|:
return|return
literal|"DW_OP_eq"
return|;
case|case
name|DW_OP_ge
case|:
return|return
literal|"DW_OP_ge"
return|;
case|case
name|DW_OP_gt
case|:
return|return
literal|"DW_OP_gt"
return|;
case|case
name|DW_OP_le
case|:
return|return
literal|"DW_OP_le"
return|;
case|case
name|DW_OP_lt
case|:
return|return
literal|"DW_OP_lt"
return|;
case|case
name|DW_OP_ne
case|:
return|return
literal|"DW_OP_ne"
return|;
case|case
name|DW_OP_skip
case|:
return|return
literal|"DW_OP_skip"
return|;
case|case
name|DW_OP_lit0
case|:
return|return
literal|"DW_OP_lit0"
return|;
case|case
name|DW_OP_lit1
case|:
return|return
literal|"DW_OP_lit1"
return|;
case|case
name|DW_OP_lit2
case|:
return|return
literal|"DW_OP_lit2"
return|;
case|case
name|DW_OP_lit3
case|:
return|return
literal|"DW_OP_lit3"
return|;
case|case
name|DW_OP_lit4
case|:
return|return
literal|"DW_OP_lit4"
return|;
case|case
name|DW_OP_lit5
case|:
return|return
literal|"DW_OP_lit5"
return|;
case|case
name|DW_OP_lit6
case|:
return|return
literal|"DW_OP_lit6"
return|;
case|case
name|DW_OP_lit7
case|:
return|return
literal|"DW_OP_lit7"
return|;
case|case
name|DW_OP_lit8
case|:
return|return
literal|"DW_OP_lit8"
return|;
case|case
name|DW_OP_lit9
case|:
return|return
literal|"DW_OP_lit9"
return|;
case|case
name|DW_OP_lit10
case|:
return|return
literal|"DW_OP_lit10"
return|;
case|case
name|DW_OP_lit11
case|:
return|return
literal|"DW_OP_lit11"
return|;
case|case
name|DW_OP_lit12
case|:
return|return
literal|"DW_OP_lit12"
return|;
case|case
name|DW_OP_lit13
case|:
return|return
literal|"DW_OP_lit13"
return|;
case|case
name|DW_OP_lit14
case|:
return|return
literal|"DW_OP_lit14"
return|;
case|case
name|DW_OP_lit15
case|:
return|return
literal|"DW_OP_lit15"
return|;
case|case
name|DW_OP_lit16
case|:
return|return
literal|"DW_OP_lit16"
return|;
case|case
name|DW_OP_lit17
case|:
return|return
literal|"DW_OP_lit17"
return|;
case|case
name|DW_OP_lit18
case|:
return|return
literal|"DW_OP_lit18"
return|;
case|case
name|DW_OP_lit19
case|:
return|return
literal|"DW_OP_lit19"
return|;
case|case
name|DW_OP_lit20
case|:
return|return
literal|"DW_OP_lit20"
return|;
case|case
name|DW_OP_lit21
case|:
return|return
literal|"DW_OP_lit21"
return|;
case|case
name|DW_OP_lit22
case|:
return|return
literal|"DW_OP_lit22"
return|;
case|case
name|DW_OP_lit23
case|:
return|return
literal|"DW_OP_lit23"
return|;
case|case
name|DW_OP_lit24
case|:
return|return
literal|"DW_OP_lit24"
return|;
case|case
name|DW_OP_lit25
case|:
return|return
literal|"DW_OP_lit25"
return|;
case|case
name|DW_OP_lit26
case|:
return|return
literal|"DW_OP_lit26"
return|;
case|case
name|DW_OP_lit27
case|:
return|return
literal|"DW_OP_lit27"
return|;
case|case
name|DW_OP_lit28
case|:
return|return
literal|"DW_OP_lit28"
return|;
case|case
name|DW_OP_lit29
case|:
return|return
literal|"DW_OP_lit29"
return|;
case|case
name|DW_OP_lit30
case|:
return|return
literal|"DW_OP_lit30"
return|;
case|case
name|DW_OP_lit31
case|:
return|return
literal|"DW_OP_lit31"
return|;
case|case
name|DW_OP_reg0
case|:
return|return
literal|"DW_OP_reg0"
return|;
case|case
name|DW_OP_reg1
case|:
return|return
literal|"DW_OP_reg1"
return|;
case|case
name|DW_OP_reg2
case|:
return|return
literal|"DW_OP_reg2"
return|;
case|case
name|DW_OP_reg3
case|:
return|return
literal|"DW_OP_reg3"
return|;
case|case
name|DW_OP_reg4
case|:
return|return
literal|"DW_OP_reg4"
return|;
case|case
name|DW_OP_reg5
case|:
return|return
literal|"DW_OP_reg5"
return|;
case|case
name|DW_OP_reg6
case|:
return|return
literal|"DW_OP_reg6"
return|;
case|case
name|DW_OP_reg7
case|:
return|return
literal|"DW_OP_reg7"
return|;
case|case
name|DW_OP_reg8
case|:
return|return
literal|"DW_OP_reg8"
return|;
case|case
name|DW_OP_reg9
case|:
return|return
literal|"DW_OP_reg9"
return|;
case|case
name|DW_OP_reg10
case|:
return|return
literal|"DW_OP_reg10"
return|;
case|case
name|DW_OP_reg11
case|:
return|return
literal|"DW_OP_reg11"
return|;
case|case
name|DW_OP_reg12
case|:
return|return
literal|"DW_OP_reg12"
return|;
case|case
name|DW_OP_reg13
case|:
return|return
literal|"DW_OP_reg13"
return|;
case|case
name|DW_OP_reg14
case|:
return|return
literal|"DW_OP_reg14"
return|;
case|case
name|DW_OP_reg15
case|:
return|return
literal|"DW_OP_reg15"
return|;
case|case
name|DW_OP_reg16
case|:
return|return
literal|"DW_OP_reg16"
return|;
case|case
name|DW_OP_reg17
case|:
return|return
literal|"DW_OP_reg17"
return|;
case|case
name|DW_OP_reg18
case|:
return|return
literal|"DW_OP_reg18"
return|;
case|case
name|DW_OP_reg19
case|:
return|return
literal|"DW_OP_reg19"
return|;
case|case
name|DW_OP_reg20
case|:
return|return
literal|"DW_OP_reg20"
return|;
case|case
name|DW_OP_reg21
case|:
return|return
literal|"DW_OP_reg21"
return|;
case|case
name|DW_OP_reg22
case|:
return|return
literal|"DW_OP_reg22"
return|;
case|case
name|DW_OP_reg23
case|:
return|return
literal|"DW_OP_reg23"
return|;
case|case
name|DW_OP_reg24
case|:
return|return
literal|"DW_OP_reg24"
return|;
case|case
name|DW_OP_reg25
case|:
return|return
literal|"DW_OP_reg25"
return|;
case|case
name|DW_OP_reg26
case|:
return|return
literal|"DW_OP_reg26"
return|;
case|case
name|DW_OP_reg27
case|:
return|return
literal|"DW_OP_reg27"
return|;
case|case
name|DW_OP_reg28
case|:
return|return
literal|"DW_OP_reg28"
return|;
case|case
name|DW_OP_reg29
case|:
return|return
literal|"DW_OP_reg29"
return|;
case|case
name|DW_OP_reg30
case|:
return|return
literal|"DW_OP_reg30"
return|;
case|case
name|DW_OP_reg31
case|:
return|return
literal|"DW_OP_reg31"
return|;
case|case
name|DW_OP_breg0
case|:
return|return
literal|"DW_OP_breg0"
return|;
case|case
name|DW_OP_breg1
case|:
return|return
literal|"DW_OP_breg1"
return|;
case|case
name|DW_OP_breg2
case|:
return|return
literal|"DW_OP_breg2"
return|;
case|case
name|DW_OP_breg3
case|:
return|return
literal|"DW_OP_breg3"
return|;
case|case
name|DW_OP_breg4
case|:
return|return
literal|"DW_OP_breg4"
return|;
case|case
name|DW_OP_breg5
case|:
return|return
literal|"DW_OP_breg5"
return|;
case|case
name|DW_OP_breg6
case|:
return|return
literal|"DW_OP_breg6"
return|;
case|case
name|DW_OP_breg7
case|:
return|return
literal|"DW_OP_breg7"
return|;
case|case
name|DW_OP_breg8
case|:
return|return
literal|"DW_OP_breg8"
return|;
case|case
name|DW_OP_breg9
case|:
return|return
literal|"DW_OP_breg9"
return|;
case|case
name|DW_OP_breg10
case|:
return|return
literal|"DW_OP_breg10"
return|;
case|case
name|DW_OP_breg11
case|:
return|return
literal|"DW_OP_breg11"
return|;
case|case
name|DW_OP_breg12
case|:
return|return
literal|"DW_OP_breg12"
return|;
case|case
name|DW_OP_breg13
case|:
return|return
literal|"DW_OP_breg13"
return|;
case|case
name|DW_OP_breg14
case|:
return|return
literal|"DW_OP_breg14"
return|;
case|case
name|DW_OP_breg15
case|:
return|return
literal|"DW_OP_breg15"
return|;
case|case
name|DW_OP_breg16
case|:
return|return
literal|"DW_OP_breg16"
return|;
case|case
name|DW_OP_breg17
case|:
return|return
literal|"DW_OP_breg17"
return|;
case|case
name|DW_OP_breg18
case|:
return|return
literal|"DW_OP_breg18"
return|;
case|case
name|DW_OP_breg19
case|:
return|return
literal|"DW_OP_breg19"
return|;
case|case
name|DW_OP_breg20
case|:
return|return
literal|"DW_OP_breg20"
return|;
case|case
name|DW_OP_breg21
case|:
return|return
literal|"DW_OP_breg21"
return|;
case|case
name|DW_OP_breg22
case|:
return|return
literal|"DW_OP_breg22"
return|;
case|case
name|DW_OP_breg23
case|:
return|return
literal|"DW_OP_breg23"
return|;
case|case
name|DW_OP_breg24
case|:
return|return
literal|"DW_OP_breg24"
return|;
case|case
name|DW_OP_breg25
case|:
return|return
literal|"DW_OP_breg25"
return|;
case|case
name|DW_OP_breg26
case|:
return|return
literal|"DW_OP_breg26"
return|;
case|case
name|DW_OP_breg27
case|:
return|return
literal|"DW_OP_breg27"
return|;
case|case
name|DW_OP_breg28
case|:
return|return
literal|"DW_OP_breg28"
return|;
case|case
name|DW_OP_breg29
case|:
return|return
literal|"DW_OP_breg29"
return|;
case|case
name|DW_OP_breg30
case|:
return|return
literal|"DW_OP_breg30"
return|;
case|case
name|DW_OP_breg31
case|:
return|return
literal|"DW_OP_breg31"
return|;
case|case
name|DW_OP_regx
case|:
return|return
literal|"DW_OP_regx"
return|;
case|case
name|DW_OP_fbreg
case|:
return|return
literal|"DW_OP_fbreg"
return|;
case|case
name|DW_OP_bregx
case|:
return|return
literal|"DW_OP_bregx"
return|;
case|case
name|DW_OP_piece
case|:
return|return
literal|"DW_OP_piece"
return|;
case|case
name|DW_OP_deref_size
case|:
return|return
literal|"DW_OP_deref_size"
return|;
case|case
name|DW_OP_xderef_size
case|:
return|return
literal|"DW_OP_xderef_size"
return|;
case|case
name|DW_OP_nop
case|:
return|return
literal|"DW_OP_nop"
return|;
default|default:
return|return
literal|"OP_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to a newly allocated location description.  Location    descriptions are simple expression terms that can be strung    together to form more complicated location (address) descriptions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_loc_descr_ref
name|new_loc_descr
parameter_list|(
name|op
parameter_list|,
name|oprnd1
parameter_list|,
name|oprnd2
parameter_list|)
name|enum
name|dwarf_location_atom
name|op
decl_stmt|;
name|unsigned
name|long
name|oprnd1
decl_stmt|;
name|unsigned
name|long
name|oprnd2
decl_stmt|;
block|{
comment|/* Use xcalloc here so we clear out all of the long_long constant in      the union.  */
name|dw_loc_descr_ref
name|descr
init|=
operator|(
name|dw_loc_descr_ref
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|dw_loc_descr_node
argument_list|)
argument_list|)
decl_stmt|;
name|descr
operator|->
name|dw_loc_opc
operator|=
name|op
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_unsigned_const
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
operator|=
name|oprnd1
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd2
operator|.
name|val_class
operator|=
name|dw_val_class_unsigned_const
expr_stmt|;
name|descr
operator|->
name|dw_loc_oprnd2
operator|.
name|v
operator|.
name|val_unsigned
operator|=
name|oprnd2
expr_stmt|;
return|return
name|descr
return|;
block|}
end_function

begin_comment
comment|/* Add a location description term to a location description expression.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_loc_descr
parameter_list|(
name|list_head
parameter_list|,
name|descr
parameter_list|)
name|dw_loc_descr_ref
modifier|*
name|list_head
decl_stmt|;
name|dw_loc_descr_ref
name|descr
decl_stmt|;
block|{
name|dw_loc_descr_ref
modifier|*
name|d
decl_stmt|;
comment|/* Find the end of the chain.  */
for|for
control|(
name|d
operator|=
name|list_head
init|;
operator|(
operator|*
name|d
operator|)
operator|!=
name|NULL
condition|;
name|d
operator|=
operator|&
operator|(
operator|*
name|d
operator|)
operator|->
name|dw_loc_next
control|)
empty_stmt|;
operator|*
name|d
operator|=
name|descr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the size of a location descriptor.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_loc_descr
parameter_list|(
name|loc
parameter_list|)
name|dw_loc_descr_ref
name|loc
decl_stmt|;
block|{
name|unsigned
name|long
name|size
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|loc
operator|->
name|dw_loc_opc
condition|)
block|{
case|case
name|DW_OP_addr
case|:
name|size
operator|+=
name|DWARF2_ADDR_SIZE
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
case|case
name|DW_OP_const1s
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
case|case
name|DW_OP_const2s
case|:
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
case|case
name|DW_OP_const4s
case|:
name|size
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
case|case
name|DW_OP_const8s
case|:
name|size
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_pick
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_skip
case|:
case|case
name|DW_OP_bra
case|:
name|size
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_fbreg
case|:
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd2
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_piece
case|:
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_deref_size
case|:
case|case
name|DW_OP_xderef_size
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a series of location descriptors.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_locs
parameter_list|(
name|loc
parameter_list|)
name|dw_loc_descr_ref
name|loc
decl_stmt|;
block|{
name|unsigned
name|long
name|size
decl_stmt|;
for|for
control|(
name|size
operator|=
literal|0
init|;
name|loc
operator|!=
name|NULL
condition|;
name|loc
operator|=
name|loc
operator|->
name|dw_loc_next
control|)
block|{
name|loc
operator|->
name|dw_loc_addr
operator|=
name|size
expr_stmt|;
name|size
operator|+=
name|size_of_loc_descr
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Output location description stack opcode's operands (if any).  */
end_comment

begin_function
specifier|static
name|void
name|output_loc_operands
parameter_list|(
name|loc
parameter_list|)
name|dw_loc_descr_ref
name|loc
decl_stmt|;
block|{
name|dw_val_ref
name|val1
init|=
operator|&
name|loc
operator|->
name|dw_loc_oprnd1
decl_stmt|;
name|dw_val_ref
name|val2
init|=
operator|&
name|loc
operator|->
name|dw_loc_oprnd2
decl_stmt|;
switch|switch
condition|(
name|loc
operator|->
name|dw_loc_opc
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
case|case
name|DW_OP_addr
case|:
name|dw2_asm_output_addr_rtx
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
case|case
name|DW_OP_const2s
case|:
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
case|case
name|DW_OP_const4s
case|:
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
case|case
name|DW_OP_const8s
case|:
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|<
literal|64
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|8
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_skip
case|:
case|case
name|DW_OP_bra
case|:
block|{
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|val1
operator|->
name|val_class
operator|==
name|dw_val_class_loc
condition|)
name|offset
operator|=
name|val1
operator|->
name|v
operator|.
name|val_loc
operator|->
name|dw_loc_addr
operator|-
operator|(
name|loc
operator|->
name|dw_loc_addr
operator|+
literal|3
operator|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
else|#
directive|else
case|case
name|DW_OP_addr
case|:
case|case
name|DW_OP_const2u
case|:
case|case
name|DW_OP_const2s
case|:
case|case
name|DW_OP_const4u
case|:
case|case
name|DW_OP_const4s
case|:
case|case
name|DW_OP_const8u
case|:
case|case
name|DW_OP_const8s
case|:
case|case
name|DW_OP_skip
case|:
case|case
name|DW_OP_bra
case|:
comment|/* We currently don't make any attempt to make sure these are          aligned properly like we do for the main unwind info, so          don't support emitting things larger than a byte if we're          only doing unwinding.  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
case|case
name|DW_OP_const1u
case|:
case|case
name|DW_OP_const1s
case|:
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|dw2_asm_output_data_sleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_pick
case|:
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|dw2_asm_output_data_sleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_fbreg
case|:
name|dw2_asm_output_data_sleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_sleb128
argument_list|(
name|val2
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_piece
case|:
name|dw2_asm_output_data_uleb128
argument_list|(
name|val1
operator|->
name|v
operator|.
name|val_unsigned
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_deref_size
case|:
case|case
name|DW_OP_xderef_size
case|:
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|val1
operator|->
name|v
operator|.
name|val_int
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Other codes have no operands.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Output a sequence of location operations.  */
end_comment

begin_function
specifier|static
name|void
name|output_loc_sequence
parameter_list|(
name|loc
parameter_list|)
name|dw_loc_descr_ref
name|loc
decl_stmt|;
block|{
for|for
control|(
init|;
name|loc
operator|!=
name|NULL
condition|;
name|loc
operator|=
name|loc
operator|->
name|dw_loc_next
control|)
block|{
comment|/* Output the opcode.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|loc
operator|->
name|dw_loc_opc
argument_list|,
literal|"%s"
argument_list|,
name|dwarf_stack_op_name
argument_list|(
name|loc
operator|->
name|dw_loc_opc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the operand(s) (if any).  */
name|output_loc_operands
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine will generate the correct assembly data for a location    description based on a cfi entry with a complex address.  */
end_comment

begin_function
specifier|static
name|void
name|output_cfa_loc
parameter_list|(
name|cfi
parameter_list|)
name|dw_cfi_ref
name|cfi
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|loc
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* Output the size of the block.  */
name|loc
operator|=
name|cfi
operator|->
name|dw_cfi_oprnd1
operator|.
name|dw_cfi_loc
expr_stmt|;
name|size
operator|=
name|size_of_locs
argument_list|(
name|loc
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now output the operations themselves.  */
name|output_loc_sequence
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function builds a dwarf location descriptor sequence from    a dw_cfa_location.  */
end_comment

begin_function
specifier|static
name|struct
name|dw_loc_descr_struct
modifier|*
name|build_cfa_loc
parameter_list|(
name|cfa
parameter_list|)
name|dw_cfa_location
modifier|*
name|cfa
decl_stmt|;
block|{
name|struct
name|dw_loc_descr_struct
modifier|*
name|head
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|cfa
operator|->
name|indirect
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|cfa
operator|->
name|base_offset
condition|)
block|{
if|if
condition|(
name|cfa
operator|->
name|reg
operator|<=
literal|31
condition|)
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_breg0
operator|+
name|cfa
operator|->
name|reg
argument_list|,
name|cfa
operator|->
name|base_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_bregx
argument_list|,
name|cfa
operator|->
name|reg
argument_list|,
name|cfa
operator|->
name|base_offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cfa
operator|->
name|reg
operator|<=
literal|31
condition|)
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_reg0
operator|+
name|cfa
operator|->
name|reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|head
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_regx
argument_list|,
name|cfa
operator|->
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|head
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_const
expr_stmt|;
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_deref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|head
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfa
operator|->
name|offset
operator|!=
literal|0
condition|)
block|{
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_plus_uconst
argument_list|,
name|cfa
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|head
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* This function fills in aa dw_cfa_location structure from a dwarf location    descriptor sequence.  */
end_comment

begin_function
specifier|static
name|void
name|get_cfa_from_loc_descr
parameter_list|(
name|cfa
parameter_list|,
name|loc
parameter_list|)
name|dw_cfa_location
modifier|*
name|cfa
decl_stmt|;
name|struct
name|dw_loc_descr_struct
modifier|*
name|loc
decl_stmt|;
block|{
name|struct
name|dw_loc_descr_struct
modifier|*
name|ptr
decl_stmt|;
name|cfa
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|cfa
operator|->
name|base_offset
operator|=
literal|0
expr_stmt|;
name|cfa
operator|->
name|indirect
operator|=
literal|0
expr_stmt|;
name|cfa
operator|->
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|loc
init|;
name|ptr
operator|!=
name|NULL
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|dw_loc_next
control|)
block|{
name|enum
name|dwarf_location_atom
name|op
init|=
name|ptr
operator|->
name|dw_loc_opc
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_reg0
case|:
case|case
name|DW_OP_reg1
case|:
case|case
name|DW_OP_reg2
case|:
case|case
name|DW_OP_reg3
case|:
case|case
name|DW_OP_reg4
case|:
case|case
name|DW_OP_reg5
case|:
case|case
name|DW_OP_reg6
case|:
case|case
name|DW_OP_reg7
case|:
case|case
name|DW_OP_reg8
case|:
case|case
name|DW_OP_reg9
case|:
case|case
name|DW_OP_reg10
case|:
case|case
name|DW_OP_reg11
case|:
case|case
name|DW_OP_reg12
case|:
case|case
name|DW_OP_reg13
case|:
case|case
name|DW_OP_reg14
case|:
case|case
name|DW_OP_reg15
case|:
case|case
name|DW_OP_reg16
case|:
case|case
name|DW_OP_reg17
case|:
case|case
name|DW_OP_reg18
case|:
case|case
name|DW_OP_reg19
case|:
case|case
name|DW_OP_reg20
case|:
case|case
name|DW_OP_reg21
case|:
case|case
name|DW_OP_reg22
case|:
case|case
name|DW_OP_reg23
case|:
case|case
name|DW_OP_reg24
case|:
case|case
name|DW_OP_reg25
case|:
case|case
name|DW_OP_reg26
case|:
case|case
name|DW_OP_reg27
case|:
case|case
name|DW_OP_reg28
case|:
case|case
name|DW_OP_reg29
case|:
case|case
name|DW_OP_reg30
case|:
case|case
name|DW_OP_reg31
case|:
name|cfa
operator|->
name|reg
operator|=
name|op
operator|-
name|DW_OP_reg0
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|cfa
operator|->
name|reg
operator|=
name|ptr
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|cfa
operator|->
name|reg
operator|=
name|op
operator|-
name|DW_OP_breg0
expr_stmt|;
name|cfa
operator|->
name|base_offset
operator|=
name|ptr
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|cfa
operator|->
name|reg
operator|=
name|ptr
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_int
expr_stmt|;
name|cfa
operator|->
name|base_offset
operator|=
name|ptr
operator|->
name|dw_loc_oprnd2
operator|.
name|v
operator|.
name|val_int
expr_stmt|;
break|break;
case|case
name|DW_OP_deref
case|:
name|cfa
operator|->
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|cfa
operator|->
name|offset
operator|=
name|ptr
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_unsigned
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
literal|"DW_LOC_OP %s not implemented\n"
argument_list|,
name|dwarf_stack_op_name
argument_list|(
name|ptr
operator|->
name|dw_loc_opc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* .debug_frame support */
end_comment

begin_escape
end_escape

begin_comment
comment|/* And now, the support for symbolic debugging information.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DWARF2_DEBUGGING_INFO
end_ifdef

begin_comment
comment|/* .debug_str support.  */
end_comment

begin_decl_stmt
specifier|static
name|hashnode
name|indirect_string_alloc
name|PARAMS
argument_list|(
operator|(
name|hash_table
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_indirect_string
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cpp_reader
operator|*
operator|,
name|hashnode
operator|,
specifier|const
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_init
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_finish
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_define
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_undef
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_start_source_file
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_end_source_file
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_begin_block
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_end_block
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|dwarf2out_ignore_block
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_global_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2out_abstract_function
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The debug hooks structure.  */
end_comment

begin_decl_stmt
name|struct
name|gcc_debug_hooks
name|dwarf2_debug_hooks
init|=
block|{
name|dwarf2out_init
block|,
name|dwarf2out_finish
block|,
name|dwarf2out_define
block|,
name|dwarf2out_undef
block|,
name|dwarf2out_start_source_file
block|,
name|dwarf2out_end_source_file
block|,
name|dwarf2out_begin_block
block|,
name|dwarf2out_end_block
block|,
name|dwarf2out_ignore_block
block|,
name|dwarf2out_source_line
block|,
name|dwarf2out_begin_prologue
block|,
name|debug_nothing_int
block|,
comment|/* end_prologue */
name|dwarf2out_end_epilogue
block|,
name|debug_nothing_tree
block|,
comment|/* begin_function */
name|debug_nothing_int
block|,
comment|/* end_function */
name|dwarf2out_decl
block|,
comment|/* function_decl */
name|dwarf2out_global_decl
block|,
name|debug_nothing_tree
block|,
comment|/* deferred_inline_function */
comment|/* The DWARF 2 backend tries to reduce debugging bloat by not      emitting the abstract description of inline functions until      something tries to reference them.  */
name|dwarf2out_abstract_function
block|,
comment|/* outlining_inline_function */
name|debug_nothing_rtx
comment|/* label */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* NOTE: In the comments in this file, many references are made to    "Debugging Information Entries".  This term is abbreviated as `DIE'    throughout the remainder of this file.  */
end_comment

begin_comment
comment|/* An internal representation of the DWARF output is built, and then    walked to generate the DWARF debugging info.  The walk of the internal    representation is done after the entire program has been compiled.    The types below are used to describe the internal representation.  */
end_comment

begin_comment
comment|/* Various DIE's use offsets relative to the beginning of the    .debug_info section to refer to each other.  */
end_comment

begin_typedef
typedef|typedef
name|long
name|int
name|dw_offset
typedef|;
end_typedef

begin_comment
comment|/* Define typedefs here to avoid circular dependencies.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|dw_attr_struct
modifier|*
name|dw_attr_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_line_info_struct
modifier|*
name|dw_line_info_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_separate_line_info_struct
modifier|*
name|dw_separate_line_info_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|pubname_struct
modifier|*
name|pubname_ref
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|dw_ranges_struct
modifier|*
name|dw_ranges_ref
typedef|;
end_typedef

begin_comment
comment|/* Each entry in the line_info_table maintains the file and    line number associated with the label generated for that    entry.  The label gives the PC value associated with    the line number entry.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_line_info_struct
block|{
name|unsigned
name|long
name|dw_file_num
decl_stmt|;
name|unsigned
name|long
name|dw_line_num
decl_stmt|;
block|}
name|dw_line_info_entry
typedef|;
end_typedef

begin_comment
comment|/* Line information for functions in separate sections; each one gets its    own sequence.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_separate_line_info_struct
block|{
name|unsigned
name|long
name|dw_file_num
decl_stmt|;
name|unsigned
name|long
name|dw_line_num
decl_stmt|;
name|unsigned
name|long
name|function
decl_stmt|;
block|}
name|dw_separate_line_info_entry
typedef|;
end_typedef

begin_comment
comment|/* Each DIE attribute has a field specifying the attribute kind,    a link to the next attribute in the chain, and an attribute value.    Attributes are typically linked below the DIE they modify.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dw_attr_struct
block|{
name|enum
name|dwarf_attribute
name|dw_attr
decl_stmt|;
name|dw_attr_ref
name|dw_attr_next
decl_stmt|;
name|dw_val_node
name|dw_attr_val
decl_stmt|;
block|}
name|dw_attr_node
typedef|;
end_typedef

begin_comment
comment|/* The Debugging Information Entry (DIE) structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|die_struct
block|{
name|enum
name|dwarf_tag
name|die_tag
decl_stmt|;
name|char
modifier|*
name|die_symbol
decl_stmt|;
name|dw_attr_ref
name|die_attr
decl_stmt|;
name|dw_die_ref
name|die_parent
decl_stmt|;
name|dw_die_ref
name|die_child
decl_stmt|;
name|dw_die_ref
name|die_sib
decl_stmt|;
name|dw_offset
name|die_offset
decl_stmt|;
name|unsigned
name|long
name|die_abbrev
decl_stmt|;
name|int
name|die_mark
decl_stmt|;
block|}
name|die_node
typedef|;
end_typedef

begin_comment
comment|/* The pubname structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pubname_struct
block|{
name|dw_die_ref
name|die
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|pubname_entry
typedef|;
end_typedef

begin_struct
struct|struct
name|dw_ranges_struct
block|{
name|int
name|block_num
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The limbo die list structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|limbo_die_struct
block|{
name|dw_die_ref
name|die
decl_stmt|;
name|tree
name|created_for
decl_stmt|;
name|struct
name|limbo_die_struct
modifier|*
name|next
decl_stmt|;
block|}
name|limbo_die_node
typedef|;
end_typedef

begin_comment
comment|/* How to start an assembler comment.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_COMMENT_START
end_ifndef

begin_define
define|#
directive|define
name|ASM_COMMENT_START
value|";#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define a macro which returns non-zero for a TYPE_DECL which was    implicitly generated for a tagged type.     Note that unlike the gcc front end (which generates a NULL named    TYPE_DECL node for each complete tagged type, each array type, and    each function type node created) the g++ front end generates a    _named_ TYPE_DECL node for each tagged type node created.    These TYPE_DECLs have DECL_ARTIFICIAL set, so we know not to    generate a DW_TAG_typedef DIE for them.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_DECL_IS_STUB
parameter_list|(
name|decl
parameter_list|)
define|\
value|(DECL_NAME (decl) == NULL_TREE			\    || (DECL_ARTIFICIAL (decl)				\&& is_tagged_type (TREE_TYPE (decl))		\&& ((decl == TYPE_STUB_DECL (TREE_TYPE (decl)))	\
comment|/* This is necessary for stub decls that	\ 	      appear in nested inline functions.  */
value|\ 	   || (DECL_ABSTRACT_ORIGIN (decl) != NULL_TREE	\&& (decl_ultimate_origin (decl)		\ 		   == TYPE_STUB_DECL (TREE_TYPE (decl)))))))
end_define

begin_comment
comment|/* Information concerning the compilation unit's programming    language, and compiler version.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|flag_traditional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fixed size portion of the DWARF compilation unit header.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_COMPILE_UNIT_HEADER_SIZE
value|(2 * DWARF_OFFSET_SIZE + 3)
end_define

begin_comment
comment|/* Fixed size portion of debugging line information prolog.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_PROLOG_HEADER_SIZE
value|5
end_define

begin_comment
comment|/* Fixed size portion of public names info.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_PUBNAMES_HEADER_SIZE
value|(2 * DWARF_OFFSET_SIZE + 2)
end_define

begin_comment
comment|/* Fixed size portion of the address range info.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_ARANGES_HEADER_SIZE
define|\
value|(DWARF_ROUND (2 * DWARF_OFFSET_SIZE + 4, DWARF2_ADDR_SIZE * 2)	\    - DWARF_OFFSET_SIZE)
end_define

begin_comment
comment|/* Size of padding portion in the address range info.  It must be    aligned to twice the pointer size.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_ARANGES_PAD_SIZE
define|\
value|(DWARF_ROUND (2 * DWARF_OFFSET_SIZE + 4, DWARF2_ADDR_SIZE * 2) \    - (2 * DWARF_OFFSET_SIZE + 4))
end_define

begin_comment
comment|/* Use assembler line directives if available.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF2_ASM_LINE_DEBUG_INFO
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_AS_DWARF2_DEBUG_LINE
end_ifdef

begin_define
define|#
directive|define
name|DWARF2_ASM_LINE_DEBUG_INFO
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DWARF2_ASM_LINE_DEBUG_INFO
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define the architecture-dependent minimum instruction length (in bytes).    In this implementation of DWARF, this field is used for information    purposes only.  Since GCC generates assembly language, we have    no a priori knowledge of how many instruction bytes are generated    for each source line, and therefore can use only the  DW_LNE_set_address    and DW_LNS_fixed_advance_pc line information commands.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_LINE_MIN_INSTR_LENGTH
end_ifndef

begin_define
define|#
directive|define
name|DWARF_LINE_MIN_INSTR_LENGTH
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Minimum line offset in a special line info. opcode.    This value was chosen to give a reasonable range of values.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_BASE
value|-10
end_define

begin_comment
comment|/* First special line opcode - leave room for the standard opcodes.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_OPCODE_BASE
value|10
end_define

begin_comment
comment|/* Range of line offsets in a special line info. opcode.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_RANGE
value|(254-DWARF_LINE_OPCODE_BASE+1)
end_define

begin_comment
comment|/* Flag that indicates the initial value of the is_stmt_start flag.    In the present implementation, we do not mark any lines as    the beginning of a source statement, because that information    is not made available by the GCC front-end.  */
end_comment

begin_define
define|#
directive|define
name|DWARF_LINE_DEFAULT_IS_STMT_START
value|1
end_define

begin_comment
comment|/* This location is used by calc_die_sizes() to keep track    the offset of each DIE within the .debug_info section.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|next_die_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the root of the DIE's built for the current compilation unit.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_die_ref
name|comp_unit_die
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of DIEs with a NULL parent waiting to be relocated.  */
end_comment

begin_decl_stmt
specifier|static
name|limbo_die_node
modifier|*
name|limbo_die_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure used by lookup_filename to manage sets of filenames.  */
end_comment

begin_struct
struct|struct
name|file_table
block|{
name|char
modifier|*
modifier|*
name|table
decl_stmt|;
name|unsigned
name|allocated
decl_stmt|;
name|unsigned
name|in_use
decl_stmt|;
name|unsigned
name|last_lookup_index
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Size (in elements) of increments by which we may expand the filename    table.  */
end_comment

begin_define
define|#
directive|define
name|FILE_TABLE_INCREMENT
value|64
end_define

begin_comment
comment|/* Filenames referenced by this compilation unit.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_table
name|file_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local pointer to the name of the main input file.  Initialized in    dwarf2out_init.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|primary_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the base of a table of references to DIE's that describe    declarations.  The table is indexed by DECL_UID() which is a unique    number identifying each decl.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_die_ref
modifier|*
name|decl_die_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for the decl_die_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|decl_die_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in decl_die_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|decl_die_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    decl_die_table.  */
end_comment

begin_define
define|#
directive|define
name|DECL_DIE_TABLE_INCREMENT
value|256
end_define

begin_comment
comment|/* A pointer to the base of a table of references to declaration    scopes.  This table is a display which tracks the nesting    of declaration scopes at the current scope and containing    scopes.  This table is used to find the proper place to    define type declaration DIE's.  */
end_comment

begin_decl_stmt
name|varray_type
name|decl_scope_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the base of a list of references to DIE's that    are uniquely identified by their tag, presence/absence of    children DIE's, and list of attribute/value pairs.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_die_ref
modifier|*
name|abbrev_die_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for abbrev_die_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|abbrev_die_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in type_die_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|abbrev_die_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    abbrev_die_table.  */
end_comment

begin_define
define|#
directive|define
name|ABBREV_DIE_TABLE_INCREMENT
value|256
end_define

begin_comment
comment|/* A pointer to the base of a table that contains line information    for each source code line in .text in the compilation unit.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_line_info_ref
name|line_info_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for line_info_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|line_info_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in separate_line_info_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|separate_line_info_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the base of a table that contains line information    for each source code line outside of .text in the compilation unit.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_separate_line_info_ref
name|separate_line_info_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for separate_line_info_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|separate_line_info_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in line_info_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|line_info_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    line_info_table.  */
end_comment

begin_define
define|#
directive|define
name|LINE_INFO_TABLE_INCREMENT
value|1024
end_define

begin_comment
comment|/* A pointer to the base of a table that contains a list of publicly    accessible names.  */
end_comment

begin_decl_stmt
specifier|static
name|pubname_ref
name|pubname_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for pubname_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pubname_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in pubname_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pubname_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    pubname_table.  */
end_comment

begin_define
define|#
directive|define
name|PUBNAME_TABLE_INCREMENT
value|64
end_define

begin_comment
comment|/* Array of dies for which we should generate .debug_arange info.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_die_ref
modifier|*
name|arange_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for arange_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|arange_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in arange_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|arange_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    arange_table.  */
end_comment

begin_define
define|#
directive|define
name|ARANGE_TABLE_INCREMENT
value|64
end_define

begin_comment
comment|/* Array of dies for which we should generate .debug_ranges info.  */
end_comment

begin_decl_stmt
specifier|static
name|dw_ranges_ref
name|ranges_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements currently allocated for ranges_table.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ranges_table_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in ranges_table currently in use.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ranges_table_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size (in elements) of increments by which we may expand the    ranges_table.  */
end_comment

begin_define
define|#
directive|define
name|RANGES_TABLE_INCREMENT
value|64
end_define

begin_comment
comment|/* Whether we have location lists that need outputting */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|have_location_lists
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A pointer to the base of a list of incomplete types which might be    completed at some later time.  incomplete_types_list needs to be a VARRAY    because we want to tell the garbage collector about it.  */
end_comment

begin_decl_stmt
name|varray_type
name|incomplete_types
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record whether the function being analyzed contains inlined functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_function_has_inlines
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|MIPS_DEBUGGING_INFO
argument_list|)
end_if

begin_endif
unit|static int comp_unit_has_inlines;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Array of RTXes referenced by the debugging information, which therefore    must be kept around forever.  This is a GC root.  */
end_comment

begin_decl_stmt
specifier|static
name|varray_type
name|used_rtx_varray
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations for functions defined in this file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|is_pseudo_reg
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|type_main_variant
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_tagged_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_tag_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_attr_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_form_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char *dwarf_type_encoding_name PARAMS ((unsigned));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|tree
name|decl_ultimate_origin
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|block_ultimate_origin
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|decl_class_context
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_dwarf_attr
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|dw_val_class
name|AT_class
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_flag
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|unsigned
name|AT_flag
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_int
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|long
name|int
name|AT_int
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_unsigned
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|unsigned
name|long
name|AT_unsigned
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_long_long
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
name|long
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_float
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
operator|,
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_string
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|AT_string
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|AT_string_form
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_die_ref
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|dw_die_ref
name|AT_ref
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|AT_ref_external
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|set_AT_ref_external
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_fde_ref
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_loc
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|dw_loc_descr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|dw_loc_descr_ref
name|AT_loc
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_loc_list
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|dw_loc_list_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|dw_loc_list_ref
name|AT_loc_list
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_addr
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|rtx
name|AT_addr
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_lbl_id
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_lbl_offset
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_offset
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_range_list
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|unsigned
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|AT_lbl
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_attr_ref
name|get_AT
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_AT_low_pc
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_AT_hi_pc
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|get_AT_string
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_AT_flag
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|get_AT_unsigned
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|dw_die_ref
name|get_AT_ref
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_c_family
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_cxx
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_java
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_fortran
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_AT
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|free_die
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_children
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_child_die
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|new_die
name|PARAMS
argument_list|(
operator|(
expr|enum
name|dwarf_tag
operator|,
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|lookup_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|equate_type_number_to_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|lookup_decl_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|equate_decl_number_to_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_spaces
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_die
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_dwarf_line_table
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reverse_die_lists
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reverse_all_dies
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|push_new_compile_unit
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|pop_compile_unit
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|loc_checksum
name|PARAMS
argument_list|(
operator|(
name|dw_loc_descr_ref
operator|,
expr|struct
name|md5_ctx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|attr_checksum
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|,
expr|struct
name|md5_ctx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|die_checksum
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|struct
name|md5_ctx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_section_prefix
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_type_die
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_comdat_die
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_symbol_die
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|assign_symbol_names
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|break_out_includes
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_sibling_attributes
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|build_abbrev_table
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_location_lists
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|constant_size
name|PARAMS
argument_list|(
operator|(
name|long
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_die
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|calc_die_sizes
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_dies
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unmark_dies
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_pubnames
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|size_of_aranges
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|dwarf_form
name|value_format
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_value_format
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_abbrev_section
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_die_symbol
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_die
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_compilation_unit_header
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_comp_unit
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dwarf2_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_pubname
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_pubnames
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_arange
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_aranges
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|add_ranges
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_ranges
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_line_info
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_file_names
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|base_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|root_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_base_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|modified_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|type_is_enum
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|reg_number
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|reg_loc_descriptor
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|int_loc_descriptor
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|based_loc_descr
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_based_loc
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|mem_loc_descriptor
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
expr|enum
name|machine_mode
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|concat_loc_descriptor
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|loc_descriptor
name|PARAMS
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_descr_ref
name|loc_descriptor_from_tree
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|ceiling
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|field_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|simple_type_align_in_bits
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|simple_decl_align_in_bits
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|simple_type_size_in_bits
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HOST_WIDE_INT
name|field_byte_offset
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_AT_location_description
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_data_member_location_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_const_value_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|rtl_for_decl_location
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_location_or_const_value_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tree_add_const_value_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_name_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_bound_info
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
expr|enum
name|dwarf_attribute
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_subscript_info
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_byte_size_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_bit_offset_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_bit_size_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_prototyped_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_abstract_origin_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_pure_or_virtual_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_src_coords_attributes
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_name_and_src_coords_attributes
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|push_decl_scope
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pop_decl_scope
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|scope_die_for
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|local_scope_p
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|class_scope_p
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_type_attribute
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|tree
operator|,
name|int
operator|,
name|int
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|type_tag
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tree
name|member_declared_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char *decl_start_label	PARAMS ((tree));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|gen_array_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_set_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void gen_entry_point_die		PARAMS ((tree, dw_die_ref));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|gen_inlined_enumeration_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_inlined_structure_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_inlined_union_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_enumeration_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|gen_formal_parameter_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_unspecified_parameters_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_formal_types_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_subprogram_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_variable_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_label_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_lexical_block_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_inlined_subroutine_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_field_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_ptr_to_mbr_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_die_ref
name|gen_compile_unit_die
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_string_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_inheritance_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_member_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_struct_or_union_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_subroutine_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_typedef_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_type_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_tagged_type_instantiation_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_block_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decls_for_scope
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_redundant_typedef
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_decl_die
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|lookup_filename
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_file_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|retry_incomplete_types
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gen_type_die_for_member
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|splice_child_die
name|PARAMS
argument_list|(
operator|(
name|dw_die_ref
operator|,
name|dw_die_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|file_info_cmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dw_loc_list_ref
name|new_loc_list
name|PARAMS
argument_list|(
operator|(
name|dw_loc_descr_ref
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_loc_descr_to_loc_list
name|PARAMS
argument_list|(
operator|(
name|dw_loc_list_ref
operator|*
operator|,
name|dw_loc_descr_ref
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_loc_list
name|PARAMS
argument_list|(
operator|(
name|dw_loc_list_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gen_internal_sym
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_limbo_die_list
name|PARAMS
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Section names used to hold DWARF debugging information.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_INFO_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_INFO_SECTION
value|".debug_info"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_ABBREV_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_ABBREV_SECTION
value|".debug_abbrev"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_ARANGES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_ARANGES_SECTION
value|".debug_aranges"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_MACINFO_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_MACINFO_SECTION
value|".debug_macinfo"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_LINE_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_LINE_SECTION
value|".debug_line"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_LOC_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_LOC_SECTION
value|".debug_loc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_PUBNAMES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_PUBNAMES_SECTION
value|".debug_pubnames"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_STR_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_STR_SECTION
value|".debug_str"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_RANGES_SECTION
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_RANGES_SECTION
value|".debug_ranges"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Standard ELF section names for compiled code and data.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_SECTION_NAME
end_ifndef

begin_define
define|#
directive|define
name|TEXT_SECTION_NAME
value|".text"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Section flags for .debug_str section.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GAS_SHF_MERGE
end_ifdef

begin_define
define|#
directive|define
name|DEBUG_STR_SECTION_FLAGS
define|\
value|(SECTION_DEBUG | SECTION_MERGE | SECTION_STRINGS | 1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEBUG_STR_SECTION_FLAGS
value|SECTION_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Labels we insert at beginning sections we can reference instead of    the section names themselves.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TEXT_SECTION_LABEL
value|"Ltext"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_LINE_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_LINE_SECTION_LABEL
value|"Ldebug_line"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_INFO_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_INFO_SECTION_LABEL
value|"Ldebug_info"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_ABBREV_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_ABBREV_SECTION_LABEL
value|"Ldebug_abbrev"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_LOC_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_LOC_SECTION_LABEL
value|"Ldebug_loc"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_RANGES_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_RANGES_SECTION_LABEL
value|"Ldebug_ranges"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_MACINFO_SECTION_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DEBUG_MACINFO_SECTION_LABEL
value|"Ldebug_macinfo"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Definitions of defaults for formats and names of various special    (artificial) labels which may be generated within this file (when the -g    options is used and DWARF_DEBUGGING_INFO is in effect.    If necessary, these may be overridden from within the tm.h file, but    typically, overriding these defaults is unnecessary.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|text_end_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|text_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|abbrev_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|debug_info_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|debug_line_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|macinfo_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|loc_section_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ranges_section_label
index|[
literal|2
operator|*
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|TEXT_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|TEXT_END_LABEL
value|"Letext"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DATA_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|DATA_END_LABEL
value|"Ledata"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BSS_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BSS_END_LABEL
value|"Lebss"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_BEGIN_LABEL
value|"LBB"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BLOCK_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BLOCK_END_LABEL
value|"LBE"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BODY_BEGIN_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BODY_BEGIN_LABEL
value|"Lbb"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BODY_END_LABEL
end_ifndef

begin_define
define|#
directive|define
name|BODY_END_LABEL
value|"Lbe"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_CODE_LABEL
end_ifndef

begin_define
define|#
directive|define
name|LINE_CODE_LABEL
value|"LM"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEPARATE_LINE_CODE_LABEL
end_ifndef

begin_define
define|#
directive|define
name|SEPARATE_LINE_CODE_LABEL
value|"LSM"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* We allow a language front-end to designate a function that is to be    called to "demangle" any name before it it put into a DIE.  */
end_comment

begin_expr_stmt
specifier|static
specifier|const
name|char
operator|*
operator|(
operator|*
name|demangle_name_func
operator|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
name|dwarf2out_set_demangle_name_func
argument_list|(
name|func
argument_list|)
decl|const
name|char
modifier|*
argument_list|(
operator|*
name|func
argument_list|)
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|demangle_name_func
operator|=
name|func
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Test if rtl node points to a pseudo register.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_pseudo_reg
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|rtl
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a reference to a type, with its const and volatile qualifiers    removed.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|type_main_variant
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* ??? There really should be only one main variant among any group of      variants of a given type (and all of the MAIN_VARIANT values for all      members of the group should point to that one type) but sometimes the C      front-end messes this up for array types, so we work around that bug      here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
while|while
condition|(
name|type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the given type node represents a tagged type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_tagged_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|QUAL_UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a DIE tag into its string name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_tag_name
parameter_list|(
name|tag
parameter_list|)
name|unsigned
name|tag
decl_stmt|;
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DW_TAG_padding
case|:
return|return
literal|"DW_TAG_padding"
return|;
case|case
name|DW_TAG_array_type
case|:
return|return
literal|"DW_TAG_array_type"
return|;
case|case
name|DW_TAG_class_type
case|:
return|return
literal|"DW_TAG_class_type"
return|;
case|case
name|DW_TAG_entry_point
case|:
return|return
literal|"DW_TAG_entry_point"
return|;
case|case
name|DW_TAG_enumeration_type
case|:
return|return
literal|"DW_TAG_enumeration_type"
return|;
case|case
name|DW_TAG_formal_parameter
case|:
return|return
literal|"DW_TAG_formal_parameter"
return|;
case|case
name|DW_TAG_imported_declaration
case|:
return|return
literal|"DW_TAG_imported_declaration"
return|;
case|case
name|DW_TAG_label
case|:
return|return
literal|"DW_TAG_label"
return|;
case|case
name|DW_TAG_lexical_block
case|:
return|return
literal|"DW_TAG_lexical_block"
return|;
case|case
name|DW_TAG_member
case|:
return|return
literal|"DW_TAG_member"
return|;
case|case
name|DW_TAG_pointer_type
case|:
return|return
literal|"DW_TAG_pointer_type"
return|;
case|case
name|DW_TAG_reference_type
case|:
return|return
literal|"DW_TAG_reference_type"
return|;
case|case
name|DW_TAG_compile_unit
case|:
return|return
literal|"DW_TAG_compile_unit"
return|;
case|case
name|DW_TAG_string_type
case|:
return|return
literal|"DW_TAG_string_type"
return|;
case|case
name|DW_TAG_structure_type
case|:
return|return
literal|"DW_TAG_structure_type"
return|;
case|case
name|DW_TAG_subroutine_type
case|:
return|return
literal|"DW_TAG_subroutine_type"
return|;
case|case
name|DW_TAG_typedef
case|:
return|return
literal|"DW_TAG_typedef"
return|;
case|case
name|DW_TAG_union_type
case|:
return|return
literal|"DW_TAG_union_type"
return|;
case|case
name|DW_TAG_unspecified_parameters
case|:
return|return
literal|"DW_TAG_unspecified_parameters"
return|;
case|case
name|DW_TAG_variant
case|:
return|return
literal|"DW_TAG_variant"
return|;
case|case
name|DW_TAG_common_block
case|:
return|return
literal|"DW_TAG_common_block"
return|;
case|case
name|DW_TAG_common_inclusion
case|:
return|return
literal|"DW_TAG_common_inclusion"
return|;
case|case
name|DW_TAG_inheritance
case|:
return|return
literal|"DW_TAG_inheritance"
return|;
case|case
name|DW_TAG_inlined_subroutine
case|:
return|return
literal|"DW_TAG_inlined_subroutine"
return|;
case|case
name|DW_TAG_module
case|:
return|return
literal|"DW_TAG_module"
return|;
case|case
name|DW_TAG_ptr_to_member_type
case|:
return|return
literal|"DW_TAG_ptr_to_member_type"
return|;
case|case
name|DW_TAG_set_type
case|:
return|return
literal|"DW_TAG_set_type"
return|;
case|case
name|DW_TAG_subrange_type
case|:
return|return
literal|"DW_TAG_subrange_type"
return|;
case|case
name|DW_TAG_with_stmt
case|:
return|return
literal|"DW_TAG_with_stmt"
return|;
case|case
name|DW_TAG_access_declaration
case|:
return|return
literal|"DW_TAG_access_declaration"
return|;
case|case
name|DW_TAG_base_type
case|:
return|return
literal|"DW_TAG_base_type"
return|;
case|case
name|DW_TAG_catch_block
case|:
return|return
literal|"DW_TAG_catch_block"
return|;
case|case
name|DW_TAG_const_type
case|:
return|return
literal|"DW_TAG_const_type"
return|;
case|case
name|DW_TAG_constant
case|:
return|return
literal|"DW_TAG_constant"
return|;
case|case
name|DW_TAG_enumerator
case|:
return|return
literal|"DW_TAG_enumerator"
return|;
case|case
name|DW_TAG_file_type
case|:
return|return
literal|"DW_TAG_file_type"
return|;
case|case
name|DW_TAG_friend
case|:
return|return
literal|"DW_TAG_friend"
return|;
case|case
name|DW_TAG_namelist
case|:
return|return
literal|"DW_TAG_namelist"
return|;
case|case
name|DW_TAG_namelist_item
case|:
return|return
literal|"DW_TAG_namelist_item"
return|;
case|case
name|DW_TAG_packed_type
case|:
return|return
literal|"DW_TAG_packed_type"
return|;
case|case
name|DW_TAG_subprogram
case|:
return|return
literal|"DW_TAG_subprogram"
return|;
case|case
name|DW_TAG_template_type_param
case|:
return|return
literal|"DW_TAG_template_type_param"
return|;
case|case
name|DW_TAG_template_value_param
case|:
return|return
literal|"DW_TAG_template_value_param"
return|;
case|case
name|DW_TAG_thrown_type
case|:
return|return
literal|"DW_TAG_thrown_type"
return|;
case|case
name|DW_TAG_try_block
case|:
return|return
literal|"DW_TAG_try_block"
return|;
case|case
name|DW_TAG_variant_part
case|:
return|return
literal|"DW_TAG_variant_part"
return|;
case|case
name|DW_TAG_variable
case|:
return|return
literal|"DW_TAG_variable"
return|;
case|case
name|DW_TAG_volatile_type
case|:
return|return
literal|"DW_TAG_volatile_type"
return|;
case|case
name|DW_TAG_MIPS_loop
case|:
return|return
literal|"DW_TAG_MIPS_loop"
return|;
case|case
name|DW_TAG_format_label
case|:
return|return
literal|"DW_TAG_format_label"
return|;
case|case
name|DW_TAG_function_template
case|:
return|return
literal|"DW_TAG_function_template"
return|;
case|case
name|DW_TAG_class_template
case|:
return|return
literal|"DW_TAG_class_template"
return|;
case|case
name|DW_TAG_GNU_BINCL
case|:
return|return
literal|"DW_TAG_GNU_BINCL"
return|;
case|case
name|DW_TAG_GNU_EINCL
case|:
return|return
literal|"DW_TAG_GNU_EINCL"
return|;
default|default:
return|return
literal|"DW_TAG_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF attribute code into its string name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_attr_name
parameter_list|(
name|attr
parameter_list|)
name|unsigned
name|attr
decl_stmt|;
block|{
switch|switch
condition|(
name|attr
condition|)
block|{
case|case
name|DW_AT_sibling
case|:
return|return
literal|"DW_AT_sibling"
return|;
case|case
name|DW_AT_location
case|:
return|return
literal|"DW_AT_location"
return|;
case|case
name|DW_AT_name
case|:
return|return
literal|"DW_AT_name"
return|;
case|case
name|DW_AT_ordering
case|:
return|return
literal|"DW_AT_ordering"
return|;
case|case
name|DW_AT_subscr_data
case|:
return|return
literal|"DW_AT_subscr_data"
return|;
case|case
name|DW_AT_byte_size
case|:
return|return
literal|"DW_AT_byte_size"
return|;
case|case
name|DW_AT_bit_offset
case|:
return|return
literal|"DW_AT_bit_offset"
return|;
case|case
name|DW_AT_bit_size
case|:
return|return
literal|"DW_AT_bit_size"
return|;
case|case
name|DW_AT_element_list
case|:
return|return
literal|"DW_AT_element_list"
return|;
case|case
name|DW_AT_stmt_list
case|:
return|return
literal|"DW_AT_stmt_list"
return|;
case|case
name|DW_AT_low_pc
case|:
return|return
literal|"DW_AT_low_pc"
return|;
case|case
name|DW_AT_high_pc
case|:
return|return
literal|"DW_AT_high_pc"
return|;
case|case
name|DW_AT_language
case|:
return|return
literal|"DW_AT_language"
return|;
case|case
name|DW_AT_member
case|:
return|return
literal|"DW_AT_member"
return|;
case|case
name|DW_AT_discr
case|:
return|return
literal|"DW_AT_discr"
return|;
case|case
name|DW_AT_discr_value
case|:
return|return
literal|"DW_AT_discr_value"
return|;
case|case
name|DW_AT_visibility
case|:
return|return
literal|"DW_AT_visibility"
return|;
case|case
name|DW_AT_import
case|:
return|return
literal|"DW_AT_import"
return|;
case|case
name|DW_AT_string_length
case|:
return|return
literal|"DW_AT_string_length"
return|;
case|case
name|DW_AT_common_reference
case|:
return|return
literal|"DW_AT_common_reference"
return|;
case|case
name|DW_AT_comp_dir
case|:
return|return
literal|"DW_AT_comp_dir"
return|;
case|case
name|DW_AT_const_value
case|:
return|return
literal|"DW_AT_const_value"
return|;
case|case
name|DW_AT_containing_type
case|:
return|return
literal|"DW_AT_containing_type"
return|;
case|case
name|DW_AT_default_value
case|:
return|return
literal|"DW_AT_default_value"
return|;
case|case
name|DW_AT_inline
case|:
return|return
literal|"DW_AT_inline"
return|;
case|case
name|DW_AT_is_optional
case|:
return|return
literal|"DW_AT_is_optional"
return|;
case|case
name|DW_AT_lower_bound
case|:
return|return
literal|"DW_AT_lower_bound"
return|;
case|case
name|DW_AT_producer
case|:
return|return
literal|"DW_AT_producer"
return|;
case|case
name|DW_AT_prototyped
case|:
return|return
literal|"DW_AT_prototyped"
return|;
case|case
name|DW_AT_return_addr
case|:
return|return
literal|"DW_AT_return_addr"
return|;
case|case
name|DW_AT_start_scope
case|:
return|return
literal|"DW_AT_start_scope"
return|;
case|case
name|DW_AT_stride_size
case|:
return|return
literal|"DW_AT_stride_size"
return|;
case|case
name|DW_AT_upper_bound
case|:
return|return
literal|"DW_AT_upper_bound"
return|;
case|case
name|DW_AT_abstract_origin
case|:
return|return
literal|"DW_AT_abstract_origin"
return|;
case|case
name|DW_AT_accessibility
case|:
return|return
literal|"DW_AT_accessibility"
return|;
case|case
name|DW_AT_address_class
case|:
return|return
literal|"DW_AT_address_class"
return|;
case|case
name|DW_AT_artificial
case|:
return|return
literal|"DW_AT_artificial"
return|;
case|case
name|DW_AT_base_types
case|:
return|return
literal|"DW_AT_base_types"
return|;
case|case
name|DW_AT_calling_convention
case|:
return|return
literal|"DW_AT_calling_convention"
return|;
case|case
name|DW_AT_count
case|:
return|return
literal|"DW_AT_count"
return|;
case|case
name|DW_AT_data_member_location
case|:
return|return
literal|"DW_AT_data_member_location"
return|;
case|case
name|DW_AT_decl_column
case|:
return|return
literal|"DW_AT_decl_column"
return|;
case|case
name|DW_AT_decl_file
case|:
return|return
literal|"DW_AT_decl_file"
return|;
case|case
name|DW_AT_decl_line
case|:
return|return
literal|"DW_AT_decl_line"
return|;
case|case
name|DW_AT_declaration
case|:
return|return
literal|"DW_AT_declaration"
return|;
case|case
name|DW_AT_discr_list
case|:
return|return
literal|"DW_AT_discr_list"
return|;
case|case
name|DW_AT_encoding
case|:
return|return
literal|"DW_AT_encoding"
return|;
case|case
name|DW_AT_external
case|:
return|return
literal|"DW_AT_external"
return|;
case|case
name|DW_AT_frame_base
case|:
return|return
literal|"DW_AT_frame_base"
return|;
case|case
name|DW_AT_friend
case|:
return|return
literal|"DW_AT_friend"
return|;
case|case
name|DW_AT_identifier_case
case|:
return|return
literal|"DW_AT_identifier_case"
return|;
case|case
name|DW_AT_macro_info
case|:
return|return
literal|"DW_AT_macro_info"
return|;
case|case
name|DW_AT_namelist_items
case|:
return|return
literal|"DW_AT_namelist_items"
return|;
case|case
name|DW_AT_priority
case|:
return|return
literal|"DW_AT_priority"
return|;
case|case
name|DW_AT_segment
case|:
return|return
literal|"DW_AT_segment"
return|;
case|case
name|DW_AT_specification
case|:
return|return
literal|"DW_AT_specification"
return|;
case|case
name|DW_AT_static_link
case|:
return|return
literal|"DW_AT_static_link"
return|;
case|case
name|DW_AT_type
case|:
return|return
literal|"DW_AT_type"
return|;
case|case
name|DW_AT_use_location
case|:
return|return
literal|"DW_AT_use_location"
return|;
case|case
name|DW_AT_variable_parameter
case|:
return|return
literal|"DW_AT_variable_parameter"
return|;
case|case
name|DW_AT_virtuality
case|:
return|return
literal|"DW_AT_virtuality"
return|;
case|case
name|DW_AT_vtable_elem_location
case|:
return|return
literal|"DW_AT_vtable_elem_location"
return|;
case|case
name|DW_AT_allocated
case|:
return|return
literal|"DW_AT_allocated"
return|;
case|case
name|DW_AT_associated
case|:
return|return
literal|"DW_AT_associated"
return|;
case|case
name|DW_AT_data_location
case|:
return|return
literal|"DW_AT_data_location"
return|;
case|case
name|DW_AT_stride
case|:
return|return
literal|"DW_AT_stride"
return|;
case|case
name|DW_AT_entry_pc
case|:
return|return
literal|"DW_AT_entry_pc"
return|;
case|case
name|DW_AT_use_UTF8
case|:
return|return
literal|"DW_AT_use_UTF8"
return|;
case|case
name|DW_AT_extension
case|:
return|return
literal|"DW_AT_extension"
return|;
case|case
name|DW_AT_ranges
case|:
return|return
literal|"DW_AT_ranges"
return|;
case|case
name|DW_AT_trampoline
case|:
return|return
literal|"DW_AT_trampoline"
return|;
case|case
name|DW_AT_call_column
case|:
return|return
literal|"DW_AT_call_column"
return|;
case|case
name|DW_AT_call_file
case|:
return|return
literal|"DW_AT_call_file"
return|;
case|case
name|DW_AT_call_line
case|:
return|return
literal|"DW_AT_call_line"
return|;
case|case
name|DW_AT_MIPS_fde
case|:
return|return
literal|"DW_AT_MIPS_fde"
return|;
case|case
name|DW_AT_MIPS_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_loop_begin"
return|;
case|case
name|DW_AT_MIPS_tail_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_tail_loop_begin"
return|;
case|case
name|DW_AT_MIPS_epilog_begin
case|:
return|return
literal|"DW_AT_MIPS_epilog_begin"
return|;
case|case
name|DW_AT_MIPS_loop_unroll_factor
case|:
return|return
literal|"DW_AT_MIPS_loop_unroll_factor"
return|;
case|case
name|DW_AT_MIPS_software_pipeline_depth
case|:
return|return
literal|"DW_AT_MIPS_software_pipeline_depth"
return|;
case|case
name|DW_AT_MIPS_linkage_name
case|:
return|return
literal|"DW_AT_MIPS_linkage_name"
return|;
case|case
name|DW_AT_MIPS_stride
case|:
return|return
literal|"DW_AT_MIPS_stride"
return|;
case|case
name|DW_AT_MIPS_abstract_name
case|:
return|return
literal|"DW_AT_MIPS_abstract_name"
return|;
case|case
name|DW_AT_MIPS_clone_origin
case|:
return|return
literal|"DW_AT_MIPS_clone_origin"
return|;
case|case
name|DW_AT_MIPS_has_inlines
case|:
return|return
literal|"DW_AT_MIPS_has_inlines"
return|;
case|case
name|DW_AT_sf_names
case|:
return|return
literal|"DW_AT_sf_names"
return|;
case|case
name|DW_AT_src_info
case|:
return|return
literal|"DW_AT_src_info"
return|;
case|case
name|DW_AT_mac_info
case|:
return|return
literal|"DW_AT_mac_info"
return|;
case|case
name|DW_AT_src_coords
case|:
return|return
literal|"DW_AT_src_coords"
return|;
case|case
name|DW_AT_body_begin
case|:
return|return
literal|"DW_AT_body_begin"
return|;
case|case
name|DW_AT_body_end
case|:
return|return
literal|"DW_AT_body_end"
return|;
case|case
name|DW_AT_VMS_rtnbeg_pd_address
case|:
return|return
literal|"DW_AT_VMS_rtnbeg_pd_address"
return|;
default|default:
return|return
literal|"DW_AT_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF value form code into its string name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf_form_name
parameter_list|(
name|form
parameter_list|)
name|unsigned
name|form
decl_stmt|;
block|{
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
return|return
literal|"DW_FORM_addr"
return|;
case|case
name|DW_FORM_block2
case|:
return|return
literal|"DW_FORM_block2"
return|;
case|case
name|DW_FORM_block4
case|:
return|return
literal|"DW_FORM_block4"
return|;
case|case
name|DW_FORM_data2
case|:
return|return
literal|"DW_FORM_data2"
return|;
case|case
name|DW_FORM_data4
case|:
return|return
literal|"DW_FORM_data4"
return|;
case|case
name|DW_FORM_data8
case|:
return|return
literal|"DW_FORM_data8"
return|;
case|case
name|DW_FORM_string
case|:
return|return
literal|"DW_FORM_string"
return|;
case|case
name|DW_FORM_block
case|:
return|return
literal|"DW_FORM_block"
return|;
case|case
name|DW_FORM_block1
case|:
return|return
literal|"DW_FORM_block1"
return|;
case|case
name|DW_FORM_data1
case|:
return|return
literal|"DW_FORM_data1"
return|;
case|case
name|DW_FORM_flag
case|:
return|return
literal|"DW_FORM_flag"
return|;
case|case
name|DW_FORM_sdata
case|:
return|return
literal|"DW_FORM_sdata"
return|;
case|case
name|DW_FORM_strp
case|:
return|return
literal|"DW_FORM_strp"
return|;
case|case
name|DW_FORM_udata
case|:
return|return
literal|"DW_FORM_udata"
return|;
case|case
name|DW_FORM_ref_addr
case|:
return|return
literal|"DW_FORM_ref_addr"
return|;
case|case
name|DW_FORM_ref1
case|:
return|return
literal|"DW_FORM_ref1"
return|;
case|case
name|DW_FORM_ref2
case|:
return|return
literal|"DW_FORM_ref2"
return|;
case|case
name|DW_FORM_ref4
case|:
return|return
literal|"DW_FORM_ref4"
return|;
case|case
name|DW_FORM_ref8
case|:
return|return
literal|"DW_FORM_ref8"
return|;
case|case
name|DW_FORM_ref_udata
case|:
return|return
literal|"DW_FORM_ref_udata"
return|;
case|case
name|DW_FORM_indirect
case|:
return|return
literal|"DW_FORM_indirect"
return|;
default|default:
return|return
literal|"DW_FORM_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF type code into its string name.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char * dwarf_type_encoding_name (enc)      unsigned enc; {   switch (enc)     {     case DW_ATE_address:       return "DW_ATE_address";     case DW_ATE_boolean:       return "DW_ATE_boolean";     case DW_ATE_complex_float:       return "DW_ATE_complex_float";     case DW_ATE_float:       return "DW_ATE_float";     case DW_ATE_signed:       return "DW_ATE_signed";     case DW_ATE_signed_char:       return "DW_ATE_signed_char";     case DW_ATE_unsigned:       return "DW_ATE_unsigned";     case DW_ATE_unsigned_char:       return "DW_ATE_unsigned_char";     default:       return "DW_ATE_<unknown>";     } }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Determine the "ultimate origin" of a decl.  The decl may be an inlined    instance of an inlined instance of a decl which is local to an inline    function, so we have to trace all of the way back through the origin chain    to find out what sort of node actually served as the original seed for the    given block.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_ultimate_origin
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* output_inline_function sets DECL_ABSTRACT_ORIGIN for all the      nodes in the function to point to themselves; ignore that if      we're trying to output the abstract instance of this function.  */
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|==
name|decl
condition|)
return|return
name|NULL_TREE
return|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|DECL_FROM_INLINE
argument_list|(
name|DECL_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
comment|/* Since the DECL_ABSTRACT_ORIGIN for a DECL is supposed to be the        most distant ancestor, this should never happen.  */
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine the "ultimate origin" of a block.  The block may be an inlined    instance of an inlined instance of a block which is local to an inline    function, so we have to trace all of the way back through the origin chain    to find out what sort of node actually served as the original seed for the    given block.  */
end_comment

begin_function
specifier|static
name|tree
name|block_ultimate_origin
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|immediate_origin
init|=
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|block
argument_list|)
decl_stmt|;
comment|/* output_inline_function sets BLOCK_ABSTRACT_ORIGIN for all the      nodes in the function to point to themselves; ignore that if      we're trying to output the abstract instance of this function.  */
if|if
condition|(
name|BLOCK_ABSTRACT
argument_list|(
name|block
argument_list|)
operator|&&
name|immediate_origin
operator|==
name|block
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|immediate_origin
operator|==
name|NULL_TREE
condition|)
return|return
name|NULL_TREE
return|;
else|else
block|{
name|tree
name|ret_val
decl_stmt|;
name|tree
name|lookahead
init|=
name|immediate_origin
decl_stmt|;
do|do
block|{
name|ret_val
operator|=
name|lookahead
expr_stmt|;
name|lookahead
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|ret_val
argument_list|)
operator|==
name|BLOCK
condition|?
name|BLOCK_ABSTRACT_ORIGIN
argument_list|(
name|ret_val
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|lookahead
operator|!=
name|NULL
operator|&&
name|lookahead
operator|!=
name|ret_val
condition|)
do|;
return|return
name|ret_val
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get the class to which DECL belongs, if any.  In g++, the DECL_CONTEXT    of a virtual function may refer to a base class, so we check the 'this'    parameter.  */
end_comment

begin_function
specifier|static
name|tree
name|decl_class_context
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|context
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|&&
operator|!
name|TYPE_P
argument_list|(
name|context
argument_list|)
condition|)
name|context
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|context
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an attribute/value pair to a DIE.  We build the lists up in reverse    addition order, and correct that in reverse_all_dies.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_dwarf_attr
parameter_list|(
name|die
parameter_list|,
name|attr
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|dw_attr_ref
name|attr
decl_stmt|;
block|{
if|if
condition|(
name|die
operator|!=
name|NULL
operator|&&
name|attr
operator|!=
name|NULL
condition|)
block|{
name|attr
operator|->
name|dw_attr_next
operator|=
name|die
operator|->
name|die_attr
expr_stmt|;
name|die
operator|->
name|die_attr
operator|=
name|attr
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dw_val_class
name|AT_class
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
return|;
block|}
end_function

begin_comment
comment|/* Add a flag value attribute to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_flag
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|flag
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|unsigned
name|flag
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_flag
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_flag
operator|=
name|flag
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|AT_flag
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_flag
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_flag
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a signed integer attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_int
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|int_val
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|long
name|int
name|int_val
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_const
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_int
operator|=
name|int_val
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|long
name|int
name|AT_int
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_const
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_int
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an unsigned integer attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_unsigned
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|unsigned_val
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|unsigned
name|long
name|unsigned_val
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_unsigned_const
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
operator|=
name|unsigned_val
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|AT_unsigned
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_unsigned_const
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an unsigned double integer attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_long_long
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|val_hi
parameter_list|,
name|val_low
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|unsigned
name|long
name|val_hi
decl_stmt|;
name|unsigned
name|long
name|val_low
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_long_long
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
operator|=
name|val_hi
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
operator|=
name|val_low
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a floating point attribute value to a DIE and return it.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_float
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|length
parameter_list|,
name|array
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|long
modifier|*
name|array
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_float
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|array
operator|=
name|array
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a string attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_string
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|str
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|indirect_string_node
modifier|*
name|node
decl_stmt|;
if|if
condition|(
operator|!
name|debug_str_hash
condition|)
block|{
name|debug_str_hash
operator|=
name|ht_create
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|debug_str_hash
operator|->
name|alloc_node
operator|=
name|indirect_string_alloc
expr_stmt|;
block|}
name|node
operator|=
operator|(
expr|struct
name|indirect_string_node
operator|*
operator|)
name|ht_lookup
argument_list|(
name|debug_str_hash
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|HT_ALLOC
argument_list|)
expr_stmt|;
name|node
operator|->
name|refcount
operator|++
expr_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_str
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|=
name|node
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|AT_string
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_str
condition|)
return|return
operator|(
specifier|const
name|char
operator|*
operator|)
name|HT_STR
argument_list|(
operator|&
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|->
name|id
argument_list|)
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find out whether a string should be output inline in DIE    or out-of-line in .debug_str section.  */
end_comment

begin_function
specifier|static
name|int
name|AT_string_form
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_str
condition|)
block|{
name|struct
name|indirect_string_node
modifier|*
name|node
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
specifier|extern
name|int
name|const_labelno
decl_stmt|;
name|char
name|label
index|[
literal|32
index|]
decl_stmt|;
name|node
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|form
condition|)
return|return
name|node
operator|->
name|form
return|;
name|len
operator|=
name|HT_LEN
argument_list|(
operator|&
name|node
operator|->
name|id
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* If the string is shorter or equal to the size of the reference, it is 	 always better to put it inline.  */
if|if
condition|(
name|len
operator|<=
name|DWARF_OFFSET_SIZE
operator|||
name|node
operator|->
name|refcount
operator|==
literal|0
condition|)
return|return
name|node
operator|->
name|form
operator|=
name|DW_FORM_string
return|;
comment|/* If we cannot expect the linker to merge strings in .debug_str 	 section, only put it into .debug_str if it is worth even in this 	 single module.  */
if|if
condition|(
operator|(
name|DEBUG_STR_SECTION_FLAGS
operator|&
name|SECTION_MERGE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|len
operator|-
name|DWARF_OFFSET_SIZE
operator|)
operator|*
name|node
operator|->
name|refcount
operator|<=
name|len
condition|)
return|return
name|node
operator|->
name|form
operator|=
name|DW_FORM_string
return|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
name|node
operator|->
name|label
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
name|node
operator|->
name|form
operator|=
name|DW_FORM_strp
return|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a DIE reference attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_die_ref
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|targ_die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|dw_die_ref
name|targ_die
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_die_ref
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|.
name|die
operator|=
name|targ_die
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|.
name|external
operator|=
literal|0
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|AT_ref
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_die_ref
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|.
name|die
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|AT_ref_external
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_die_ref
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|.
name|external
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|set_AT_ref_external
parameter_list|(
name|a
parameter_list|,
name|i
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_die_ref
condition|)
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_die_ref
operator|.
name|external
operator|=
name|i
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an FDE reference attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_fde_ref
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|targ_fde
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|unsigned
name|targ_fde
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_fde_ref
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_fde_index
operator|=
name|targ_fde
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a location description attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_loc
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|loc
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|dw_loc_descr_ref
name|loc
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_loc
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc
operator|=
name|loc
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dw_loc_descr_ref
name|AT_loc
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_loc
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_loc_list
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|loc_list
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|dw_loc_list_ref
name|loc_list
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_loc_list
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc_list
operator|=
name|loc_list
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|have_location_lists
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dw_loc_list_ref
name|AT_loc_list
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_loc_list
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_loc_list
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an address constant attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_addr
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|addr
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|rtx
name|addr
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_addr
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_addr
operator|=
name|addr
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|rtx
name|AT_addr
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_addr
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_addr
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a label identifier attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_lbl_id
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|lbl_id
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|lbl_id
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_lbl_id
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
operator|=
name|xstrdup
argument_list|(
name|lbl_id
argument_list|)
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a section offset attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_lbl_offset
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|label
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|label
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_lbl_offset
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
operator|=
name|xstrdup
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an offset attribute value to a DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_AT_offset
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|offset
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_offset
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_offset
operator|=
name|offset
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an range_list attribute value to a DIE.  */
end_comment

begin_function
specifier|static
name|void
name|add_AT_range_list
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|offset
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
block|{
name|dw_attr_ref
name|attr
init|=
operator|(
name|dw_attr_ref
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dw_attr_node
argument_list|)
argument_list|)
decl_stmt|;
name|attr
operator|->
name|dw_attr_next
operator|=
name|NULL
expr_stmt|;
name|attr
operator|->
name|dw_attr
operator|=
name|attr_kind
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|val_class
operator|=
name|dw_val_class_range_list
expr_stmt|;
name|attr
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_offset
operator|=
name|offset
expr_stmt|;
name|add_dwarf_attr
argument_list|(
name|die
argument_list|,
name|attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|AT_lbl
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|&&
operator|(
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_lbl_id
operator|||
name|AT_class
argument_list|(
name|a
argument_list|)
operator|==
name|dw_val_class_lbl_offset
operator|)
condition|)
return|return
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the attribute of type attr_kind.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_attr_ref
name|get_AT
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
block|{
name|dw_attr_ref
name|a
decl_stmt|;
name|dw_die_ref
name|spec
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|die
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
control|)
if|if
condition|(
name|a
operator|->
name|dw_attr
operator|==
name|attr_kind
condition|)
return|return
name|a
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|dw_attr
operator|==
name|DW_AT_specification
operator|||
name|a
operator|->
name|dw_attr
operator|==
name|DW_AT_abstract_origin
condition|)
name|spec
operator|=
name|AT_ref
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec
condition|)
return|return
name|get_AT
argument_list|(
name|spec
argument_list|,
name|attr_kind
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the "low pc" attribute value, typically associated with a subprogram    DIE.  Return null if the "low pc" attribute is either not present, or if it    cannot be represented as an assembler label identifier.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|get_AT_low_pc
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_lbl
argument_list|(
name|a
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the "high pc" attribute value, typically associated with a subprogram    DIE.  Return null if the "high pc" attribute is either not present, or if it    cannot be represented as an assembler label identifier.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|get_AT_hi_pc
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|DW_AT_high_pc
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_lbl
argument_list|(
name|a
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the string attribute designated by ATTR_KIND, or    NULL if it is not present.  */
end_comment

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|get_AT_string
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_string
argument_list|(
name|a
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the flag attribute designated by ATTR_KIND, or -1    if it is not present.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|get_AT_flag
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_flag
argument_list|(
name|a
argument_list|)
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the value of the unsigned attribute designated by ATTR_KIND, or 0    if it is not present.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|get_AT_unsigned
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_unsigned
argument_list|(
name|a
argument_list|)
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|get_AT_ref
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
block|{
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|)
decl_stmt|;
return|return
name|a
condition|?
name|AT_ref
argument_list|(
name|a
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_c_family
parameter_list|()
block|{
name|unsigned
name|lang
init|=
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
decl_stmt|;
return|return
operator|(
name|lang
operator|==
name|DW_LANG_C
operator|||
name|lang
operator|==
name|DW_LANG_C89
operator|||
name|lang
operator|==
name|DW_LANG_C_plus_plus
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_cxx
parameter_list|()
block|{
return|return
operator|(
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
operator|==
name|DW_LANG_C_plus_plus
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_fortran
parameter_list|()
block|{
name|unsigned
name|lang
init|=
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
decl_stmt|;
return|return
operator|(
name|lang
operator|==
name|DW_LANG_Fortran77
operator|||
name|lang
operator|==
name|DW_LANG_Fortran90
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_java
parameter_list|()
block|{
name|unsigned
name|lang
init|=
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
decl_stmt|;
return|return
operator|(
name|lang
operator|==
name|DW_LANG_Java
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free up the memory used by A.  */
end_comment

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|free_AT
name|PARAMS
argument_list|(
operator|(
name|dw_attr_ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|free_AT
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
switch|switch
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|dw_val_class_str
case|:
if|if
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|->
name|refcount
condition|)
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|->
name|refcount
operator|--
expr_stmt|;
break|break;
case|case
name|dw_val_class_lbl_id
case|:
case|case
name|dw_val_class_lbl_offset
case|:
name|free
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_lbl_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_float
case|:
name|free
argument_list|(
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|array
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the specified attribute if present.  */
end_comment

begin_function
specifier|static
name|void
name|remove_AT
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
block|{
name|dw_attr_ref
modifier|*
name|p
decl_stmt|;
name|dw_attr_ref
name|removed
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|die
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|&
operator|(
name|die
operator|->
name|die_attr
operator|)
init|;
operator|*
name|p
condition|;
name|p
operator|=
operator|&
operator|(
operator|(
operator|*
name|p
operator|)
operator|->
name|dw_attr_next
operator|)
control|)
if|if
condition|(
operator|(
operator|*
name|p
operator|)
operator|->
name|dw_attr
operator|==
name|attr_kind
condition|)
block|{
name|removed
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|dw_attr_next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|removed
operator|!=
literal|0
condition|)
name|free_AT
argument_list|(
name|removed
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free up the memory used by DIE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|free_die
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|remove_children
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard the children of this DIE.  */
end_comment

begin_function
specifier|static
name|void
name|remove_children
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_die_ref
name|child_die
init|=
name|die
operator|->
name|die_child
decl_stmt|;
name|die
operator|->
name|die_child
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|child_die
operator|!=
name|NULL
condition|)
block|{
name|dw_die_ref
name|tmp_die
init|=
name|child_die
decl_stmt|;
name|dw_attr_ref
name|a
decl_stmt|;
name|child_die
operator|=
name|child_die
operator|->
name|die_sib
expr_stmt|;
for|for
control|(
name|a
operator|=
name|tmp_die
operator|->
name|die_attr
init|;
name|a
operator|!=
name|NULL
condition|;
control|)
block|{
name|dw_attr_ref
name|tmp_a
init|=
name|a
decl_stmt|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
expr_stmt|;
name|free_AT
argument_list|(
name|tmp_a
argument_list|)
expr_stmt|;
block|}
name|free_die
argument_list|(
name|tmp_die
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a child DIE below its parent.  We build the lists up in reverse    addition order, and correct that in reverse_all_dies.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_child_die
parameter_list|(
name|die
parameter_list|,
name|child_die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|dw_die_ref
name|child_die
decl_stmt|;
block|{
if|if
condition|(
name|die
operator|!=
name|NULL
operator|&&
name|child_die
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|die
operator|==
name|child_die
condition|)
name|abort
argument_list|()
expr_stmt|;
name|child_die
operator|->
name|die_parent
operator|=
name|die
expr_stmt|;
name|child_die
operator|->
name|die_sib
operator|=
name|die
operator|->
name|die_child
expr_stmt|;
name|die
operator|->
name|die_child
operator|=
name|child_die
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Move CHILD, which must be a child of PARENT or the DIE for which PARENT    is the specification, to the front of PARENT's list of children.  */
end_comment

begin_function
specifier|static
name|void
name|splice_child_die
parameter_list|(
name|parent
parameter_list|,
name|child
parameter_list|)
name|dw_die_ref
name|parent
decl_stmt|,
name|child
decl_stmt|;
block|{
name|dw_die_ref
modifier|*
name|p
decl_stmt|;
comment|/* We want the declaration DIE from inside the class, not the      specification DIE at toplevel.  */
if|if
condition|(
name|child
operator|->
name|die_parent
operator|!=
name|parent
condition|)
block|{
name|dw_die_ref
name|tmp
init|=
name|get_AT_ref
argument_list|(
name|child
argument_list|,
name|DW_AT_specification
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
name|child
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|child
operator|->
name|die_parent
operator|!=
name|parent
operator|&&
name|child
operator|->
name|die_parent
operator|!=
name|get_AT_ref
argument_list|(
name|parent
argument_list|,
name|DW_AT_specification
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|&
operator|(
name|child
operator|->
name|die_parent
operator|->
name|die_child
operator|)
init|;
operator|*
name|p
condition|;
name|p
operator|=
operator|&
operator|(
operator|(
operator|*
name|p
operator|)
operator|->
name|die_sib
operator|)
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|child
condition|)
block|{
operator|*
name|p
operator|=
name|child
operator|->
name|die_sib
expr_stmt|;
break|break;
block|}
name|child
operator|->
name|die_sib
operator|=
name|parent
operator|->
name|die_child
expr_stmt|;
name|parent
operator|->
name|die_child
operator|=
name|child
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a newly created DIE node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|new_die
parameter_list|(
name|tag_value
parameter_list|,
name|parent_die
parameter_list|,
name|t
parameter_list|)
name|enum
name|dwarf_tag
name|tag_value
decl_stmt|;
name|dw_die_ref
name|parent_die
decl_stmt|;
name|tree
name|t
decl_stmt|;
block|{
name|dw_die_ref
name|die
init|=
operator|(
name|dw_die_ref
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|die_node
argument_list|)
argument_list|)
decl_stmt|;
name|die
operator|->
name|die_tag
operator|=
name|tag_value
expr_stmt|;
if|if
condition|(
name|parent_die
operator|!=
name|NULL
condition|)
name|add_child_die
argument_list|(
name|parent_die
argument_list|,
name|die
argument_list|)
expr_stmt|;
else|else
block|{
name|limbo_die_node
modifier|*
name|limbo_node
decl_stmt|;
name|limbo_node
operator|=
operator|(
name|limbo_die_node
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|limbo_die_node
argument_list|)
argument_list|)
expr_stmt|;
name|limbo_node
operator|->
name|die
operator|=
name|die
expr_stmt|;
name|limbo_node
operator|->
name|created_for
operator|=
name|t
expr_stmt|;
name|limbo_node
operator|->
name|next
operator|=
name|limbo_die_list
expr_stmt|;
name|limbo_die_list
operator|=
name|limbo_node
expr_stmt|;
block|}
return|return
name|die
return|;
block|}
end_function

begin_comment
comment|/* Return the DIE associated with the given type specifier.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|lookup_type_die
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
name|type
operator|=
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|dw_die_ref
operator|)
name|TYPE_SYMTAB_POINTER
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Equate a DIE to a given type specifier.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|equate_type_number_to_die
parameter_list|(
name|type
parameter_list|,
name|type_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|type_die
decl_stmt|;
block|{
name|TYPE_SYMTAB_POINTER
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|type_die
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the DIE associated with a given declaration.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_die_ref
name|lookup_decl_die
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|unsigned
name|decl_id
init|=
name|DECL_UID
argument_list|(
name|decl
argument_list|)
decl_stmt|;
return|return
operator|(
name|decl_id
operator|<
name|decl_die_table_in_use
condition|?
name|decl_die_table
index|[
name|decl_id
index|]
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Equate a DIE to a particular declaration.  */
end_comment

begin_function
specifier|static
name|void
name|equate_decl_number_to_die
parameter_list|(
name|decl
parameter_list|,
name|decl_die
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|dw_die_ref
name|decl_die
decl_stmt|;
block|{
name|unsigned
name|int
name|decl_id
init|=
name|DECL_UID
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|num_allocated
decl_stmt|;
if|if
condition|(
name|decl_id
operator|>=
name|decl_die_table_allocated
condition|)
block|{
name|num_allocated
operator|=
operator|(
operator|(
name|decl_id
operator|+
literal|1
operator|+
name|DECL_DIE_TABLE_INCREMENT
operator|-
literal|1
operator|)
operator|/
name|DECL_DIE_TABLE_INCREMENT
operator|)
operator|*
name|DECL_DIE_TABLE_INCREMENT
expr_stmt|;
name|decl_die_table
operator|=
operator|(
name|dw_die_ref
operator|*
operator|)
name|xrealloc
argument_list|(
name|decl_die_table
argument_list|,
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
operator|*
name|num_allocated
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|decl_die_table
index|[
name|decl_die_table_allocated
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|num_allocated
operator|-
name|decl_die_table_allocated
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|decl_die_table_allocated
operator|=
name|num_allocated
expr_stmt|;
block|}
if|if
condition|(
name|decl_id
operator|>=
name|decl_die_table_in_use
condition|)
name|decl_die_table_in_use
operator|=
operator|(
name|decl_id
operator|+
literal|1
operator|)
expr_stmt|;
name|decl_die_table
index|[
name|decl_id
index|]
operator|=
name|decl_die
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keep track of the number of spaces used to indent the    output of the debugging routines that print the structure of    the DIE internal representation.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_indent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indent the line the number of spaces given by print_indent.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|print_spaces
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%*s"
argument_list|,
name|print_indent
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the information associated with a given DIE, and its children.    This routine is a debugging aid only.  */
end_comment

begin_function
specifier|static
name|void
name|print_die
parameter_list|(
name|die
parameter_list|,
name|outfile
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|dw_attr_ref
name|a
decl_stmt|;
name|dw_die_ref
name|c
decl_stmt|;
name|print_spaces
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"DIE %4lu: %s\n"
argument_list|,
name|die
operator|->
name|die_offset
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|die_tag
argument_list|)
argument_list|)
expr_stmt|;
name|print_spaces
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  abbrev id: %lu"
argument_list|,
name|die
operator|->
name|die_abbrev
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|" offset: %lu\n"
argument_list|,
name|die
operator|->
name|die_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
control|)
block|{
name|print_spaces
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"  %s: "
argument_list|,
name|dwarf_attr_name
argument_list|(
name|a
operator|->
name|dw_attr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"address"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_offset
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"offset"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"location descriptor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc_list
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"location list -> label:%s"
argument_list|,
name|AT_loc_list
argument_list|(
name|a
argument_list|)
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_range_list
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"range list"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_const
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%ld"
argument_list|,
name|AT_int
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_unsigned_const
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%lu"
argument_list|,
name|AT_unsigned
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_long_long
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"constant (%lu,%lu)"
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_float
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"floating-point constant"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_flag
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%u"
argument_list|,
name|AT_flag
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_die_ref
case|:
if|if
condition|(
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_symbol
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"die -> label: %s"
argument_list|,
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_symbol
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"die -> %lu"
argument_list|,
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_offset
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"die -><null>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_lbl_id
case|:
case|case
name|dw_val_class_lbl_offset
case|:
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"label: %s"
argument_list|,
name|AT_lbl
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_str
case|:
if|if
condition|(
name|AT_string
argument_list|(
name|a
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\"%s\""
argument_list|,
name|AT_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"<null>"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
condition|)
block|{
name|print_indent
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|print_die
argument_list|(
name|c
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|print_indent
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|print_indent
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the contents of the source code line number correspondence table.    This routine is a debugging aid only.  */
end_comment

begin_function
specifier|static
name|void
name|print_dwarf_line_table
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
name|dw_line_info_ref
name|line_info
decl_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n\nDWARF source line information\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|line_info_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|line_info
operator|=
operator|&
name|line_info_table
index|[
name|i
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%5d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%-20s"
argument_list|,
name|file_table
operator|.
name|table
index|[
name|line_info
operator|->
name|dw_file_num
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"%6ld"
argument_list|,
name|line_info
operator|->
name|dw_line_num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|outfile
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the information collected for a given DIE.  */
end_comment

begin_function
name|void
name|debug_dwarf_die
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|print_die
argument_list|(
name|die
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print all DWARF information collected for the compilation unit.    This routine is a debugging aid only.  */
end_comment

begin_function
name|void
name|debug_dwarf
parameter_list|()
block|{
name|print_indent
operator|=
literal|0
expr_stmt|;
name|print_die
argument_list|(
name|comp_unit_die
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DWARF2_ASM_LINE_DEBUG_INFO
condition|)
name|print_dwarf_line_table
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We build up the lists of children and attributes by pushing new ones    onto the beginning of the list.  Reverse the lists for DIE so that    they are in order of addition.  */
end_comment

begin_function
specifier|static
name|void
name|reverse_die_lists
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_die_ref
name|c
decl_stmt|,
name|cp
decl_stmt|,
name|cn
decl_stmt|;
name|dw_attr_ref
name|a
decl_stmt|,
name|ap
decl_stmt|,
name|an
decl_stmt|;
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
operator|,
name|ap
operator|=
literal|0
init|;
name|a
condition|;
name|a
operator|=
name|an
control|)
block|{
name|an
operator|=
name|a
operator|->
name|dw_attr_next
expr_stmt|;
name|a
operator|->
name|dw_attr_next
operator|=
name|ap
expr_stmt|;
name|ap
operator|=
name|a
expr_stmt|;
block|}
name|die
operator|->
name|die_attr
operator|=
name|ap
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
operator|,
name|cp
operator|=
literal|0
init|;
name|c
condition|;
name|c
operator|=
name|cn
control|)
block|{
name|cn
operator|=
name|c
operator|->
name|die_sib
expr_stmt|;
name|c
operator|->
name|die_sib
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
name|c
expr_stmt|;
block|}
name|die
operator|->
name|die_child
operator|=
name|cp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reverse_die_lists only reverses the single die you pass it. Since we used to    reverse all dies in add_sibling_attributes, which runs through all the dies,    it would reverse all the dies.  Now, however, since we don't call    reverse_die_lists in add_sibling_attributes, we need a routine to    recursively reverse all the dies. This is that routine.  */
end_comment

begin_function
specifier|static
name|void
name|reverse_all_dies
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|reverse_die_lists
argument_list|(
name|die
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|reverse_all_dies
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a new compilation unit DIE for an include file.  OLD_UNIT is the CU    for the enclosing include file, if any.  BINCL_DIE is the DW_TAG_GNU_BINCL    DIE that marks the start of the DIEs for this include file.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|push_new_compile_unit
parameter_list|(
name|old_unit
parameter_list|,
name|bincl_die
parameter_list|)
name|dw_die_ref
name|old_unit
decl_stmt|,
name|bincl_die
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|get_AT_string
argument_list|(
name|bincl_die
argument_list|,
name|DW_AT_name
argument_list|)
decl_stmt|;
name|dw_die_ref
name|new_unit
init|=
name|gen_compile_unit_die
argument_list|(
name|filename
argument_list|)
decl_stmt|;
name|new_unit
operator|->
name|die_sib
operator|=
name|old_unit
expr_stmt|;
return|return
name|new_unit
return|;
block|}
end_function

begin_comment
comment|/* Close an include-file CU and reopen the enclosing one.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|pop_compile_unit
parameter_list|(
name|old_unit
parameter_list|)
name|dw_die_ref
name|old_unit
decl_stmt|;
block|{
name|dw_die_ref
name|new_unit
init|=
name|old_unit
operator|->
name|die_sib
decl_stmt|;
name|old_unit
operator|->
name|die_sib
operator|=
name|NULL
expr_stmt|;
return|return
name|new_unit
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CHECKSUM
parameter_list|(
name|FOO
parameter_list|)
value|md5_process_bytes (&(FOO), sizeof (FOO), ctx)
end_define

begin_define
define|#
directive|define
name|CHECKSUM_STRING
parameter_list|(
name|FOO
parameter_list|)
value|md5_process_bytes ((FOO), strlen (FOO), ctx)
end_define

begin_comment
comment|/* Calculate the checksum of a location expression.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|loc_checksum
parameter_list|(
name|loc
parameter_list|,
name|ctx
parameter_list|)
name|dw_loc_descr_ref
name|loc
decl_stmt|;
name|struct
name|md5_ctx
modifier|*
name|ctx
decl_stmt|;
block|{
name|CHECKSUM
argument_list|(
name|loc
operator|->
name|dw_loc_opc
argument_list|)
expr_stmt|;
name|CHECKSUM
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd1
argument_list|)
expr_stmt|;
name|CHECKSUM
argument_list|(
name|loc
operator|->
name|dw_loc_oprnd2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate the checksum of an attribute.  */
end_comment

begin_function
specifier|static
name|void
name|attr_checksum
parameter_list|(
name|at
parameter_list|,
name|ctx
parameter_list|)
name|dw_attr_ref
name|at
decl_stmt|;
name|struct
name|md5_ctx
modifier|*
name|ctx
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|loc
decl_stmt|;
name|rtx
name|r
decl_stmt|;
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr
argument_list|)
expr_stmt|;
comment|/* We don't care about differences in file numbering.  */
if|if
condition|(
name|at
operator|->
name|dw_attr
operator|==
name|DW_AT_decl_file
comment|/* Or that this was compiled with a different compiler snapshot; if 	 the output is the same, that's what matters.  */
operator|||
name|at
operator|->
name|dw_attr
operator|==
name|DW_AT_producer
condition|)
return|return;
switch|switch
condition|(
name|AT_class
argument_list|(
name|at
argument_list|)
condition|)
block|{
case|case
name|dw_val_class_const
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_int
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_unsigned_const
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_unsigned
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_long_long
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_float
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_flag
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_flag
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_str
case|:
name|CHECKSUM_STRING
argument_list|(
name|AT_string
argument_list|(
name|at
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_addr
case|:
name|r
operator|=
name|AT_addr
argument_list|(
name|at
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
name|CHECKSUM_STRING
argument_list|(
name|XSTR
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_offset
case|:
name|CHECKSUM
argument_list|(
name|at
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc
case|:
for|for
control|(
name|loc
operator|=
name|AT_loc
argument_list|(
name|at
argument_list|)
init|;
name|loc
condition|;
name|loc
operator|=
name|loc
operator|->
name|dw_loc_next
control|)
name|loc_checksum
argument_list|(
name|loc
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_die_ref
case|:
if|if
condition|(
name|AT_ref
argument_list|(
name|at
argument_list|)
operator|->
name|die_offset
condition|)
name|CHECKSUM
argument_list|(
name|AT_ref
argument_list|(
name|at
argument_list|)
operator|->
name|die_offset
argument_list|)
expr_stmt|;
comment|/* FIXME else use target die name or something.  */
case|case
name|dw_val_class_fde_ref
case|:
case|case
name|dw_val_class_lbl_id
case|:
case|case
name|dw_val_class_lbl_offset
case|:
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Calculate the checksum of a DIE.  */
end_comment

begin_function
specifier|static
name|void
name|die_checksum
parameter_list|(
name|die
parameter_list|,
name|ctx
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|struct
name|md5_ctx
modifier|*
name|ctx
decl_stmt|;
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|dw_attr_ref
name|a
decl_stmt|;
name|CHECKSUM
argument_list|(
name|die
operator|->
name|die_tag
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
control|)
name|attr_checksum
argument_list|(
name|a
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|die_checksum
argument_list|(
name|c
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|CHECKSUM
end_undef

begin_undef
undef|#
directive|undef
name|CHECKSUM_STRING
end_undef

begin_comment
comment|/* The prefix to attach to symbols on DIEs in the current comdat debug    info section.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|comdat_symbol_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index of the current symbol within the current comdat CU.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|comdat_symbol_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Calculate the MD5 checksum of the compilation unit DIE UNIT_DIE and its    children, and set comdat_symbol_id accordingly.  */
end_comment

begin_function
specifier|static
name|void
name|compute_section_prefix
parameter_list|(
name|unit_die
parameter_list|)
name|dw_die_ref
name|unit_die
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|base
init|=
name|lbasename
argument_list|(
name|get_AT_string
argument_list|(
name|unit_die
argument_list|,
name|DW_AT_name
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|base
argument_list|)
operator|+
literal|64
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|checksum
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|md5_ctx
name|ctx
decl_stmt|;
comment|/* Compute the checksum of the DIE, then append part of it as hex digits to      the name filename of the unit.  */
name|md5_init_ctx
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|die_checksum
argument_list|(
name|unit_die
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|md5_finish_ctx
argument_list|(
operator|&
name|ctx
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s."
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|clean_symbol_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%.2x"
argument_list|,
name|checksum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|comdat_symbol_id
operator|=
name|unit_die
operator|->
name|die_symbol
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|comdat_symbol_number
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if DIE represents a type, in the sense of TYPE_P.  */
end_comment

begin_function
specifier|static
name|int
name|is_type_die
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
switch|switch
condition|(
name|die
operator|->
name|die_tag
condition|)
block|{
case|case
name|DW_TAG_array_type
case|:
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_enumeration_type
case|:
case|case
name|DW_TAG_pointer_type
case|:
case|case
name|DW_TAG_reference_type
case|:
case|case
name|DW_TAG_string_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_subroutine_type
case|:
case|case
name|DW_TAG_union_type
case|:
case|case
name|DW_TAG_ptr_to_member_type
case|:
case|case
name|DW_TAG_set_type
case|:
case|case
name|DW_TAG_subrange_type
case|:
case|case
name|DW_TAG_base_type
case|:
case|case
name|DW_TAG_const_type
case|:
case|case
name|DW_TAG_file_type
case|:
case|case
name|DW_TAG_packed_type
case|:
case|case
name|DW_TAG_volatile_type
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Returns 1 iff C is the sort of DIE that should go into a COMDAT CU.    Basically, we want to choose the bits that are likely to be shared between    compilations (types) and leave out the bits that are specific to individual    compilations (functions).  */
end_comment

begin_function
specifier|static
name|int
name|is_comdat_die
parameter_list|(
name|c
parameter_list|)
name|dw_die_ref
name|c
decl_stmt|;
block|{
comment|/* I think we want to leave base types and __vtbl_ptr_type in the main CU, as      we do for stabs.  The advantage is a greater likelihood of sharing between      objects that don't include headers in the same order (and therefore would      put the base types in a different comdat).  jason 8/28/00 */
if|if
condition|(
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_base_type
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_pointer_type
operator|||
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_reference_type
operator|||
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_const_type
operator|||
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_volatile_type
condition|)
block|{
name|dw_die_ref
name|t
init|=
name|get_AT_ref
argument_list|(
name|c
argument_list|,
name|DW_AT_type
argument_list|)
decl_stmt|;
return|return
name|t
condition|?
name|is_comdat_die
argument_list|(
name|t
argument_list|)
else|:
literal|0
return|;
block|}
return|return
name|is_type_die
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns 1 iff C is the sort of DIE that might be referred to from another    compilation unit.  */
end_comment

begin_function
specifier|static
name|int
name|is_symbol_die
parameter_list|(
name|c
parameter_list|)
name|dw_die_ref
name|c
decl_stmt|;
block|{
return|return
operator|(
name|is_type_die
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|get_AT
argument_list|(
name|c
argument_list|,
name|DW_AT_declaration
argument_list|)
operator|&&
operator|!
name|get_AT
argument_list|(
name|c
argument_list|,
name|DW_AT_specification
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|gen_internal_sym
parameter_list|(
name|prefix
parameter_list|)
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|int
name|label_num
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
name|prefix
argument_list|,
name|label_num
operator|++
argument_list|)
expr_stmt|;
return|return
name|xstrdup
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Assign symbols to all worthy DIEs under DIE.  */
end_comment

begin_function
specifier|static
name|void
name|assign_symbol_names
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_die_ref
name|c
decl_stmt|;
if|if
condition|(
name|is_symbol_die
argument_list|(
name|die
argument_list|)
condition|)
block|{
if|if
condition|(
name|comdat_symbol_id
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|comdat_symbol_id
argument_list|)
operator|+
literal|64
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s.%s.%x"
argument_list|,
name|DIE_LABEL_PREFIX
argument_list|,
name|comdat_symbol_id
argument_list|,
name|comdat_symbol_number
operator|++
argument_list|)
expr_stmt|;
name|die
operator|->
name|die_symbol
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|die
operator|->
name|die_symbol
operator|=
name|gen_internal_sym
argument_list|(
literal|"LDIE"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|assign_symbol_names
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Traverse the DIE (which is always comp_unit_die), and set up    additional compilation units for each of the include files we see    bracketed by BINCL/EINCL.  */
end_comment

begin_function
specifier|static
name|void
name|break_out_includes
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_die_ref
modifier|*
name|ptr
decl_stmt|;
name|dw_die_ref
name|unit
init|=
name|NULL
decl_stmt|;
name|limbo_die_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|ptr
operator|=
operator|&
operator|(
name|die
operator|->
name|die_child
operator|)
init|;
operator|*
name|ptr
condition|;
control|)
block|{
name|dw_die_ref
name|c
init|=
operator|*
name|ptr
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_GNU_BINCL
operator|||
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_GNU_EINCL
operator|||
operator|(
name|unit
operator|&&
name|is_comdat_die
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
comment|/* This DIE is for a secondary CU; remove it from the main one.  */
operator|*
name|ptr
operator|=
name|c
operator|->
name|die_sib
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_GNU_BINCL
condition|)
block|{
name|unit
operator|=
name|push_new_compile_unit
argument_list|(
name|unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|free_die
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|die_tag
operator|==
name|DW_TAG_GNU_EINCL
condition|)
block|{
name|unit
operator|=
name|pop_compile_unit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|free_die
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|add_child_die
argument_list|(
name|unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave this DIE in the main CU.  */
name|ptr
operator|=
operator|&
operator|(
name|c
operator|->
name|die_sib
operator|)
expr_stmt|;
continue|continue;
block|}
block|}
if|#
directive|if
literal|0
comment|/* We can only use this in debugging, since the frontend doesn't check      to make sure that we leave every include file we enter.  */
block|if (unit != NULL)     abort ();
endif|#
directive|endif
name|assign_symbol_names
argument_list|(
name|die
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|compute_section_prefix
argument_list|(
name|node
operator|->
name|die
argument_list|)
expr_stmt|;
name|assign_symbol_names
argument_list|(
name|node
operator|->
name|die
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Traverse the DIE and add a sibling attribute if it may have the    effect of speeding up access to siblings.  To save some space,    avoid generating sibling attributes for DIE's without children.  */
end_comment

begin_function
specifier|static
name|void
name|add_sibling_attributes
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_die_ref
name|c
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|die_tag
operator|!=
name|DW_TAG_compile_unit
operator|&&
name|die
operator|->
name|die_sib
operator|&&
name|die
operator|->
name|die_child
operator|!=
name|NULL
condition|)
comment|/* Add the sibling link to the front of the attribute list.  */
name|add_AT_die_ref
argument_list|(
name|die
argument_list|,
name|DW_AT_sibling
argument_list|,
name|die
operator|->
name|die_sib
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|add_sibling_attributes
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output all location lists for the DIE and its children.  */
end_comment

begin_function
specifier|static
name|void
name|output_location_lists
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|dw_attr_ref
name|d_attr
decl_stmt|;
for|for
control|(
name|d_attr
operator|=
name|die
operator|->
name|die_attr
init|;
name|d_attr
condition|;
name|d_attr
operator|=
name|d_attr
operator|->
name|dw_attr_next
control|)
if|if
condition|(
name|AT_class
argument_list|(
name|d_attr
argument_list|)
operator|==
name|dw_val_class_loc_list
condition|)
name|output_loc_list
argument_list|(
name|AT_loc_list
argument_list|(
name|d_attr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|output_location_lists
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The format of each DIE (and its attribute value pairs) is encoded in an    abbreviation table.  This routine builds the abbreviation table and assigns    a unique abbreviation id for each abbreviation entry.  The children of each    die are visited recursively.  */
end_comment

begin_function
specifier|static
name|void
name|build_abbrev_table
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|unsigned
name|long
name|abbrev_id
decl_stmt|;
name|unsigned
name|int
name|n_alloc
decl_stmt|;
name|dw_die_ref
name|c
decl_stmt|;
name|dw_attr_ref
name|d_attr
decl_stmt|,
name|a_attr
decl_stmt|;
comment|/* Scan the DIE references, and mark as external any that refer to      DIEs from other CUs (i.e. those which are not marked).  */
for|for
control|(
name|d_attr
operator|=
name|die
operator|->
name|die_attr
init|;
name|d_attr
condition|;
name|d_attr
operator|=
name|d_attr
operator|->
name|dw_attr_next
control|)
if|if
condition|(
name|AT_class
argument_list|(
name|d_attr
argument_list|)
operator|==
name|dw_val_class_die_ref
operator|&&
name|AT_ref
argument_list|(
name|d_attr
argument_list|)
operator|->
name|die_mark
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|AT_ref
argument_list|(
name|d_attr
argument_list|)
operator|->
name|die_symbol
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|set_AT_ref_external
argument_list|(
name|d_attr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|abbrev_id
operator|=
literal|1
init|;
name|abbrev_id
operator|<
name|abbrev_die_table_in_use
condition|;
operator|++
name|abbrev_id
control|)
block|{
name|dw_die_ref
name|abbrev
init|=
name|abbrev_die_table
index|[
name|abbrev_id
index|]
decl_stmt|;
if|if
condition|(
name|abbrev
operator|->
name|die_tag
operator|==
name|die
operator|->
name|die_tag
condition|)
block|{
if|if
condition|(
operator|(
name|abbrev
operator|->
name|die_child
operator|!=
name|NULL
operator|)
operator|==
operator|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
operator|)
condition|)
block|{
name|a_attr
operator|=
name|abbrev
operator|->
name|die_attr
expr_stmt|;
name|d_attr
operator|=
name|die
operator|->
name|die_attr
expr_stmt|;
while|while
condition|(
name|a_attr
operator|!=
name|NULL
operator|&&
name|d_attr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|a_attr
operator|->
name|dw_attr
operator|!=
name|d_attr
operator|->
name|dw_attr
operator|)
operator|||
operator|(
name|value_format
argument_list|(
name|a_attr
argument_list|)
operator|!=
name|value_format
argument_list|(
name|d_attr
argument_list|)
operator|)
condition|)
break|break;
name|a_attr
operator|=
name|a_attr
operator|->
name|dw_attr_next
expr_stmt|;
name|d_attr
operator|=
name|d_attr
operator|->
name|dw_attr_next
expr_stmt|;
block|}
if|if
condition|(
name|a_attr
operator|==
name|NULL
operator|&&
name|d_attr
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|abbrev_id
operator|>=
name|abbrev_die_table_in_use
condition|)
block|{
if|if
condition|(
name|abbrev_die_table_in_use
operator|>=
name|abbrev_die_table_allocated
condition|)
block|{
name|n_alloc
operator|=
name|abbrev_die_table_allocated
operator|+
name|ABBREV_DIE_TABLE_INCREMENT
expr_stmt|;
name|abbrev_die_table
operator|=
operator|(
name|dw_die_ref
operator|*
operator|)
name|xrealloc
argument_list|(
name|abbrev_die_table
argument_list|,
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
operator|*
name|n_alloc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|abbrev_die_table
index|[
name|abbrev_die_table_allocated
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|n_alloc
operator|-
name|abbrev_die_table_allocated
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|abbrev_die_table_allocated
operator|=
name|n_alloc
expr_stmt|;
block|}
operator|++
name|abbrev_die_table_in_use
expr_stmt|;
name|abbrev_die_table
index|[
name|abbrev_id
index|]
operator|=
name|die
expr_stmt|;
block|}
name|die
operator|->
name|die_abbrev
operator|=
name|abbrev_id
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|build_abbrev_table
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the power-of-two number of bytes necessary to represent VALUE.  */
end_comment

begin_function
specifier|static
name|int
name|constant_size
parameter_list|(
name|value
parameter_list|)
name|long
name|unsigned
name|value
decl_stmt|;
block|{
name|int
name|log
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|log
operator|=
literal|0
expr_stmt|;
else|else
name|log
operator|=
name|floor_log2
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|log
operator|=
name|log
operator|/
literal|8
expr_stmt|;
name|log
operator|=
literal|1
operator|<<
operator|(
name|floor_log2
argument_list|(
name|log
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
return|return
name|log
return|;
block|}
end_function

begin_comment
comment|/* Return the size of a DIE as it is represented in the    .debug_info section.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_die
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|unsigned
name|long
name|size
init|=
literal|0
decl_stmt|;
name|dw_attr_ref
name|a
decl_stmt|;
name|size
operator|+=
name|size_of_uleb128
argument_list|(
name|die
operator|->
name|die_abbrev
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
control|)
block|{
switch|switch
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
name|size
operator|+=
name|DWARF2_ADDR_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_offset
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc
case|:
block|{
name|unsigned
name|long
name|lsize
init|=
name|size_of_locs
argument_list|(
name|AT_loc
argument_list|(
name|a
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Block length.  */
name|size
operator|+=
name|constant_size
argument_list|(
name|lsize
argument_list|)
expr_stmt|;
name|size
operator|+=
name|lsize
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_loc_list
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_range_list
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_const
case|:
name|size
operator|+=
name|size_of_sleb128
argument_list|(
name|AT_int
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_unsigned_const
case|:
name|size
operator|+=
name|constant_size
argument_list|(
name|AT_unsigned
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_long_long
case|:
name|size
operator|+=
literal|1
operator|+
literal|2
operator|*
name|HOST_BITS_PER_LONG
operator|/
name|HOST_BITS_PER_CHAR
expr_stmt|;
comment|/* block */
break|break;
case|case
name|dw_val_class_float
case|:
name|size
operator|+=
literal|1
operator|+
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|length
operator|*
literal|4
expr_stmt|;
comment|/* block */
break|break;
case|case
name|dw_val_class_flag
case|:
name|size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|dw_val_class_die_ref
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_fde_ref
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_lbl_id
case|:
name|size
operator|+=
name|DWARF2_ADDR_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_lbl_offset
case|:
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
break|break;
case|case
name|dw_val_class_str
case|:
if|if
condition|(
name|AT_string_form
argument_list|(
name|a
argument_list|)
operator|==
name|DW_FORM_strp
condition|)
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
else|else
name|size
operator|+=
name|HT_LEN
argument_list|(
operator|&
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|->
name|id
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Size the debugging information associated with a given DIE.  Visits the    DIE's children recursively.  Updates the global variable next_die_offset, on    each time through.  Uses the current value of next_die_offset to update the    die_offset field in each DIE.  */
end_comment

begin_function
specifier|static
name|void
name|calc_die_sizes
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|die
operator|->
name|die_offset
operator|=
name|next_die_offset
expr_stmt|;
name|next_die_offset
operator|+=
name|size_of_die
argument_list|(
name|die
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|calc_die_sizes
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
condition|)
comment|/* Count the null byte used to terminate sibling lists.  */
name|next_die_offset
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the marks for a die and its children.  We do this so    that we know whether or not a reference needs to use FORM_ref_addr; only    DIEs in the same CU will be marked.  We used to clear out the offset    and use that as the flag, but ran into ordering problems.  */
end_comment

begin_function
specifier|static
name|void
name|mark_dies
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|die
operator|->
name|die_mark
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|mark_dies
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the marks for a die and its children.  */
end_comment

begin_function
specifier|static
name|void
name|unmark_dies
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_die_ref
name|c
decl_stmt|;
name|die
operator|->
name|die_mark
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|unmark_dies
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the size of the .debug_pubnames table  generated for the    compilation unit.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_pubnames
parameter_list|()
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|size
operator|=
name|DWARF_PUBNAMES_HEADER_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pubname_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|pubname_ref
name|p
init|=
operator|&
name|pubname_table
index|[
name|i
index|]
decl_stmt|;
name|size
operator|+=
name|DWARF_OFFSET_SIZE
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|size
operator|+=
name|DWARF_OFFSET_SIZE
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the information in the .debug_aranges section.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|size_of_aranges
parameter_list|()
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|size
operator|=
name|DWARF_ARANGES_HEADER_SIZE
expr_stmt|;
comment|/* Count the address/length pair for this compilation unit.  */
name|size
operator|+=
literal|2
operator|*
name|DWARF2_ADDR_SIZE
expr_stmt|;
name|size
operator|+=
literal|2
operator|*
name|DWARF2_ADDR_SIZE
operator|*
name|arange_table_in_use
expr_stmt|;
comment|/* Count the two zero words used to terminated the address range table.  */
name|size
operator|+=
literal|2
operator|*
name|DWARF2_ADDR_SIZE
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Select the encoding of an attribute value.  */
end_comment

begin_function
specifier|static
name|enum
name|dwarf_form
name|value_format
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
switch|switch
condition|(
name|a
operator|->
name|dw_attr_val
operator|.
name|val_class
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
return|return
name|DW_FORM_addr
return|;
case|case
name|dw_val_class_range_list
case|:
case|case
name|dw_val_class_offset
case|:
if|if
condition|(
name|DWARF_OFFSET_SIZE
operator|==
literal|4
condition|)
return|return
name|DW_FORM_data4
return|;
if|if
condition|(
name|DWARF_OFFSET_SIZE
operator|==
literal|8
condition|)
return|return
name|DW_FORM_data8
return|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|dw_val_class_loc_list
case|:
comment|/* FIXME: Could be DW_FORM_data8, with a> 32 bit size 	 .debug_loc section */
return|return
name|DW_FORM_data4
return|;
case|case
name|dw_val_class_loc
case|:
switch|switch
condition|(
name|constant_size
argument_list|(
name|size_of_locs
argument_list|(
name|AT_loc
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|DW_FORM_block1
return|;
case|case
literal|2
case|:
return|return
name|DW_FORM_block2
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|dw_val_class_const
case|:
return|return
name|DW_FORM_sdata
return|;
case|case
name|dw_val_class_unsigned_const
case|:
switch|switch
condition|(
name|constant_size
argument_list|(
name|AT_unsigned
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
return|return
name|DW_FORM_data1
return|;
case|case
literal|2
case|:
return|return
name|DW_FORM_data2
return|;
case|case
literal|4
case|:
return|return
name|DW_FORM_data4
return|;
case|case
literal|8
case|:
return|return
name|DW_FORM_data8
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
case|case
name|dw_val_class_long_long
case|:
return|return
name|DW_FORM_block1
return|;
case|case
name|dw_val_class_float
case|:
return|return
name|DW_FORM_block1
return|;
case|case
name|dw_val_class_flag
case|:
return|return
name|DW_FORM_flag
return|;
case|case
name|dw_val_class_die_ref
case|:
if|if
condition|(
name|AT_ref_external
argument_list|(
name|a
argument_list|)
condition|)
return|return
name|DW_FORM_ref_addr
return|;
else|else
return|return
name|DW_FORM_ref
return|;
case|case
name|dw_val_class_fde_ref
case|:
return|return
name|DW_FORM_data
return|;
case|case
name|dw_val_class_lbl_id
case|:
return|return
name|DW_FORM_addr
return|;
case|case
name|dw_val_class_lbl_offset
case|:
return|return
name|DW_FORM_data
return|;
case|case
name|dw_val_class_str
case|:
return|return
name|AT_string_form
argument_list|(
name|a
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the encoding of an attribute value.  */
end_comment

begin_function
specifier|static
name|void
name|output_value_format
parameter_list|(
name|a
parameter_list|)
name|dw_attr_ref
name|a
decl_stmt|;
block|{
name|enum
name|dwarf_form
name|form
init|=
name|value_format
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|form
argument_list|,
literal|"(%s)"
argument_list|,
name|dwarf_form_name
argument_list|(
name|form
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the .debug_abbrev section which defines the DIE abbreviation    table.  */
end_comment

begin_function
specifier|static
name|void
name|output_abbrev_section
parameter_list|()
block|{
name|unsigned
name|long
name|abbrev_id
decl_stmt|;
name|dw_attr_ref
name|a_attr
decl_stmt|;
for|for
control|(
name|abbrev_id
operator|=
literal|1
init|;
name|abbrev_id
operator|<
name|abbrev_die_table_in_use
condition|;
operator|++
name|abbrev_id
control|)
block|{
name|dw_die_ref
name|abbrev
init|=
name|abbrev_die_table
index|[
name|abbrev_id
index|]
decl_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|abbrev_id
argument_list|,
literal|"(abbrev code)"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|abbrev
operator|->
name|die_tag
argument_list|,
literal|"(TAG: %s)"
argument_list|,
name|dwarf_tag_name
argument_list|(
name|abbrev
operator|->
name|die_tag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abbrev
operator|->
name|die_child
operator|!=
name|NULL
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_children_yes
argument_list|,
literal|"DW_children_yes"
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_children_no
argument_list|,
literal|"DW_children_no"
argument_list|)
expr_stmt|;
for|for
control|(
name|a_attr
operator|=
name|abbrev
operator|->
name|die_attr
init|;
name|a_attr
operator|!=
name|NULL
condition|;
name|a_attr
operator|=
name|a_attr
operator|->
name|dw_attr_next
control|)
block|{
name|dw2_asm_output_data_uleb128
argument_list|(
name|a_attr
operator|->
name|dw_attr
argument_list|,
literal|"(%s)"
argument_list|,
name|dwarf_attr_name
argument_list|(
name|a_attr
operator|->
name|dw_attr
argument_list|)
argument_list|)
expr_stmt|;
name|output_value_format
argument_list|(
name|a_attr
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Terminate the table.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a symbol we can use to refer to this DIE from another CU.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|output_die_symbol
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|char
modifier|*
name|sym
init|=
name|die
operator|->
name|die_symbol
decl_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|strncmp
argument_list|(
name|sym
argument_list|,
name|DIE_LABEL_PREFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|DIE_LABEL_PREFIX
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* We make these global, not weak; if the target doesn't support        .linkonce, it doesn't support combining the sections, so debugging        will break.  */
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a new location list, given the begin and end range, and the    expression. gensym tells us whether to generate a new internal symbol for    this location list node, which is done for the head of the list only.  */
end_comment

begin_function
specifier|static
specifier|inline
name|dw_loc_list_ref
name|new_loc_list
parameter_list|(
name|expr
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|,
name|section
parameter_list|,
name|gensym
parameter_list|)
name|dw_loc_descr_ref
name|expr
decl_stmt|;
specifier|const
name|char
modifier|*
name|begin
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
specifier|const
name|char
modifier|*
name|section
decl_stmt|;
name|unsigned
name|gensym
decl_stmt|;
block|{
name|dw_loc_list_ref
name|retlist
init|=
operator|(
name|dw_loc_list_ref
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|dw_loc_list_node
argument_list|)
argument_list|)
decl_stmt|;
name|retlist
operator|->
name|begin
operator|=
name|begin
expr_stmt|;
name|retlist
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|retlist
operator|->
name|expr
operator|=
name|expr
expr_stmt|;
name|retlist
operator|->
name|section
operator|=
name|section
expr_stmt|;
if|if
condition|(
name|gensym
condition|)
name|retlist
operator|->
name|ll_symbol
operator|=
name|gen_internal_sym
argument_list|(
literal|"LLST"
argument_list|)
expr_stmt|;
return|return
name|retlist
return|;
block|}
end_function

begin_comment
comment|/* Add a location description expression to a location list */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_loc_descr_to_loc_list
parameter_list|(
name|list_head
parameter_list|,
name|descr
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|,
name|section
parameter_list|)
name|dw_loc_list_ref
modifier|*
name|list_head
decl_stmt|;
name|dw_loc_descr_ref
name|descr
decl_stmt|;
specifier|const
name|char
modifier|*
name|begin
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
specifier|const
name|char
modifier|*
name|section
decl_stmt|;
block|{
name|dw_loc_list_ref
modifier|*
name|d
decl_stmt|;
comment|/* Find the end of the chain.  */
for|for
control|(
name|d
operator|=
name|list_head
init|;
operator|(
operator|*
name|d
operator|)
operator|!=
name|NULL
condition|;
name|d
operator|=
operator|&
operator|(
operator|*
name|d
operator|)
operator|->
name|dw_loc_next
control|)
empty_stmt|;
comment|/* Add a new location list node to the list */
operator|*
name|d
operator|=
name|new_loc_list
argument_list|(
name|descr
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|section
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the location list given to us */
end_comment

begin_function
specifier|static
name|void
name|output_loc_list
parameter_list|(
name|list_head
parameter_list|)
name|dw_loc_list_ref
name|list_head
decl_stmt|;
block|{
name|dw_loc_list_ref
name|curr
init|=
name|list_head
decl_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
comment|/* ??? This shouldn't be needed now that we've forced the      compilation unit base address to zero when there is code      in more than one section.  */
if|if
condition|(
name|strcmp
argument_list|(
name|curr
operator|->
name|section
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* dw2_asm_output_data will mask off any extra bits in the ~0.  */
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
operator|~
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
argument_list|,
literal|"Location list base address specifier fake entry"
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|curr
operator|->
name|section
argument_list|,
literal|"Location list base address specifier base"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|curr
operator|=
name|list_head
init|;
name|curr
operator|!=
name|NULL
condition|;
name|curr
operator|=
name|curr
operator|->
name|dw_loc_next
control|)
block|{
name|unsigned
name|long
name|size
decl_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|curr
operator|->
name|begin
argument_list|,
name|curr
operator|->
name|section
argument_list|,
literal|"Location list begin address (%s)"
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|curr
operator|->
name|end
argument_list|,
name|curr
operator|->
name|section
argument_list|,
literal|"Location list end address (%s)"
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
name|size
operator|=
name|size_of_locs
argument_list|(
name|curr
operator|->
name|expr
argument_list|)
expr_stmt|;
comment|/* Output the block length for this list of location operations.  */
if|if
condition|(
name|size
operator|>
literal|0xffff
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|size
argument_list|,
literal|"%s"
argument_list|,
literal|"Location expression size"
argument_list|)
expr_stmt|;
name|output_loc_sequence
argument_list|(
name|curr
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
literal|0
argument_list|,
literal|"Location list terminator begin (%s)"
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
literal|0
argument_list|,
literal|"Location list terminator end (%s)"
argument_list|,
name|list_head
operator|->
name|ll_symbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the DIE and its attributes.  Called recursively to generate    the definitions of each child DIE.  */
end_comment

begin_function
specifier|static
name|void
name|output_die
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|dw_attr_ref
name|a
decl_stmt|;
name|dw_die_ref
name|c
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
comment|/* If someone in another CU might refer to us, set up a symbol for      them to point to.  */
if|if
condition|(
name|die
operator|->
name|die_symbol
condition|)
name|output_die_symbol
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|die
operator|->
name|die_abbrev
argument_list|,
literal|"(DIE (0x%lx) %s)"
argument_list|,
name|die
operator|->
name|die_offset
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|die_tag
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|die
operator|->
name|die_attr
init|;
name|a
operator|!=
name|NULL
condition|;
name|a
operator|=
name|a
operator|->
name|dw_attr_next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|dwarf_attr_name
argument_list|(
name|a
operator|->
name|dw_attr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|AT_class
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|dw_val_class_addr
case|:
name|dw2_asm_output_addr_rtx
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|AT_addr
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_offset
case|:
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_offset
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_range_list
case|:
block|{
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|ranges_section_label
argument_list|,
literal|'\0'
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"+0x%lx"
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_offset
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|ranges_section_label
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_loc
case|:
name|size
operator|=
name|size_of_locs
argument_list|(
name|AT_loc
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the block length for this list of location operations.  */
name|dw2_asm_output_data
argument_list|(
name|constant_size
argument_list|(
name|size
argument_list|)
argument_list|,
name|size
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|output_loc_sequence
argument_list|(
name|AT_loc
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_const
case|:
comment|/* ??? It would be slightly more efficient to use a scheme like is 	     used for unsigned constants below, but gdb 4.x does not sign 	     extend.  Gdb 5.x does sign extend.  */
name|dw2_asm_output_data_sleb128
argument_list|(
name|AT_int
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_unsigned_const
case|:
name|dw2_asm_output_data
argument_list|(
name|constant_size
argument_list|(
name|AT_unsigned
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|,
name|AT_unsigned
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_long_long
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|first
decl_stmt|,
name|second
decl_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|2
operator|*
name|HOST_BITS_PER_LONG
operator|/
name|HOST_BITS_PER_CHAR
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
block|{
name|first
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
expr_stmt|;
name|second
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|low
expr_stmt|;
name|second
operator|=
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_long_long
operator|.
name|hi
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
name|HOST_BITS_PER_LONG
operator|/
name|HOST_BITS_PER_CHAR
argument_list|,
name|first
argument_list|,
literal|"long long constant"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|HOST_BITS_PER_LONG
operator|/
name|HOST_BITS_PER_CHAR
argument_list|,
name|second
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_float
case|:
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|length
operator|*
literal|4
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|length
condition|;
name|i
operator|++
control|)
name|dw2_asm_output_data
argument_list|(
literal|4
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_float
operator|.
name|array
index|[
name|i
index|]
argument_list|,
literal|"fp constant word %u"
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|dw_val_class_flag
case|:
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|AT_flag
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_loc_list
case|:
block|{
name|char
modifier|*
name|sym
init|=
name|AT_loc_list
argument_list|(
name|a
argument_list|)
operator|->
name|ll_symbol
decl_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|sym
argument_list|,
name|loc_section_label
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_die_ref
case|:
if|if
condition|(
name|AT_ref_external
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|char
modifier|*
name|sym
init|=
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_symbol
decl_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|sym
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_offset
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|AT_ref
argument_list|(
name|a
argument_list|)
operator|->
name|die_offset
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_fde_ref
case|:
block|{
name|char
name|l1
index|[
literal|20
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
name|FDE_LABEL
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_fde_index
operator|*
literal|2
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|l1
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|dw_val_class_lbl_id
case|:
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|AT_lbl
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_lbl_offset
case|:
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|AT_lbl
argument_list|(
name|a
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|dw_val_class_str
case|:
if|if
condition|(
name|AT_string_form
argument_list|(
name|a
argument_list|)
operator|==
name|DW_FORM_strp
condition|)
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|a
operator|->
name|dw_attr_val
operator|.
name|v
operator|.
name|val_str
operator|->
name|label
argument_list|,
literal|"%s: \"%s\""
argument_list|,
name|name
argument_list|,
name|AT_string
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dw2_asm_output_nstring
argument_list|(
name|AT_string
argument_list|(
name|a
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
for|for
control|(
name|c
operator|=
name|die
operator|->
name|die_child
init|;
name|c
operator|!=
name|NULL
condition|;
name|c
operator|=
name|c
operator|->
name|die_sib
control|)
name|output_die
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Add null byte to terminate sibling list.  */
if|if
condition|(
name|die
operator|->
name|die_child
operator|!=
name|NULL
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"end of children of DIE 0x%lx"
argument_list|,
name|die
operator|->
name|die_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the compilation unit that appears at the beginning of the    .debug_info section, and precedes the DIE descriptions.  */
end_comment

begin_function
specifier|static
name|void
name|output_compilation_unit_header
parameter_list|()
block|{
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|next_die_offset
operator|-
name|DWARF_OFFSET_SIZE
argument_list|,
literal|"Length of Compilation Unit Info"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|DWARF_VERSION
argument_list|,
literal|"DWARF version number"
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|abbrev_section_label
argument_list|,
literal|"Offset Into Abbrev. Section"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF2_ADDR_SIZE
argument_list|,
literal|"Pointer Size (in bytes)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the compilation unit DIE and its children.  */
end_comment

begin_function
specifier|static
name|void
name|output_comp_unit
parameter_list|(
name|die
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|secname
decl_stmt|;
comment|/* Even if there are no children of this DIE, we must output the information      about the compilation unit.  Otherwise, on an empty translation unit, we      will generate a present, but empty, .debug_info section.  IRIX 6.5 `nm'      will then complain when examining the file.  First mark all the DIEs in      this CU so we know which get local refs.  */
name|mark_dies
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|build_abbrev_table
argument_list|(
name|die
argument_list|)
expr_stmt|;
comment|/* Initialize the beginning DIE offset - and calculate sizes/offsets.  */
name|next_die_offset
operator|=
name|DWARF_COMPILE_UNIT_HEADER_SIZE
expr_stmt|;
name|calc_die_sizes
argument_list|(
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_symbol
condition|)
block|{
name|char
modifier|*
name|tmp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|die
operator|->
name|die_symbol
argument_list|)
operator|+
literal|24
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|".gnu.linkonce.wi.%s"
argument_list|,
name|die
operator|->
name|die_symbol
argument_list|)
expr_stmt|;
name|secname
operator|=
name|tmp
expr_stmt|;
name|die
operator|->
name|die_symbol
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|secname
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|DEBUG_INFO_SECTION
expr_stmt|;
comment|/* Output debugging information.  */
name|named_section_flags
argument_list|(
name|secname
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|output_compilation_unit_header
argument_list|()
expr_stmt|;
name|output_die
argument_list|(
name|die
argument_list|)
expr_stmt|;
comment|/* Leave the marks on the main CU, so we can check them in      output_pubnames.  */
if|if
condition|(
name|die
operator|->
name|die_symbol
condition|)
name|unmark_dies
argument_list|(
name|die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The DWARF2 pubname for a nested thingy looks like "A::f".  The output    of decl_printable_name for C++ looks like "A::f(int)".  Let's drop the    argument list, and maybe the scope.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|dwarf2_name
parameter_list|(
name|decl
parameter_list|,
name|scope
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|scope
decl_stmt|;
block|{
return|return
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|decl
argument_list|,
name|scope
condition|?
literal|1
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a new entry to .debug_pubnames if appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|add_pubname
parameter_list|(
name|decl
parameter_list|,
name|die
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|dw_die_ref
name|die
decl_stmt|;
block|{
name|pubname_ref
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|pubname_table_in_use
operator|==
name|pubname_table_allocated
condition|)
block|{
name|pubname_table_allocated
operator|+=
name|PUBNAME_TABLE_INCREMENT
expr_stmt|;
name|pubname_table
operator|=
operator|(
name|pubname_ref
operator|)
name|xrealloc
argument_list|(
name|pubname_table
argument_list|,
operator|(
name|pubname_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|pubname_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
operator|&
name|pubname_table
index|[
name|pubname_table_in_use
operator|++
index|]
expr_stmt|;
name|p
operator|->
name|die
operator|=
name|die
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|dwarf2_name
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the public names table used to speed up access to externally    visible names.  For now, only generate entries for externally    visible procedures.  */
end_comment

begin_function
specifier|static
name|void
name|output_pubnames
parameter_list|()
block|{
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|long
name|pubnames_length
init|=
name|size_of_pubnames
argument_list|()
decl_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|pubnames_length
argument_list|,
literal|"Length of Public Names Info"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|DWARF_VERSION
argument_list|,
literal|"DWARF Version"
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|debug_info_section_label
argument_list|,
literal|"Offset of Compilation Unit Info"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|next_die_offset
argument_list|,
literal|"Compilation Unit Length"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pubname_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|pubname_ref
name|pub
init|=
operator|&
name|pubname_table
index|[
name|i
index|]
decl_stmt|;
comment|/* We shouldn't see pubnames for DIEs outside of the main CU.  */
if|if
condition|(
name|pub
operator|->
name|die
operator|->
name|die_mark
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|pub
operator|->
name|die
operator|->
name|die_offset
argument_list|,
literal|"DIE offset"
argument_list|)
expr_stmt|;
name|dw2_asm_output_nstring
argument_list|(
name|pub
operator|->
name|name
argument_list|,
operator|-
literal|1
argument_list|,
literal|"external name"
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new entry to .debug_aranges if appropriate.  */
end_comment

begin_function
specifier|static
name|void
name|add_arange
parameter_list|(
name|decl
parameter_list|,
name|die
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|dw_die_ref
name|die
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
if|if
condition|(
name|arange_table_in_use
operator|==
name|arange_table_allocated
condition|)
block|{
name|arange_table_allocated
operator|+=
name|ARANGE_TABLE_INCREMENT
expr_stmt|;
name|arange_table
operator|=
operator|(
name|dw_die_ref
operator|*
operator|)
name|xrealloc
argument_list|(
name|arange_table
argument_list|,
name|arange_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arange_table
index|[
name|arange_table_in_use
operator|++
index|]
operator|=
name|die
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the information that goes into the .debug_aranges table.    Namely, define the beginning and ending address range of the    text section generated for this compilation unit.  */
end_comment

begin_function
specifier|static
name|void
name|output_aranges
parameter_list|()
block|{
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|long
name|aranges_length
init|=
name|size_of_aranges
argument_list|()
decl_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|aranges_length
argument_list|,
literal|"Length of Address Ranges Info"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|DWARF_VERSION
argument_list|,
literal|"DWARF Version"
argument_list|)
expr_stmt|;
name|dw2_asm_output_offset
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|debug_info_section_label
argument_list|,
literal|"Offset of Compilation Unit Info"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF2_ADDR_SIZE
argument_list|,
literal|"Size of Address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Size of Segment Descriptor"
argument_list|)
expr_stmt|;
comment|/* We need to align to twice the pointer size here.  */
if|if
condition|(
name|DWARF_ARANGES_PAD_SIZE
condition|)
block|{
comment|/* Pad using a 2 byte words so that padding is correct for any          pointer size.  */
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Pad to %d byte boundary"
argument_list|,
literal|2
operator|*
name|DWARF2_ADDR_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|DWARF_ARANGES_PAD_SIZE
condition|;
name|i
operator|+=
literal|2
control|)
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|text_section_label
argument_list|,
literal|"Address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|text_end_label
argument_list|,
name|text_section_label
argument_list|,
literal|"Length"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arange_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|dw_die_ref
name|die
init|=
name|arange_table
index|[
name|i
index|]
decl_stmt|;
comment|/* We shouldn't see aranges for DIEs outside of the main CU.  */
if|if
condition|(
name|die
operator|->
name|die_mark
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|get_AT_low_pc
argument_list|(
name|die
argument_list|)
argument_list|,
literal|"Address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|get_AT_hi_pc
argument_list|(
name|die
argument_list|)
argument_list|,
name|get_AT_low_pc
argument_list|(
name|die
argument_list|)
argument_list|,
literal|"Length"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A static variable; extract the symbol from DW_AT_location. 	     Note that this code isn't currently hit, as we only emit 	     aranges for functions (jason 9/23/99).  */
name|dw_attr_ref
name|a
init|=
name|get_AT
argument_list|(
name|die
argument_list|,
name|DW_AT_location
argument_list|)
decl_stmt|;
name|dw_loc_descr_ref
name|loc
decl_stmt|;
if|if
condition|(
operator|!
name|a
operator|||
name|AT_class
argument_list|(
name|a
argument_list|)
operator|!=
name|dw_val_class_loc
condition|)
name|abort
argument_list|()
expr_stmt|;
name|loc
operator|=
name|AT_loc
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|->
name|dw_loc_opc
operator|!=
name|DW_OP_addr
condition|)
name|abort
argument_list|()
expr_stmt|;
name|dw2_asm_output_addr_rtx
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|loc
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_addr
argument_list|,
literal|"Address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|get_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|)
argument_list|,
literal|"Length"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output the terminator words.  */
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a new entry to .debug_ranges.  Return the offset at which it    was placed.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|add_ranges
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|unsigned
name|int
name|in_use
init|=
name|ranges_table_in_use
decl_stmt|;
if|if
condition|(
name|in_use
operator|==
name|ranges_table_allocated
condition|)
block|{
name|ranges_table_allocated
operator|+=
name|RANGES_TABLE_INCREMENT
expr_stmt|;
name|ranges_table
operator|=
operator|(
name|dw_ranges_ref
operator|)
name|xrealloc
argument_list|(
name|ranges_table
argument_list|,
operator|(
name|ranges_table_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dw_ranges_struct
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|ranges_table
index|[
name|in_use
index|]
operator|.
name|block_num
operator|=
operator|(
name|block
condition|?
name|BLOCK_NUMBER
argument_list|(
name|block
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|ranges_table_in_use
operator|=
name|in_use
operator|+
literal|1
expr_stmt|;
return|return
name|in_use
operator|*
literal|2
operator|*
name|DWARF2_ADDR_SIZE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_ranges
parameter_list|()
block|{
name|unsigned
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|start_fmt
init|=
literal|"Offset 0x%x"
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
init|=
name|start_fmt
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ranges_table_in_use
condition|;
name|i
operator|++
control|)
block|{
name|int
name|block_num
init|=
name|ranges_table
index|[
name|i
index|]
operator|.
name|block_num
decl_stmt|;
if|if
condition|(
name|block_num
condition|)
block|{
name|char
name|blabel
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|elabel
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|blabel
argument_list|,
name|BLOCK_BEGIN_LABEL
argument_list|,
name|block_num
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|elabel
argument_list|,
name|BLOCK_END_LABEL
argument_list|,
name|block_num
argument_list|)
expr_stmt|;
comment|/* If all code is in the text section, then the compilation 	     unit base address defaults to DW_AT_low_pc, which is the 	     base of the text section.  */
if|if
condition|(
name|separate_line_info_table_in_use
operator|==
literal|0
condition|)
block|{
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|blabel
argument_list|,
name|text_section_label
argument_list|,
name|fmt
argument_list|,
name|i
operator|*
literal|2
operator|*
name|DWARF2_ADDR_SIZE
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|elabel
argument_list|,
name|text_section_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, we add a DW_AT_entry_pc attribute to force the 	     compilation unit base address to zero, which allows us to 	     use absolute addresses, and not worry about whether the 	     target supports cross-section arithmetic.  */
else|else
block|{
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|blabel
argument_list|,
name|fmt
argument_list|,
name|i
operator|*
literal|2
operator|*
name|DWARF2_ADDR_SIZE
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|elabel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|fmt
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|start_fmt
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Data structure containing information about input files.  */
end_comment

begin_struct
struct|struct
name|file_info
block|{
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Complete file name.  */
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* File name part.  */
name|int
name|length
decl_stmt|;
comment|/* Length of entire string.  */
name|int
name|file_idx
decl_stmt|;
comment|/* Index in input file table.  */
name|int
name|dir_idx
decl_stmt|;
comment|/* Index in directory table.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Data structure containing information about directories with source    files.  */
end_comment

begin_struct
struct|struct
name|dir_info
block|{
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Path including directory name.  */
name|int
name|length
decl_stmt|;
comment|/* Path length.  */
name|int
name|prefix
decl_stmt|;
comment|/* Index of directory entry which is a prefix.  */
name|int
name|count
decl_stmt|;
comment|/* Number of files in this directory.  */
name|int
name|dir_idx
decl_stmt|;
comment|/* Index of directory used as base.  */
name|int
name|used
decl_stmt|;
comment|/* Used in the end?  */
block|}
struct|;
end_struct

begin_comment
comment|/* Callback function for file_info comparison.  We sort by looking at    the directories in the path.  */
end_comment

begin_function
specifier|static
name|int
name|file_info_cmp
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
specifier|const
name|void
modifier|*
name|p1
decl_stmt|;
specifier|const
name|void
modifier|*
name|p2
decl_stmt|;
block|{
specifier|const
name|struct
name|file_info
modifier|*
name|s1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|file_info
modifier|*
name|s2
init|=
name|p2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cp1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cp2
decl_stmt|;
comment|/* Take care of file names without directories.  We need to make sure that      we return consistent values to qsort since some will get confused if      we return the same value when identical operands are passed in opposite      orders.  So if neither has a directory, return 0 and otherwise return      1 or -1 depending on which one has the directory.  */
if|if
condition|(
operator|(
name|s1
operator|->
name|path
operator|==
name|s1
operator|->
name|fname
operator|||
name|s2
operator|->
name|path
operator|==
name|s2
operator|->
name|fname
operator|)
condition|)
return|return
operator|(
name|s2
operator|->
name|path
operator|==
name|s2
operator|->
name|fname
operator|)
operator|-
operator|(
name|s1
operator|->
name|path
operator|==
name|s1
operator|->
name|fname
operator|)
return|;
name|cp1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s1
operator|->
name|path
expr_stmt|;
name|cp2
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s2
operator|->
name|path
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
operator|++
name|cp1
expr_stmt|;
operator|++
name|cp2
expr_stmt|;
comment|/* Reached the end of the first path?  If so, handle like above.  */
if|if
condition|(
operator|(
name|cp1
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s1
operator|->
name|fname
operator|)
operator|||
operator|(
name|cp2
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s2
operator|->
name|fname
operator|)
condition|)
return|return
operator|(
operator|(
name|cp2
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s2
operator|->
name|fname
operator|)
operator|-
operator|(
name|cp1
operator|==
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s1
operator|->
name|fname
operator|)
operator|)
return|;
comment|/* Character of current path component the same?  */
elseif|else
if|if
condition|(
operator|*
name|cp1
operator|!=
operator|*
name|cp2
condition|)
return|return
operator|*
name|cp1
operator|-
operator|*
name|cp2
return|;
block|}
block|}
end_function

begin_comment
comment|/* Output the directory table and the file name table.  We try to minimize    the total amount of memory needed.  A heuristic is used to avoid large    slowdowns with many input files.  */
end_comment

begin_function
specifier|static
name|void
name|output_file_names
parameter_list|()
block|{
name|struct
name|file_info
modifier|*
name|files
decl_stmt|;
name|struct
name|dir_info
modifier|*
name|dirs
decl_stmt|;
name|int
modifier|*
name|saved
decl_stmt|;
name|int
modifier|*
name|savehere
decl_stmt|;
name|int
modifier|*
name|backmap
decl_stmt|;
name|int
name|ndirs
decl_stmt|;
name|int
name|idx_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* Allocate the various arrays we need.  */
name|files
operator|=
operator|(
expr|struct
name|file_info
operator|*
operator|)
name|alloca
argument_list|(
name|file_table
operator|.
name|in_use
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file_info
argument_list|)
argument_list|)
expr_stmt|;
name|dirs
operator|=
operator|(
expr|struct
name|dir_info
operator|*
operator|)
name|alloca
argument_list|(
name|file_table
operator|.
name|in_use
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dir_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sort the file names.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|file_table
operator|.
name|in_use
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|f
decl_stmt|;
comment|/* Skip all leading "./".  */
name|f
operator|=
name|file_table
operator|.
name|table
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|f
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|f
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|f
operator|+=
literal|2
expr_stmt|;
comment|/* Create a new array entry.  */
name|files
index|[
name|i
index|]
operator|.
name|path
operator|=
name|f
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|file_idx
operator|=
name|i
expr_stmt|;
comment|/* Search for the file name part.  */
name|f
operator|=
name|strrchr
argument_list|(
name|f
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|=
name|f
operator|==
name|NULL
condition|?
name|files
index|[
name|i
index|]
operator|.
name|path
else|:
name|f
operator|+
literal|1
expr_stmt|;
block|}
name|qsort
argument_list|(
name|files
operator|+
literal|1
argument_list|,
name|file_table
operator|.
name|in_use
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|files
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|file_info_cmp
argument_list|)
expr_stmt|;
comment|/* Find all the different directories used.  */
name|dirs
index|[
literal|0
index|]
operator|.
name|path
operator|=
name|files
index|[
literal|1
index|]
operator|.
name|path
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|files
index|[
literal|1
index|]
operator|.
name|fname
operator|-
name|files
index|[
literal|1
index|]
operator|.
name|path
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|.
name|prefix
operator|=
operator|-
literal|1
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|.
name|dir_idx
operator|=
literal|0
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
name|files
index|[
literal|1
index|]
operator|.
name|dir_idx
operator|=
literal|0
expr_stmt|;
name|ndirs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|file_table
operator|.
name|in_use
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|-
name|files
index|[
name|i
index|]
operator|.
name|path
operator|==
name|dirs
index|[
name|ndirs
operator|-
literal|1
index|]
operator|.
name|length
operator|&&
name|memcmp
argument_list|(
name|dirs
index|[
name|ndirs
operator|-
literal|1
index|]
operator|.
name|path
argument_list|,
name|files
index|[
name|i
index|]
operator|.
name|path
argument_list|,
name|dirs
index|[
name|ndirs
operator|-
literal|1
index|]
operator|.
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Same directory as last entry.  */
name|files
index|[
name|i
index|]
operator|.
name|dir_idx
operator|=
name|ndirs
operator|-
literal|1
expr_stmt|;
operator|++
name|dirs
index|[
name|ndirs
operator|-
literal|1
index|]
operator|.
name|count
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
comment|/* This is a new directory.  */
name|dirs
index|[
name|ndirs
index|]
operator|.
name|path
operator|=
name|files
index|[
name|i
index|]
operator|.
name|path
expr_stmt|;
name|dirs
index|[
name|ndirs
index|]
operator|.
name|length
operator|=
name|files
index|[
name|i
index|]
operator|.
name|fname
operator|-
name|files
index|[
name|i
index|]
operator|.
name|path
expr_stmt|;
name|dirs
index|[
name|ndirs
index|]
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|dirs
index|[
name|ndirs
index|]
operator|.
name|dir_idx
operator|=
name|ndirs
expr_stmt|;
name|dirs
index|[
name|ndirs
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
name|files
index|[
name|i
index|]
operator|.
name|dir_idx
operator|=
name|ndirs
expr_stmt|;
comment|/* Search for a prefix.  */
name|dirs
index|[
name|ndirs
index|]
operator|.
name|prefix
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ndirs
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|dirs
index|[
name|j
index|]
operator|.
name|length
operator|<
name|dirs
index|[
name|ndirs
index|]
operator|.
name|length
operator|&&
name|dirs
index|[
name|j
index|]
operator|.
name|length
operator|>
literal|1
operator|&&
operator|(
name|dirs
index|[
name|ndirs
index|]
operator|.
name|prefix
operator|==
operator|-
literal|1
operator|||
name|dirs
index|[
name|j
index|]
operator|.
name|length
operator|>
name|dirs
index|[
name|dirs
index|[
name|ndirs
index|]
operator|.
name|prefix
index|]
operator|.
name|length
operator|)
operator|&&
name|memcmp
argument_list|(
name|dirs
index|[
name|j
index|]
operator|.
name|path
argument_list|,
name|dirs
index|[
name|ndirs
index|]
operator|.
name|path
argument_list|,
name|dirs
index|[
name|j
index|]
operator|.
name|length
argument_list|)
operator|==
literal|0
condition|)
name|dirs
index|[
name|ndirs
index|]
operator|.
name|prefix
operator|=
name|j
expr_stmt|;
operator|++
name|ndirs
expr_stmt|;
block|}
comment|/* Now to the actual work.  We have to find a subset of the directories which      allow expressing the file name using references to the directory table      with the least amount of characters.  We do not do an exhaustive search      where we would have to check out every combination of every single      possible prefix.  Instead we use a heuristic which provides nearly optimal      results in most cases and never is much off.  */
name|saved
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|ndirs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|savehere
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|ndirs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|saved
argument_list|,
literal|'\0'
argument_list|,
name|ndirs
operator|*
sizeof|sizeof
argument_list|(
name|saved
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndirs
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|int
name|total
decl_stmt|;
comment|/* We can always save some space for the current directory.  But this 	 does not mean it will be enough to justify adding the directory.  */
name|savehere
index|[
name|i
index|]
operator|=
name|dirs
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|total
operator|=
operator|(
name|savehere
index|[
name|i
index|]
operator|-
name|saved
index|[
name|i
index|]
operator|)
operator|*
name|dirs
index|[
name|i
index|]
operator|.
name|count
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|ndirs
condition|;
name|j
operator|++
control|)
block|{
name|savehere
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|saved
index|[
name|j
index|]
operator|<
name|dirs
index|[
name|i
index|]
operator|.
name|length
condition|)
block|{
comment|/* Determine whether the dirs[i] path is a prefix of the 		 dirs[j] path.  */
name|int
name|k
decl_stmt|;
name|k
operator|=
name|dirs
index|[
name|j
index|]
operator|.
name|prefix
expr_stmt|;
while|while
condition|(
name|k
operator|!=
operator|-
literal|1
operator|&&
name|k
operator|!=
name|i
condition|)
name|k
operator|=
name|dirs
index|[
name|k
index|]
operator|.
name|prefix
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|i
condition|)
block|{
comment|/* Yes it is.  We can possibly safe some memory but 		     writing the filenames in dirs[j] relative to 		     dirs[i].  */
name|savehere
index|[
name|j
index|]
operator|=
name|dirs
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|total
operator|+=
operator|(
name|savehere
index|[
name|j
index|]
operator|-
name|saved
index|[
name|j
index|]
operator|)
operator|*
name|dirs
index|[
name|j
index|]
operator|.
name|count
expr_stmt|;
block|}
block|}
block|}
comment|/* Check whether we can safe enough to justify adding the dirs[i] 	 directory.  */
if|if
condition|(
name|total
operator|>
name|dirs
index|[
name|i
index|]
operator|.
name|length
operator|+
literal|1
condition|)
block|{
comment|/* It's worthwhile adding.  */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|ndirs
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|savehere
index|[
name|j
index|]
operator|>
literal|0
condition|)
block|{
comment|/* Remember how much we saved for this directory so far.  */
name|saved
index|[
name|j
index|]
operator|=
name|savehere
index|[
name|j
index|]
expr_stmt|;
comment|/* Remember the prefix directory.  */
name|dirs
index|[
name|j
index|]
operator|.
name|dir_idx
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
comment|/* We have to emit them in the order they appear in the file_table array      since the index is used in the debug info generation.  To do this      efficiently we generate a back-mapping of the indices first.  */
name|backmap
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|file_table
operator|.
name|in_use
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|file_table
operator|.
name|in_use
condition|;
name|i
operator|++
control|)
block|{
name|backmap
index|[
name|files
index|[
name|i
index|]
operator|.
name|file_idx
index|]
operator|=
name|i
expr_stmt|;
comment|/* Mark this directory as used.  */
name|dirs
index|[
name|dirs
index|[
name|files
index|[
name|i
index|]
operator|.
name|dir_idx
index|]
operator|.
name|dir_idx
index|]
operator|.
name|used
operator|=
literal|1
expr_stmt|;
block|}
comment|/* That was it.  We are ready to emit the information.  First emit the      directory name table.  We have to make sure the first actually emitted      directory name has index one; zero is reserved for the current working      directory.  Make sure we do not confuse these indices with the one for the      constructed table (even though most of the time they are identical).  */
name|idx
operator|=
literal|1
expr_stmt|;
name|idx_offset
operator|=
name|dirs
index|[
literal|0
index|]
operator|.
name|length
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|-
name|idx_offset
init|;
name|i
operator|<
name|ndirs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dirs
index|[
name|i
index|]
operator|.
name|used
operator|!=
literal|0
condition|)
block|{
name|dirs
index|[
name|i
index|]
operator|.
name|used
operator|=
name|idx
operator|++
expr_stmt|;
name|dw2_asm_output_nstring
argument_list|(
name|dirs
index|[
name|i
index|]
operator|.
name|path
argument_list|,
name|dirs
index|[
name|i
index|]
operator|.
name|length
operator|-
literal|1
argument_list|,
literal|"Directory Entry: 0x%x"
argument_list|,
name|dirs
index|[
name|i
index|]
operator|.
name|used
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"End directory table"
argument_list|)
expr_stmt|;
comment|/* Correct the index for the current working directory entry if it      exists.  */
if|if
condition|(
name|idx_offset
operator|==
literal|0
condition|)
name|dirs
index|[
literal|0
index|]
operator|.
name|used
operator|=
literal|0
expr_stmt|;
comment|/* Now write all the file names.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|file_table
operator|.
name|in_use
condition|;
name|i
operator|++
control|)
block|{
name|int
name|file_idx
init|=
name|backmap
index|[
name|i
index|]
decl_stmt|;
name|int
name|dir_idx
init|=
name|dirs
index|[
name|files
index|[
name|file_idx
index|]
operator|.
name|dir_idx
index|]
operator|.
name|dir_idx
decl_stmt|;
name|dw2_asm_output_nstring
argument_list|(
name|files
index|[
name|file_idx
index|]
operator|.
name|path
operator|+
name|dirs
index|[
name|dir_idx
index|]
operator|.
name|length
argument_list|,
operator|-
literal|1
argument_list|,
literal|"File Entry: 0x%x"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Include directory index.  */
name|dw2_asm_output_data_uleb128
argument_list|(
name|dirs
index|[
name|dir_idx
index|]
operator|.
name|used
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Modification time.  */
name|dw2_asm_output_data_uleb128
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* File length in bytes.  */
name|dw2_asm_output_data_uleb128
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"End file name table"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the source line number correspondence information.  This    information goes into the .debug_line section.  */
end_comment

begin_function
specifier|static
name|void
name|output_line_info
parameter_list|()
block|{
name|char
name|l1
index|[
literal|20
index|]
decl_stmt|,
name|l2
index|[
literal|20
index|]
decl_stmt|,
name|p1
index|[
literal|20
index|]
decl_stmt|,
name|p2
index|[
literal|20
index|]
decl_stmt|;
name|char
name|line_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|char
name|prev_line_label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|unsigned
name|opc
decl_stmt|;
name|unsigned
name|n_op_args
decl_stmt|;
name|unsigned
name|long
name|lt_index
decl_stmt|;
name|unsigned
name|long
name|current_line
decl_stmt|;
name|long
name|line_offset
decl_stmt|;
name|long
name|line_delta
decl_stmt|;
name|unsigned
name|long
name|current_file
decl_stmt|;
name|unsigned
name|long
name|function
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l1
argument_list|,
name|LINE_NUMBER_BEGIN_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|l2
argument_list|,
name|LINE_NUMBER_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|p1
argument_list|,
name|LN_PROLOG_AS_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|p2
argument_list|,
name|LN_PROLOG_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|l2
argument_list|,
name|l1
argument_list|,
literal|"Length of Source Line Info"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|2
argument_list|,
name|DWARF_VERSION
argument_list|,
literal|"DWARF Version"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
name|DWARF_OFFSET_SIZE
argument_list|,
name|p2
argument_list|,
name|p1
argument_list|,
literal|"Prolog Length"
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_MIN_INSTR_LENGTH
argument_list|,
literal|"Minimum Instruction Length"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_DEFAULT_IS_STMT_START
argument_list|,
literal|"Default is_stmt_start flag"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_BASE
argument_list|,
literal|"Line Base Value (Special Opcodes)"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_RANGE
argument_list|,
literal|"Line Range Value (Special Opcodes)"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_OPCODE_BASE
argument_list|,
literal|"Special Opcode Base"
argument_list|)
expr_stmt|;
for|for
control|(
name|opc
operator|=
literal|1
init|;
name|opc
operator|<
name|DWARF_LINE_OPCODE_BASE
condition|;
name|opc
operator|++
control|)
block|{
switch|switch
condition|(
name|opc
condition|)
block|{
case|case
name|DW_LNS_advance_pc
case|:
case|case
name|DW_LNS_advance_line
case|:
case|case
name|DW_LNS_set_file
case|:
case|case
name|DW_LNS_set_column
case|:
case|case
name|DW_LNS_fixed_advance_pc
case|:
name|n_op_args
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|n_op_args
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|n_op_args
argument_list|,
literal|"opcode: 0x%x has %d args"
argument_list|,
name|opc
argument_list|,
name|n_op_args
argument_list|)
expr_stmt|;
block|}
comment|/* Write out the information about the files we use.  */
name|output_file_names
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|p2
argument_list|)
expr_stmt|;
comment|/* We used to set the address register to the first location in the text      section here, but that didn't accomplish anything since we already      have a line note for the opening brace of the first function.  */
comment|/* Generate the line number to PC correspondence table, encoded as      a series of state machine operations.  */
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|prev_line_label
argument_list|,
name|text_section_label
argument_list|)
expr_stmt|;
for|for
control|(
name|lt_index
operator|=
literal|1
init|;
name|lt_index
operator|<
name|line_info_table_in_use
condition|;
operator|++
name|lt_index
control|)
block|{
name|dw_line_info_ref
name|line_info
init|=
operator|&
name|line_info_table
index|[
name|lt_index
index|]
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Disable this optimization for now; GDB wants to see two line notes 	 at the beginning of a function so it can find the end of the 	 prologue.  */
comment|/* Don't emit anything for redundant notes.  Just updating the          address doesn't accomplish anything, because we already assume          that anything after the last address is this line.  */
block|if (line_info->dw_line_num == current_line&& line_info->dw_file_num == current_file) 	continue;
endif|#
directive|endif
comment|/* Emit debug info for the address of the current line.  	 Unfortunately, we have little choice here currently, and must always 	 use the most general form.  GCC does not know the address delta 	 itself, so we can't use DW_LNS_advance_pc.  Many ports do have length 	 attributes which will give an upper bound on the address range.  We 	 could perhaps use length attributes to determine when it is safe to 	 use DW_LNS_fixed_advance_pc.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|line_label
argument_list|,
name|LINE_CODE_LABEL
argument_list|,
name|lt_index
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
comment|/* This can handle deltas up to 0xffff.  This takes 3 bytes.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|,
literal|"DW_LNS_fixed_advance_pc"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
literal|2
argument_list|,
name|line_label
argument_list|,
name|prev_line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This can handle any delta.  This takes              4+DWARF2_ADDR_SIZE bytes.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_set_address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
operator|+
name|DWARF2_ADDR_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_set_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|prev_line_label
argument_list|,
name|line_label
argument_list|)
expr_stmt|;
comment|/* Emit debug info for the source file of the current line, if 	 different from the previous line.  */
if|if
condition|(
name|line_info
operator|->
name|dw_file_num
operator|!=
name|current_file
condition|)
block|{
name|current_file
operator|=
name|line_info
operator|->
name|dw_file_num
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_set_file
argument_list|,
literal|"DW_LNS_set_file"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|current_file
argument_list|,
literal|"(\"%s\")"
argument_list|,
name|file_table
operator|.
name|table
index|[
name|current_file
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Emit debug info for the current line number, choosing the encoding 	 that uses the least amount of space.  */
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|!=
name|current_line
condition|)
block|{
name|line_offset
operator|=
name|line_info
operator|->
name|dw_line_num
operator|-
name|current_line
expr_stmt|;
name|line_delta
operator|=
name|line_offset
operator|-
name|DWARF_LINE_BASE
expr_stmt|;
name|current_line
operator|=
name|line_info
operator|->
name|dw_line_num
expr_stmt|;
if|if
condition|(
name|line_delta
operator|>=
literal|0
operator|&&
name|line_delta
operator|<
operator|(
name|DWARF_LINE_RANGE
operator|-
literal|1
operator|)
condition|)
comment|/* This can handle deltas from -10 to 234, using the current 	       definitions of DWARF_LINE_BASE and DWARF_LINE_RANGE.  This 	       takes 1 byte.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_OPCODE_BASE
operator|+
name|line_delta
argument_list|,
literal|"line %lu"
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* This can handle any delta.  This takes at least 4 bytes, 		 depending on the value being encoded.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_advance_line
argument_list|,
literal|"advance to line %lu"
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_sleb128
argument_list|(
name|line_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_copy
argument_list|,
literal|"DW_LNS_copy"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* We still need to start a new row, so output a copy insn.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_copy
argument_list|,
literal|"DW_LNS_copy"
argument_list|)
expr_stmt|;
block|}
comment|/* Emit debug info for the address of the end of the function.  */
if|if
condition|(
literal|0
condition|)
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|,
literal|"DW_LNS_fixed_advance_pc"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
literal|2
argument_list|,
name|text_end_label
argument_list|,
name|prev_line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_set_address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
operator|+
name|DWARF2_ADDR_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_set_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|text_end_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_end_sequence"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_end_sequence
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|function
operator|=
literal|0
expr_stmt|;
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|lt_index
operator|=
literal|0
init|;
name|lt_index
operator|<
name|separate_line_info_table_in_use
condition|;
control|)
block|{
name|dw_separate_line_info_ref
name|line_info
init|=
operator|&
name|separate_line_info_table
index|[
name|lt_index
index|]
decl_stmt|;
if|#
directive|if
literal|0
comment|/* Don't emit anything for redundant notes.  */
block|if (line_info->dw_line_num == current_line&& line_info->dw_file_num == current_file&& line_info->function == function) 	goto cont;
endif|#
directive|endif
comment|/* Emit debug info for the address of the current line.  If this is 	 a new function, or the first line of a function, then we need 	 to handle it differently.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|line_label
argument_list|,
name|SEPARATE_LINE_CODE_LABEL
argument_list|,
name|lt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|function
operator|!=
name|line_info
operator|->
name|function
condition|)
block|{
name|function
operator|=
name|line_info
operator|->
name|function
expr_stmt|;
comment|/* Set the address register to the first line in the function */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_set_address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
operator|+
name|DWARF2_ADDR_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_set_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? See the DW_LNS_advance_pc comment above.  */
if|if
condition|(
literal|0
condition|)
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|,
literal|"DW_LNS_fixed_advance_pc"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
literal|2
argument_list|,
name|line_label
argument_list|,
name|prev_line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_set_address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
operator|+
name|DWARF2_ADDR_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_set_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|strcpy
argument_list|(
name|prev_line_label
argument_list|,
name|line_label
argument_list|)
expr_stmt|;
comment|/* Emit debug info for the source file of the current line, if 	 different from the previous line.  */
if|if
condition|(
name|line_info
operator|->
name|dw_file_num
operator|!=
name|current_file
condition|)
block|{
name|current_file
operator|=
name|line_info
operator|->
name|dw_file_num
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_set_file
argument_list|,
literal|"DW_LNS_set_file"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|current_file
argument_list|,
literal|"(\"%s\")"
argument_list|,
name|file_table
operator|.
name|table
index|[
name|current_file
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Emit debug info for the current line number, choosing the encoding 	 that uses the least amount of space.  */
if|if
condition|(
name|line_info
operator|->
name|dw_line_num
operator|!=
name|current_line
condition|)
block|{
name|line_offset
operator|=
name|line_info
operator|->
name|dw_line_num
operator|-
name|current_line
expr_stmt|;
name|line_delta
operator|=
name|line_offset
operator|-
name|DWARF_LINE_BASE
expr_stmt|;
name|current_line
operator|=
name|line_info
operator|->
name|dw_line_num
expr_stmt|;
if|if
condition|(
name|line_delta
operator|>=
literal|0
operator|&&
name|line_delta
operator|<
operator|(
name|DWARF_LINE_RANGE
operator|-
literal|1
operator|)
condition|)
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DWARF_LINE_OPCODE_BASE
operator|+
name|line_delta
argument_list|,
literal|"line %lu"
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
else|else
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_advance_line
argument_list|,
literal|"advance to line %lu"
argument_list|,
name|current_line
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_sleb128
argument_list|(
name|line_offset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_copy
argument_list|,
literal|"DW_LNS_copy"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_copy
argument_list|,
literal|"DW_LNS_copy"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|cont:
endif|#
directive|endif
name|lt_index
operator|++
expr_stmt|;
comment|/* If we're done with a function, end its sequence.  */
if|if
condition|(
name|lt_index
operator|==
name|separate_line_info_table_in_use
operator|||
name|separate_line_info_table
index|[
name|lt_index
index|]
operator|.
name|function
operator|!=
name|function
condition|)
block|{
name|current_file
operator|=
literal|1
expr_stmt|;
name|current_line
operator|=
literal|1
expr_stmt|;
comment|/* Emit debug info for the address of the end of the function.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|line_label
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|function
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNS_fixed_advance_pc
argument_list|,
literal|"DW_LNS_fixed_advance_pc"
argument_list|)
expr_stmt|;
name|dw2_asm_output_delta
argument_list|(
literal|2
argument_list|,
name|line_label
argument_list|,
name|prev_line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_set_address"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
operator|+
name|DWARF2_ADDR_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_set_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_addr
argument_list|(
name|DWARF2_ADDR_SIZE
argument_list|,
name|line_label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Output the marker for the end of this sequence.  */
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"DW_LNE_end_sequence"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_LNE_end_sequence
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Output the marker for the end of the line number info.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|l2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a pointer to a tree node for some base type, return a pointer to    a DIE that describes the given type.     This routine must only be called for GCC type nodes that correspond to    Dwarf base (fundamental) types.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|base_type_die
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|dw_die_ref
name|base_type_result
decl_stmt|;
specifier|const
name|char
modifier|*
name|type_name
decl_stmt|;
name|enum
name|dwarf_type
name|encoding
decl_stmt|;
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|type_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|type_name
operator|=
literal|"__unknown__"
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
comment|/* Carefully distinguish the C character types, without messing          up if the language is not C. Note that we check only for the names          that contain spaces; other names might occur by coincidence in other          languages.  */
if|if
condition|(
operator|!
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|CHAR_TYPE_SIZE
operator|&&
operator|(
name|type
operator|==
name|char_type_node
operator|||
operator|!
name|strcmp
argument_list|(
name|type_name
argument_list|,
literal|"signed char"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|type_name
argument_list|,
literal|"unsigned char"
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|encoding
operator|=
name|DW_ATE_unsigned
expr_stmt|;
else|else
name|encoding
operator|=
name|DW_ATE_signed
expr_stmt|;
break|break;
block|}
comment|/* else fall through.  */
case|case
name|CHAR_TYPE
case|:
comment|/* GNU Pascal/Ada CHAR type.  Not used in C.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|encoding
operator|=
name|DW_ATE_unsigned_char
expr_stmt|;
else|else
name|encoding
operator|=
name|DW_ATE_signed_char
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
name|encoding
operator|=
name|DW_ATE_float
expr_stmt|;
break|break;
comment|/* Dwarf2 doesn't know anything about complex ints, so use 	 a user defined type for it.  */
case|case
name|COMPLEX_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|encoding
operator|=
name|DW_ATE_complex_float
expr_stmt|;
else|else
name|encoding
operator|=
name|DW_ATE_lo_user
expr_stmt|;
break|break;
case|case
name|BOOLEAN_TYPE
case|:
comment|/* GNU FORTRAN/Ada/C++ BOOLEAN type.  */
name|encoding
operator|=
name|DW_ATE_boolean
expr_stmt|;
break|break;
default|default:
comment|/* No other TREE_CODEs are Dwarf fundamental types.  */
name|abort
argument_list|()
expr_stmt|;
block|}
name|base_type_result
operator|=
name|new_die
argument_list|(
name|DW_TAG_base_type
argument_list|,
name|comp_unit_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangle_name_func
condition|)
name|type_name
operator|=
call|(
modifier|*
name|demangle_name_func
call|)
argument_list|(
name|type_name
argument_list|)
expr_stmt|;
name|add_AT_string
argument_list|(
name|base_type_result
argument_list|,
name|DW_AT_name
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|base_type_result
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|base_type_result
argument_list|,
name|DW_AT_encoding
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
return|return
name|base_type_result
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return a pointer to    the Dwarf "root" type for the given input type.  The Dwarf "root" type of    a given type is generally the same as the given type, except that if the    given type is a pointer or reference type, then the root type of the given    type is the root type of the "basis" type for the pointer or reference    type.  (This definition of the "root" type is recursive.) Also, the root    type of a `const' qualified type or a `volatile' qualified type is the    root type of the given type without the qualifiers.  */
end_comment

begin_function
specifier|static
name|tree
name|root_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|error_mark_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|error_mark_node
return|;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
return|return
name|type_main_variant
argument_list|(
name|root_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|type_main_variant
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return non-zero if the    given input type is a Dwarf "fundamental" type.  Otherwise return null.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_base_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
return|return
literal|1
return|;
case|case
name|SET_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|FUNCTION_TYPE
case|:
case|case
name|METHOD_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
case|case
name|FILE_TYPE
case|:
case|case
name|OFFSET_TYPE
case|:
case|case
name|LANG_TYPE
case|:
case|case
name|VECTOR_TYPE
case|:
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return a debugging    entry that chains various modifiers in front of the given type.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|modified_type_die
parameter_list|(
name|type
parameter_list|,
name|is_const_type
parameter_list|,
name|is_volatile_type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|is_const_type
decl_stmt|;
name|int
name|is_volatile_type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|dw_die_ref
name|mod_type_die
init|=
name|NULL
decl_stmt|;
name|dw_die_ref
name|sub_die
init|=
name|NULL
decl_stmt|;
name|tree
name|item_type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|code
operator|!=
name|ERROR_MARK
condition|)
block|{
name|tree
name|qualified_type
decl_stmt|;
comment|/* See if we already have the appropriately qualified variant of 	 this type.  */
name|qualified_type
operator|=
name|get_qualified_type
argument_list|(
name|type
argument_list|,
operator|(
operator|(
name|is_const_type
condition|?
name|TYPE_QUAL_CONST
else|:
literal|0
operator|)
operator||
operator|(
name|is_volatile_type
condition|?
name|TYPE_QUAL_VOLATILE
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If we do, then we can just use its DIE, if it exists.  */
if|if
condition|(
name|qualified_type
condition|)
block|{
name|mod_type_die
operator|=
name|lookup_type_die
argument_list|(
name|qualified_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_type_die
condition|)
return|return
name|mod_type_die
return|;
block|}
comment|/* Handle C typedef types.  */
if|if
condition|(
name|qualified_type
operator|&&
name|TYPE_NAME
argument_list|(
name|qualified_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|qualified_type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|qualified_type
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type_name
init|=
name|TYPE_NAME
argument_list|(
name|qualified_type
argument_list|)
decl_stmt|;
name|tree
name|dtype
init|=
name|TREE_TYPE
argument_list|(
name|type_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|qualified_type
operator|==
name|dtype
condition|)
block|{
comment|/* For a named type, use the typedef.  */
name|gen_type_die
argument_list|(
name|qualified_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|mod_type_die
operator|=
name|lookup_type_die
argument_list|(
name|qualified_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_const_type
operator|<
name|TYPE_READONLY
argument_list|(
name|dtype
argument_list|)
operator|||
name|is_volatile_type
operator|<
name|TYPE_VOLATILE
argument_list|(
name|dtype
argument_list|)
condition|)
comment|/* cv-unqualified version of named type.  Just use the unnamed 	       type to which it refers.  */
name|mod_type_die
operator|=
name|modified_type_die
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|type_name
argument_list|)
argument_list|,
name|is_const_type
argument_list|,
name|is_volatile_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Else cv-qualified version of named type; fall through.  */
block|}
if|if
condition|(
name|mod_type_die
condition|)
comment|/* OK.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|is_const_type
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_const_type
argument_list|,
name|comp_unit_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|sub_die
operator|=
name|modified_type_die
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|is_volatile_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_volatile_type
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_volatile_type
argument_list|,
name|comp_unit_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|sub_die
operator|=
name|modified_type_die
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|POINTER_TYPE
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_pointer_type
argument_list|,
name|comp_unit_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|mod_type_die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|PTR_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);
endif|#
directive|endif
name|item_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|mod_type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_reference_type
argument_list|,
name|comp_unit_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|mod_type_die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|PTR_SIZE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_AT_unsigned (mod_type_die, DW_AT_address_class, 0);
endif|#
directive|endif
name|item_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_base_type
argument_list|(
name|type
argument_list|)
condition|)
name|mod_type_die
operator|=
name|base_type_die
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|gen_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* We have to get the type_main_variant here (and pass that to the 	     `lookup_type_die' routine) because the ..._TYPE node we have 	     might simply be a *copy* of some original type node (where the 	     copy was created to help us keep track of typedef names) and 	     that copy might have a different TYPE_UID from the original 	     ..._TYPE node.  */
name|mod_type_die
operator|=
name|lookup_type_die
argument_list|(
name|type_main_variant
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod_type_die
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* We want to equate the qualified type to the die below.  */
if|if
condition|(
name|qualified_type
condition|)
name|type
operator|=
name|qualified_type
expr_stmt|;
block|}
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|mod_type_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|item_type
condition|)
comment|/* We must do this after the equate_type_number_to_die call, in case        this is a recursive type.  This ensures that the modified_type_die        recursion will terminate even if the type is recursive.  Recursive        types are possible in Ada.  */
name|sub_die
operator|=
name|modified_type_die
argument_list|(
name|item_type
argument_list|,
name|TYPE_READONLY
argument_list|(
name|item_type
argument_list|)
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|item_type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_die
operator|!=
name|NULL
condition|)
name|add_AT_die_ref
argument_list|(
name|mod_type_die
argument_list|,
name|DW_AT_type
argument_list|,
name|sub_die
argument_list|)
expr_stmt|;
return|return
name|mod_type_die
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to an arbitrary ..._TYPE tree node, return true if it is    an enumerated type.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|type_is_enum
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
return|;
block|}
end_function

begin_comment
comment|/* Return the register number described by a given RTL node.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|reg_number
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
name|unsigned
name|regno
init|=
name|REGNO
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|DBX_REGISTER_NUMBER
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a location descriptor that designates a machine register or    zero if there is no such.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|reg_loc_descriptor
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|loc_result
init|=
name|NULL
decl_stmt|;
name|unsigned
name|reg
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
name|reg
operator|=
name|reg_number
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|<=
literal|31
condition|)
name|loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_reg0
operator|+
name|reg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_regx
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|loc_result
return|;
block|}
end_function

begin_comment
comment|/* Return a location descriptor that designates a constant.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|int_loc_descriptor
parameter_list|(
name|i
parameter_list|)
name|HOST_WIDE_INT
name|i
decl_stmt|;
block|{
name|enum
name|dwarf_location_atom
name|op
decl_stmt|;
comment|/* Pick the smallest representation of a constant, rather than just      defaulting to the LEB encoding.  */
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|<=
literal|31
condition|)
name|op
operator|=
name|DW_OP_lit0
operator|+
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<=
literal|0xff
condition|)
name|op
operator|=
name|DW_OP_const1u
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<=
literal|0xffff
condition|)
name|op
operator|=
name|DW_OP_const2u
expr_stmt|;
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
operator|||
name|i
operator|<=
literal|0xffffffff
condition|)
name|op
operator|=
name|DW_OP_const4u
expr_stmt|;
else|else
name|op
operator|=
name|DW_OP_constu
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|>=
operator|-
literal|0x80
condition|)
name|op
operator|=
name|DW_OP_const1s
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>=
operator|-
literal|0x8000
condition|)
name|op
operator|=
name|DW_OP_const2s
expr_stmt|;
elseif|else
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|32
operator|||
name|i
operator|>=
operator|-
literal|0x80000000
condition|)
name|op
operator|=
name|DW_OP_const4s
expr_stmt|;
else|else
name|op
operator|=
name|DW_OP_consts
expr_stmt|;
block|}
return|return
name|new_loc_descr
argument_list|(
name|op
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a location descriptor that designates a base+offset location.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|based_loc_descr
parameter_list|(
name|reg
parameter_list|,
name|offset
parameter_list|)
name|unsigned
name|reg
decl_stmt|;
name|long
name|int
name|offset
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|loc_result
decl_stmt|;
comment|/* For the "frame base", we use the frame pointer or stack pointer      registers, since the RTL for local variables is relative to one of      them.  */
name|unsigned
name|fp_reg
init|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|frame_pointer_needed
condition|?
name|HARD_FRAME_POINTER_REGNUM
else|:
name|STACK_POINTER_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|fp_reg
condition|)
name|loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_fbreg
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|<=
literal|31
condition|)
name|loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_breg0
operator|+
name|reg
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_bregx
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|loc_result
return|;
block|}
end_function

begin_comment
comment|/* Return true if this RTL expression describes a base+offset calculation.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_based_loc
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
return|return
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following routine converts the RTL for a variable or parameter    (resident in memory) into an equivalent Dwarf representation of a    mechanism for getting the address of that same variable onto the top of a    hypothetical "address evaluation" stack.     When creating memory location descriptors, we are effectively transforming    the RTL for a memory-resident object into its Dwarf postfix expression    equivalent.  This routine recursively descends an RTL tree, turning    it into Dwarf postfix code as it goes.     MODE is the mode of the memory reference, needed to handle some    autoincrement addressing modes.     Return 0 if we can't represent the location.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|mem_loc_descriptor
parameter_list|(
name|rtl
parameter_list|,
name|mode
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|mem_loc_result
init|=
name|NULL
decl_stmt|;
comment|/* Note that for a dynamically sized array, the location we will generate a      description of here will be the lowest numbered location which is      actually within the array.  That's *not* necessarily the same as the      zeroth element of the array.  */
ifdef|#
directive|ifdef
name|ASM_SIMPLIFY_DWARF_ADDR
name|rtl
operator|=
name|ASM_SIMPLIFY_DWARF_ADDR
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|POST_INC
case|:
case|case
name|POST_DEC
case|:
case|case
name|POST_MODIFY
case|:
comment|/* POST_INC and POST_DEC can be handled just like a SUBREG.  So we 	 just fall into the SUBREG code.  */
comment|/* ... fall through ...  */
case|case
name|SUBREG
case|:
comment|/* The case of a subreg may arise when we have a local (register)          variable or a formal (register) parameter which doesn't quite fill          up an entire register.  For now, just assume that it is          legitimate to make the Dwarf info refer to the whole register which          contains the given subreg.  */
name|rtl
operator|=
name|SUBREG_REG
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|REG
case|:
comment|/* Whenever a register number forms a part of the description of the          method for calculating the (dynamic) address of a memory resident          object, DWARF rules require the register number be referred to as          a "base register".  This distinction is not based in any way upon          what category of register the hardware believes the given register          belongs to.  This is strictly DWARF terminology we're dealing with          here. Note that in cases where the location of a memory-resident          data object could be expressed as: OP_ADD (OP_BASEREG (basereg),          OP_CONST (0)) the actual DWARF location descriptor that we generate          may just be OP_BASEREG (basereg).  This may look deceptively like          the object in question was allocated to a register (rather than in          memory) so DWARF consumers need to be aware of the subtle          distinction between OP_REG and OP_BASEREG.  */
if|if
condition|(
name|REGNO
argument_list|(
name|rtl
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|mem_loc_result
operator|=
name|based_loc_descr
argument_list|(
name|reg_number
argument_list|(
name|rtl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|mem_loc_result
operator|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_loc_result
operator|!=
literal|0
condition|)
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_deref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
comment|/* Some ports can transform a symbol ref into a label ref, because  	 the symbol ref is too far away and has to be dumped into a constant  	 pool.  */
case|case
name|CONST
case|:
case|case
name|SYMBOL_REF
case|:
comment|/* Alternatively, the symbol in the constant pool might be referenced 	 by a different symbol.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|get_pool_constant
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
name|rtl
operator|=
name|tmp
expr_stmt|;
block|}
name|mem_loc_result
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem_loc_result
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_addr
expr_stmt|;
name|mem_loc_result
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_addr
operator|=
name|rtl
expr_stmt|;
name|VARRAY_PUSH_RTX
argument_list|(
name|used_rtx_varray
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRE_MODIFY
case|:
comment|/* Extract the PLUS expression nested inside and fall into          PLUS code below.  */
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|plus
goto|;
case|case
name|PRE_INC
case|:
case|case
name|PRE_DEC
case|:
comment|/* Turn these into a PLUS expression and fall into the PLUS code 	 below.  */
name|rtl
operator|=
name|gen_rtx_PLUS
argument_list|(
name|word_mode
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|PRE_INC
condition|?
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
else|:
operator|-
name|GET_MODE_UNIT_SIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|PLUS
case|:
name|plus
label|:
if|if
condition|(
name|is_based_loc
argument_list|(
name|rtl
argument_list|)
condition|)
name|mem_loc_result
operator|=
name|based_loc_descr
argument_list|(
name|reg_number
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|mem_loc_result
operator|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem_loc_result
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus_uconst
argument_list|,
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MULT
case|:
block|{
comment|/* If a pseudo-reg is optimized away, it is possible for it to 	   be replaced with a MEM containing a multiply.  */
name|dw_loc_descr_ref
name|op0
init|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|dw_loc_descr_ref
name|op1
init|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|,
name|mode
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|==
literal|0
operator|||
name|op1
operator|==
literal|0
condition|)
break|break;
name|mem_loc_result
operator|=
name|op0
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|mem_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_mul
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CONST_INT
case|:
name|mem_loc_result
operator|=
name|int_loc_descriptor
argument_list|(
name|INTVAL
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDRESSOF
case|:
comment|/* If this is a MEM, return its address.  Otherwise, we can't 	 represent this.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|mode
argument_list|)
return|;
else|else
return|return
literal|0
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|mem_loc_result
return|;
block|}
end_function

begin_comment
comment|/* Return a descriptor that describes the concatenation of two locations.    This is typically a complex variable.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|concat_loc_descriptor
parameter_list|(
name|x0
parameter_list|,
name|x1
parameter_list|)
name|rtx
name|x0
decl_stmt|,
name|x1
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|cc_loc_result
init|=
name|NULL
decl_stmt|;
name|dw_loc_descr_ref
name|x0_ref
init|=
name|loc_descriptor
argument_list|(
name|x0
argument_list|)
decl_stmt|;
name|dw_loc_descr_ref
name|x1_ref
init|=
name|loc_descriptor
argument_list|(
name|x1
argument_list|)
decl_stmt|;
if|if
condition|(
name|x0_ref
operator|==
literal|0
operator|||
name|x1_ref
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|cc_loc_result
operator|=
name|x0_ref
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|cc_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_piece
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|cc_loc_result
argument_list|,
name|x1_ref
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|cc_loc_result
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_piece
argument_list|,
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cc_loc_result
return|;
block|}
end_function

begin_comment
comment|/* Output a proper Dwarf location descriptor for a variable or parameter    which is either allocated in a register or in a memory location.  For a    register, we just generate an OP_REG and the register number.  For a    memory location we provide a Dwarf postfix expression describing how to    generate the (dynamic) address of the object onto the address stack.     If we don't know how to describe it, return 0.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|loc_descriptor
parameter_list|(
name|rtl
parameter_list|)
name|rtx
name|rtl
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|loc_result
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|SUBREG
case|:
comment|/* The case of a subreg may arise when we have a local (register)          variable or a formal (register) parameter which doesn't quite fill          up an entire register.  For now, just assume that it is          legitimate to make the Dwarf info refer to the whole register which          contains the given subreg.  */
name|rtl
operator|=
name|SUBREG_REG
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|REG
case|:
name|loc_result
operator|=
name|reg_loc_descriptor
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
name|loc_result
operator|=
name|mem_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONCAT
case|:
name|loc_result
operator|=
name|concat_loc_descriptor
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|loc_result
return|;
block|}
end_function

begin_comment
comment|/* Similar, but generate the descriptor from trees instead of rtl.  This comes    up particularly with variable length arrays.  If ADDRESSP is nonzero, we are    looking for an address.  Otherwise, we return a value.  If we can't make a    descriptor, return 0.  */
end_comment

begin_function
specifier|static
name|dw_loc_descr_ref
name|loc_descriptor_from_tree
parameter_list|(
name|loc
parameter_list|,
name|addressp
parameter_list|)
name|tree
name|loc
decl_stmt|;
name|int
name|addressp
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|ret
decl_stmt|,
name|ret1
decl_stmt|;
name|int
name|indirect_p
init|=
literal|0
decl_stmt|;
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|loc
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|dwarf_location_atom
name|op
decl_stmt|;
comment|/* ??? Most of the time we do not take proper care for sign/zero      extending the values properly.  Hopefully this won't be a real      problem...  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|loc
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
literal|0
return|;
case|case
name|WITH_RECORD_EXPR
case|:
case|case
name|PLACEHOLDER_EXPR
case|:
comment|/* This case involves extracting fields from an object to determine the 	 position of other fields.  We don't try to encode this here.  The 	 only user of this is Ada, which encodes the needed information using 	 the names of types.  */
return|return
literal|0
return|;
case|case
name|CALL_EXPR
case|:
return|return
literal|0
return|;
case|case
name|ADDR_EXPR
case|:
comment|/* We can support this only if we can look through conversions and 	 find an INDIRECT_EXPR.  */
for|for
control|(
name|loc
operator|=
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
init|;
name|TREE_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|VIEW_CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|SAVE_EXPR
condition|;
name|loc
operator|=
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
control|)
empty_stmt|;
return|return
operator|(
name|TREE_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|INDIRECT_REF
condition|?
name|loc_descriptor_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|addressp
argument_list|)
else|:
literal|0
operator|)
return|;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
block|{
name|rtx
name|rtl
init|=
name|rtl_for_decl_location
argument_list|(
name|loc
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
name|ret
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_addr
expr_stmt|;
name|ret
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_addr
operator|=
name|rtl
expr_stmt|;
name|indirect_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|indirect_p
operator|=
literal|1
expr_stmt|;
name|rtl
operator|=
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|mem_loc_descriptor
argument_list|(
name|rtl
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|INDIRECT_REF
case|:
name|ret
operator|=
name|loc_descriptor_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indirect_p
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
return|return
name|loc_descriptor_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
name|addressp
argument_list|)
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|SAVE_EXPR
case|:
return|return
name|loc_descriptor_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|addressp
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
block|{
name|tree
name|obj
decl_stmt|,
name|offset
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|,
name|bytepos
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|obj
operator|=
name|get_inner_reference
argument_list|(
name|loc
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|loc
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|loc_descriptor_from_tree
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|bitpos
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
operator|||
name|bitsize
operator|%
name|BITS_PER_UNIT
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|offset
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* Variable offset.  */
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|loc_descriptor_from_tree
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addressp
condition|)
name|indirect_p
operator|=
literal|1
expr_stmt|;
name|bytepos
operator|=
name|bitpos
operator|/
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|bytepos
operator|>
literal|0
condition|)
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus_uconst
argument_list|,
name|bytepos
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bytepos
operator|<
literal|0
condition|)
block|{
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|int_loc_descriptor
argument_list|(
name|bytepos
argument_list|)
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|INTEGER_CST
case|:
if|if
condition|(
name|host_integerp
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
condition|)
name|ret
operator|=
name|int_loc_descriptor
argument_list|(
name|tree_low_cst
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|BIT_AND_EXPR
case|:
name|op
operator|=
name|DW_OP_and
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
name|op
operator|=
name|DW_OP_xor
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
name|op
operator|=
name|DW_OP_or
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|TRUNC_DIV_EXPR
case|:
name|op
operator|=
name|DW_OP_div
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|MINUS_EXPR
case|:
name|op
operator|=
name|DW_OP_minus
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|TRUNC_MOD_EXPR
case|:
name|op
operator|=
name|DW_OP_mod
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|MULT_EXPR
case|:
name|op
operator|=
name|DW_OP_mul
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|LSHIFT_EXPR
case|:
name|op
operator|=
name|DW_OP_shl
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|RSHIFT_EXPR
case|:
name|op
operator|=
operator|(
name|unsignedp
condition|?
name|DW_OP_shr
else|:
name|DW_OP_shra
operator|)
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|host_integerp
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ret
operator|=
name|loc_descriptor_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_plus_uconst
argument_list|,
name|tree_low_cst
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|op
operator|=
name|DW_OP_plus
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|LE_EXPR
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|DW_OP_le
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|GE_EXPR
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|DW_OP_ge
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|DW_OP_lt
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|GT_EXPR
case|:
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|op
operator|=
name|DW_OP_gt
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|EQ_EXPR
case|:
name|op
operator|=
name|DW_OP_eq
expr_stmt|;
goto|goto
name|do_binop
goto|;
case|case
name|NE_EXPR
case|:
name|op
operator|=
name|DW_OP_ne
expr_stmt|;
goto|goto
name|do_binop
goto|;
name|do_binop
label|:
name|ret
operator|=
name|loc_descriptor_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret1
operator|=
name|loc_descriptor_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|ret1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|ret1
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
name|op
operator|=
name|DW_OP_not
expr_stmt|;
goto|goto
name|do_unop
goto|;
case|case
name|ABS_EXPR
case|:
name|op
operator|=
name|DW_OP_abs
expr_stmt|;
goto|goto
name|do_unop
goto|;
case|case
name|NEGATE_EXPR
case|:
name|op
operator|=
name|DW_OP_neg
expr_stmt|;
goto|goto
name|do_unop
goto|;
name|do_unop
label|:
name|ret
operator|=
name|loc_descriptor_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|loc
operator|=
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|build
argument_list|(
name|LT_EXPR
argument_list|,
name|integer_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... fall through ...  */
case|case
name|COND_EXPR
case|:
block|{
name|dw_loc_descr_ref
name|lhs
init|=
name|loc_descriptor_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|dw_loc_descr_ref
name|rhs
init|=
name|loc_descriptor_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|dw_loc_descr_ref
name|bra_node
decl_stmt|,
name|jump_node
decl_stmt|,
name|tmp
decl_stmt|;
name|ret
operator|=
name|loc_descriptor_from_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|lhs
operator|==
literal|0
operator|||
name|rhs
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|bra_node
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_bra
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|bra_node
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|jump_node
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_skip
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|jump_node
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|bra_node
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_loc
expr_stmt|;
name|bra_node
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_loc
operator|=
name|lhs
expr_stmt|;
comment|/* ??? Need a node to point the skip at.  Use a nop.  */
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_nop
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|jump_node
operator|->
name|dw_loc_oprnd1
operator|.
name|val_class
operator|=
name|dw_val_class_loc
expr_stmt|;
name|jump_node
operator|->
name|dw_loc_oprnd1
operator|.
name|v
operator|.
name|val_loc
operator|=
name|tmp
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Show if we can't fill the request for an address.  */
if|if
condition|(
name|addressp
operator|&&
name|indirect_p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we've got an address and don't want one, dereference.  */
if|if
condition|(
operator|!
name|addressp
operator|&&
name|indirect_p
operator|>
literal|0
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|loc
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|DWARF2_ADDR_SIZE
operator|||
name|size
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|size
operator|==
name|DWARF2_ADDR_SIZE
condition|)
name|op
operator|=
name|DW_OP_deref
expr_stmt|;
else|else
name|op
operator|=
name|DW_OP_deref_size
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|ret
argument_list|,
name|new_loc_descr
argument_list|(
name|op
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Given a value, round it up to the lowest multiple of `boundary'    which is not less than the value itself.  */
end_comment

begin_function
specifier|static
specifier|inline
name|HOST_WIDE_INT
name|ceiling
parameter_list|(
name|value
parameter_list|,
name|boundary
parameter_list|)
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|unsigned
name|int
name|boundary
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|(
name|value
operator|+
name|boundary
operator|-
literal|1
operator|)
operator|/
name|boundary
operator|)
operator|*
name|boundary
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to what is assumed to be a FIELD_DECL node, return a    pointer to the declared type for the relevant field variable, or return    `integer_type_node' if the given node turns out to be an    ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|field_type
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|integer_type_node
return|;
name|type
operator|=
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node, return the alignment in bits for    it, or else return BITS_PER_WORD if the node actually turns out to    be an ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|simple_type_align_in_bits
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|?
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
else|:
name|BITS_PER_WORD
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|simple_decl_align_in_bits
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|ERROR_MARK
operator|)
condition|?
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
else|:
name|BITS_PER_WORD
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a tree node, assumed to be some kind of a ..._TYPE    node, return the size in bits for the type if it is a constant, or else    return the alignment for the type if the type's size is not constant, or    else return BITS_PER_WORD if the type actually turns out to be an    ERROR_MARK node.  */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|HOST_WIDE_INT
name|simple_type_size_in_bits
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|BITS_PER_WORD
return|;
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a FIELD_DECL, compute and return the byte offset of the    lowest addressed byte of the "containing object" for the given FIELD_DECL,    or return 0 if we are unable to determine what that offset is, either    because the argument turns out to be a pointer to an ERROR_MARK node, or    because the offset is actually variable.  (We can't handle the latter case    just yet).  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|field_byte_offset
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|unsigned
name|int
name|type_align_in_bits
decl_stmt|;
name|unsigned
name|int
name|decl_align_in_bits
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|type_size_in_bits
decl_stmt|;
name|HOST_WIDE_INT
name|object_offset_in_bits
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|tree
name|field_size_tree
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos_int
decl_stmt|;
name|HOST_WIDE_INT
name|deepest_bitpos
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|field_size_in_bits
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|type
operator|=
name|field_type
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|field_size_tree
operator|=
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The size could be unspecified if there was an error, or for      a flexible array member.  */
if|if
condition|(
operator|!
name|field_size_tree
condition|)
name|field_size_tree
operator|=
name|bitsize_zero_node
expr_stmt|;
comment|/* We cannot yet cope with fields whose positions are variable, so      for now, when we see such things, we simply return 0.  Someday, we may      be able to handle such cases, but it will be damn difficult.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|bitpos_int
operator|=
name|int_bit_position
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If we don't know the size of the field, pretend it's a full word.  */
if|if
condition|(
name|host_integerp
argument_list|(
name|field_size_tree
argument_list|,
literal|1
argument_list|)
condition|)
name|field_size_in_bits
operator|=
name|tree_low_cst
argument_list|(
name|field_size_tree
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|field_size_in_bits
operator|=
name|BITS_PER_WORD
expr_stmt|;
name|type_size_in_bits
operator|=
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_align_in_bits
operator|=
name|simple_type_align_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|decl_align_in_bits
operator|=
name|simple_decl_align_in_bits
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The GCC front-end doesn't make any attempt to keep track of the starting      bit offset (relative to the start of the containing structure type) of the      hypothetical "containing object" for a bit-field.  Thus, when computing      the byte offset value for the start of the "containing object" of a      bit-field, we must deduce this information on our own. This can be rather      tricky to do in some cases.  For example, handling the following structure      type definition when compiling for an i386/i486 target (which only aligns      long long's to 32-bit boundaries) can be very tricky:  	 struct S { int field1; long long field2:31; };       Fortunately, there is a simple rule-of-thumb which can be used in such      cases.  When compiling for an i386/i486, GCC will allocate 8 bytes for the      structure shown above.  It decides to do this based upon one simple rule      for bit-field allocation.  GCC allocates each "containing object" for each      bit-field at the first (i.e. lowest addressed) legitimate alignment      boundary (based upon the required minimum alignment for the declared type      of the field) which it can possibly use, subject to the condition that      there is still enough available space remaining in the containing object      (when allocated at the selected point) to fully accommodate all of the      bits of the bit-field itself.       This simple rule makes it obvious why GCC allocates 8 bytes for each      object of the structure type shown above.  When looking for a place to      allocate the "containing object" for `field2', the compiler simply tries      to allocate a 64-bit "containing object" at each successive 32-bit      boundary (starting at zero) until it finds a place to allocate that 64-      bit field such that at least 31 contiguous (and previously unallocated)      bits remain within that selected 64 bit field.  (As it turns out, for the      example above, the compiler finds it is OK to allocate the "containing      object" 64-bit field at bit-offset zero within the structure type.)       Here we attempt to work backwards from the limited set of facts we're      given, and we try to deduce from those facts, where GCC must have believed      that the containing object started (within the structure type). The value      we deduce is then used (by the callers of this routine) to generate      DW_AT_location and DW_AT_bit_offset attributes for fields (both bit-fields      and, in the case of DW_AT_location, regular fields as well).  */
comment|/* Figure out the bit-distance from the start of the structure to the      "deepest" bit of the bit-field.  */
name|deepest_bitpos
operator|=
name|bitpos_int
operator|+
name|field_size_in_bits
expr_stmt|;
comment|/* This is the tricky part.  Use some fancy footwork to deduce where the      lowest addressed bit of the containing object must be.  */
name|object_offset_in_bits
operator|=
name|deepest_bitpos
operator|-
name|type_size_in_bits
expr_stmt|;
comment|/* Round up to type_align by default.  This works best for bitfields.  */
name|object_offset_in_bits
operator|+=
name|type_align_in_bits
operator|-
literal|1
expr_stmt|;
name|object_offset_in_bits
operator|/=
name|type_align_in_bits
expr_stmt|;
name|object_offset_in_bits
operator|*=
name|type_align_in_bits
expr_stmt|;
if|if
condition|(
name|object_offset_in_bits
operator|>
name|bitpos_int
condition|)
block|{
comment|/* Sigh, the decl must be packed.  */
name|object_offset_in_bits
operator|=
name|deepest_bitpos
operator|-
name|type_size_in_bits
expr_stmt|;
comment|/* Round up to decl_align instead.  */
name|object_offset_in_bits
operator|+=
name|decl_align_in_bits
operator|-
literal|1
expr_stmt|;
name|object_offset_in_bits
operator|/=
name|decl_align_in_bits
expr_stmt|;
name|object_offset_in_bits
operator|*=
name|decl_align_in_bits
expr_stmt|;
block|}
return|return
name|object_offset_in_bits
operator|/
name|BITS_PER_UNIT
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following routines define various Dwarf attributes and any data    associated with them.  */
end_comment

begin_comment
comment|/* Add a location description attribute value to a DIE.     This emits location attributes suitable for whole variables and    whole parameters.  Note that the location attributes for struct fields are    generated by the routine `data_member_location_attribute' below.  */
end_comment

begin_function
specifier|static
name|void
name|add_AT_location_description
parameter_list|(
name|die
parameter_list|,
name|attr_kind
parameter_list|,
name|rtl
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|enum
name|dwarf_attribute
name|attr_kind
decl_stmt|;
name|rtx
name|rtl
decl_stmt|;
block|{
name|dw_loc_descr_ref
name|descr
init|=
name|loc_descriptor
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|descr
operator|!=
literal|0
condition|)
name|add_AT_loc
argument_list|(
name|die
argument_list|,
name|attr_kind
argument_list|,
name|descr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach the specialized form of location attribute used for data members of    struct and union types.  In the special case of a FIELD_DECL node which    represents a bit-field, the "offset" part of this special location    descriptor must indicate the distance in bytes from the lowest-addressed    byte of the containing struct or union type to the lowest-addressed byte of    the "containing object" for the bit-field.  (See the `field_byte_offset'    function above).     For any given bit-field, the "containing object" is a hypothetical object    (of some integral or enum type) within which the given bit-field lives.  The    type of this hypothetical "containing object" is always the same as the    declared type of the individual bit-field itself (for GCC anyway... the    DWARF spec doesn't actually mandate this).  Note that it is the size (in    bytes) of the hypothetical "containing object" which will be given in the    DW_AT_byte_size attribute for this bit-field.  (See the    `byte_size_attribute' function below.)  It is also used when calculating the    value of the DW_AT_bit_offset attribute.  (See the `bit_offset_attribute'    function below.)  */
end_comment

begin_function
specifier|static
name|void
name|add_data_member_location_attribute
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|dw_loc_descr_ref
name|loc_descr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TREE_VEC
condition|)
block|{
comment|/* We're working on the TAG_inheritance for a base class.  */
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|is_cxx
argument_list|()
condition|)
block|{
comment|/* For C++ virtual bases we can't just use BINFO_OFFSET, as they 	     aren't at a fixed offset from all (sub)objects of the same 	     type.  We need to extract the appropriate offset from our 	     vtable.  The following dwarf expression means  	       BaseAddr = ObAddr + *((*ObAddr) - Offset)  	     This is specific to the V3 ABI, of course.  */
name|dw_loc_descr_ref
name|tmp
decl_stmt|;
comment|/* Make a copy of the object address.  */
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_dup
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Extract the vtable address.  */
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_deref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Calculate the address of the offset.  */
name|offset
operator|=
name|tree_low_cst
argument_list|(
name|BINFO_VPTR_FIELD
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tmp
operator|=
name|int_loc_descriptor
argument_list|(
operator|-
name|offset
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_minus
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Extract the offset.  */
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_deref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Add it to the object address.  */
name|tmp
operator|=
name|new_loc_descr
argument_list|(
name|DW_OP_plus
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_loc_descr
argument_list|(
operator|&
name|loc_descr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|field_byte_offset
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loc_descr
condition|)
block|{
name|enum
name|dwarf_location_atom
name|op
decl_stmt|;
comment|/* The DWARF2 standard says that we should assume that the structure 	 address is already on the stack, so we can specify a structure field 	 address by using DW_OP_plus_uconst.  */
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* ??? The SGI dwarf reader does not handle the DW_OP_plus_uconst 	 operator correctly.  It works only if we leave the offset on the 	 stack.  */
name|op
operator|=
name|DW_OP_constu
expr_stmt|;
else|#
directive|else
name|op
operator|=
name|DW_OP_plus_uconst
expr_stmt|;
endif|#
directive|endif
name|loc_descr
operator|=
name|new_loc_descr
argument_list|(
name|op
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|add_AT_loc
argument_list|(
name|die
argument_list|,
name|DW_AT_data_member_location
argument_list|,
name|loc_descr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach an DW_AT_const_value attribute for a variable or a parameter which    does not have a "location" either in memory or in a register.  These    things can arise in GNU C when a constant is passed as an actual parameter    to an inlined function.  They can also arise in C++ where declared    constants do not necessarily get memory "homes".  */
end_comment

begin_function
specifier|static
name|void
name|add_const_value_attribute
parameter_list|(
name|die
parameter_list|,
name|rtl
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|rtx
name|rtl
decl_stmt|;
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
comment|/* Note that a CONST_INT rtx could represent either an integer 	 or a floating-point constant.  A CONST_INT is used whenever 	 the constant will fit into a single word.  In all such 	 cases, the original mode of the constant value is wiped 	 out, and the CONST_INT rtx is assigned VOIDmode.  */
block|{
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
comment|/* ??? We really should be using HOST_WIDE_INT throughout.  */
if|if
condition|(
name|val
operator|<
literal|0
operator|&&
operator|(
name|long
operator|)
name|val
operator|==
name|val
condition|)
name|add_AT_int
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|unsigned
name|long
operator|)
name|val
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|val
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|*
literal|2
operator|==
name|HOST_BITS_PER_WIDE_INT
name|add_AT_long_long
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|val
operator|>>
name|HOST_BITS_PER_LONG
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|#
directive|else
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
break|break;
case|case
name|CONST_DOUBLE
case|:
comment|/* Note that a CONST_DOUBLE rtx could represent either an integer or a          floating-point constant.  A CONST_DOUBLE is used whenever the          constant requires more than one word in order to be adequately          represented.  We output CONST_DOUBLEs as blocks.  */
block|{
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|unsigned
name|length
init|=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|/
literal|4
decl_stmt|;
name|long
modifier|*
name|array
init|=
operator|(
name|long
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
name|length
argument_list|)
decl_stmt|;
name|REAL_VALUE_TYPE
name|rv
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|rv
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|SFmode
case|:
name|REAL_VALUE_TO_TARGET_SINGLE
argument_list|(
name|rv
argument_list|,
name|array
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|DFmode
case|:
name|REAL_VALUE_TO_TARGET_DOUBLE
argument_list|(
name|rv
argument_list|,
name|array
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFmode
case|:
case|case
name|TFmode
case|:
name|REAL_VALUE_TO_TARGET_LONG_DOUBLE
argument_list|(
name|rv
argument_list|,
name|array
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|add_AT_float
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|length
argument_list|,
name|array
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ??? We really should be using HOST_WIDE_INT throughout.  */
if|if
condition|(
name|HOST_BITS_PER_LONG
operator|!=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|add_AT_long_long
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|rtl
argument_list|)
argument_list|,
name|CONST_DOUBLE_LOW
argument_list|(
name|rtl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CONST_STRING
case|:
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|XSTR
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
name|add_AT_addr
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
name|VARRAY_PUSH_RTX
argument_list|(
name|used_rtx_varray
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
comment|/* In cases where an inlined instance of an inline function is passed          the address of an `auto' variable (which is local to the caller) we          can get a situation where the DECL_RTL of the artificial local          variable (for the inlining) which acts as a stand-in for the          corresponding formal parameter (of the inline function) will look          like (plus:SI (reg:SI FRAME_PTR) (const_int ...)).  This is not          exactly a compile-time constant expression, but it isn't the address          of the (artificial) local variable either.  Rather, it represents the          *value* which the artificial local variable always has during its          lifetime.  We currently have no way to represent such quasi-constant          values in Dwarf, so for now we just punt and generate nothing.  */
break|break;
default|default:
comment|/* No other kinds of rtx should be possible here.  */
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|rtx
name|rtl_for_decl_location
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|rtl
decl_stmt|;
comment|/* Here we have to decide where we are going to say the parameter "lives"      (as far as the debugger is concerned).  We only have a couple of      choices.  GCC provides us with DECL_RTL and with DECL_INCOMING_RTL.       DECL_RTL normally indicates where the parameter lives during most of the      activation of the function.  If optimization is enabled however, this      could be either NULL or else a pseudo-reg.  Both of those cases indicate      that the parameter doesn't really live anywhere (as far as the code      generation parts of GCC are concerned) during most of the function's      activation.  That will happen (for example) if the parameter is never      referenced within the function.       We could just generate a location descriptor here for all non-NULL      non-pseudo values of DECL_RTL and ignore all of the rest, but we can be      a little nicer than that if we also consider DECL_INCOMING_RTL in cases      where DECL_RTL is NULL or is a pseudo-reg.       Note however that we can only get away with using DECL_INCOMING_RTL as      a backup substitute for DECL_RTL in certain limited cases.  In cases      where DECL_ARG_TYPE (decl) indicates the same type as TREE_TYPE (decl),      we can be sure that the parameter was passed using the same type as it is      declared to have within the function, and that its DECL_INCOMING_RTL      points us to a place where a value of that type is passed.       In cases where DECL_ARG_TYPE (decl) and TREE_TYPE (decl) are different,      we cannot (in general) use DECL_INCOMING_RTL as a substitute for DECL_RTL      because in these cases DECL_INCOMING_RTL points us to a value of some      type which is *different* from the type of the parameter itself.  Thus,      if we tried to use DECL_INCOMING_RTL to generate a location attribute in      such cases, the debugger would end up (for example) trying to fetch a      `float' from a place which actually contains the first part of a      `double'.  That would lead to really incorrect and confusing      output at debug-time.       So, in general, we *do not* use DECL_INCOMING_RTL as a backup for DECL_RTL      in cases where DECL_ARG_TYPE (decl) != TREE_TYPE (decl).  There      are a couple of exceptions however.  On little-endian machines we can      get away with using DECL_INCOMING_RTL even when DECL_ARG_TYPE (decl) is      not the same as TREE_TYPE (decl), but only when DECL_ARG_TYPE (decl) is      an integral type that is smaller than TREE_TYPE (decl). These cases arise      when (on a little-endian machine) a non-prototyped function has a      parameter declared to be of type `short' or `char'.  In such cases,      TREE_TYPE (decl) will be `short' or `char', DECL_ARG_TYPE (decl) will      be `int', and DECL_INCOMING_RTL will point to the lowest-order byte of the      passed `int' value.  If the debugger then uses that address to fetch      a `short' or a `char' (on a little-endian machine) the result will be      the correct data, so we allow for such exceptional cases below.       Note that our goal here is to describe the place where the given formal      parameter lives during most of the function's activation (i.e. between the      end of the prologue and the start of the epilogue).  We'll do that as best      as we can. Note however that if the given formal parameter is modified      sometime during the execution of the function, then a stack backtrace (at      debug-time) will show the function as having been called with the *new*      value rather than the value which was originally passed in.  This happens      rarely enough that it is not a major problem, but it *is* a problem, and      I'd like to fix it.       A future version of dwarf2out.c may generate two additional attributes for      any given DW_TAG_formal_parameter DIE which will describe the "passed      type" and the "passed location" for the given formal parameter in addition      to the attributes we now generate to indicate the "declared type" and the      "active location" for each parameter.  This additional set of attributes      could be used by debuggers for stack backtraces. Separately, note that      sometimes DECL_RTL can be NULL and DECL_INCOMING_RTL can be NULL also.      This happens (for example) for inlined-instances of inline function formal      parameters which are never referenced.  This really shouldn't be      happening.  All PARM_DECL nodes should get valid non-NULL      DECL_INCOMING_RTL values, but integrate.c doesn't currently generate these      values for inlined instances of inline function parameters, so when we see      such cases, we are just out-of-luck for the time being (until integrate.c      gets fixed).  */
comment|/* Use DECL_RTL as the "location" unless we find something better.  */
name|rtl
operator|=
name|DECL_RTL_IF_SET
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* When generating abstract instances, ignore everything except      constants and symbols living in memory.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
block|{
if|if
condition|(
name|rtl
operator|&&
operator|(
name|CONSTANT_P
argument_list|(
name|rtl
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
return|return
name|rtl
return|;
name|rtl
operator|=
name|NULL_RTX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
operator|||
name|is_pseudo_reg
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
name|tree
name|declared_type
init|=
name|type_main_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|passed_type
init|=
name|type_main_variant
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
comment|/* This decl represents a formal parameter which was optimized out. 	     Note that DECL_INCOMING_RTL may be NULL in here, but we handle 	     all cases where (rtl == NULL_RTX) just below.  */
if|if
condition|(
name|declared_type
operator|==
name|passed_type
condition|)
name|rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
operator|&&
name|TREE_CODE
argument_list|(
name|declared_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|declared_type
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|passed_type
argument_list|)
argument_list|)
operator|)
condition|)
name|rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* If the parm was passed in registers, but lives on the stack, then 	 make a big endian correction if the mode of the type of the 	 parameter is not the same as the mode of the rtl.  */
comment|/* ??? This is the same series of checks that are made in dbxout.c before 	 we reach the big endian correction code there.  It isn't clear if all 	 of these checks are necessary here, but keeping them all is the safe 	 thing to do.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
operator|!=
name|const0_rtx
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
comment|/* Not passed in memory.  */
operator|&&
name|GET_CODE
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
comment|/* Not passed by invisible reference.  */
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|STACK_POINTER_REGNUM
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|)
comment|/* Big endian correction check.  */
operator|&&
name|BYTES_BIG_ENDIAN
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|rtl
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|<
name|UNITS_PER_WORD
operator|)
condition|)
block|{
name|int
name|offset
init|=
operator|(
name|UNITS_PER_WORD
operator|-
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|rtl
operator|=
name|gen_rtx_MEM
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtl
operator|!=
name|NULL_RTX
condition|)
block|{
name|rtl
operator|=
name|eliminate_regs
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* A variable with no DECL_RTL but a DECL_INITIAL is a compile-time constant,      and will have been substituted directly into all expressions that use it.      C does not have such a concept, but C++ and other languages do.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|rtl
operator|=
name|expand_expr
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
expr_stmt|;
return|return
name|rtl
return|;
block|}
end_function

begin_comment
comment|/* Generate *either* an DW_AT_location attribute or else an DW_AT_const_value    data attribute for a variable or a parameter.  We generate the    DW_AT_const_value attribute only in those cases where the given variable    or parameter does not have a true "location" either in memory or in a    register.  This can happen (for example) when a constant is passed as an    actual argument in a call to an inline function.  (It's possible that    these things can crop up in other ways also.)  Note that one type of    constant value which can be passed into an inlined function is a constant    pointer.  This can happen for example if an actual argument in an inlined    function call evaluates to a compile-time constant address.  */
end_comment

begin_function
specifier|static
name|void
name|add_location_or_const_value_attribute
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|rtl
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|rtl
operator|=
name|rtl_for_decl_location
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl
operator|==
name|NULL_RTX
condition|)
return|return;
comment|/* If we don't look past the constant pool, we risk emitting a      reference to a constant pool entry that isn't referenced from      code, and thus is not emitted.  */
name|rtl
operator|=
name|avoid_constant_pool_reference
argument_list|(
name|rtl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
condition|)
block|{
case|case
name|ADDRESSOF
case|:
comment|/* The address of a variable that was optimized away; don't emit 	 anything.  */
break|break;
case|case
name|CONST_INT
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_STRING
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
case|case
name|CONST
case|:
case|case
name|PLUS
case|:
comment|/* DECL_RTL could be (plus (reg ...) (const_int ...)) */
name|add_const_value_attribute
argument_list|(
name|die
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM
case|:
case|case
name|REG
case|:
case|case
name|SUBREG
case|:
case|case
name|CONCAT
case|:
name|add_AT_location_description
argument_list|(
name|die
argument_list|,
name|DW_AT_location
argument_list|,
name|rtl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If we don't have a copy of this variable in memory for some reason (such    as a C++ member constant that doesn't have an out-of-line definition),    we should tell the debugger about the constant value.  */
end_comment

begin_function
specifier|static
name|void
name|tree_add_const_value_attribute
parameter_list|(
name|var_die
parameter_list|,
name|decl
parameter_list|)
name|dw_die_ref
name|var_die
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|&&
name|init
operator|&&
name|initializer_constant_valid_p
argument_list|(
name|init
argument_list|,
name|type
argument_list|)
operator|==
name|null_pointer_node
condition|)
comment|/* OK */
empty_stmt|;
else|else
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|host_integerp
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|tree_low_cst
argument_list|(
name|init
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_AT_long_long
argument_list|(
name|var_die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|init
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|init
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate an DW_AT_name attribute given some string value to be included as    the value of the attribute.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_name_attribute
parameter_list|(
name|die
parameter_list|,
name|name_string
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_string
decl_stmt|;
block|{
if|if
condition|(
name|name_string
operator|!=
name|NULL
operator|&&
operator|*
name|name_string
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|demangle_name_func
condition|)
name|name_string
operator|=
call|(
modifier|*
name|demangle_name_func
call|)
argument_list|(
name|name_string
argument_list|)
expr_stmt|;
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|,
name|name_string
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a tree node describing an array bound (either lower or upper) output    a representation for that bound.  */
end_comment

begin_function
specifier|static
name|void
name|add_bound_info
parameter_list|(
name|subrange_die
parameter_list|,
name|bound_attr
parameter_list|,
name|bound
parameter_list|)
name|dw_die_ref
name|subrange_die
decl_stmt|;
name|enum
name|dwarf_attribute
name|bound_attr
decl_stmt|;
name|tree
name|bound
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|bound
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return;
comment|/* All fixed-bounds are represented by INTEGER_CST nodes.  */
case|case
name|INTEGER_CST
case|:
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
operator|||
operator|(
name|bound_attr
operator|==
name|DW_AT_lower_bound
operator|&&
operator|(
operator|(
operator|(
name|is_c_family
argument_list|()
operator|||
name|is_java
argument_list|()
operator|)
operator|&&
name|integer_zerop
argument_list|(
name|bound
argument_list|)
operator|)
operator|||
operator|(
name|is_fortran
argument_list|()
operator|&&
name|integer_onep
argument_list|(
name|bound
argument_list|)
operator|)
operator|)
operator|)
condition|)
comment|/* use the default */
empty_stmt|;
else|else
name|add_AT_unsigned
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|tree_low_cst
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
name|add_bound_info
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|TREE_OPERAND
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SAVE_EXPR
case|:
comment|/* If optimization is turned on, the SAVE_EXPRs that describe how to          access the upper bound values may be bogus.  If they refer to a          register, they may only describe how to get at these values at the          points in the generated code right after they have just been          computed.  Worse yet, in the typical case, the upper bound values          will not even *be* computed in the optimized code (though the          number of elements will), so these SAVE_EXPRs are entirely          bogus. In order to compensate for this fact, we check here to see          if optimization is enabled, and if so, we don't add an attribute          for the (unknown and unknowable) upper bound.  This should not          cause too much trouble for existing (stupid?)  debuggers because          they have to deal with empty upper bounds location descriptions          anyway in order to be able to deal with incomplete array types.          Of course an intelligent debugger (GDB?)  should be able to          comprehend that a missing upper bound specification in an array          type used for a storage class `auto' local array variable          indicates that the upper bound is both unknown (at compile- time)          and unknowable (at run-time) due to optimization.  	 We assume that a MEM rtx is safe because gcc wouldn't put the 	 value there unless it was going to be used repeatedly in the 	 function, i.e. for cleanups.  */
if|if
condition|(
name|SAVE_EXPR_RTL
argument_list|(
name|bound
argument_list|)
operator|&&
operator|(
operator|!
name|optimize
operator|||
name|GET_CODE
argument_list|(
name|SAVE_EXPR_RTL
argument_list|(
name|bound
argument_list|)
argument_list|)
operator|==
name|MEM
operator|)
condition|)
block|{
name|dw_die_ref
name|ctx
init|=
name|lookup_decl_die
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
name|dw_die_ref
name|decl_die
init|=
name|new_die
argument_list|(
name|DW_TAG_variable
argument_list|,
name|ctx
argument_list|,
name|bound
argument_list|)
decl_stmt|;
name|rtx
name|loc
init|=
name|SAVE_EXPR_RTL
argument_list|(
name|bound
argument_list|)
decl_stmt|;
comment|/* If the RTL for the SAVE_EXPR is memory, handle the case where 	     it references an outer function's frame.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|loc
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|new_addr
init|=
name|fix_lexical_addr
argument_list|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|bound
argument_list|)
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|loc
argument_list|,
literal|0
argument_list|)
operator|!=
name|new_addr
condition|)
name|loc
operator|=
name|gen_rtx_MEM
argument_list|(
name|GET_MODE
argument_list|(
name|loc
argument_list|)
argument_list|,
name|new_addr
argument_list|)
expr_stmt|;
block|}
name|add_AT_flag
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|decl_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|bound
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|add_AT_location_description
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_location
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|decl_die
argument_list|)
expr_stmt|;
block|}
comment|/* Else leave out the attribute.  */
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
block|{
name|dw_die_ref
name|decl_die
init|=
name|lookup_decl_die
argument_list|(
name|bound
argument_list|)
decl_stmt|;
comment|/* ??? Can this happen, or should the variable have been bound 	   first?  Probably it can, since I imagine that we try to create 	   the types of parameters in the order in which they exist in 	   the list, and won't have created a forward reference to a 	   later parameter.  */
if|if
condition|(
name|decl_die
operator|!=
name|NULL
condition|)
name|add_AT_die_ref
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|decl_die
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
comment|/* Otherwise try to create a stack operation procedure to 	   evaluate the value of the array bound.  */
name|dw_die_ref
name|ctx
decl_stmt|,
name|decl_die
decl_stmt|;
name|dw_loc_descr_ref
name|loc
decl_stmt|;
name|loc
operator|=
name|loc_descriptor_from_tree
argument_list|(
name|bound
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
name|ctx
operator|=
name|comp_unit_die
expr_stmt|;
else|else
name|ctx
operator|=
name|lookup_decl_die
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* If we weren't able to find a context, it's most likely the case 	   that we are processing the return type of the function.  So 	   make a SAVE_EXPR to point to it and have the limbo DIE code 	   find the proper die.  The save_expr function doesn't always 	   make a SAVE_EXPR, so do it ourselves.  */
if|if
condition|(
name|ctx
operator|==
literal|0
condition|)
name|bound
operator|=
name|build
argument_list|(
name|SAVE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|bound
argument_list|)
argument_list|,
name|bound
argument_list|,
name|current_function_decl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|decl_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_variable
argument_list|,
name|ctx
argument_list|,
name|bound
argument_list|)
expr_stmt|;
name|add_AT_flag
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|decl_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|bound
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|add_AT_loc
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_location
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|subrange_die
argument_list|,
name|bound_attr
argument_list|,
name|decl_die
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Note that the block of subscript information for an array type also    includes information about the element type of type given array type.  */
end_comment

begin_function
specifier|static
name|void
name|add_subscript_info
parameter_list|(
name|type_die
parameter_list|,
name|type
parameter_list|)
name|dw_die_ref
name|type_die
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
name|unsigned
name|dimension_number
decl_stmt|;
endif|#
directive|endif
name|tree
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|dw_die_ref
name|subrange_die
decl_stmt|;
comment|/* The GNU compilers represent multidimensional array types as sequences of      one dimensional array types whose element types are themselves array      types.  Here we squish that down, so that each multidimensional array      type gets only one array_type DIE in the Dwarf debugging info. The draft      Dwarf specification say that we are allowed to do this kind of      compression in C (because there is no difference between an array or      arrays and a multidimensional array in C) but for other source languages      (e.g. Ada) we probably shouldn't do this.  */
comment|/* ??? The SGI dwarf reader fails for multidimensional arrays with a      const enum type.  E.g. const enum machine_mode insn_operand_mode[2][10].      We work around this by disabling this feature.  See also      gen_array_type_die.  */
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
for|for
control|(
name|dimension_number
operator|=
literal|0
init|;
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|,
name|dimension_number
operator|++
control|)
endif|#
directive|endif
block|{
name|tree
name|domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Arrays come in three flavors: Unspecified bounds, fixed bounds, 	 and (in GNU C only) variable bounds.  Handle all three forms          here.  */
name|subrange_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subrange_type
argument_list|,
name|type_die
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
condition|)
block|{
comment|/* We have an array type with specified bounds.  */
name|lower
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|upper
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|domain
argument_list|)
expr_stmt|;
comment|/* define the index type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
condition|)
block|{
comment|/* ??? This is probably an Ada unnamed subrange type.  Ignore the 		 TREE_TYPE field.  We can't emit debug info for this 		 because it is an unnamed integral type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|domain
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|domain
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|==
name|NULL_TREE
condition|)
empty_stmt|;
else|else
name|add_type_attribute
argument_list|(
name|subrange_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
comment|/* ??? If upper is NULL, the array has unspecified length, 	     but it does have a lower bound.  This happens with Fortran 	       dimension arr(N:*)        	     Since the debugger is definitely going to need to know N 	     to produce useful results, go ahead and output the lower 	     bound solo, and hope the debugger can cope.  */
name|add_bound_info
argument_list|(
name|subrange_die
argument_list|,
name|DW_AT_lower_bound
argument_list|,
name|lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper
condition|)
name|add_bound_info
argument_list|(
name|subrange_die
argument_list|,
name|DW_AT_upper_bound
argument_list|,
name|upper
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise we have an array type with an unspecified length.  The 	 DWARF-2 spec does not say how to handle this; let's just leave out the 	 bounds.  */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_byte_size_attribute
parameter_list|(
name|die
parameter_list|,
name|tree_node
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|tree
name|tree_node
decl_stmt|;
block|{
name|unsigned
name|size
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|tree_node
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
name|size
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|tree_node
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD_DECL
case|:
comment|/* For a data member of a struct or union, the DW_AT_byte_size is          generally given as the number of bytes normally allocated for an          object of the *declared* type of the member itself.  This is true          even for bit-fields.  */
name|size
operator|=
name|simple_type_size_in_bits
argument_list|(
name|field_type
argument_list|(
name|tree_node
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Note that `size' might be -1 when we get to this point.  If it is, that      indicates that the byte size of the entity in question is variable.  We      have no good way of expressing this fact in Dwarf at the present time,      so just let the -1 pass on through.  */
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a FIELD_DECL node which represents a bit-field, output an attribute    which specifies the distance in bits from the highest order bit of the    "containing object" for the bit-field to the highest order bit of the    bit-field itself.     For any given bit-field, the "containing object" is a hypothetical object    (of some integral or enum type) within which the given bit-field lives.  The    type of this hypothetical "containing object" is always the same as the    declared type of the individual bit-field itself.  The determination of the    exact location of the "containing object" for a bit-field is rather    complicated.  It's handled by the `field_byte_offset' function (above).     Note that it is the size (in bytes) of the hypothetical "containing object"    which will be given in the DW_AT_byte_size attribute for this bit-field.    (See `byte_size_attribute' above).  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_bit_offset_attribute
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|object_offset_in_bytes
init|=
name|field_byte_offset
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|bitpos_int
decl_stmt|;
name|HOST_WIDE_INT
name|highest_order_object_bit_offset
decl_stmt|;
name|HOST_WIDE_INT
name|highest_order_field_bit_offset
decl_stmt|;
name|HOST_WIDE_INT
name|unsigned
name|bit_offset
decl_stmt|;
comment|/* Must be a field and a bit field.  */
if|if
condition|(
operator|!
name|type
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* We can't yet handle bit-fields whose offsets are variable, so if we      encounter such things, just return without generating any attribute      whatsoever.  Likewise for variable or too large size.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
name|bitpos_int
operator|=
name|int_bit_position
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Note that the bit offset is always the distance (in bits) from the      highest-order bit of the "containing object" to the highest-order bit of      the bit-field itself.  Since the "high-order end" of any object or field      is different on big-endian and little-endian machines, the computation      below must take account of these differences.  */
name|highest_order_object_bit_offset
operator|=
name|object_offset_in_bytes
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|highest_order_field_bit_offset
operator|=
name|bitpos_int
expr_stmt|;
if|if
condition|(
operator|!
name|BYTES_BIG_ENDIAN
condition|)
block|{
name|highest_order_field_bit_offset
operator|+=
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|highest_order_object_bit_offset
operator|+=
name|simple_type_size_in_bits
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|bit_offset
operator|=
operator|(
operator|!
name|BYTES_BIG_ENDIAN
condition|?
name|highest_order_object_bit_offset
operator|-
name|highest_order_field_bit_offset
else|:
name|highest_order_field_bit_offset
operator|-
name|highest_order_object_bit_offset
operator|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_bit_offset
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For a FIELD_DECL node which represents a bit field, output an attribute    which specifies the length in bits of the given field.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_bit_size_attribute
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
comment|/* Must be a field and a bit field.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
operator|||
operator|!
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_bit_size
argument_list|,
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the compiled language is ANSI C, then add a 'prototyped'    attribute, if arg types are given for the parameters of a function.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_prototyped_attribute
parameter_list|(
name|die
parameter_list|,
name|func_type
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|tree
name|func_type
decl_stmt|;
block|{
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
operator|==
name|DW_LANG_C89
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|func_type
argument_list|)
operator|!=
name|NULL
condition|)
name|add_AT_flag
argument_list|(
name|die
argument_list|,
name|DW_AT_prototyped
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an 'abstract_origin' attribute below a given DIE.  The DIE is found    by looking in either the type declaration or object declaration    equate table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_abstract_origin_attribute
parameter_list|(
name|die
parameter_list|,
name|origin
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|tree
name|origin
decl_stmt|;
block|{
name|dw_die_ref
name|origin_die
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
comment|/* We may have gotten separated from the block for the inlined 	 function, if we're in an exception handler or some such; make 	 sure that the abstract function has been written out.           Doing this for nested functions is wrong, however; functions are 	 distinct units, and our context might not even be inline.  */
name|tree
name|fn
init|=
name|origin
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|fn
argument_list|)
condition|)
name|fn
operator|=
name|TYPE_STUB_DECL
argument_list|(
name|fn
argument_list|)
expr_stmt|;
name|fn
operator|=
name|decl_function_context
argument_list|(
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
condition|)
name|dwarf2out_abstract_function
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_P
argument_list|(
name|origin
argument_list|)
condition|)
name|origin_die
operator|=
name|lookup_decl_die
argument_list|(
name|origin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|origin
argument_list|)
condition|)
name|origin_die
operator|=
name|lookup_type_die
argument_list|(
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin_die
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|die
argument_list|,
name|DW_AT_abstract_origin
argument_list|,
name|origin_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We do not currently support the pure_virtual attribute.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|add_pure_or_virtual_attribute
parameter_list|(
name|die
parameter_list|,
name|func_decl
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|tree
name|func_decl
decl_stmt|;
block|{
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|func_decl
argument_list|)
condition|)
block|{
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_virtuality
argument_list|,
name|DW_VIRTUALITY_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|DECL_VINDEX
argument_list|(
name|func_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
name|add_AT_loc
argument_list|(
name|die
argument_list|,
name|DW_AT_vtable_elem_location
argument_list|,
name|new_loc_descr
argument_list|(
name|DW_OP_constu
argument_list|,
name|tree_low_cst
argument_list|(
name|DECL_VINDEX
argument_list|(
name|func_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* GNU extension: Record what type this method came from originally.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
name|add_AT_die_ref
argument_list|(
name|die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|lookup_type_die
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|func_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add source coordinate attributes for the given decl.  */
end_comment

begin_function
specifier|static
name|void
name|add_src_coords_attributes
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|unsigned
name|file_index
init|=
name|lookup_filename
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_file
argument_list|,
name|file_index
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_line
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an DW_AT_name attribute and source coordinate attribute for the    given decl, but only if it actually has a name.  */
end_comment

begin_function
specifier|static
name|void
name|add_name_and_src_coords_attributes
parameter_list|(
name|die
parameter_list|,
name|decl
parameter_list|)
name|dw_die_ref
name|die
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|decl_name
decl_stmt|;
name|decl_name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl_name
operator|!=
name|NULL
operator|&&
name|IDENTIFIER_POINTER
argument_list|(
name|decl_name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|add_name_attribute
argument_list|(
name|die
argument_list|,
name|dwarf2_name
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|add_src_coords_attributes
argument_list|(
name|die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_MIPS_linkage_name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VMS_DEBUGGING_INFO
comment|/* Get the function's name, as described by its RTL.  This may be different      from the DECL_NAME name used in the source file.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|add_AT_addr
argument_list|(
name|die
argument_list|,
name|DW_AT_VMS_rtnbeg_pd_address
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|VARRAY_PUSH_RTX
argument_list|(
name|used_rtx_varray
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Push a new declaration scope.  */
end_comment

begin_function
specifier|static
name|void
name|push_decl_scope
parameter_list|(
name|scope
parameter_list|)
name|tree
name|scope
decl_stmt|;
block|{
name|VARRAY_PUSH_TREE
argument_list|(
name|decl_scope_table
argument_list|,
name|scope
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pop a declaration scope.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|pop_decl_scope
parameter_list|()
block|{
if|if
condition|(
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|decl_scope_table
argument_list|)
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|VARRAY_POP
argument_list|(
name|decl_scope_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the DIE for the scope that immediately contains this type.    Non-named types get global scope.  Named types nested in other    types get their containing scope if it's open, or global scope    otherwise.  All other types (i.e. function-local named types) get    the current active scope.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|scope_die_for
parameter_list|(
name|t
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|t
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|scope_die
init|=
name|NULL
decl_stmt|;
name|tree
name|containing_scope
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Non-types always go in the current scope.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|containing_scope
operator|=
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Ignore namespaces for the moment.  */
if|if
condition|(
name|containing_scope
operator|&&
name|TREE_CODE
argument_list|(
name|containing_scope
argument_list|)
operator|==
name|NAMESPACE_DECL
condition|)
name|containing_scope
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* Ignore function type "scopes" from the C frontend.  They mean that      a tagged type is local to a parmlist of a function declarator, but      that isn't useful to DWARF.  */
if|if
condition|(
name|containing_scope
operator|&&
name|TREE_CODE
argument_list|(
name|containing_scope
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|containing_scope
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|containing_scope
operator|==
name|NULL_TREE
condition|)
name|scope_die
operator|=
name|comp_unit_die
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
name|containing_scope
argument_list|)
condition|)
block|{
comment|/* For types, we can just look up the appropriate DIE.  But 	 first we check to see if we're in the middle of emitting it 	 so we know where the new DIE should go.  */
for|for
control|(
name|i
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|decl_scope_table
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|VARRAY_TREE
argument_list|(
name|decl_scope_table
argument_list|,
name|i
argument_list|)
operator|==
name|containing_scope
condition|)
break|break;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|containing_scope
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If none of the current dies are suitable, we get file scope.  */
name|scope_die
operator|=
name|comp_unit_die
expr_stmt|;
block|}
else|else
name|scope_die
operator|=
name|lookup_type_die
argument_list|(
name|containing_scope
argument_list|)
expr_stmt|;
block|}
else|else
name|scope_die
operator|=
name|context_die
expr_stmt|;
return|return
name|scope_die
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if CONTEXT_DIE is internal to a function.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|local_scope_p
parameter_list|(
name|context_die
parameter_list|)
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
for|for
control|(
init|;
name|context_die
condition|;
name|context_die
operator|=
name|context_die
operator|->
name|die_parent
control|)
if|if
condition|(
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_inlined_subroutine
operator|||
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_subprogram
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if CONTEXT_DIE is a class.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|class_scope_p
parameter_list|(
name|context_die
parameter_list|)
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
return|return
operator|(
name|context_die
operator|&&
operator|(
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_structure_type
operator|||
name|context_die
operator|->
name|die_tag
operator|==
name|DW_TAG_union_type
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Many forms of DIEs require a "type description" attribute.  This    routine locates the proper "type descriptor" die for the type given    by 'type', and adds an DW_AT_type attribute below the given die.  */
end_comment

begin_function
specifier|static
name|void
name|add_type_attribute
parameter_list|(
name|object_die
parameter_list|,
name|type
parameter_list|,
name|decl_const
parameter_list|,
name|decl_volatile
parameter_list|,
name|context_die
parameter_list|)
name|dw_die_ref
name|object_die
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|decl_const
decl_stmt|;
name|int
name|decl_volatile
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|dw_die_ref
name|type_die
init|=
name|NULL
decl_stmt|;
comment|/* ??? If this type is an unnamed subrange type of an integral or      floating-point type, use the inner type.  This is because we have no      support for unnamed types in base_type_die.  This can happen if this is      an Ada subrange type.  Correct solution is emit a subrange type die.  */
if|if
condition|(
operator|(
name|code
operator|==
name|INTEGER_TYPE
operator|||
name|code
operator|==
name|REAL_TYPE
operator|)
operator|&&
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|,
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ERROR_MARK
comment|/* Handle a special case.  For functions whose return type is void, we 	 generate *no* type attribute.  (Note that no object may have type 	 `void', so this only applies to function return types).  */
operator|||
name|code
operator|==
name|VOID_TYPE
condition|)
return|return;
name|type_die
operator|=
name|modified_type_die
argument_list|(
name|type
argument_list|,
name|decl_const
operator|||
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
name|decl_volatile
operator|||
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_die
operator|!=
name|NULL
condition|)
name|add_AT_die_ref
argument_list|(
name|object_die
argument_list|,
name|DW_AT_type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a tree pointer to a struct, class, union, or enum type node, return    a pointer to the (string) tag name for the given type, or zero if the type    was declared without a tag.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|type_tag
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tree
name|t
init|=
literal|0
decl_stmt|;
comment|/* Find the IDENTIFIER_NODE for the type name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The g++ front end makes the TYPE_NAME of *each* tagged type point to          a TYPE_DECL node, regardless of whether or not a `typedef' was          involved.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|t
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now get the name as a string, or invent one.  */
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|==
literal|0
operator|||
operator|*
name|name
operator|==
literal|'\0'
operator|)
condition|?
literal|0
else|:
name|name
return|;
block|}
end_function

begin_comment
comment|/* Return the type associated with a data member, make a special check    for bit field types.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|member_declared_type
parameter_list|(
name|member
parameter_list|)
name|tree
name|member
decl_stmt|;
block|{
return|return
operator|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|member
argument_list|)
condition|?
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|member
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|member
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the decl's label, as described by its RTL. This may be different    from the DECL_NAME name used in the source file.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char * decl_start_label (decl)      tree decl; {   rtx x;   const char *fnname;    x = DECL_RTL (decl);   if (GET_CODE (x) != MEM)     abort ();    x = XEXP (x, 0);   if (GET_CODE (x) != SYMBOL_REF)     abort ();    fnname = XSTR (x, 0);   return fnname; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* These routines generate the internal representation of the DIE's for    the compilation unit.  Debugging information is collected by walking    the declaration trees passed in from dwarf2out_decl().  */
end_comment

begin_function
specifier|static
name|void
name|gen_array_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|scope_die
init|=
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
decl_stmt|;
name|dw_die_ref
name|array_die
decl_stmt|;
name|tree
name|element_type
decl_stmt|;
comment|/* ??? The SGI dwarf reader fails for array of array of enum types unless      the inner array type comes before the outer array type.  Thus we must      call gen_type_die before we call new_die.  See below also.  */
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|array_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_array_type
argument_list|,
name|scope_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* We default the array ordering.  SDB will probably do      the right things even if DW_AT_ordering is not present.  It's not even      an issue until we start to get into multidimensional arrays anyway.  If      SDB is ever caught doing the Wrong Thing for multi-dimensional arrays,      then we'll have to put the DW_AT_ordering attribute back in.  (But if      and when we find out that we need to put these in, we will only do so      for multidimensional arrays.  */
block|add_AT_unsigned (array_die, DW_AT_ordering, DW_ORD_row_major);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* The SGI compilers handle arrays of unknown bound by setting      AT_declaration and not emitting any subrange DIEs.  */
if|if
condition|(
operator|!
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|array_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|add_subscript_info
argument_list|(
name|array_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|add_name_attribute
argument_list|(
name|array_die
argument_list|,
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|array_die
argument_list|)
expr_stmt|;
comment|/* Add representation of the type of the elements of this array type.  */
name|element_type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* ??? The SGI dwarf reader fails for multidimensional arrays with a      const enum type.  E.g. const enum machine_mode insn_operand_mode[2][10].      We work around this by disabling this feature.  See also      add_subscript_info.  */
ifndef|#
directive|ifndef
name|MIPS_DEBUGGING_INFO
while|while
condition|(
name|TREE_CODE
argument_list|(
name|element_type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|element_type
operator|=
name|TREE_TYPE
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|gen_type_die
argument_list|(
name|element_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_type_attribute
argument_list|(
name|array_die
argument_list|,
name|element_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gen_set_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_set_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|type_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void gen_entry_point_die (decl, context_die)      tree decl;      dw_die_ref context_die; {   tree origin = decl_ultimate_origin (decl);   dw_die_ref decl_die = new_die (DW_TAG_entry_point, context_die, decl);    if (origin != NULL)     add_abstract_origin_attribute (decl_die, origin);   else     {       add_name_and_src_coords_attributes (decl_die, decl);       add_type_attribute (decl_die, TREE_TYPE (TREE_TYPE (decl)), 			  0, 0, context_die);     }    if (DECL_ABSTRACT (decl))     equate_decl_number_to_die (decl, decl_die);   else     add_AT_lbl_id (decl_die, DW_AT_low_pc, decl_start_label (decl)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Walk through the list of incomplete types again, trying once more to    emit full debugging info for them.  */
end_comment

begin_function
specifier|static
name|void
name|retry_incomplete_types
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|VARRAY_ACTIVE_SIZE
argument_list|(
name|incomplete_types
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|gen_type_die
argument_list|(
name|VARRAY_TREE
argument_list|(
name|incomplete_types
argument_list|,
name|i
argument_list|)
argument_list|,
name|comp_unit_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an inlined instance of an enumeration type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_enumeration_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_enumeration_type
argument_list|,
name|context_die
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may      be incomplete and such types are not marked.  */
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an inlined instance of a structure type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_structure_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_structure_type
argument_list|,
name|context_die
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may      be incomplete and such types are not marked.  */
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an inlined instance of a union type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_union_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_union_type
argument_list|,
name|context_die
argument_list|,
name|type
argument_list|)
decl_stmt|;
comment|/* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may      be incomplete and such types are not marked.  */
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent an enumeration type.  Note that these DIEs    include all of the information about the enumeration values also. Each    enumerated type name/value is listed as a child of the enumerated type    DIE.  */
end_comment

begin_function
specifier|static
name|void
name|gen_enumeration_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|type_die
init|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type_die
operator|==
name|NULL
condition|)
block|{
name|type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_enumeration_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|add_name_attribute
argument_list|(
name|type_die
argument_list|,
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
return|return;
else|else
name|remove_AT
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|)
expr_stmt|;
comment|/* Handle a GNU C/C++ extension, i.e. incomplete enum types.  If the      given enum type is incomplete, do not generate the DW_AT_byte_size      attribute or the DW_AT_element_list attribute.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|link
decl_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_byte_size_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|add_src_coords_attributes
argument_list|(
name|type_die
argument_list|,
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the first reference to this type was as the return type of an 	 inline function, then it may not have a parent.  Fix this now.  */
if|if
condition|(
name|type_die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
name|add_child_die
argument_list|(
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|link
operator|!=
name|NULL
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|dw_die_ref
name|enum_die
init|=
name|new_die
argument_list|(
name|DW_TAG_enumerator
argument_list|,
name|type_die
argument_list|,
name|link
argument_list|)
decl_stmt|;
name|add_name_attribute
argument_list|(
name|enum_die
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|add_AT_int
argument_list|(
name|enum_die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|add_AT_unsigned
argument_list|(
name|enum_die
argument_list|,
name|DW_AT_const_value
argument_list|,
name|tree_low_cst
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|add_AT_flag
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent either a real live formal parameter decl or to    represent just the type of some formal parameter position in some function    type.     Note that this routine is a bit unusual because its argument may be a    ..._DECL node (i.e. either a PARM_DECL or perhaps a VAR_DECL which    represents an inlining of some PARM_DECL) or else some sort of a ..._TYPE    node.  If it's the former then this function is being called to output a    DIE to represent a formal parameter object (or some inlining thereof).  If    it's the latter, then this function is only being called to output a    DW_TAG_formal_parameter DIE to stand as a placeholder for some formal    argument type of some subprogram type.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|gen_formal_parameter_die
parameter_list|(
name|node
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|node
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|parm_die
init|=
name|new_die
argument_list|(
name|DW_TAG_formal_parameter
argument_list|,
name|context_die
argument_list|,
name|node
argument_list|)
decl_stmt|;
name|tree
name|origin
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'d'
case|:
name|origin
operator|=
name|decl_ultimate_origin
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|parm_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|add_name_and_src_coords_attributes
argument_list|(
name|parm_die
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|parm_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|node
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|node
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|node
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|parm_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|equate_decl_number_to_die
argument_list|(
name|node
argument_list|,
name|parm_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_ABSTRACT
argument_list|(
name|node
argument_list|)
condition|)
name|add_location_or_const_value_attribute
argument_list|(
name|parm_die
argument_list|,
name|node
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* We were called with some kind of a ..._TYPE node.  */
name|add_type_attribute
argument_list|(
name|parm_die
argument_list|,
name|node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
name|parm_die
return|;
block|}
end_function

begin_comment
comment|/* Generate a special type of DIE used as a stand-in for a trailing ellipsis    at the end of an (ANSI prototyped) formal parameters list.  */
end_comment

begin_function
specifier|static
name|void
name|gen_unspecified_parameters_die
parameter_list|(
name|decl_or_type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|decl_or_type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|new_die
argument_list|(
name|DW_TAG_unspecified_parameters
argument_list|,
name|context_die
argument_list|,
name|decl_or_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a list of nameless DW_TAG_formal_parameter DIEs (and perhaps a    DW_TAG_unspecified_parameters DIE) to represent the types of the formal    parameters as specified in some function type specification (except for    those which appear as part of a function *definition*).  */
end_comment

begin_function
specifier|static
name|void
name|gen_formal_types_die
parameter_list|(
name|function_or_method_type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|function_or_method_type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|tree
name|link
decl_stmt|;
name|tree
name|formal_type
init|=
name|NULL
decl_stmt|;
name|tree
name|first_parm_type
decl_stmt|;
name|tree
name|arg
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|function_or_method_type
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|arg
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|function_or_method_type
argument_list|)
expr_stmt|;
name|function_or_method_type
operator|=
name|TREE_TYPE
argument_list|(
name|function_or_method_type
argument_list|)
expr_stmt|;
block|}
else|else
name|arg
operator|=
name|NULL_TREE
expr_stmt|;
name|first_parm_type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|function_or_method_type
argument_list|)
expr_stmt|;
comment|/* Make our first pass over the list of formal parameter types and output a      DW_TAG_formal_parameter DIE for each one.  */
for|for
control|(
name|link
operator|=
name|first_parm_type
init|;
name|link
condition|;
control|)
block|{
name|dw_die_ref
name|parm_die
decl_stmt|;
name|formal_type
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|formal_type
operator|==
name|void_type_node
condition|)
break|break;
comment|/* Output a (nameless) DIE to represent the formal parameter itself.  */
name|parm_die
operator|=
name|gen_formal_parameter_die
argument_list|(
name|formal_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|function_or_method_type
argument_list|)
operator|==
name|METHOD_TYPE
operator|&&
name|link
operator|==
name|first_parm_type
operator|)
operator|||
operator|(
name|arg
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
name|add_AT_flag
argument_list|(
name|parm_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|arg
operator|=
name|TREE_CHAIN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* If this function type has an ellipsis, add a      DW_TAG_unspecified_parameters DIE to the end of the parameter list.  */
if|if
condition|(
name|formal_type
operator|!=
name|void_type_node
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|function_or_method_type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Make our second (and final) pass over the list of formal parameter types      and output DIEs to represent those types (as necessary).  */
for|for
control|(
name|link
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|function_or_method_type
argument_list|)
init|;
name|link
operator|&&
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|gen_type_die
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We want to generate the DIE for TYPE so that we can generate the    die for MEMBER, which has been defined; we will need to refer back    to the member declaration nested within TYPE.  If we're trying to    generate minimal debug info for TYPE, processing TYPE won't do the    trick; we need to attach the member declaration by hand.  */
end_comment

begin_function
specifier|static
name|void
name|gen_type_die_for_member
parameter_list|(
name|type
parameter_list|,
name|member
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|,
name|member
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|gen_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* If we're trying to avoid duplicate debug info, we may not have      emitted the member decl for this function.  Emit it now.  */
if|if
condition|(
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|lookup_decl_die
argument_list|(
name|member
argument_list|)
condition|)
block|{
if|if
condition|(
name|decl_ultimate_origin
argument_list|(
name|member
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|push_decl_scope
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|member
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|gen_subprogram_die
argument_list|(
name|member
argument_list|,
name|lookup_type_die
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gen_variable_die
argument_list|(
name|member
argument_list|,
name|lookup_type_die
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|pop_decl_scope
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the DWARF2 info for the "abstract" instance of a function which we    may later generate inlined and/or out-of-line instances of.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_abstract_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|dw_die_ref
name|old_die
decl_stmt|;
name|tree
name|save_fn
decl_stmt|;
name|tree
name|context
decl_stmt|;
name|int
name|was_abstract
init|=
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
decl_stmt|;
comment|/* Make sure we have the actual abstract inline, not a clone.  */
name|decl
operator|=
name|DECL_ORIGIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|old_die
operator|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_die
operator|&&
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_inline
argument_list|)
condition|)
comment|/* We've already generated the abstract instance.  */
return|return;
comment|/* Be sure we've emitted the in-class declaration DIE (if any) first, so      we don't get confused by DECL_ABSTRACT.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
block|{
name|context
operator|=
name|decl_class_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
condition|)
name|gen_type_die_for_member
argument_list|(
name|context
argument_list|,
name|decl
argument_list|,
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|?
name|NULL
else|:
name|comp_unit_die
argument_list|)
expr_stmt|;
block|}
comment|/* Pretend we've just finished compiling this function.  */
name|save_fn
operator|=
name|current_function_decl
expr_stmt|;
name|current_function_decl
operator|=
name|decl
expr_stmt|;
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dwarf2out_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|was_abstract
condition|)
name|set_decl_abstract_flags
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_function_decl
operator|=
name|save_fn
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent a declared function (either file-scope or    block-local).  */
end_comment

begin_function
specifier|static
name|void
name|gen_subprogram_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|char
name|label_id
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|dw_die_ref
name|subr_die
decl_stmt|;
name|rtx
name|fp_reg
decl_stmt|;
name|tree
name|fn_arg_types
decl_stmt|;
name|tree
name|outer_scope
decl_stmt|;
name|dw_die_ref
name|old_die
init|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|declaration
init|=
operator|(
name|current_function_decl
operator|!=
name|decl
operator|||
name|class_scope_p
argument_list|(
name|context_die
argument_list|)
operator|)
decl_stmt|;
comment|/* It is possible to have both DECL_ABSTRACT and DECLARATION be true if we      started to generate the abstract instance of an inline, decided to output      its containing class, and proceeded to emit the declaration of the inline      from the member list for the class.  If so, DECLARATION takes priority;      we'll get back to the abstract instance when done with the class.  */
comment|/* The class-scope declaration DIE must be the primary DIE.  */
if|if
condition|(
name|origin
operator|&&
name|declaration
operator|&&
name|class_scope_p
argument_list|(
name|context_die
argument_list|)
condition|)
block|{
name|origin
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|old_die
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|declaration
operator|&&
operator|!
name|local_scope_p
argument_list|(
name|context_die
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Fixup die_parent for the abstract instance of a nested 	 inline function.  */
if|if
condition|(
name|old_die
operator|&&
name|old_die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
name|add_child_die
argument_list|(
name|context_die
argument_list|,
name|old_die
argument_list|)
expr_stmt|;
name|subr_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subprogram
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_abstract_origin_attribute
argument_list|(
name|subr_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_die
condition|)
block|{
name|unsigned
name|file_index
init|=
name|lookup_filename
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|get_AT_flag
argument_list|(
name|old_die
argument_list|,
name|DW_AT_declaration
argument_list|)
comment|/* We can have a normal definition following an inline one in the 	     case of redefinition of GNU C extern inlines. 	     It seems reasonable to use AT_specification in this case.  */
operator|&&
operator|!
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_inline
argument_list|)
condition|)
block|{
comment|/* ??? This can happen if there is a bug in the program, for 	     instance, if it has duplicate function definitions.  Ideally, 	     we should detect this case and ignore it.  For now, if we have 	     already reported an error, any error at all, then assume that 	     we got here because of an input error, not a dwarf2 bug.  */
if|if
condition|(
name|errorcount
condition|)
return|return;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If the definition comes from the same place as the declaration, 	 maybe use the old DIE.  We always want the DIE for this function 	 that has the *_pc attributes to be under comp_unit_die so the 	 debugger can find it.  We also need to do this for abstract 	 instances of inlines, since the spec requires the out-of-line copy 	 to have the same parent.  For local class methods, this doesn't 	 apply; we just use the old DIE.  */
if|if
condition|(
operator|(
name|old_die
operator|->
name|die_parent
operator|==
name|comp_unit_die
operator|||
name|context_die
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|||
operator|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_file
argument_list|)
operator|==
name|file_index
operator|&&
operator|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_line
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|subr_die
operator|=
name|old_die
expr_stmt|;
comment|/* Clear out the declaration attribute and the parm types.  */
name|remove_AT
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_declaration
argument_list|)
expr_stmt|;
name|remove_children
argument_list|(
name|subr_die
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subr_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subprogram
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_specification
argument_list|,
name|old_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_file
argument_list|)
operator|!=
name|file_index
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_decl_file
argument_list|,
name|file_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_line
argument_list|)
operator|!=
operator|(
name|unsigned
operator|)
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_decl_line
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|subr_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_subprogram
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_external
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_name_and_src_coords_attributes
argument_list|(
name|subr_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
block|{
name|add_prototyped_attribute
argument_list|(
name|subr_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|subr_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
name|add_pure_or_virtual_attribute
argument_list|(
name|subr_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_private
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declaration
condition|)
block|{
if|if
condition|(
operator|!
name|old_die
operator|||
operator|!
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_inline
argument_list|)
condition|)
block|{
name|add_AT_flag
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The first time we see a member function, it is in the context of 	     the class to which it belongs.  We make sure of this by emitting 	     the class first.  The next time is the definition, which is 	     handled above.  The two may come from the same source text.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|||
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|flag_no_inline
condition|)
block|{
comment|/* ??? Checking DECL_DEFER_OUTPUT is correct for static 	     inline functions, but not for extern inline functions. 	     We can't get this completely correct because information 	     about whether the function was declared inline is not 	     saved anywhere.  */
if|if
condition|(
name|DECL_DEFER_OUTPUT
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_inline
argument_list|,
name|DW_INL_declared_inlined
argument_list|)
expr_stmt|;
else|else
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_inline
argument_list|,
name|DW_INL_inlined
argument_list|)
expr_stmt|;
block|}
else|else
name|add_AT_unsigned
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_inline
argument_list|,
name|DW_INL_declared_not_inlined
argument_list|)
expr_stmt|;
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|old_die
operator|||
operator|!
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_inline
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label_id
argument_list|,
name|FUNC_BEGIN_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|label_id
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label_id
argument_list|,
name|FUNC_END_LABEL
argument_list|,
name|current_funcdef_number
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|label_id
argument_list|)
expr_stmt|;
name|add_pubname
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
name|add_arange
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* Add a reference to the FDE for this routine.  */
name|add_AT_fde_ref
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_MIPS_fde
argument_list|,
name|current_funcdef_fde
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Define the "frame base" location for this routine.  We use the          frame pointer or stack pointer registers, since the RTL for local          variables is relative to one of them.  */
name|fp_reg
operator|=
name|frame_pointer_needed
condition|?
name|hard_frame_pointer_rtx
else|:
name|stack_pointer_rtx
expr_stmt|;
name|add_AT_loc
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_frame_base
argument_list|,
name|reg_loc_descriptor
argument_list|(
name|fp_reg
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ??? This fails for nested inline functions, because context_display 	 is not part of the state saved/restored for inline functions.  */
block|if (current_function_needs_context) 	add_AT_location_description (subr_die, DW_AT_static_link, 				     lookup_static_chain (decl));
endif|#
directive|endif
block|}
comment|/* Now output descriptions of the arguments for this function. This gets      (unnecessarily?) complex because of the fact that the DECL_ARGUMENT list      for a FUNCTION_DECL doesn't indicate cases where there was a trailing      `...' at the end of the formal parameter list.  In order to find out if      there was a trailing ellipsis or not, we must instead look at the type      associated with the FUNCTION_DECL.  This will be a node of type      FUNCTION_TYPE. If the chain of type nodes hanging off of this      FUNCTION_TYPE node ends with a void_type_node then there should *not* be      an ellipsis at the end.  */
comment|/* In the case where we are describing a mere function declaration, all we      need to do here (and all we *can* do here) is to describe the *types* of      its formal parameters.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|declaration
condition|)
name|gen_formal_types_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Generate DIEs to represent all known formal parameters */
name|tree
name|arg_decls
init|=
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|parm
decl_stmt|;
comment|/* When generating DIEs, generate the unspecified_parameters DIE          instead if we come across the arg "__builtin_va_alist" */
for|for
control|(
name|parm
operator|=
name|arg_decls
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|,
literal|"__builtin_va_alist"
argument_list|)
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|parm
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
else|else
name|gen_decl_die
argument_list|(
name|parm
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
comment|/* Decide whether we need an unspecified_parameters DIE at the end.          There are 2 more cases to do this for: 1) the ansi ... declaration -          this is detectable when the end of the arg list is not a          void_type_node 2) an unprototyped function declaration (not a          definition).  This just means that we have no info about the          parameters at all.  */
name|fn_arg_types
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn_arg_types
operator|!=
name|NULL
condition|)
block|{
comment|/* this is the prototyped case, check for ...  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tree_last
argument_list|(
name|fn_arg_types
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|gen_unspecified_parameters_die
argument_list|(
name|decl
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
comment|/* Output Dwarf info for all of the stuff within the body of the function      (if it has one - it may be just a declaration).  */
name|outer_scope
operator|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* OUTER_SCOPE is a pointer to the outermost BLOCK node created to represent      a function.  This BLOCK actually represents the outermost binding contour      for the function, i.e. the contour in which the function's formal      parameters and labels get declared. Curiously, it appears that the front      end doesn't actually put the PARM_DECL nodes for the current function onto      the BLOCK_VARS list for this outer scope, but are strung off of the      DECL_ARGUMENTS list for the function instead.       The BLOCK_VARS list for the `outer_scope' does provide us with a list of      the LABEL_DECL nodes for the function however, and we output DWARF info      for those in decls_for_scope.  Just within the `outer_scope' there will be      a BLOCK node representing the function's outermost pair of curly braces,      and any blocks used for the base and member initializers of a C++      constructor function.  */
if|if
condition|(
operator|!
name|declaration
operator|&&
name|TREE_CODE
argument_list|(
name|outer_scope
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
block|{
name|current_function_has_inlines
operator|=
literal|0
expr_stmt|;
name|decls_for_scope
argument_list|(
name|outer_scope
argument_list|,
name|subr_die
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|MIPS_DEBUGGING_INFO
argument_list|)
block|if (current_function_has_inlines) 	{ 	  add_AT_flag (subr_die, DW_AT_MIPS_has_inlines, 1); 	  if (! comp_unit_has_inlines) 	    { 	      add_AT_flag (comp_unit_die, DW_AT_MIPS_has_inlines, 1); 	      comp_unit_has_inlines = 1; 	    } 	}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent a declared data object.  */
end_comment

begin_function
specifier|static
name|void
name|gen_variable_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|dw_die_ref
name|var_die
init|=
name|new_die
argument_list|(
name|DW_TAG_variable
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
decl_stmt|;
name|dw_die_ref
name|old_die
init|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|declaration
init|=
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|class_scope_p
argument_list|(
name|context_die
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|var_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
comment|/* Loop unrolling can create multiple blocks that refer to the same      static variable, so we must test for the DW_AT_declaration flag.       ??? Loop unrolling/reorder_blocks should perhaps be rewritten to      copy decls and set the DECL_ABSTRACT flag on them instead of      sharing them.       ??? Duplicated blocks have been rewritten to use .debug_ranges.  */
elseif|else
if|if
condition|(
name|old_die
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|get_AT_flag
argument_list|(
name|old_die
argument_list|,
name|DW_AT_declaration
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* This is a definition of a C++ class level static.  */
name|add_AT_die_ref
argument_list|(
name|var_die
argument_list|,
name|DW_AT_specification
argument_list|,
name|old_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|unsigned
name|file_index
init|=
name|lookup_filename
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_file
argument_list|)
operator|!=
name|file_index
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_decl_file
argument_list|,
name|file_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_AT_unsigned
argument_list|(
name|old_die
argument_list|,
name|DW_AT_decl_line
argument_list|)
operator|!=
operator|(
name|unsigned
operator|)
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_decl_line
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|add_name_and_src_coords_attributes
argument_list|(
name|var_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|var_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|var_die
argument_list|,
name|DW_AT_external
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|var_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|var_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_private
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|declaration
condition|)
name|add_AT_flag
argument_list|(
name|var_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|class_scope_p
argument_list|(
name|context_die
argument_list|)
operator|||
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|var_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|declaration
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|add_location_or_const_value_attribute
argument_list|(
name|var_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_pubname
argument_list|(
name|decl
argument_list|,
name|var_die
argument_list|)
expr_stmt|;
block|}
else|else
name|tree_add_const_value_attribute
argument_list|(
name|var_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE to represent a label identifier.  */
end_comment

begin_function
specifier|static
name|void
name|gen_label_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|tree
name|origin
init|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|dw_die_ref
name|lbl_die
init|=
name|new_die
argument_list|(
name|DW_TAG_label
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|lbl_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
name|add_name_and_src_coords_attributes
argument_list|(
name|lbl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|lbl_die
argument_list|)
expr_stmt|;
else|else
block|{
name|insn
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Deleted labels are programmer specified labels which have been 	 eliminated because of various optimisations.  We still emit them 	 here so that it is possible to put breakpoints on them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|||
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_DELETED_LABEL
operator|)
operator|)
condition|)
block|{
comment|/* When optimization is enabled (via -O) some parts of the compiler 	     (e.g. jump.c and cse.c) may try to delete CODE_LABEL insns which 	     represent source-level labels which were explicitly declared by 	     the user.  This really shouldn't be happening though, so catch 	     it if it ever does happen.  */
if|if
condition|(
name|INSN_DELETED_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"L"
argument_list|,
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|lbl_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE for a lexical block.  */
end_comment

begin_function
specifier|static
name|void
name|gen_lexical_block_die
parameter_list|(
name|stmt
parameter_list|,
name|context_die
parameter_list|,
name|depth
parameter_list|)
name|tree
name|stmt
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|dw_die_ref
name|stmt_die
init|=
name|new_die
argument_list|(
name|DW_TAG_lexical_block
argument_list|,
name|context_die
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
if|if
condition|(
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|tree
name|chain
decl_stmt|;
name|add_AT_range_list
argument_list|(
name|stmt_die
argument_list|,
name|DW_AT_ranges
argument_list|,
name|add_ranges
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|chain
operator|=
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
do|do
block|{
name|add_ranges
argument_list|(
name|chain
argument_list|)
expr_stmt|;
name|chain
operator|=
name|BLOCK_FRAGMENT_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chain
condition|)
do|;
name|add_ranges
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|BLOCK_BEGIN_LABEL
argument_list|,
name|BLOCK_NUMBER
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|stmt_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|BLOCK_END_LABEL
argument_list|,
name|BLOCK_NUMBER
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|stmt_die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
block|}
block|}
name|decls_for_scope
argument_list|(
name|stmt
argument_list|,
name|stmt_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for an inlined subprogram.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inlined_subroutine_die
parameter_list|(
name|stmt
parameter_list|,
name|context_die
parameter_list|,
name|depth
parameter_list|)
name|tree
name|stmt
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|dw_die_ref
name|subr_die
init|=
name|new_die
argument_list|(
name|DW_TAG_inlined_subroutine
argument_list|,
name|context_die
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|decl
init|=
name|block_ultimate_origin
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|char
name|label
index|[
name|MAX_ARTIFICIAL_LABEL_BYTES
index|]
decl_stmt|;
comment|/* Emit info for the abstract instance first, if we haven't yet.  */
name|dwarf2out_abstract_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|add_abstract_origin_attribute
argument_list|(
name|subr_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|BLOCK_BEGIN_LABEL
argument_list|,
name|BLOCK_NUMBER
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|BLOCK_END_LABEL
argument_list|,
name|BLOCK_NUMBER
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|subr_die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|decls_for_scope
argument_list|(
name|stmt
argument_list|,
name|subr_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|current_function_has_inlines
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE for a field in a record, or structure.  */
end_comment

begin_function
specifier|static
name|void
name|gen_field_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|decl_die
init|=
name|new_die
argument_list|(
name|DW_TAG_member
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
decl_stmt|;
name|add_name_and_src_coords_attributes
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|decl_die
argument_list|,
name|member_declared_type
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|add_byte_size_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_bit_size_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|add_bit_offset_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
name|add_data_member_location_attribute
argument_list|(
name|decl_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_flag
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_artificial
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|decl_die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_private
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Don't generate either pointer_type DIEs or reference_type DIEs here.    Use modified_type_die instead.    We keep this code here just in case these types of DIEs may be needed to    represent certain things in other languages (e.g. Pascal) someday.  */
end_comment

begin_comment
unit|static void gen_pointer_type_die (type, context_die)      tree type;      dw_die_ref context_die; {   dw_die_ref ptr_die     = new_die (DW_TAG_pointer_type, scope_die_for (type, context_die), type);    equate_type_number_to_die (type, ptr_die);   add_type_attribute (ptr_die, TREE_TYPE (type), 0, 0, context_die);   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE); }
comment|/* Don't generate either pointer_type DIEs or reference_type DIEs here.    Use modified_type_die instead.    We keep this code here just in case these types of DIEs may be needed to    represent certain things in other languages (e.g. Pascal) someday.  */
end_comment

begin_endif
unit|static void gen_reference_type_die (type, context_die)      tree type;      dw_die_ref context_die; {   dw_die_ref ref_die     = new_die (DW_TAG_reference_type, scope_die_for (type, context_die), type);    equate_type_number_to_die (type, ref_die);   add_type_attribute (ref_die, TREE_TYPE (type), 0, 0, context_die);   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generate a DIE for a pointer to a member type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_ptr_to_mbr_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|ptr_die
init|=
name|new_die
argument_list|(
name|DW_TAG_ptr_to_member_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|ptr_die
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|ptr_die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|lookup_type_die
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|ptr_die
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the DIE for the compilation unit.  */
end_comment

begin_function
specifier|static
name|dw_die_ref
name|gen_compile_unit_die
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|dw_die_ref
name|die
decl_stmt|;
name|char
name|producer
index|[
literal|250
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|wd
init|=
name|getpwd
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|language_string
init|=
name|lang_hooks
operator|.
name|name
decl_stmt|;
name|int
name|language
decl_stmt|;
name|die
operator|=
name|new_die
argument_list|(
name|DW_TAG_compile_unit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_name_attribute
argument_list|(
name|die
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|wd
operator|!=
name|NULL
operator|&&
name|filename
index|[
literal|0
index|]
operator|!=
name|DIR_SEPARATOR
condition|)
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_comp_dir
argument_list|,
name|wd
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|producer
argument_list|,
literal|"%s %s"
argument_list|,
name|language_string
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MIPS_DEBUGGING_INFO
comment|/* The MIPS/SGI compilers place the 'cc' command line options in the producer      string.  The SGI debugger looks for -g, -g1, -g2, or -g3; if they do      not appear in the producer string, the debugger reaches the conclusion      that the object file is stripped and has no debugging information.      To get the MIPS/SGI debugger to believe that there is debugging      information in the object file, we add a -g to the producer string.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
name|strcat
argument_list|(
name|producer
argument_list|,
literal|" -g"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_AT_string
argument_list|(
name|die
argument_list|,
name|DW_AT_producer
argument_list|,
name|producer
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_C_plus_plus
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Ada"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_Ada83
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F77"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_Fortran77
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Pascal"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_Pascal83
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Java"
argument_list|)
operator|==
literal|0
condition|)
name|language
operator|=
name|DW_LANG_Java
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_traditional
condition|)
name|language
operator|=
name|DW_LANG_C
expr_stmt|;
else|else
name|language
operator|=
name|DW_LANG_C89
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_language
argument_list|,
name|language
argument_list|)
expr_stmt|;
return|return
name|die
return|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a string type.  */
end_comment

begin_function
specifier|static
name|void
name|gen_string_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|type_die
init|=
name|new_die
argument_list|(
name|DW_TAG_string_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
comment|/* ??? Fudge the string length attribute for now.      TODO: add string length info.  */
if|#
directive|if
literal|0
block|string_length_attribute (TYPE_MAX_VALUE (TYPE_DOMAIN (type)));   bound_representation (upper_bound, 0, 'u');
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Generate the DIE for a base class.  */
end_comment

begin_function
specifier|static
name|void
name|gen_inheritance_die
parameter_list|(
name|binfo
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|binfo
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|die
init|=
name|new_die
argument_list|(
name|DW_TAG_inheritance
argument_list|,
name|context_die
argument_list|,
name|binfo
argument_list|)
decl_stmt|;
name|add_type_attribute
argument_list|(
name|die
argument_list|,
name|BINFO_TYPE
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|add_data_member_location_attribute
argument_list|(
name|die
argument_list|,
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|binfo
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_virtuality
argument_list|,
name|DW_VIRTUALITY_virtual
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_PUBLIC
argument_list|(
name|binfo
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_public
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VIA_PROTECTED
argument_list|(
name|binfo
argument_list|)
condition|)
name|add_AT_unsigned
argument_list|(
name|die
argument_list|,
name|DW_AT_accessibility
argument_list|,
name|DW_ACCESS_protected
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a class member.  */
end_comment

begin_function
specifier|static
name|void
name|gen_member_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|tree
name|member
decl_stmt|;
name|dw_die_ref
name|child
decl_stmt|;
comment|/* If this is not an incomplete type, output descriptions of each of its      members. Note that as we output the DIEs necessary to represent the      members of this record or union type, we will also be trying to output      DIEs to represent the *types* of those members. However the `type'      function (above) will specifically avoid generating type DIEs for member      types *within* the list of member DIEs for this (containing) type except      for those types (of members) which are explicitly marked as also being      members of this (containing) type themselves.  The g++ front- end can      force any given type to be treated as a member of some other (containing)      type by setting the TYPE_CONTEXT of the given (member) type to point to      the TREE node representing the appropriate (containing) type.  */
comment|/* First output info about the base classes.  */
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|bases
init|=
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|n_bases
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|bases
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_bases
condition|;
name|i
operator|++
control|)
name|gen_inheritance_die
argument_list|(
name|TREE_VEC_ELT
argument_list|(
name|bases
argument_list|,
name|i
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
comment|/* Now output info about the data members and type members.  */
for|for
control|(
name|member
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
comment|/* If we thought we were generating minimal debug info for TYPE 	 and then changed our minds, some of the member declarations 	 may have already been defined.  Don't define them again, but 	 do put them in the right order.  */
name|child
operator|=
name|lookup_decl_die
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
condition|)
name|splice_child_die
argument_list|(
name|context_die
argument_list|,
name|child
argument_list|)
expr_stmt|;
else|else
name|gen_decl_die
argument_list|(
name|member
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
comment|/* Now output info about the function members (if any).  */
for|for
control|(
name|member
operator|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
init|;
name|member
condition|;
name|member
operator|=
name|TREE_CHAIN
argument_list|(
name|member
argument_list|)
control|)
block|{
comment|/* Don't include clones in the member list.  */
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|member
argument_list|)
condition|)
continue|continue;
name|child
operator|=
name|lookup_decl_die
argument_list|(
name|member
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
condition|)
name|splice_child_die
argument_list|(
name|context_die
argument_list|,
name|child
argument_list|)
expr_stmt|;
else|else
name|gen_decl_die
argument_list|(
name|member
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE for a structure or union type.  If TYPE_DECL_SUPPRESS_DEBUG    is set, we pretend that the type was never defined, so we only get the    member DIEs needed by later specification DIEs.  */
end_comment

begin_function
specifier|static
name|void
name|gen_struct_or_union_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|type_die
init|=
name|lookup_type_die
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|dw_die_ref
name|scope_die
init|=
literal|0
decl_stmt|;
name|int
name|nested
init|=
literal|0
decl_stmt|;
name|int
name|complete
init|=
operator|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
operator|!
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|type_die
operator|&&
operator|!
name|complete
condition|)
return|return;
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|nested
operator|=
literal|1
expr_stmt|;
name|scope_die
operator|=
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_die
operator|||
operator|(
name|nested
operator|&&
name|scope_die
operator|==
name|comp_unit_die
operator|)
condition|)
comment|/* First occurrence of type or toplevel definition of nested class.  */
block|{
name|dw_die_ref
name|old_die
init|=
name|type_die
decl_stmt|;
name|type_die
operator|=
name|new_die
argument_list|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
condition|?
name|DW_TAG_structure_type
else|:
name|DW_TAG_union_type
argument_list|,
name|scope_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_die
condition|)
name|add_AT_die_ref
argument_list|(
name|type_die
argument_list|,
name|DW_AT_specification
argument_list|,
name|old_die
argument_list|)
expr_stmt|;
else|else
name|add_name_attribute
argument_list|(
name|type_die
argument_list|,
name|type_tag
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|remove_AT
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|)
expr_stmt|;
comment|/* If this type has been completed, then give it a byte_size attribute and      then give a list of members.  */
if|if
condition|(
name|complete
condition|)
block|{
comment|/* Prevent infinite recursion in cases where the type of some member of          this type is expressed in terms of this type itself.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|add_byte_size_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|add_src_coords_attributes
argument_list|(
name|type_die
argument_list|,
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the first reference to this type was as the return type of an 	 inline function, then it may not have a parent.  Fix this now.  */
if|if
condition|(
name|type_die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
name|add_child_die
argument_list|(
name|scope_die
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|push_decl_scope
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|gen_member_die
argument_list|(
name|type
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
name|pop_decl_scope
argument_list|()
expr_stmt|;
comment|/* GNU extension: Record what type our vtable lives in.  */
if|if
condition|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|vtype
init|=
name|DECL_FCONTEXT
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|gen_type_die
argument_list|(
name|vtype
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|add_AT_die_ref
argument_list|(
name|type_die
argument_list|,
name|DW_AT_containing_type
argument_list|,
name|lookup_type_die
argument_list|(
name|vtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|add_AT_flag
argument_list|(
name|type_die
argument_list|,
name|DW_AT_declaration
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We don't need to do this for function-local types.  */
if|if
condition|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|decl_function_context
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|VARRAY_PUSH_TREE
argument_list|(
name|incomplete_types
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DIE for a subroutine _type_.  */
end_comment

begin_function
specifier|static
name|void
name|gen_subroutine_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|dw_die_ref
name|subr_die
init|=
name|new_die
argument_list|(
name|DW_TAG_subroutine_type
argument_list|,
name|scope_die_for
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|equate_type_number_to_die
argument_list|(
name|type
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
name|add_prototyped_attribute
argument_list|(
name|subr_die
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|subr_die
argument_list|,
name|return_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_formal_types_die
argument_list|(
name|type
argument_list|,
name|subr_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a type definition */
end_comment

begin_function
specifier|static
name|void
name|gen_typedef_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|dw_die_ref
name|type_die
decl_stmt|;
name|tree
name|origin
decl_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type_die
operator|=
name|new_die
argument_list|(
name|DW_TAG_typedef
argument_list|,
name|context_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|origin
operator|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
name|add_abstract_origin_attribute
argument_list|(
name|type_die
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|type
decl_stmt|;
name|add_name_and_src_coords_attributes
argument_list|(
name|type_die
argument_list|,
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|type
operator|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
else|else
name|equate_type_number_to_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|add_type_attribute
argument_list|(
name|type_die
argument_list|,
name|type
argument_list|,
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
condition|)
name|equate_decl_number_to_die
argument_list|(
name|decl
argument_list|,
name|type_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a type description DIE.  */
end_comment

begin_function
specifier|static
name|void
name|gen_type_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|int
name|need_pop
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* We are going to output a DIE to represent the unqualified version of      this type (i.e. without any const or volatile qualifiers) so get the      main variant (i.e. the unqualified version) of this type now.  */
name|type
operator|=
name|type_main_variant
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gen_decl_die
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* We must set TREE_ASM_WRITTEN in case this is a recursive type.  This 	 ensures that the gen_type_die recursion will terminate even if the 	 type is recursive.  Recursive types are possible in Ada.  */
comment|/* ??? We could perhaps do this for all types before the switch 	 statement.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* For these types, all that is required is that we output a DIE (or a          set of DIEs) to represent the "basis" type.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
comment|/* This code is used for C++ pointer-to-data-member types. 	 Output a description of the relevant class type.  */
name|gen_type_die
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Output a description of the type of the object pointed to.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Now output a DIE to represent this pointer-to-data-member type          itself.  */
name|gen_ptr_to_mbr_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|SET_TYPE
case|:
name|gen_type_die
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_set_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_TYPE
case|:
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* No way to represent these in Dwarf yet!  */
break|break;
case|case
name|FUNCTION_TYPE
case|:
comment|/* Force out return type (in case it wasn't forced out already).  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_subroutine_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
comment|/* Force out return type (in case it wasn't forced out already).  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_subroutine_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|CHAR_TYPE
condition|)
block|{
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_string_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
else|else
name|gen_array_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_TYPE
case|:
name|gen_type_die
argument_list|(
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
comment|/* If this is a nested type whose containing class hasn't been written          out yet, writing it out will cover this one, too.  This does not apply          to instantiations of member class templates; they need to be added to          the containing class as they are generated.  FIXME: This hurts the          idea of combining type decls from multiple TUs, since we can't predict          what set of template instantiations we'll get.  */
if|if
condition|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|&&
name|AGGREGATE_TYPE_P
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|gen_type_die
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
condition|)
return|return;
comment|/* If that failed, attach ourselves to the stub.  */
name|push_decl_scope
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|context_die
operator|=
name|lookup_type_die
argument_list|(
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|need_pop
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|need_pop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|gen_enumeration_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
else|else
name|gen_struct_or_union_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_pop
condition|)
name|pop_decl_scope
argument_list|()
expr_stmt|;
comment|/* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix 	 it up if it is ever completed.  gen_*_type_die will set it for us 	 when appropriate.  */
return|return;
case|case
name|VOID_TYPE
case|:
case|case
name|INTEGER_TYPE
case|:
case|case
name|REAL_TYPE
case|:
case|case
name|COMPLEX_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|CHAR_TYPE
case|:
comment|/* No DIEs needed for fundamental types.  */
break|break;
case|case
name|LANG_TYPE
case|:
comment|/* No Dwarf representation currently defined.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_ASM_WRITTEN
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate a DIE for a tagged type instantiation.  */
end_comment

begin_function
specifier|static
name|void
name|gen_tagged_type_instantiation_die
parameter_list|(
name|type
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|type
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
name|NULL_TREE
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* We are going to output a DIE to represent the unqualified version of      this type (i.e. without any const or volatile qualifiers) so make sure      that we have the main variant (i.e. the unqualified version) of this      type now.  */
if|if
condition|(
name|type
operator|!=
name|type_main_variant
argument_list|(
name|type
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Do not check TREE_ASM_WRITTEN (type) as it may not be set if this is      an instance of an unresolved type.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|ENUMERAL_TYPE
case|:
name|gen_inlined_enumeration_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
name|gen_inlined_structure_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
name|gen_inlined_union_type_die
argument_list|(
name|type
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate a DW_TAG_lexical_block DIE followed by DIEs to represent all of the    things which are local to the given block.  */
end_comment

begin_function
specifier|static
name|void
name|gen_block_die
parameter_list|(
name|stmt
parameter_list|,
name|context_die
parameter_list|,
name|depth
parameter_list|)
name|tree
name|stmt
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|int
name|must_output_die
init|=
literal|0
decl_stmt|;
name|tree
name|origin
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|enum
name|tree_code
name|origin_code
decl_stmt|;
comment|/* Ignore blocks never really used to make RTL.  */
if|if
condition|(
name|stmt
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
operator|||
operator|(
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|stmt
argument_list|)
operator|&&
operator|!
name|BLOCK_ABSTRACT
argument_list|(
name|stmt
argument_list|)
operator|)
condition|)
return|return;
comment|/* If the block is one fragment of a non-contiguous block, do not      process the variables, since they will have been done by the      origin block.  Do process subblocks.  */
if|if
condition|(
name|BLOCK_FRAGMENT_ORIGIN
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
name|tree
name|sub
decl_stmt|;
for|for
control|(
name|sub
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|sub
condition|;
name|sub
operator|=
name|BLOCK_CHAIN
argument_list|(
name|sub
argument_list|)
control|)
name|gen_block_die
argument_list|(
name|sub
argument_list|,
name|context_die
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Determine the "ultimate origin" of this block.  This block may be an      inlined instance of an inlined instance of inline function, so we have      to trace all of the way back through the origin chain to find out what      sort of node actually served as the original seed for the creation of      the current block.  */
name|origin
operator|=
name|block_ultimate_origin
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|origin_code
operator|=
operator|(
name|origin
operator|!=
name|NULL
operator|)
condition|?
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
else|:
name|ERROR_MARK
expr_stmt|;
comment|/* Determine if we need to output any Dwarf DIEs at all to represent this      block.  */
if|if
condition|(
name|origin_code
operator|==
name|FUNCTION_DECL
condition|)
comment|/* The outer scopes for inlinings *must* always be represented.  We        generate DW_TAG_inlined_subroutine DIEs for them.  (See below.) */
name|must_output_die
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* In the case where the current block represents an inlining of the          "body block" of an inline function, we must *NOT* output any DIE for          this block because we have already output a DIE to represent the whole          inlined function scope and the "body block" of any function doesn't          really represent a different scope according to ANSI C rules.  So we          check here to make sure that this block does not represent a "body          block inlining" before trying to set the MUST_OUTPUT_DIE flag.  */
if|if
condition|(
operator|!
name|is_body_block
argument_list|(
name|origin
condition|?
name|origin
else|:
name|stmt
argument_list|)
condition|)
block|{
comment|/* Determine if this block directly contains any "significant" 	     local declarations which we will need to output DIEs for.  */
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
comment|/* We are not in terse mode so *any* local declaration counts 	       as being a "significant" one.  */
name|must_output_die
operator|=
operator|(
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
else|else
comment|/* We are in terse mode, so only local (nested) function 	       definitions count as "significant" local declarations.  */
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|decl
operator|!=
name|NULL
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|must_output_die
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* It would be a waste of space to generate a Dwarf DW_TAG_lexical_block      DIE for any block which contains no significant local declarations at      all.  Rather, in such cases we just call `decls_for_scope' so that any      needed Dwarf info for any sub-blocks will get properly generated. Note      that in terse mode, our definition of what constitutes a "significant"      local declaration gets restricted to include only inlined function      instances and local (nested) function definitions.  */
if|if
condition|(
name|must_output_die
condition|)
block|{
if|if
condition|(
name|origin_code
operator|==
name|FUNCTION_DECL
condition|)
name|gen_inlined_subroutine_die
argument_list|(
name|stmt
argument_list|,
name|context_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
else|else
name|gen_lexical_block_die
argument_list|(
name|stmt
argument_list|,
name|context_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
else|else
name|decls_for_scope
argument_list|(
name|stmt
argument_list|,
name|context_die
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate all of the decls declared within a given scope and (recursively)    all of its sub-blocks.  */
end_comment

begin_function
specifier|static
name|void
name|decls_for_scope
parameter_list|(
name|stmt
parameter_list|,
name|context_die
parameter_list|,
name|depth
parameter_list|)
name|tree
name|stmt
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|subblocks
decl_stmt|;
comment|/* Ignore blocks never really used to make RTL.  */
if|if
condition|(
name|stmt
operator|==
name|NULL_TREE
operator|||
operator|!
name|TREE_USED
argument_list|(
name|stmt
argument_list|)
condition|)
return|return;
comment|/* Output the DIEs to represent all of the data objects and typedefs      declared directly within this block but not within any nested      sub-blocks.  Also, nested function and tag DIEs have been      generated with a parent of NULL; fix that up now.  */
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|stmt
argument_list|)
init|;
name|decl
operator|!=
name|NULL
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
name|dw_die_ref
name|die
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|die
operator|=
name|lookup_decl_die
argument_list|(
name|decl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
condition|)
name|die
operator|=
name|lookup_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|die
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|die
operator|!=
name|NULL
operator|&&
name|die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
name|add_child_die
argument_list|(
name|context_die
argument_list|,
name|die
argument_list|)
expr_stmt|;
else|else
name|gen_decl_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
comment|/* Output the DIEs to represent all sub-blocks (and the items declared      therein) of this block.  */
for|for
control|(
name|subblocks
operator|=
name|BLOCK_SUBBLOCKS
argument_list|(
name|stmt
argument_list|)
init|;
name|subblocks
operator|!=
name|NULL
condition|;
name|subblocks
operator|=
name|BLOCK_CHAIN
argument_list|(
name|subblocks
argument_list|)
control|)
name|gen_block_die
argument_list|(
name|subblocks
argument_list|,
name|context_die
argument_list|,
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Is this a typedef we can avoid emitting?  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|is_redundant_typedef
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|is_tagged_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* Also ignore the artificial member typedef for the class name.  */
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generate Dwarf debug information for a decl described by DECL.  */
end_comment

begin_function
specifier|static
name|void
name|gen_decl_die
parameter_list|(
name|decl
parameter_list|,
name|context_die
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|dw_die_ref
name|context_die
decl_stmt|;
block|{
name|tree
name|origin
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
break|break;
case|case
name|CONST_DECL
case|:
comment|/* The individual enumerators of an enum type get output when we output          the Dwarf representation of the relevant enum type itself.  */
break|break;
case|case
name|FUNCTION_DECL
case|:
comment|/* Don't output any DIEs to represent mere function declarations, 	 unless they are class members or explicit block externs.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|&&
operator|(
name|current_function_decl
operator|==
name|NULL_TREE
operator|||
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
break|break;
comment|/* If we're emitting a clone, emit info for the abstract instance.  */
if|if
condition|(
name|DECL_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
name|decl
condition|)
name|dwarf2out_abstract_function
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're emitting an out-of-line copy of an inline function, 	 emit info for the abstract instance and set up to refer to it.  */
elseif|else
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_ABSTRACT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|class_scope_p
argument_list|(
name|context_die
argument_list|)
comment|/* dwarf2out_abstract_function won't emit a die if this is just 		  a declaration.  We must avoid setting DECL_ABSTRACT_ORIGIN in 		  that case, because that works only if we have a die.  */
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|dwarf2out_abstract_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|set_decl_origin_self
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise we're emitting the primary DIE for this decl.  */
elseif|else
if|if
condition|(
name|debug_info_level
operator|>
name|DINFO_LEVEL_TERSE
condition|)
block|{
comment|/* Before we describe the FUNCTION_DECL itself, make sure that we 	     have described its return type.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* And its virtual context.  */
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|gen_type_die
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* And its containing type.  */
name|origin
operator|=
name|decl_class_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL_TREE
condition|)
name|gen_type_die_for_member
argument_list|(
name|origin
argument_list|,
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
comment|/* Now output a DIE to represent the function itself.  */
name|gen_subprogram_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* If we are in terse mode, don't generate any DIEs to represent any          actual typedefs.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
break|break;
comment|/* In the special case of a TYPE_DECL node representing the declaration          of some type tag, if the given TYPE_DECL is marked as having been          instantiated from some other (original) TYPE_DECL node (e.g. one which          was generated within the original definition of an inline function) we          have to generate a special (abbreviated) DW_TAG_structure_type,          DW_TAG_union_type, or DW_TAG_enumeration_type DIE here.  */
if|if
condition|(
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|gen_tagged_type_instantiation_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_redundant_typedef
argument_list|(
name|decl
argument_list|)
condition|)
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
else|else
comment|/* Output a DIE to represent the typedef itself.  */
name|gen_typedef_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_DECL
case|:
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
name|gen_label_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
comment|/* If we are in terse mode, don't generate any DIEs to represent any          variable declarations or definitions.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
break|break;
comment|/* Output any DIEs that are needed to specify the type of this data          object.  */
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* And its containing type.  */
name|origin
operator|=
name|decl_class_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL_TREE
condition|)
name|gen_type_die_for_member
argument_list|(
name|origin
argument_list|,
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
comment|/* Now output the DIE to represent the data object itself.  This gets          complicated because of the possibility that the VAR_DECL really          represents an inlined instance of a formal parameter for an inline          function.  */
name|origin
operator|=
name|decl_ultimate_origin
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|origin
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|gen_formal_parameter_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
else|else
name|gen_variable_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD_DECL
case|:
comment|/* Ignore the nameless fields that are used to skip bits but handle C++ 	 anonymous unions.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
name|gen_type_die
argument_list|(
name|member_declared_type
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_field_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PARM_DECL
case|:
name|gen_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
name|gen_formal_parameter_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
break|break;
case|case
name|NAMESPACE_DECL
case|:
comment|/* Ignore for now.  */
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mark_limbo_die_list
parameter_list|(
name|ptr
parameter_list|)
name|void
modifier|*
name|ptr
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|limbo_die_node
modifier|*
name|node
decl_stmt|;
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|ggc_mark_tree
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add Ada "use" clause information for SGI Workshop debugger.  */
end_comment

begin_function
name|void
name|dwarf2out_add_library_unit_info
parameter_list|(
name|filename
parameter_list|,
name|context_list
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|context_list
decl_stmt|;
block|{
name|unsigned
name|int
name|file_index
decl_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
block|{
name|dw_die_ref
name|unit_die
init|=
name|new_die
argument_list|(
name|DW_TAG_module
argument_list|,
name|comp_unit_die
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|tree
name|context_list_decl
init|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|get_identifier
argument_list|(
name|context_list
argument_list|)
argument_list|,
name|void_type_node
argument_list|)
decl_stmt|;
name|TREE_PUBLIC
argument_list|(
name|context_list_decl
argument_list|)
operator|=
name|TRUE
expr_stmt|;
name|add_name_attribute
argument_list|(
name|unit_die
argument_list|,
name|context_list
argument_list|)
expr_stmt|;
name|file_index
operator|=
name|lookup_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|add_AT_unsigned
argument_list|(
name|unit_die
argument_list|,
name|DW_AT_decl_file
argument_list|,
name|file_index
argument_list|)
expr_stmt|;
name|add_pubname
argument_list|(
name|context_list_decl
argument_list|,
name|unit_die
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output debug information for global decl DECL.  Called from toplev.c after    compilation proper has finished.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_global_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* Output DWARF2 information for file-scope tentative data object      declarations, file-scope (extern) function declarations (which had no      corresponding body) and file-scope tagged type declarations and      definitions which have not yet been forced out.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|dwarf2out_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the debugging output for DECL.  */
end_comment

begin_function
name|void
name|dwarf2out_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|dw_die_ref
name|context_die
init|=
name|comp_unit_die
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return;
case|case
name|FUNCTION_DECL
case|:
comment|/* Ignore this FUNCTION_DECL if it refers to a builtin declaration of a          builtin function.  Explicit programmer-supplied declarations of          these same functions should NOT be ignored however.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* What we would really like to do here is to filter out all mere          file-scope declarations of file-scope functions which are never          referenced later within this translation unit (and keep all of ones          that *are* referenced later on) but we aren't clairvoyant, so we have          no idea which functions will be referenced in the future (i.e. later          on within the current translation unit). So here we just ignore all          file-scope function declarations which are not also definitions.  If          and when the debugger needs to know something about these functions,          it will have to hunt around and find the DWARF information associated          with the definition of the function.  	 We can't just check DECL_EXTERNAL to find out which FUNCTION_DECL          nodes represent definitions and which ones represent mere          declarations.  We have to check DECL_INITIAL instead. That's because          the C front-end supports some weird semantics for "extern inline"          function definitions.  These can get inlined within the current          translation unit (an thus, we need to generate Dwarf info for their          abstract instances so that the Dwarf info for the concrete inlined          instances can have something to refer to) but the compiler never          generates any out-of-lines instances of such things (despite the fact          that they *are* definitions).  	 The important point is that the C front-end marks these "extern 	 inline" functions as DECL_EXTERNAL, but we need to generate DWARF for 	 them anyway. Note that the C++ front-end also plays some similar games 	 for inline function definitions appearing within include files which 	 also contain `#pragma interface' pragmas.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return;
comment|/* If we're a nested function, initially use a parent of NULL; if we're 	 a plain function, this will be fixed up in decls_for_scope.  If 	 we're a method, it will be ignored, since we already have a DIE.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|context_die
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|VAR_DECL
case|:
comment|/* Ignore this VAR_DECL if it refers to a file-scope extern data object          declaration and if the declaration was never even referenced from          within this entire compilation unit.  We suppress these DIEs in          order to save space in the .debug section (by eliminating entries          which are probably useless).  Note that we must not suppress          block-local extern declarations (whether used or not) because that          would screw-up the debugger's name lookup mechanism and cause it to          miss things which really ought to be in scope at a given point.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* If we are in terse mode, don't generate any DIEs to represent any          variable declarations or definitions.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* Don't emit stubs for types unless they are needed by other DIEs.  */
if|if
condition|(
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Don't bother trying to generate any DIEs to represent any of the          normal built-in types for the language we are compiling.  */
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* OK, we need to generate one for `bool' so GDB knows what type              comparisons have.  */
if|if
condition|(
operator|(
name|get_AT_unsigned
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_language
argument_list|)
operator|==
name|DW_LANG_C_plus_plus
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BOOLEAN_TYPE
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
name|modified_type_die
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we are in terse mode, don't generate any DIEs for types.  */
if|if
condition|(
name|debug_info_level
operator|<=
name|DINFO_LEVEL_TERSE
condition|)
return|return;
comment|/* If we're a function-scope tag, initially use a parent of NULL; 	 this will be fixed up in decls_for_scope.  */
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|)
name|context_die
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|gen_decl_die
argument_list|(
name|decl
argument_list|,
name|context_die
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the beginning of the generated code for    a lexical block.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_begin_block
parameter_list|(
name|line
parameter_list|,
name|blocknum
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|blocknum
decl_stmt|;
block|{
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEBUG_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BLOCK_BEGIN_LABEL
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a marker (i.e. a label) for the end of the generated code for a    lexical block.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_end_block
parameter_list|(
name|line
parameter_list|,
name|blocknum
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|blocknum
decl_stmt|;
block|{
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_DEBUG_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|BLOCK_END_LABEL
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if it is appropriate not to emit any debugging    information for BLOCK, because it doesn't contain any instructions.     Don't allow this for blocks with nested functions or local classes    as we would end up with orphans, and in the presence of scheduling    we may end up calling them anyway.  */
end_comment

begin_function
specifier|static
name|bool
name|dwarf2out_ignore_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_DECL_IS_STUB
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Lookup FILE_NAME (in the list of filenames that we know about here in    dwarf2out.c) and return its "index".  The index of each (known) filename is    just a unique number which is associated with only that one filename.  We    need such numbers for the sake of generating labels (in the .debug_sfnames    section) and references to those files numbers (in the .debug_srcinfo    and.debug_macinfo sections).  If the filename given as an argument is not    found in our current list, add it to the list and assign it the next    available unique index number.  In order to speed up searches, we remember    the index of the filename was looked up last.  This handles the majority of    all searches.  */
end_comment

begin_function
specifier|static
name|unsigned
name|lookup_filename
parameter_list|(
name|file_name
parameter_list|)
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* ??? Why isn't DECL_SOURCE_FILE left null instead.  */
if|if
condition|(
name|strcmp
argument_list|(
name|file_name
argument_list|,
literal|"<internal>"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|file_name
argument_list|,
literal|"<built-in>"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Check to see if the file name that was searched on the previous      call matches this file name.  If so, return the index.  */
if|if
condition|(
name|file_table
operator|.
name|last_lookup_index
operator|!=
literal|0
condition|)
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|file_name
argument_list|,
name|file_table
operator|.
name|table
index|[
name|file_table
operator|.
name|last_lookup_index
index|]
argument_list|)
condition|)
return|return
name|file_table
operator|.
name|last_lookup_index
return|;
comment|/* Didn't match the previous lookup, search the table */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|file_table
operator|.
name|in_use
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|file_name
argument_list|,
name|file_table
operator|.
name|table
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|file_table
operator|.
name|last_lookup_index
operator|=
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/* Prepare to add a new table entry by making sure there is enough space in      the table to do so.  If not, expand the current table.  */
if|if
condition|(
name|i
operator|==
name|file_table
operator|.
name|allocated
condition|)
block|{
name|file_table
operator|.
name|allocated
operator|=
name|i
operator|+
name|FILE_TABLE_INCREMENT
expr_stmt|;
name|file_table
operator|.
name|table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|file_table
operator|.
name|table
argument_list|,
name|file_table
operator|.
name|allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry to the end of the filename table.  */
name|file_table
operator|.
name|table
index|[
name|i
index|]
operator|=
name|xstrdup
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
name|file_table
operator|.
name|in_use
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|file_table
operator|.
name|last_lookup_index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|DWARF2_ASM_LINE_DEBUG_INFO
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.file %u \"%s\"\n"
argument_list|,
name|i
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_file_table
parameter_list|()
block|{
comment|/* Allocate the initial hunk of the file_table.  */
name|file_table
operator|.
name|table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xcalloc
argument_list|(
name|FILE_TABLE_INCREMENT
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|file_table
operator|.
name|allocated
operator|=
name|FILE_TABLE_INCREMENT
expr_stmt|;
comment|/* Skip the first entry - file numbers begin at 1.  */
name|file_table
operator|.
name|in_use
operator|=
literal|1
expr_stmt|;
name|file_table
operator|.
name|last_lookup_index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a label to mark the beginning of a source code line entry    and record information relating to this source line, in    'line_info_table' for later output of the .debug_line section.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_source_line
parameter_list|(
name|line
parameter_list|,
name|filename
parameter_list|)
name|unsigned
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
block|{
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
comment|/* If requested, emit something human-readable.  */
if|if
condition|(
name|flag_debug_asm
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s %s:%d\n"
argument_list|,
name|ASM_COMMENT_START
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|DWARF2_ASM_LINE_DEBUG_INFO
condition|)
block|{
name|unsigned
name|file_num
init|=
name|lookup_filename
argument_list|(
name|filename
argument_list|)
decl_stmt|;
comment|/* Emit the .loc directive understood by GNU as.  */
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.loc %d %d 0\n"
argument_list|,
name|file_num
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Indicate that line number info exists.  */
name|line_info_table_in_use
operator|++
expr_stmt|;
comment|/* Indicate that multiple line number tables exist.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|separate_line_info_table_in_use
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
block|{
name|dw_separate_line_info_ref
name|line_info
decl_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|SEPARATE_LINE_CODE_LABEL
argument_list|,
name|separate_line_info_table_in_use
argument_list|)
expr_stmt|;
comment|/* expand the line info table if necessary */
if|if
condition|(
name|separate_line_info_table_in_use
operator|==
name|separate_line_info_table_allocated
condition|)
block|{
name|separate_line_info_table_allocated
operator|+=
name|LINE_INFO_TABLE_INCREMENT
expr_stmt|;
name|separate_line_info_table
operator|=
operator|(
name|dw_separate_line_info_ref
operator|)
name|xrealloc
argument_list|(
name|separate_line_info_table
argument_list|,
name|separate_line_info_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_separate_line_info_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry at the end of the line_info_table.  */
name|line_info
operator|=
operator|&
name|separate_line_info_table
index|[
name|separate_line_info_table_in_use
operator|++
index|]
expr_stmt|;
name|line_info
operator|->
name|dw_file_num
operator|=
name|lookup_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|line_info
operator|->
name|dw_line_num
operator|=
name|line
expr_stmt|;
name|line_info
operator|->
name|function
operator|=
name|current_funcdef_number
expr_stmt|;
block|}
else|else
block|{
name|dw_line_info_ref
name|line_info
decl_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|LINE_CODE_LABEL
argument_list|,
name|line_info_table_in_use
argument_list|)
expr_stmt|;
comment|/* Expand the line info table if necessary.  */
if|if
condition|(
name|line_info_table_in_use
operator|==
name|line_info_table_allocated
condition|)
block|{
name|line_info_table_allocated
operator|+=
name|LINE_INFO_TABLE_INCREMENT
expr_stmt|;
name|line_info_table
operator|=
operator|(
name|dw_line_info_ref
operator|)
name|xrealloc
argument_list|(
name|line_info_table
argument_list|,
operator|(
name|line_info_table_allocated
operator|*
sizeof|sizeof
argument_list|(
name|dw_line_info_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the new entry at the end of the line_info_table.  */
name|line_info
operator|=
operator|&
name|line_info_table
index|[
name|line_info_table_in_use
operator|++
index|]
expr_stmt|;
name|line_info
operator|->
name|dw_file_num
operator|=
name|lookup_filename
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|line_info
operator|->
name|dw_line_num
operator|=
name|line
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record the beginning of a new source file.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_start_source_file
parameter_list|(
name|lineno
parameter_list|,
name|filename
parameter_list|)
name|unsigned
name|int
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|flag_eliminate_dwarf2_dups
condition|)
block|{
comment|/* Record the beginning of the file for break_out_includes.  */
name|dw_die_ref
name|bincl_die
init|=
name|new_die
argument_list|(
name|DW_TAG_GNU_BINCL
argument_list|,
name|comp_unit_die
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|add_AT_string
argument_list|(
name|bincl_die
argument_list|,
name|DW_AT_name
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|named_section_flags
argument_list|(
name|DEBUG_MACINFO_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_MACINFO_start_file
argument_list|,
literal|"Start new file"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|lineno
argument_list|,
literal|"Included from line number %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|lookup_filename
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"Filename we just started"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Record the end of a source file.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_end_source_file
parameter_list|(
name|lineno
parameter_list|)
name|unsigned
name|int
name|lineno
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|flag_eliminate_dwarf2_dups
condition|)
comment|/* Record the end of the file for break_out_includes.  */
name|new_die
argument_list|(
name|DW_TAG_GNU_EINCL
argument_list|,
name|comp_unit_die
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|named_section_flags
argument_list|(
name|DEBUG_MACINFO_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_MACINFO_end_file
argument_list|,
literal|"End file"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from debug_define in toplev.c.  The `buffer' parameter contains    the tail part of the directive line, i.e. the part which is past the    initial whitespace, #, whitespace, directive-name, whitespace part.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_define
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
name|unsigned
name|lineno
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|dwarf2out_start_source_file
argument_list|(
literal|0
argument_list|,
name|primary_filename
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|named_section_flags
argument_list|(
name|DEBUG_MACINFO_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_MACINFO_define
argument_list|,
literal|"Define macro"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|lineno
argument_list|,
literal|"At line number %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|dw2_asm_output_nstring
argument_list|(
name|buffer
argument_list|,
operator|-
literal|1
argument_list|,
literal|"The macro"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called from debug_undef in toplev.c.  The `buffer' parameter contains    the tail part of the directive line, i.e. the part which is past the    initial whitespace, #, whitespace, directive-name, whitespace part.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_undef
parameter_list|(
name|lineno
parameter_list|,
name|buffer
parameter_list|)
name|unsigned
name|lineno
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|buffer
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|named_section_flags
argument_list|(
name|DEBUG_MACINFO_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_MACINFO_undef
argument_list|,
literal|"Undefine macro"
argument_list|)
expr_stmt|;
name|dw2_asm_output_data_uleb128
argument_list|(
name|lineno
argument_list|,
literal|"At line number %d"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|dw2_asm_output_nstring
argument_list|(
name|buffer
argument_list|,
operator|-
literal|1
argument_list|,
literal|"The macro"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set up for Dwarf output at the start of compilation.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_init
parameter_list|(
name|main_input_filename
parameter_list|)
specifier|const
name|char
modifier|*
name|main_input_filename
decl_stmt|;
block|{
name|init_file_table
argument_list|()
expr_stmt|;
comment|/* Remember the name of the primary input file.  */
name|primary_filename
operator|=
name|main_input_filename
expr_stmt|;
comment|/* Add it to the file table first, under the assumption that we'll      be emitting line number data for it first, which avoids having      to add an initial DW_LNS_set_file.  */
name|lookup_filename
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
comment|/* Allocate the initial hunk of the decl_die_table.  */
name|decl_die_table
operator|=
operator|(
name|dw_die_ref
operator|*
operator|)
name|xcalloc
argument_list|(
name|DECL_DIE_TABLE_INCREMENT
argument_list|,
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|decl_die_table_allocated
operator|=
name|DECL_DIE_TABLE_INCREMENT
expr_stmt|;
name|decl_die_table_in_use
operator|=
literal|0
expr_stmt|;
comment|/* Allocate the initial hunk of the decl_scope_table.  */
name|VARRAY_TREE_INIT
argument_list|(
name|decl_scope_table
argument_list|,
literal|256
argument_list|,
literal|"decl_scope_table"
argument_list|)
expr_stmt|;
name|ggc_add_tree_varray_root
argument_list|(
operator|&
name|decl_scope_table
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Allocate the initial hunk of the abbrev_die_table.  */
name|abbrev_die_table
operator|=
operator|(
name|dw_die_ref
operator|*
operator|)
name|xcalloc
argument_list|(
name|ABBREV_DIE_TABLE_INCREMENT
argument_list|,
sizeof|sizeof
argument_list|(
name|dw_die_ref
argument_list|)
argument_list|)
expr_stmt|;
name|abbrev_die_table_allocated
operator|=
name|ABBREV_DIE_TABLE_INCREMENT
expr_stmt|;
comment|/* Zero-th entry is allocated, but unused */
name|abbrev_die_table_in_use
operator|=
literal|1
expr_stmt|;
comment|/* Allocate the initial hunk of the line_info_table.  */
name|line_info_table
operator|=
operator|(
name|dw_line_info_ref
operator|)
name|xcalloc
argument_list|(
name|LINE_INFO_TABLE_INCREMENT
argument_list|,
sizeof|sizeof
argument_list|(
name|dw_line_info_entry
argument_list|)
argument_list|)
expr_stmt|;
name|line_info_table_allocated
operator|=
name|LINE_INFO_TABLE_INCREMENT
expr_stmt|;
comment|/* Zero-th entry is allocated, but unused */
name|line_info_table_in_use
operator|=
literal|1
expr_stmt|;
comment|/* Generate the initial DIE for the .debug section.  Note that the (string)      value given in the DW_AT_name attribute of the DW_TAG_compile_unit DIE      will (typically) be a relative pathname and that this pathname should be      taken as being relative to the directory from which the compiler was      invoked when the given (base) source file was compiled.  */
name|comp_unit_die
operator|=
name|gen_compile_unit_die
argument_list|(
name|main_input_filename
argument_list|)
expr_stmt|;
name|VARRAY_TREE_INIT
argument_list|(
name|incomplete_types
argument_list|,
literal|64
argument_list|,
literal|"incomplete_types"
argument_list|)
expr_stmt|;
name|ggc_add_tree_varray_root
argument_list|(
operator|&
name|incomplete_types
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VARRAY_RTX_INIT
argument_list|(
name|used_rtx_varray
argument_list|,
literal|32
argument_list|,
literal|"used_rtx_varray"
argument_list|)
expr_stmt|;
name|ggc_add_rtx_varray_root
argument_list|(
operator|&
name|used_rtx_varray
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ggc_add_root
argument_list|(
operator|&
name|limbo_die_list
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|mark_limbo_die_list
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|text_end_label
argument_list|,
name|TEXT_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|abbrev_section_label
argument_list|,
name|DEBUG_ABBREV_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DWARF2_GENERATE_TEXT_SECTION_LABEL
condition|)
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|text_section_label
argument_list|,
name|TEXT_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|text_section_label
argument_list|,
name|stripattributes
argument_list|(
name|TEXT_SECTION_NAME
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|debug_info_section_label
argument_list|,
name|DEBUG_INFO_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|debug_line_section_label
argument_list|,
name|DEBUG_LINE_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ranges_section_label
argument_list|,
name|DEBUG_RANGES_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|named_section_flags
argument_list|(
name|DEBUG_ABBREV_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|abbrev_section_label
argument_list|)
expr_stmt|;
name|named_section_flags
argument_list|(
name|DEBUG_INFO_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|debug_info_section_label
argument_list|)
expr_stmt|;
name|named_section_flags
argument_list|(
name|DEBUG_LINE_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|debug_line_section_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|named_section_flags
argument_list|(
name|DEBUG_MACINFO_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|macinfo_section_label
argument_list|,
name|DEBUG_MACINFO_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|macinfo_section_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DWARF2_GENERATE_TEXT_SECTION_LABEL
condition|)
block|{
name|text_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|text_section_label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Allocate a string in .debug_str hash table.  */
end_comment

begin_function
specifier|static
name|hashnode
name|indirect_string_alloc
parameter_list|(
name|tab
parameter_list|)
name|hash_table
modifier|*
name|tab
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|indirect_string_node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|indirect_string_node
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|form
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|label
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|hashnode
operator|)
name|node
return|;
block|}
end_function

begin_comment
comment|/* A helper function for dwarf2out_finish called through    ht_forall.  Emit one queued .debug_str string.  */
end_comment

begin_function
specifier|static
name|int
name|output_indirect_string
parameter_list|(
name|pfile
parameter_list|,
name|h
parameter_list|,
name|v
parameter_list|)
name|struct
name|cpp_reader
modifier|*
name|pfile
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|hashnode
name|h
decl_stmt|;
specifier|const
name|PTR
name|v
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|struct
name|indirect_string_node
modifier|*
name|node
init|=
operator|(
expr|struct
name|indirect_string_node
operator|*
operator|)
name|h
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|form
operator|==
name|DW_FORM_strp
condition|)
block|{
name|named_section_flags
argument_list|(
name|DEBUG_STR_SECTION
argument_list|,
name|DEBUG_STR_SECTION_FLAGS
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|node
operator|->
name|label
argument_list|)
expr_stmt|;
name|assemble_string
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|HT_STR
argument_list|(
operator|&
name|node
operator|->
name|id
argument_list|)
argument_list|,
name|HT_LEN
argument_list|(
operator|&
name|node
operator|->
name|id
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Output stuff that dwarf requires at the end of every file,    and generate the DWARF-2 debugging info.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2out_finish
parameter_list|(
name|input_filename
parameter_list|)
specifier|const
name|char
modifier|*
name|input_filename
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|limbo_die_node
modifier|*
name|node
decl_stmt|,
modifier|*
name|next_node
decl_stmt|;
name|dw_die_ref
name|die
init|=
literal|0
decl_stmt|;
comment|/* Traverse the limbo die list, and add parent/child links.  The only      dies without parents that should be here are concrete instances of      inline functions, and the comp_unit_die.  We can ignore the comp_unit_die.      For concrete instances, we can get the parent die from the abstract      instance.  */
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|next_node
control|)
block|{
name|next_node
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|die
operator|=
name|node
operator|->
name|die
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|die_parent
operator|==
name|NULL
condition|)
block|{
name|dw_die_ref
name|origin
init|=
name|get_AT_ref
argument_list|(
name|die
argument_list|,
name|DW_AT_abstract_origin
argument_list|)
decl_stmt|;
name|tree
name|context
decl_stmt|;
if|if
condition|(
name|origin
condition|)
name|add_child_die
argument_list|(
name|origin
operator|->
name|die_parent
argument_list|,
name|die
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|die
operator|==
name|comp_unit_die
condition|)
empty_stmt|;
comment|/* If this was an expression for a bound involved in a function 	     return type, it may be a SAVE_EXPR for which we weren't able 	     to find a DIE previously.  So try now.  */
elseif|else
if|if
condition|(
name|node
operator|->
name|created_for
operator|&&
name|TREE_CODE
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
operator|==
name|SAVE_EXPR
operator|&&
literal|0
operator|!=
operator|(
name|origin
operator|=
operator|(
name|lookup_decl_die
argument_list|(
name|SAVE_EXPR_CONTEXT
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|add_child_die
argument_list|(
name|origin
argument_list|,
name|die
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errorcount
operator|>
literal|0
operator|||
name|sorrycount
operator|>
literal|0
condition|)
comment|/* It's OK to be confused by errors in the input.  */
name|add_child_die
argument_list|(
name|comp_unit_die
argument_list|,
name|die
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|created_for
operator|&&
operator|(
operator|(
name|DECL_P
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
operator|&&
operator|(
name|context
operator|=
name|DECL_CONTEXT
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|TYPE_P
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
operator|&&
operator|(
name|context
operator|=
name|TYPE_CONTEXT
argument_list|(
name|node
operator|->
name|created_for
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* In certain situations, the lexical block containing a 		 nested function can be optimized away, which results 		 in the nested function die being orphaned.  Likewise 		 with the return type of that nested function.  Force 		 this to be a child of the containing function.  */
name|origin
operator|=
name|lookup_decl_die
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|origin
condition|)
name|abort
argument_list|()
expr_stmt|;
name|add_child_die
argument_list|(
name|origin
argument_list|,
name|die
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|limbo_die_list
operator|=
name|NULL
expr_stmt|;
comment|/* Walk through the list of incomplete types again, trying once more to      emit full debugging info for them.  */
name|retry_incomplete_types
argument_list|()
expr_stmt|;
comment|/* We need to reverse all the dies before break_out_includes, or      we'll see the end of an include file before the beginning.  */
name|reverse_all_dies
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
comment|/* Generate separate CUs for each of the include files we've seen.      They will go into limbo_die_list.  */
if|if
condition|(
name|flag_eliminate_dwarf2_dups
condition|)
name|break_out_includes
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
comment|/* Traverse the DIE's and add add sibling attributes to those DIE's      that have children.  */
name|add_sibling_attributes
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|add_sibling_attributes
argument_list|(
name|node
operator|->
name|die
argument_list|)
expr_stmt|;
comment|/* Output a terminator label for the .text section.  */
name|text_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|TEXT_END_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Output the source line correspondence table.  We must do this      even if there is no line information.  Otherwise, on an empty      translation unit, we will generate a present, but empty,      .debug_info section.  IRIX 6.5 `nm' will then complain when      examining the file.  */
if|if
condition|(
operator|!
name|DWARF2_ASM_LINE_DEBUG_INFO
condition|)
block|{
name|named_section_flags
argument_list|(
name|DEBUG_LINE_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|output_line_info
argument_list|()
expr_stmt|;
block|}
comment|/* Output location list section if necessary.  */
if|if
condition|(
name|have_location_lists
condition|)
block|{
comment|/* Output the location lists info.  */
name|named_section_flags
argument_list|(
name|DEBUG_LOC_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|loc_section_label
argument_list|,
name|DEBUG_LOC_SECTION_LABEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|loc_section_label
argument_list|)
expr_stmt|;
name|output_location_lists
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|have_location_lists
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We can only use the low/high_pc attributes if all of the code was      in .text.  */
if|if
condition|(
name|separate_line_info_table_in_use
operator|==
literal|0
condition|)
block|{
name|add_AT_lbl_id
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_low_pc
argument_list|,
name|text_section_label
argument_list|)
expr_stmt|;
name|add_AT_lbl_id
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_high_pc
argument_list|,
name|text_end_label
argument_list|)
expr_stmt|;
block|}
comment|/* If it wasn't, we need to give .debug_loc and .debug_ranges an appropriate      "base address".  Use zero so that these addresses become absolute.  */
elseif|else
if|if
condition|(
name|have_location_lists
operator|||
name|ranges_table_in_use
condition|)
name|add_AT_addr
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_entry_pc
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_NORMAL
condition|)
name|add_AT_lbl_offset
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_stmt_list
argument_list|,
name|debug_line_section_label
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
name|add_AT_lbl_offset
argument_list|(
name|comp_unit_die
argument_list|,
name|DW_AT_macro_info
argument_list|,
name|macinfo_section_label
argument_list|)
expr_stmt|;
comment|/* Output all of the compilation units.  We put the main one last so that      the offsets are available to output_pubnames.  */
for|for
control|(
name|node
operator|=
name|limbo_die_list
init|;
name|node
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
name|output_comp_unit
argument_list|(
name|node
operator|->
name|die
argument_list|)
expr_stmt|;
name|output_comp_unit
argument_list|(
name|comp_unit_die
argument_list|)
expr_stmt|;
comment|/* Output the abbreviation table.  */
name|named_section_flags
argument_list|(
name|DEBUG_ABBREV_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|output_abbrev_section
argument_list|()
expr_stmt|;
comment|/* Output public names table if necessary.  */
if|if
condition|(
name|pubname_table_in_use
condition|)
block|{
name|named_section_flags
argument_list|(
name|DEBUG_PUBNAMES_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|output_pubnames
argument_list|()
expr_stmt|;
block|}
comment|/* Output the address range information.  We only put functions in the arange      table, so don't write it out if we don't have any.  */
if|if
condition|(
name|fde_table_in_use
condition|)
block|{
name|named_section_flags
argument_list|(
name|DEBUG_ARANGES_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|output_aranges
argument_list|()
expr_stmt|;
block|}
comment|/* Output ranges section if necessary.  */
if|if
condition|(
name|ranges_table_in_use
condition|)
block|{
name|named_section_flags
argument_list|(
name|DEBUG_RANGES_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|ranges_section_label
argument_list|)
expr_stmt|;
name|output_ranges
argument_list|()
expr_stmt|;
block|}
comment|/* Have to end the primary source file.  */
if|if
condition|(
name|debug_info_level
operator|>=
name|DINFO_LEVEL_VERBOSE
condition|)
block|{
name|named_section_flags
argument_list|(
name|DEBUG_MACINFO_SECTION
argument_list|,
name|SECTION_DEBUG
argument_list|)
expr_stmt|;
name|dw2_asm_output_data
argument_list|(
literal|1
argument_list|,
name|DW_MACINFO_end_file
argument_list|,
literal|"End file"
argument_list|)
expr_stmt|;
block|}
comment|/* If we emitted any DW_FORM_strp form attribute, output the string      table too.  */
if|if
condition|(
name|debug_str_hash
condition|)
name|ht_forall
argument_list|(
name|debug_str_hash
argument_list|,
name|output_indirect_string
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DWARF2_DEBUGGING_INFO || DWARF2_UNWIND_INFO */
end_comment

end_unit

