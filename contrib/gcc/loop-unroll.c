begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Loop unrolling and peeling.    Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_comment
comment|/* We need to use the macro exact_log2. */
end_comment

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* This pass performs loop unrolling and peeling.  We only perform these    optimizations on innermost loops (with single exception) because    the impact on performance is greatest here, and we want to avoid    unnecessary code size growth.  The gain is caused by greater sequentiality    of code, better code to optimize for further passes and in some cases    by fewer testings of exit conditions.  The main problem is code growth,    that impacts performance negatively due to effect of caches.     What we do:     -- complete peeling of once-rolling loops; this is the above mentioned       exception, as this causes loop to be cancelled completely and       does not cause code growth    -- complete peeling of loops that roll (small) constant times.    -- simple peeling of first iterations of loops that do not roll much       (according to profile feedback)    -- unrolling of loops that roll constant times; this is almost always       win, as we get rid of exit condition tests.    -- unrolling of loops that roll number of times that we can compute       in runtime; we also get rid of exit condition tests here, but there       is the extra expense for calculating the number of iterations    -- simple unrolling of remaining loops; this is performed only if we       are asked to, as the gain is questionable in this case and often       it may even slow down the code    For more detailed descriptions of each of those, see comments at    appropriate function below.     There is a lot of parameters (defined and described in params.def) that    control how much we unroll/peel.     ??? A great problem is that we don't have a good way how to determine    how many times we should unroll the loop; the experiments I have made    showed that this choice may affect performance in order of several %.    */
end_comment

begin_function_decl
specifier|static
name|void
name|decide_unrolling_and_peeling
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|peel_loops_completely
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_peel_simple
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_peel_once_rolling
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_peel_completely
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_unroll_stupid
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_unroll_constant_iterations
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_unroll_runtime_iterations
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|peel_loop_simple
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|peel_loop_completely
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unroll_loop_stupid
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unroll_loop_constant_iterations
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unroll_loop_runtime_iterations
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_bct
parameter_list|(
name|edge
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|discard_increment
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Unroll and/or peel (depending on FLAGS) LOOPS.  */
end_comment

begin_function
name|void
name|unroll_and_peel_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|check
decl_stmt|;
comment|/* First perform complete loop peeling (it is almost surely a win,      and affects parameters for further decision a lot).  */
name|peel_loops_completely
argument_list|(
name|loops
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Now decide rest of unrolling and peeling.  */
name|decide_unrolling_and_peeling
argument_list|(
name|loops
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|loop
operator|=
name|loops
operator|->
name|tree_root
expr_stmt|;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
name|loop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
comment|/* Scan the loops, inner ones first.  */
while|while
condition|(
name|loop
operator|!=
name|loops
operator|->
name|tree_root
condition|)
block|{
if|if
condition|(
name|loop
operator|->
name|next
condition|)
block|{
name|next
operator|=
name|loop
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|next
operator|->
name|inner
condition|)
name|next
operator|=
name|next
operator|->
name|inner
expr_stmt|;
block|}
else|else
name|next
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
name|check
operator|=
literal|1
expr_stmt|;
comment|/* And perform the appropriate transformations.  */
switch|switch
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
condition|)
block|{
case|case
name|LPT_PEEL_COMPLETELY
case|:
comment|/* Already done.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|LPT_PEEL_SIMPLE
case|:
name|peel_loop_simple
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
break|break;
case|case
name|LPT_UNROLL_CONSTANT
case|:
name|unroll_loop_constant_iterations
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
break|break;
case|case
name|LPT_UNROLL_RUNTIME
case|:
name|unroll_loop_runtime_iterations
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
break|break;
case|case
name|LPT_UNROLL_STUPID
case|:
name|unroll_loop_stupid
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
break|break;
case|case
name|LPT_NONE
case|:
name|check
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|check
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|verify_loop_structure
argument_list|(
name|loops
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|loop
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check whether to peel LOOPS (depending on FLAGS) completely and do so.  */
end_comment

begin_function
specifier|static
name|void
name|peel_loops_completely
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|loop
operator|=
name|loops
operator|->
name|tree_root
expr_stmt|;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
name|loop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
while|while
condition|(
name|loop
operator|!=
name|loops
operator|->
name|tree_root
condition|)
block|{
if|if
condition|(
name|loop
operator|->
name|next
condition|)
block|{
name|next
operator|=
name|loop
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|next
operator|->
name|inner
condition|)
name|next
operator|=
name|next
operator|->
name|inner
expr_stmt|;
block|}
else|else
name|next
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_NONE
expr_stmt|;
name|loop
operator|->
name|has_desc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Considering loop %d for complete peeling\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|loop
operator|->
name|ninsns
operator|=
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|decide_peel_once_rolling
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|==
name|LPT_NONE
condition|)
name|decide_peel_completely
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|==
name|LPT_PEEL_COMPLETELY
condition|)
block|{
name|peel_loop_completely
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|verify_loop_structure
argument_list|(
name|loops
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|loop
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decide whether unroll or peel LOOPS (depending on FLAGS) and how much.  */
end_comment

begin_function
specifier|static
name|void
name|decide_unrolling_and_peeling
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|tree_root
decl_stmt|,
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
name|loop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
comment|/* Scan the loops, inner ones first.  */
while|while
condition|(
name|loop
operator|!=
name|loops
operator|->
name|tree_root
condition|)
block|{
if|if
condition|(
name|loop
operator|->
name|next
condition|)
block|{
name|next
operator|=
name|loop
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|next
operator|->
name|inner
condition|)
name|next
operator|=
name|next
operator|->
name|inner
expr_stmt|;
block|}
else|else
name|next
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_NONE
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Considering loop %d\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
comment|/* Do not peel cold areas.  */
if|if
condition|(
operator|!
name|maybe_hot_bb_p
argument_list|(
name|loop
operator|->
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, cold area\n"
argument_list|)
expr_stmt|;
name|loop
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Can the loop be manipulated?  */
if|if
condition|(
operator|!
name|can_duplicate_loop_p
argument_list|(
name|loop
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, cannot duplicate\n"
argument_list|)
expr_stmt|;
name|loop
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Skip non-innermost loops.  */
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, is not innermost\n"
argument_list|)
expr_stmt|;
name|loop
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
name|loop
operator|->
name|ninsns
operator|=
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|loop
operator|->
name|av_ninsns
operator|=
name|average_num_loop_insns
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Try transformations one by one in decreasing order of 	 priority.  */
name|decide_unroll_constant_iterations
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|==
name|LPT_NONE
condition|)
name|decide_unroll_runtime_iterations
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|==
name|LPT_NONE
condition|)
name|decide_unroll_stupid
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|==
name|LPT_NONE
condition|)
name|decide_peel_simple
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|loop
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decide whether the LOOP is once rolling and suitable for complete    peeling.  */
end_comment

begin_function
specifier|static
name|void
name|decide_peel_once_rolling
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Considering peeling once rolling loop\n"
argument_list|)
expr_stmt|;
comment|/* Is the loop small enough?  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_ONCE_PEELED_INSNS
argument_list|)
operator|<
name|loop
operator|->
name|ninsns
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
name|loop
operator|->
name|simple
operator|=
name|simple_loop_p
argument_list|(
name|loop
argument_list|,
operator|&
name|loop
operator|->
name|desc
argument_list|)
expr_stmt|;
name|loop
operator|->
name|has_desc
operator|=
literal|1
expr_stmt|;
comment|/* Check number of iterations.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|simple
operator|||
operator|!
name|loop
operator|->
name|desc
operator|.
name|const_iter
operator|||
name|loop
operator|->
name|desc
operator|.
name|niter
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Unable to prove that the loop rolls exactly once\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success.  */
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Decided to peel exactly once rolling loop\n"
argument_list|)
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_PEEL_COMPLETELY
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether the LOOP is suitable for complete peeling.  */
end_comment

begin_function
specifier|static
name|void
name|decide_peel_completely
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|npeel
decl_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Considering peeling completely\n"
argument_list|)
expr_stmt|;
comment|/* Skip non-innermost loops.  */
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, is not innermost\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do not peel cold areas.  */
if|if
condition|(
operator|!
name|maybe_hot_bb_p
argument_list|(
name|loop
operator|->
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, cold area\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Can the loop be manipulated?  */
if|if
condition|(
operator|!
name|can_duplicate_loop_p
argument_list|(
name|loop
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, cannot duplicate\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* npeel = number of iterations to peel.  */
name|npeel
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_COMPLETELY_PEELED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|ninsns
expr_stmt|;
if|if
condition|(
name|npeel
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_COMPLETELY_PEEL_TIMES
argument_list|)
condition|)
name|npeel
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_COMPLETELY_PEEL_TIMES
argument_list|)
expr_stmt|;
comment|/* Is the loop small enough?  */
if|if
condition|(
operator|!
name|npeel
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|has_desc
condition|)
block|{
name|loop
operator|->
name|simple
operator|=
name|simple_loop_p
argument_list|(
name|loop
argument_list|,
operator|&
name|loop
operator|->
name|desc
argument_list|)
expr_stmt|;
name|loop
operator|->
name|has_desc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check number of iterations.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|simple
operator|||
operator|!
name|loop
operator|->
name|desc
operator|.
name|const_iter
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Unable to prove that the loop iterates constant times\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|loop
operator|->
name|desc
operator|.
name|niter
operator|>
name|npeel
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not peeling loop completely, rolls too much ("
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|loop
operator|->
name|desc
operator|.
name|niter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" iterations> %d [maximum peelings])\n"
argument_list|,
name|npeel
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Success.  */
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Decided to peel loop completely\n"
argument_list|)
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_PEEL_COMPLETELY
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Peel all iterations of LOOP, remove exit edges and cancel the loop    completely.  The transformation done:     for (i = 0; i< 4; i++)      body;     ==>     i = 0;    body; i++;    body; i++;    body; i++;    body; i++;    */
end_comment

begin_function
specifier|static
name|void
name|peel_loop_completely
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|sbitmap
name|wont_exit
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|npeel
decl_stmt|;
name|unsigned
name|n_remove_edges
decl_stmt|,
name|i
decl_stmt|;
name|edge
modifier|*
name|remove_edges
decl_stmt|;
name|struct
name|loop_desc
modifier|*
name|desc
init|=
operator|&
name|loop
operator|->
name|desc
decl_stmt|;
name|bool
name|discard_inc
init|=
name|false
decl_stmt|;
name|bool
name|is_bct
decl_stmt|;
if|if
condition|(
operator|(
name|is_bct
operator|=
name|is_bct_cond
argument_list|(
name|BB_END
argument_list|(
name|loop
operator|->
name|desc
operator|.
name|out_edge
operator|->
name|src
argument_list|)
argument_list|)
operator|)
condition|)
name|discard_inc
operator|=
name|discard_increment
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|npeel
operator|=
name|desc
operator|->
name|niter
expr_stmt|;
if|if
condition|(
name|npeel
condition|)
block|{
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|npeel
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|may_be_zero
condition|)
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|remove_edges
operator|=
name|xcalloc
argument_list|(
name|npeel
argument_list|,
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|n_remove_edges
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|npeel
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
comment|/* Expand the branch and count.  */
if|if
condition|(
name|is_bct
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_remove_edges
condition|;
name|i
operator|++
control|)
name|expand_bct
argument_list|(
name|remove_edges
index|[
name|i
index|]
argument_list|,
name|discard_inc
argument_list|)
expr_stmt|;
comment|/* Remove the exit edges.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_remove_edges
condition|;
name|i
operator|++
control|)
name|remove_path
argument_list|(
name|loops
argument_list|,
name|remove_edges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remove_edges
argument_list|)
expr_stmt|;
block|}
comment|/* Expand the branch and count.  */
if|if
condition|(
name|is_bct
condition|)
name|expand_bct
argument_list|(
name|desc
operator|->
name|in_edge
argument_list|,
name|discard_inc
argument_list|)
expr_stmt|;
comment|/* Now remove the unreachable part of the last iteration and cancel      the loop.  */
name|remove_path
argument_list|(
name|loops
argument_list|,
name|desc
operator|->
name|in_edge
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Peeled loop completely, %d times\n"
argument_list|,
operator|(
name|int
operator|)
name|npeel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether to unroll LOOP iterating constant number of times and how much.  */
end_comment

begin_function
specifier|static
name|void
name|decide_unroll_constant_iterations
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|nunroll
decl_stmt|,
name|nunroll_by_av
decl_stmt|,
name|best_copies
decl_stmt|,
name|best_unroll
init|=
operator|-
literal|1
decl_stmt|,
name|n_copies
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|UAP_UNROLL
operator|)
condition|)
block|{
comment|/* We were not asked to, just return back silently.  */
return|return;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Considering unrolling loop with constant number of iterations\n"
argument_list|)
expr_stmt|;
comment|/* nunroll = total number of copies of the original loop body in      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|ninsns
expr_stmt|;
name|nunroll_by_av
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_AVERAGE_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|av_ninsns
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
name|nunroll_by_av
condition|)
name|nunroll
operator|=
name|nunroll_by_av
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
condition|)
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
expr_stmt|;
comment|/* Skip big loops.  */
if|if
condition|(
name|nunroll
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|has_desc
condition|)
block|{
name|loop
operator|->
name|simple
operator|=
name|simple_loop_p
argument_list|(
name|loop
argument_list|,
operator|&
name|loop
operator|->
name|desc
argument_list|)
expr_stmt|;
name|loop
operator|->
name|has_desc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check number of iterations.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|simple
operator|||
operator|!
name|loop
operator|->
name|desc
operator|.
name|const_iter
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Unable to prove that the loop iterates constant times\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check whether the loop rolls enough to consider.  */
if|if
condition|(
name|loop
operator|->
name|desc
operator|.
name|niter
operator|<
literal|2
operator|*
name|nunroll
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not unrolling loop, doesn't roll\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success; now compute number of iterations to unroll.  We alter      nunroll so that as few as possible copies of loop body are      necessary, while still not decreasing the number of unrollings      too much (at most by 1).  */
name|best_copies
operator|=
literal|2
operator|*
name|nunroll
operator|+
literal|10
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|nunroll
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|i
operator|-
literal|1
operator|>=
name|loop
operator|->
name|desc
operator|.
name|niter
condition|)
name|i
operator|=
name|loop
operator|->
name|desc
operator|.
name|niter
operator|-
literal|2
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
name|nunroll
operator|-
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|unsigned
name|exit_mod
init|=
name|loop
operator|->
name|desc
operator|.
name|niter
operator|%
operator|(
name|i
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|loop
operator|->
name|desc
operator|.
name|postincr
condition|)
name|n_copies
operator|=
name|exit_mod
operator|+
name|i
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|exit_mod
operator|!=
operator|(
name|unsigned
operator|)
name|i
operator|||
name|loop
operator|->
name|desc
operator|.
name|may_be_zero
condition|)
name|n_copies
operator|=
name|exit_mod
operator|+
name|i
operator|+
literal|2
expr_stmt|;
else|else
name|n_copies
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n_copies
operator|<
name|best_copies
condition|)
block|{
name|best_copies
operator|=
name|n_copies
expr_stmt|;
name|best_unroll
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; max_unroll %d (%d copies, initial %d).\n"
argument_list|,
name|best_unroll
operator|+
literal|1
argument_list|,
name|best_copies
argument_list|,
name|nunroll
argument_list|)
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_UNROLL_CONSTANT
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|times
operator|=
name|best_unroll
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unroll LOOP with constant number of iterations LOOP->LPT_DECISION.TIMES + 1    times.  The transformation does this:     for (i = 0; i< 102; i++)      body;     ==>     i = 0;    body; i++;    body; i++;    while (i< 102)      {        body; i++;        body; i++;        body; i++;        body; i++;      }   */
end_comment

begin_function
specifier|static
name|void
name|unroll_loop_constant_iterations
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|niter
decl_stmt|;
name|unsigned
name|exit_mod
decl_stmt|;
name|sbitmap
name|wont_exit
decl_stmt|;
name|unsigned
name|n_remove_edges
decl_stmt|,
name|i
decl_stmt|;
name|edge
modifier|*
name|remove_edges
decl_stmt|;
name|unsigned
name|max_unroll
init|=
name|loop
operator|->
name|lpt_decision
operator|.
name|times
decl_stmt|;
name|struct
name|loop_desc
modifier|*
name|desc
init|=
operator|&
name|loop
operator|->
name|desc
decl_stmt|;
name|bool
name|discard_inc
init|=
name|false
decl_stmt|;
name|bool
name|is_bct
decl_stmt|;
name|niter
operator|=
name|desc
operator|->
name|niter
expr_stmt|;
if|if
condition|(
name|niter
operator|<=
operator|(
name|unsigned
operator|)
name|max_unroll
operator|+
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Should not get here (such loop should be peeled instead).  */
name|exit_mod
operator|=
name|niter
operator|%
operator|(
name|max_unroll
operator|+
literal|1
operator|)
expr_stmt|;
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|max_unroll
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|remove_edges
operator|=
name|xcalloc
argument_list|(
name|max_unroll
operator|+
name|exit_mod
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|n_remove_edges
operator|=
literal|0
expr_stmt|;
comment|/* For a loop ending with a branch and count for which the increment      of the count register will be discarded, adjust the initialization of      the count register.  */
if|if
condition|(
operator|(
name|is_bct
operator|=
name|is_bct_cond
argument_list|(
name|BB_END
argument_list|(
name|desc
operator|->
name|out_edge
operator|->
name|src
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|discard_inc
operator|=
name|discard_increment
argument_list|(
name|loop
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|ini_var
decl_stmt|;
name|rtx
name|init_code
decl_stmt|;
name|int
name|n_peel
decl_stmt|,
name|new_bct_value
decl_stmt|;
comment|/* Get expression for number of iterations.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|n_peel
operator|=
operator|(
name|niter
operator|+
literal|1
operator|)
operator|%
operator|(
name|max_unroll
operator|+
literal|1
operator|)
expr_stmt|;
name|new_bct_value
operator|=
operator|(
name|niter
operator|+
literal|1
operator|-
name|n_peel
operator|)
operator|/
operator|(
name|max_unroll
operator|+
literal|1
operator|)
expr_stmt|;
name|ini_var
operator|=
name|GEN_INT
argument_list|(
name|new_bct_value
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|desc
operator|->
name|var
argument_list|,
name|ini_var
argument_list|)
expr_stmt|;
name|init_code
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|init_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|->
name|postincr
condition|)
block|{
comment|/* Counter is incremented after the exit test; leave exit test 	 in the first copy, so that the loops that start with test 	 of exit condition have continuous body after unrolling.  */
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Condition on beginning of loop.\n"
argument_list|)
expr_stmt|;
comment|/* Peel exit_mod iterations.  */
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|may_be_zero
condition|)
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_mod
operator|&&
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|exit_mod
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave exit test in last copy, for the same reason as above if 	 the loop tests the condition at the end of loop body.  */
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Condition on end of loop.\n"
argument_list|)
expr_stmt|;
comment|/* We know that niter>= max_unroll + 2; so we do not need to care of 	 case when we would exit before reaching the loop.  So just peel 	 exit_mod + 1 iterations. 	 */
if|if
condition|(
name|exit_mod
operator|!=
operator|(
name|unsigned
operator|)
name|max_unroll
operator|||
name|desc
operator|->
name|may_be_zero
condition|)
block|{
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|may_be_zero
condition|)
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|exit_mod
operator|+
literal|1
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
name|max_unroll
argument_list|)
expr_stmt|;
block|}
comment|/* Now unroll the loop.  */
if|if
condition|(
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|max_unroll
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
comment|/* Expand the branch and count.  */
if|if
condition|(
name|is_bct
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_remove_edges
condition|;
name|i
operator|++
control|)
name|expand_bct
argument_list|(
name|remove_edges
index|[
name|i
index|]
argument_list|,
name|discard_inc
argument_list|)
expr_stmt|;
comment|/* Remove the edges.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_remove_edges
condition|;
name|i
operator|++
control|)
name|remove_path
argument_list|(
name|loops
argument_list|,
name|remove_edges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remove_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Unrolled loop %d times, constant # of iterations %i insns\n"
argument_list|,
name|max_unroll
argument_list|,
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether to unroll LOOP iterating runtime computable number of times    and how much.  */
end_comment

begin_function
specifier|static
name|void
name|decide_unroll_runtime_iterations
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|nunroll
decl_stmt|,
name|nunroll_by_av
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|UAP_UNROLL
operator|)
condition|)
block|{
comment|/* We were not asked to, just return back silently.  */
return|return;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Considering unrolling loop with runtime computable number of iterations\n"
argument_list|)
expr_stmt|;
comment|/* nunroll = total number of copies of the original loop body in      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|ninsns
expr_stmt|;
name|nunroll_by_av
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_AVERAGE_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|av_ninsns
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
name|nunroll_by_av
condition|)
name|nunroll
operator|=
name|nunroll_by_av
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
condition|)
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
expr_stmt|;
comment|/* Skip big loops.  */
if|if
condition|(
name|nunroll
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|has_desc
condition|)
block|{
name|loop
operator|->
name|simple
operator|=
name|simple_loop_p
argument_list|(
name|loop
argument_list|,
operator|&
name|loop
operator|->
name|desc
argument_list|)
expr_stmt|;
name|loop
operator|->
name|has_desc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check simpleness.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|simple
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Unable to prove that the number of iterations can be counted in runtime\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|loop
operator|->
name|desc
operator|.
name|const_iter
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Loop iterates constant times\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have profile feedback, check whether the loop rolls.  */
if|if
condition|(
name|loop
operator|->
name|header
operator|->
name|count
operator|&&
name|expected_loop_iterations
argument_list|(
name|loop
argument_list|)
operator|<
literal|2
operator|*
name|nunroll
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not unrolling loop, doesn't roll\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success; now force nunroll to be power of 2, as we are unable to      cope with overflows in computation of number of iterations.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
literal|2
operator|*
name|i
operator|<=
name|nunroll
condition|;
name|i
operator|*=
literal|2
control|)
empty_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_UNROLL_RUNTIME
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|times
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unroll LOOP for that we are able to count number of iterations in runtime    LOOP->LPT_DECISION.TIMES + 1 times.  The transformation does this (with some    extra care for case n< 0):     for (i = 0; i< n; i++)      body;     ==>     i = 0;    mod = n % 4;     switch (mod)      {        case 3:          body; i++;        case 2:          body; i++;        case 1:          body; i++;        case 0: ;      }     while (i< n)      {        body; i++;        body; i++;        body; i++;        body; i++;      }    */
end_comment

begin_function
specifier|static
name|void
name|unroll_loop_runtime_iterations
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|rtx
name|niter
decl_stmt|,
name|init_code
decl_stmt|,
name|branch_code
decl_stmt|,
name|jump
decl_stmt|,
name|label
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|p
decl_stmt|;
name|basic_block
name|preheader
decl_stmt|,
modifier|*
name|body
decl_stmt|,
modifier|*
name|dom_bbs
decl_stmt|,
name|swtch
decl_stmt|,
name|ezc_swtch
decl_stmt|;
name|unsigned
name|n_dom_bbs
decl_stmt|;
name|sbitmap
name|wont_exit
decl_stmt|;
name|int
name|may_exit_copy
decl_stmt|;
name|unsigned
name|n_peel
decl_stmt|,
name|n_remove_edges
decl_stmt|;
name|edge
modifier|*
name|remove_edges
decl_stmt|,
name|e
decl_stmt|;
name|bool
name|extra_zero_check
decl_stmt|,
name|last_may_exit
decl_stmt|;
name|unsigned
name|max_unroll
init|=
name|loop
operator|->
name|lpt_decision
operator|.
name|times
decl_stmt|;
name|struct
name|loop_desc
modifier|*
name|desc
init|=
operator|&
name|loop
operator|->
name|desc
decl_stmt|;
name|bool
name|discard_inc
init|=
name|false
decl_stmt|;
name|bool
name|is_bct
decl_stmt|;
comment|/* Remember blocks whose dominators will have to be updated.  */
name|dom_bbs
operator|=
name|xcalloc
argument_list|(
name|n_basic_blocks
argument_list|,
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|n_dom_bbs
operator|=
literal|0
expr_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|nldom
decl_stmt|;
name|basic_block
modifier|*
name|ldom
decl_stmt|;
name|nldom
operator|=
name|get_dominated_by
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|body
index|[
name|i
index|]
argument_list|,
operator|&
name|ldom
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nldom
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|ldom
index|[
name|j
index|]
argument_list|)
condition|)
name|dom_bbs
index|[
name|n_dom_bbs
operator|++
index|]
operator|=
name|ldom
index|[
name|j
index|]
expr_stmt|;
name|free
argument_list|(
name|ldom
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|postincr
condition|)
block|{
comment|/* Leave exit in first copy (for explanation why see comment in 	 unroll_loop_constant_iterations).  */
name|may_exit_copy
operator|=
literal|0
expr_stmt|;
name|n_peel
operator|=
name|max_unroll
operator|-
literal|1
expr_stmt|;
name|extra_zero_check
operator|=
name|true
expr_stmt|;
name|last_may_exit
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave exit in last copy (for explanation why see comment in 	 unroll_loop_constant_iterations).  */
name|may_exit_copy
operator|=
name|max_unroll
expr_stmt|;
name|n_peel
operator|=
name|max_unroll
expr_stmt|;
name|extra_zero_check
operator|=
name|false
expr_stmt|;
name|last_may_exit
operator|=
name|true
expr_stmt|;
block|}
comment|/* Get expression for number of iterations.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|niter
operator|=
name|count_loop_iterations
argument_list|(
name|desc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|niter
condition|)
name|abort
argument_list|()
expr_stmt|;
name|niter
operator|=
name|force_operand
argument_list|(
name|niter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Count modulo by ANDing it with max_unroll; we use the fact that      the number of unrollings is a power of two, and thus this is correct      even if there is overflow in the computation.  */
name|niter
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
argument_list|,
name|AND
argument_list|,
name|niter
argument_list|,
name|GEN_INT
argument_list|(
name|max_unroll
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* For a loop ending with a branch and count for which the increment      of the count register will be discarded, adjust the initialization of      the count register.  */
if|if
condition|(
operator|(
name|is_bct
operator|=
name|is_bct_cond
argument_list|(
name|BB_END
argument_list|(
name|desc
operator|->
name|out_edge
operator|->
name|src
argument_list|)
argument_list|)
operator|)
operator|&&
operator|(
name|discard_inc
operator|=
name|discard_increment
argument_list|(
name|loop
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|count
decl_stmt|,
name|count2
decl_stmt|,
name|count_unroll_mod
decl_stmt|;
name|int
name|count_unroll
decl_stmt|;
comment|/* start_sequence (); */
name|count
operator|=
name|count_loop_iterations
argument_list|(
name|desc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|count_unroll
operator|=
name|loop
operator|->
name|lpt_decision
operator|.
name|times
operator|+
literal|1
expr_stmt|;
name|count_unroll_mod
operator|=
name|GEN_INT
argument_list|(
name|exact_log2
argument_list|(
name|count_unroll
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
argument_list|,
name|LSHIFTRT
argument_list|,
name|count
argument_list|,
name|count_unroll_mod
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|count2
operator|=
name|expand_simple_binop
argument_list|(
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
argument_list|,
name|PLUS
argument_list|,
name|count
argument_list|,
name|GEN_INT
argument_list|(
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|desc
operator|->
name|var
argument_list|,
name|count2
argument_list|)
expr_stmt|;
block|}
name|init_code
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Precondition the loop.  */
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|init_code
argument_list|)
expr_stmt|;
name|remove_edges
operator|=
name|xcalloc
argument_list|(
name|max_unroll
operator|+
name|n_peel
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|edge
argument_list|)
argument_list|)
expr_stmt|;
name|n_remove_edges
operator|=
literal|0
expr_stmt|;
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|max_unroll
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Peel the first copy of loop body (almost always we must leave exit test      here; the only exception is when we have extra zero check and the number      of iterations is reliable (i.e. comes out of NE condition).  Also record      the place of (possible) extra zero check.  */
name|sbitmap_zero
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_zero_check
operator|&&
name|desc
operator|->
name|cond
operator|==
name|NE
condition|)
name|SET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ezc_swtch
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
literal|1
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Record the place where switch will be built for preconditioning.  */
name|swtch
operator|=
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_peel
condition|;
name|i
operator|++
control|)
block|{
comment|/* Peel the copy.  */
name|sbitmap_zero
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|n_peel
operator|-
literal|1
operator|||
operator|!
name|last_may_exit
condition|)
name|SET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
literal|1
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Create item for switch.  */
name|j
operator|=
name|n_peel
operator|-
name|i
operator|-
operator|(
name|extra_zero_check
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|p
operator|=
name|REG_BR_PROB_BASE
operator|/
operator|(
name|i
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* If modulo is zero do not jumo to the header of the unrolled loops.            Jump instead to the last branch and count that precedes it.  */
if|if
condition|(
name|is_bct
operator|&&
name|discard_inc
operator|&&
operator|(
name|j
operator|==
literal|0
operator|)
condition|)
block|{
name|basic_block
name|lastbb
init|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
decl_stmt|;
name|rtx
name|split_after
decl_stmt|;
comment|/* Skip dummy basic blocks generated during the unrolling.  */
while|while
condition|(
operator|!
name|is_bct_cond
argument_list|(
name|BB_END
argument_list|(
name|lastbb
argument_list|)
argument_list|)
condition|)
name|lastbb
operator|=
name|lastbb
operator|->
name|pred
operator|->
name|src
expr_stmt|;
name|split_after
operator|=
name|PREV_INSN
argument_list|(
name|BB_END
argument_list|(
name|lastbb
argument_list|)
argument_list|)
expr_stmt|;
name|preheader
operator|=
name|split_loop_bb
argument_list|(
name|lastbb
argument_list|,
name|split_after
argument_list|)
operator|->
name|dest
expr_stmt|;
block|}
else|else
name|preheader
operator|=
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|label
operator|=
name|block_label
argument_list|(
name|preheader
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|copy_rtx
argument_list|(
name|niter
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|j
argument_list|)
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|jump
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|p
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
name|branch_code
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|swtch
operator|=
name|loop_split_edge_with
argument_list|(
name|swtch
operator|->
name|pred
argument_list|,
name|branch_code
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|preheader
argument_list|,
name|swtch
argument_list|)
expr_stmt|;
name|swtch
operator|->
name|succ
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|p
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|swtch
argument_list|,
name|preheader
argument_list|,
name|swtch
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|extra_zero_check
condition|)
block|{
comment|/* Add branch for zero iterations.  */
name|p
operator|=
name|REG_BR_PROB_BASE
operator|/
operator|(
name|max_unroll
operator|+
literal|1
operator|)
expr_stmt|;
name|swtch
operator|=
name|ezc_swtch
expr_stmt|;
name|preheader
operator|=
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|label
operator|=
name|block_label
argument_list|(
name|preheader
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|copy_rtx
argument_list|(
name|niter
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|desc
operator|->
name|var
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|jump
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|JUMP_LABEL
argument_list|(
name|jump
argument_list|)
operator|=
name|label
expr_stmt|;
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_BR_PROB
argument_list|,
name|GEN_INT
argument_list|(
name|p
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|jump
argument_list|)
argument_list|)
expr_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|++
expr_stmt|;
name|branch_code
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|swtch
operator|=
name|loop_split_edge_with
argument_list|(
name|swtch
operator|->
name|succ
argument_list|,
name|branch_code
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|preheader
argument_list|,
name|swtch
argument_list|)
expr_stmt|;
name|swtch
operator|->
name|succ
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|p
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|swtch
argument_list|,
name|preheader
argument_list|,
name|swtch
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|p
expr_stmt|;
block|}
comment|/* Recount dominators for outer blocks.  */
name|iterate_fix_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dom_bbs
argument_list|,
name|n_dom_bbs
argument_list|)
expr_stmt|;
comment|/* And unroll loop.  */
name|sbitmap_ones
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
name|may_exit_copy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|max_unroll
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
comment|/* Expand the branch and count.  */
if|if
condition|(
name|is_bct
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_remove_edges
condition|;
name|i
operator|++
control|)
name|expand_bct
argument_list|(
name|remove_edges
index|[
name|i
index|]
argument_list|,
name|discard_inc
argument_list|)
expr_stmt|;
comment|/* Remove the edges.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_remove_edges
condition|;
name|i
operator|++
control|)
name|remove_path
argument_list|(
name|loops
argument_list|,
name|remove_edges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remove_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Unrolled loop %d times, counting # of iterations in runtime, %i insns\n"
argument_list|,
name|max_unroll
argument_list|,
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether to simply peel LOOP and how much.  */
end_comment

begin_function
specifier|static
name|void
name|decide_peel_simple
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|npeel
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|UAP_PEEL
operator|)
condition|)
block|{
comment|/* We were not asked to, just return back silently.  */
return|return;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Considering simply peeling loop\n"
argument_list|)
expr_stmt|;
comment|/* npeel = number of iterations to peel.  */
name|npeel
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_PEELED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|ninsns
expr_stmt|;
if|if
condition|(
name|npeel
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_PEEL_TIMES
argument_list|)
condition|)
name|npeel
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_PEEL_TIMES
argument_list|)
expr_stmt|;
comment|/* Skip big loops.  */
if|if
condition|(
operator|!
name|npeel
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|has_desc
condition|)
block|{
name|loop
operator|->
name|simple
operator|=
name|simple_loop_p
argument_list|(
name|loop
argument_list|,
operator|&
name|loop
operator|->
name|desc
argument_list|)
expr_stmt|;
name|loop
operator|->
name|has_desc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check number of iterations.  */
if|if
condition|(
name|loop
operator|->
name|simple
operator|&&
name|loop
operator|->
name|desc
operator|.
name|const_iter
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Loop iterates constant times\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do not simply peel loops with branches inside -- it increases number      of mispredicts.  */
if|if
condition|(
name|loop
operator|->
name|desc
operator|.
name|n_branches
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not peeling, contains branches\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|loop
operator|->
name|header
operator|->
name|count
condition|)
block|{
name|unsigned
name|niter
init|=
name|expected_loop_iterations
argument_list|(
name|loop
argument_list|)
decl_stmt|;
if|if
condition|(
name|niter
operator|+
literal|1
operator|>
name|npeel
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not peeling loop, rolls too much ("
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
call|(
name|HOST_WIDEST_INT
call|)
argument_list|(
name|niter
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|" iterations> %d [maximum peelings])\n"
argument_list|,
name|npeel
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|npeel
operator|=
name|niter
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* For now we have no good heuristics to decide whether loop peeling          will be effective, so disable it.  */
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not peeling loop, no evidence it will be profitable\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success.  */
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_PEEL_SIMPLE
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|times
operator|=
name|npeel
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Peel a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation:    while (cond)      body;     ==>     if (!cond) goto end;    body;    if (!cond) goto end;    body;    while (cond)      body;    end: ;    */
end_comment

begin_function
specifier|static
name|void
name|peel_loop_simple
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|sbitmap
name|wont_exit
decl_stmt|;
name|unsigned
name|npeel
init|=
name|loop
operator|->
name|lpt_decision
operator|.
name|times
decl_stmt|;
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|npeel
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|npeel
argument_list|,
name|wont_exit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Peeling loop %d times\n"
argument_list|,
name|npeel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether to unroll LOOP stupidly and how much.  */
end_comment

begin_function
specifier|static
name|void
name|decide_unroll_stupid
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|nunroll
decl_stmt|,
name|nunroll_by_av
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|UAP_UNROLL_ALL
operator|)
condition|)
block|{
comment|/* We were not asked to, just return back silently.  */
return|return;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Considering unrolling loop stupidly\n"
argument_list|)
expr_stmt|;
comment|/* nunroll = total number of copies of the original loop body in      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|ninsns
expr_stmt|;
name|nunroll_by_av
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_AVERAGE_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|av_ninsns
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
name|nunroll_by_av
condition|)
name|nunroll
operator|=
name|nunroll_by_av
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
condition|)
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
expr_stmt|;
comment|/* Skip big loops.  */
if|if
condition|(
name|nunroll
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
if|if
condition|(
operator|!
name|loop
operator|->
name|has_desc
condition|)
block|{
name|loop
operator|->
name|simple
operator|=
name|simple_loop_p
argument_list|(
name|loop
argument_list|,
operator|&
name|loop
operator|->
name|desc
argument_list|)
expr_stmt|;
name|loop
operator|->
name|has_desc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check simpleness.  */
if|if
condition|(
name|loop
operator|->
name|simple
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; The loop is simple\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do not unroll loops with branches inside -- it increases number      of mispredicts.  */
if|if
condition|(
name|loop
operator|->
name|desc
operator|.
name|n_branches
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not unrolling, contains branches\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have profile feedback, check whether the loop rolls.  */
if|if
condition|(
name|loop
operator|->
name|header
operator|->
name|count
operator|&&
name|expected_loop_iterations
argument_list|(
name|loop
argument_list|)
operator|<
literal|2
operator|*
name|nunroll
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Not unrolling loop, doesn't roll\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success.  Now force nunroll to be power of 2, as it seems that this      improves results (partially because of better alignments, partially      because of some dark magic).  */
for|for
control|(
name|i
operator|=
literal|1
init|;
literal|2
operator|*
name|i
operator|<=
name|nunroll
condition|;
name|i
operator|*=
literal|2
control|)
empty_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_UNROLL_STUPID
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|times
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unroll a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation:    while (cond)      body;     ==>     while (cond)      {        body;        if (!cond) break;        body;        if (!cond) break;        body;        if (!cond) break;        body;      }    */
end_comment

begin_function
specifier|static
name|void
name|unroll_loop_stupid
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|sbitmap
name|wont_exit
decl_stmt|;
name|unsigned
name|nunroll
init|=
name|loop
operator|->
name|lpt_decision
operator|.
name|times
decl_stmt|;
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|nunroll
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|nunroll
argument_list|,
name|wont_exit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|";; Unrolled loop %d times, %i insns\n"
argument_list|,
name|nunroll
argument_list|,
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Expand a bct instruction in a branch and an increment.    If flag_inc is set, the induction variable does not need to be    incremented.  */
end_comment

begin_function
specifier|static
name|void
name|expand_bct
parameter_list|(
name|edge
name|e
parameter_list|,
name|int
name|flag_inc
parameter_list|)
block|{
name|rtx
name|bct_insn
init|=
name|BB_END
argument_list|(
name|e
operator|->
name|src
argument_list|)
decl_stmt|;
name|rtx
name|cmp
decl_stmt|;
name|rtx
name|inc
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|rtx
name|tgt
decl_stmt|;
name|rtx
name|condition
decl_stmt|;
name|rtx
name|labelref
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|rtx
name|pattern
init|=
name|PATTERN
argument_list|(
name|bct_insn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_bct_cond
argument_list|(
name|bct_insn
argument_list|)
condition|)
return|return;
name|inc
operator|=
name|get_var_set_from_bct
argument_list|(
name|bct_insn
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|XVECEXP
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SET_DEST
argument_list|(
name|inc
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|flag_inc
condition|)
block|{
name|tgt
operator|=
name|force_operand
argument_list|(
name|XEXP
argument_list|(
name|inc
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|inc
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgt
operator|!=
name|XEXP
argument_list|(
name|inc
argument_list|,
literal|0
argument_list|)
condition|)
name|emit_move_insn
argument_list|(
name|XEXP
argument_list|(
name|inc
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tgt
argument_list|)
expr_stmt|;
block|}
name|condition
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|cmp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|labelref
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|cmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|do_compare_rtx_and_jump
argument_list|(
name|copy_rtx
argument_list|(
name|reg
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|condition
argument_list|,
literal|1
argument_list|)
argument_list|,
name|GET_CODE
argument_list|(
name|condition
argument_list|)
argument_list|,
literal|0
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|NULL_RTX
argument_list|,
name|XEXP
argument_list|(
name|labelref
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|bct_insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|bct_insn
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Check that the increment of the count register can be discarded.  */
end_comment

begin_function
name|bool
name|discard_increment
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|loop_desc
modifier|*
name|desc
init|=
operator|&
name|loop
operator|->
name|desc
decl_stmt|;
name|rtx
name|inc
decl_stmt|,
name|set_src
decl_stmt|,
name|reg
decl_stmt|;
name|rtx
name|bct_insn
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|basic_block
modifier|*
name|body
decl_stmt|;
name|bct_insn
operator|=
name|BB_END
argument_list|(
name|desc
operator|->
name|out_edge
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_bct_cond
argument_list|(
name|bct_insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|inc
operator|=
name|get_var_set_from_bct
argument_list|(
name|bct_insn
argument_list|)
expr_stmt|;
comment|/* Check that inc is of the form reg = reg - 1.  */
name|reg
operator|=
name|SET_DEST
argument_list|(
name|inc
argument_list|)
expr_stmt|;
name|set_src
operator|=
name|SET_SRC
argument_list|(
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|set_src
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|false
return|;
comment|/* We need to check that the register has no other uses beside the branch and      count.  */
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|desc
operator|->
name|var
argument_list|,
name|BB_HEAD
argument_list|(
name|body
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|body
index|[
name|i
index|]
operator|!=
name|desc
operator|->
name|out_edge
operator|->
name|src
condition|)
if|if
condition|(
name|reg_mentioned_p
argument_list|(
name|desc
operator|->
name|var
argument_list|,
name|BB_END
argument_list|(
name|body
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|reg_used_between_p
argument_list|(
name|desc
operator|->
name|var
argument_list|,
name|BB_HEAD
argument_list|(
name|body
index|[
name|i
index|]
argument_list|)
argument_list|,
name|BB_END
argument_list|(
name|body
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
block|}
comment|/* Check that the branch and count ends the latch.  */
if|if
condition|(
name|desc
operator|->
name|out_edge
operator|->
name|src
operator|!=
name|loop
operator|->
name|latch
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Latch is a dummy block generated by loop-init.  */
if|if
condition|(
name|BRANCH_EDGE
argument_list|(
name|desc
operator|->
name|out_edge
operator|->
name|src
argument_list|)
operator|->
name|dest
operator|!=
name|loop
operator|->
name|latch
condition|)
return|return
name|false
return|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|loop
operator|->
name|latch
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

end_unit

