begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Loop unrolling and peeling.    Copyright (C) 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"cfglayout.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_comment
comment|/* This pass performs loop unrolling and peeling.  We only perform these    optimizations on innermost loops (with single exception) because    the impact on performance is greatest here, and we want to avoid    unnecessary code size growth.  The gain is caused by greater sequentiality    of code, better code to optimize for further passes and in some cases    by fewer testings of exit conditions.  The main problem is code growth,    that impacts performance negatively due to effect of caches.     What we do:     -- complete peeling of once-rolling loops; this is the above mentioned       exception, as this causes loop to be cancelled completely and       does not cause code growth    -- complete peeling of loops that roll (small) constant times.    -- simple peeling of first iterations of loops that do not roll much       (according to profile feedback)    -- unrolling of loops that roll constant times; this is almost always       win, as we get rid of exit condition tests.    -- unrolling of loops that roll number of times that we can compute       in runtime; we also get rid of exit condition tests here, but there       is the extra expense for calculating the number of iterations    -- simple unrolling of remaining loops; this is performed only if we       are asked to, as the gain is questionable in this case and often       it may even slow down the code    For more detailed descriptions of each of those, see comments at    appropriate function below.     There is a lot of parameters (defined and described in params.def) that    control how much we unroll/peel.     ??? A great problem is that we don't have a good way how to determine    how many times we should unroll the loop; the experiments I have made    showed that this choice may affect performance in order of several %.    */
end_comment

begin_comment
comment|/* Information about induction variables to split.  */
end_comment

begin_struct
struct|struct
name|iv_to_split
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* The insn in that the induction variable occurs.  */
name|rtx
name|base_var
decl_stmt|;
comment|/* The variable on that the values in the further 			   iterations are based.  */
name|rtx
name|step
decl_stmt|;
comment|/* Step of the induction variable.  */
name|unsigned
name|n_loc
decl_stmt|;
name|unsigned
name|loc
index|[
literal|3
index|]
decl_stmt|;
comment|/* Location where the definition of the induction 			   variable occurs in the insn.  For example if 			   N_LOC is 2, the expression is located at 			   XEXP (XEXP (single_set, loc[0]), loc[1]).  */
block|}
struct|;
end_struct

begin_comment
comment|/* Information about accumulators to expand.  */
end_comment

begin_struct
struct|struct
name|var_to_expand
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* The insn in that the variable expansion occurs.  */
name|rtx
name|reg
decl_stmt|;
comment|/* The accumulator which is expanded.  */
name|VEC
argument_list|(
name|rtx
argument_list|,
name|heap
argument_list|)
operator|*
name|var_expansions
expr_stmt|;
comment|/* The copies of the accumulator which is expanded.  */
name|enum
name|rtx_code
name|op
decl_stmt|;
comment|/* The type of the accumulation - addition, subtraction                                        or multiplication.  */
name|int
name|expansion_count
decl_stmt|;
comment|/* Count the number of expansions generated so far.  */
name|int
name|reuse_expansion
decl_stmt|;
comment|/* The expansion we intend to reuse to expand                                       the accumulator.  If REUSE_EXPANSION is 0 reuse                                        the original accumulator.  Else use                                        var_expansions[REUSE_EXPANSION - 1].  */
block|}
struct|;
end_struct

begin_comment
comment|/* Information about optimization applied in    the unrolled loop.  */
end_comment

begin_struct
struct|struct
name|opt_info
block|{
name|htab_t
name|insns_to_split
decl_stmt|;
comment|/* A hashtable of insns to split.  */
name|htab_t
name|insns_with_var_to_expand
decl_stmt|;
comment|/* A hashtable of insns with accumulators                                       to expand.  */
name|unsigned
name|first_new_block
decl_stmt|;
comment|/* The first basic block that was                                       duplicated.  */
name|basic_block
name|loop_exit
decl_stmt|;
comment|/* The loop exit basic block.  */
name|basic_block
name|loop_preheader
decl_stmt|;
comment|/* The loop preheader basic block.  */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|decide_unrolling_and_peeling
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|peel_loops_completely
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_peel_simple
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_peel_once_rolling
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_peel_completely
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_unroll_stupid
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_unroll_constant_iterations
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|decide_unroll_runtime_iterations
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|peel_loop_simple
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|peel_loop_completely
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unroll_loop_stupid
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unroll_loop_constant_iterations
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unroll_loop_runtime_iterations
parameter_list|(
name|struct
name|loops
modifier|*
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|opt_info
modifier|*
name|analyze_insns_in_loop
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opt_info_start_duplication
parameter_list|(
name|struct
name|opt_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|apply_opt_in_copies
parameter_list|(
name|struct
name|opt_info
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|bool
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_opt_info
parameter_list|(
name|struct
name|opt_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|var_to_expand
modifier|*
name|analyze_insn_to_expand_var
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|referenced_in_one_insn_in_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|iv_to_split
modifier|*
name|analyze_iv_to_split_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_var_during_unrolling
parameter_list|(
name|struct
name|var_to_expand
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insert_var_expansion_initialization
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|combine_var_copies_in_loop_exit
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|release_var_copies
parameter_list|(
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|get_expansion
parameter_list|(
name|struct
name|var_to_expand
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Unroll and/or peel (depending on FLAGS) LOOPS.  */
end_comment

begin_function
name|void
name|unroll_and_peel_loops
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|bool
name|check
decl_stmt|;
comment|/* First perform complete loop peeling (it is almost surely a win,      and affects parameters for further decision a lot).  */
name|peel_loops_completely
argument_list|(
name|loops
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Now decide rest of unrolling and peeling.  */
name|decide_unrolling_and_peeling
argument_list|(
name|loops
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|loop
operator|=
name|loops
operator|->
name|tree_root
expr_stmt|;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
name|loop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
comment|/* Scan the loops, inner ones first.  */
while|while
condition|(
name|loop
operator|!=
name|loops
operator|->
name|tree_root
condition|)
block|{
if|if
condition|(
name|loop
operator|->
name|next
condition|)
block|{
name|next
operator|=
name|loop
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|next
operator|->
name|inner
condition|)
name|next
operator|=
name|next
operator|->
name|inner
expr_stmt|;
block|}
else|else
name|next
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
name|check
operator|=
name|true
expr_stmt|;
comment|/* And perform the appropriate transformations.  */
switch|switch
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
condition|)
block|{
case|case
name|LPT_PEEL_COMPLETELY
case|:
comment|/* Already done.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|LPT_PEEL_SIMPLE
case|:
name|peel_loop_simple
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
break|break;
case|case
name|LPT_UNROLL_CONSTANT
case|:
name|unroll_loop_constant_iterations
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
break|break;
case|case
name|LPT_UNROLL_RUNTIME
case|:
name|unroll_loop_runtime_iterations
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
break|break;
case|case
name|LPT_UNROLL_STUPID
case|:
name|unroll_loop_stupid
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
break|break;
case|case
name|LPT_NONE
case|:
name|check
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|check
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|verify_loop_structure
argument_list|(
name|loops
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|loop
operator|=
name|next
expr_stmt|;
block|}
name|iv_analysis_done
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check whether exit of the LOOP is at the end of loop body.  */
end_comment

begin_function
specifier|static
name|bool
name|loop_exit_at_end_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|struct
name|niter_desc
modifier|*
name|desc
init|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
if|if
condition|(
name|desc
operator|->
name|in_edge
operator|->
name|dest
operator|!=
name|loop
operator|->
name|latch
condition|)
return|return
name|false
return|;
comment|/* Check that the latch is empty.  */
name|FOR_BB_INSNS
argument_list|(
argument|loop->latch
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Check whether to peel LOOPS (depending on FLAGS) completely and do so.  */
end_comment

begin_function
specifier|static
name|void
name|peel_loops_completely
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* Scan the loops, the inner ones first.  */
for|for
control|(
name|i
operator|=
name|loops
operator|->
name|num
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|loop
operator|=
name|loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_NONE
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n;; *** Considering loop %d for complete peeling ***\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|loop
operator|->
name|ninsns
operator|=
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|decide_peel_once_rolling
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|==
name|LPT_NONE
condition|)
name|decide_peel_completely
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|==
name|LPT_PEEL_COMPLETELY
condition|)
block|{
name|peel_loop_completely
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|)
expr_stmt|;
name|verify_loop_structure
argument_list|(
name|loops
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* Decide whether unroll or peel LOOPS (depending on FLAGS) and how much.  */
end_comment

begin_function
specifier|static
name|void
name|decide_unrolling_and_peeling
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|loops
operator|->
name|tree_root
decl_stmt|,
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|loop
operator|->
name|inner
condition|)
name|loop
operator|=
name|loop
operator|->
name|inner
expr_stmt|;
comment|/* Scan the loops, inner ones first.  */
while|while
condition|(
name|loop
operator|!=
name|loops
operator|->
name|tree_root
condition|)
block|{
if|if
condition|(
name|loop
operator|->
name|next
condition|)
block|{
name|next
operator|=
name|loop
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|next
operator|->
name|inner
condition|)
name|next
operator|=
name|next
operator|->
name|inner
expr_stmt|;
block|}
else|else
name|next
operator|=
name|loop
operator|->
name|outer
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_NONE
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n;; *** Considering loop %d ***\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
comment|/* Do not peel cold areas.  */
if|if
condition|(
operator|!
name|maybe_hot_bb_p
argument_list|(
name|loop
operator|->
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, cold area\n"
argument_list|)
expr_stmt|;
name|loop
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Can the loop be manipulated?  */
if|if
condition|(
operator|!
name|can_duplicate_loop_p
argument_list|(
name|loop
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, cannot duplicate\n"
argument_list|)
expr_stmt|;
name|loop
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* Skip non-innermost loops.  */
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, is not innermost\n"
argument_list|)
expr_stmt|;
name|loop
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
name|loop
operator|->
name|ninsns
operator|=
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|loop
operator|->
name|av_ninsns
operator|=
name|average_num_loop_insns
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Try transformations one by one in decreasing order of 	 priority.  */
name|decide_unroll_constant_iterations
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|==
name|LPT_NONE
condition|)
name|decide_unroll_runtime_iterations
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|==
name|LPT_NONE
condition|)
name|decide_unroll_stupid
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|==
name|LPT_NONE
condition|)
name|decide_peel_simple
argument_list|(
name|loop
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|loop
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decide whether the LOOP is once rolling and suitable for complete    peeling.  */
end_comment

begin_function
specifier|static
name|void
name|decide_peel_once_rolling
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|niter_desc
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n;; Considering peeling once rolling loop\n"
argument_list|)
expr_stmt|;
comment|/* Is the loop small enough?  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_ONCE_PEELED_INSNS
argument_list|)
operator|<
name|loop
operator|->
name|ninsns
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
name|desc
operator|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Check number of iterations.  */
if|if
condition|(
operator|!
name|desc
operator|->
name|simple_p
operator|||
name|desc
operator|->
name|assumptions
operator|||
name|desc
operator|->
name|infinite
operator|||
operator|!
name|desc
operator|->
name|const_iter
operator|||
name|desc
operator|->
name|niter
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Unable to prove that the loop rolls exactly once\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success.  */
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Decided to peel exactly once rolling loop\n"
argument_list|)
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_PEEL_COMPLETELY
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether the LOOP is suitable for complete peeling.  */
end_comment

begin_function
specifier|static
name|void
name|decide_peel_completely
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|unsigned
name|npeel
decl_stmt|;
name|struct
name|niter_desc
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n;; Considering peeling completely\n"
argument_list|)
expr_stmt|;
comment|/* Skip non-innermost loops.  */
if|if
condition|(
name|loop
operator|->
name|inner
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, is not innermost\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do not peel cold areas.  */
if|if
condition|(
operator|!
name|maybe_hot_bb_p
argument_list|(
name|loop
operator|->
name|header
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, cold area\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Can the loop be manipulated?  */
if|if
condition|(
operator|!
name|can_duplicate_loop_p
argument_list|(
name|loop
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, cannot duplicate\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* npeel = number of iterations to peel.  */
name|npeel
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_COMPLETELY_PEELED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|ninsns
expr_stmt|;
if|if
condition|(
name|npeel
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_COMPLETELY_PEEL_TIMES
argument_list|)
condition|)
name|npeel
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_COMPLETELY_PEEL_TIMES
argument_list|)
expr_stmt|;
comment|/* Is the loop small enough?  */
if|if
condition|(
operator|!
name|npeel
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
name|desc
operator|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Check number of iterations.  */
if|if
condition|(
operator|!
name|desc
operator|->
name|simple_p
operator|||
name|desc
operator|->
name|assumptions
operator|||
operator|!
name|desc
operator|->
name|const_iter
operator|||
name|desc
operator|->
name|infinite
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Unable to prove that the loop iterates constant times\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|desc
operator|->
name|niter
operator|>
name|npeel
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not peeling loop completely, rolls too much ("
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
name|desc
operator|->
name|niter
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" iterations> %d [maximum peelings])\n"
argument_list|,
name|npeel
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* Success.  */
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Decided to peel loop completely\n"
argument_list|)
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_PEEL_COMPLETELY
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Peel all iterations of LOOP, remove exit edges and cancel the loop    completely.  The transformation done:     for (i = 0; i< 4; i++)      body;     ==>     i = 0;    body; i++;    body; i++;    body; i++;    body; i++;    */
end_comment

begin_function
specifier|static
name|void
name|peel_loop_completely
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|sbitmap
name|wont_exit
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|npeel
decl_stmt|;
name|unsigned
name|n_remove_edges
decl_stmt|,
name|i
decl_stmt|;
name|edge
modifier|*
name|remove_edges
decl_stmt|,
name|ein
decl_stmt|;
name|struct
name|niter_desc
modifier|*
name|desc
init|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|opt_info
modifier|*
name|opt_info
init|=
name|NULL
decl_stmt|;
name|npeel
operator|=
name|desc
operator|->
name|niter
expr_stmt|;
if|if
condition|(
name|npeel
condition|)
block|{
name|bool
name|ok
decl_stmt|;
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|npeel
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|noloop_assumptions
condition|)
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|remove_edges
operator|=
name|XCNEWVEC
argument_list|(
name|edge
argument_list|,
name|npeel
argument_list|)
expr_stmt|;
name|n_remove_edges
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_split_ivs_in_unroller
condition|)
name|opt_info
operator|=
name|analyze_insns_in_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|opt_info_start_duplication
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
name|ok
operator|=
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|npeel
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
operator||
name|DLTHE_FLAG_COMPLETTE_PEEL
operator||
operator|(
name|opt_info
condition|?
name|DLTHE_RECORD_COPY_NUMBER
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_info
condition|)
block|{
name|apply_opt_in_copies
argument_list|(
name|opt_info
argument_list|,
name|npeel
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|free_opt_info
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the exit edges.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_remove_edges
condition|;
name|i
operator|++
control|)
name|remove_path
argument_list|(
name|loops
argument_list|,
name|remove_edges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remove_edges
argument_list|)
expr_stmt|;
block|}
name|ein
operator|=
name|desc
operator|->
name|in_edge
expr_stmt|;
name|free_simple_loop_desc
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Now remove the unreachable part of the last iteration and cancel      the loop.  */
name|remove_path
argument_list|(
name|loops
argument_list|,
name|ein
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Peeled loop completely, %d times\n"
argument_list|,
operator|(
name|int
operator|)
name|npeel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether to unroll LOOP iterating constant number of times    and how much.  */
end_comment

begin_function
specifier|static
name|void
name|decide_unroll_constant_iterations
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|nunroll
decl_stmt|,
name|nunroll_by_av
decl_stmt|,
name|best_copies
decl_stmt|,
name|best_unroll
init|=
literal|0
decl_stmt|,
name|n_copies
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|niter_desc
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|UAP_UNROLL
operator|)
condition|)
block|{
comment|/* We were not asked to, just return back silently.  */
return|return;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n;; Considering unrolling loop with constant "
literal|"number of iterations\n"
argument_list|)
expr_stmt|;
comment|/* nunroll = total number of copies of the original loop body in      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|ninsns
expr_stmt|;
name|nunroll_by_av
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_AVERAGE_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|av_ninsns
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
name|nunroll_by_av
condition|)
name|nunroll
operator|=
name|nunroll_by_av
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
condition|)
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
expr_stmt|;
comment|/* Skip big loops.  */
if|if
condition|(
name|nunroll
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
name|desc
operator|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Check number of iterations.  */
if|if
condition|(
operator|!
name|desc
operator|->
name|simple_p
operator|||
operator|!
name|desc
operator|->
name|const_iter
operator|||
name|desc
operator|->
name|assumptions
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Unable to prove that the loop iterates constant times\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check whether the loop rolls enough to consider.  */
if|if
condition|(
name|desc
operator|->
name|niter
operator|<
literal|2
operator|*
name|nunroll
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unrolling loop, doesn't roll\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success; now compute number of iterations to unroll.  We alter      nunroll so that as few as possible copies of loop body are      necessary, while still not decreasing the number of unrollings      too much (at most by 1).  */
name|best_copies
operator|=
literal|2
operator|*
name|nunroll
operator|+
literal|10
expr_stmt|;
name|i
operator|=
literal|2
operator|*
name|nunroll
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|-
literal|1
operator|>=
name|desc
operator|->
name|niter
condition|)
name|i
operator|=
name|desc
operator|->
name|niter
operator|-
literal|2
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
name|nunroll
operator|-
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|unsigned
name|exit_mod
init|=
name|desc
operator|->
name|niter
operator|%
operator|(
name|i
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|loop_exit_at_end_p
argument_list|(
name|loop
argument_list|)
condition|)
name|n_copies
operator|=
name|exit_mod
operator|+
name|i
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|exit_mod
operator|!=
operator|(
name|unsigned
operator|)
name|i
operator|||
name|desc
operator|->
name|noloop_assumptions
operator|!=
name|NULL_RTX
condition|)
name|n_copies
operator|=
name|exit_mod
operator|+
name|i
operator|+
literal|2
expr_stmt|;
else|else
name|n_copies
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n_copies
operator|<
name|best_copies
condition|)
block|{
name|best_copies
operator|=
name|n_copies
expr_stmt|;
name|best_unroll
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; max_unroll %d (%d copies, initial %d).\n"
argument_list|,
name|best_unroll
operator|+
literal|1
argument_list|,
name|best_copies
argument_list|,
name|nunroll
argument_list|)
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_UNROLL_CONSTANT
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|times
operator|=
name|best_unroll
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Decided to unroll the constant times rolling loop, %d times.\n"
argument_list|,
name|loop
operator|->
name|lpt_decision
operator|.
name|times
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unroll LOOP with constant number of iterations LOOP->LPT_DECISION.TIMES + 1    times.  The transformation does this:     for (i = 0; i< 102; i++)      body;     ==>     i = 0;    body; i++;    body; i++;    while (i< 102)      {        body; i++;        body; i++;        body; i++;        body; i++;      }   */
end_comment

begin_function
specifier|static
name|void
name|unroll_loop_constant_iterations
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|niter
decl_stmt|;
name|unsigned
name|exit_mod
decl_stmt|;
name|sbitmap
name|wont_exit
decl_stmt|;
name|unsigned
name|n_remove_edges
decl_stmt|,
name|i
decl_stmt|;
name|edge
modifier|*
name|remove_edges
decl_stmt|;
name|unsigned
name|max_unroll
init|=
name|loop
operator|->
name|lpt_decision
operator|.
name|times
decl_stmt|;
name|struct
name|niter_desc
modifier|*
name|desc
init|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|bool
name|exit_at_end
init|=
name|loop_exit_at_end_p
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|opt_info
modifier|*
name|opt_info
init|=
name|NULL
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|niter
operator|=
name|desc
operator|->
name|niter
expr_stmt|;
comment|/* Should not get here (such loop should be peeled instead).  */
name|gcc_assert
argument_list|(
name|niter
operator|>
name|max_unroll
operator|+
literal|1
argument_list|)
expr_stmt|;
name|exit_mod
operator|=
name|niter
operator|%
operator|(
name|max_unroll
operator|+
literal|1
operator|)
expr_stmt|;
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|max_unroll
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_ones
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|remove_edges
operator|=
name|XCNEWVEC
argument_list|(
name|edge
argument_list|,
name|max_unroll
operator|+
name|exit_mod
operator|+
literal|1
argument_list|)
expr_stmt|;
name|n_remove_edges
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flag_split_ivs_in_unroller
operator|||
name|flag_variable_expansion_in_unroller
condition|)
name|opt_info
operator|=
name|analyze_insns_in_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exit_at_end
condition|)
block|{
comment|/* The exit is not at the end of the loop; leave exit test 	 in the first copy, so that the loops that start with test 	 of exit condition have continuous body after unrolling.  */
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Condition on beginning of loop.\n"
argument_list|)
expr_stmt|;
comment|/* Peel exit_mod iterations.  */
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|noloop_assumptions
condition|)
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_mod
condition|)
block|{
name|opt_info_start_duplication
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
name|ok
operator|=
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|exit_mod
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
operator||
operator|(
name|opt_info
operator|&&
name|exit_mod
operator|>
literal|1
condition|?
name|DLTHE_RECORD_COPY_NUMBER
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_info
operator|&&
name|exit_mod
operator|>
literal|1
condition|)
name|apply_opt_in_copies
argument_list|(
name|opt_info
argument_list|,
name|exit_mod
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|desc
operator|->
name|noloop_assumptions
operator|=
name|NULL_RTX
expr_stmt|;
name|desc
operator|->
name|niter
operator|-=
name|exit_mod
expr_stmt|;
name|desc
operator|->
name|niter_max
operator|-=
name|exit_mod
expr_stmt|;
block|}
name|SET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave exit test in last copy, for the same reason as above if 	 the loop tests the condition at the end of loop body.  */
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Condition on end of loop.\n"
argument_list|)
expr_stmt|;
comment|/* We know that niter>= max_unroll + 2; so we do not need to care of 	 case when we would exit before reaching the loop.  So just peel 	 exit_mod + 1 iterations.  */
if|if
condition|(
name|exit_mod
operator|!=
name|max_unroll
operator|||
name|desc
operator|->
name|noloop_assumptions
condition|)
block|{
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|noloop_assumptions
condition|)
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|opt_info_start_duplication
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
name|ok
operator|=
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|exit_mod
operator|+
literal|1
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
operator||
operator|(
name|opt_info
operator|&&
name|exit_mod
operator|>
literal|0
condition|?
name|DLTHE_RECORD_COPY_NUMBER
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_info
operator|&&
name|exit_mod
operator|>
literal|0
condition|)
name|apply_opt_in_copies
argument_list|(
name|opt_info
argument_list|,
name|exit_mod
operator|+
literal|1
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|desc
operator|->
name|niter
operator|-=
name|exit_mod
operator|+
literal|1
expr_stmt|;
name|desc
operator|->
name|niter_max
operator|-=
name|exit_mod
operator|+
literal|1
expr_stmt|;
name|desc
operator|->
name|noloop_assumptions
operator|=
name|NULL_RTX
expr_stmt|;
name|SET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
name|max_unroll
argument_list|)
expr_stmt|;
block|}
comment|/* Now unroll the loop.  */
name|opt_info_start_duplication
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
name|ok
operator|=
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|max_unroll
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
operator||
operator|(
name|opt_info
condition|?
name|DLTHE_RECORD_COPY_NUMBER
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_info
condition|)
block|{
name|apply_opt_in_copies
argument_list|(
name|opt_info
argument_list|,
name|max_unroll
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|free_opt_info
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_at_end
condition|)
block|{
name|basic_block
name|exit_block
init|=
name|get_bb_copy
argument_list|(
name|desc
operator|->
name|in_edge
operator|->
name|src
argument_list|)
decl_stmt|;
comment|/* Find a new in and out edge; they are in the last copy we have made.  */
if|if
condition|(
name|EDGE_SUCC
argument_list|(
name|exit_block
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
operator|==
name|desc
operator|->
name|out_edge
operator|->
name|dest
condition|)
block|{
name|desc
operator|->
name|out_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|exit_block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|desc
operator|->
name|in_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|exit_block
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|desc
operator|->
name|out_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|exit_block
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|desc
operator|->
name|in_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|exit_block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|desc
operator|->
name|niter
operator|/=
name|max_unroll
operator|+
literal|1
expr_stmt|;
name|desc
operator|->
name|niter_max
operator|/=
name|max_unroll
operator|+
literal|1
expr_stmt|;
name|desc
operator|->
name|niter_expr
operator|=
name|GEN_INT
argument_list|(
name|desc
operator|->
name|niter
argument_list|)
expr_stmt|;
comment|/* Remove the edges.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_remove_edges
condition|;
name|i
operator|++
control|)
name|remove_path
argument_list|(
name|loops
argument_list|,
name|remove_edges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remove_edges
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Unrolled loop %d times, constant # of iterations %i insns\n"
argument_list|,
name|max_unroll
argument_list|,
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether to unroll LOOP iterating runtime computable number of times    and how much.  */
end_comment

begin_function
specifier|static
name|void
name|decide_unroll_runtime_iterations
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|nunroll
decl_stmt|,
name|nunroll_by_av
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|niter_desc
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|UAP_UNROLL
operator|)
condition|)
block|{
comment|/* We were not asked to, just return back silently.  */
return|return;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n;; Considering unrolling loop with runtime "
literal|"computable number of iterations\n"
argument_list|)
expr_stmt|;
comment|/* nunroll = total number of copies of the original loop body in      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|ninsns
expr_stmt|;
name|nunroll_by_av
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_AVERAGE_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|av_ninsns
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
name|nunroll_by_av
condition|)
name|nunroll
operator|=
name|nunroll_by_av
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
condition|)
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
expr_stmt|;
comment|/* Skip big loops.  */
if|if
condition|(
name|nunroll
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
name|desc
operator|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Check simpleness.  */
if|if
condition|(
operator|!
name|desc
operator|->
name|simple_p
operator|||
name|desc
operator|->
name|assumptions
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Unable to prove that the number of iterations "
literal|"can be counted in runtime\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|desc
operator|->
name|const_iter
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Loop iterates constant times\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have profile feedback, check whether the loop rolls.  */
if|if
condition|(
name|loop
operator|->
name|header
operator|->
name|count
operator|&&
name|expected_loop_iterations
argument_list|(
name|loop
argument_list|)
operator|<
literal|2
operator|*
name|nunroll
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unrolling loop, doesn't roll\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success; now force nunroll to be power of 2, as we are unable to      cope with overflows in computation of number of iterations.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
literal|2
operator|*
name|i
operator|<=
name|nunroll
condition|;
name|i
operator|*=
literal|2
control|)
continue|continue;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_UNROLL_RUNTIME
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|times
operator|=
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Decided to unroll the runtime computable "
literal|"times rolling loop, %d times.\n"
argument_list|,
name|loop
operator|->
name|lpt_decision
operator|.
name|times
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unroll LOOP for that we are able to count number of iterations in runtime    LOOP->LPT_DECISION.TIMES + 1 times.  The transformation does this (with some    extra care for case n< 0):     for (i = 0; i< n; i++)      body;     ==>     i = 0;    mod = n % 4;     switch (mod)      {        case 3:          body; i++;        case 2:          body; i++;        case 1:          body; i++;        case 0: ;      }     while (i< n)      {        body; i++;        body; i++;        body; i++;        body; i++;      }    */
end_comment

begin_function
specifier|static
name|void
name|unroll_loop_runtime_iterations
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|rtx
name|old_niter
decl_stmt|,
name|niter
decl_stmt|,
name|init_code
decl_stmt|,
name|branch_code
decl_stmt|,
name|tmp
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|,
name|p
decl_stmt|;
name|basic_block
name|preheader
decl_stmt|,
modifier|*
name|body
decl_stmt|,
modifier|*
name|dom_bbs
decl_stmt|,
name|swtch
decl_stmt|,
name|ezc_swtch
decl_stmt|;
name|unsigned
name|n_dom_bbs
decl_stmt|;
name|sbitmap
name|wont_exit
decl_stmt|;
name|int
name|may_exit_copy
decl_stmt|;
name|unsigned
name|n_peel
decl_stmt|,
name|n_remove_edges
decl_stmt|;
name|edge
modifier|*
name|remove_edges
decl_stmt|,
name|e
decl_stmt|;
name|bool
name|extra_zero_check
decl_stmt|,
name|last_may_exit
decl_stmt|;
name|unsigned
name|max_unroll
init|=
name|loop
operator|->
name|lpt_decision
operator|.
name|times
decl_stmt|;
name|struct
name|niter_desc
modifier|*
name|desc
init|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|bool
name|exit_at_end
init|=
name|loop_exit_at_end_p
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|opt_info
modifier|*
name|opt_info
init|=
name|NULL
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|flag_split_ivs_in_unroller
operator|||
name|flag_variable_expansion_in_unroller
condition|)
name|opt_info
operator|=
name|analyze_insns_in_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Remember blocks whose dominators will have to be updated.  */
name|dom_bbs
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|n_dom_bbs
operator|=
literal|0
expr_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|nldom
decl_stmt|;
name|basic_block
modifier|*
name|ldom
decl_stmt|;
name|nldom
operator|=
name|get_dominated_by
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|body
index|[
name|i
index|]
argument_list|,
operator|&
name|ldom
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nldom
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|ldom
index|[
name|j
index|]
argument_list|)
condition|)
name|dom_bbs
index|[
name|n_dom_bbs
operator|++
index|]
operator|=
name|ldom
index|[
name|j
index|]
expr_stmt|;
name|free
argument_list|(
name|ldom
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exit_at_end
condition|)
block|{
comment|/* Leave exit in first copy (for explanation why see comment in 	 unroll_loop_constant_iterations).  */
name|may_exit_copy
operator|=
literal|0
expr_stmt|;
name|n_peel
operator|=
name|max_unroll
operator|-
literal|1
expr_stmt|;
name|extra_zero_check
operator|=
name|true
expr_stmt|;
name|last_may_exit
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
comment|/* Leave exit in last copy (for explanation why see comment in 	 unroll_loop_constant_iterations).  */
name|may_exit_copy
operator|=
name|max_unroll
expr_stmt|;
name|n_peel
operator|=
name|max_unroll
expr_stmt|;
name|extra_zero_check
operator|=
name|false
expr_stmt|;
name|last_may_exit
operator|=
name|true
expr_stmt|;
block|}
comment|/* Get expression for number of iterations.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|old_niter
operator|=
name|niter
operator|=
name|gen_reg_rtx
argument_list|(
name|desc
operator|->
name|mode
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|force_operand
argument_list|(
name|copy_rtx
argument_list|(
name|desc
operator|->
name|niter_expr
argument_list|)
argument_list|,
name|niter
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|niter
condition|)
name|emit_move_insn
argument_list|(
name|niter
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Count modulo by ANDing it with max_unroll; we use the fact that      the number of unrollings is a power of two, and thus this is correct      even if there is overflow in the computation.  */
name|niter
operator|=
name|expand_simple_binop
argument_list|(
name|desc
operator|->
name|mode
argument_list|,
name|AND
argument_list|,
name|niter
argument_list|,
name|GEN_INT
argument_list|(
name|max_unroll
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|init_code
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* Precondition the loop.  */
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|init_code
argument_list|)
expr_stmt|;
name|remove_edges
operator|=
name|XCNEWVEC
argument_list|(
name|edge
argument_list|,
name|max_unroll
operator|+
name|n_peel
operator|+
literal|1
argument_list|)
expr_stmt|;
name|n_remove_edges
operator|=
literal|0
expr_stmt|;
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|max_unroll
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Peel the first copy of loop body (almost always we must leave exit test      here; the only exception is when we have extra zero check and the number      of iterations is reliable.  Also record the place of (possible) extra      zero check.  */
name|sbitmap_zero
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_zero_check
operator|&&
operator|!
name|desc
operator|->
name|noloop_assumptions
condition|)
name|SET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ezc_swtch
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
expr_stmt|;
name|ok
operator|=
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
literal|1
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
comment|/* Record the place where switch will be built for preconditioning.  */
name|swtch
operator|=
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_peel
condition|;
name|i
operator|++
control|)
block|{
comment|/* Peel the copy.  */
name|sbitmap_zero
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|n_peel
operator|-
literal|1
operator|||
operator|!
name|last_may_exit
condition|)
name|SET_BIT
argument_list|(
name|wont_exit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ok
operator|=
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
literal|1
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
comment|/* Create item for switch.  */
name|j
operator|=
name|n_peel
operator|-
name|i
operator|-
operator|(
name|extra_zero_check
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|p
operator|=
name|REG_BR_PROB_BASE
operator|/
operator|(
name|i
operator|+
literal|2
operator|)
expr_stmt|;
name|preheader
operator|=
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|branch_code
operator|=
name|compare_and_jump_seq
argument_list|(
name|copy_rtx
argument_list|(
name|niter
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|j
argument_list|)
argument_list|,
name|EQ
argument_list|,
name|block_label
argument_list|(
name|preheader
argument_list|)
argument_list|,
name|p
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|swtch
operator|=
name|loop_split_edge_with
argument_list|(
name|single_pred_edge
argument_list|(
name|swtch
argument_list|)
argument_list|,
name|branch_code
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|preheader
argument_list|,
name|swtch
argument_list|)
expr_stmt|;
name|single_pred_edge
argument_list|(
name|swtch
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|p
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|swtch
argument_list|,
name|preheader
argument_list|,
name|single_succ_edge
argument_list|(
name|swtch
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|extra_zero_check
condition|)
block|{
comment|/* Add branch for zero iterations.  */
name|p
operator|=
name|REG_BR_PROB_BASE
operator|/
operator|(
name|max_unroll
operator|+
literal|1
operator|)
expr_stmt|;
name|swtch
operator|=
name|ezc_swtch
expr_stmt|;
name|preheader
operator|=
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|branch_code
operator|=
name|compare_and_jump_seq
argument_list|(
name|copy_rtx
argument_list|(
name|niter
argument_list|)
argument_list|,
name|const0_rtx
argument_list|,
name|EQ
argument_list|,
name|block_label
argument_list|(
name|preheader
argument_list|)
argument_list|,
name|p
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|swtch
operator|=
name|loop_split_edge_with
argument_list|(
name|single_succ_edge
argument_list|(
name|swtch
argument_list|)
argument_list|,
name|branch_code
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|preheader
argument_list|,
name|swtch
argument_list|)
expr_stmt|;
name|single_succ_edge
argument_list|(
name|swtch
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
operator|-
name|p
expr_stmt|;
name|e
operator|=
name|make_edge
argument_list|(
name|swtch
argument_list|,
name|preheader
argument_list|,
name|single_succ_edge
argument_list|(
name|swtch
argument_list|)
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
argument_list|)
expr_stmt|;
name|e
operator|->
name|probability
operator|=
name|p
expr_stmt|;
block|}
comment|/* Recount dominators for outer blocks.  */
name|iterate_fix_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|dom_bbs
argument_list|,
name|n_dom_bbs
argument_list|)
expr_stmt|;
comment|/* And unroll loop.  */
name|sbitmap_ones
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|wont_exit
argument_list|,
name|may_exit_copy
argument_list|)
expr_stmt|;
name|opt_info_start_duplication
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
name|ok
operator|=
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|max_unroll
argument_list|,
name|wont_exit
argument_list|,
name|desc
operator|->
name|out_edge
argument_list|,
name|remove_edges
argument_list|,
operator|&
name|n_remove_edges
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
operator||
operator|(
name|opt_info
condition|?
name|DLTHE_RECORD_COPY_NUMBER
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_info
condition|)
block|{
name|apply_opt_in_copies
argument_list|(
name|opt_info
argument_list|,
name|max_unroll
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|free_opt_info
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_at_end
condition|)
block|{
name|basic_block
name|exit_block
init|=
name|get_bb_copy
argument_list|(
name|desc
operator|->
name|in_edge
operator|->
name|src
argument_list|)
decl_stmt|;
comment|/* Find a new in and out edge; they are in the last copy we have 	 made.  */
if|if
condition|(
name|EDGE_SUCC
argument_list|(
name|exit_block
argument_list|,
literal|0
argument_list|)
operator|->
name|dest
operator|==
name|desc
operator|->
name|out_edge
operator|->
name|dest
condition|)
block|{
name|desc
operator|->
name|out_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|exit_block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|desc
operator|->
name|in_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|exit_block
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|desc
operator|->
name|out_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|exit_block
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|desc
operator|->
name|in_edge
operator|=
name|EDGE_SUCC
argument_list|(
name|exit_block
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove the edges.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_remove_edges
condition|;
name|i
operator|++
control|)
name|remove_path
argument_list|(
name|loops
argument_list|,
name|remove_edges
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remove_edges
argument_list|)
expr_stmt|;
comment|/* We must be careful when updating the number of iterations due to      preconditioning and the fact that the value must be valid at entry      of the loop.  After passing through the above code, we see that      the correct new number of iterations is this:  */
name|gcc_assert
argument_list|(
operator|!
name|desc
operator|->
name|const_iter
argument_list|)
expr_stmt|;
name|desc
operator|->
name|niter_expr
operator|=
name|simplify_gen_binary
argument_list|(
name|UDIV
argument_list|,
name|desc
operator|->
name|mode
argument_list|,
name|old_niter
argument_list|,
name|GEN_INT
argument_list|(
name|max_unroll
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|->
name|niter_max
operator|/=
name|max_unroll
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|exit_at_end
condition|)
block|{
name|desc
operator|->
name|niter_expr
operator|=
name|simplify_gen_binary
argument_list|(
name|MINUS
argument_list|,
name|desc
operator|->
name|mode
argument_list|,
name|desc
operator|->
name|niter_expr
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|desc
operator|->
name|noloop_assumptions
operator|=
name|NULL_RTX
expr_stmt|;
name|desc
operator|->
name|niter_max
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Unrolled loop %d times, counting # of iterations "
literal|"in runtime, %i insns\n"
argument_list|,
name|max_unroll
argument_list|,
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_bbs
condition|)
name|free
argument_list|(
name|dom_bbs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether to simply peel LOOP and how much.  */
end_comment

begin_function
specifier|static
name|void
name|decide_peel_simple
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|npeel
decl_stmt|;
name|struct
name|niter_desc
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|UAP_PEEL
operator|)
condition|)
block|{
comment|/* We were not asked to, just return back silently.  */
return|return;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n;; Considering simply peeling loop\n"
argument_list|)
expr_stmt|;
comment|/* npeel = number of iterations to peel.  */
name|npeel
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_PEELED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|ninsns
expr_stmt|;
if|if
condition|(
name|npeel
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_PEEL_TIMES
argument_list|)
condition|)
name|npeel
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_PEEL_TIMES
argument_list|)
expr_stmt|;
comment|/* Skip big loops.  */
if|if
condition|(
operator|!
name|npeel
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
name|desc
operator|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Check number of iterations.  */
if|if
condition|(
name|desc
operator|->
name|simple_p
operator|&&
operator|!
name|desc
operator|->
name|assumptions
operator|&&
name|desc
operator|->
name|const_iter
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Loop iterates constant times\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do not simply peel loops with branches inside -- it increases number      of mispredicts.  */
if|if
condition|(
name|num_loop_branches
argument_list|(
name|loop
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not peeling, contains branches\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|loop
operator|->
name|header
operator|->
name|count
condition|)
block|{
name|unsigned
name|niter
init|=
name|expected_loop_iterations
argument_list|(
name|loop
argument_list|)
decl_stmt|;
if|if
condition|(
name|niter
operator|+
literal|1
operator|>
name|npeel
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not peeling loop, rolls too much ("
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
call|(
name|HOST_WIDEST_INT
call|)
argument_list|(
name|niter
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|" iterations> %d [maximum peelings])\n"
argument_list|,
name|npeel
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|npeel
operator|=
name|niter
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* For now we have no good heuristics to decide whether loop peeling          will be effective, so disable it.  */
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not peeling loop, no evidence it will be profitable\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success.  */
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_PEEL_SIMPLE
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|times
operator|=
name|npeel
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Decided to simply peel the loop, %d times.\n"
argument_list|,
name|loop
operator|->
name|lpt_decision
operator|.
name|times
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Peel a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation:    while (cond)      body;     ==>     if (!cond) goto end;    body;    if (!cond) goto end;    body;    while (cond)      body;    end: ;    */
end_comment

begin_function
specifier|static
name|void
name|peel_loop_simple
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|sbitmap
name|wont_exit
decl_stmt|;
name|unsigned
name|npeel
init|=
name|loop
operator|->
name|lpt_decision
operator|.
name|times
decl_stmt|;
name|struct
name|niter_desc
modifier|*
name|desc
init|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|opt_info
modifier|*
name|opt_info
init|=
name|NULL
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|flag_split_ivs_in_unroller
operator|&&
name|npeel
operator|>
literal|1
condition|)
name|opt_info
operator|=
name|analyze_insns_in_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|npeel
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|opt_info_start_duplication
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
name|ok
operator|=
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|npeel
argument_list|,
name|wont_exit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
operator||
operator|(
name|opt_info
condition|?
name|DLTHE_RECORD_COPY_NUMBER
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_info
condition|)
block|{
name|apply_opt_in_copies
argument_list|(
name|opt_info
argument_list|,
name|npeel
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|free_opt_info
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|->
name|simple_p
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|const_iter
condition|)
block|{
name|desc
operator|->
name|niter
operator|-=
name|npeel
expr_stmt|;
name|desc
operator|->
name|niter_expr
operator|=
name|GEN_INT
argument_list|(
name|desc
operator|->
name|niter
argument_list|)
expr_stmt|;
name|desc
operator|->
name|noloop_assumptions
operator|=
name|NULL_RTX
expr_stmt|;
block|}
else|else
block|{
comment|/* We cannot just update niter_expr, as its value might be clobbered 	     inside loop.  We could handle this by counting the number into 	     temporary just like we do in runtime unrolling, but it does not 	     seem worthwhile.  */
name|free_simple_loop_desc
argument_list|(
name|loop
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Peeling loop %d times\n"
argument_list|,
name|npeel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decide whether to unroll LOOP stupidly and how much.  */
end_comment

begin_function
specifier|static
name|void
name|decide_unroll_stupid
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|nunroll
decl_stmt|,
name|nunroll_by_av
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|niter_desc
modifier|*
name|desc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|UAP_UNROLL_ALL
operator|)
condition|)
block|{
comment|/* We were not asked to, just return back silently.  */
return|return;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n;; Considering unrolling loop stupidly\n"
argument_list|)
expr_stmt|;
comment|/* nunroll = total number of copies of the original loop body in      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|ninsns
expr_stmt|;
name|nunroll_by_av
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_AVERAGE_UNROLLED_INSNS
argument_list|)
operator|/
name|loop
operator|->
name|av_ninsns
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
name|nunroll_by_av
condition|)
name|nunroll
operator|=
name|nunroll_by_av
expr_stmt|;
if|if
condition|(
name|nunroll
operator|>
operator|(
name|unsigned
operator|)
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
condition|)
name|nunroll
operator|=
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_UNROLL_TIMES
argument_list|)
expr_stmt|;
comment|/* Skip big loops.  */
if|if
condition|(
name|nunroll
operator|<=
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not considering loop, is too big\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check for simple loops.  */
name|desc
operator|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Check simpleness.  */
if|if
condition|(
name|desc
operator|->
name|simple_p
operator|&&
operator|!
name|desc
operator|->
name|assumptions
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; The loop is simple\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Do not unroll loops with branches inside -- it increases number      of mispredicts.  */
if|if
condition|(
name|num_loop_branches
argument_list|(
name|loop
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unrolling, contains branches\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have profile feedback, check whether the loop rolls.  */
if|if
condition|(
name|loop
operator|->
name|header
operator|->
name|count
operator|&&
name|expected_loop_iterations
argument_list|(
name|loop
argument_list|)
operator|<
literal|2
operator|*
name|nunroll
condition|)
block|{
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Not unrolling loop, doesn't roll\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Success.  Now force nunroll to be power of 2, as it seems that this      improves results (partially because of better alignments, partially      because of some dark magic).  */
for|for
control|(
name|i
operator|=
literal|1
init|;
literal|2
operator|*
name|i
operator|<=
name|nunroll
condition|;
name|i
operator|*=
literal|2
control|)
continue|continue;
name|loop
operator|->
name|lpt_decision
operator|.
name|decision
operator|=
name|LPT_UNROLL_STUPID
expr_stmt|;
name|loop
operator|->
name|lpt_decision
operator|.
name|times
operator|=
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Decided to unroll the loop stupidly, %d times.\n"
argument_list|,
name|loop
operator|->
name|lpt_decision
operator|.
name|times
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unroll a LOOP LOOP->LPT_DECISION.TIMES times.  The transformation:    while (cond)      body;     ==>     while (cond)      {        body;        if (!cond) break;        body;        if (!cond) break;        body;        if (!cond) break;        body;      }    */
end_comment

begin_function
specifier|static
name|void
name|unroll_loop_stupid
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|sbitmap
name|wont_exit
decl_stmt|;
name|unsigned
name|nunroll
init|=
name|loop
operator|->
name|lpt_decision
operator|.
name|times
decl_stmt|;
name|struct
name|niter_desc
modifier|*
name|desc
init|=
name|get_simple_loop_desc
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|struct
name|opt_info
modifier|*
name|opt_info
init|=
name|NULL
decl_stmt|;
name|bool
name|ok
decl_stmt|;
if|if
condition|(
name|flag_split_ivs_in_unroller
operator|||
name|flag_variable_expansion_in_unroller
condition|)
name|opt_info
operator|=
name|analyze_insns_in_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|wont_exit
operator|=
name|sbitmap_alloc
argument_list|(
name|nunroll
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
name|opt_info_start_duplication
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
name|ok
operator|=
name|duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|loops
argument_list|,
name|nunroll
argument_list|,
name|wont_exit
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DLTHE_FLAG_UPDATE_FREQ
operator||
operator|(
name|opt_info
condition|?
name|DLTHE_RECORD_COPY_NUMBER
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_info
condition|)
block|{
name|apply_opt_in_copies
argument_list|(
name|opt_info
argument_list|,
name|nunroll
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|free_opt_info
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|wont_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|simple_p
condition|)
block|{
comment|/* We indeed may get here provided that there are nontrivial assumptions 	 for a loop to be really simple.  We could update the counts, but the 	 problem is that we are unable to decide which exit will be taken 	 (not really true in case the number of iterations is constant, 	 but noone will do anything with this information, so we do not 	 worry about it).  */
name|desc
operator|->
name|simple_p
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|";; Unrolled loop %d times, %i insns\n"
argument_list|,
name|nunroll
argument_list|,
name|num_loop_insns
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A hash function for information about insns to split.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|si_info_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|ivts
parameter_list|)
block|{
return|return
operator|(
name|hashval_t
operator|)
name|INSN_UID
argument_list|(
operator|(
operator|(
expr|struct
name|iv_to_split
operator|*
operator|)
name|ivts
operator|)
operator|->
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* An equality functions for information about insns to split.  */
end_comment

begin_function
specifier|static
name|int
name|si_info_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|ivts1
parameter_list|,
specifier|const
name|void
modifier|*
name|ivts2
parameter_list|)
block|{
specifier|const
name|struct
name|iv_to_split
modifier|*
name|i1
init|=
name|ivts1
decl_stmt|;
specifier|const
name|struct
name|iv_to_split
modifier|*
name|i2
init|=
name|ivts2
decl_stmt|;
return|return
name|i1
operator|->
name|insn
operator|==
name|i2
operator|->
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Return a hash for VES, which is really a "var_to_expand *".  */
end_comment

begin_function
specifier|static
name|hashval_t
name|ve_info_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|ves
parameter_list|)
block|{
return|return
operator|(
name|hashval_t
operator|)
name|INSN_UID
argument_list|(
operator|(
operator|(
expr|struct
name|var_to_expand
operator|*
operator|)
name|ves
operator|)
operator|->
name|insn
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if IVTS1 and IVTS2 (which are really both of type     "var_to_expand *") refer to the same instruction.  */
end_comment

begin_function
specifier|static
name|int
name|ve_info_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|ivts1
parameter_list|,
specifier|const
name|void
modifier|*
name|ivts2
parameter_list|)
block|{
specifier|const
name|struct
name|var_to_expand
modifier|*
name|i1
init|=
name|ivts1
decl_stmt|;
specifier|const
name|struct
name|var_to_expand
modifier|*
name|i2
init|=
name|ivts2
decl_stmt|;
return|return
name|i1
operator|->
name|insn
operator|==
name|i2
operator|->
name|insn
return|;
block|}
end_function

begin_comment
comment|/* Returns true if REG is referenced in one insn in LOOP.  */
end_comment

begin_function
name|bool
name|referenced_in_one_insn_in_loop_p
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|rtx
name|reg
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
decl_stmt|,
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|count_ref
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|body
index|[
name|i
index|]
expr_stmt|;
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
name|rtx_referenced_p
argument_list|(
name|reg
argument_list|,
name|insn
argument_list|)
condition|)
name|count_ref
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count_ref
operator|==
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether INSN contains an accumulator    which can be expanded into separate copies,     one for each copy of the LOOP body.        for (i = 0 ; i< n; i++)      sum += a[i];        ==>          sum += a[i]    ....    i = i+1;    sum1 += a[i]    ....    i = i+1    sum2 += a[i];    ....     Return NULL if INSN contains no opportunity for expansion of accumulator.      Otherwise, allocate a VAR_TO_EXPAND structure, fill it with the relevant     information and return a pointer to it. */
end_comment

begin_function
specifier|static
name|struct
name|var_to_expand
modifier|*
name|analyze_insn_to_expand_var
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|dest
decl_stmt|,
name|src
decl_stmt|,
name|op1
decl_stmt|;
name|struct
name|var_to_expand
modifier|*
name|ves
decl_stmt|;
name|enum
name|machine_mode
name|mode1
decl_stmt|,
name|mode2
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|NULL
return|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|src
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MINUS
operator|&&
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|MULT
condition|)
return|return
name|NULL
return|;
comment|/* Hmm, this is a bit paradoxical.  We know that INSN is a valid insn      in MD.  But if there is no optab to generate the insn, we can not      perform the variable expansion.  This can happen if an MD provides      an insn but not a named pattern to generate it, for example to avoid      producing code that needs additional mode switches like for x87/mmx.       So we check have_insn_for which looks for an optab for the operation      in SRC.  If it doesn't exist, we can't perform the expansion even      though INSN is valid.  */
if|if
condition|(
operator|!
name|have_insn_for
argument_list|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|src
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|op1
operator|=
name|XEXP
argument_list|(
name|src
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|dest
argument_list|)
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|dest
argument_list|)
operator|==
name|SUBREG
operator|&&
name|REG_P
argument_list|(
name|SUBREG_REG
argument_list|(
name|dest
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|rtx_equal_p
argument_list|(
name|dest
argument_list|,
name|op1
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|referenced_in_one_insn_in_loop_p
argument_list|(
name|loop
argument_list|,
name|dest
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|rtx_referenced_p
argument_list|(
name|dest
argument_list|,
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|mode1
operator|=
name|GET_MODE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|mode2
operator|=
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|src
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|FLOAT_MODE_P
argument_list|(
name|mode1
argument_list|)
operator|||
name|FLOAT_MODE_P
argument_list|(
name|mode2
argument_list|)
operator|)
operator|&&
operator|!
name|flag_unsafe_math_optimizations
condition|)
return|return
name|NULL
return|;
comment|/* Record the accumulator to expand.  */
name|ves
operator|=
name|XNEW
argument_list|(
expr|struct
name|var_to_expand
argument_list|)
expr_stmt|;
name|ves
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|ves
operator|->
name|var_expansions
operator|=
name|VEC_alloc
argument_list|(
name|rtx
argument_list|,
name|heap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ves
operator|->
name|reg
operator|=
name|copy_rtx
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|ves
operator|->
name|op
operator|=
name|GET_CODE
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|ves
operator|->
name|expansion_count
operator|=
literal|0
expr_stmt|;
name|ves
operator|->
name|reuse_expansion
operator|=
literal|0
expr_stmt|;
return|return
name|ves
return|;
block|}
end_function

begin_comment
comment|/* Determine whether there is an induction variable in INSN that    we would like to split during unrolling.       I.e. replace     i = i + 1;    ...    i = i + 1;    ...    i = i + 1;    ...     type chains by     i0 = i + 1    ...    i = i0 + 1    ...    i = i0 + 2    ...     Return NULL if INSN contains no interesting IVs.  Otherwise, allocate     an IV_TO_SPLIT structure, fill it with the relevant information and return a    pointer to it.  */
end_comment

begin_function
specifier|static
name|struct
name|iv_to_split
modifier|*
name|analyze_iv_to_split_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|set
decl_stmt|,
name|dest
decl_stmt|;
name|struct
name|rtx_iv
name|iv
decl_stmt|;
name|struct
name|iv_to_split
modifier|*
name|ivts
decl_stmt|;
name|bool
name|ok
decl_stmt|;
comment|/* For now we just split the basic induction variables.  Later this may be      extended for example by selecting also addresses of memory references.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
return|return
name|NULL
return|;
name|dest
operator|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|dest
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|biv_p
argument_list|(
name|insn
argument_list|,
name|dest
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ok
operator|=
name|iv_analyze_result
argument_list|(
name|insn
argument_list|,
name|dest
argument_list|,
operator|&
name|iv
argument_list|)
expr_stmt|;
comment|/* This used to be an assert under the assumption that if biv_p returns      true that iv_analyze_result must also return true.  However, that      assumption is not strictly correct as evidenced by pr25569.       Returning NULL when iv_analyze_result returns false is safe and      avoids the problems in pr25569 until the iv_analyze_* routines      can be fixed, which is apparently hard and time consuming      according to their author.  */
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|iv
operator|.
name|step
operator|==
name|const0_rtx
operator|||
name|iv
operator|.
name|mode
operator|!=
name|iv
operator|.
name|extend_mode
condition|)
return|return
name|NULL
return|;
comment|/* Record the insn to split.  */
name|ivts
operator|=
name|XNEW
argument_list|(
expr|struct
name|iv_to_split
argument_list|)
expr_stmt|;
name|ivts
operator|->
name|insn
operator|=
name|insn
expr_stmt|;
name|ivts
operator|->
name|base_var
operator|=
name|NULL_RTX
expr_stmt|;
name|ivts
operator|->
name|step
operator|=
name|iv
operator|.
name|step
expr_stmt|;
name|ivts
operator|->
name|n_loc
operator|=
literal|1
expr_stmt|;
name|ivts
operator|->
name|loc
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
return|return
name|ivts
return|;
block|}
end_function

begin_comment
comment|/* Determines which of insns in LOOP can be optimized.    Return a OPT_INFO struct with the relevant hash tables filled    with all insns to be optimized.  The FIRST_NEW_BLOCK field    is undefined for the return value.  */
end_comment

begin_function
specifier|static
name|struct
name|opt_info
modifier|*
name|analyze_insns_in_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
modifier|*
name|body
decl_stmt|,
name|bb
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|num_edges
init|=
literal|0
decl_stmt|;
name|struct
name|opt_info
modifier|*
name|opt_info
init|=
name|XCNEW
argument_list|(
expr|struct
name|opt_info
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|iv_to_split
modifier|*
name|ivts
init|=
name|NULL
decl_stmt|;
name|struct
name|var_to_expand
modifier|*
name|ves
init|=
name|NULL
decl_stmt|;
name|PTR
modifier|*
name|slot1
decl_stmt|;
name|PTR
modifier|*
name|slot2
decl_stmt|;
name|edge
modifier|*
name|edges
init|=
name|get_loop_exit_edges
argument_list|(
name|loop
argument_list|,
operator|&
name|num_edges
argument_list|)
decl_stmt|;
name|bool
name|can_apply
init|=
name|false
decl_stmt|;
name|iv_analysis_loop_init
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|body
operator|=
name|get_loop_body
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_split_ivs_in_unroller
condition|)
name|opt_info
operator|->
name|insns_to_split
operator|=
name|htab_create
argument_list|(
literal|5
operator|*
name|loop
operator|->
name|num_nodes
argument_list|,
name|si_info_hash
argument_list|,
name|si_info_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
comment|/* Record the loop exit bb and loop preheader before the unrolling.  */
if|if
condition|(
operator|!
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
condition|)
block|{
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|opt_info
operator|->
name|loop_preheader
operator|=
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
block|}
else|else
name|opt_info
operator|->
name|loop_preheader
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|num_edges
operator|==
literal|1
operator|&&
operator|!
operator|(
name|edges
index|[
literal|0
index|]
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
condition|)
block|{
name|opt_info
operator|->
name|loop_exit
operator|=
name|loop_split_edge_with
argument_list|(
name|edges
index|[
literal|0
index|]
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|can_apply
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|flag_variable_expansion_in_unroller
operator|&&
name|can_apply
condition|)
name|opt_info
operator|->
name|insns_with_var_to_expand
operator|=
name|htab_create
argument_list|(
literal|5
operator|*
name|loop
operator|->
name|num_nodes
argument_list|,
name|ve_info_hash
argument_list|,
name|ve_info_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|loop
operator|->
name|num_nodes
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|body
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|loop
operator|->
name|latch
argument_list|,
name|bb
argument_list|)
condition|)
continue|continue;
name|FOR_BB_INSNS
argument_list|(
argument|bb
argument_list|,
argument|insn
argument_list|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|opt_info
operator|->
name|insns_to_split
condition|)
name|ivts
operator|=
name|analyze_iv_to_split_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivts
condition|)
block|{
name|slot1
operator|=
name|htab_find_slot
argument_list|(
name|opt_info
operator|->
name|insns_to_split
argument_list|,
name|ivts
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot1
operator|=
name|ivts
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|opt_info
operator|->
name|insns_with_var_to_expand
condition|)
name|ves
operator|=
name|analyze_insn_to_expand_var
argument_list|(
name|loop
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ves
condition|)
block|{
name|slot2
operator|=
name|htab_find_slot
argument_list|(
name|opt_info
operator|->
name|insns_with_var_to_expand
argument_list|,
name|ves
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
operator|*
name|slot2
operator|=
name|ves
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|edges
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|body
argument_list|)
expr_stmt|;
return|return
name|opt_info
return|;
block|}
end_function

begin_comment
comment|/* Called just before loop duplication.  Records start of duplicated area    to OPT_INFO.  */
end_comment

begin_function
specifier|static
name|void
name|opt_info_start_duplication
parameter_list|(
name|struct
name|opt_info
modifier|*
name|opt_info
parameter_list|)
block|{
if|if
condition|(
name|opt_info
condition|)
name|opt_info
operator|->
name|first_new_block
operator|=
name|last_basic_block
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the number of iterations between initialization of the base    variable and the current copy (N_COPY).  N_COPIES is the total number    of newly created copies.  UNROLLING is true if we are unrolling    (not peeling) the loop.  */
end_comment

begin_function
specifier|static
name|unsigned
name|determine_split_iv_delta
parameter_list|(
name|unsigned
name|n_copy
parameter_list|,
name|unsigned
name|n_copies
parameter_list|,
name|bool
name|unrolling
parameter_list|)
block|{
if|if
condition|(
name|unrolling
condition|)
block|{
comment|/* If we are unrolling, initialization is done in the original loop 	 body (number 0).  */
return|return
name|n_copy
return|;
block|}
else|else
block|{
comment|/* If we are peeling, the copy in that the initialization occurs has 	 number 1.  The original loop (number 0) is the last.  */
if|if
condition|(
name|n_copy
condition|)
return|return
name|n_copy
operator|-
literal|1
return|;
else|else
return|return
name|n_copies
return|;
block|}
block|}
end_function

begin_comment
comment|/* Locate in EXPR the expression corresponding to the location recorded    in IVTS, and return a pointer to the RTX for this location.  */
end_comment

begin_function
specifier|static
name|rtx
modifier|*
name|get_ivts_expr
parameter_list|(
name|rtx
name|expr
parameter_list|,
name|struct
name|iv_to_split
modifier|*
name|ivts
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|rtx
modifier|*
name|ret
init|=
operator|&
name|expr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ivts
operator|->
name|n_loc
condition|;
name|i
operator|++
control|)
name|ret
operator|=
operator|&
name|XEXP
argument_list|(
operator|*
name|ret
argument_list|,
name|ivts
operator|->
name|loc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Allocate basic variable for the induction variable chain.  Callback for    htab_traverse.  */
end_comment

begin_function
specifier|static
name|int
name|allocate_basic_variable
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|iv_to_split
modifier|*
name|ivts
init|=
operator|*
name|slot
decl_stmt|;
name|rtx
name|expr
init|=
operator|*
name|get_ivts_expr
argument_list|(
name|single_set
argument_list|(
name|ivts
operator|->
name|insn
argument_list|)
argument_list|,
name|ivts
argument_list|)
decl_stmt|;
name|ivts
operator|->
name|base_var
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Insert initialization of basic variable of IVTS before INSN, taking    the initial value from INSN.  */
end_comment

begin_function
specifier|static
name|void
name|insert_base_initialization
parameter_list|(
name|struct
name|iv_to_split
modifier|*
name|ivts
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|expr
init|=
name|copy_rtx
argument_list|(
operator|*
name|get_ivts_expr
argument_list|(
name|single_set
argument_list|(
name|insn
argument_list|)
argument_list|,
name|ivts
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|seq
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|expr
operator|=
name|force_operand
argument_list|(
name|expr
argument_list|,
name|ivts
operator|->
name|base_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|ivts
operator|->
name|base_var
condition|)
name|emit_move_insn
argument_list|(
name|ivts
operator|->
name|base_var
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Replace the use of induction variable described in IVTS in INSN    by base variable + DELTA * step.  */
end_comment

begin_function
specifier|static
name|void
name|split_iv
parameter_list|(
name|struct
name|iv_to_split
modifier|*
name|ivts
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|unsigned
name|delta
parameter_list|)
block|{
name|rtx
name|expr
decl_stmt|,
modifier|*
name|loc
decl_stmt|,
name|seq
decl_stmt|,
name|incr
decl_stmt|,
name|var
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|ivts
operator|->
name|base_var
argument_list|)
decl_stmt|;
name|rtx
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|set
decl_stmt|;
comment|/* Construct base + DELTA * step.  */
if|if
condition|(
operator|!
name|delta
condition|)
name|expr
operator|=
name|ivts
operator|->
name|base_var
expr_stmt|;
else|else
block|{
name|incr
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|ivts
operator|->
name|step
argument_list|,
name|gen_int_mode
argument_list|(
name|delta
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|expr
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|ivts
operator|->
name|base_var
argument_list|)
argument_list|,
name|ivts
operator|->
name|base_var
argument_list|,
name|incr
argument_list|)
expr_stmt|;
block|}
comment|/* Figure out where to do the replacement.  */
name|loc
operator|=
name|get_ivts_expr
argument_list|(
name|single_set
argument_list|(
name|insn
argument_list|)
argument_list|,
name|ivts
argument_list|)
expr_stmt|;
comment|/* If we can make the replacement right away, we're done.  */
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* Otherwise, force EXPR into a register and try again.  */
name|start_sequence
argument_list|()
expr_stmt|;
name|var
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|expr
operator|=
name|force_operand
argument_list|(
name|expr
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|var
condition|)
name|emit_move_insn
argument_list|(
name|var
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|validate_change
argument_list|(
name|insn
argument_list|,
name|loc
argument_list|,
name|var
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* The last chance.  Try recreating the assignment in insn      completely from scratch.  */
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
operator|*
name|loc
operator|=
name|var
expr_stmt|;
name|src
operator|=
name|copy_rtx
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|=
name|copy_rtx
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|force_operand
argument_list|(
name|src
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|!=
name|dest
condition|)
name|emit_move_insn
argument_list|(
name|dest
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|emit_insn_before
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return one expansion of the accumulator recorded in struct VE.  */
end_comment

begin_function
specifier|static
name|rtx
name|get_expansion
parameter_list|(
name|struct
name|var_to_expand
modifier|*
name|ve
parameter_list|)
block|{
name|rtx
name|reg
decl_stmt|;
if|if
condition|(
name|ve
operator|->
name|reuse_expansion
operator|==
literal|0
condition|)
name|reg
operator|=
name|ve
operator|->
name|reg
expr_stmt|;
else|else
name|reg
operator|=
name|VEC_index
argument_list|(
name|rtx
argument_list|,
name|ve
operator|->
name|var_expansions
argument_list|,
name|ve
operator|->
name|reuse_expansion
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|rtx
argument_list|,
name|ve
operator|->
name|var_expansions
argument_list|)
operator|==
operator|(
name|unsigned
operator|)
name|ve
operator|->
name|reuse_expansion
condition|)
name|ve
operator|->
name|reuse_expansion
operator|=
literal|0
expr_stmt|;
else|else
name|ve
operator|->
name|reuse_expansion
operator|++
expr_stmt|;
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* Given INSN replace the uses of the accumulator recorded in VE     with a new register.  */
end_comment

begin_function
specifier|static
name|void
name|expand_var_during_unrolling
parameter_list|(
name|struct
name|var_to_expand
modifier|*
name|ve
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|new_reg
decl_stmt|,
name|set
decl_stmt|;
name|bool
name|really_new_expansion
init|=
name|false
decl_stmt|;
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|set
argument_list|)
expr_stmt|;
comment|/* Generate a new register only if the expansion limit has not been      reached.  Else reuse an already existing expansion.  */
if|if
condition|(
name|PARAM_VALUE
argument_list|(
name|PARAM_MAX_VARIABLE_EXPANSIONS
argument_list|)
operator|>
name|ve
operator|->
name|expansion_count
condition|)
block|{
name|really_new_expansion
operator|=
name|true
expr_stmt|;
name|new_reg
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|ve
operator|->
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|new_reg
operator|=
name|get_expansion
argument_list|(
name|ve
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|,
name|new_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|new_reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|apply_change_group
argument_list|()
condition|)
if|if
condition|(
name|really_new_expansion
condition|)
block|{
name|VEC_safe_push
argument_list|(
name|rtx
argument_list|,
name|heap
argument_list|,
name|ve
operator|->
name|var_expansions
argument_list|,
name|new_reg
argument_list|)
expr_stmt|;
name|ve
operator|->
name|expansion_count
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the variable expansions in loop preheader.      Callbacks for htab_traverse.  PLACE_P is the loop-preheader     basic block where the initialization of the expansions     should take place.  */
end_comment

begin_function
specifier|static
name|int
name|insert_var_expansion_initialization
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|place_p
parameter_list|)
block|{
name|struct
name|var_to_expand
modifier|*
name|ve
init|=
operator|*
name|slot
decl_stmt|;
name|basic_block
name|place
init|=
operator|(
name|basic_block
operator|)
name|place_p
decl_stmt|;
name|rtx
name|seq
decl_stmt|,
name|var
decl_stmt|,
name|zero_init
decl_stmt|,
name|insn
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|rtx
argument_list|,
name|ve
operator|->
name|var_expansions
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|ve
operator|->
name|op
operator|==
name|PLUS
operator|||
name|ve
operator|->
name|op
operator|==
name|MINUS
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|rtx
argument_list|,
name|ve
operator|->
name|var_expansions
argument_list|,
name|i
argument_list|,
name|var
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|zero_init
operator|=
name|CONST0_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|var
argument_list|,
name|zero_init
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ve
operator|->
name|op
operator|==
name|MULT
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|rtx
argument_list|,
name|ve
operator|->
name|var_expansions
argument_list|,
name|i
argument_list|,
name|var
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|zero_init
operator|=
name|CONST1_RTX
argument_list|(
name|GET_MODE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|var
argument_list|,
name|zero_init
argument_list|)
expr_stmt|;
block|}
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|place
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  Combine the variable expansions at the loop exit.       Callbacks for htab_traverse.  PLACE_P is the loop exit     basic block where the summation of the expansions should      take place.  */
end_comment

begin_function
specifier|static
name|int
name|combine_var_copies_in_loop_exit
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|place_p
parameter_list|)
block|{
name|struct
name|var_to_expand
modifier|*
name|ve
init|=
operator|*
name|slot
decl_stmt|;
name|basic_block
name|place
init|=
operator|(
name|basic_block
operator|)
name|place_p
decl_stmt|;
name|rtx
name|sum
init|=
name|ve
operator|->
name|reg
decl_stmt|;
name|rtx
name|expr
decl_stmt|,
name|seq
decl_stmt|,
name|var
decl_stmt|,
name|insn
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
name|VEC_length
argument_list|(
name|rtx
argument_list|,
name|ve
operator|->
name|var_expansions
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|start_sequence
argument_list|()
expr_stmt|;
if|if
condition|(
name|ve
operator|->
name|op
operator|==
name|PLUS
operator|||
name|ve
operator|->
name|op
operator|==
name|MINUS
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|rtx
argument_list|,
name|ve
operator|->
name|var_expansions
argument_list|,
name|i
argument_list|,
name|var
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|=
name|simplify_gen_binary
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|ve
operator|->
name|reg
argument_list|)
argument_list|,
name|var
argument_list|,
name|sum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ve
operator|->
name|op
operator|==
name|MULT
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|rtx
argument_list|,
name|ve
operator|->
name|var_expansions
argument_list|,
name|i
argument_list|,
name|var
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|=
name|simplify_gen_binary
argument_list|(
name|MULT
argument_list|,
name|GET_MODE
argument_list|(
name|ve
operator|->
name|reg
argument_list|)
argument_list|,
name|var
argument_list|,
name|sum
argument_list|)
expr_stmt|;
block|}
name|expr
operator|=
name|force_operand
argument_list|(
name|sum
argument_list|,
name|ve
operator|->
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
name|ve
operator|->
name|reg
condition|)
name|emit_move_insn
argument_list|(
name|ve
operator|->
name|reg
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|seq
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|place
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|insn
argument_list|)
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|emit_insn_after
argument_list|(
name|seq
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Apply loop optimizations in loop copies using the     data which gathered during the unrolling.  Structure     OPT_INFO record that data.        UNROLLING is true if we unrolled (not peeled) the loop.    REWRITE_ORIGINAL_BODY is true if we should also rewrite the original body of    the loop (as it should happen in complete unrolling, but not in ordinary    peeling of the loop).  */
end_comment

begin_function
specifier|static
name|void
name|apply_opt_in_copies
parameter_list|(
name|struct
name|opt_info
modifier|*
name|opt_info
parameter_list|,
name|unsigned
name|n_copies
parameter_list|,
name|bool
name|unrolling
parameter_list|,
name|bool
name|rewrite_original_loop
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|delta
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|orig_bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|orig_insn
decl_stmt|,
name|next
decl_stmt|;
name|struct
name|iv_to_split
name|ivts_templ
decl_stmt|,
modifier|*
name|ivts
decl_stmt|;
name|struct
name|var_to_expand
name|ve_templ
decl_stmt|,
modifier|*
name|ves
decl_stmt|;
comment|/* Sanity check -- we need to put initialization in the original loop      body.  */
name|gcc_assert
argument_list|(
operator|!
name|unrolling
operator|||
name|rewrite_original_loop
argument_list|)
expr_stmt|;
comment|/* Allocate the basic variables (i0).  */
if|if
condition|(
name|opt_info
operator|->
name|insns_to_split
condition|)
name|htab_traverse
argument_list|(
name|opt_info
operator|->
name|insns_to_split
argument_list|,
name|allocate_basic_variable
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|opt_info
operator|->
name|first_new_block
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|last_basic_block
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|orig_bb
operator|=
name|get_bb_original
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* bb->aux holds position in copy sequence initialized by 	 duplicate_loop_to_header_edge.  */
name|delta
operator|=
name|determine_split_iv_delta
argument_list|(
operator|(
name|size_t
operator|)
name|bb
operator|->
name|aux
argument_list|,
name|n_copies
argument_list|,
name|unrolling
argument_list|)
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
literal|0
expr_stmt|;
name|orig_insn
operator|=
name|BB_HEAD
argument_list|(
name|orig_bb
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
while|while
condition|(
operator|!
name|INSN_P
argument_list|(
name|orig_insn
argument_list|)
condition|)
name|orig_insn
operator|=
name|NEXT_INSN
argument_list|(
name|orig_insn
argument_list|)
expr_stmt|;
name|ivts_templ
operator|.
name|insn
operator|=
name|orig_insn
expr_stmt|;
name|ve_templ
operator|.
name|insn
operator|=
name|orig_insn
expr_stmt|;
comment|/* Apply splitting iv optimization.  */
if|if
condition|(
name|opt_info
operator|->
name|insns_to_split
condition|)
block|{
name|ivts
operator|=
name|htab_find
argument_list|(
name|opt_info
operator|->
name|insns_to_split
argument_list|,
operator|&
name|ivts_templ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivts
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|orig_insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta
condition|)
name|insert_base_initialization
argument_list|(
name|ivts
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|split_iv
argument_list|(
name|ivts
argument_list|,
name|insn
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Apply variable expansion optimization.  */
if|if
condition|(
name|unrolling
operator|&&
name|opt_info
operator|->
name|insns_with_var_to_expand
condition|)
block|{
name|ves
operator|=
name|htab_find
argument_list|(
name|opt_info
operator|->
name|insns_with_var_to_expand
argument_list|,
operator|&
name|ve_templ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ves
condition|)
block|{
name|gcc_assert
argument_list|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|orig_insn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expand_var_during_unrolling
argument_list|(
name|ves
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|orig_insn
operator|=
name|NEXT_INSN
argument_list|(
name|orig_insn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|rewrite_original_loop
condition|)
return|return;
comment|/* Initialize the variable expansions in the loop preheader      and take care of combining them at the loop exit.  */
if|if
condition|(
name|opt_info
operator|->
name|insns_with_var_to_expand
condition|)
block|{
name|htab_traverse
argument_list|(
name|opt_info
operator|->
name|insns_with_var_to_expand
argument_list|,
name|insert_var_expansion_initialization
argument_list|,
name|opt_info
operator|->
name|loop_preheader
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|opt_info
operator|->
name|insns_with_var_to_expand
argument_list|,
name|combine_var_copies_in_loop_exit
argument_list|,
name|opt_info
operator|->
name|loop_exit
argument_list|)
expr_stmt|;
block|}
comment|/* Rewrite also the original loop body.  Find them as originals of the blocks      in the last copied iteration, i.e. those that have      get_bb_copy (get_bb_original (bb)) == bb.  */
for|for
control|(
name|i
operator|=
name|opt_info
operator|->
name|first_new_block
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|last_basic_block
condition|;
name|i
operator|++
control|)
block|{
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|orig_bb
operator|=
name|get_bb_original
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_bb_copy
argument_list|(
name|orig_bb
argument_list|)
operator|!=
name|bb
condition|)
continue|continue;
name|delta
operator|=
name|determine_split_iv_delta
argument_list|(
literal|0
argument_list|,
name|n_copies
argument_list|,
name|unrolling
argument_list|)
expr_stmt|;
for|for
control|(
name|orig_insn
operator|=
name|BB_HEAD
argument_list|(
name|orig_bb
argument_list|)
init|;
name|orig_insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|orig_insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|orig_insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|orig_insn
argument_list|)
condition|)
continue|continue;
name|ivts_templ
operator|.
name|insn
operator|=
name|orig_insn
expr_stmt|;
if|if
condition|(
name|opt_info
operator|->
name|insns_to_split
condition|)
block|{
name|ivts
operator|=
name|htab_find
argument_list|(
name|opt_info
operator|->
name|insns_to_split
argument_list|,
operator|&
name|ivts_templ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ivts
condition|)
block|{
if|if
condition|(
operator|!
name|delta
condition|)
name|insert_base_initialization
argument_list|(
name|ivts
argument_list|,
name|orig_insn
argument_list|)
expr_stmt|;
name|split_iv
argument_list|(
name|ivts
argument_list|,
name|orig_insn
argument_list|,
name|delta
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  Release the data structures used for the variable expansion     optimization.  Callbacks for htab_traverse.  */
end_comment

begin_function
specifier|static
name|int
name|release_var_copies
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|var_to_expand
modifier|*
name|ve
init|=
operator|*
name|slot
decl_stmt|;
name|VEC_free
argument_list|(
name|rtx
argument_list|,
name|heap
argument_list|,
name|ve
operator|->
name|var_expansions
argument_list|)
expr_stmt|;
comment|/* Continue traversing the hash table.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Release OPT_INFO.  */
end_comment

begin_function
specifier|static
name|void
name|free_opt_info
parameter_list|(
name|struct
name|opt_info
modifier|*
name|opt_info
parameter_list|)
block|{
if|if
condition|(
name|opt_info
operator|->
name|insns_to_split
condition|)
name|htab_delete
argument_list|(
name|opt_info
operator|->
name|insns_to_split
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_info
operator|->
name|insns_with_var_to_expand
condition|)
block|{
name|htab_traverse
argument_list|(
name|opt_info
operator|->
name|insns_with_var_to_expand
argument_list|,
name|release_var_copies
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|htab_delete
argument_list|(
name|opt_info
operator|->
name|insns_with_var_to_expand
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|opt_info
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

