begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Data flow analysis for GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains the data flow analysis pass of the compiler.  It    computes data flow information which tells combine_instructions    which insns to consider combining and controls register allocation.     Additional data flow information that is too bulky to record is    generated during the analysis, and is used at that time to create    autoincrement and autodecrement addressing.     The first step is dividing the function into basic blocks.    find_basic_blocks does this.  Then life_analysis determines    where each register is live and where it is dead.     ** find_basic_blocks **     find_basic_blocks divides the current function's rtl into basic    blocks and constructs the CFG.  The blocks are recorded in the    basic_block_info array; the CFG exists in the edge structures    referenced by the blocks.     find_basic_blocks also finds any unreachable loops and deletes them.     ** life_analysis **     life_analysis is called immediately after find_basic_blocks.    It uses the basic block information to determine where each    hard or pseudo register is live.     ** live-register info **     The information about where each register is live is in two parts:    the REG_NOTES of insns, and the vector basic_block->global_live_at_start.     basic_block->global_live_at_start has an element for each basic    block, and the element is a bit-vector with a bit for each hard or    pseudo register.  The bit is 1 if the register is live at the    beginning of the basic block.     Two types of elements can be added to an insn's REG_NOTES.    A REG_DEAD note is added to an insn's REG_NOTES for any register    that meets both of two conditions:  The value in the register is not    needed in subsequent insns and the insn does not replace the value in    the register (in the case of multi-word hard registers, the value in    each register must be replaced by the insn to avoid a REG_DEAD note).     In the vast majority of cases, an object in a REG_DEAD note will be    used somewhere in the insn.  The (rare) exception to this is if an    insn uses a multi-word hard register and only some of the registers are    needed in subsequent insns.  In that case, REG_DEAD notes will be    provided for those hard registers that are not subsequently needed.    Partial REG_DEAD notes of this type do not occur when an insn sets    only some of the hard registers used in such a multi-word operand;    omitting REG_DEAD notes for objects stored in an insn is optional and    the desire to do so does not justify the complexity of the partial    REG_DEAD notes.     REG_UNUSED notes are added for each register that is set by the insn    but is unused subsequently (if every register set by the insn is unused    and the insn does not reference memory or have some other side-effect,    the insn is deleted instead).  If only part of a multi-word hard    register is used in a subsequent insn, REG_UNUSED notes are made for    the parts that will not be used.     To determine which registers are live after any insn, one can    start from the beginning of the basic block and scan insns, noting    which registers are set by each insn and which die there.     ** Other actions of life_analysis **     life_analysis sets up the LOG_LINKS fields of insns because the    information needed to do so is readily available.     life_analysis deletes insns whose only effect is to store a value    that is never used.     life_analysis notices cases where a reference to a register as    a memory address can be combined with a preceding or following    incrementation or decrementation of the register.  The separate    instruction to increment or decrement is deleted and the address    is changed to a POST_INC or similar rtx.     Each time an incrementing or decrementing address is created,    a REG_INC element is added to the insn's REG_NOTES list.     life_analysis fills in certain vectors containing information about    register usage: REG_N_REFS, REG_N_DEATHS, REG_N_SETS, REG_LIVE_LENGTH,    REG_N_CALLS_CROSSED and REG_BASIC_BLOCK.     life_analysis sets current_function_sp_is_unchanging if the function    doesn't modify the stack pointer.  */
end_comment

begin_comment
comment|/* TODO:     Split out from life_analysis: 	- local property discovery (bb->local_live, bb->local_set) 	- global property computation 	- log links creation 	- pre/post modify transformation */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_epilogue
end_ifndef

begin_define
define|#
directive|define
name|HAVE_epilogue
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_prologue
end_ifndef

begin_define
define|#
directive|define
name|HAVE_prologue
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_sibcall_epilogue
end_ifndef

begin_define
define|#
directive|define
name|HAVE_sibcall_epilogue
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EPILOGUE_USES
end_ifndef

begin_define
define|#
directive|define
name|EPILOGUE_USES
parameter_list|(
name|REGNO
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EH_USES
end_ifndef

begin_define
define|#
directive|define
name|EH_USES
parameter_list|(
name|REGNO
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|REVERSE_CONDEXEC_PREDICATES_P
end_ifndef

begin_define
define|#
directive|define
name|REVERSE_CONDEXEC_PREDICATES_P
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x) == reverse_condition (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if the second flow pass has completed.  */
end_comment

begin_decl_stmt
name|int
name|flow2_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum register number used in this function, plus one.  */
end_comment

begin_decl_stmt
name|int
name|max_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, giving various register information */
end_comment

begin_decl_stmt
name|varray_type
name|reg_n_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of a regset for the current function,    in (1) bytes and (2) elements.  */
end_comment

begin_decl_stmt
name|int
name|regset_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regset_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regset of regs live when calls to `setjmp'-like functions happen.  */
end_comment

begin_comment
comment|/* ??? Does this exist only for the setjmp-clobbered warning message?  */
end_comment

begin_decl_stmt
name|regset
name|regs_live_at_setjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List made of EXPR_LIST rtx's which gives pairs of pseudo registers    that have to go in the same hard reg.    The first two regs in the list are a pair, and the next two    are another pair, etc.  */
end_comment

begin_decl_stmt
name|rtx
name|regs_may_share
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callback that determines if it's ok for a function to have no    noreturn attribute.  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|lang_missing_noreturn_ok_p
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set of registers that may be eliminable.  These are handled specially    in updating regs_ever_live.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|elim_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds information for tracking conditional register life information.  */
end_comment

begin_struct
struct|struct
name|reg_cond_life_info
block|{
comment|/* A boolean expression of conditions under which a register is dead.  */
name|rtx
name|condition
decl_stmt|;
comment|/* Conditions under which a register is dead at the basic block end.  */
name|rtx
name|orig_condition
decl_stmt|;
comment|/* A boolean expression of conditions under which a register has been      stored into.  */
name|rtx
name|stores
decl_stmt|;
comment|/* ??? Could store mask of bytes that are dead, so that we could finally      track lifetimes of multi-word registers accessed via subregs.  */
block|}
struct|;
end_struct

begin_comment
comment|/* For use in communicating between propagate_block and its subroutines.    Holds all information needed to compute life and def-use information.  */
end_comment

begin_struct
struct|struct
name|propagate_block_info
block|{
comment|/* The basic block we're considering.  */
name|basic_block
name|bb
decl_stmt|;
comment|/* Bit N is set if register N is conditionally or unconditionally live.  */
name|regset
name|reg_live
decl_stmt|;
comment|/* Bit N is set if register N is set this insn.  */
name|regset
name|new_set
decl_stmt|;
comment|/* Element N is the next insn that uses (hard or pseudo) register N      within the current basic block; or zero, if there is no such insn.  */
name|rtx
modifier|*
name|reg_next_use
decl_stmt|;
comment|/* Contains a list of all the MEMs we are tracking for dead store      elimination.  */
name|rtx
name|mem_set_list
decl_stmt|;
comment|/* If non-null, record the set of registers set unconditionally in the      basic block.  */
name|regset
name|local_set
decl_stmt|;
comment|/* If non-null, record the set of registers set conditionally in the      basic block.  */
name|regset
name|cond_local_set
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
comment|/* Indexed by register number, holds a reg_cond_life_info for each      register that is not unconditionally live or dead.  */
name|splay_tree
name|reg_cond_dead
decl_stmt|;
comment|/* Bit N is set if register N is in an expression in reg_cond_dead.  */
name|regset
name|reg_cond_reg
decl_stmt|;
endif|#
directive|endif
comment|/* The length of mem_set_list.  */
name|int
name|mem_set_list_len
decl_stmt|;
comment|/* Nonzero if the value of CC0 is live.  */
name|int
name|cc0_live
decl_stmt|;
comment|/* Flags controlling the set of information propagate_block collects.  */
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Number of dead insns removed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ndead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum length of pbi->mem_set_list before we start dropping    new elements on the floor.  */
end_comment

begin_define
define|#
directive|define
name|MAX_MEM_SET_LIST_LEN
value|100
end_define

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
specifier|static
name|int
name|verify_wide_reg_1
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verify_wide_reg
parameter_list|(
name|int
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verify_local_live_at_start
parameter_list|(
name|regset
parameter_list|,
name|basic_block
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|notice_stack_pointer_modification_1
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|notice_stack_pointer_modification
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_reg
parameter_list|(
name|rtx
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_regs_live_at_end
parameter_list|(
name|regset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|calculate_global_regs_live
parameter_list|(
name|sbitmap
parameter_list|,
name|sbitmap
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propagate_block_delete_insn
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|propagate_block_delete_libcall
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|insn_dead_p
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|libcall_dead_p
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_set_regs
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_set_1
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|enum
name|rtx_code
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_regno_partial
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
end_ifdef

begin_function_decl
specifier|static
name|int
name|mark_regno_cond_dead
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|int
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_reg_cond_life_info
parameter_list|(
name|splay_tree_value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|flush_reg_cond_reg_1
parameter_list|(
name|splay_tree_node
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flush_reg_cond_reg
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|elim_reg_cond
parameter_list|(
name|rtx
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|ior_reg_cond
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|not_reg_cond
parameter_list|(
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|and_reg_cond
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_function_decl
specifier|static
name|void
name|attempt_auto_inc
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_auto_inc
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_pre_increment_1
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_pre_increment
parameter_list|(
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|mark_used_reg
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_used_regs
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|debug_flow_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_to_mem_set_list
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|invalidate_mems_from_autoinc
parameter_list|(
name|rtx
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|invalidate_mems_from_set
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_log_links
parameter_list|(
name|sbitmap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|count_or_remove_death_notes_bb
parameter_list|(
name|basic_block
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
name|void
name|check_function_return_warnings
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|warn_missing_noreturn
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
operator|&&
name|EXIT_BLOCK_PTR
operator|->
name|pred
operator|==
name|NULL
operator|&&
operator|(
name|lang_missing_noreturn_ok_p
operator|&&
operator|!
name|lang_missing_noreturn_ok_p
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"function might be possible candidate for attribute `noreturn'"
argument_list|)
expr_stmt|;
comment|/* If we have a path to EXIT, then we do return.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|cfun
operator|->
name|decl
argument_list|)
operator|&&
name|EXIT_BLOCK_PTR
operator|->
name|pred
operator|!=
name|NULL
condition|)
name|warning
argument_list|(
literal|"`noreturn' function does return"
argument_list|)
expr_stmt|;
comment|/* If the clobber_return_insn appears in some basic block, then we      do reach the end without returning a value.  */
elseif|else
if|if
condition|(
name|warn_return_type
operator|&&
name|cfun
operator|->
name|x_clobber_return_insn
operator|!=
name|NULL
operator|&&
name|EXIT_BLOCK_PTR
operator|->
name|pred
operator|!=
name|NULL
condition|)
block|{
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
comment|/* If clobber_return_insn was excised by jump1, then renumber_insns 	 can make max_uid smaller than the number still recorded in our rtx. 	 That's fine, since this is a quick way of verifying that the insn 	 is no longer in the chain.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|cfun
operator|->
name|x_clobber_return_insn
argument_list|)
operator|<
name|max_uid
condition|)
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|insn
operator|==
name|cfun
operator|->
name|x_clobber_return_insn
condition|)
block|{
name|warning
argument_list|(
literal|"control reaches end of non-void function"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the INSN immediately following the NOTE_INSN_BASIC_BLOCK    note associated with the BLOCK.  */
end_comment

begin_function
name|rtx
name|first_insn_after_basic_block_note
parameter_list|(
name|basic_block
name|block
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Get the first instruction in the block.  */
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|NULL_RTX
condition|)
return|return
name|NULL_RTX
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NOTE_INSN_BASIC_BLOCK_P
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform data flow analysis.    F is the first insn of the function; FLAGS is a set of PROP_* flags    to be used in accumulating flow info.  */
end_comment

begin_function
name|void
name|life_analysis
parameter_list|(
name|rtx
name|f
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
endif|#
directive|endif
comment|/* Record which registers will be eliminated.  We use this in      mark_used_regs.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|elim_reg_set
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|ARRAY_SIZE
argument_list|(
name|eliminables
argument_list|)
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
if|if
condition|(
name|flags
operator|&
name|PROP_REG_INFO
condition|)
name|init_subregs_of_mode
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|optimize
condition|)
name|flags
operator|&=
operator|~
operator|(
name|PROP_LOG_LINKS
operator||
name|PROP_AUTOINC
operator||
name|PROP_ALLOW_CFG_CHANGES
operator|)
expr_stmt|;
comment|/* The post-reload life analysis have (on a global basis) the same      registers live as was computed by reload itself.  elimination      Otherwise offsets and such may be incorrect.       Reload will make some registers as live even though they do not      appear in the rtl.       We don't want to create new auto-incs after reload, since they      are unlikely to be useful and can cause problems with shared      stack slots.  */
if|if
condition|(
name|reload_completed
condition|)
name|flags
operator|&=
operator|~
operator|(
name|PROP_REG_INFO
operator||
name|PROP_AUTOINC
operator|)
expr_stmt|;
comment|/* We want alias analysis information for local dead store elimination.  */
if|if
condition|(
name|optimize
operator|&&
operator|(
name|flags
operator|&
name|PROP_SCAN_DEAD_STORES
operator|)
condition|)
name|init_alias_analysis
argument_list|()
expr_stmt|;
comment|/* Always remove no-op moves.  Do this before other processing so      that we don't have to keep re-scanning them.  */
name|delete_noop_moves
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Some targets can emit simpler epilogues if they know that sp was      not ever modified during the function.  After reload, of course,      we've already emitted the epilogue so there's no sense searching.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
name|notice_stack_pointer_modification
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Allocate and zero out data structures that will record the      data from lifetime analysis.  */
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|allocate_bb_life_data
argument_list|()
expr_stmt|;
comment|/* Find the set of registers live on function exit.  */
name|mark_regs_live_at_end
argument_list|(
name|EXIT_BLOCK_PTR
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
comment|/* "Update" life info from zero.  It'd be nice to begin the      relaxation with just the exit and noreturn blocks, but that set      is not immediately handy.  */
if|if
condition|(
name|flags
operator|&
name|PROP_REG_INFO
condition|)
block|{
name|memset
argument_list|(
name|regs_ever_live
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|regs_ever_live
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|regs_asm_clobbered
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|regs_asm_clobbered
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_GLOBAL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Clean up.  */
if|if
condition|(
name|optimize
operator|&&
operator|(
name|flags
operator|&
name|PROP_SCAN_DEAD_STORES
operator|)
condition|)
name|end_alias_analysis
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_flow_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free_basic_block_vars
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Removing dead insns should've made jumptables really dead.  */
name|delete_dead_jumptables
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of verify_wide_reg, called through for_each_rtx.    Search for REGNO.  If found, return 2 if it is not wider than    word_mode.  */
end_comment

begin_function
specifier|static
name|int
name|verify_wide_reg_1
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|pregno
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|pregno
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|x
argument_list|)
operator|==
name|regno
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_WORD
condition|)
return|return
literal|2
return|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of verify_local_live_at_start.  Search through insns    of BB looking for register REGNO.  */
end_comment

begin_function
specifier|static
name|void
name|verify_wide_reg
parameter_list|(
name|int
name|regno
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|rtx
name|head
init|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
decl_stmt|,
name|end
init|=
name|BB_END
argument_list|(
name|bb
argument_list|)
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|int
name|r
init|=
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|head
argument_list|)
argument_list|,
name|verify_wide_reg_1
argument_list|,
operator|&
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
literal|1
condition|)
return|return;
if|if
condition|(
name|r
operator|==
literal|2
condition|)
break|break;
block|}
if|if
condition|(
name|head
operator|==
name|end
condition|)
break|break;
name|head
operator|=
name|NEXT_INSN
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Register %d died unexpectedly.\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|dump_bb
argument_list|(
name|bb
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of update_life_info.  Verify that there are no untoward    changes in live_at_start during a local update.  */
end_comment

begin_function
specifier|static
name|void
name|verify_local_live_at_start
parameter_list|(
name|regset
name|new_live_at_start
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
name|reload_completed
condition|)
block|{
comment|/* After reload, there are no pseudos, nor subregs of multi-word 	 registers.  The regsets should exactly match.  */
if|if
condition|(
operator|!
name|REG_SET_EQUAL_P
argument_list|(
name|new_live_at_start
argument_list|,
name|bb
operator|->
name|global_live_at_start
argument_list|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"live_at_start mismatch in bb %d, aborting\nNew:\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|debug_bitmap_file
argument_list|(
name|rtl_dump_file
argument_list|,
name|new_live_at_start
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"Old:\n"
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
name|dump_bb
argument_list|(
name|bb
argument_list|,
name|rtl_dump_file
argument_list|)
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Find the set of changed registers.  */
name|XOR_REG_SET
argument_list|(
name|new_live_at_start
argument_list|,
name|bb
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|new_live_at_start
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{
comment|/* No registers should die.  */
argument|if (REGNO_REG_SET_P (bb->global_live_at_start, i)) 	    { 	      if (rtl_dump_file) 		{ 		  fprintf (rtl_dump_file,
literal|"Register %d died unexpectedly.\n"
argument|, i); 		  dump_bb (bb, rtl_dump_file); 		} 	      abort (); 	    }
comment|/* Verify that the now-live register is wider than word_mode.  */
argument|verify_wide_reg (i, bb); 	}
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Updates life information starting with the basic blocks set in BLOCKS.    If BLOCKS is null, consider it to be the universal set.     If EXTENT is UPDATE_LIFE_LOCAL, such as after splitting or peepholing,    we are only expecting local modifications to basic blocks.  If we find    extra registers live at the beginning of a block, then we either killed    useful data, or we have a broken split that wants data not provided.    If we find registers removed from live_at_start, that means we have    a broken peephole that is killing a register it shouldn't.     ??? This is not true in one situation -- when a pre-reload splitter    generates subregs of a multi-word pseudo, current life analysis will    lose the kill.  So we _can_ have a pseudo go live.  How irritating.     It is also not true when a peephole decides that it doesn't need one    or more of the inputs.     Including PROP_REG_INFO does not properly refresh regs_ever_live    unless the caller resets it to zero.  */
end_comment

begin_function
name|int
name|update_life_info
parameter_list|(
name|sbitmap
name|blocks
parameter_list|,
name|enum
name|update_life_extent
name|extent
parameter_list|,
name|int
name|prop_flags
parameter_list|)
block|{
name|regset
name|tmp
decl_stmt|;
name|regset_head
name|tmp_head
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|stabilized_prop_flags
init|=
name|prop_flags
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tmp
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|tmp_head
argument_list|)
expr_stmt|;
name|ndead
operator|=
literal|0
expr_stmt|;
name|timevar_push
argument_list|(
operator|(
name|extent
operator|==
name|UPDATE_LIFE_LOCAL
operator|||
name|blocks
operator|)
condition|?
name|TV_LIFE_UPDATE
else|:
name|TV_LIFE
argument_list|)
expr_stmt|;
comment|/* Changes to the CFG are only allowed when      doing a global update for the entire CFG.  */
if|if
condition|(
operator|(
name|prop_flags
operator|&
name|PROP_ALLOW_CFG_CHANGES
operator|)
operator|&&
operator|(
name|extent
operator|==
name|UPDATE_LIFE_LOCAL
operator|||
name|blocks
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* For a global update, we go through the relaxation process again.  */
if|if
condition|(
name|extent
operator|!=
name|UPDATE_LIFE_LOCAL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|calculate_global_regs_live
argument_list|(
name|blocks
argument_list|,
name|blocks
argument_list|,
name|prop_flags
operator|&
operator|(
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_SCAN_DEAD_STORES
operator||
name|PROP_ALLOW_CFG_CHANGES
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prop_flags
operator|&
operator|(
name|PROP_KILL_DEAD_CODE
operator||
name|PROP_ALLOW_CFG_CHANGES
operator|)
operator|)
operator|!=
operator|(
name|PROP_KILL_DEAD_CODE
operator||
name|PROP_ALLOW_CFG_CHANGES
operator|)
condition|)
break|break;
comment|/* Removing dead code may allow the CFG to be simplified which 	     in turn may allow for further dead code detection / removal.  */
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|COPY_REG_SET
argument_list|(
name|tmp
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|changed
operator||=
name|propagate_block
argument_list|(
name|bb
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|prop_flags
operator|&
operator|(
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_SCAN_DEAD_STORES
operator||
name|PROP_KILL_DEAD_CODE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Don't pass PROP_SCAN_DEAD_CODE or PROP_KILL_DEAD_CODE to 	     subsequent propagate_block calls, since removing or acting as 	     removing dead code can affect global register liveness, which 	     is supposed to be finalized for this call after this loop.  */
name|stabilized_prop_flags
operator|&=
operator|~
operator|(
name|PROP_SCAN_DEAD_CODE
operator||
name|PROP_SCAN_DEAD_STORES
operator||
name|PROP_KILL_DEAD_CODE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
break|break;
comment|/* We repeat regardless of what cleanup_cfg says.  If there were 	     instructions deleted above, that might have been only a 	     partial improvement (see MAX_MEM_SET_LIST_LEN usage). 	     Further improvement may be possible.  */
name|cleanup_cfg
argument_list|(
name|CLEANUP_EXPENSIVE
argument_list|)
expr_stmt|;
comment|/* Zap the life information from the last round.  If we don't 	     do this, we can wind up with registers that no longer appear 	     in the code being marked live at entry, which twiggs bogus 	     warnings from regno_uninitialized.  */
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|CLEAR_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If asked, remove notes from the blocks we'll update.  */
if|if
condition|(
name|extent
operator|==
name|UPDATE_LIFE_GLOBAL_RM_NOTES
condition|)
name|count_or_remove_death_notes
argument_list|(
name|blocks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Clear log links in case we are asked to (re)compute them.  */
if|if
condition|(
name|prop_flags
operator|&
name|PROP_LOG_LINKS
condition|)
name|clear_log_links
argument_list|(
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocks
condition|)
block|{
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	  bb = BASIC_BLOCK (i);  	  COPY_REG_SET (tmp, bb->global_live_at_end); 	  propagate_block (bb, tmp, NULL, NULL, stabilized_prop_flags);  	  if (extent == UPDATE_LIFE_LOCAL) 	    verify_local_live_at_start (tmp, bb); 	}
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|COPY_REG_SET
argument_list|(
name|tmp
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|propagate_block
argument_list|(
name|bb
argument_list|,
name|tmp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|stabilized_prop_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|extent
operator|==
name|UPDATE_LIFE_LOCAL
condition|)
name|verify_local_live_at_start
argument_list|(
name|tmp
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
block|}
name|FREE_REG_SET
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_flags
operator|&
name|PROP_REG_INFO
condition|)
block|{
comment|/* The only pseudos that are live at the beginning of the function 	 are those that were not set anywhere in the function.  local-alloc 	 doesn't know how to handle these correctly, so mark them as not 	 local to any one basic block.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|ENTRY_BLOCK_PTR->global_live_at_end
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; }
argument_list|)
empty_stmt|;
comment|/* We have a problem with any pseudoreg that lives across the setjmp. 	 ANSI says that if a user variable does not change in value between 	 the setjmp and the longjmp, then the longjmp preserves it.  This 	 includes longjmp from a place where the pseudo appears dead. 	 (In principle, the value still exists if it is in scope.) 	 If the pseudo goes in a hard reg, some other value may occupy 	 that hard reg where this pseudo is dead, thus clobbering the pseudo. 	 Conclusion: such a pseudo must not go in a hard reg.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|regs_live_at_setjmp
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 				   if (regno_reg_rtx[i] !=
literal|0
argument|) 				     { 				       REG_LIVE_LENGTH (i) = -
literal|1
argument|; 				       REG_BASIC_BLOCK (i) = REG_BLOCK_UNKNOWN; 				     } 				 }
argument_list|)
empty_stmt|;
block|}
name|timevar_pop
argument_list|(
operator|(
name|extent
operator|==
name|UPDATE_LIFE_LOCAL
operator|||
name|blocks
operator|)
condition|?
name|TV_LIFE_UPDATE
else|:
name|TV_LIFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndead
operator|&&
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"deleted %i dead insns\n"
argument_list|,
name|ndead
argument_list|)
expr_stmt|;
return|return
name|ndead
return|;
block|}
end_function

begin_comment
comment|/* Update life information in all blocks where BB_DIRTY is set.  */
end_comment

begin_function
name|int
name|update_life_info_in_dirty_blocks
parameter_list|(
name|enum
name|update_life_extent
name|extent
parameter_list|,
name|int
name|prop_flags
parameter_list|)
block|{
name|sbitmap
name|update_life_blocks
init|=
name|sbitmap_alloc
argument_list|(
name|last_basic_block
argument_list|)
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|sbitmap_zero
argument_list|(
name|update_life_blocks
argument_list|)
expr_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
if|if
condition|(
name|extent
operator|==
name|UPDATE_LIFE_LOCAL
condition|)
block|{
if|if
condition|(
name|bb
operator|->
name|flags
operator|&
name|BB_DIRTY
condition|)
block|{
name|SET_BIT
argument_list|(
name|update_life_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ??? Bootstrap with -march=pentium4 fails to terminate 	     with only a partial life update.  */
name|SET_BIT
argument_list|(
name|update_life_blocks
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|flags
operator|&
name|BB_DIRTY
condition|)
name|n
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
condition|)
name|retval
operator|=
name|update_life_info
argument_list|(
name|update_life_blocks
argument_list|,
name|extent
argument_list|,
name|prop_flags
argument_list|)
expr_stmt|;
name|sbitmap_free
argument_list|(
name|update_life_blocks
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Free the variables allocated by find_basic_blocks.     KEEP_HEAD_END_P is nonzero if basic_block_info is not to be freed.  */
end_comment

begin_function
name|void
name|free_basic_block_vars
parameter_list|(
name|int
name|keep_head_end_p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|keep_head_end_p
condition|)
block|{
if|if
condition|(
name|basic_block_info
condition|)
block|{
name|clear_edges
argument_list|()
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|basic_block_info
argument_list|)
expr_stmt|;
block|}
name|n_basic_blocks
operator|=
literal|0
expr_stmt|;
name|last_basic_block
operator|=
literal|0
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|global_live_at_end
operator|=
name|NULL
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|global_live_at_start
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete any insns that copy a register to itself.  */
end_comment

begin_function
name|int
name|delete_noop_moves
parameter_list|(
name|rtx
name|f
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|int
name|nnoops
init|=
literal|0
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|noop_move_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* If we're about to remove the first insn of a libcall 		 then move the libcall note to the next real insn and 		 update the retval note.  */
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|&&
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|!=
name|insn
condition|)
block|{
name|rtx
name|new_libcall_insn
init|=
name|next_real_insn
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|retval_note
init|=
name|find_reg_note
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|REG_NOTES
argument_list|(
name|new_libcall_insn
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|REG_LIBCALL
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|new_libcall_insn
argument_list|)
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|retval_note
argument_list|,
literal|0
argument_list|)
operator|=
name|new_libcall_insn
expr_stmt|;
block|}
name|delete_insn_and_edges
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|nnoops
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nnoops
operator|&&
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"deleted %i noop moves"
argument_list|,
name|nnoops
argument_list|)
expr_stmt|;
return|return
name|nnoops
return|;
block|}
end_function

begin_comment
comment|/* Delete any jump tables never referenced.  We can't delete them at the    time of removing tablejump insn as they are referenced by the preceding    insns computing the destination, so we delay deleting and garbagecollect    them once life information is computed.  */
end_comment

begin_function
name|void
name|delete_dead_jumptables
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|LABEL_NUSES
argument_list|(
name|insn
argument_list|)
operator|==
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
if|if
condition|(
name|rtl_dump_file
condition|)
name|fprintf
argument_list|(
name|rtl_dump_file
argument_list|,
literal|"Dead jumptable %i removed\n"
argument_list|,
name|INSN_UID
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Determine if the stack pointer is constant over the life of the function.    Only useful before prologues have been emitted.  */
end_comment

begin_function
specifier|static
name|void
name|notice_stack_pointer_modification_1
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|pat
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|x
operator|==
name|stack_pointer_rtx
comment|/* The stack pointer is only modified indirectly as the result 	 of a push until later in flow.  See the comments in rtl.texi 	 regarding Embedded Side-Effects on Addresses.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'a'
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
condition|)
name|current_function_sp_is_unchanging
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notice_stack_pointer_modification
parameter_list|(
name|rtx
name|f
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
comment|/* Assume that the stack pointer is unchanging if alloca hasn't      been used.  */
name|current_function_sp_is_unchanging
operator|=
operator|!
name|current_function_calls_alloca
expr_stmt|;
if|if
condition|(
operator|!
name|current_function_sp_is_unchanging
condition|)
return|return;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* Check if insn modifies the stack pointer.  */
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|notice_stack_pointer_modification_1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_function_sp_is_unchanging
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Mark a register in SET.  Hard registers in large modes get all    of their component registers set as well.  */
end_comment

begin_function
specifier|static
name|void
name|mark_reg
parameter_list|(
name|rtx
name|reg
parameter_list|,
name|void
modifier|*
name|xset
parameter_list|)
block|{
name|regset
name|set
init|=
operator|(
name|regset
operator|)
name|xset
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|==
name|BLKmode
condition|)
name|abort
argument_list|()
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|regno
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark those regs which are needed at the end of the function as live    at the end of the last basic block.  */
end_comment

begin_function
specifier|static
name|void
name|mark_regs_live_at_end
parameter_list|(
name|regset
name|set
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* If exiting needs the right stack value, consider the stack pointer      live at the end of the function.  */
if|if
condition|(
operator|(
name|HAVE_epilogue
operator|&&
name|epilogue_completed
operator|)
operator|||
operator|!
name|EXIT_IGNORE_STACK
operator|||
operator|(
operator|!
name|FRAME_POINTER_REQUIRED
operator|&&
operator|!
name|current_function_calls_alloca
operator|&&
name|flag_omit_frame_pointer
operator|)
operator|||
name|current_function_sp_is_unchanging
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the frame pointer if needed at the end of the function.  If      we end up eliminating it, it will be removed from the live list      of each basic block by reload.  */
if|if
condition|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
comment|/* If they are different, also mark the hard frame pointer as live.  */
if|if
condition|(
operator|!
name|LOCAL_REGNO
argument_list|(
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|PIC_OFFSET_TABLE_REG_CALL_CLOBBERED
comment|/* Many architectures have a GP register even without flag_pic.      Assume the pic register is not in use, or will be handled by      other means, if it is not fixed.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|!=
name|INVALID_REGNUM
operator|&&
name|fixed_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Mark all global registers, and all registers used by the epilogue      as being live at the end of the function since they may be      referenced by our caller.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
operator|||
name|EPILOGUE_USES
argument_list|(
name|i
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|HAVE_epilogue
operator|&&
name|epilogue_completed
condition|)
block|{
comment|/* Mark all call-saved registers that we actually used.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regs_ever_live
index|[
name|i
index|]
operator|&&
operator|!
name|LOCAL_REGNO
argument_list|(
name|i
argument_list|)
operator|&&
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|EH_RETURN_DATA_REGNO
comment|/* Mark the registers that will contain data for the handler.  */
if|if
condition|(
name|reload_completed
operator|&&
name|current_function_calls_eh_return
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
operator|++
name|i
control|)
block|{
name|unsigned
name|regno
init|=
name|EH_RETURN_DATA_REGNO
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|INVALID_REGNUM
condition|)
break|break;
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EH_RETURN_STACKADJ_RTX
if|if
condition|(
operator|(
operator|!
name|HAVE_epilogue
operator|||
operator|!
name|epilogue_completed
operator|)
operator|&&
name|current_function_calls_eh_return
condition|)
block|{
name|rtx
name|tmp
init|=
name|EH_RETURN_STACKADJ_RTX
decl_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|REG_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|mark_reg
argument_list|(
name|tmp
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EH_RETURN_HANDLER_RTX
if|if
condition|(
operator|(
operator|!
name|HAVE_epilogue
operator|||
operator|!
name|epilogue_completed
operator|)
operator|&&
name|current_function_calls_eh_return
condition|)
block|{
name|rtx
name|tmp
init|=
name|EH_RETURN_HANDLER_RTX
decl_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|REG_P
argument_list|(
name|tmp
argument_list|)
condition|)
name|mark_reg
argument_list|(
name|tmp
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Mark function return value.  */
name|diddle_return_value
argument_list|(
name|mark_reg
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Propagate global life info around the graph of basic blocks.  Begin    considering blocks with their corresponding bit set in BLOCKS_IN.    If BLOCKS_IN is null, consider it the universal set.     BLOCKS_OUT is set for every block that was changed.  */
end_comment

begin_function
specifier|static
name|void
name|calculate_global_regs_live
parameter_list|(
name|sbitmap
name|blocks_in
parameter_list|,
name|sbitmap
name|blocks_out
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|basic_block
modifier|*
name|queue
decl_stmt|,
modifier|*
name|qhead
decl_stmt|,
modifier|*
name|qtail
decl_stmt|,
modifier|*
name|qend
decl_stmt|,
name|bb
decl_stmt|;
name|regset
name|tmp
decl_stmt|,
name|new_live_at_end
decl_stmt|,
name|invalidated_by_call
decl_stmt|;
name|regset_head
name|tmp_head
decl_stmt|,
name|invalidated_by_call_head
decl_stmt|;
name|regset_head
name|new_live_at_end_head
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Some passes used to forget clear aux field of basic block causing      sick behavior here.  */
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
if|if
condition|(
name|bb
operator|->
name|aux
condition|)
name|abort
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|tmp
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|tmp_head
argument_list|)
expr_stmt|;
name|new_live_at_end
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|new_live_at_end_head
argument_list|)
expr_stmt|;
name|invalidated_by_call
operator|=
name|INITIALIZE_REG_SET
argument_list|(
name|invalidated_by_call_head
argument_list|)
expr_stmt|;
comment|/* Inconveniently, this is only readily available in hard reg set form.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|invalidated_by_call
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Create a worklist.  Allocate an extra slot for ENTRY_BLOCK, and one      because the `head == tail' style test for an empty queue doesn't      work with a full queue.  */
name|queue
operator|=
name|xmalloc
argument_list|(
operator|(
name|n_basic_blocks
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|queue
argument_list|)
argument_list|)
expr_stmt|;
name|qtail
operator|=
name|queue
expr_stmt|;
name|qhead
operator|=
name|qend
operator|=
name|queue
operator|+
name|n_basic_blocks
operator|+
literal|2
expr_stmt|;
comment|/* Queue the blocks set in the initial mask.  Do this in reverse block      number order so that we are more likely for the first round to do      useful work.  We use AUX non-null to flag that the block is queued.  */
if|if
condition|(
name|blocks_in
condition|)
block|{
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|blocks_in
argument_list|,
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
operator|*
operator|--
name|qhead
operator|=
name|bb
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
block|}
block|}
else|else
block|{
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
operator|*
operator|--
name|qhead
operator|=
name|bb
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
block|}
block|}
comment|/* We clean aux when we remove the initially-enqueued bbs, but we      don't enqueue ENTRY and EXIT initially, so clean them upfront and      unconditionally.  */
name|ENTRY_BLOCK_PTR
operator|->
name|aux
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|blocks_out
condition|)
name|sbitmap_zero
argument_list|(
name|blocks_out
argument_list|)
expr_stmt|;
comment|/* We work through the queue until there are no more blocks.  What      is live at the end of this block is precisely the union of what      is live at the beginning of all its successors.  So, we set its      GLOBAL_LIVE_AT_END field based on the GLOBAL_LIVE_AT_START field      for its successors.  Then, we compute GLOBAL_LIVE_AT_START for      this block by walking through the instructions in this block in      reverse order and updating as we go.  If that changed      GLOBAL_LIVE_AT_START, we add the predecessors of the block to the      queue; they will now need to recalculate GLOBAL_LIVE_AT_END.       We are guaranteed to terminate, because GLOBAL_LIVE_AT_START      never shrinks.  If a register appears in GLOBAL_LIVE_AT_START, it      must either be live at the end of the block, or used within the      block.  In the latter case, it will certainly never disappear      from GLOBAL_LIVE_AT_START.  In the former case, the register      could go away only if it disappeared from GLOBAL_LIVE_AT_START      for one of the successor blocks.  By induction, that cannot      occur.  */
while|while
condition|(
name|qhead
operator|!=
name|qtail
condition|)
block|{
name|int
name|rescan
decl_stmt|,
name|changed
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|bb
operator|=
operator|*
name|qhead
operator|++
expr_stmt|;
if|if
condition|(
name|qhead
operator|==
name|qend
condition|)
name|qhead
operator|=
name|queue
expr_stmt|;
name|bb
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
comment|/* Begin by propagating live_at_start from the successor blocks.  */
name|CLEAR_REG_SET
argument_list|(
name|new_live_at_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|succ
condition|)
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|basic_block
name|sb
init|=
name|e
operator|->
name|dest
decl_stmt|;
comment|/* Call-clobbered registers die across exception and 	       call edges.  */
comment|/* ??? Abnormal call edges ignored for the moment, as this gets 	       confused by sibling call edges, which crashes reg-stack.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
block|{
name|bitmap_operation
argument_list|(
name|tmp
argument_list|,
name|sb
operator|->
name|global_live_at_start
argument_list|,
name|invalidated_by_call
argument_list|,
name|BITMAP_AND_COMPL
argument_list|)
expr_stmt|;
name|IOR_REG_SET
argument_list|(
name|new_live_at_end
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|IOR_REG_SET
argument_list|(
name|new_live_at_end
argument_list|,
name|sb
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
comment|/* If a target saves one register in another (instead of on 	       the stack) the save register will need to be live for EH.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_EH
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|EH_USES
argument_list|(
name|i
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|new_live_at_end
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This might be a noreturn function that throws.  And 	     even if it isn't, getting the unwind info right helps 	     debugging.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|EH_USES
argument_list|(
name|i
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|new_live_at_end
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* The all-important stack pointer must always be live.  */
name|SET_REGNO_REG_SET
argument_list|(
name|new_live_at_end
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
comment|/* Before reload, there are a few registers that must be forced 	 live everywhere -- which might not already be the case for 	 blocks within infinite loops.  */
if|if
condition|(
operator|!
name|reload_completed
condition|)
block|{
comment|/* Any reference to any pseudo before reload is a potential 	     reference of the frame pointer.  */
name|SET_REGNO_REG_SET
argument_list|(
name|new_live_at_end
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
comment|/* Pseudos with argument area equivalences may require 	     reloading via the argument pointer.  */
if|if
condition|(
name|fixed_regs
index|[
name|ARG_POINTER_REGNUM
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|new_live_at_end
argument_list|,
name|ARG_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Any constant, or pseudo with constant equivalences, may 	     require reloading from memory using the pic register.  */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|PIC_OFFSET_TABLE_REGNUM
operator|!=
name|INVALID_REGNUM
operator|&&
name|fixed_regs
index|[
name|PIC_OFFSET_TABLE_REGNUM
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|new_live_at_end
argument_list|,
name|PIC_OFFSET_TABLE_REGNUM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|==
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|new_live_at_end
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* On our first pass through this block, we'll go ahead and continue. 	 Recognize first pass by local_set NULL.  On subsequent passes, we 	 get to skip out early if live_at_end wouldn't have changed.  */
if|if
condition|(
name|bb
operator|->
name|local_set
operator|==
name|NULL
condition|)
block|{
name|bb
operator|->
name|local_set
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|bb
operator|->
name|cond_local_set
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|rescan
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If any bits were removed from live_at_end, we'll have to 	     rescan the block.  This wouldn't be necessary if we had 	     precalculated local_live, however with PROP_SCAN_DEAD_CODE 	     local_live is really dependent on live_at_end.  */
name|CLEAR_REG_SET
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|rescan
operator|=
name|bitmap_operation
argument_list|(
name|tmp
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|new_live_at_end
argument_list|,
name|BITMAP_AND_COMPL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rescan
condition|)
block|{
comment|/* If any of the registers in the new live_at_end set are 		 conditionally set in this basic block, we must rescan. 	         This is because conditional lifetimes at the end of the 		 block do not just take the live_at_end set into account, 		 but also the liveness at the start of each successor 		 block.  We can miss changes in those sets if we only 		 compare the new live_at_end against the previous one.  */
name|CLEAR_REG_SET
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|rescan
operator|=
name|bitmap_operation
argument_list|(
name|tmp
argument_list|,
name|new_live_at_end
argument_list|,
name|bb
operator|->
name|cond_local_set
argument_list|,
name|BITMAP_AND
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rescan
condition|)
block|{
comment|/* Find the set of changed bits.  Take this opportunity 		 to notice that this set is empty and early out.  */
name|CLEAR_REG_SET
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|changed
operator|=
name|bitmap_operation
argument_list|(
name|tmp
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|new_live_at_end
argument_list|,
name|BITMAP_XOR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
continue|continue;
comment|/* If any of the changed bits overlap with local_set, 		 we'll have to rescan the block.  Detect overlap by 		 the AND with ~local_set turning off bits.  */
name|rescan
operator|=
name|bitmap_operation
argument_list|(
name|tmp
argument_list|,
name|tmp
argument_list|,
name|bb
operator|->
name|local_set
argument_list|,
name|BITMAP_AND_COMPL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Let our caller know that BB changed enough to require its 	 death notes updated.  */
if|if
condition|(
name|blocks_out
condition|)
name|SET_BIT
argument_list|(
name|blocks_out
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rescan
condition|)
block|{
comment|/* Add to live_at_start the set of all registers in 	     new_live_at_end that aren't in the old live_at_end.  */
name|bitmap_operation
argument_list|(
name|tmp
argument_list|,
name|new_live_at_end
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|BITMAP_AND_COMPL
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|new_live_at_end
argument_list|)
expr_stmt|;
name|changed
operator|=
name|bitmap_operation
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|tmp
argument_list|,
name|BITMAP_IOR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|changed
condition|)
continue|continue;
block|}
else|else
block|{
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|new_live_at_end
argument_list|)
expr_stmt|;
comment|/* Rescan the block insn by insn to turn (a copy of) live_at_end 	     into live_at_start.  */
name|propagate_block
argument_list|(
name|bb
argument_list|,
name|new_live_at_end
argument_list|,
name|bb
operator|->
name|local_set
argument_list|,
name|bb
operator|->
name|cond_local_set
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* If live_at start didn't change, no need to go farther.  */
if|if
condition|(
name|REG_SET_EQUAL_P
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|new_live_at_end
argument_list|)
condition|)
continue|continue;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|new_live_at_end
argument_list|)
expr_stmt|;
block|}
comment|/* Queue all predecessors of BB so that we may re-examine 	 their live_at_end.  */
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|basic_block
name|pb
init|=
name|e
operator|->
name|src
decl_stmt|;
if|if
condition|(
name|pb
operator|->
name|aux
operator|==
name|NULL
condition|)
block|{
operator|*
name|qtail
operator|++
operator|=
name|pb
expr_stmt|;
if|if
condition|(
name|qtail
operator|==
name|qend
condition|)
name|qtail
operator|=
name|queue
expr_stmt|;
name|pb
operator|->
name|aux
operator|=
name|pb
expr_stmt|;
block|}
block|}
block|}
name|FREE_REG_SET
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|new_live_at_end
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|invalidated_by_call
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocks_out
condition|)
block|{
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|blocks_out
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	  basic_block bb = BASIC_BLOCK (i); 	  FREE_REG_SET (bb->local_set); 	  FREE_REG_SET (bb->cond_local_set); 	}
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|FREE_REG_SET
argument_list|(
name|bb
operator|->
name|local_set
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|bb
operator|->
name|cond_local_set
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This structure is used to pass parameters to and from the    the function find_regno_partial(). It is used to pass in the    register number we are looking, as well as to return any rtx    we find.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|regno_to_find
decl_stmt|;
name|rtx
name|retval
decl_stmt|;
block|}
name|find_regno_partial_param
typedef|;
end_typedef

begin_comment
comment|/* Find the rtx for the reg numbers specified in 'data' if it is    part of an expression which only uses part of the register.  Return    it in the structure passed in.  */
end_comment

begin_function
specifier|static
name|int
name|find_regno_partial
parameter_list|(
name|rtx
modifier|*
name|ptr
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|find_regno_partial_param
modifier|*
name|param
init|=
operator|(
name|find_regno_partial_param
operator|*
operator|)
name|data
decl_stmt|;
name|unsigned
name|reg
init|=
name|param
operator|->
name|regno_to_find
decl_stmt|;
name|param
operator|->
name|retval
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
name|NULL_RTX
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
case|case
name|STRICT_LOW_PART
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
operator|*
name|ptr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
operator|*
name|ptr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|reg
condition|)
block|{
name|param
operator|->
name|retval
operator|=
name|XEXP
argument_list|(
operator|*
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
operator|*
name|ptr
argument_list|)
argument_list|)
operator|==
name|reg
condition|)
block|{
name|param
operator|->
name|retval
operator|=
name|SUBREG_REG
argument_list|(
operator|*
name|ptr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process all immediate successors of the entry block looking for pseudo    registers which are live on entry. Find all of those whose first    instance is a partial register reference of some kind, and initialize    them to 0 after the entry block.  This will prevent bit sets within    registers whose value is unknown, and may contain some kind of sticky    bits we don't want.  */
end_comment

begin_function
name|int
name|initialize_uninitialized_subregs
parameter_list|(
name|void
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|did_something
init|=
literal|0
decl_stmt|;
name|find_regno_partial_param
name|param
decl_stmt|;
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|regset
name|map
init|=
name|bb
operator|->
name|global_live_at_start
decl_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|map
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|reg
argument_list|,
argument|{ 	  int uid = REGNO_FIRST_UID (reg); 	  rtx i;
comment|/* Find an insn which mentions the register we are looking for. 	     Its preferable to have an instance of the register's rtl since 	     there may be various flags set which we need to duplicate. 	     If we can't find it, its probably an automatic whose initial 	     value doesn't matter, or hopefully something we don't care about.  */
argument|for (i = get_insns (); i&& INSN_UID (i) != uid; i = NEXT_INSN (i)) 	    ; 	  if (i != NULL_RTX) 	    {
comment|/* Found the insn, now get the REG rtx, if we can.  */
argument|param.regno_to_find = reg; 	      for_each_rtx (&i, find_regno_partial,&param); 	      if (param.retval != NULL_RTX) 		{ 		  start_sequence (); 		  emit_move_insn (param.retval, 				  CONST0_RTX (GET_MODE (param.retval))); 		  insn = get_insns (); 		  end_sequence (); 		  insert_insn_on_edge (insn, e); 		  did_something =
literal|1
argument|; 		} 	    } 	}
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|did_something
condition|)
name|commit_edge_insertions
argument_list|()
expr_stmt|;
return|return
name|did_something
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of life analysis.  */
end_comment

begin_comment
comment|/* Allocate the permanent data structures that represent the results    of life analysis.  Not static since used also for stupid life analysis.  */
end_comment

begin_function
name|void
name|allocate_bb_life_data
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
name|bb
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|bb
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
block|}
name|regs_live_at_setjmp
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|allocate_reg_life_data
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|max_regno
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
comment|/* Recalculate the register space, in case it has grown.  Old style      vector oriented regsets would set regset_{size,bytes} here also.  */
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Reset all the data we'll collect in propagate_block and its      subroutines.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
block|{
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_FREQ
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|=
name|REG_BLOCK_UNKNOWN
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete dead instructions for propagate_block.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_block_delete_insn
parameter_list|(
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|inote
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
comment|/* If the insn referred to a label, and that label was attached to      an ADDR_VEC, it's safe to delete the ADDR_VEC.  In fact, it's      pretty much mandatory to delete it, because the ADDR_VEC may be      referencing labels that no longer exist.       INSN may reference a deleted label, particularly when a jump      table has been optimized into a direct jump.  There's no      real good way to fix up the reference to the deleted label      when the label is deleted, so we just allow it here.  */
if|if
condition|(
name|inote
operator|&&
name|GET_CODE
argument_list|(
name|inote
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|inote
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|next
decl_stmt|;
comment|/* The label may be forced if it has been put in the constant 	 pool.  If that is the only use we must discard the table 	 jump following it, but not the label itself.  */
if|if
condition|(
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|==
literal|1
operator|+
name|LABEL_PRESERVE_P
argument_list|(
name|label
argument_list|)
operator|&&
operator|(
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|label
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|int
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|--
expr_stmt|;
name|delete_insn_and_edges
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|ndead
operator|++
expr_stmt|;
block|}
block|}
name|delete_insn_and_edges
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|ndead
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete dead libcalls for propagate_block.  Return the insn    before the libcall.  */
end_comment

begin_function
specifier|static
name|rtx
name|propagate_block_delete_libcall
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|note
parameter_list|)
block|{
name|rtx
name|first
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|before
init|=
name|PREV_INSN
argument_list|(
name|first
argument_list|)
decl_stmt|;
name|delete_insn_chain_and_edges
argument_list|(
name|first
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|ndead
operator|++
expr_stmt|;
return|return
name|before
return|;
block|}
end_function

begin_comment
comment|/* Update the life-status of regs for one insn.  Return the previous insn.  */
end_comment

begin_function
name|rtx
name|propagate_one_insn
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|pbi
operator|->
name|flags
decl_stmt|;
name|int
name|insn_is_dead
init|=
literal|0
decl_stmt|;
name|int
name|libcall_is_dead
init|=
literal|0
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
return|return
name|prev
return|;
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PROP_SCAN_DEAD_CODE
condition|)
block|{
name|insn_is_dead
operator|=
name|insn_dead_p
argument_list|(
name|pbi
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|libcall_is_dead
operator|=
operator|(
name|insn_is_dead
operator|&&
name|note
operator|!=
literal|0
operator|&&
name|libcall_dead_p
argument_list|(
name|pbi
argument_list|,
name|note
argument_list|,
name|insn
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* If an instruction consists of just dead store(s) on final pass,      delete it.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|PROP_KILL_DEAD_CODE
operator|)
operator|&&
name|insn_is_dead
condition|)
block|{
comment|/* If we're trying to delete a prologue or epilogue instruction 	 that isn't flagged as possibly being dead, something is wrong. 	 But if we are keeping the stack pointer depressed, we might well 	 be deleting insns that are used to compute the amount to update 	 it by, so they are fine.  */
if|if
condition|(
name|reload_completed
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|(
name|TYPE_RETURNS_STACK_DEPRESSED
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|HAVE_epilogue
operator|||
name|HAVE_prologue
operator|)
operator|&&
name|prologue_epilogue_contains
argument_list|(
name|insn
argument_list|)
operator|)
operator|||
operator|(
name|HAVE_sibcall_epilogue
operator|&&
name|sibcall_epilogue_contains
argument_list|(
name|insn
argument_list|)
operator|)
operator|)
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_MAYBE_DEAD
argument_list|,
name|NULL_RTX
argument_list|)
operator|==
literal|0
condition|)
name|fatal_insn
argument_list|(
literal|"Attempt to delete prologue/epilogue insn:"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Record sets.  Do this even for dead instructions, since they 	 would have killed the values if they hadn't been deleted.  */
name|mark_set_regs
argument_list|(
name|pbi
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* CC0 is now known to be dead.  Either this insn used it, 	 in which case it doesn't anymore, or clobbered it, 	 so the next insn can't use it.  */
name|pbi
operator|->
name|cc0_live
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|libcall_is_dead
condition|)
name|prev
operator|=
name|propagate_block_delete_libcall
argument_list|(
name|insn
argument_list|,
name|note
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* If INSN contains a RETVAL note and is dead, but the libcall 	   as a whole is not dead, then we want to remove INSN, but 	   not the whole libcall sequence.  	   However, we need to also remove the dangling REG_LIBCALL 	   note so that we do not have mis-matched LIBCALL/RETVAL 	   notes.  In theory we could find a new location for the 	   REG_RETVAL note, but it hardly seems worth the effort.  	   NOTE at this point will be the RETVAL note if it exists.  */
if|if
condition|(
name|note
condition|)
block|{
name|rtx
name|libcall_note
decl_stmt|;
name|libcall_note
operator|=
name|find_reg_note
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|libcall_note
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly if INSN contains a LIBCALL note, remove the 	     dangling REG_RETVAL note.  */
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
condition|)
block|{
name|rtx
name|retval_note
decl_stmt|;
name|retval_note
operator|=
name|find_reg_note
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|remove_note
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|retval_note
argument_list|)
expr_stmt|;
block|}
comment|/* Now delete INSN.  */
name|propagate_block_delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
comment|/* See if this is an increment or decrement that can be merged into      a following memory address.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
block|{
name|rtx
name|x
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Does this instruction increment or decrement a register?  */
if|if
condition|(
operator|(
name|flags
operator|&
name|PROP_AUTOINC
operator|)
operator|&&
name|x
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
comment|/* Ok, look for a following memory ref we can combine with. 	   If one is found, change the memory ref to a PRE_INC 	   or PRE_DEC, cancel this insn, and return 1. 	   Return 0 if nothing has been done.  */
operator|&&
name|try_pre_increment_1
argument_list|(
name|pbi
argument_list|,
name|insn
argument_list|)
condition|)
return|return
name|prev
return|;
block|}
endif|#
directive|endif
comment|/* AUTO_INC_DEC */
name|CLEAR_REG_SET
argument_list|(
name|pbi
operator|->
name|new_set
argument_list|)
expr_stmt|;
comment|/* If this is not the final pass, and this insn is copying the value of      a library call and it's dead, don't scan the insns that perform the      library call, so that the call's arguments are not marked live.  */
if|if
condition|(
name|libcall_is_dead
condition|)
block|{
comment|/* Record the death of the dest reg.  */
name|mark_set_regs
argument_list|(
name|pbi
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
comment|/* We have an insn to pop a constant amount off the stack.        (Such insns use PLUS regardless of the direction of the stack,        and any insn to adjust the stack by a constant is always a pop.)        These insns, if not dead stores, have no effect on life, though        they do have an effect on the memory stores we are tracking.  */
name|invalidate_mems_from_set
argument_list|(
name|pbi
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
else|else
block|{
name|rtx
name|note
decl_stmt|;
comment|/* Any regs live at the time of a call instruction must not go 	 in a register clobbered by calls.  Find all regs now live and 	 record this for them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|(
name|flags
operator|&
name|PROP_REG_INFO
operator|)
condition|)
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|pbi->reg_live
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ REG_N_CALLS_CROSSED (i)++; }
argument_list|)
empty_stmt|;
comment|/* Record sets.  Do this even for dead instructions, since they 	 would have killed the values if they hadn't been deleted.  */
name|mark_set_regs
argument_list|(
name|pbi
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|regset
name|live_at_end
decl_stmt|;
name|bool
name|sibcall_p
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|cond
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cond
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|cond
operator|=
name|COND_EXEC_TEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Non-constant calls clobber memory, constant calls do not 	     clobber memory, though they may clobber outgoing arguments 	     on the stack.  */
if|if
condition|(
operator|!
name|CONST_OR_PURE_CALL_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|pbi
operator|->
name|mem_set_list
argument_list|)
expr_stmt|;
name|pbi
operator|->
name|mem_set_list_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|invalidate_mems_from_set
argument_list|(
name|pbi
argument_list|,
name|stack_pointer_rtx
argument_list|)
expr_stmt|;
comment|/* There may be extra registers to be clobbered.  */
for|for
control|(
name|note
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CLOBBER
condition|)
name|mark_set_1
argument_list|(
name|pbi
argument_list|,
name|CLOBBER
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|,
name|pbi
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* Calls change all call-used and global registers; sibcalls do not 	     clobber anything that must be preserved at end-of-function, 	     except for return values.  */
name|sibcall_p
operator|=
name|SIBLING_CALL_P
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|live_at_end
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|global_live_at_start
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TEST_HARD_REG_BIT
argument_list|(
name|regs_invalidated_by_call
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
operator|(
name|sibcall_p
operator|&&
name|REGNO_REG_SET_P
argument_list|(
name|live_at_end
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|refers_to_regno_p
argument_list|(
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|current_function_return_rtx
argument_list|,
operator|(
name|rtx
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|global_regs
index|[
name|i
index|]
condition|?
name|SET
else|:
name|CLOBBER
decl_stmt|;
comment|/* We do not want REG_UNUSED notes for these registers.  */
name|mark_set_1
argument_list|(
name|pbi
argument_list|,
name|code
argument_list|,
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|,
name|pbi
operator|->
name|flags
operator|&
operator|~
operator|(
name|PROP_DEATH_NOTES
operator||
name|PROP_REG_INFO
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If an insn doesn't use CC0, it becomes dead since we assume 	 that every insn clobbers it.  So show it dead here; 	 mark_used_regs will set it live if it is referenced.  */
name|pbi
operator|->
name|cc0_live
operator|=
literal|0
expr_stmt|;
comment|/* Record uses.  */
if|if
condition|(
operator|!
name|insn_is_dead
condition|)
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PROP_EQUAL_NOTES
operator|)
operator|&&
operator|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|||
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUIV
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|)
condition|)
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Sometimes we may have inserted something before INSN (such as a move) 	 when we make an auto-inc.  So ensure we will scan those insns.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|insn_is_dead
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|int
name|i
decl_stmt|;
name|rtx
name|note
decl_stmt|,
name|cond
decl_stmt|;
name|cond
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|COND_EXEC
condition|)
name|cond
operator|=
name|COND_EXEC_TEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calls use their arguments, and may clobber memory which 	     address involves some register.  */
for|for
control|(
name|note
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
comment|/* We find USE or CLOBBER entities in a FUNCTION_USAGE list: both 	       of which mark_used_regs knows how to handle.  */
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* The stack ptr is used (honorarily) by a CALL insn.  */
name|SET_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
comment|/* Calls may also reference any of the global registers, 	     so they are made live.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
name|mark_used_reg
argument_list|(
name|pbi
argument_list|,
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* On final pass, update counts of how many insns in which each reg      is live.  */
if|if
condition|(
name|flags
operator|&
name|PROP_REG_INFO
condition|)
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|pbi->reg_live
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ REG_LIVE_LENGTH (i)++; }
argument_list|)
empty_stmt|;
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Initialize a propagate_block_info struct for public consumption.    Note that the structure itself is opaque to this file, but that    the user can use the regsets provided here.  */
end_comment

begin_function
name|struct
name|propagate_block_info
modifier|*
name|init_propagate_block_info
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|regset
name|live
parameter_list|,
name|regset
name|local_set
parameter_list|,
name|regset
name|cond_local_set
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|propagate_block_info
modifier|*
name|pbi
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pbi
argument_list|)
argument_list|)
decl_stmt|;
name|pbi
operator|->
name|bb
operator|=
name|bb
expr_stmt|;
name|pbi
operator|->
name|reg_live
operator|=
name|live
expr_stmt|;
name|pbi
operator|->
name|mem_set_list
operator|=
name|NULL_RTX
expr_stmt|;
name|pbi
operator|->
name|mem_set_list_len
operator|=
literal|0
expr_stmt|;
name|pbi
operator|->
name|local_set
operator|=
name|local_set
expr_stmt|;
name|pbi
operator|->
name|cond_local_set
operator|=
name|cond_local_set
expr_stmt|;
name|pbi
operator|->
name|cc0_live
operator|=
literal|0
expr_stmt|;
name|pbi
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|PROP_LOG_LINKS
operator||
name|PROP_AUTOINC
operator|)
condition|)
name|pbi
operator|->
name|reg_next_use
operator|=
name|xcalloc
argument_list|(
name|max_reg_num
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pbi
operator|->
name|reg_next_use
operator|=
name|NULL
expr_stmt|;
name|pbi
operator|->
name|new_set
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
name|pbi
operator|->
name|reg_cond_dead
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_ints
argument_list|,
name|NULL
argument_list|,
name|free_reg_cond_life_info
argument_list|)
expr_stmt|;
name|pbi
operator|->
name|reg_cond_reg
operator|=
name|BITMAP_XMALLOC
argument_list|()
expr_stmt|;
comment|/* If this block ends in a conditional branch, for each register      live from one side of the branch and not the other, record the      register as conditionally dead.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|any_condjump_p
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
condition|)
block|{
name|regset_head
name|diff_head
decl_stmt|;
name|regset
name|diff
init|=
name|INITIALIZE_REG_SET
argument_list|(
name|diff_head
argument_list|)
decl_stmt|;
name|basic_block
name|bb_true
decl_stmt|,
name|bb_false
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Identify the successor blocks.  */
name|bb_true
operator|=
name|bb
operator|->
name|succ
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|!=
name|NULL
condition|)
block|{
name|bb_false
operator|=
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|dest
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|succ
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
block|{
name|basic_block
name|t
init|=
name|bb_false
decl_stmt|;
name|bb_false
operator|=
name|bb_true
expr_stmt|;
name|bb_true
operator|=
name|t
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* This can happen with a conditional jump to the next insn.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
operator|!=
name|BB_HEAD
argument_list|(
name|bb_true
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Simplest way to do nothing.  */
name|bb_false
operator|=
name|bb_true
expr_stmt|;
block|}
comment|/* Compute which register lead different lives in the successors.  */
if|if
condition|(
name|bitmap_operation
argument_list|(
name|diff
argument_list|,
name|bb_true
operator|->
name|global_live_at_start
argument_list|,
name|bb_false
operator|->
name|global_live_at_start
argument_list|,
name|BITMAP_XOR
argument_list|)
condition|)
block|{
comment|/* Extract the condition from the branch.  */
name|rtx
name|set_src
init|=
name|SET_SRC
argument_list|(
name|pc_set
argument_list|(
name|BB_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|cond_true
init|=
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|cond_true
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
condition|)
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* We can only track conditional lifetimes if the condition is 	     in the form of a comparison of a register against zero.   	     If the condition is more complex than that, then it is safe 	     not to record any information.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|XEXP
argument_list|(
name|cond_true
argument_list|,
literal|1
argument_list|)
operator|==
name|const0_rtx
condition|)
block|{
name|rtx
name|cond_false
init|=
name|gen_rtx_fmt_ee
argument_list|(
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|cond_true
argument_list|)
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|cond_true
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond_true
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|cond_true
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|set_src
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|PC
condition|)
block|{
name|rtx
name|t
init|=
name|cond_false
decl_stmt|;
name|cond_false
operator|=
name|cond_true
expr_stmt|;
name|cond_true
operator|=
name|t
expr_stmt|;
block|}
name|SET_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|reg_cond_reg
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each such register, mark it conditionally dead.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|diff
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 		   struct reg_cond_life_info *rcli; 		   rtx cond;  		   rcli = xmalloc (sizeof (*rcli));  		   if (REGNO_REG_SET_P (bb_true->global_live_at_start, i)) 		     cond = cond_false; 		   else 		     cond = cond_true; 		   rcli->condition = cond; 		   rcli->stores = const0_rtx; 		   rcli->orig_condition = cond;  		   splay_tree_insert (pbi->reg_cond_dead, i, 				      (splay_tree_value) rcli); 		 }
argument_list|)
empty_stmt|;
block|}
block|}
name|FREE_REG_SET
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* If this block has no successors, any stores to the frame that aren't      used later in the block are dead.  So make a pass over the block      recording any such that are made and show them dead at the end.  We do      a very conservative and simple job here.  */
if|if
condition|(
name|optimize
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|(
name|TYPE_RETURNS_STACK_DEPRESSED
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|flags
operator|&
name|PROP_SCAN_DEAD_STORES
operator|)
operator|&&
operator|(
name|bb
operator|->
name|succ
operator|==
name|NULL
operator|||
operator|(
name|bb
operator|->
name|succ
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
name|bb
operator|->
name|succ
operator|->
name|dest
operator|==
name|EXIT_BLOCK_PTR
operator|&&
operator|!
name|current_function_calls_eh_return
operator|)
operator|)
condition|)
block|{
name|rtx
name|insn
decl_stmt|,
name|set
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
init|;
name|insn
operator|!=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|INSN
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|mem
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|canon_mem
init|=
name|canon_rtx
argument_list|(
name|mem
argument_list|)
decl_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|canon_mem
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|canon_mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|canon_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|canon_mem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|)
condition|)
name|add_to_mem_set_list
argument_list|(
name|pbi
argument_list|,
name|canon_mem
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|pbi
return|;
block|}
end_function

begin_comment
comment|/* Release a propagate_block_info struct.  */
end_comment

begin_function
name|void
name|free_propagate_block_info
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|)
block|{
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|pbi
operator|->
name|mem_set_list
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|pbi
operator|->
name|new_set
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
name|splay_tree_delete
argument_list|(
name|pbi
operator|->
name|reg_cond_dead
argument_list|)
expr_stmt|;
name|BITMAP_XFREE
argument_list|(
name|pbi
operator|->
name|reg_cond_reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pbi
operator|->
name|reg_next_use
condition|)
name|free
argument_list|(
name|pbi
operator|->
name|reg_next_use
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pbi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the registers live at the beginning of a basic block BB from    those live at the end.     When called, REG_LIVE contains those live at the end.  On return, it    contains those live at the beginning.     LOCAL_SET, if non-null, will be set with all registers killed    unconditionally by this basic block.    Likewise, COND_LOCAL_SET, if non-null, will be set with all registers    killed conditionally by this basic block.  If there is any unconditional    set of a register, then the corresponding bit will be set in LOCAL_SET    and cleared in COND_LOCAL_SET.    It is valid for LOCAL_SET and COND_LOCAL_SET to be the same set.  In this    case, the resulting set will be equal to the union of the two sets that    would otherwise be computed.     Return nonzero if an INSN is deleted (i.e. by dead code removal).  */
end_comment

begin_function
name|int
name|propagate_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|regset
name|live
parameter_list|,
name|regset
name|local_set
parameter_list|,
name|regset
name|cond_local_set
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|propagate_block_info
modifier|*
name|pbi
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|prev
decl_stmt|;
name|int
name|changed
decl_stmt|;
name|pbi
operator|=
name|init_propagate_block_info
argument_list|(
name|bb
argument_list|,
name|live
argument_list|,
name|local_set
argument_list|,
name|cond_local_set
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PROP_REG_INFO
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Process the regs live at the end of the block. 	 Mark them as not local to any one basic block.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|live
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; }
argument_list|)
empty_stmt|;
block|}
comment|/* Scan the block an insn at a time from end to beginning.  */
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_END
argument_list|(
name|bb
argument_list|)
init|;
condition|;
name|insn
operator|=
name|prev
control|)
block|{
comment|/* If this is a call to `setjmp' et al, warn if any 	 non-volatile datum is live.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|PROP_REG_INFO
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_SETJMP
argument_list|,
name|NULL
argument_list|)
condition|)
name|IOR_REG_SET
argument_list|(
name|regs_live_at_setjmp
argument_list|,
name|pbi
operator|->
name|reg_live
argument_list|)
expr_stmt|;
name|prev
operator|=
name|propagate_one_insn
argument_list|(
name|pbi
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
name|changed
operator||=
name|insn
operator|!=
name|get_insns
argument_list|()
expr_stmt|;
else|else
name|changed
operator||=
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|!=
name|insn
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
name|free_propagate_block_info
argument_list|(
name|pbi
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X (the body of an insn, or part of it) is just dead stores    (SET expressions whose destinations are registers dead after the insn).    NEEDED is the regset that says which regs are alive after the insn.     Unless CALL_OK is nonzero, an insn is needed if it contains a CALL.     If X is the entire body of an insn, NOTES contains the reg notes    pertaining to the insn.  */
end_comment

begin_function
specifier|static
name|int
name|insn_dead_p
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|call_ok
parameter_list|,
name|rtx
name|notes
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Don't eliminate insns that may trap.  */
if|if
condition|(
name|flag_non_call_exceptions
operator|&&
name|may_trap_p
argument_list|(
name|x
argument_list|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* As flow is invoked after combine, we must take existing AUTO_INC      expressions into account.  */
for|for
control|(
init|;
name|notes
condition|;
name|notes
operator|=
name|XEXP
argument_list|(
name|notes
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|notes
argument_list|)
operator|==
name|REG_INC
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|notes
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Don't delete insns to set global regs.  */
if|if
condition|(
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
operator|||
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
endif|#
directive|endif
comment|/* If setting something that's a reg or part of one,      see if that register's altered value will be live.  */
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|rtx
name|r
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|CC0
condition|)
return|return
operator|!
name|pbi
operator|->
name|cc0_live
return|;
endif|#
directive|endif
comment|/* A SET that is a subroutine call cannot be dead.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
block|{
if|if
condition|(
operator|!
name|call_ok
condition|)
return|return
literal|0
return|;
block|}
comment|/* Don't eliminate loads from volatile memory or volatile asms.  */
elseif|else
if|if
condition|(
name|volatile_refs_p
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|rtx
name|temp
decl_stmt|,
name|canon_r
decl_stmt|;
if|if
condition|(
name|MEM_VOLATILE_P
argument_list|(
name|r
argument_list|)
operator|||
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|==
name|BLKmode
condition|)
return|return
literal|0
return|;
name|canon_r
operator|=
name|canon_rtx
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* Walk the set of memory locations we are currently tracking 	     and see if one is an identical match to this memory location. 	     If so, this memory write is dead (remember, we're walking 	     backwards from the end of the block to the start).  Since 	     rtx_equal_p does not check the alias set or flags, we also 	     must have the potential for them to conflict (anti_dependence).  */
for|for
control|(
name|temp
operator|=
name|pbi
operator|->
name|mem_set_list
init|;
name|temp
operator|!=
literal|0
condition|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|unchanging_anti_dependence
argument_list|(
name|r
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|mem
init|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|canon_r
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|canon_r
argument_list|)
argument_list|)
operator|<=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Check if memory reference matches an auto increment. Only 		   post increment/decrement or modify are valid.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_MODIFY
operator|)
operator|&&
name|GET_MODE
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
while|while
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|r
operator|=
name|XEXP
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|r
argument_list|)
decl_stmt|;
comment|/* Obvious.  */
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is a hard register, verify that subsequent 		 words are not needed.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|r
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|regno
operator|+
name|n
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* Don't delete insns to set global regs.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
comment|/* Make sure insns to set the stack pointer aren't deleted.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return
literal|0
return|;
comment|/* ??? These bits might be redundant with the force live bits 		 in calculate_global_regs_live.  We would delete from 		 sequential sets; whether this actually affects real code 		 for anything but the stack pointer I don't know.  */
comment|/* Make sure insns to set the frame pointer aren't deleted.  */
if|if
condition|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
if|if
condition|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
comment|/* Make sure insns to set arg pointer are never deleted 		 (if the arg pointer isn't fixed, there will be a USE 		 for it, so we can treat it normally).  */
if|if
condition|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Otherwise, the set is dead.  */
return|return
literal|1
return|;
block|}
block|}
block|}
comment|/* If performing several activities, insn is dead if each activity      is individually dead.  Also, CLOBBERs and USEs can be ignored; a      CLOBBER or USE that's inside a PARALLEL doesn't make the insn      worth keeping.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
operator|!
name|insn_dead_p
argument_list|(
name|pbi
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|call_ok
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/* A CLOBBER of a pseudo-register that is dead serves no purpose.  That      is not necessarily true for hard registers until after reload.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CLOBBER
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|reload_completed
operator|)
operator|&&
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* ??? A base USE is a historical relic.  It ought not be needed anymore.      Instances where it is still used are either (1) temporary and the USE      escaped the pass, (2) cruft and the USE need not be emitted anymore,      or (3) hiding bugs elsewhere that are not properly representing data      flow.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If INSN is the last insn in a libcall, and assuming INSN is dead,    return 1 if the entire library call is dead.    This is true if INSN copies a register (hard or pseudo)    and if the hard return reg of the call insn is dead.    (The caller should have tested the destination of the SET inside    INSN already for death.)     If this insn doesn't just copy a register, then we don't    have an ordinary libcall.  In that case, cse could not have    managed to substitute the source for the dest later on,    so we can assume the libcall is dead.     PBI is the block info giving pseudoregs live before this insn.    NOTE is the REG_RETVAL note of the insn.  */
end_comment

begin_function
specifier|static
name|int
name|libcall_dead_p
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|rtx
name|note
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|x
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|x
condition|)
block|{
name|rtx
name|r
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|call
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|call_pat
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find the call insn.  */
while|while
condition|(
name|call
operator|!=
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|call
argument_list|)
operator|!=
name|CALL_INSN
condition|)
name|call
operator|=
name|NEXT_INSN
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|/* If there is none, do nothing special, 	     since ordinary death handling can understand these insns.  */
if|if
condition|(
name|call
operator|==
name|insn
condition|)
return|return
literal|0
return|;
comment|/* See if the hard reg holding the value is dead. 	     If this is a PARALLEL, find the call within it.  */
name|call_pat
operator|=
name|PATTERN
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|call_pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|call_pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|call_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|call_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
break|break;
comment|/* This may be a library call that is returning a value 		 via invisible pointer.  Do nothing special, since 		 ordinary death handling can understand these insns.  */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|call_pat
operator|=
name|XVECEXP
argument_list|(
name|call_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|insn_dead_p
argument_list|(
name|pbi
argument_list|,
name|call_pat
argument_list|,
literal|1
argument_list|,
name|REG_NOTES
argument_list|(
name|call
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|call
condition|)
block|{
if|if
condition|(
operator|!
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|insn_dead_p
argument_list|(
name|pbi
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if register REGNO was used before it was set, i.e. if it is    live at function entry.  Don't count global register variables, variables    in registers that can be used for function arg passing, or variables in    fixed hard registers.  */
end_comment

begin_function
name|int
name|regno_uninitialized
parameter_list|(
name|unsigned
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
operator|||
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|global_regs
index|[
name|regno
index|]
operator|||
name|fixed_regs
index|[
name|regno
index|]
operator|||
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|REGNO_REG_SET_P
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|global_live_at_end
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* 1 if register REGNO was alive at a place where `setjmp' was called    and was set more than once or is an argument.    Such regs may be clobbered by `longjmp'.  */
end_comment

begin_function
name|int
name|regno_clobbered_at_setjmp
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|>
literal|1
operator|||
name|REGNO_REG_SET_P
argument_list|(
name|ENTRY_BLOCK_PTR
operator|->
name|global_live_at_end
argument_list|,
name|regno
argument_list|)
operator|)
operator|&&
name|REGNO_REG_SET_P
argument_list|(
name|regs_live_at_setjmp
argument_list|,
name|regno
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add MEM to PBI->MEM_SET_LIST.  MEM should be canonical.  Respect the    maximal list size; look for overlaps in mode and select the largest.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_mem_set_list
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|rtx
name|mem
parameter_list|)
block|{
name|rtx
name|i
decl_stmt|;
comment|/* We don't know how large a BLKmode store is, so we must not      take them into consideration.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
operator|==
name|BLKmode
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|pbi
operator|->
name|mem_set_list
init|;
name|i
condition|;
name|i
operator|=
name|XEXP
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|rtx
name|e
init|=
name|XEXP
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|e
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|e
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* If we must store a copy of the mem, we can just modify 		 the mode of the stored copy.  */
if|if
condition|(
name|pbi
operator|->
name|flags
operator|&
name|PROP_AUTOINC
condition|)
name|PUT_MODE
argument_list|(
name|e
argument_list|,
name|GET_MODE
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|XEXP
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
operator|=
name|mem
expr_stmt|;
block|}
return|return;
block|}
block|}
if|if
condition|(
name|pbi
operator|->
name|mem_set_list_len
operator|<
name|MAX_MEM_SET_LIST_LEN
condition|)
block|{
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Store a copy of mem, otherwise the address may be 	 scrogged by find_auto_inc.  */
if|if
condition|(
name|pbi
operator|->
name|flags
operator|&
name|PROP_AUTOINC
condition|)
name|mem
operator|=
name|shallow_copy_rtx
argument_list|(
name|mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pbi
operator|->
name|mem_set_list
operator|=
name|alloc_EXPR_LIST
argument_list|(
literal|0
argument_list|,
name|mem
argument_list|,
name|pbi
operator|->
name|mem_set_list
argument_list|)
expr_stmt|;
name|pbi
operator|->
name|mem_set_list_len
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* INSN references memory, possibly using autoincrement addressing modes.    Find any entries on the mem_set_list that need to be invalidated due    to an address change.  */
end_comment

begin_function
specifier|static
name|int
name|invalidate_mems_from_autoinc
parameter_list|(
name|rtx
modifier|*
name|px
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|rtx
name|x
init|=
operator|*
name|px
decl_stmt|;
name|struct
name|propagate_block_info
modifier|*
name|pbi
init|=
name|data
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'a'
condition|)
block|{
name|invalidate_mems_from_set
argument_list|(
name|pbi
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* EXP is a REG.  Remove any dependent entries from pbi->mem_set_list.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_mems_from_set
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|rtx
name|exp
parameter_list|)
block|{
name|rtx
name|temp
init|=
name|pbi
operator|->
name|mem_set_list
decl_stmt|;
name|rtx
name|prev
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|next
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|exp
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Splice this entry out of the list.  */
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|pbi
operator|->
name|mem_set_list
operator|=
name|next
expr_stmt|;
name|free_EXPR_LIST_node
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|pbi
operator|->
name|mem_set_list_len
operator|--
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process the registers that are set within X.  Their bits are set to    1 in the regset DEAD, because they are dead prior to this insn.     If INSN is nonzero, it is the insn being processed.     FLAGS is the set of operations to perform.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set_regs
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|cond
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|link
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|flags
init|=
name|pbi
operator|->
name|flags
decl_stmt|;
if|if
condition|(
name|insn
condition|)
for|for
control|(
name|link
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
operator|==
name|REG_INC
condition|)
name|mark_set_1
argument_list|(
name|pbi
argument_list|,
name|SET
argument_list|,
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|COND_EXEC
condition|?
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
else|:
name|NULL_RTX
operator|)
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|retry
label|:
switch|switch
condition|(
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|SET
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|flags
operator||=
name|PROP_ASM_SCAN
expr_stmt|;
comment|/* Fall through */
case|case
name|CLOBBER
case|:
name|mark_set_1
argument_list|(
name|pbi
argument_list|,
name|code
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
case|case
name|COND_EXEC
case|:
name|cond
operator|=
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
name|PARALLEL
case|:
block|{
name|int
name|i
decl_stmt|;
comment|/* We must scan forwards.  If we have an asm, we need to set 	   the PROP_ASM_SCAN flag before scanning the clobbers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|sub
init|=
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
operator|=
name|GET_CODE
argument_list|(
name|sub
argument_list|)
condition|)
block|{
case|case
name|COND_EXEC
case|:
if|if
condition|(
name|cond
operator|!=
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|cond
operator|=
name|COND_EXEC_TEST
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|sub
operator|=
name|COND_EXEC_CODE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|SET
condition|)
goto|goto
name|mark_set
goto|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|CLOBBER
condition|)
goto|goto
name|mark_clob
goto|;
break|break;
case|case
name|SET
case|:
name|mark_set
label|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|sub
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|ASM_OPERANDS
condition|)
name|flags
operator||=
name|PROP_ASM_SCAN
expr_stmt|;
comment|/* Fall through */
case|case
name|CLOBBER
case|:
name|mark_clob
label|:
name|mark_set_1
argument_list|(
name|pbi
argument_list|,
name|code
argument_list|,
name|SET_DEST
argument_list|(
name|sub
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
name|flags
operator||=
name|PROP_ASM_SCAN
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Process a single set, which appears in INSN.  REG (which may not    actually be a REG, it may also be a SUBREG, PARALLEL, etc.) is    being set using the CODE (which may be SET, CLOBBER, or COND_EXEC).    If the set is conditional (because it appear in a COND_EXEC), COND    will be the condition.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set_1
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|enum
name|rtx_code
name|code
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
name|cond
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|regno_first
init|=
operator|-
literal|1
decl_stmt|,
name|regno_last
init|=
operator|-
literal|1
decl_stmt|;
name|unsigned
name|long
name|not_dead
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Modifying just one hardware register of a multi-reg value or just a      byte field of a register does not mean the value from before this insn      is now dead.  Of course, if it was dead after it's unused now.  */
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
condition|)
block|{
case|case
name|PARALLEL
case|:
comment|/* Some targets place small structures in registers for return values of 	 functions.  We have to detect this case specially here to get correct 	 flow information.  */
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|mark_set_1
argument_list|(
name|pbi
argument_list|,
name|code
argument_list|,
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
case|case
name|ZERO_EXTRACT
case|:
case|case
name|SIGN_EXTRACT
case|:
case|case
name|STRICT_LOW_PART
case|:
comment|/* ??? Assumes STRICT_LOW_PART not used on multi-word registers.  */
do|do
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
do|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
condition|)
break|break;
name|not_dead
operator|=
operator|(
name|unsigned
name|long
operator|)
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|REG
case|:
name|regno_last
operator|=
name|regno_first
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno_first
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno_last
operator|+=
name|HARD_REGNO_NREGS
argument_list|(
name|regno_first
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|enum
name|machine_mode
name|outer_mode
init|=
name|GET_MODE
argument_list|(
name|reg
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Identify the range of registers affected.  This is moderately 	     tricky for hard registers.  See alter_subreg.  */
name|regno_last
operator|=
name|regno_first
operator|=
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno_first
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|regno_first
operator|+=
name|subreg_regno_offset
argument_list|(
name|regno_first
argument_list|,
name|inner_mode
argument_list|,
name|SUBREG_BYTE
argument_list|(
name|reg
argument_list|)
argument_list|,
name|outer_mode
argument_list|)
expr_stmt|;
name|regno_last
operator|=
operator|(
name|regno_first
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno_first
argument_list|,
name|outer_mode
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Since we've just adjusted the register number ranges, make 		 sure REG matches.  Otherwise some_was_live will be clear 		 when it shouldn't have been, and we'll create incorrect 		 REG_UNUSED notes.  */
name|reg
operator|=
name|gen_rtx_REG
argument_list|(
name|outer_mode
argument_list|,
name|regno_first
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the number of words in the subreg is less than the number 		 of words in the full register, we have a well-defined partial 		 set.  Otherwise the high bits are undefined.  		 This is only really applicable to pseudos, since we just took 		 care of multi-word hard registers.  */
if|if
condition|(
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|outer_mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
operator|<
operator|(
operator|(
name|GET_MODE_SIZE
argument_list|(
name|inner_mode
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
condition|)
name|not_dead
operator|=
operator|(
name|unsigned
name|long
operator|)
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|regno_first
argument_list|)
expr_stmt|;
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|reg
operator|=
name|SUBREG_REG
argument_list|(
name|reg
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* If this set is a MEM, then it kills any aliased writes.      If this set is a REG, then it kills any MEMs which use the reg.  */
if|if
condition|(
name|optimize
operator|&&
operator|(
name|flags
operator|&
name|PROP_SCAN_DEAD_STORES
operator|)
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
name|invalidate_mems_from_set
argument_list|(
name|pbi
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* If the memory reference had embedded side effects (autoincrement 	 address modes.  Then we may need to kill some entries on the 	 memory set list.  */
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
condition|)
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|invalidate_mems_from_autoinc
argument_list|,
name|pbi
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|reg
argument_list|)
comment|/* ??? With more effort we could track conditional memory life.  */
operator|&&
operator|!
name|cond
condition|)
name|add_to_mem_set_list
argument_list|(
name|pbi
argument_list|,
name|canon_rtx
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
operator|!
operator|(
name|regno_first
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno_first
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno_first
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno_first
index|]
operator|)
endif|#
directive|endif
condition|)
block|{
name|int
name|some_was_live
init|=
literal|0
decl_stmt|,
name|some_was_dead
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
block|{
name|int
name|needed_regno
init|=
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|pbi
operator|->
name|local_set
condition|)
block|{
comment|/* Order of the set operation matters here since both 		 sets may be the same.  */
name|CLEAR_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|cond_local_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|!=
name|NULL_RTX
operator|&&
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|local_set
argument_list|,
name|i
argument_list|)
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|cond_local_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|SET_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|local_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|!=
name|CLOBBER
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|new_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|some_was_live
operator||=
name|needed_regno
expr_stmt|;
name|some_was_dead
operator||=
operator|!
name|needed_regno
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
comment|/* Consider conditional death in deciding that the register needs 	 a death note.  */
if|if
condition|(
name|some_was_live
operator|&&
operator|!
name|not_dead
comment|/* The stack pointer is never dead.  Well, not strictly true, 	     but it's very difficult to tell from here.  Hopefully 	     combine_stack_adjustments will fix up the most egregious 	     errors.  */
operator|&&
name|regno_first
operator|!=
name|STACK_POINTER_REGNUM
condition|)
block|{
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|mark_regno_cond_dead
argument_list|(
name|pbi
argument_list|,
name|i
argument_list|,
name|cond
argument_list|)
condition|)
name|not_dead
operator||=
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|)
operator|<<
operator|(
name|i
operator|-
name|regno_first
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Additional data to record if this is the final pass.  */
if|if
condition|(
name|flags
operator|&
operator|(
name|PROP_LOG_LINKS
operator||
name|PROP_REG_INFO
operator||
name|PROP_DEATH_NOTES
operator||
name|PROP_AUTOINC
operator|)
condition|)
block|{
name|rtx
name|y
decl_stmt|;
name|int
name|blocknum
init|=
name|pbi
operator|->
name|bb
operator|->
name|index
decl_stmt|;
name|y
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|PROP_LOG_LINKS
operator||
name|PROP_AUTOINC
operator|)
condition|)
block|{
name|y
operator|=
name|pbi
operator|->
name|reg_next_use
index|[
name|regno_first
index|]
expr_stmt|;
comment|/* The next use is no longer next, since a store intervenes.  */
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
name|pbi
operator|->
name|reg_next_use
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|PROP_REG_INFO
condition|)
block|{
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
block|{
comment|/* Count (weighted) references, stores, etc.  This counts a 		     register twice if it is modified, but that is correct.  */
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|REG_FREQ
argument_list|(
name|i
argument_list|)
operator|+=
name|REG_FREQ_FROM_BB
argument_list|(
name|pbi
operator|->
name|bb
argument_list|)
expr_stmt|;
comment|/* The insns where a reg is live are normally counted 		     elsewhere, but we want the count to include the insn 		     where the reg is set, and the normal counting mechanism 		     would not count it.  */
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* If this is a hard reg, record this function uses the reg.  */
if|if
condition|(
name|regno_first
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
name|i
operator|++
control|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PROP_ASM_SCAN
condition|)
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
name|i
operator|++
control|)
name|regs_asm_clobbered
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep track of which basic blocks each reg appears in.  */
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno_first
argument_list|)
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno_first
argument_list|)
operator|=
name|blocknum
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno_first
argument_list|)
operator|!=
name|blocknum
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno_first
argument_list|)
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|some_was_dead
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|PROP_LOG_LINKS
condition|)
block|{
comment|/* Make a logical link from the next following insn 		     that uses this register, back to this insn. 		     The following insns have already been processed.  		     We don't build a LOG_LINK for hard registers containing 		     in ASM_OPERANDs.  If these registers get replaced, 		     we might wind up changing the semantics of the insn, 		     even if reload can make what appear to be valid 		     assignments later.  		     We don't build a LOG_LINK for global registers to 		     or from a function call.  We don't want to let 		     combine think that it knows what is going on with 		     global registers.  */
if|if
condition|(
name|y
operator|&&
operator|(
name|BLOCK_NUM
argument_list|(
name|y
argument_list|)
operator|==
name|blocknum
operator|)
operator|&&
operator|(
name|regno_first
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|(
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|y
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
operator|!
operator|(
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|||
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|CALL_INSN
operator|)
operator|&&
name|global_regs
index|[
name|regno_first
index|]
operator|)
operator|)
operator|)
condition|)
name|LOG_LINKS
argument_list|(
name|y
argument_list|)
operator|=
name|alloc_INSN_LIST
argument_list|(
name|insn
argument_list|,
name|LOG_LINKS
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|not_dead
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|some_was_live
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|PROP_REG_INFO
condition|)
name|REG_N_DEATHS
argument_list|(
name|regno_first
argument_list|)
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PROP_DEATH_NOTES
condition|)
block|{
comment|/* Note that dead stores have already been deleted 		     when possible.  If we get here, we have found a 		     dead store that cannot be eliminated (because the 		     same insn does something useful).  Indicate this 		     by marking the reg being set as dying here.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|PROP_DEATH_NOTES
condition|)
block|{
comment|/* This is a case where we have a multi-word hard register 		     and some, but not all, of the words of the register are 		     needed in subsequent insns.  Write REG_UNUSED notes 		     for those parts that were not needed.  This case should 		     be rare.  */
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|i
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Mark the register as being dead.  */
if|if
condition|(
name|some_was_live
comment|/* The stack pointer is never dead.  Well, not strictly true, 	     but it's very difficult to tell from here.  Hopefully 	     combine_stack_adjustments will fix up the most egregious 	     errors.  */
operator|&&
name|regno_first
operator|!=
name|STACK_POINTER_REGNUM
condition|)
block|{
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
operator|(
name|not_dead
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|)
operator|<<
operator|(
name|i
operator|-
name|regno_first
operator|)
operator|)
operator|)
condition|)
name|CLEAR_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
name|PROP_LOG_LINKS
operator||
name|PROP_AUTOINC
operator|)
condition|)
name|pbi
operator|->
name|reg_next_use
index|[
name|regno_first
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PROP_REG_INFO
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|flags
operator|&
name|PROP_ASM_SCAN
operator|)
operator|!=
literal|0
operator|&&
name|regno_first
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
name|i
operator|++
control|)
name|regs_asm_clobbered
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this is the last pass and this is a SCRATCH, show it will be dying      here and count it.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SCRATCH
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|PROP_DEATH_NOTES
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
end_ifdef

begin_comment
comment|/* Mark REGNO conditionally dead.    Return true if the register is now unconditionally dead.  */
end_comment

begin_function
specifier|static
name|int
name|mark_regno_cond_dead
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|int
name|regno
parameter_list|,
name|rtx
name|cond
parameter_list|)
block|{
comment|/* If this is a store to a predicate register, the value of the      predicate is changing, we don't know that the predicate as seen      before is the same as that seen after.  Flush all dependent      conditions from reg_cond_dead.  This will make all such      conditionally live registers unconditionally live.  */
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_cond_reg
argument_list|,
name|regno
argument_list|)
condition|)
name|flush_reg_cond_reg
argument_list|(
name|pbi
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* If this is an unconditional store, remove any conditional      life that may have existed.  */
if|if
condition|(
name|cond
operator|==
name|NULL_RTX
condition|)
name|splay_tree_remove
argument_list|(
name|pbi
operator|->
name|reg_cond_dead
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|splay_tree_node
name|node
decl_stmt|;
name|struct
name|reg_cond_life_info
modifier|*
name|rcli
decl_stmt|;
name|rtx
name|ncond
decl_stmt|;
comment|/* Otherwise this is a conditional set.  Record that fact. 	 It may have been conditionally used, or there may be a 	 subsequent set with a complimentary condition.  */
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|pbi
operator|->
name|reg_cond_dead
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
comment|/* The register was unconditionally live previously. 	     Record the current condition as the condition under 	     which it is dead.  */
name|rcli
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rcli
argument_list|)
argument_list|)
expr_stmt|;
name|rcli
operator|->
name|condition
operator|=
name|cond
expr_stmt|;
name|rcli
operator|->
name|stores
operator|=
name|cond
expr_stmt|;
name|rcli
operator|->
name|orig_condition
operator|=
name|const0_rtx
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|pbi
operator|->
name|reg_cond_dead
argument_list|,
name|regno
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|rcli
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|reg_cond_reg
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Not unconditionally dead.  */
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* The register was conditionally live previously. 	     Add the new condition to the old.  */
name|rcli
operator|=
operator|(
expr|struct
name|reg_cond_life_info
operator|*
operator|)
name|node
operator|->
name|value
expr_stmt|;
name|ncond
operator|=
name|rcli
operator|->
name|condition
expr_stmt|;
name|ncond
operator|=
name|ior_reg_cond
argument_list|(
name|ncond
argument_list|,
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcli
operator|->
name|stores
operator|==
name|const0_rtx
condition|)
name|rcli
operator|->
name|stores
operator|=
name|cond
expr_stmt|;
elseif|else
if|if
condition|(
name|rcli
operator|->
name|stores
operator|!=
name|const1_rtx
condition|)
name|rcli
operator|->
name|stores
operator|=
name|ior_reg_cond
argument_list|(
name|rcli
operator|->
name|stores
argument_list|,
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the register is now unconditionally dead, remove the entry 	     in the splay_tree.  A register is unconditionally dead if the 	     dead condition ncond is true.  A register is also unconditionally 	     dead if the sum of all conditional stores is an unconditional 	     store (stores is true), and the dead condition is identically the 	     same as the original dead condition initialized at the end of 	     the block.  This is a pointer compare, not an rtx_equal_p 	     compare.  */
if|if
condition|(
name|ncond
operator|==
name|const1_rtx
operator|||
operator|(
name|ncond
operator|==
name|rcli
operator|->
name|orig_condition
operator|&&
name|rcli
operator|->
name|stores
operator|==
name|const1_rtx
operator|)
condition|)
name|splay_tree_remove
argument_list|(
name|pbi
operator|->
name|reg_cond_dead
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|rcli
operator|->
name|condition
operator|=
name|ncond
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|reg_cond_reg
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Not unconditionally dead.  */
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Called from splay_tree_delete for pbi->reg_cond_life.  */
end_comment

begin_function
specifier|static
name|void
name|free_reg_cond_life_info
parameter_list|(
name|splay_tree_value
name|value
parameter_list|)
block|{
name|struct
name|reg_cond_life_info
modifier|*
name|rcli
init|=
operator|(
expr|struct
name|reg_cond_life_info
operator|*
operator|)
name|value
decl_stmt|;
name|free
argument_list|(
name|rcli
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper function for flush_reg_cond_reg.  */
end_comment

begin_function
specifier|static
name|int
name|flush_reg_cond_reg_1
parameter_list|(
name|splay_tree_node
name|node
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|reg_cond_life_info
modifier|*
name|rcli
decl_stmt|;
name|int
modifier|*
name|xdata
init|=
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
name|unsigned
name|int
name|regno
init|=
name|xdata
index|[
literal|0
index|]
decl_stmt|;
comment|/* Don't need to search if last flushed value was farther on in      the in-order traversal.  */
if|if
condition|(
name|xdata
index|[
literal|1
index|]
operator|>=
operator|(
name|int
operator|)
name|node
operator|->
name|key
condition|)
return|return
literal|0
return|;
comment|/* Splice out portions of the expression that refer to regno.  */
name|rcli
operator|=
operator|(
expr|struct
name|reg_cond_life_info
operator|*
operator|)
name|node
operator|->
name|value
expr_stmt|;
name|rcli
operator|->
name|condition
operator|=
name|elim_reg_cond
argument_list|(
name|rcli
operator|->
name|condition
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcli
operator|->
name|stores
operator|!=
name|const0_rtx
operator|&&
name|rcli
operator|->
name|stores
operator|!=
name|const1_rtx
condition|)
name|rcli
operator|->
name|stores
operator|=
name|elim_reg_cond
argument_list|(
name|rcli
operator|->
name|stores
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* If the entire condition is now false, signal the node to be removed.  */
if|if
condition|(
name|rcli
operator|->
name|condition
operator|==
name|const0_rtx
condition|)
block|{
name|xdata
index|[
literal|1
index|]
operator|=
name|node
operator|->
name|key
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|rcli
operator|->
name|condition
operator|==
name|const1_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Flush all (sub) expressions referring to REGNO from REG_COND_LIVE.  */
end_comment

begin_function
specifier|static
name|void
name|flush_reg_cond_reg
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|pair
index|[
literal|2
index|]
decl_stmt|;
name|pair
index|[
literal|0
index|]
operator|=
name|regno
expr_stmt|;
name|pair
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|splay_tree_foreach
argument_list|(
name|pbi
operator|->
name|reg_cond_dead
argument_list|,
name|flush_reg_cond_reg_1
argument_list|,
name|pair
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|splay_tree_remove
argument_list|(
name|pbi
operator|->
name|reg_cond_dead
argument_list|,
name|pair
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CLEAR_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|reg_cond_reg
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Logical arithmetic on predicate conditions.  IOR, NOT and AND.    For ior/and, the ADD flag determines whether we want to add the new    condition X to the old one unconditionally.  If it is zero, we will    only return a new expression if X allows us to simplify part of    OLD, otherwise we return NULL to the caller.    If ADD is nonzero, we will return a new condition in all cases.  The    toplevel caller of one of these functions should always pass 1 for    ADD.  */
end_comment

begin_function
specifier|static
name|rtx
name|ior_reg_cond
parameter_list|(
name|rtx
name|old
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|add
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|REVERSE_CONDEXEC_PREDICATES_P
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|GET_CODE
argument_list|(
name|old
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|const1_rtx
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|old
return|;
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|NULL
return|;
return|return
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|old
argument_list|,
name|x
argument_list|)
return|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
condition|)
block|{
case|case
name|IOR
case|:
name|op0
operator|=
name|ior_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|ior_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|NULL
operator|||
name|op1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|op0
operator|==
name|const0_rtx
condition|)
return|return
name|op1
condition|?
name|op1
else|:
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
condition|?
name|op0
else|:
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
if|if
condition|(
name|op0
operator|==
name|const1_rtx
operator|||
name|op1
operator|==
name|const1_rtx
condition|)
return|return
name|const1_rtx
return|;
if|if
condition|(
name|op0
operator|==
name|NULL
condition|)
name|op0
operator|=
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|op0
argument_list|)
condition|)
comment|/* (x | A) | x ~ (x | A).  */
return|return
name|old
return|;
if|if
condition|(
name|op1
operator|==
name|NULL
condition|)
name|op1
operator|=
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|op1
argument_list|)
condition|)
comment|/* (A | x) | x ~ (A | x).  */
return|return
name|old
return|;
return|return
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|NULL
return|;
return|return
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|old
argument_list|,
name|x
argument_list|)
return|;
case|case
name|AND
case|:
name|op0
operator|=
name|ior_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|ior_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|NULL
operator|||
name|op1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|op0
operator|==
name|const1_rtx
condition|)
return|return
name|op1
condition|?
name|op1
else|:
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
return|return
name|op0
condition|?
name|op0
else|:
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
if|if
condition|(
name|op0
operator|==
name|const0_rtx
operator|||
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|op0
operator|==
name|NULL
condition|)
name|op0
operator|=
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|op0
argument_list|)
condition|)
comment|/* (x& A) | x ~ x.  */
return|return
name|op0
return|;
if|if
condition|(
name|op1
operator|==
name|NULL
condition|)
name|op1
operator|=
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|op1
argument_list|)
condition|)
comment|/* (A& x) | x ~ x.  */
return|return
name|op1
return|;
return|return
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|NULL
return|;
return|return
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|old
argument_list|,
name|x
argument_list|)
return|;
case|case
name|NOT
case|:
name|op0
operator|=
name|and_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|not_reg_cond
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|NULL
condition|)
return|return
name|not_reg_cond
argument_list|(
name|op0
argument_list|)
return|;
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|NULL
return|;
return|return
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|old
argument_list|,
name|x
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|rtx
name|not_reg_cond
parameter_list|(
name|rtx
name|x
parameter_list|)
block|{
name|enum
name|rtx_code
name|x_code
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|const0_rtx
condition|)
return|return
name|const1_rtx
return|;
elseif|else
if|if
condition|(
name|x
operator|==
name|const1_rtx
condition|)
return|return
name|const0_rtx
return|;
name|x_code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_code
operator|==
name|NOT
condition|)
return|return
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|x_code
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|!=
name|const0_rtx
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|gen_rtx_fmt_ee
argument_list|(
name|reverse_condition
argument_list|(
name|x_code
argument_list|)
argument_list|,
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|const0_rtx
argument_list|)
return|;
block|}
return|return
name|gen_rtx_NOT
argument_list|(
literal|0
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|rtx
name|and_reg_cond
parameter_list|(
name|rtx
name|old
parameter_list|,
name|rtx
name|x
parameter_list|,
name|int
name|add
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'<'
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|reverse_condition
argument_list|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|GET_CODE
argument_list|(
name|old
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|old
return|;
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|NULL
return|;
return|return
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|old
argument_list|,
name|x
argument_list|)
return|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|old
argument_list|)
condition|)
block|{
case|case
name|IOR
case|:
name|op0
operator|=
name|and_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|and_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|NULL
operator|||
name|op1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|op0
operator|==
name|const0_rtx
condition|)
return|return
name|op1
condition|?
name|op1
else|:
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
condition|?
name|op0
else|:
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
if|if
condition|(
name|op0
operator|==
name|const1_rtx
operator|||
name|op1
operator|==
name|const1_rtx
condition|)
return|return
name|const1_rtx
return|;
if|if
condition|(
name|op0
operator|==
name|NULL
condition|)
name|op0
operator|=
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|op0
argument_list|)
condition|)
comment|/* (x | A)& x ~ x.  */
return|return
name|op0
return|;
if|if
condition|(
name|op1
operator|==
name|NULL
condition|)
name|op1
operator|=
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|op1
argument_list|)
condition|)
comment|/* (A | x)& x ~ x.  */
return|return
name|op1
return|;
return|return
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|NULL
return|;
return|return
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|old
argument_list|,
name|x
argument_list|)
return|;
case|case
name|AND
case|:
name|op0
operator|=
name|and_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|and_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|NULL
operator|||
name|op1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|op0
operator|==
name|const1_rtx
condition|)
return|return
name|op1
condition|?
name|op1
else|:
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
return|return
name|op0
condition|?
name|op0
else|:
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
return|;
if|if
condition|(
name|op0
operator|==
name|const0_rtx
operator|||
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|op0
operator|==
name|NULL
condition|)
name|op0
operator|=
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|op0
argument_list|)
condition|)
comment|/* (x& A)& x ~ (x& A).  */
return|return
name|old
return|;
if|if
condition|(
name|op1
operator|==
name|NULL
condition|)
name|op1
operator|=
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|XEXP
argument_list|(
name|old
argument_list|,
literal|1
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|x
argument_list|,
name|op1
argument_list|)
condition|)
comment|/* (A& x)& x ~ (A& x).  */
return|return
name|old
return|;
return|return
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|NULL
return|;
return|return
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|old
argument_list|,
name|x
argument_list|)
return|;
case|case
name|NOT
case|:
name|op0
operator|=
name|ior_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
argument_list|,
name|not_reg_cond
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|NULL
condition|)
return|return
name|not_reg_cond
argument_list|(
name|op0
argument_list|)
return|;
if|if
condition|(
operator|!
name|add
condition|)
return|return
name|NULL
return|;
return|return
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|old
argument_list|,
name|x
argument_list|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a condition X, remove references to reg REGNO and return the    new condition.  The removal will be done so that all conditions    involving REGNO are considered to evaluate to false.  This function    is used when the value of REGNO changes.  */
end_comment

begin_function
specifier|static
name|rtx
name|elim_reg_cond
parameter_list|(
name|rtx
name|x
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|'<'
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|regno
condition|)
return|return
name|const0_rtx
return|;
return|return
name|x
return|;
block|}
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|AND
case|:
name|op0
operator|=
name|elim_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|op1
operator|=
name|elim_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|const0_rtx
operator|||
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|op0
operator|==
name|const1_rtx
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|gen_rtx_AND
argument_list|(
literal|0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|IOR
case|:
name|op0
operator|=
name|elim_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|op1
operator|=
name|elim_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|const1_rtx
operator|||
name|op1
operator|==
name|const1_rtx
condition|)
return|return
name|const1_rtx
return|;
if|if
condition|(
name|op0
operator|==
name|const0_rtx
condition|)
return|return
name|op1
return|;
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|op0
return|;
if|if
condition|(
name|op0
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|x
return|;
return|return
name|gen_rtx_IOR
argument_list|(
literal|0
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
name|NOT
case|:
name|op0
operator|=
name|elim_reg_cond
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|const0_rtx
condition|)
return|return
name|const1_rtx
return|;
if|if
condition|(
name|op0
operator|==
name|const1_rtx
condition|)
return|return
name|const0_rtx
return|;
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|not_reg_cond
argument_list|(
name|op0
argument_list|)
return|;
return|return
name|x
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_conditional_execution */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_comment
comment|/* Try to substitute the auto-inc expression INC as the address inside    MEM which occurs in INSN.  Currently, the address of MEM is an expression    involving INCR_REG, and INCR is the next use of INCR_REG; it is an insn    that has a single set whose source is a PLUS of INCR_REG and something    else.  */
end_comment

begin_function
specifier|static
name|void
name|attempt_auto_inc
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|rtx
name|inc
parameter_list|,
name|rtx
name|insn
parameter_list|,
name|rtx
name|mem
parameter_list|,
name|rtx
name|incr
parameter_list|,
name|rtx
name|incr_reg
parameter_list|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|incr_reg
argument_list|)
decl_stmt|;
name|rtx
name|set
init|=
name|single_set
argument_list|(
name|incr
argument_list|)
decl_stmt|;
name|rtx
name|q
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|y
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|int
name|opnum
init|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
operator|==
name|incr_reg
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* Make sure this reg appears only once in this insn.  */
if|if
condition|(
name|count_occurrences
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|incr_reg
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return;
if|if
condition|(
name|dead_or_set_p
argument_list|(
name|incr
argument_list|,
name|incr_reg
argument_list|)
comment|/* Mustn't autoinc an eliminable register.  */
operator|&&
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|regno
argument_list|)
operator|)
condition|)
block|{
comment|/* This is the simple case.  Try to make the auto-inc.  If 	 we can't, we are done.  Otherwise, we will do any 	 needed updates below.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|inc
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|REG
comment|/* PREV_INSN used here to check the semi-open interval 	      [insn,incr).  */
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|q
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|incr
argument_list|)
comment|/* We must also check for sets of q as q may be 	      a call clobbered hard register and there may 	      be a call between PREV_INSN (insn) and incr.  */
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|q
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|incr
argument_list|)
condition|)
block|{
comment|/* We have *p followed sometime later by q = p+size. 	 Both p and q must be live afterward, 	 and q is not used between INSN and its assignment. 	 Change it to q = p, ...*q..., q = q+size. 	 Then fall into the usual case.  */
name|rtx
name|insns
decl_stmt|,
name|temp
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|q
argument_list|,
name|incr_reg
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* If we can't make the auto-inc, or can't make the 	 replacement into Y, exit.  There's no point in making 	 the change below if we can't do the auto-inc and doing 	 so is not correct in the pre-inc case.  */
name|XEXP
argument_list|(
name|inc
argument_list|,
literal|0
argument_list|)
operator|=
name|q
expr_stmt|;
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|mem
argument_list|,
literal|0
argument_list|)
argument_list|,
name|inc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|incr
argument_list|,
operator|&
name|XEXP
argument_list|(
name|y
argument_list|,
name|opnum
argument_list|)
argument_list|,
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
return|return;
comment|/* We now know we'll be doing this change, so emit the 	 new insn(s) and do the updates.  */
name|emit_insn_before
argument_list|(
name|insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BB_HEAD
argument_list|(
name|pbi
operator|->
name|bb
argument_list|)
operator|==
name|insn
condition|)
name|BB_HEAD
argument_list|(
name|pbi
operator|->
name|bb
argument_list|)
operator|=
name|insns
expr_stmt|;
comment|/* INCR will become a NOTE and INSN won't contain a 	 use of INCR_REG.  If a use of INCR_REG was just placed in 	 the insn before INSN, make that the next use. 	 Otherwise, invalidate it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|incr_reg
condition|)
name|pbi
operator|->
name|reg_next_use
index|[
name|regno
index|]
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|pbi
operator|->
name|reg_next_use
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|incr_reg
operator|=
name|q
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* REGNO is now used in INCR which is below INSN, but 	 it previously wasn't live here.  If we don't mark 	 it as live, we'll put a REG_DEAD note for it 	 on this insn, which is incorrect.  */
name|SET_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* If there are any calls between INSN and INCR, show 	 that REGNO now crosses them.  */
for|for
control|(
name|temp
operator|=
name|insn
init|;
name|temp
operator|!=
name|incr
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
comment|/* Invalidate alias info for Q since we just changed its value.  */
name|clear_reg_alias_info
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
return|return;
comment|/* If we haven't returned, it means we were able to make the      auto-inc, so update the status.  First, record that this insn      has an implicit side effect.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|incr_reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Modify the old increment-insn to simply copy      the already-incremented value of our register.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|incr
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|incr_reg
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If that makes it a no-op (copying the register into itself) delete      it so it won't appear to be a "use" and a "set" of this      register.  */
if|if
condition|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|incr_reg
argument_list|)
condition|)
block|{
comment|/* If the original source was dead, it's dead now.  */
name|rtx
name|note
decl_stmt|;
while|while
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|incr
argument_list|,
name|REG_DEAD
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|NULL_RTX
condition|)
block|{
name|remove_note
argument_list|(
name|incr
argument_list|,
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
operator|!=
name|incr_reg
condition|)
name|CLEAR_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PUT_CODE
argument_list|(
name|incr
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|incr
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|incr
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Count an extra reference to the reg.  When a reg is 	 incremented, spilling it is worse, so we want to make 	 that less likely.  */
name|REG_FREQ
argument_list|(
name|regno
argument_list|)
operator|+=
name|REG_FREQ_FROM_BB
argument_list|(
name|pbi
operator|->
name|bb
argument_list|)
expr_stmt|;
comment|/* Count the increment as a setting of the register, 	 even though it isn't a SET in rtl.  */
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* X is a MEM found in INSN.  See if we can convert it into an auto-increment    reference.  */
end_comment

begin_function
specifier|static
name|void
name|find_auto_inc
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|set
decl_stmt|,
name|y
decl_stmt|,
name|incr
decl_stmt|,
name|inc_val
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return;
comment|/* Here we detect use of an index register which might be good for      postincrement, postdecrement, preincrement, or predecrement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|!=
name|REG
condition|)
return|return;
name|regno
operator|=
name|REGNO
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* Is the next use an increment that might make auto-increment? */
name|incr
operator|=
name|pbi
operator|->
name|reg_next_use
index|[
name|regno
index|]
expr_stmt|;
if|if
condition|(
name|incr
operator|==
literal|0
operator|||
name|BLOCK_NUM
argument_list|(
name|incr
argument_list|)
operator|!=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
condition|)
return|return;
name|set
operator|=
name|single_set
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|!=
name|SET
condition|)
return|return;
name|y
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|!=
name|PLUS
condition|)
return|return;
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|addr
argument_list|)
condition|)
name|inc_val
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|addr
argument_list|)
condition|)
name|inc_val
operator|=
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return;
if|if
condition|(
name|GET_CODE
argument_list|(
name|inc_val
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|inc_val
argument_list|)
operator|==
name|size
operator|&&
name|offset
operator|==
literal|0
operator|)
condition|)
name|attempt_auto_inc
argument_list|(
name|pbi
argument_list|,
name|gen_rtx_POST_INC
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|insn
argument_list|,
name|x
argument_list|,
name|incr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_POST_DECREMENT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|inc_val
argument_list|)
operator|==
operator|-
name|size
operator|&&
name|offset
operator|==
literal|0
operator|)
condition|)
name|attempt_auto_inc
argument_list|(
name|pbi
argument_list|,
name|gen_rtx_POST_DEC
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|insn
argument_list|,
name|x
argument_list|,
name|incr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_PRE_INCREMENT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|inc_val
argument_list|)
operator|==
name|size
operator|&&
name|offset
operator|==
name|size
operator|)
condition|)
name|attempt_auto_inc
argument_list|(
name|pbi
argument_list|,
name|gen_rtx_PRE_INC
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|insn
argument_list|,
name|x
argument_list|,
name|incr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|inc_val
argument_list|)
operator|==
operator|-
name|size
operator|&&
name|offset
operator|==
operator|-
name|size
operator|)
condition|)
name|attempt_auto_inc
argument_list|(
name|pbi
argument_list|,
name|gen_rtx_PRE_DEC
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
name|insn
argument_list|,
name|x
argument_list|,
name|incr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_POST_MODIFY_DISP
operator|&&
name|offset
operator|==
literal|0
condition|)
name|attempt_auto_inc
argument_list|(
name|pbi
argument_list|,
name|gen_rtx_POST_MODIFY
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|inc_val
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
name|x
argument_list|,
name|incr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|HAVE_PRE_MODIFY_DISP
operator|&&
name|offset
operator|==
name|INTVAL
argument_list|(
name|inc_val
argument_list|)
condition|)
name|attempt_auto_inc
argument_list|(
name|pbi
argument_list|,
name|gen_rtx_PRE_MODIFY
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|inc_val
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
name|x
argument_list|,
name|incr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|inc_val
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|inc_val
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NEXT_INSN
argument_list|(
name|incr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|HAVE_POST_MODIFY_REG
operator|&&
name|offset
operator|==
literal|0
condition|)
name|attempt_auto_inc
argument_list|(
name|pbi
argument_list|,
name|gen_rtx_POST_MODIFY
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|gen_rtx_PLUS
argument_list|(
name|Pmode
argument_list|,
name|addr
argument_list|,
name|inc_val
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
name|x
argument_list|,
name|incr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTO_INC_DEC */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|void
name|mark_used_reg
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|rtx
name|cond
name|ATTRIBUTE_UNUSED
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|unsigned
name|int
name|regno_first
decl_stmt|,
name|regno_last
decl_stmt|,
name|i
decl_stmt|;
name|int
name|some_was_live
decl_stmt|,
name|some_was_dead
decl_stmt|,
name|some_not_set
decl_stmt|;
name|regno_last
operator|=
name|regno_first
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno_first
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|regno_last
operator|+=
name|HARD_REGNO_NREGS
argument_list|(
name|regno_first
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Find out if any of this register is live after this instruction.  */
name|some_was_live
operator|=
name|some_was_dead
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
block|{
name|int
name|needed_regno
init|=
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|some_was_live
operator||=
name|needed_regno
expr_stmt|;
name|some_was_dead
operator||=
operator|!
name|needed_regno
expr_stmt|;
block|}
comment|/* Find out if any of the register was set this insn.  */
name|some_not_set
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
name|some_not_set
operator||=
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|new_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbi
operator|->
name|flags
operator|&
operator|(
name|PROP_LOG_LINKS
operator||
name|PROP_AUTOINC
operator|)
condition|)
block|{
comment|/* Record where each reg is used, so when the reg is set we know 	 the next insn that uses it.  */
name|pbi
operator|->
name|reg_next_use
index|[
name|regno_first
index|]
operator|=
name|insn
expr_stmt|;
block|}
if|if
condition|(
name|pbi
operator|->
name|flags
operator|&
name|PROP_REG_INFO
condition|)
block|{
if|if
condition|(
name|regno_first
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* If this is a register we are going to try to eliminate, 	     don't mark it live here.  If we are successful in 	     eliminating it, it need not be live unless it is used for 	     pseudos, in which case it will have been set live when it 	     was allocated to the pseudos.  If the register will not 	     be eliminated, reload will set it live at that point.  	     Otherwise, record that this function uses this register.  */
comment|/* ??? The PPC backend tries to "eliminate" on the pic 	     register to itself.  This should be fixed.  In the mean 	     time, hack around it.  */
if|if
condition|(
operator|!
operator|(
name|TEST_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|regno_first
argument_list|)
operator|&&
operator|(
name|regno_first
operator|==
name|FRAME_POINTER_REGNUM
operator|||
name|regno_first
operator|==
name|ARG_POINTER_REGNUM
operator|)
operator|)
condition|)
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Keep track of which basic block each reg appears in.  */
name|int
name|blocknum
init|=
name|pbi
operator|->
name|bb
operator|->
name|index
decl_stmt|;
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno_first
argument_list|)
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno_first
argument_list|)
operator|=
name|blocknum
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno_first
argument_list|)
operator|!=
name|blocknum
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno_first
argument_list|)
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
comment|/* Count (weighted) number of uses of each reg.  */
name|REG_FREQ
argument_list|(
name|regno_first
argument_list|)
operator|+=
name|REG_FREQ_FROM_BB
argument_list|(
name|pbi
operator|->
name|bb
argument_list|)
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|regno_first
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
comment|/* Record and count the insns in which a reg dies.  If it is used in      this insn and was dead below the insn then it dies in this insn.      If it was set in this insn, we do not make a REG_DEAD note;      likewise if we already made such a note.  */
if|if
condition|(
operator|(
name|pbi
operator|->
name|flags
operator|&
operator|(
name|PROP_DEATH_NOTES
operator||
name|PROP_REG_INFO
operator|)
operator|)
operator|&&
name|some_was_dead
operator|&&
name|some_not_set
condition|)
block|{
comment|/* Check for the case where the register dying partially 	 overlaps the register set by this insn.  */
if|if
condition|(
name|regno_first
operator|!=
name|regno_last
condition|)
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
name|some_was_live
operator||=
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|new_set
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If none of the words in X is needed, make a REG_DEAD note. 	 Otherwise, we must make partial REG_DEAD notes.  */
if|if
condition|(
operator|!
name|some_was_live
condition|)
block|{
if|if
condition|(
operator|(
name|pbi
operator|->
name|flags
operator|&
name|PROP_DEATH_NOTES
operator|)
operator|&&
operator|!
name|find_regno_note
argument_list|(
name|insn
argument_list|,
name|REG_DEAD
argument_list|,
name|regno_first
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbi
operator|->
name|flags
operator|&
name|PROP_REG_INFO
condition|)
name|REG_N_DEATHS
argument_list|(
name|regno_first
argument_list|)
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't make a REG_DEAD note for a part of a register 	     that is set in the insn.  */
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|i
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark the register as being live.  */
for|for
control|(
name|i
operator|=
name|regno_first
init|;
name|i
operator|<=
name|regno_last
condition|;
operator|++
name|i
control|)
block|{
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
name|int
name|this_was_live
init|=
name|REGNO_REG_SET_P
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|i
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|SET_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|reg_live
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_conditional_execution
comment|/* If this is a conditional use, record that fact.  If it is later 	 conditionally set, we'll know to kill the register.  */
if|if
condition|(
name|cond
operator|!=
name|NULL_RTX
condition|)
block|{
name|splay_tree_node
name|node
decl_stmt|;
name|struct
name|reg_cond_life_info
modifier|*
name|rcli
decl_stmt|;
name|rtx
name|ncond
decl_stmt|;
if|if
condition|(
name|this_was_live
condition|)
block|{
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|pbi
operator|->
name|reg_cond_dead
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
comment|/* The register was unconditionally live previously. 		     No need to do anything.  */
block|}
else|else
block|{
comment|/* The register was conditionally live previously. 		     Subtract the new life cond from the old death cond.  */
name|rcli
operator|=
operator|(
expr|struct
name|reg_cond_life_info
operator|*
operator|)
name|node
operator|->
name|value
expr_stmt|;
name|ncond
operator|=
name|rcli
operator|->
name|condition
expr_stmt|;
name|ncond
operator|=
name|and_reg_cond
argument_list|(
name|ncond
argument_list|,
name|not_reg_cond
argument_list|(
name|cond
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the register is now unconditionally live, 		     remove the entry in the splay_tree.  */
if|if
condition|(
name|ncond
operator|==
name|const0_rtx
condition|)
name|splay_tree_remove
argument_list|(
name|pbi
operator|->
name|reg_cond_dead
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
block|{
name|rcli
operator|->
name|condition
operator|=
name|ncond
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|reg_cond_reg
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* The register was not previously live at all.  Record 		 the condition under which it is still dead.  */
name|rcli
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rcli
argument_list|)
argument_list|)
expr_stmt|;
name|rcli
operator|->
name|condition
operator|=
name|not_reg_cond
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|rcli
operator|->
name|stores
operator|=
name|const0_rtx
expr_stmt|;
name|rcli
operator|->
name|orig_condition
operator|=
name|const0_rtx
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|pbi
operator|->
name|reg_cond_dead
argument_list|,
name|i
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|rcli
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|pbi
operator|->
name|reg_cond_reg
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|this_was_live
condition|)
block|{
comment|/* The register may have been conditionally live previously, but 	     is now unconditionally live.  Remove it from the conditionally 	     dead list, so that a conditional set won't cause us to think 	     it dead.  */
name|splay_tree_remove
argument_list|(
name|pbi
operator|->
name|reg_cond_dead
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Scan expression X and store a 1-bit in NEW_LIVE for each reg it uses.    This is done assuming the registers needed from X are those that    have 1-bits in PBI->REG_LIVE.     INSN is the containing instruction.  If INSN is dead, this function    is not called.  */
end_comment

begin_function
specifier|static
name|void
name|mark_used_regs
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|rtx
name|x
parameter_list|,
name|rtx
name|cond
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|flags
init|=
name|pbi
operator|->
name|flags
decl_stmt|;
name|retry
label|:
if|if
condition|(
operator|!
name|x
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|CONST_VECTOR
case|:
case|case
name|PC
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
name|pbi
operator|->
name|cc0_live
operator|=
literal|1
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
name|CLOBBER
case|:
comment|/* If we are clobbering a MEM, mark any registers inside the address 	 as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEM
case|:
comment|/* Don't bother watching stores to mems if this is not the 	 final pass.  We'll not be deleting dead stores this round.  */
if|if
condition|(
name|optimize
operator|&&
operator|(
name|flags
operator|&
name|PROP_SCAN_DEAD_STORES
operator|)
condition|)
block|{
comment|/* Invalidate the data for the last MEM stored, but only if MEM is 	     something that can be stored into.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* Needn't clear the memory set list.  */
empty_stmt|;
else|else
block|{
name|rtx
name|temp
init|=
name|pbi
operator|->
name|mem_set_list
decl_stmt|;
name|rtx
name|prev
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|next
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
name|next
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|unchanging_anti_dependence
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
block|{
comment|/* Splice temp out of the list.  */
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|next
expr_stmt|;
else|else
name|pbi
operator|->
name|mem_set_list
operator|=
name|next
expr_stmt|;
name|free_EXPR_LIST_node
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|pbi
operator|->
name|mem_set_list_len
operator|--
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/* If the memory reference had embedded side effects (autoincrement 	     address modes.  Then we may need to kill some entries on the 	     memory set list.  */
if|if
condition|(
name|insn
condition|)
name|for_each_rtx
argument_list|(
operator|&
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|invalidate_mems_from_autoinc
argument_list|,
name|pbi
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
if|if
condition|(
name|flags
operator|&
name|PROP_AUTOINC
condition|)
name|find_auto_inc
argument_list|(
name|pbi
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SUBREG
case|:
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
if|if
condition|(
name|flags
operator|&
name|PROP_REG_INFO
condition|)
name|record_subregs_of_mode
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* While we're here, optimize this case.  */
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
goto|goto
name|retry
goto|;
comment|/* Fall through.  */
case|case
name|REG
case|:
comment|/* See a register other than being set => mark it as needed.  */
name|mark_used_reg
argument_list|(
name|pbi
argument_list|,
name|x
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
case|case
name|SET
case|:
block|{
name|rtx
name|testreg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|mark_dest
init|=
literal|0
decl_stmt|;
comment|/* If storing into MEM, don't show it as being used.  But do 	   show the address as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|MEM
condition|)
block|{
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
if|if
condition|(
name|flags
operator|&
name|PROP_AUTOINC
condition|)
name|find_auto_inc
argument_list|(
name|pbi
argument_list|,
name|testreg
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Storing in STRICT_LOW_PART is like storing in a reg 	   in that this SET might be dead, so ignore it in TESTREG. 	   but in some other ways it is like using the reg.  	   Storing in a SUBREG or a bit field is like storing the entire 	   register in that if the register's value is not used 	   then this SET is not needed.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
ifdef|#
directive|ifdef
name|CANNOT_CHANGE_MODE_CLASS
if|if
condition|(
operator|(
name|flags
operator|&
name|PROP_REG_INFO
operator|)
operator|&&
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
condition|)
name|record_subregs_of_mode
argument_list|(
name|testreg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Modifying a single register in an alternate mode 	       does not use any of the old value.  But these other 	       ways of storing in a register do use the old value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|!
operator|(
operator|(
name|REG_BYTES
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|>
operator|(
name|REG_BYTES
argument_list|(
name|testreg
argument_list|)
operator|+
name|UNITS_PER_WORD
operator|-
literal|1
operator|)
operator|/
name|UNITS_PER_WORD
operator|)
condition|)
empty_stmt|;
else|else
name|mark_dest
operator|=
literal|1
expr_stmt|;
name|testreg
operator|=
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a store into a register or group of registers, 	   recursively scan the value being stored.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_MODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|BLKmode
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|testreg
argument_list|)
operator|,
operator|!
operator|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
if|if
condition|(
name|mark_dest
condition|)
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|ASM_OPERANDS
case|:
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|TRAP_IF
case|:
case|case
name|ASM_INPUT
case|:
block|{
comment|/* Traditional and volatile asm instructions must be considered to use 	   and clobber all hard registers, all pseudo-registers and all of 	   memory.  So must TRAP_IF and UNSPEC_VOLATILE operations.  	   Consider for instance a volatile asm that changes the fpu rounding 	   mode.  An insn should not be moved across this even if it only uses 	   pseudo-regs because it might give an incorrectly rounded result.  	   ?!? Unfortunately, marking all hard registers as live causes massive 	   problems for the register allocator and marking all pseudos as live 	   creates mountains of uninitialized variable warnings.  	   So for now, just clear the memory set list and mark any regs 	   we can find in ASM_OPERANDS as used.  */
if|if
condition|(
name|code
operator|!=
name|ASM_OPERANDS
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|free_EXPR_LIST_list
argument_list|(
operator|&
name|pbi
operator|->
name|mem_set_list
argument_list|)
expr_stmt|;
name|pbi
operator|->
name|mem_set_list_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	   We can not just fall through here since then we would be confused 	   by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	   traditional asms unlike their normal usage.  */
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|COND_EXEC
case|:
if|if
condition|(
name|cond
operator|!=
name|NULL_RTX
condition|)
name|abort
argument_list|()
expr_stmt|;
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|cond
operator|=
name|COND_EXEC_TEST
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|COND_EXEC_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|const
name|char
modifier|*
specifier|const
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Tail recursive case: save a function call level.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_used_regs
argument_list|(
name|pbi
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|cond
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_function
specifier|static
name|int
name|try_pre_increment_1
parameter_list|(
name|struct
name|propagate_block_info
modifier|*
name|pbi
parameter_list|,
name|rtx
name|insn
parameter_list|)
block|{
comment|/* Find the next use of this reg.  If in same basic block,      make it do pre-increment or pre-decrement if appropriate.  */
name|rtx
name|x
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|amount
init|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|y
init|=
name|pbi
operator|->
name|reg_next_use
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|!=
name|stack_pointer_rtx
operator|&&
name|BLOCK_NUM
argument_list|(
name|y
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
comment|/* Don't do this if the reg dies, or gets set in y; a standard addressing 	 mode would be better.  */
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|y
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|try_pre_increment
argument_list|(
name|y
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|amount
argument_list|)
condition|)
block|{
comment|/* We have found a suitable auto-increment and already changed 	 insn Y to do it.  So flush this increment instruction.  */
name|propagate_block_delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Count a reference to this reg for the increment insn we are 	 deleting.  When a reg is incremented, spilling it is worse, 	 so we want to make that less likely.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|REG_FREQ
argument_list|(
name|regno
argument_list|)
operator|+=
name|REG_FREQ_FROM_BB
argument_list|(
name|pbi
operator|->
name|bb
argument_list|)
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
comment|/* Flush any remembered memories depending on the value of 	 the incremented register.  */
name|invalidate_mems_from_set
argument_list|(
name|pbi
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to change INSN so that it does pre-increment or pre-decrement    addressing on register REG in order to add AMOUNT to REG.    AMOUNT is negative for pre-decrement.    Returns 1 if the change could be made.    This checks all about the validity of the result of modifying INSN.  */
end_comment

begin_function
specifier|static
name|int
name|try_pre_increment
parameter_list|(
name|rtx
name|insn
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|amount
parameter_list|)
block|{
name|rtx
name|use
decl_stmt|;
comment|/* Nonzero if we can try to make a pre-increment or pre-decrement.      For example, addl $4,r1; movl (r1),... can become movl +(r1),...  */
name|int
name|pre_ok
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if we can try to make a post-increment or post-decrement.      For example, addl $4,r1; movl -4(r1),... can become movl (r1)+,...      It is possible for both PRE_OK and POST_OK to be nonzero if the machine      supports both pre-inc and post-inc, or both pre-dec and post-dec.  */
name|int
name|post_ok
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if the opportunity actually requires post-inc or post-dec.  */
name|int
name|do_post
init|=
literal|0
decl_stmt|;
comment|/* From the sign of increment, see which possibilities are conceivable      on this target machine.  */
if|if
condition|(
name|HAVE_PRE_INCREMENT
operator|&&
name|amount
operator|>
literal|0
condition|)
name|pre_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|amount
operator|>
literal|0
condition|)
name|post_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|amount
operator|<
literal|0
condition|)
name|pre_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|HAVE_POST_DECREMENT
operator|&&
name|amount
operator|<
literal|0
condition|)
name|post_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pre_ok
operator|||
name|post_ok
operator|)
condition|)
return|return
literal|0
return|;
comment|/* It is not safe to add a side effect to a jump insn      because if the incremented register is spilled and must be reloaded      there would be no way to store the incremented value back in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
name|use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pre_ok
condition|)
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_ok
operator|&&
operator|(
name|use
operator|==
literal|0
operator|||
name|use
operator|==
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
literal|1
operator|)
condition|)
block|{
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|,
operator|-
name|amount
argument_list|)
expr_stmt|;
name|do_post
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|use
operator|==
literal|0
operator|||
name|use
operator|==
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|use
argument_list|)
argument_list|)
operator|!=
operator|(
name|amount
operator|>
literal|0
condition|?
name|amount
else|:
operator|-
name|amount
operator|)
condition|)
return|return
literal|0
return|;
comment|/* See if this combination of instruction and addressing mode exists.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|use
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|amount
operator|>
literal|0
condition|?
operator|(
name|do_post
condition|?
name|POST_INC
else|:
name|PRE_INC
operator|)
else|:
operator|(
name|do_post
condition|?
name|POST_DEC
else|:
name|PRE_DEC
operator|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Record that this insn now has an implicit side effect on X.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|alloc_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTO_INC_DEC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Find the place in the rtx X where REG is used as a memory address.    Return the MEM rtx that so uses it.    If PLUSCONST is nonzero, search instead for a memory address equivalent to    (plus REG (const_int PLUSCONST)).     If such an address does not appear, return 0.    If REG appears more than once, or is used other than in such an address,    return (rtx) 1.  */
end_comment

begin_function
name|rtx
name|find_use_as_address
parameter_list|(
name|rtx
name|x
parameter_list|,
name|rtx
name|reg
parameter_list|,
name|HOST_WIDE_INT
name|plusconst
parameter_list|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rtx
name|value
init|=
literal|0
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|plusconst
operator|==
literal|0
condition|)
return|return
name|x
return|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|plusconst
condition|)
return|return
name|x
return|;
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
operator|||
name|code
operator|==
name|ZERO_EXTRACT
condition|)
block|{
comment|/* If REG occurs inside a MEM used in a bit-field reference, 	 that is unacceptable.  */
if|if
condition|(
name|find_use_as_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
literal|1
return|;
block|}
if|if
condition|(
name|x
operator|==
name|reg
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
literal|1
return|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|tem
operator|=
name|find_use_as_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|reg
argument_list|,
name|plusconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tem
operator|=
name|find_use_as_address
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg
argument_list|,
name|plusconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|size_t
argument_list|)
literal|1
return|;
block|}
block|}
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write information about registers and basic blocks into FILE.    This is part of making a debugging dump.  */
end_comment

begin_function
name|void
name|dump_regset
parameter_list|(
name|regset
name|r
parameter_list|,
name|FILE
modifier|*
name|outf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|fputs
argument_list|(
literal|" (nil)"
argument_list|,
name|outf
argument_list|)
expr_stmt|;
return|return;
block|}
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|r
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{       fprintf (outf,
literal|" %d"
argument|, i);       if (i< FIRST_PSEUDO_REGISTER) 	fprintf (outf,
literal|" [%s]"
argument|, 		 reg_names[i]);     }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Print a human-readable representation of R on the standard error    stream.  This function is designed to be used from within the    debugger.  */
end_comment

begin_function
name|void
name|debug_regset
parameter_list|(
name|regset
name|r
parameter_list|)
block|{
name|dump_regset
argument_list|(
name|r
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recompute register set/reference counts immediately prior to register    allocation.     This avoids problems with set/reference counts changing to/from values    which have special meanings to the register allocators.     Additionally, the reference counts are the primary component used by the    register allocators to prioritize pseudos for allocation to hard regs.    More accurate reference counts generally lead to better register allocation.     F is the first insn to be scanned.     LOOP_STEP denotes how much loop_depth should be incremented per    loop nesting level in order to increase the ref count more for    references in a loop.     It might be worthwhile to update REG_LIVE_LENGTH, REG_BASIC_BLOCK and    possibly other information which is used by the register allocators.  */
end_comment

begin_function
name|void
name|recompute_reg_usage
parameter_list|(
name|rtx
name|f
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|loop_step
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|update_life_info
argument_list|(
name|NULL
argument_list|,
name|UPDATE_LIFE_LOCAL
argument_list|,
name|PROP_REG_INFO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Optionally removes all the REG_DEAD and REG_UNUSED notes from a set of    blocks.  If BLOCKS is NULL, assume the universal set.  Returns a count    of the number of registers that died.  */
end_comment

begin_function
name|int
name|count_or_remove_death_notes
parameter_list|(
name|sbitmap
name|blocks
parameter_list|,
name|int
name|kill
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* This used to be a loop over all the blocks with a membership test      inside the loop.  That can be amazingly expensive on a large CFG      when only a small number of bits are set in BLOCKs (for example,      the calls from the scheduler typically have very few bits set).       For extra credit, someone should convert BLOCKS to a bitmap rather      than an sbitmap.  */
if|if
condition|(
name|blocks
condition|)
block|{
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	  count += count_or_remove_death_notes_bb (BASIC_BLOCK (i), kill); 	}
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|count
operator|+=
name|count_or_remove_death_notes_bb
argument_list|(
name|bb
argument_list|,
name|kill
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Optionally removes all the REG_DEAD and REG_UNUSED notes from basic    block BB.  Returns a count of the number of registers that died.  */
end_comment

begin_function
specifier|static
name|int
name|count_or_remove_death_notes_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|int
name|kill
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|BB_HEAD
argument_list|(
name|bb
argument_list|)
init|;
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|rtx
modifier|*
name|pprev
init|=
operator|&
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|link
init|=
operator|*
name|pprev
decl_stmt|;
while|while
condition|(
name|link
condition|)
block|{
switch|switch
condition|(
name|REG_NOTE_KIND
argument_list|(
name|link
argument_list|)
condition|)
block|{
case|case
name|REG_DEAD
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|reg
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|n
operator|=
literal|1
expr_stmt|;
else|else
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|+=
name|n
expr_stmt|;
block|}
comment|/* Fall through.  */
case|case
name|REG_UNUSED
case|:
if|if
condition|(
name|kill
condition|)
block|{
name|rtx
name|next
init|=
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|free_EXPR_LIST_node
argument_list|(
name|link
argument_list|)
expr_stmt|;
operator|*
name|pprev
operator|=
name|link
operator|=
name|next
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
default|default:
name|pprev
operator|=
operator|&
name|XEXP
argument_list|(
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|link
operator|=
operator|*
name|pprev
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|insn
operator|==
name|BB_END
argument_list|(
name|bb
argument_list|)
condition|)
break|break;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Clear LOG_LINKS fields of insns in a selected blocks or whole chain    if blocks is NULL.  */
end_comment

begin_function
specifier|static
name|void
name|clear_log_links
parameter_list|(
name|sbitmap
name|blocks
parameter_list|)
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|blocks
condition|)
block|{
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|INSN_P
argument_list|(
name|insn
argument_list|)
condition|)
name|free_INSN_LIST_list
argument_list|(
operator|&
name|LOG_LINKS
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|blocks
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 	basic_block bb = BASIC_BLOCK (i);  	for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb)); 	     insn = NEXT_INSN (insn)) 	  if (INSN_P (insn)) 	    free_INSN_LIST_list (&LOG_LINKS (insn));       }
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Given a register bitmap, turn on the bits in a HARD_REG_SET that    correspond to the hard registers, if any, set in that map.  This    could be done far more efficiently by having all sorts of special-cases    with moving single words, but probably isn't worth the trouble.  */
end_comment

begin_function
name|void
name|reg_set_to_hard_reg_set
parameter_list|(
name|HARD_REG_SET
modifier|*
name|to
parameter_list|,
name|bitmap
name|from
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|from
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{        if (i>= FIRST_PSEUDO_REGISTER) 	 return;        SET_HARD_REG_BIT (*to, i);      }
argument_list|)
empty_stmt|;
block|}
end_function

end_unit

