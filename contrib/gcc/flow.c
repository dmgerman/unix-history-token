begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Data flow analysis for GNU compiler.    Copyright (C) 1987, 88, 92-98, 1999 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains the data flow analysis pass of the compiler.  It    computes data flow information which tells combine_instructions    which insns to consider combining and controls register allocation.     Additional data flow information that is too bulky to record is    generated during the analysis, and is used at that time to create    autoincrement and autodecrement addressing.     The first step is dividing the function into basic blocks.    find_basic_blocks does this.  Then life_analysis determines    where each register is live and where it is dead.     ** find_basic_blocks **     find_basic_blocks divides the current function's rtl into basic    blocks and constructs the CFG.  The blocks are recorded in the    basic_block_info array; the CFG exists in the edge structures    referenced by the blocks.     find_basic_blocks also finds any unreachable loops and deletes them.     ** life_analysis **     life_analysis is called immediately after find_basic_blocks.    It uses the basic block information to determine where each    hard or pseudo register is live.     ** live-register info **     The information about where each register is live is in two parts:    the REG_NOTES of insns, and the vector basic_block->global_live_at_start.     basic_block->global_live_at_start has an element for each basic    block, and the element is a bit-vector with a bit for each hard or    pseudo register.  The bit is 1 if the register is live at the    beginning of the basic block.     Two types of elements can be added to an insn's REG_NOTES.      A REG_DEAD note is added to an insn's REG_NOTES for any register    that meets both of two conditions:  The value in the register is not    needed in subsequent insns and the insn does not replace the value in    the register (in the case of multi-word hard registers, the value in    each register must be replaced by the insn to avoid a REG_DEAD note).     In the vast majority of cases, an object in a REG_DEAD note will be    used somewhere in the insn.  The (rare) exception to this is if an    insn uses a multi-word hard register and only some of the registers are    needed in subsequent insns.  In that case, REG_DEAD notes will be    provided for those hard registers that are not subsequently needed.    Partial REG_DEAD notes of this type do not occur when an insn sets    only some of the hard registers used in such a multi-word operand;    omitting REG_DEAD notes for objects stored in an insn is optional and    the desire to do so does not justify the complexity of the partial    REG_DEAD notes.     REG_UNUSED notes are added for each register that is set by the insn    but is unused subsequently (if every register set by the insn is unused    and the insn does not reference memory or have some other side-effect,    the insn is deleted instead).  If only part of a multi-word hard    register is used in a subsequent insn, REG_UNUSED notes are made for    the parts that will not be used.     To determine which registers are live after any insn, one can    start from the beginning of the basic block and scan insns, noting    which registers are set by each insn and which die there.     ** Other actions of life_analysis **     life_analysis sets up the LOG_LINKS fields of insns because the    information needed to do so is readily available.     life_analysis deletes insns whose only effect is to store a value    that is never used.     life_analysis notices cases where a reference to a register as    a memory address can be combined with a preceding or following    incrementation or decrementation of the register.  The separate    instruction to increment or decrement is deleted and the address    is changed to a POST_INC or similar rtx.     Each time an incrementing or decrementing address is created,    a REG_INC element is added to the insn's REG_NOTES list.     life_analysis fills in certain vectors containing information about    register usage: reg_n_refs, reg_n_deaths, reg_n_sets, reg_live_length,    reg_n_calls_crosses and reg_basic_block.     life_analysis sets current_function_sp_is_unchanging if the function    doesn't modify the stack pointer.  */
end_comment

begin_comment
comment|/* TODO:      Split out from life_analysis: 	- local property discovery (bb->local_live, bb->local_set) 	- global property computation 	- log links creation 	- pre/post modify transformation */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,    the stack pointer does not matter.  The value is tested only in    functions that have frame pointers.    No definition is equivalent to always zero.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EXIT_IGNORE_STACK
end_ifndef

begin_define
define|#
directive|define
name|EXIT_IGNORE_STACK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The contents of the current function definition are allocated    in this obstack, and all are freed at the end of the function.    For top-level functions, this is temporary_obstack.    Separate obstacks are made for nested functions.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|function_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of labels that must never be deleted.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|forced_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of basic blocks in the current function.  */
end_comment

begin_decl_stmt
name|int
name|n_basic_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The basic block array.  */
end_comment

begin_decl_stmt
name|varray_type
name|basic_block_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The special entry and exit blocks.  */
end_comment

begin_decl_stmt
name|struct
name|basic_block_def
name|entry_exit_blocks
index|[
literal|2
index|]
init|=
block|{
block|{
name|NULL
block|,
comment|/* head */
name|NULL
block|,
comment|/* end */
name|NULL
block|,
comment|/* pred */
name|NULL
block|,
comment|/* succ */
name|NULL
block|,
comment|/* local_set */
name|NULL
block|,
comment|/* global_live_at_start */
name|NULL
block|,
comment|/* global_live_at_end */
name|NULL
block|,
comment|/* aux */
name|ENTRY_BLOCK
block|,
comment|/* index */
literal|0
comment|/* loop_depth */
block|}
block|,
block|{
name|NULL
block|,
comment|/* head */
name|NULL
block|,
comment|/* end */
name|NULL
block|,
comment|/* pred */
name|NULL
block|,
comment|/* succ */
name|NULL
block|,
comment|/* local_set */
name|NULL
block|,
comment|/* global_live_at_start */
name|NULL
block|,
comment|/* global_live_at_end */
name|NULL
block|,
comment|/* aux */
name|EXIT_BLOCK
block|,
comment|/* index */
literal|0
comment|/* loop_depth */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if the second flow pass has completed.  */
end_comment

begin_decl_stmt
name|int
name|flow2_completed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum register number used in this function, plus one.  */
end_comment

begin_decl_stmt
name|int
name|max_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, giving various register information */
end_comment

begin_decl_stmt
name|varray_type
name|reg_n_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the reg_n_info table.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|reg_n_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the next insn that uses (hard or pseudo) register number N    within the current basic block; or zero, if there is no such insn.    This is valid only during the final backward scan in propagate_block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_next_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of a regset for the current function,    in (1) bytes and (2) elements.  */
end_comment

begin_decl_stmt
name|int
name|regset_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regset_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regset of regs live when calls to `setjmp'-like functions happen.  */
end_comment

begin_comment
comment|/* ??? Does this exist only for the setjmp-clobbered warning message?  */
end_comment

begin_decl_stmt
name|regset
name|regs_live_at_setjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List made of EXPR_LIST rtx's which gives pairs of pseudo registers    that have to go in the same hard reg.    The first two regs in the list are a pair, and the next two    are another pair, etc.  */
end_comment

begin_decl_stmt
name|rtx
name|regs_may_share
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Depth within loops of basic block being scanned for lifetime analysis,    plus one.  This is the weight attached to references to registers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During propagate_block, this is non-zero if the value of CC0 is live.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cc0_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During propagate_block, this contains a list of all the MEMs we are    tracking for dead store elimination.      ?!? Note we leak memory by not free-ing items on this list.  We need to    write some generic routines to operate on memory lists since cse, gcse,    loop, sched, flow and possibly other passes all need to do basically the    same operations on these lists.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|mem_set_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of registers that may be eliminable.  These are handled specially    in updating regs_ever_live.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|elim_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The basic block structure for every insn, indexed by uid.  */
end_comment

begin_decl_stmt
name|varray_type
name|basic_block_for_insn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The labels mentioned in non-jump rtl.  Valid during find_basic_blocks.  */
end_comment

begin_comment
comment|/* ??? Should probably be using LABEL_NUSES instead.  It would take a     bit of surgery to be able to use or co-opt the routines in jump.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|label_value_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INSN_VOLATILE (insn) is 1 if the insn refers to anything volatile.  */
end_comment

begin_define
define|#
directive|define
name|INSN_VOLATILE
parameter_list|(
name|INSN
parameter_list|)
value|bitmap_bit_p (uid_volatile, INSN_UID (INSN))
end_define

begin_define
define|#
directive|define
name|SET_INSN_VOLATILE
parameter_list|(
name|INSN
parameter_list|)
value|bitmap_set_bit (uid_volatile, INSN_UID (INSN))
end_define

begin_decl_stmt
specifier|static
name|bitmap
name|uid_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|int
name|count_basic_blocks
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|find_basic_blocks_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|create_basic_block
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compute_bb_for_insn
name|PROTO
argument_list|(
operator|(
name|varray_type
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|clear_edges
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_edges
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_edge
name|PROTO
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_label_edge
name|PROTO
argument_list|(
operator|(
name|basic_block
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_critical_edges
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|commit_one_edge_insertion
name|PROTO
argument_list|(
operator|(
name|edge
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_unreachable_blocks
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_eh_regions
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_delete_note_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_insn_chain
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|delete_block
name|PROTO
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expunge_block
name|PROTO
argument_list|(
operator|(
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|flow_delete_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|can_delete_label_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_blocks_nomove
name|PROTO
argument_list|(
operator|(
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|merge_blocks
name|PROTO
argument_list|(
operator|(
name|edge
operator|,
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tidy_fallthru_edge
name|PROTO
argument_list|(
operator|(
name|edge
operator|,
name|basic_block
operator|,
name|basic_block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|calculate_loop_depth
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_noop_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noop_move_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|notice_stack_pointer_modification
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_volatile_insns
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_regs_live_at_end
name|PROTO
argument_list|(
operator|(
name|regset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|life_analysis_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_regset_vector
name|PROTO
argument_list|(
operator|(
name|regset
operator|*
operator|,
name|int
operator|,
expr|struct
name|obstack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|propagate_block
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|regset
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_dead_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|regset
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|libcall_dead_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_set_regs
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|regset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_set_1
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|regset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|find_auto_inc
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_pre_increment_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_pre_increment
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|mark_used_regs
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|regset
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dump_flow_info
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dump_edge_info
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|edge
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int_list_ptr
name|alloc_int_list_node
name|PROTO
argument_list|(
operator|(
name|int_list_block
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int_list_ptr
name|add_int_list_node
name|PROTO
argument_list|(
operator|(
name|int_list_block
operator|*
operator|*
operator|,
name|int_list
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_pred_succ
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|int_list_ptr
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_reg_sets_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_reg_sets
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_reg_references
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|notice_stack_pointer_modification
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|invalidate_mems_from_autoinc
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|verify_flow_info
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Find basic blocks of the current function.    F is the first insn of the function and NREGS the number of register    numbers in use.  */
end_comment

begin_function
name|void
name|find_basic_blocks
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|file
parameter_list|,
name|do_cleanup
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|FILE
modifier|*
name|file
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|int
name|do_cleanup
decl_stmt|;
block|{
name|rtx
modifier|*
name|bb_eh_end
decl_stmt|;
name|int
name|max_uid
decl_stmt|;
comment|/* Flush out existing data.  */
if|if
condition|(
name|basic_block_info
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|clear_edges
argument_list|()
expr_stmt|;
comment|/* Clear bb->aux on all extant basic blocks.  We'll use this as a  	 tag for reuse during create_basic_block, just in case some pass 	 copies around basic block notes improperly.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|basic_block_info
argument_list|)
expr_stmt|;
block|}
name|n_basic_blocks
operator|=
name|count_basic_blocks
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Size the basic block table.  The actual structures will be allocated      by find_basic_blocks_1, since we want to keep the structure pointers      stable across calls to find_basic_blocks.  */
comment|/* ??? This whole issue would be much simpler if we called find_basic_blocks      exactly once, and thereafter we don't have a single long chain of       instructions at all until close to the end of compilation when we      actually lay them out.  */
name|VARRAY_BB_INIT
argument_list|(
name|basic_block_info
argument_list|,
name|n_basic_blocks
argument_list|,
literal|"basic_block_info"
argument_list|)
expr_stmt|;
comment|/* An array to record the active exception region at the end of each      basic block.  It is filled in by find_basic_blocks_1 for make_edges.  */
name|bb_eh_end
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|label_value_list
operator|=
name|find_basic_blocks_1
argument_list|(
name|f
argument_list|,
name|bb_eh_end
argument_list|)
expr_stmt|;
comment|/* Record the block to which an insn belongs.  */
comment|/* ??? This should be done another way, by which (perhaps) a label is      tagged directly with the basic block that it starts.  It is used for      more than that currently, but IMO that is the only valid use.  */
name|max_uid
operator|=
name|get_max_uid
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Leave space for insns life_analysis makes in some cases for auto-inc.      These cases are rare, so we don't need too much space.  */
name|max_uid
operator|+=
name|max_uid
operator|/
literal|10
expr_stmt|;
endif|#
directive|endif
name|VARRAY_BB_INIT
argument_list|(
name|basic_block_for_insn
argument_list|,
name|max_uid
argument_list|,
literal|"basic_block_for_insn"
argument_list|)
expr_stmt|;
name|compute_bb_for_insn
argument_list|(
name|basic_block_for_insn
argument_list|,
name|max_uid
argument_list|)
expr_stmt|;
comment|/* Discover the edges of our cfg.  */
name|make_edges
argument_list|(
name|label_value_list
argument_list|,
name|bb_eh_end
argument_list|)
expr_stmt|;
comment|/* Delete unreachable blocks.  */
if|if
condition|(
name|do_cleanup
condition|)
name|delete_unreachable_blocks
argument_list|()
expr_stmt|;
comment|/* Mark critical edges.  */
name|mark_critical_edges
argument_list|()
expr_stmt|;
comment|/* Discover the loop depth at the start of each basic block to aid      register allocation.  */
name|calculate_loop_depth
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Kill the data we won't maintain.  */
name|label_value_list
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|verify_flow_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Count the basic blocks of the function.  */
end_comment

begin_function
specifier|static
name|int
name|count_basic_blocks
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|RTX_CODE
name|prev_code
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|eh_region
init|=
literal|0
decl_stmt|;
name|int
name|call_had_abnormal_edge
init|=
literal|0
decl_stmt|;
name|rtx
name|prev_call
init|=
name|NULL_RTX
decl_stmt|;
name|prev_code
operator|=
name|JUMP_INSN
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|prev_code
operator|==
name|JUMP_INSN
operator|||
name|prev_code
operator|==
name|BARRIER
operator|||
operator|(
name|prev_code
operator|==
name|CALL_INSN
operator|&&
name|call_had_abnormal_edge
operator|)
operator|)
operator|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
comment|/* If the previous insn was a call that did not create an 	     abnormal edge, we want to add a nop so that the CALL_INSN 	     itself is not at basic_block_end.  This allows us to 	     easily distinguish between normal calls and those which 	     create abnormal edges in the flow graph.  */
if|if
condition|(
name|count
operator|>
literal|0
operator|&&
name|prev_call
operator|!=
literal|0
operator|&&
operator|!
name|call_had_abnormal_edge
condition|)
block|{
name|rtx
name|nop
init|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
name|emit_insn_after
argument_list|(
name|nop
argument_list|,
name|prev_call
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record whether this call created an edge.  */
if|if
condition|(
name|code
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|int
name|region
init|=
operator|(
name|note
condition|?
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
name|prev_call
operator|=
name|insn
expr_stmt|;
name|call_had_abnormal_edge
operator|=
literal|0
expr_stmt|;
comment|/* If there is a specified EH region, we have an edge.  */
if|if
condition|(
name|eh_region
operator|&&
name|region
operator|>
literal|0
condition|)
name|call_had_abnormal_edge
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* If there is a nonlocal goto label and the specified 		 region number isn't -1, we have an edge. (0 means 		 no throw, but might have a nonlocal goto).  */
if|if
condition|(
name|nonlocal_goto_handler_labels
operator|&&
name|region
operator|>=
literal|0
condition|)
name|call_had_abnormal_edge
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_call
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
operator|++
name|eh_region
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
operator|--
name|eh_region
expr_stmt|;
block|}
comment|/* The rest of the compiler works a bit smoother when we don't have to      check for the edge case of do-nothing functions with no basic blocks.  */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|emit_insn
argument_list|(
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Find all basic blocks of the function whose first insn is F.    Store the correct data in the tables that describe the basic blocks,    set up the chains of references for each CODE_LABEL, and    delete any entire basic blocks that cannot be reached.     NONLOCAL_LABEL_LIST is a list of non-local labels in the function.  Blocks    that are otherwise unreachable may be reachable with a non-local goto.     BB_EH_END is an array in which we record the list of exception regions    active at the end of every basic block.  */
end_comment

begin_function
specifier|static
name|rtx
name|find_basic_blocks_1
parameter_list|(
name|f
parameter_list|,
name|bb_eh_end
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|rtx
modifier|*
name|bb_eh_end
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|,
name|next
decl_stmt|;
name|int
name|call_has_abnormal_edge
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|rtx
name|bb_note
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|eh_list
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|label_value_list
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|head
init|=
name|NULL_RTX
decl_stmt|;
name|rtx
name|end
init|=
name|NULL_RTX
decl_stmt|;
comment|/* We process the instructions in a slightly different way than we did      previously.  This is so that we see a NOTE_BASIC_BLOCK after we have      closed out the previous block, so that it gets attached at the proper      place.  Since this form should be equivalent to the previous,      find_basic_blocks_0 continues to use the old form as a check.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|next
control|)
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CALL_INSN
condition|)
block|{
comment|/* Record whether this call created an edge.  */
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|int
name|region
init|=
operator|(
name|note
condition|?
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
else|:
literal|1
operator|)
decl_stmt|;
name|call_has_abnormal_edge
operator|=
literal|0
expr_stmt|;
comment|/* If there is an EH region, we have an edge.  */
if|if
condition|(
name|eh_list
operator|&&
name|region
operator|>
literal|0
condition|)
name|call_has_abnormal_edge
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* If there is a nonlocal goto label and the specified 		 region number isn't -1, we have an edge. (0 means 		 no throw, but might have a nonlocal goto).  */
if|if
condition|(
name|nonlocal_goto_handler_labels
operator|&&
name|region
operator|>=
literal|0
condition|)
name|call_has_abnormal_edge
operator|=
literal|1
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOTE
case|:
block|{
name|int
name|kind
init|=
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Keep a LIFO list of the currently active exception notes.  */
if|if
condition|(
name|kind
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
name|eh_list
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|eh_list
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
name|eh_list
operator|=
name|XEXP
argument_list|(
name|eh_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Look for basic block notes with which to keep the  	       basic_block_info pointers stable.  Unthread the note now; 	       we'll put it back at the right place in create_basic_block. 	       Or not at all if we've already found a note in this block.  */
elseif|else
if|if
condition|(
name|kind
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
if|if
condition|(
name|bb_note
operator|==
name|NULL_RTX
condition|)
name|bb_note
operator|=
name|insn
expr_stmt|;
name|next
operator|=
name|flow_delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CODE_LABEL
case|:
comment|/* A basic block starts at a label.  If we've closed one off due  	     to a barrier or some such, no need to do it again.  */
if|if
condition|(
name|head
operator|!=
name|NULL_RTX
condition|)
block|{
comment|/* While we now have edge lists with which other portions of 		 the compiler might determine a call ending a basic block 		 does not imply an abnormal edge, it will be a bit before 		 everything can be updated.  So continue to emit a noop at 		 the end of such a block.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|end
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|nop
init|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
name|end
operator|=
name|emit_insn_after
argument_list|(
name|nop
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
name|bb_eh_end
index|[
name|i
index|]
operator|=
name|eh_list
expr_stmt|;
name|create_basic_block
argument_list|(
name|i
operator|++
argument_list|,
name|head
argument_list|,
name|end
argument_list|,
name|bb_note
argument_list|)
expr_stmt|;
name|bb_note
operator|=
name|NULL_RTX
expr_stmt|;
block|}
name|head
operator|=
name|end
operator|=
name|insn
expr_stmt|;
break|break;
case|case
name|JUMP_INSN
case|:
comment|/* A basic block ends at a jump.  */
if|if
condition|(
name|head
operator|==
name|NULL_RTX
condition|)
name|head
operator|=
name|insn
expr_stmt|;
else|else
block|{
comment|/* ??? Make a special check for table jumps.  The way this  		 happens is truely and amazingly gross.  We are about to 		 create a basic block that contains just a code label and 		 an addr*vec jump insn.  Worse, an addr_diff_vec creates 		 its own natural loop.  		 Prevent this bit of brain damage, pasting things together 		 correctly in make_edges.    		 The correct solution involves emitting the table directly 		 on the tablejump instruction as a note, or JUMP_LABEL.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
condition|)
block|{
name|head
operator|=
name|end
operator|=
name|NULL
expr_stmt|;
name|n_basic_blocks
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|end
operator|=
name|insn
expr_stmt|;
goto|goto
name|new_bb_inclusive
goto|;
case|case
name|BARRIER
case|:
comment|/* A basic block ends at a barrier.  It may be that an unconditional 	     jump already closed the basic block -- no need to do it again.  */
if|if
condition|(
name|head
operator|==
name|NULL_RTX
condition|)
break|break;
comment|/* While we now have edge lists with which other portions of the 	     compiler might determine a call ending a basic block does not 	     imply an abnormal edge, it will be a bit before everything can 	     be updated.  So continue to emit a noop at the end of such a 	     block.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|end
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|nop
init|=
name|gen_rtx_USE
argument_list|(
name|VOIDmode
argument_list|,
name|const0_rtx
argument_list|)
decl_stmt|;
name|end
operator|=
name|emit_insn_after
argument_list|(
name|nop
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
goto|goto
name|new_bb_exclusive
goto|;
case|case
name|CALL_INSN
case|:
comment|/* A basic block ends at a call that can either throw or 	     do a non-local goto.  */
if|if
condition|(
name|call_has_abnormal_edge
condition|)
block|{
name|new_bb_inclusive
label|:
if|if
condition|(
name|head
operator|==
name|NULL_RTX
condition|)
name|head
operator|=
name|insn
expr_stmt|;
name|end
operator|=
name|insn
expr_stmt|;
name|new_bb_exclusive
label|:
name|bb_eh_end
index|[
name|i
index|]
operator|=
name|eh_list
expr_stmt|;
name|create_basic_block
argument_list|(
name|i
operator|++
argument_list|,
name|head
argument_list|,
name|end
argument_list|,
name|bb_note
argument_list|)
expr_stmt|;
name|head
operator|=
name|end
operator|=
name|NULL_RTX
expr_stmt|;
name|bb_note
operator|=
name|NULL_RTX
expr_stmt|;
break|break;
block|}
comment|/* FALLTHRU */
default|default:
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|head
operator|==
name|NULL_RTX
condition|)
name|head
operator|=
name|insn
expr_stmt|;
name|end
operator|=
name|insn
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|note
decl_stmt|;
comment|/* Make a list of all labels referred to other than by jumps 	     (which just don't have the REG_LABEL notes).   	     Make a special exception for labels followed by an ADDR*VEC, 	     as this would be a part of the tablejump setup code.   	     Make a special exception for the eh_return_stub_label, which 	     we know isn't part of any otherwise visible control flow.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
condition|)
block|{
name|rtx
name|lab
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|next
decl_stmt|;
if|if
condition|(
name|lab
operator|==
name|eh_return_stub_label
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|lab
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
empty_stmt|;
else|else
name|label_value_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_value_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|head
operator|!=
name|NULL_RTX
condition|)
block|{
name|bb_eh_end
index|[
name|i
index|]
operator|=
name|eh_list
expr_stmt|;
name|create_basic_block
argument_list|(
name|i
operator|++
argument_list|,
name|head
argument_list|,
name|end
argument_list|,
name|bb_note
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|label_value_list
return|;
block|}
end_function

begin_comment
comment|/* Create a new basic block consisting of the instructions between    HEAD and END inclusive.  Reuses the note and basic block struct    in BB_NOTE, if any.  */
end_comment

begin_function
specifier|static
name|void
name|create_basic_block
parameter_list|(
name|index
parameter_list|,
name|head
parameter_list|,
name|end
parameter_list|,
name|bb_note
parameter_list|)
name|int
name|index
decl_stmt|;
name|rtx
name|head
decl_stmt|,
name|end
decl_stmt|,
name|bb_note
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|bb_note
operator|&&
operator|!
name|RTX_INTEGRATED_P
argument_list|(
name|bb_note
argument_list|)
operator|&&
operator|(
name|bb
operator|=
name|NOTE_BASIC_BLOCK
argument_list|(
name|bb_note
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|bb
operator|->
name|aux
operator|==
name|NULL
condition|)
block|{
comment|/* If we found an existing note, thread it back onto the chain.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|add_insn_after
argument_list|(
name|bb_note
argument_list|,
name|head
argument_list|)
expr_stmt|;
else|else
block|{
name|add_insn_before
argument_list|(
name|bb_note
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|bb_note
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise we must create a note and a basic block structure. 	 Since we allow basic block structs in rtl, give the struct 	 the same lifetime by allocating it off the function obstack 	 rather than using malloc.  */
name|bb
operator|=
operator|(
name|basic_block
operator|)
name|obstack_alloc
argument_list|(
name|function_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|bb_note
operator|=
name|emit_note_after
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|head
argument_list|)
expr_stmt|;
else|else
block|{
name|bb_note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|bb_note
expr_stmt|;
block|}
name|NOTE_BASIC_BLOCK
argument_list|(
name|bb_note
argument_list|)
operator|=
name|bb
expr_stmt|;
block|}
comment|/* Always include the bb note in the block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|end
argument_list|)
operator|==
name|bb_note
condition|)
name|end
operator|=
name|bb_note
expr_stmt|;
name|bb
operator|->
name|head
operator|=
name|head
expr_stmt|;
name|bb
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|bb
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|BASIC_BLOCK
argument_list|(
name|index
argument_list|)
operator|=
name|bb
expr_stmt|;
comment|/* Tag the block so that we know it has been used when considering      other basic block notes.  */
name|bb
operator|->
name|aux
operator|=
name|bb
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Records the basic block struct in BB_FOR_INSN, for every instruction    indexed by INSN_UID.  MAX is the size of the array.  */
end_comment

begin_function
specifier|static
name|void
name|compute_bb_for_insn
parameter_list|(
name|bb_for_insn
parameter_list|,
name|max
parameter_list|)
name|varray_type
name|bb_for_insn
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|end
decl_stmt|;
name|end
operator|=
name|bb
operator|->
name|end
expr_stmt|;
name|insn
operator|=
name|bb
operator|->
name|head
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|uid
operator|<
name|max
condition|)
name|VARRAY_BB
argument_list|(
name|bb_for_insn
argument_list|,
name|uid
argument_list|)
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|end
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Free the memory associated with the edge structures.  */
end_comment

begin_function
specifier|static
name|void
name|clear_edges
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|edge
name|n
decl_stmt|,
name|e
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|n
control|)
block|{
name|n
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|bb
operator|->
name|succ
operator|=
literal|0
expr_stmt|;
name|bb
operator|->
name|pred
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|n
control|)
block|{
name|n
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|ENTRY_BLOCK_PTR
operator|->
name|succ
operator|=
literal|0
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|pred
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Identify the edges between basic blocks.     NONLOCAL_LABEL_LIST is a list of non-local labels in the function.  Blocks    that are otherwise unreachable may be reachable with a non-local goto.     BB_EH_END is an array indexed by basic block number in which we record     the list of exception regions active at the end of the basic block.  */
end_comment

begin_function
specifier|static
name|void
name|make_edges
parameter_list|(
name|label_value_list
parameter_list|,
name|bb_eh_end
parameter_list|)
name|rtx
name|label_value_list
decl_stmt|;
name|rtx
modifier|*
name|bb_eh_end
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* Assume no computed jump; revise as we create edges.  */
name|current_function_has_computed_jump
operator|=
literal|0
expr_stmt|;
comment|/* By nature of the way these get numbered, block 0 is always the entry.  */
name|make_edge
argument_list|(
name|ENTRY_BLOCK_PTR
argument_list|,
name|BASIC_BLOCK
argument_list|(
literal|0
argument_list|)
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|x
decl_stmt|,
name|eh_list
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|int
name|force_fallthru
init|=
literal|0
decl_stmt|;
comment|/* If we have asynchronous exceptions, scan the notes for all exception 	 regions active in the block.  In the normal case, we only need the 	 one active at the end of the block, which is bb_eh_end[i].  */
name|eh_list
operator|=
name|bb_eh_end
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|asynchronous_exceptions
condition|)
block|{
for|for
control|(
name|insn
operator|=
name|bb
operator|->
name|end
init|;
name|insn
operator|!=
name|bb
operator|->
name|head
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
name|eh_list
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|eh_list
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now examine the last instruction of the block, and discover the 	 ways we can leave the block.  */
name|insn
operator|=
name|bb
operator|->
name|end
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A branch.  */
if|if
condition|(
name|code
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|tmp
decl_stmt|;
comment|/* ??? Recognize a tablejump and do the right thing.  */
if|if
condition|(
operator|(
name|tmp
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtvec
name|vec
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
condition|)
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|make_label_edge
argument_list|(
name|bb
argument_list|,
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Some targets (eg, ARM) emit a conditional jump that also 		 contains the out-of-range target.  Scan for these and 		 add an edge if necessary.  */
if|if
condition|(
operator|(
name|tmp
operator|=
name|single_set
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|SET_DEST
argument_list|(
name|tmp
argument_list|)
operator|==
name|pc_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|IF_THEN_ELSE
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|make_label_edge
argument_list|(
name|bb
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CASE_DROPS_THROUGH
comment|/* Silly VAXen.  The ADDR_VEC is going to be in the way of 		 us naturally detecting fallthru into the next block.  */
name|force_fallthru
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* If this is a computed jump, then mark it as reaching 	     everything on the label_value_list and forced_labels list.  */
elseif|else
if|if
condition|(
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|current_function_has_computed_jump
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
name|label_value_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|make_label_edge
argument_list|(
name|bb
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EDGE_ABNORMAL
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|make_label_edge
argument_list|(
name|bb
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EDGE_ABNORMAL
argument_list|)
expr_stmt|;
block|}
comment|/* Returns create an exit out.  */
elseif|else
if|if
condition|(
name|returnjump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|make_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Otherwise, we have a plain conditional or unconditional jump.  */
else|else
block|{
if|if
condition|(
operator|!
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|make_label_edge
argument_list|(
name|bb
argument_list|,
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a CALL_INSN, then mark it as reaching the active EH 	 handler for this CALL_INSN.  If we're handling asynchronous 	 exceptions then any insn can reach any of the active handlers.  	 Also mark the CALL_INSN as reaching any nonlocal goto handler.  */
if|if
condition|(
name|code
operator|==
name|CALL_INSN
operator|||
name|asynchronous_exceptions
condition|)
block|{
name|int
name|is_call
init|=
operator|(
name|code
operator|==
name|CALL_INSN
condition|?
name|EDGE_ABNORMAL_CALL
else|:
literal|0
operator|)
decl_stmt|;
name|handler_info
modifier|*
name|ptr
decl_stmt|;
comment|/* Use REG_EH_RETHROW and REG_EH_REGION if available.  */
comment|/* ??? REG_EH_REGION is not generated presently.  Is it 	     inteded that there be multiple notes for the regions? 	     or is my eh_list collection redundant with handler linking?  */
name|x
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_RETHROW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x
condition|)
name|x
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EH_REGION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
block|{
if|if
condition|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ptr
operator|=
name|get_first_handler
argument_list|(
name|XINT
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
name|make_label_edge
argument_list|(
name|bb
argument_list|,
name|ptr
operator|->
name|handler_label
argument_list|,
name|EDGE_ABNORMAL
operator||
name|EDGE_EH
operator||
name|is_call
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|eh_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|ptr
operator|=
name|get_first_handler
argument_list|(
name|NOTE_BLOCK_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|ptr
condition|)
block|{
name|make_label_edge
argument_list|(
name|bb
argument_list|,
name|ptr
operator|->
name|handler_label
argument_list|,
name|EDGE_ABNORMAL
operator||
name|EDGE_EH
operator||
name|is_call
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|code
operator|==
name|CALL_INSN
operator|&&
name|nonlocal_goto_handler_labels
condition|)
block|{
comment|/* ??? This could be made smarter: in some cases it's possible 		 to tell that certain calls will not do a nonlocal goto.  		 For example, if the nested functions that do the nonlocal 		 gotos do not have their addresses taken, then only calls to 		 those functions or to other nested functions that use them 		 could possibly do nonlocal gotos.  */
for|for
control|(
name|x
operator|=
name|nonlocal_goto_handler_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|make_label_edge
argument_list|(
name|bb
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|EDGE_ABNORMAL
operator||
name|EDGE_ABNORMAL_CALL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We know something about the structure of the function __throw in 	 libgcc2.c.  It is the only function that ever contains eh_stub 	 labels.  It modifies its return address so that the last block 	 returns to one of the eh_stub labels within it.  So we have to 	 make additional edges in the flow graph.  */
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|n_basic_blocks
operator|&&
name|eh_return_stub_label
operator|!=
literal|0
condition|)
name|make_label_edge
argument_list|(
name|bb
argument_list|,
name|eh_return_stub_label
argument_list|,
name|EDGE_EH
argument_list|)
expr_stmt|;
comment|/* Find out if we can drop through to the next block.  */
name|insn
operator|=
name|next_nonnote_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|insn
operator|||
operator|(
name|i
operator|+
literal|1
operator|==
name|n_basic_blocks
operator|&&
name|force_fallthru
operator|)
condition|)
name|make_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|n_basic_blocks
condition|)
block|{
name|rtx
name|tmp
init|=
name|BLOCK_HEAD
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE
condition|)
name|tmp
operator|=
name|next_nonnote_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_fallthru
operator|||
name|insn
operator|==
name|tmp
condition|)
name|make_edge
argument_list|(
name|bb
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create an edge between two basic blocks.  FLAGS are auxiliary information    about the edge that is accumulated between calls.  */
end_comment

begin_function
specifier|static
name|void
name|make_edge
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|flags
parameter_list|)
name|basic_block
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
comment|/* Make sure we don't add duplicate edges.  */
for|for
control|(
name|e
operator|=
name|src
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
name|e
operator|->
name|dest
operator|==
name|dst
condition|)
block|{
name|e
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
return|return;
block|}
name|e
operator|=
operator|(
name|edge
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|succ_next
operator|=
name|src
operator|->
name|succ
expr_stmt|;
name|e
operator|->
name|pred_next
operator|=
name|dst
operator|->
name|pred
expr_stmt|;
name|e
operator|->
name|src
operator|=
name|src
expr_stmt|;
name|e
operator|->
name|dest
operator|=
name|dst
expr_stmt|;
name|e
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|src
operator|->
name|succ
operator|=
name|e
expr_stmt|;
name|dst
operator|->
name|pred
operator|=
name|e
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an edge from a basic block to a label.  */
end_comment

begin_function
specifier|static
name|void
name|make_label_edge
parameter_list|(
name|src
parameter_list|,
name|label
parameter_list|,
name|flags
parameter_list|)
name|basic_block
name|src
decl_stmt|;
name|rtx
name|label
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the label was never emitted, this insn is junk, but avoid a      crash trying to refer to BLOCK_FOR_INSN (label).  This can happen      as a result of a syntax error and a diagnostic has already been      printed.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|make_edge
argument_list|(
name|src
argument_list|,
name|BLOCK_FOR_INSN
argument_list|(
name|label
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Identify critical edges and set the bits appropriately.  */
end_comment

begin_function
specifier|static
name|void
name|mark_critical_edges
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
name|n_basic_blocks
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* We begin with the entry block.  This is not terribly important now,      but could be if a front end (Fortran) implemented alternate entry      points.  */
name|bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|edge
name|e
decl_stmt|;
comment|/* (1) Critical edges must have a source with multiple successors.  */
if|if
condition|(
name|bb
operator|->
name|succ
operator|&&
name|bb
operator|->
name|succ
operator|->
name|succ_next
condition|)
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
comment|/* (2) Critical edges must have a destination with multiple 		 predecessors.  Note that we know there is at least one 		 predecessor -- the edge we followed to get here.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|pred
operator|->
name|pred_next
condition|)
name|e
operator|->
name|flags
operator||=
name|EDGE_CRITICAL
expr_stmt|;
else|else
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_CRITICAL
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_CRITICAL
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|>=
name|n
condition|)
break|break;
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Split a (typically critical) edge.  Return the new block.    Abort on abnormal edges.      ??? The code generally expects to be called on critical edges.    The case of a block ending in an unconditional jump to a     block with multiple predecessors is not handled optimally.  */
end_comment

begin_function
name|basic_block
name|split_edge
parameter_list|(
name|edge_in
parameter_list|)
name|edge
name|edge_in
decl_stmt|;
block|{
name|basic_block
name|old_pred
decl_stmt|,
name|bb
decl_stmt|,
name|old_succ
decl_stmt|;
name|edge
name|edge_out
decl_stmt|;
name|rtx
name|bb_note
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Abnormal edges cannot be split.  */
if|if
condition|(
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|old_pred
operator|=
name|edge_in
operator|->
name|src
expr_stmt|;
name|old_succ
operator|=
name|edge_in
operator|->
name|dest
expr_stmt|;
comment|/* Remove the existing edge from the destination's pred list.  */
block|{
name|edge
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
operator|&
name|old_succ
operator|->
name|pred
init|;
operator|*
name|pp
operator|!=
name|edge_in
condition|;
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|pred_next
control|)
continue|continue;
operator|*
name|pp
operator|=
name|edge_in
operator|->
name|pred_next
expr_stmt|;
name|edge_in
operator|->
name|pred_next
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Create the new structures.  */
name|bb
operator|=
operator|(
name|basic_block
operator|)
name|obstack_alloc
argument_list|(
name|function_obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|edge_out
operator|=
operator|(
name|edge
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|edge_out
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bb
argument_list|)
argument_list|)
expr_stmt|;
name|bb
operator|->
name|local_set
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
name|bb
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
name|bb
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
comment|/* ??? This info is likely going to be out of date very soon.  */
name|CLEAR_REG_SET
argument_list|(
name|bb
operator|->
name|local_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_succ
operator|->
name|global_live_at_start
condition|)
block|{
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|old_succ
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|old_succ
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CLEAR_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
block|}
comment|/* Wire them up.  */
name|bb
operator|->
name|pred
operator|=
name|edge_in
expr_stmt|;
name|bb
operator|->
name|succ
operator|=
name|edge_out
expr_stmt|;
name|edge_in
operator|->
name|dest
operator|=
name|bb
expr_stmt|;
name|edge_in
operator|->
name|flags
operator|&=
operator|~
name|EDGE_CRITICAL
expr_stmt|;
name|edge_out
operator|->
name|pred_next
operator|=
name|old_succ
operator|->
name|pred
expr_stmt|;
name|edge_out
operator|->
name|succ_next
operator|=
name|NULL
expr_stmt|;
name|edge_out
operator|->
name|src
operator|=
name|bb
expr_stmt|;
name|edge_out
operator|->
name|dest
operator|=
name|old_succ
expr_stmt|;
name|edge_out
operator|->
name|flags
operator|=
name|EDGE_FALLTHRU
expr_stmt|;
name|edge_out
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|old_succ
operator|->
name|pred
operator|=
name|edge_out
expr_stmt|;
comment|/* Tricky case -- if there existed a fallthru into the successor      (and we're not it) we must add a new unconditional jump around      the new block we're actually interested in.        Further, if that edge is critical, this means a second new basic      block must be created to hold it.  In order to simplify correct      insn placement, do this before we touch the existing basic block      ordering for the block we were really wanting.  */
if|if
condition|(
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
block|{
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|edge_out
operator|->
name|pred_next
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
break|break;
if|if
condition|(
name|e
condition|)
block|{
name|basic_block
name|jump_block
decl_stmt|;
name|rtx
name|pos
decl_stmt|;
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_CRITICAL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Non critical -- we can simply add a jump to the end 		 of the existing predecessor.  */
name|jump_block
operator|=
name|e
operator|->
name|src
expr_stmt|;
block|}
else|else
block|{
comment|/* We need a new block to hold the jump.  The simplest 	         way to do the bulk of the work here is to recursively 	         call ourselves.  */
name|jump_block
operator|=
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|e
operator|=
name|jump_block
operator|->
name|succ
expr_stmt|;
block|}
comment|/* Now add the jump insn ...  */
name|pos
operator|=
name|emit_jump_insn_after
argument_list|(
name|gen_jump
argument_list|(
name|old_succ
operator|->
name|head
argument_list|)
argument_list|,
name|jump_block
operator|->
name|end
argument_list|)
expr_stmt|;
name|jump_block
operator|->
name|end
operator|=
name|pos
expr_stmt|;
name|emit_barrier_after
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|/* ... let jump know that label is in use, ...  */
operator|++
name|LABEL_NUSES
argument_list|(
name|old_succ
operator|->
name|head
argument_list|)
expr_stmt|;
comment|/* ... and clear fallthru on the outgoing edge.  */
name|e
operator|->
name|flags
operator|&=
operator|~
name|EDGE_FALLTHRU
expr_stmt|;
comment|/* Continue splitting the interesting edge.  */
block|}
block|}
comment|/* Place the new block just in front of the successor.  */
name|VARRAY_GROW
argument_list|(
name|basic_block_info
argument_list|,
operator|++
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>
name|old_succ
operator|->
name|index
condition|;
operator|--
name|i
control|)
block|{
name|basic_block
name|tmp
init|=
name|BASIC_BLOCK
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|->
name|index
operator|=
name|i
expr_stmt|;
block|}
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|=
name|bb
expr_stmt|;
name|bb
operator|->
name|index
operator|=
name|i
expr_stmt|;
comment|/* Create the basic block note.  */
name|bb_note
operator|=
name|emit_note_before
argument_list|(
name|NOTE_INSN_BASIC_BLOCK
argument_list|,
name|old_succ
operator|->
name|head
argument_list|)
expr_stmt|;
name|NOTE_BASIC_BLOCK
argument_list|(
name|bb_note
argument_list|)
operator|=
name|bb
expr_stmt|;
name|bb
operator|->
name|head
operator|=
name|bb
operator|->
name|end
operator|=
name|bb_note
expr_stmt|;
comment|/* Not quite simple -- for non-fallthru edges, we must adjust the      predecessor's jump instruction to target our new block.  */
if|if
condition|(
operator|(
name|edge_in
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
block|{
name|rtx
name|tmp
decl_stmt|,
name|insn
init|=
name|old_pred
operator|->
name|end
decl_stmt|;
name|rtx
name|old_label
init|=
name|old_succ
operator|->
name|head
decl_stmt|;
name|rtx
name|new_label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* ??? Recognize a tablejump and adjust all matching cases.  */
if|if
condition|(
operator|(
name|tmp
operator|=
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtvec
name|vec
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
condition|)
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|vec
operator|=
name|XVEC
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|GET_NUM_ELEM
argument_list|(
name|vec
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
if|if
condition|(
name|XEXP
argument_list|(
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|old_label
condition|)
block|{
name|RTVEC_ELT
argument_list|(
name|vec
argument_list|,
name|j
argument_list|)
operator|=
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
operator|--
name|LABEL_NUSES
argument_list|(
name|old_label
argument_list|)
expr_stmt|;
operator|++
name|LABEL_NUSES
argument_list|(
name|new_label
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This would have indicated an abnormal edge.  */
if|if
condition|(
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* A return instruction can't be redirected.  */
if|if
condition|(
name|returnjump_p
argument_list|(
name|insn
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the insn doesn't go where we think, we're confused.  */
if|if
condition|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
operator|!=
name|old_label
condition|)
name|abort
argument_list|()
expr_stmt|;
name|redirect_jump
argument_list|(
name|insn
argument_list|,
name|new_label
argument_list|)
expr_stmt|;
block|}
name|emit_label_before
argument_list|(
name|new_label
argument_list|,
name|bb_note
argument_list|)
expr_stmt|;
name|bb
operator|->
name|head
operator|=
name|new_label
expr_stmt|;
block|}
return|return
name|bb
return|;
block|}
end_function

begin_comment
comment|/* Queue instructions for insertion on an edge between two basic blocks.    The new instructions and basic blocks (if any) will not appear in the    CFG until commit_edge_insertions is called.  */
end_comment

begin_function
name|void
name|insert_insn_on_edge
parameter_list|(
name|pattern
parameter_list|,
name|e
parameter_list|)
name|rtx
name|pattern
decl_stmt|;
name|edge
name|e
decl_stmt|;
block|{
comment|/* We cannot insert instructions on an abnormal critical edge.      It will be easier to find the culprit if we die now.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_CRITICAL
operator|)
operator|)
operator|==
operator|(
name|EDGE_ABNORMAL
operator||
name|EDGE_CRITICAL
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|insns
operator|==
name|NULL_RTX
condition|)
name|start_sequence
argument_list|()
expr_stmt|;
else|else
name|push_to_sequence
argument_list|(
name|e
operator|->
name|insns
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
name|e
operator|->
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the CFG for the instructions queued on edge E.  */
end_comment

begin_function
specifier|static
name|void
name|commit_one_edge_insertion
parameter_list|(
name|e
parameter_list|)
name|edge
name|e
decl_stmt|;
block|{
name|rtx
name|before
init|=
name|NULL_RTX
decl_stmt|,
name|after
init|=
name|NULL_RTX
decl_stmt|,
name|tmp
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* Figure out where to put these things.  If the destination has      one predecessor, insert there.  Except for the exit block.  */
if|if
condition|(
name|e
operator|->
name|dest
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
operator|&&
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|bb
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* Get the location correct wrt a code label, and "nice" wrt 	 a basic block note, and before everything else.  */
name|tmp
operator|=
name|bb
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|tmp
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|bb
operator|->
name|head
condition|)
name|before
operator|=
name|tmp
expr_stmt|;
else|else
name|after
operator|=
name|PREV_INSN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* If the source has one successor and the edge is not abnormal,      insert there.  Except for the entry block.  */
elseif|else
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
operator|)
operator|==
literal|0
operator|&&
name|e
operator|->
name|src
operator|->
name|succ
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|bb
operator|=
name|e
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|bb
operator|->
name|end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* ??? Is it possible to wind up with non-simple jumps?  Perhaps 	     a jump with delay slots already filled?  */
if|if
condition|(
operator|!
name|simplejump_p
argument_list|(
name|bb
operator|->
name|end
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|before
operator|=
name|bb
operator|->
name|end
expr_stmt|;
block|}
else|else
block|{
comment|/* We'd better be fallthru, or we've lost track of what's what.  */
if|if
condition|(
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|after
operator|=
name|bb
operator|->
name|end
expr_stmt|;
block|}
block|}
comment|/* Otherwise we must split the edge.  */
else|else
block|{
name|bb
operator|=
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|after
operator|=
name|bb
operator|->
name|end
expr_stmt|;
block|}
comment|/* Now that we've found the spot, do the insertion.  */
name|tmp
operator|=
name|e
operator|->
name|insns
expr_stmt|;
name|e
operator|->
name|insns
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|before
condition|)
block|{
name|emit_insns_before
argument_list|(
name|tmp
argument_list|,
name|before
argument_list|)
expr_stmt|;
if|if
condition|(
name|before
operator|==
name|bb
operator|->
name|head
condition|)
name|bb
operator|->
name|head
operator|=
name|before
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|emit_insns_after
argument_list|(
name|tmp
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
operator|==
name|bb
operator|->
name|end
condition|)
name|bb
operator|->
name|end
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Update the CFG for all queued instructions.  */
end_comment

begin_function
name|void
name|commit_edge_insertions
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
name|bb
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|edge
name|e
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|insns
condition|)
name|commit_one_edge_insertion
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|>=
name|n_basic_blocks
condition|)
break|break;
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete all unreachable basic blocks.   */
end_comment

begin_function
specifier|static
name|void
name|delete_unreachable_blocks
parameter_list|()
block|{
name|basic_block
modifier|*
name|worklist
decl_stmt|,
modifier|*
name|tos
decl_stmt|;
name|int
name|deleted_handler
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|n_basic_blocks
expr_stmt|;
name|tos
operator|=
name|worklist
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
comment|/* Use basic_block->aux as a marker.  Clear them all.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
comment|/* Add our starting points to the worklist.  Almost always there will      be only one.  It isn't inconcievable that we might one day directly      support Fortran alternate entry points.  */
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
block|{
operator|*
name|tos
operator|++
operator|=
name|e
operator|->
name|dest
expr_stmt|;
comment|/* Mark the block with a handy non-null value.  */
name|e
operator|->
name|dest
operator|->
name|aux
operator|=
name|e
expr_stmt|;
block|}
comment|/* Iterate: find everything reachable from what we've already seen.  */
while|while
condition|(
name|tos
operator|!=
name|worklist
condition|)
block|{
name|basic_block
name|b
init|=
operator|*
operator|--
name|tos
decl_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
if|if
condition|(
operator|!
name|e
operator|->
name|dest
operator|->
name|aux
condition|)
block|{
operator|*
name|tos
operator|++
operator|=
name|e
operator|->
name|dest
expr_stmt|;
name|e
operator|->
name|dest
operator|->
name|aux
operator|=
name|e
expr_stmt|;
block|}
block|}
comment|/* Delete all unreachable basic blocks.  Count down so that we don't      interfere with the block renumbering that happens in delete_block.  */
name|deleted_handler
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|aux
operator|!=
name|NULL
condition|)
comment|/* This block was found.  Tidy up the mark.  */
name|b
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
else|else
name|deleted_handler
operator||=
name|delete_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|/* Fix up edges that now fall through, or rather should now fall through      but previously required a jump around now deleted blocks.  Simplify      the search by only examining blocks numerically adjacent, since this      is how find_basic_blocks created them.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
block|{
name|basic_block
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
name|basic_block
name|c
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|s
decl_stmt|;
comment|/* We care about simple conditional or unconditional jumps with 	 a single successor.  	 If we had a conditional branch to the next instruction when 	 find_basic_blocks was called, then there will only be one 	 out edge for the block which ended with the conditional 	 branch (since we do not create duplicate edges).  	 Furthermore, the edge will be marked as a fallthru because we 	 merge the flags for the duplicate edges.  So we do not want to 	 check that the edge is not a FALLTHRU edge.  */
if|if
condition|(
operator|(
name|s
operator|=
name|b
operator|->
name|succ
operator|)
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
name|s
operator|->
name|dest
operator|==
name|c
comment|/* If the last insn is not a normal conditional jump 	     (or an unconditional jump), then we can not tidy the 	     fallthru edge because we can not delete the jump.  */
operator|&&
name|GET_CODE
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|condjump_p
argument_list|(
name|b
operator|->
name|end
argument_list|)
condition|)
name|tidy_fallthru_edge
argument_list|(
name|s
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Attempt to merge blocks as made possible by edge removal.  If a block      has only one successor, and the successor has only one predecessor,       they may be combined.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
control|)
block|{
name|basic_block
name|c
decl_stmt|,
name|b
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|edge
name|s
decl_stmt|;
comment|/* A loop because chains of blocks might be combineable.  */
while|while
condition|(
operator|(
name|s
operator|=
name|b
operator|->
name|succ
operator|)
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|succ_next
operator|==
name|NULL
operator|&&
operator|(
name|s
operator|->
name|flags
operator|&
name|EDGE_EH
operator|)
operator|==
literal|0
operator|&&
operator|(
name|c
operator|=
name|s
operator|->
name|dest
operator|)
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|c
operator|->
name|pred
operator|->
name|pred_next
operator|==
name|NULL
comment|/* If the last insn is not a normal conditional jump 		(or an unconditional jump), then we can not merge 		the blocks because we can not delete the jump.  */
operator|&&
name|GET_CODE
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|condjump_p
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|&&
name|merge_blocks
argument_list|(
name|s
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
condition|)
continue|continue;
comment|/* Don't get confused by the index shift caused by deleting blocks.  */
name|i
operator|=
name|b
operator|->
name|index
operator|+
literal|1
expr_stmt|;
block|}
comment|/* If we deleted an exception handler, we may have EH region begin/end      blocks to remove as well. */
if|if
condition|(
name|deleted_handler
condition|)
name|delete_eh_regions
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find EH regions for which there is no longer a handler, and delete them.  */
end_comment

begin_function
specifier|static
name|void
name|delete_eh_regions
parameter_list|()
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|)
operator|||
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
operator|)
condition|)
block|{
name|int
name|num
init|=
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* A NULL handler indicates a region is no longer needed */
if|if
condition|(
name|get_first_handler
argument_list|(
name|num
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return true if NOTE is not one of the ones that must be kept paired,    so that we may simply delete them.  */
end_comment

begin_function
specifier|static
name|int
name|can_delete_note_p
parameter_list|(
name|note
parameter_list|)
name|rtx
name|note
decl_stmt|;
block|{
return|return
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_DELETED
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|note
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Unlink a chain of insns between START and FINISH, leaving notes    that must be paired.  */
end_comment

begin_function
specifier|static
name|void
name|delete_insn_chain
parameter_list|(
name|start
parameter_list|,
name|finish
parameter_list|)
name|rtx
name|start
decl_stmt|,
name|finish
decl_stmt|;
block|{
comment|/* Unchain the insns one by one.  It would be quicker to delete all      of these with a single unchaining, rather than one at a time, but      we need to keep the NOTE's.  */
name|rtx
name|next
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|next
operator|=
name|NEXT_INSN
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|start
argument_list|)
operator|==
name|NOTE
operator|&&
operator|!
name|can_delete_note_p
argument_list|(
name|start
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|start
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|!
name|can_delete_label_p
argument_list|(
name|start
argument_list|)
condition|)
empty_stmt|;
else|else
name|next
operator|=
name|flow_delete_insn
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|finish
condition|)
break|break;
name|start
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete the insns in a (non-live) block.  We physically delete every    non-deleted-note insn, and update the flow graph appropriately.     Return nonzero if we deleted an exception handler.  */
end_comment

begin_comment
comment|/* ??? Preserving all such notes strikes me as wrong.  It would be nice    to post-process the stream to remove empty blocks, loops, ranges, etc.  */
end_comment

begin_function
specifier|static
name|int
name|delete_block
parameter_list|(
name|b
parameter_list|)
name|basic_block
name|b
decl_stmt|;
block|{
name|int
name|deleted_handler
init|=
literal|0
decl_stmt|;
name|rtx
name|insn
decl_stmt|,
name|end
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* If the head of this block is a CODE_LABEL, then it might be the      label for an exception handler which can't be reached.       We need to remove the label from the exception_handler_label list      and remove the associated NOTE_EH_REGION_BEG and NOTE_EH_REGION_END      notes.  */
name|insn
operator|=
name|b
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|rtx
name|x
decl_stmt|,
modifier|*
name|prev
init|=
operator|&
name|exception_handler_labels
decl_stmt|;
for|for
control|(
name|x
operator|=
name|exception_handler_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
condition|)
block|{
comment|/* Found a match, splice this label out of the EH label list.  */
operator|*
name|prev
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Remove the handler from all regions */
name|remove_handler
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|deleted_handler
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|prev
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* This label may be referenced by code solely for its value, or 	 referenced by static data, or something.  We have determined 	 that it is not reachable, but cannot delete the label itself. 	 Save code space and continue to delete the balance of the block, 	 along with properly updating the cfg.  */
if|if
condition|(
operator|!
name|can_delete_label_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
comment|/* If we've only got one of these, skip the whole deleting 	     insns thing.  */
if|if
condition|(
name|insn
operator|==
name|b
operator|->
name|end
condition|)
goto|goto
name|no_delete_insns
goto|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Include any jump table following the basic block.  */
name|end
operator|=
name|b
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|end
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|tmp
operator|=
name|JUMP_LABEL
argument_list|(
name|end
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
operator|(
name|tmp
operator|=
name|NEXT_INSN
argument_list|(
name|tmp
argument_list|)
operator|)
operator|!=
name|NULL_RTX
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
name|end
operator|=
name|tmp
expr_stmt|;
comment|/* Include any barrier that may follow the basic block.  */
name|tmp
operator|=
name|next_nonnote_insn
argument_list|(
name|b
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|BARRIER
condition|)
name|end
operator|=
name|tmp
expr_stmt|;
name|delete_insn_chain
argument_list|(
name|insn
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|no_delete_insns
label|:
comment|/* Remove the edges into and out of this block.  Note that there may       indeed be edges in, if we are removing an unreachable loop.  */
block|{
name|edge
name|e
decl_stmt|,
name|next
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|e
operator|=
name|b
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
for|for
control|(
name|q
operator|=
operator|&
name|e
operator|->
name|src
operator|->
name|succ
init|;
operator|*
name|q
operator|!=
name|e
condition|;
name|q
operator|=
operator|&
operator|(
operator|*
name|q
operator|)
operator|->
name|succ_next
control|)
continue|continue;
operator|*
name|q
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
name|next
operator|=
name|e
operator|->
name|pred_next
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|next
control|)
block|{
for|for
control|(
name|q
operator|=
operator|&
name|e
operator|->
name|dest
operator|->
name|pred
init|;
operator|*
name|q
operator|!=
name|e
condition|;
name|q
operator|=
operator|&
operator|(
operator|*
name|q
operator|)
operator|->
name|pred_next
control|)
continue|continue;
operator|*
name|q
operator|=
name|e
operator|->
name|pred_next
expr_stmt|;
name|next
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
name|b
operator|->
name|pred
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|succ
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Remove the basic block from the array, and compact behind it.  */
name|expunge_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
name|deleted_handler
return|;
block|}
end_function

begin_comment
comment|/* Remove block B from the basic block array and compact behind it.  */
end_comment

begin_function
specifier|static
name|void
name|expunge_block
parameter_list|(
name|b
parameter_list|)
name|basic_block
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
name|n_basic_blocks
decl_stmt|;
for|for
control|(
name|i
operator|=
name|b
operator|->
name|index
init|;
name|i
operator|+
literal|1
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|basic_block
name|x
init|=
name|BASIC_BLOCK
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|index
operator|=
name|i
expr_stmt|;
block|}
name|basic_block_info
operator|->
name|num_elements
operator|--
expr_stmt|;
name|n_basic_blocks
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete INSN by patching it out.  Return the next insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|flow_delete_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|prev
init|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|next
init|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|NEXT_INSN
argument_list|(
name|prev
argument_list|)
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|PREV_INSN
argument_list|(
name|next
argument_list|)
operator|=
name|prev
expr_stmt|;
else|else
name|set_last_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
name|remove_node_from_expr_list
argument_list|(
name|insn
argument_list|,
operator|&
name|nonlocal_goto_handler_labels
argument_list|)
expr_stmt|;
comment|/* If deleting a jump, decrement the use count of the label.  Deleting      the label itself should happen in the normal course of block merging.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
condition|)
name|LABEL_NUSES
argument_list|(
name|JUMP_LABEL
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|--
expr_stmt|;
comment|/* Also if deleting an insn that references a label.  */
elseif|else
if|if
condition|(
operator|(
name|note
operator|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LABEL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
operator|!=
name|NULL_RTX
condition|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|--
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_comment
comment|/* True if a given label can be deleted.  */
end_comment

begin_function
specifier|static
name|int
name|can_delete_label_p
parameter_list|(
name|label
parameter_list|)
name|rtx
name|label
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|LABEL_PRESERVE_P
argument_list|(
name|label
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|label
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|x
operator|=
name|label_value_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|label
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|x
operator|=
name|exception_handler_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|label
operator|==
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* User declared labels must be preserved.  */
if|if
condition|(
name|LABEL_NAME
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Blocks A and B are to be merged into a single block.  The insns    are already contiguous, hence `nomove'.  */
end_comment

begin_function
specifier|static
name|void
name|merge_blocks_nomove
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|basic_block
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|edge
name|e
decl_stmt|;
name|rtx
name|b_head
decl_stmt|,
name|b_end
decl_stmt|,
name|a_end
decl_stmt|;
name|int
name|b_empty
init|=
literal|0
decl_stmt|;
comment|/* If there was a CODE_LABEL beginning B, delete it.  */
name|b_head
operator|=
name|b
operator|->
name|head
expr_stmt|;
name|b_end
operator|=
name|b
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|b_head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
comment|/* Detect basic blocks with nothing but a label.  This can happen 	 in particular at the end of a function.  */
if|if
condition|(
name|b_head
operator|==
name|b_end
condition|)
name|b_empty
operator|=
literal|1
expr_stmt|;
name|b_head
operator|=
name|flow_delete_insn
argument_list|(
name|b_head
argument_list|)
expr_stmt|;
block|}
comment|/* Delete the basic block note.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|b_head
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|b_head
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
if|if
condition|(
name|b_head
operator|==
name|b_end
condition|)
name|b_empty
operator|=
literal|1
expr_stmt|;
name|b_head
operator|=
name|flow_delete_insn
argument_list|(
name|b_head
argument_list|)
expr_stmt|;
block|}
comment|/* If there was a jump out of A, delete it.  */
name|a_end
operator|=
name|a
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|a_end
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
name|rtx
name|prev
decl_stmt|;
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|a_end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
name|prev
operator|=
name|a
operator|->
name|head
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this was a conditional jump, we need to also delete 	 the insn that set cc0.  */
if|if
condition|(
name|prev
operator|&&
name|sets_cc0_p
argument_list|(
name|prev
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|prev
decl_stmt|;
name|prev
operator|=
name|prev_nonnote_insn
argument_list|(
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev
condition|)
name|prev
operator|=
name|a
operator|->
name|head
expr_stmt|;
name|flow_delete_insn
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Note that a->head != a->end, since we should have at least a 	 bb note plus the jump, so prev != insn.  */
name|flow_delete_insn
argument_list|(
name|a_end
argument_list|)
expr_stmt|;
name|a_end
operator|=
name|prev
expr_stmt|;
block|}
comment|/* By definition, there should only be one successor of A, and that is      B.  Free that edge struct.  */
name|free
argument_list|(
name|a
operator|->
name|succ
argument_list|)
expr_stmt|;
comment|/* Adjust the edges out of B for the new owner.  */
for|for
control|(
name|e
operator|=
name|b
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|e
operator|->
name|src
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|succ
operator|=
name|b
operator|->
name|succ
expr_stmt|;
comment|/* Reassociate the insns of B with A.  */
if|if
condition|(
operator|!
name|b_empty
condition|)
block|{
name|BLOCK_FOR_INSN
argument_list|(
name|b_head
argument_list|)
operator|=
name|a
expr_stmt|;
while|while
condition|(
name|b_head
operator|!=
name|b_end
condition|)
block|{
name|b_head
operator|=
name|NEXT_INSN
argument_list|(
name|b_head
argument_list|)
expr_stmt|;
name|BLOCK_FOR_INSN
argument_list|(
name|b_head
argument_list|)
operator|=
name|a
expr_stmt|;
block|}
name|a_end
operator|=
name|b_head
expr_stmt|;
block|}
name|a
operator|->
name|end
operator|=
name|a_end
expr_stmt|;
comment|/* Compact the basic block array.  */
name|expunge_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attempt to merge basic blocks that are potentially non-adjacent.      Return true iff the attempt succeeded.  */
end_comment

begin_function
specifier|static
name|int
name|merge_blocks
parameter_list|(
name|e
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|b
decl_stmt|,
name|c
decl_stmt|;
block|{
comment|/* If B has a fallthru edge to C, no need to move anything.  */
if|if
condition|(
operator|!
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
block|{
comment|/* ??? From here on out we must make sure to not munge nesting 	 of exception regions and lexical blocks.  Need to think about 	 these cases before this gets implemented.  */
return|return
literal|0
return|;
comment|/* If C has an outgoing fallthru, and B does not have an incoming 	 fallthru, move B before C.  The later clause is somewhat arbitrary, 	 but avoids modifying blocks other than the two we've been given.  */
comment|/* Otherwise, move C after B.  If C had a fallthru, which doesn't 	 happen to be the physical successor to B, insert an unconditional 	 branch.  If C already ended with a conditional branch, the new 	 jump must go in a new basic block D.  */
block|}
comment|/* If a label still appears somewhere and we cannot delete the label,      then we cannot merge the blocks.  The edge was tidied already.  */
block|{
name|rtx
name|insn
decl_stmt|,
name|stop
init|=
name|NEXT_INSN
argument_list|(
name|c
operator|->
name|head
argument_list|)
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|b
operator|->
name|end
argument_list|)
init|;
name|insn
operator|!=
name|stop
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
operator|!
name|can_delete_label_p
argument_list|(
name|insn
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|merge_blocks_nomove
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The given edge should potentially a fallthru edge.  If that is in    fact true, delete the unconditional jump and barriers that are in    the way.  */
end_comment

begin_function
specifier|static
name|void
name|tidy_fallthru_edge
parameter_list|(
name|e
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|edge
name|e
decl_stmt|;
name|basic_block
name|b
decl_stmt|,
name|c
decl_stmt|;
block|{
name|rtx
name|q
decl_stmt|;
comment|/* ??? In a late-running flow pass, other folks may have deleted basic      blocks by nopping out blocks, leaving multiple BARRIERs between here      and the target label. They ought to be chastized and fixed.       We can also wind up with a sequence of undeletable labels between      one block and the next.       So search through a sequence of barriers, labels, and notes for      the head of block C and assert that we really do fall through.  */
if|if
condition|(
name|next_real_insn
argument_list|(
name|b
operator|->
name|end
argument_list|)
operator|!=
name|next_real_insn
argument_list|(
name|PREV_INSN
argument_list|(
name|c
operator|->
name|head
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Remove what will soon cease being the jump insn from the source block.      If block B consisted only of this single jump, turn it into a deleted      note.  */
name|q
operator|=
name|b
operator|->
name|end
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|JUMP_INSN
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_cc0
comment|/* If this was a conditional jump, we need to also delete 	 the insn that set cc0.  */
if|if
condition|(
operator|!
name|simplejump_p
argument_list|(
name|q
argument_list|)
operator|&&
name|condjump_p
argument_list|(
name|q
argument_list|)
condition|)
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|b
operator|->
name|head
operator|==
name|q
condition|)
block|{
name|PUT_CODE
argument_list|(
name|q
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|q
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|q
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|b
operator|->
name|end
operator|=
name|q
operator|=
name|PREV_INSN
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* Selectively unlink the sequence.  */
if|if
condition|(
name|q
operator|!=
name|PREV_INSN
argument_list|(
name|c
operator|->
name|head
argument_list|)
condition|)
name|delete_insn_chain
argument_list|(
name|NEXT_INSN
argument_list|(
name|q
argument_list|)
argument_list|,
name|PREV_INSN
argument_list|(
name|c
operator|->
name|head
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|flags
operator||=
name|EDGE_FALLTHRU
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discover and record the loop depth at the head of each basic block.  */
end_comment

begin_function
specifier|static
name|void
name|calculate_loop_depth
parameter_list|(
name|insns
parameter_list|)
name|rtx
name|insns
decl_stmt|;
block|{
name|basic_block
name|bb
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|depth
init|=
literal|1
decl_stmt|;
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|insns
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|insn
operator|==
name|bb
operator|->
name|head
condition|)
block|{
name|bb
operator|->
name|loop_depth
operator|=
name|depth
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
name|n_basic_blocks
condition|)
break|break;
name|bb
operator|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|depth
operator|--
expr_stmt|;
comment|/* If we have LOOP_DEPTH == 0, there has been a bookkeeping error. */
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform data flow analysis.    F is the first insn of the function and NREGS the number of register numbers    in use.  */
end_comment

begin_function
name|void
name|life_analysis
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|file
parameter_list|,
name|remove_dead_code
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|remove_dead_code
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|register
name|size_t
name|i
decl_stmt|;
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
endif|#
directive|endif
comment|/* Record which registers will be eliminated.  We use this in      mark_used_regs.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|elim_reg_set
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|eliminables
operator|/
sizeof|sizeof
name|eliminables
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate a bitmap to be filled in by record_volatile_insns.  */
name|uid_volatile
operator|=
name|BITMAP_ALLOCA
argument_list|()
expr_stmt|;
comment|/* We want alias analysis information for local dead store elimination.  */
name|init_alias_analysis
argument_list|()
expr_stmt|;
name|life_analysis_1
argument_list|(
name|f
argument_list|,
name|nregs
argument_list|,
name|remove_dead_code
argument_list|)
expr_stmt|;
name|end_alias_analysis
argument_list|()
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_flow_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|uid_volatile
argument_list|)
expr_stmt|;
name|free_basic_block_vars
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the variables allocated by find_basic_blocks.     KEEP_HEAD_END_P is non-zero if basic_block_info is not to be freed.  */
end_comment

begin_function
name|void
name|free_basic_block_vars
parameter_list|(
name|keep_head_end_p
parameter_list|)
name|int
name|keep_head_end_p
decl_stmt|;
block|{
if|if
condition|(
name|basic_block_for_insn
condition|)
block|{
name|VARRAY_FREE
argument_list|(
name|basic_block_for_insn
argument_list|)
expr_stmt|;
name|basic_block_for_insn
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|keep_head_end_p
condition|)
block|{
name|clear_edges
argument_list|()
expr_stmt|;
name|VARRAY_FREE
argument_list|(
name|basic_block_info
argument_list|)
expr_stmt|;
name|n_basic_blocks
operator|=
literal|0
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|global_live_at_end
operator|=
name|NULL
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|global_live_at_start
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if the destination of SET equals the source.  */
end_comment

begin_function
specifier|static
name|int
name|set_noop_p
parameter_list|(
name|set
parameter_list|)
name|rtx
name|set
decl_stmt|;
block|{
name|rtx
name|src
init|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|rtx
name|dst
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dst
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|!=
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|!=
name|SUBREG
operator|||
name|SUBREG_WORD
argument_list|(
name|src
argument_list|)
operator|!=
name|SUBREG_WORD
argument_list|(
name|dst
argument_list|)
condition|)
return|return
literal|0
return|;
name|src
operator|=
name|SUBREG_REG
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dst
operator|=
name|SUBREG_REG
argument_list|(
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|src
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|dst
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|src
argument_list|)
operator|==
name|REGNO
argument_list|(
name|dst
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if an insn consists only of SETs, each of which only sets a    value to itself.  */
end_comment

begin_function
specifier|static
name|int
name|noop_move_p
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Insns carrying these notes are useful later on.  */
if|if
condition|(
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|SET
operator|&&
name|set_noop_p
argument_list|(
name|pat
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* If nothing but SETs of registers to themselves, 	 this insn can also be deleted.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|XVECEXP
argument_list|(
name|pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|SET
operator|||
operator|!
name|set_noop_p
argument_list|(
name|tem
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|notice_stack_pointer_modification
parameter_list|(
name|x
parameter_list|,
name|pat
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|rtx
name|pat
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|==
name|stack_pointer_rtx
comment|/* The stack pointer is only modified indirectly as the result 	 of a push until later in flow.  See the comments in rtl.texi 	 regarding Embedded Side-Effects on Addresses.  */
operator|||
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PRE_INC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_DEC
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|POST_INC
operator|)
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|)
condition|)
name|current_function_sp_is_unchanging
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record which insns refer to any volatile memory    or for any reason can't be deleted just because they are dead stores.    Also, delete any insns that copy a register to itself.    And see if the stack pointer is modified.  */
end_comment

begin_function
specifier|static
name|void
name|record_volatile_insns
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|CALL_INSN
condition|)
name|SET_INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|INSN
operator|||
name|code1
operator|==
name|JUMP_INSN
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
condition|)
name|SET_INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* A SET that makes space on the stack cannot be dead. 	     (Such SETs occur only for allocating variable-size data, 	     so they will always have a PLUS or MINUS according to the 	     direction of stack growth.) 	     Even if this function never uses this stack pointer value, 	     signal handlers do!  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MINUS
else|#
directive|else
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
endif|#
directive|endif
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
name|SET_INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
comment|/* Delete (in effect) any obvious no-op moves.  */
elseif|else
if|if
condition|(
name|noop_move_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Check if insn modifies the stack pointer.  */
if|if
condition|(
name|current_function_sp_is_unchanging
operator|&&
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
name|note_stores
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|notice_stack_pointer_modification
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Mark those regs which are needed at the end of the function as live    at the end of the last basic block.  */
end_comment

begin_function
specifier|static
name|void
name|mark_regs_live_at_end
parameter_list|(
name|set
parameter_list|)
name|regset
name|set
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* If exiting needs the right stack value, consider the stack pointer      live at the end of the function.  */
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
operator|||
operator|(
operator|!
name|FRAME_POINTER_REQUIRED
operator|&&
operator|!
name|current_function_calls_alloca
operator|&&
name|flag_omit_frame_pointer
operator|)
operator|||
name|current_function_sp_is_unchanging
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the frame pointer if needed at the end of the function.  If      we end up eliminating it, it will be removed from the live list      of each basic block by reload.  */
if|if
condition|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
comment|/* If they are different, also mark the hard frame pointer as live */
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Mark all global registers, and all registers used by the epilogue      as being live at the end of the function since they may be      referenced by our caller.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
ifdef|#
directive|ifdef
name|EPILOGUE_USES
operator|||
name|EPILOGUE_USES
argument_list|(
name|i
argument_list|)
endif|#
directive|endif
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|set
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* ??? Mark function return value here rather than as uses.  */
block|}
end_function

begin_comment
comment|/* Determine which registers are live at the start of each    basic block of the function whose first insn is F.    NREGS is the number of registers used in F.    We allocate the vector basic_block_live_at_start    and the regsets that it points to, and fill them with the data.    regset_size and regset_bytes are also set here.  */
end_comment

begin_function
specifier|static
name|void
name|life_analysis_1
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|remove_dead_code
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|int
name|remove_dead_code
decl_stmt|;
block|{
name|int
name|first_pass
decl_stmt|;
name|int
name|changed
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|save_regs_ever_live
index|[
name|FIRST_PSEUDO_REGISTER
index|]
decl_stmt|;
name|regset
modifier|*
name|new_live_at_end
decl_stmt|;
name|struct
name|obstack
name|flow_obstack
decl_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|max_regno
operator|=
name|nregs
expr_stmt|;
comment|/* Allocate and zero out many data structures      that will record the data from lifetime analysis.  */
name|allocate_reg_life_data
argument_list|()
expr_stmt|;
name|allocate_bb_life_data
argument_list|()
expr_stmt|;
name|reg_next_use
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|reg_next_use
argument_list|,
literal|0
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up regset-vectors used internally within this function.      Their meanings are documented above, with their declarations.  */
name|new_live_at_end
operator|=
operator|(
name|regset
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|n_basic_blocks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|new_live_at_end
argument_list|,
name|n_basic_blocks
operator|+
literal|1
argument_list|,
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
comment|/* Stick these vectors into the AUX field of the basic block, so that      we don't have to keep going through the index.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|aux
operator|=
name|new_live_at_end
index|[
name|i
index|]
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|aux
operator|=
name|new_live_at_end
index|[
name|i
index|]
expr_stmt|;
comment|/* Assume that the stack pointer is unchanging if alloca hasn't been used.      This will be cleared by record_volatile_insns if it encounters an insn      which modifies the stack pointer.  */
name|current_function_sp_is_unchanging
operator|=
operator|!
name|current_function_calls_alloca
expr_stmt|;
name|record_volatile_insns
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
block|{
name|regset
name|theend
decl_stmt|;
specifier|register
name|edge
name|e
decl_stmt|;
name|theend
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|global_live_at_start
expr_stmt|;
name|mark_regs_live_at_end
argument_list|(
name|theend
argument_list|)
expr_stmt|;
comment|/* Propogate this exit data to each of EXIT's predecessors.  */
for|for
control|(
name|e
operator|=
name|EXIT_BLOCK_PTR
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
block|{
name|COPY_REG_SET
argument_list|(
name|e
operator|->
name|src
operator|->
name|global_live_at_end
argument_list|,
name|theend
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
operator|(
name|regset
operator|)
name|e
operator|->
name|src
operator|->
name|aux
argument_list|,
name|theend
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The post-reload life analysis have (on a global basis) the same registers      live as was computed by reload itself.       Otherwise elimination offsets and such may be incorrect.       Reload will make some registers as live even though they do not appear      in the rtl.  */
if|if
condition|(
name|reload_completed
condition|)
name|memcpy
argument_list|(
name|save_regs_ever_live
argument_list|,
name|regs_ever_live
argument_list|,
sizeof|sizeof
argument_list|(
name|regs_ever_live
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|regs_ever_live
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|regs_ever_live
argument_list|)
expr_stmt|;
comment|/* Propagate life info through the basic blocks      around the graph of basic blocks.       This is a relaxation process: each time a new register      is live at the end of the basic block, we must scan the block      to determine which registers are, as a consequence, live at the beginning      of that block.  These registers must then be marked live at the ends      of all the blocks that can transfer control to that block.      The process continues until it reaches a fixed point.  */
name|first_pass
operator|=
literal|1
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|consider
init|=
name|first_pass
decl_stmt|;
name|int
name|must_rescan
init|=
name|first_pass
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|first_pass
condition|)
block|{
comment|/* Set CONSIDER if this block needs thinking about at all 		 (that is, if the regs live now at the end of it 		 are not the same as were live at the end of it when 		 we last thought about it). 		 Set must_rescan if it needs to be thought about 		 instruction by instruction (that is, if any additional 		 reg that is live at the end now but was not live there before 		 is one of the significant regs of this basic block).  */
name|EXECUTE_IF_AND_COMPL_IN_REG_SET
argument_list|(
argument|(regset) bb->aux
argument_list|,
argument|bb->global_live_at_end
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 		   consider =
literal|1
argument|; 		   if (REGNO_REG_SET_P (bb->local_set, j)) 		     { 		       must_rescan =
literal|1
argument|; 		       goto done; 		     } 		 }
argument_list|)
empty_stmt|;
name|done
label|:
if|if
condition|(
operator|!
name|consider
condition|)
continue|continue;
block|}
comment|/* The live_at_start of this block may be changing, 	     so another pass will be required after this one.  */
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|must_rescan
condition|)
block|{
comment|/* No complete rescan needed; 		 just record those variables newly known live at end 		 as live at start as well.  */
name|IOR_AND_COMPL_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
operator|(
name|regset
operator|)
name|bb
operator|->
name|aux
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|IOR_AND_COMPL_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
operator|(
name|regset
operator|)
name|bb
operator|->
name|aux
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update the basic_block_live_at_start 		 by propagation backwards through the block.  */
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
operator|(
name|regset
operator|)
name|bb
operator|->
name|aux
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|bb
operator|->
name|global_live_at_end
argument_list|)
expr_stmt|;
name|propagate_block
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|bb
operator|->
name|head
argument_list|,
name|bb
operator|->
name|end
argument_list|,
literal|0
argument_list|,
name|first_pass
condition|?
name|bb
operator|->
name|local_set
else|:
operator|(
name|regset
operator|)
literal|0
argument_list|,
name|i
argument_list|,
name|remove_dead_code
argument_list|)
expr_stmt|;
block|}
comment|/* Update the new_live_at_end's of the block's predecessors.  */
block|{
specifier|register
name|edge
name|e
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|IOR_REG_SET
argument_list|(
operator|(
name|regset
operator|)
name|e
operator|->
name|src
operator|->
name|aux
argument_list|,
name|bb
operator|->
name|global_live_at_start
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|first_pass
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The only pseudos that are live at the beginning of the function are      those that were not set anywhere in the function.  local-alloc doesn't      know how to handle these correctly, so mark them as not local to any      one basic block.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|BASIC_BLOCK (
literal|0
argument|)->global_live_at_start
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 				 REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; 			       }
argument_list|)
empty_stmt|;
comment|/* Now the life information is accurate.  Make one more pass over each      basic block to delete dead stores, create autoincrement addressing      and record how many times each register is used, is set, or dies.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* We start with global_live_at_end to determine which stores are 	 dead.  This process is destructive, and we wish to preserve the 	 contents of global_live_at_end for posterity.  Fortunately, 	 new_live_at_end, due to the way we converged on a solution, 	 contains a duplicate of global_live_at_end that we can kill.  */
name|propagate_block
argument_list|(
operator|(
name|regset
operator|)
name|bb
operator|->
name|aux
argument_list|,
name|bb
operator|->
name|head
argument_list|,
name|bb
operator|->
name|end
argument_list|,
literal|1
argument_list|,
operator|(
name|regset
operator|)
literal|0
argument_list|,
name|i
argument_list|,
name|remove_dead_code
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* We have a problem with any pseudoreg that lives across the setjmp.       ANSI says that if a user variable does not change in value between      the setjmp and the longjmp, then the longjmp preserves it.  This      includes longjmp from a place where the pseudo appears dead.      (In principle, the value still exists if it is in scope.)      If the pseudo goes in a hard reg, some other value may occupy      that hard reg where this pseudo is dead, thus clobbering the pseudo.      Conclusion: such a pseudo must not go in a hard reg.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|regs_live_at_setjmp
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 			       if (regno_reg_rtx[i] !=
literal|0
argument|) 				 { 				   REG_LIVE_LENGTH (i) = -
literal|1
argument|; 				   REG_BASIC_BLOCK (i) = -
literal|1
argument|; 				 } 			     }
argument_list|)
empty_stmt|;
comment|/* Restore regs_ever_live that was provided by reload.  */
if|if
condition|(
name|reload_completed
condition|)
name|memcpy
argument_list|(
name|regs_ever_live
argument_list|,
name|save_regs_ever_live
argument_list|,
sizeof|sizeof
argument_list|(
name|regs_ever_live
argument_list|)
argument_list|)
expr_stmt|;
name|free_regset_vector
argument_list|(
name|new_live_at_end
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|flow_obstack
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
operator|++
name|i
control|)
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
name|ENTRY_BLOCK_PTR
operator|->
name|aux
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of life analysis.  */
end_comment

begin_comment
comment|/* Allocate the permanent data structures that represent the results    of life analysis.  Not static since used also for stupid life analysis.  */
end_comment

begin_function
name|void
name|allocate_bb_life_data
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|bb
operator|->
name|local_set
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
name|bb
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
name|bb
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
block|}
name|ENTRY_BLOCK_PTR
operator|->
name|global_live_at_end
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
name|EXIT_BLOCK_PTR
operator|->
name|global_live_at_start
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
name|regs_live_at_setjmp
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|allocate_reg_life_data
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Recalculate the register space, in case it has grown.  Old style      vector oriented regsets would set regset_{size,bytes} here also.  */
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Because both reg_scan and flow_analysis want to set up the REG_N_SETS      information, explicitly reset it here.  The allocation should have      already happened on the previous reg_scan pass.  Make sure in case      some more registers were allocated.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make each element of VECTOR point at a regset.  The vector has    NELTS elements, and space is allocated from the ALLOC_OBSTACK    obstack.  */
end_comment

begin_function
specifier|static
name|void
name|init_regset_vector
parameter_list|(
name|vector
parameter_list|,
name|nelts
parameter_list|,
name|alloc_obstack
parameter_list|)
name|regset
modifier|*
name|vector
decl_stmt|;
name|int
name|nelts
decl_stmt|;
name|struct
name|obstack
modifier|*
name|alloc_obstack
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|alloc_obstack
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|vector
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Release any additional space allocated for each element of VECTOR point    other than the regset header itself.  The vector has NELTS elements.  */
end_comment

begin_function
name|void
name|free_regset_vector
parameter_list|(
name|vector
parameter_list|,
name|nelts
parameter_list|)
name|regset
modifier|*
name|vector
decl_stmt|;
name|int
name|nelts
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
name|FREE_REG_SET
argument_list|(
name|vector
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the registers live at the beginning of a basic block    from those live at the end.     When called, OLD contains those live at the end.    On return, it contains those live at the beginning.    FIRST and LAST are the first and last insns of the basic block.     FINAL is nonzero if we are doing the final pass which is not    for computing the life info (since that has already been done)    but for acting on it.  On this pass, we delete dead stores,    set up the logical links and dead-variables lists of instructions,    and merge instructions for autoincrement and autodecrement addresses.     SIGNIFICANT is nonzero only the first time for each basic block.    If it is nonzero, it points to a regset in which we store    a 1 for each register that is set within the block.     BNUM is the number of the basic block.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_block
parameter_list|(
name|old
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|,
name|final
parameter_list|,
name|significant
parameter_list|,
name|bnum
parameter_list|,
name|remove_dead_code
parameter_list|)
specifier|register
name|regset
name|old
decl_stmt|;
name|rtx
name|first
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|int
name|final
decl_stmt|;
name|regset
name|significant
decl_stmt|;
name|int
name|bnum
decl_stmt|;
name|int
name|remove_dead_code
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|regset
name|live
decl_stmt|;
name|regset
name|dead
decl_stmt|;
comment|/* Find the loop depth for this block.  Ignore loop level changes in the      middle of the basic block -- for register allocation purposes, the       important uses will be in the blocks wholely contained within the loop      not in the loop pre-header or post-trailer.  */
name|loop_depth
operator|=
name|BASIC_BLOCK
argument_list|(
name|bnum
argument_list|)
operator|->
name|loop_depth
expr_stmt|;
name|dead
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|live
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|cc0_live
operator|=
literal|0
expr_stmt|;
name|mem_set_list
operator|=
name|NULL_RTX
expr_stmt|;
if|if
condition|(
name|final
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Process the regs live at the end of the block. 	 Mark them as not local to any one basic block. */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|old
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 				   REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; 				 }
argument_list|)
empty_stmt|;
block|}
comment|/* Scan the block an insn at a time from end to beginning.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* If this is a call to `setjmp' et al, 	     warn if any non-volatile datum is live.  */
if|if
condition|(
name|final
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
name|IOR_REG_SET
argument_list|(
name|regs_live_at_setjmp
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
comment|/* Update the life-status of regs for this insn. 	 First DEAD gets which regs are set in this insn 	 then LIVE gets which regs are used in this insn. 	 Then the regs live before the insn 	 are those live after, with DEAD regs turned off, 	 and then LIVE regs turned on.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|int
name|insn_is_dead
init|=
literal|0
decl_stmt|;
name|int
name|libcall_is_dead
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|remove_dead_code
condition|)
block|{
name|insn_is_dead
operator|=
operator|(
name|insn_dead_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|,
literal|0
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
comment|/* Don't delete something that refers to volatile storage!  */
operator|&&
operator|!
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|)
expr_stmt|;
name|libcall_is_dead
operator|=
operator|(
name|insn_is_dead
operator|&&
name|note
operator|!=
literal|0
operator|&&
name|libcall_dead_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|,
name|note
argument_list|,
name|insn
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* If an instruction consists of just dead store(s) on final pass, 	     "delete" it by turning it into a NOTE of type NOTE_INSN_DELETED. 	     We could really delete it with delete_insn, but that 	     can cause trouble for first or last insn in a basic block.  */
if|if
condition|(
name|final
operator|&&
name|insn_is_dead
condition|)
block|{
name|rtx
name|inote
decl_stmt|;
comment|/* If the insn referred to a label, note that the label is 		 now less used.  */
for|for
control|(
name|inote
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|inote
condition|;
name|inote
operator|=
name|XEXP
argument_list|(
name|inote
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|inote
argument_list|)
operator|==
name|REG_LABEL
condition|)
block|{
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|inote
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|next
decl_stmt|;
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|--
expr_stmt|;
comment|/* If this label was attached to an ADDR_VEC, it's 			 safe to delete the ADDR_VEC.  In fact, it's pretty much 			 mandatory to delete it, because the ADDR_VEC may 			 be referencing labels that no longer exist.  */
if|if
condition|(
name|LABEL_NUSES
argument_list|(
name|label
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|next
operator|=
name|next_nonnote_insn
argument_list|(
name|label
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|GET_CODE
argument_list|(
name|next
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|next
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|)
condition|)
block|{
name|rtx
name|pat
init|=
name|PATTERN
argument_list|(
name|next
argument_list|)
decl_stmt|;
name|int
name|diff_vec_p
init|=
name|GET_CODE
argument_list|(
name|pat
argument_list|)
operator|==
name|ADDR_DIFF_VEC
decl_stmt|;
name|int
name|len
init|=
name|XVECLEN
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|LABEL_NUSES
argument_list|(
name|XEXP
argument_list|(
name|XVECEXP
argument_list|(
name|pat
argument_list|,
name|diff_vec_p
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|--
expr_stmt|;
name|flow_delete_insn
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* CC0 is now known to be dead.  Either this insn used it, 		 in which case it doesn't anymore, or clobbered it, 		 so the next insn can't use it.  */
name|cc0_live
operator|=
literal|0
expr_stmt|;
comment|/* If this insn is copying the return value from a library call, 		 delete the entire library call.  */
if|if
condition|(
name|libcall_is_dead
condition|)
block|{
name|rtx
name|first
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|p
init|=
name|insn
decl_stmt|;
while|while
condition|(
name|INSN_DELETED_P
argument_list|(
name|first
argument_list|)
condition|)
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|first
condition|)
block|{
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|p
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
goto|goto
name|flushed
goto|;
block|}
name|CLEAR_REG_SET
argument_list|(
name|dead
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|live
argument_list|)
expr_stmt|;
comment|/* See if this is an increment or decrement that can be 	     merged into a following memory address.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
block|{
specifier|register
name|rtx
name|x
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Does this instruction increment or decrement a register?  */
if|if
condition|(
operator|!
name|reload_completed
operator|&&
name|final
operator|&&
name|x
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
comment|/* Ok, look for a following memory ref we can combine with. 		   If one is found, change the memory ref to a PRE_INC 		   or PRE_DEC, cancel this insn, and return 1. 		   Return 0 if nothing has been done.  */
operator|&&
name|try_pre_increment_1
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|flushed
goto|;
block|}
endif|#
directive|endif
comment|/* AUTO_INC_DEC */
comment|/* If this is not the final pass, and this insn is copying the 	     value of a library call and it's dead, don't scan the 	     insns that perform the library call, so that the call's 	     arguments are not marked live.  */
if|if
condition|(
name|libcall_is_dead
condition|)
block|{
comment|/* Mark the dest reg as `significant'.  */
name|mark_set_regs
argument_list|(
name|old
argument_list|,
name|dead
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|significant
argument_list|)
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
comment|/* We have an insn to pop a constant amount off the stack. 	       (Such insns use PLUS regardless of the direction of the stack, 	       and any insn to adjust the stack by a constant is always a pop.) 	       These insns, if not dead stores, have no effect on life.  */
empty_stmt|;
else|else
block|{
comment|/* Any regs live at the time of a call instruction 		 must not go in a register clobbered by calls. 		 Find all regs now live and record this for them.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|final
condition|)
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|old
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 					     REG_N_CALLS_CROSSED (i)++; 					   }
argument_list|)
empty_stmt|;
comment|/* LIVE gets the regs used in INSN; 		 DEAD gets those set by it.  Dead insns don't make anything 		 live.  */
name|mark_set_regs
argument_list|(
name|old
argument_list|,
name|dead
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|final
condition|?
name|insn
else|:
name|NULL_RTX
argument_list|,
name|significant
argument_list|)
expr_stmt|;
comment|/* If an insn doesn't use CC0, it becomes dead since we  		 assume that every insn clobbers it.  So show it dead here; 		 mark_used_regs will set it live if it is referenced.  */
name|cc0_live
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|insn_is_dead
condition|)
name|mark_used_regs
argument_list|(
name|old
argument_list|,
name|live
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Sometimes we may have inserted something before INSN (such as 		 a move) when we make an auto-inc.  So ensure we will scan 		 those insns.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|insn_is_dead
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|mark_used_regs
argument_list|(
name|old
argument_list|,
name|live
argument_list|,
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Each call clobbers all call-clobbered regs that are not 		     global or fixed.  Note that the function-value reg is a 		     call-clobbered reg, and mark_set_regs has already had 		     a chance to handle it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|dead
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The stack ptr is used (honorarily) by a CALL insn.  */
name|SET_REGNO_REG_SET
argument_list|(
name|live
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
comment|/* Calls may also reference any of the global registers, 		     so they are made live.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
name|mark_used_regs
argument_list|(
name|old
argument_list|,
name|live
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Calls also clobber memory.  */
name|mem_set_list
operator|=
name|NULL_RTX
expr_stmt|;
block|}
comment|/* Update OLD for the registers used or set.  */
name|AND_COMPL_REG_SET
argument_list|(
name|old
argument_list|,
name|dead
argument_list|)
expr_stmt|;
name|IOR_REG_SET
argument_list|(
name|old
argument_list|,
name|live
argument_list|)
expr_stmt|;
block|}
comment|/* On final pass, update counts of how many insns each reg is live 	     at.  */
if|if
condition|(
name|final
condition|)
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|old
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ REG_LIVE_LENGTH (i)++; }
argument_list|)
empty_stmt|;
block|}
name|flushed
label|:
empty_stmt|;
if|if
condition|(
name|insn
operator|==
name|first
condition|)
break|break;
block|}
name|FREE_REG_SET
argument_list|(
name|dead
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|live
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X (the body of an insn, or part of it) is just dead stores    (SET expressions whose destinations are registers dead after the insn).    NEEDED is the regset that says which regs are alive after the insn.     Unless CALL_OK is non-zero, an insn is needed if it contains a CALL.     If X is the entire body of an insn, NOTES contains the reg notes    pertaining to the insn.  */
end_comment

begin_function
specifier|static
name|int
name|insn_dead_p
parameter_list|(
name|x
parameter_list|,
name|needed
parameter_list|,
name|call_ok
parameter_list|,
name|notes
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|regset
name|needed
decl_stmt|;
name|int
name|call_ok
decl_stmt|;
name|rtx
name|notes
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* If flow is invoked after reload, we must take existing AUTO_INC      expresions into account.  */
if|if
condition|(
name|reload_completed
condition|)
block|{
for|for
control|(
init|;
name|notes
condition|;
name|notes
operator|=
name|XEXP
argument_list|(
name|notes
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|notes
argument_list|)
operator|==
name|REG_INC
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|notes
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Don't delete insns to set global regs.  */
if|if
condition|(
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
operator|||
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* If setting something that's a reg or part of one,      see if that register's altered value will be live.  */
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|rtx
name|r
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* A SET that is a subroutine call cannot be dead.  */
if|if
condition|(
operator|!
name|call_ok
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|CC0
condition|)
return|return
operator|!
name|cc0_live
return|;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|rtx
name|temp
decl_stmt|;
comment|/* Walk the set of memory locations we are currently tracking 	     and see if one is an identical match to this memory location. 	     If so, this memory write is dead (remember, we're walking 	     backwards from the end of the block to the start.  */
name|temp
operator|=
name|mem_set_list
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|r
argument_list|)
condition|)
return|return
literal|1
return|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|r
operator|=
name|SUBREG_REG
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|r
argument_list|)
decl_stmt|;
comment|/* Don't delete insns to set global regs.  */
if|if
condition|(
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
comment|/* Make sure insns to set frame pointer aren't deleted.  */
operator|||
operator|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
operator|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
comment|/* Make sure insns to set arg pointer are never deleted 		 (if the arg pointer isn't fixed, there will be a USE for 		 it, so we can treat it normally).  */
operator|||
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|||
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is a hard register, verify that subsequent words are 	     not needed.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|r
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
operator|+
name|n
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
block|}
comment|/* If performing several activities,      insn is dead if each activity is individually dead.      Also, CLOBBERs and USEs can be ignored; a CLOBBER or USE      that's inside a PARALLEL doesn't make the insn worth keeping.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
operator|!
name|insn_dead_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|needed
argument_list|,
name|call_ok
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/* A CLOBBER of a pseudo-register that is dead serves no purpose.  That      is not necessarily true for hard registers.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We do not check other CLOBBER or USE here.  An insn consisting of just      a CLOBBER or just a USE should not be deleted.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If X is the pattern of the last insn in a libcall, and assuming X is dead,    return 1 if the entire library call is dead.    This is true if X copies a register (hard or pseudo)    and if the hard return  reg of the call insn is dead.    (The caller should have tested the destination of X already for death.)     If this insn doesn't just copy a register, then we don't    have an ordinary libcall.  In that case, cse could not have    managed to substitute the source for the dest later on,    so we can assume the libcall is dead.     NEEDED is the bit vector of pseudoregs live before this insn.    NOTE is the REG_RETVAL note of the insn.  INSN is the insn itself.  */
end_comment

begin_function
specifier|static
name|int
name|libcall_dead_p
parameter_list|(
name|x
parameter_list|,
name|needed
parameter_list|,
name|note
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|regset
name|needed
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
specifier|register
name|rtx
name|r
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|call
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|call_pat
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Find the call insn.  */
while|while
condition|(
name|call
operator|!=
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|call
argument_list|)
operator|!=
name|CALL_INSN
condition|)
name|call
operator|=
name|NEXT_INSN
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|/* If there is none, do nothing special, 	     since ordinary death handling can understand these insns.  */
if|if
condition|(
name|call
operator|==
name|insn
condition|)
return|return
literal|0
return|;
comment|/* See if the hard reg holding the value is dead. 	     If this is a PARALLEL, find the call within it.  */
name|call_pat
operator|=
name|PATTERN
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|call_pat
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|call_pat
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|call_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|call_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
break|break;
comment|/* This may be a library call that is returning a value 		 via invisible pointer.  Do nothing special, since 		 ordinary death handling can understand these insns.  */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|call_pat
operator|=
name|XVECEXP
argument_list|(
name|call_pat
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|insn_dead_p
argument_list|(
name|call_pat
argument_list|,
name|needed
argument_list|,
literal|1
argument_list|,
name|REG_NOTES
argument_list|(
name|call
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if register REGNO was used before it was set, i.e. if it is    live at function entry.  Don't count global register variables, variables    in registers that can be used for function arg passing, or variables in    fixed hard registers.  */
end_comment

begin_function
name|int
name|regno_uninitialized
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
operator|||
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|global_regs
index|[
name|regno
index|]
operator|||
name|fixed_regs
index|[
name|regno
index|]
operator|||
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|REGNO_REG_SET_P
argument_list|(
name|BASIC_BLOCK
argument_list|(
literal|0
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* 1 if register REGNO was alive at a place where `setjmp' was called    and was set more than once or is an argument.    Such regs may be clobbered by `longjmp'.  */
end_comment

begin_function
name|int
name|regno_clobbered_at_setjmp
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|>
literal|1
operator|||
name|REGNO_REG_SET_P
argument_list|(
name|BASIC_BLOCK
argument_list|(
literal|0
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
operator|)
operator|&&
name|REGNO_REG_SET_P
argument_list|(
name|regs_live_at_setjmp
argument_list|,
name|regno
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* INSN references memory, possibly using autoincrement addressing modes.    Find any entries on the mem_set_list that need to be invalidated due    to an address change.  */
end_comment

begin_function
specifier|static
name|void
name|invalidate_mems_from_autoinc
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|note
init|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
decl_stmt|;
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_INC
condition|)
block|{
name|rtx
name|temp
init|=
name|mem_set_list
decl_stmt|;
name|rtx
name|prev
init|=
name|NULL_RTX
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|reg_overlap_mentioned_p
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Splice temp out of list.  */
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|mem_set_list
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process the registers that are set within X.    Their bits are set to 1 in the regset DEAD,    because they are dead prior to this insn.     If INSN is nonzero, it is the insn being processed    and the fact that it is nonzero implies this is the FINAL pass    in propagate_block.  In this case, various info about register    usage is stored, LOG_LINKS fields of insns are set up.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set_regs
parameter_list|(
name|needed
parameter_list|,
name|dead
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|,
name|significant
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|dead
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|regset
name|significant
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|mark_set_1
argument_list|(
name|needed
argument_list|,
name|dead
argument_list|,
name|x
argument_list|,
name|insn
argument_list|,
name|significant
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|mark_set_1
argument_list|(
name|needed
argument_list|,
name|dead
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|significant
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process a single SET rtx, X.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set_1
parameter_list|(
name|needed
parameter_list|,
name|dead
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|,
name|significant
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|dead
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|regset
name|significant
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Some targets place small structures in registers for      return values of functions.  We have to detect this      case specially here to get correct flow information.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|mark_set_1
argument_list|(
name|needed
argument_list|,
name|dead
argument_list|,
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|significant
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Modifying just one hardware register of a multi-reg value      or just a byte field of a register      does not mean the value from before this insn is now dead.      But it does mean liveness of that register at the end of the block      is significant.       Within mark_set_1, however, we treat it as if the register is      indeed modified.  mark_used_regs will, however, also treat this      register as being used.  Thus, we treat these insns as setting a      new value for the register as a function of its old value.  This      cases LOG_LINKS to be made appropriately and this will help combine.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this set is a MEM, then it kills any aliased writes.       If this set is a REG, then it kills any MEMs which use the reg.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|temp
init|=
name|mem_set_list
decl_stmt|;
name|rtx
name|prev
init|=
name|NULL_RTX
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|&&
name|output_dependence
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Splice this entry out of the list.  */
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|mem_set_list
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the memory reference had embedded side effects (autoincrement      address modes.  Then we may need to kill some entries on the      memory set list.  */
if|if
condition|(
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
condition|)
name|invalidate_mems_from_autoinc
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|reg
argument_list|)
comment|/* We do not know the size of a BLKmode store, so we do not track 	 them for redundant store elimination.  */
operator|&&
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|!=
name|BLKmode
comment|/* There are no REG_INC notes for SP, so we can't assume we'll see  	 everything that invalidates it.  To be safe, don't eliminate any 	 stores though SP; none of them should be redundant anyway.  */
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
condition|)
name|mem_set_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|mem_set_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|,
operator|!
operator|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
condition|)
comment|/*&& regno != STACK_POINTER_REGNUM) -- let's try without this.  */
block|{
name|int
name|some_needed
init|=
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|int
name|some_not_needed
init|=
operator|!
name|some_needed
decl_stmt|;
comment|/* Mark it as a significant register for this basic block.  */
if|if
condition|(
name|significant
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|significant
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Mark it as dead before this insn.  */
name|SET_REGNO_REG_SET
argument_list|(
name|dead
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers. 	 If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* Nothing below is needed for the stack pointer; get out asap. 	     Eg, log links aren't needed, since combine won't use them.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return;
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|regno_n
init|=
name|regno
operator|+
name|n
decl_stmt|;
name|int
name|needed_regno
init|=
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno_n
argument_list|)
decl_stmt|;
if|if
condition|(
name|significant
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|significant
argument_list|,
name|regno_n
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|dead
argument_list|,
name|regno_n
argument_list|)
expr_stmt|;
name|some_needed
operator||=
name|needed_regno
expr_stmt|;
name|some_not_needed
operator||=
operator|!
name|needed_regno
expr_stmt|;
block|}
block|}
comment|/* Additional data to record if this is the final pass.  */
if|if
condition|(
name|insn
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|reg_next_use
index|[
name|regno
index|]
decl_stmt|;
specifier|register
name|int
name|blocknum
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If this is a hard reg, record this function uses the reg.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
comment|/* The next use is no longer "next", since a store 		     intervenes.  */
name|reg_next_use
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The next use is no longer "next", since a store 		 intervenes.  */
name|reg_next_use
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Keep track of which basic blocks each reg appears in.  */
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|=
name|blocknum
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|!=
name|blocknum
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
comment|/* Count (weighted) references, stores, etc.  This counts a 		 register twice if it is modified, but that is correct.  */
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
comment|/* The insns where a reg is live are normally counted 		 elsewhere, but we want the count to include the insn 		 where the reg is set, and the normal counting mechanism 		 would not count it.  */
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|some_not_needed
condition|)
block|{
comment|/* Make a logical link from the next following insn 		 that uses this register, back to this insn. 		 The following insns have already been processed.  		 We don't build a LOG_LINK for hard registers containing 		 in ASM_OPERANDs.  If these registers get replaced, 		 we might wind up changing the semantics of the insn, 		 even if reload can make what appear to be valid assignments 		 later.  */
if|if
condition|(
name|y
operator|&&
operator|(
name|BLOCK_NUM
argument_list|(
name|y
argument_list|)
operator|==
name|blocknum
operator|)
operator|&&
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|y
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|LOG_LINKS
argument_list|(
name|y
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|LOG_LINKS
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|some_needed
condition|)
block|{
comment|/* Note that dead stores have already been deleted when possible 		 If we get here, we have found a dead store that cannot 		 be eliminated (because the same insn does something useful). 		 Indicate this by marking the reg being set as dying here.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a case where we have a multi-word hard register 		 and some, but not all, of the words of the register are 		 needed in subsequent insns.  Write REG_UNUSED notes 		 for those parts that were not needed.  This case should 		 be rare.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
name|reg_next_use
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If this is the last pass and this is a SCRATCH, show it will be dying      here and count it.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SCRATCH
operator|&&
name|insn
operator|!=
literal|0
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_comment
comment|/* X is a MEM found in INSN.  See if we can convert it into an auto-increment    reference.  */
end_comment

begin_function
specifier|static
name|void
name|find_auto_inc
parameter_list|(
name|needed
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Here we detect use of an index register which might be good for      postincrement, postdecrement, preincrement, or predecrement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|y
decl_stmt|;
specifier|register
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|use
decl_stmt|;
name|rtx
name|incr
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|addr
argument_list|)
decl_stmt|;
comment|/* Is the next use an increment that might make auto-increment? */
if|if
condition|(
operator|(
name|incr
operator|=
name|reg_next_use
index|[
name|regno
index|]
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|incr
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|BLOCK_NUM
argument_list|(
name|incr
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
comment|/* Can't add side effects to jumps; if reg is spilled and 	     reloaded, there's no way to store back the altered value.  */
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|&&
operator|(
name|y
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
operator|)
operator|&&
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
operator|==
name|addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
operator|(
name|HAVE_POST_INCREMENT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
operator|&&
name|offset
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|HAVE_POST_DECREMENT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|size
operator|&&
name|offset
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|HAVE_PRE_INCREMENT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
operator|&&
name|offset
operator|==
name|size
operator|)
operator|)
operator|||
operator|(
name|HAVE_PRE_DECREMENT
operator|&&
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|size
operator|&&
name|offset
operator|==
operator|-
name|size
operator|)
operator|)
operator|)
comment|/* Make sure this reg appears only once in this insn.  */
operator|&&
operator|(
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
operator|,
name|use
operator|!=
literal|0
operator|&&
name|use
operator|!=
operator|(
name|rtx
operator|)
literal|1
operator|)
condition|)
block|{
name|rtx
name|q
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|inc_code
init|=
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
condition|?
operator|(
name|offset
condition|?
name|PRE_INC
else|:
name|POST_INC
operator|)
else|:
operator|(
name|offset
condition|?
name|PRE_DEC
else|:
name|POST_DEC
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|dead_or_set_p
argument_list|(
name|incr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
comment|/* This is the simple case.  Try to make the auto-inc.  If 		 we can't, we are done.  Otherwise, we will do any 		 needed updates below.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|inc_code
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|REG
comment|/* PREV_INSN used here to check the semi-open interval 		      [insn,incr).  */
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|q
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|incr
argument_list|)
comment|/* We must also check for sets of q as q may be 		      a call clobbered hard register and there may 		      be a call between PREV_INSN (insn) and incr.  */
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|q
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|incr
argument_list|)
condition|)
block|{
comment|/* We have *p followed sometime later by q = p+size. 		 Both p and q must be live afterward, 		 and q is not used between INSN and its assignment. 		 Change it to q = p, ...*q..., q = q+size. 		 Then fall into the usual case.  */
name|rtx
name|insns
decl_stmt|,
name|temp
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|q
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
name|bb
operator|=
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|insns
init|;
name|temp
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
name|set_block_for_insn
argument_list|(
name|temp
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* If we can't make the auto-inc, or can't make the 		 replacement into Y, exit.  There's no point in making 		 the change below if we can't do the auto-inc and doing 		 so is not correct in the pre-inc case.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|inc_code
argument_list|,
name|Pmode
argument_list|,
name|q
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|incr
argument_list|,
operator|&
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
return|return;
comment|/* We now know we'll be doing this change, so emit the 		 new insn(s) and do the updates.  */
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|->
name|head
operator|==
name|insn
condition|)
name|BLOCK_FOR_INSN
argument_list|(
name|insn
argument_list|)
operator|->
name|head
operator|=
name|insns
expr_stmt|;
comment|/* INCR will become a NOTE and INSN won't contain a 		 use of ADDR.  If a use of ADDR was just placed in 		 the insn before INSN, make that the next use.  		 Otherwise, invalidate it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|addr
condition|)
name|reg_next_use
index|[
name|regno
index|]
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|reg_next_use
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|q
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* REGNO is now used in INCR which is below INSN, but 		 it previously wasn't live here.  If we don't mark 		 it as needed, we'll put a REG_DEAD note for it 		 on this insn, which is incorrect.  */
name|SET_REGNO_REG_SET
argument_list|(
name|needed
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* If there are any calls between INSN and INCR, show 		 that REGNO now crosses them.  */
for|for
control|(
name|temp
operator|=
name|insn
init|;
name|temp
operator|!=
name|incr
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
else|else
return|return;
comment|/* If we haven't returned, it means we were able to make the 	     auto-inc, so update the status.  First, record that this insn 	     has an implicit side effect.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|addr
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Modify the old increment-insn to simply copy 	     the already-incremented value of our register.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|incr
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If that makes it a no-op (copying the register into itself) delete 	     it so it won't appear to be a "use" and a "set" of this 	     register.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|addr
condition|)
block|{
name|PUT_CODE
argument_list|(
name|incr
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|incr
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|incr
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Count an extra reference to the reg.  When a reg is 		 incremented, spilling it is worse, so we want to make 		 that less likely.  */
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
comment|/* Count the increment as a setting of the register, 		 even though it isn't a SET in rtl.  */
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTO_INC_DEC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Scan expression X and store a 1-bit in LIVE for each reg it uses.    This is done assuming the registers needed from X    are those that have 1-bits in NEEDED.     On the final pass, FINAL is 1.  This means try for autoincrement    and count the uses and deaths of each pseudo-reg.     INSN is the containing instruction.  If INSN is dead, this function is not    called.  */
end_comment

begin_function
specifier|static
name|void
name|mark_used_regs
parameter_list|(
name|needed
parameter_list|,
name|live
parameter_list|,
name|x
parameter_list|,
name|final
parameter_list|,
name|insn
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|live
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|final
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|retry
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|PC
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
name|cc0_live
operator|=
literal|1
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
name|CLOBBER
case|:
comment|/* If we are clobbering a MEM, mark any registers inside the address 	 as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEM
case|:
comment|/* Invalidate the data for the last MEM stored, but only if MEM is 	 something that can be stored into.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* needn't clear the memory set list */
else|else
block|{
name|rtx
name|temp
init|=
name|mem_set_list
decl_stmt|;
name|rtx
name|prev
init|=
name|NULL_RTX
decl_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|anti_dependence
argument_list|(
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
condition|)
block|{
comment|/* Splice temp out of the list.  */
if|if
condition|(
name|prev
condition|)
name|XEXP
argument_list|(
name|prev
argument_list|,
literal|1
argument_list|)
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|mem_set_list
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|XEXP
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the memory reference had embedded side effects (autoincrement 	 address modes.  Then we may need to kill some entries on the 	 memory set list.  */
if|if
condition|(
name|insn
condition|)
name|invalidate_mems_from_autoinc
argument_list|(
name|insn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
if|if
condition|(
name|final
condition|)
name|find_auto_inc
argument_list|(
name|needed
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|REG_CHANGES_SIZE
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* While we're here, optimize this case.  */
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* In case the SUBREG is not of a register, don't optimize */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|x
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ... fall through ...  */
case|case
name|REG
case|:
comment|/* See a register other than being set 	 => mark it as needed.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|{
name|int
name|some_needed
init|=
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|int
name|some_not_needed
init|=
operator|!
name|some_needed
decl_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers. 	   If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* For stack ptr or fixed arg pointer, 	       nothing below can be necessary, so waste no more time.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
operator|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|||
operator|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
condition|)
block|{
comment|/* If this is a register we are going to try to eliminate, 		   don't mark it live here.  If we are successful in 		   eliminating it, it need not be live unless it is used for 		   pseudos, in which case it will have been set live when 		   it was allocated to the pseudos.  If the register will not 		   be eliminated, reload will set it live at that point.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|regno
argument_list|)
condition|)
name|regs_ever_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* No death notes for global register variables; 	       their values are live after this function exits.  */
if|if
condition|(
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|final
condition|)
name|reg_next_use
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|regno_n
init|=
name|regno
operator|+
name|n
decl_stmt|;
name|int
name|needed_regno
init|=
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno_n
argument_list|)
decl_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|live
argument_list|,
name|regno_n
argument_list|)
expr_stmt|;
name|some_needed
operator||=
name|needed_regno
expr_stmt|;
name|some_not_needed
operator||=
operator|!
name|needed_regno
expr_stmt|;
block|}
block|}
if|if
condition|(
name|final
condition|)
block|{
comment|/* Record where each reg is used, so when the reg 	       is set we know the next insn that uses it.  */
name|reg_next_use
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* If a hard reg is being used, 		   record that this function does use it.  */
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
do|do
name|regs_ever_live
index|[
name|regno
operator|+
operator|--
name|i
index|]
operator|=
literal|1
expr_stmt|;
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|/* Keep track of which basic block each reg appears in.  */
specifier|register
name|int
name|blocknum
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|=
name|blocknum
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|!=
name|blocknum
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
comment|/* Count (weighted) number of uses of each reg.  */
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
block|}
comment|/* Record and count the insns in which a reg dies. 	       If it is used in this insn and was dead below the insn 	       then it dies in this insn.  If it was set in this insn, 	       we do not make a REG_DEAD note; likewise if we already 	       made such a note.  */
if|if
condition|(
name|some_not_needed
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
if|#
directive|if
literal|0
condition|&& (regno>= FIRST_PSEUDO_REGISTER || ! fixed_regs[regno])
endif|#
directive|endif
condition|)
block|{
comment|/* Check for the case where the register dying partially 		   overlaps the register set by this insn.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|some_needed
operator||=
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* If none of the words in X is needed, make a REG_DEAD 		   note.  Otherwise, we must make partial REG_DEAD notes.  */
if|if
condition|(
operator|!
name|some_needed
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|x
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Don't make a REG_DEAD note for a part of a register 		       that is set in the insn.  */
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
operator|+
name|i
argument_list|)
operator|&&
operator|!
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return;
case|case
name|SET
case|:
block|{
specifier|register
name|rtx
name|testreg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|mark_dest
init|=
literal|0
decl_stmt|;
comment|/* If storing into MEM, don't show it as being used.  But do 	   show the address as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|MEM
condition|)
block|{
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
if|if
condition|(
name|final
condition|)
name|find_auto_inc
argument_list|(
name|needed
argument_list|,
name|testreg
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Storing in STRICT_LOW_PART is like storing in a reg 	   in that this SET might be dead, so ignore it in TESTREG. 	   but in some other ways it is like using the reg.  	   Storing in a SUBREG or a bit field is like storing the entire 	   register in that if the register's value is not used 	   then this SET is not needed.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|REG_CHANGES_SIZE
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Modifying a single register in an alternate mode 	       does not use any of the old value.  But these other 	       ways of storing in a register do use the old value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|!
operator|(
name|REG_SIZE
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|>
name|REG_SIZE
argument_list|(
name|testreg
argument_list|)
operator|)
condition|)
empty_stmt|;
else|else
name|mark_dest
operator|=
literal|1
expr_stmt|;
name|testreg
operator|=
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a store into a register, 	   recursively scan the value being stored.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_MODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|BLKmode
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|testreg
argument_list|)
operator|,
operator|!
operator|(
name|regno
operator|==
name|FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
operator|&&
operator|(
operator|!
name|reload_completed
operator|||
name|frame_pointer_needed
operator|)
operator|)
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|)
condition|)
comment|/* We used to exclude global_regs here, but that seems wrong. 	     Storing in them is like storing in mem.  */
block|{
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_dest
condition|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|RETURN
case|:
comment|/* If exiting needs the right stack value, consider this insn as 	 using the stack pointer.  In any event, consider it as using 	 all global registers and all registers used by return.  */
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
operator|||
operator|(
operator|!
name|FRAME_POINTER_REQUIRED
operator|&&
operator|!
name|current_function_calls_alloca
operator|&&
name|flag_omit_frame_pointer
operator|)
operator|||
name|current_function_sp_is_unchanging
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|live
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
ifdef|#
directive|ifdef
name|EPILOGUE_USES
operator|||
name|EPILOGUE_USES
argument_list|(
name|i
argument_list|)
endif|#
directive|endif
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|live
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASM_OPERANDS
case|:
case|case
name|UNSPEC_VOLATILE
case|:
case|case
name|TRAP_IF
case|:
case|case
name|ASM_INPUT
case|:
block|{
comment|/* Traditional and volatile asm instructions must be considered to use 	   and clobber all hard registers, all pseudo-registers and all of 	   memory.  So must TRAP_IF and UNSPEC_VOLATILE operations.  	   Consider for instance a volatile asm that changes the fpu rounding 	   mode.  An insn should not be moved across this even if it only uses 	   pseudo-regs because it might give an incorrectly rounded result.   	   ?!? Unfortunately, marking all hard registers as live causes massive 	   problems for the register allocator and marking all pseudos as live 	   creates mountains of uninitialized variable warnings.  	   So for now, just clear the memory set list and mark any regs 	   we can find in ASM_OPERANDS as used.  */
if|if
condition|(
name|code
operator|!=
name|ASM_OPERANDS
operator|||
name|MEM_VOLATILE_P
argument_list|(
name|x
argument_list|)
condition|)
name|mem_set_list
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* For all ASM_OPERANDS, we must traverse the vector of input operands. 	   We can not just fall through here since then we would be confused 	   by the ASM_INPUT rtx inside ASM_OPERANDS, which do not indicate 	   traditional asms unlike their normal usage.  */
if|if
condition|(
name|code
operator|==
name|ASM_OPERANDS
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ASM_OPERANDS_INPUT_LENGTH
argument_list|(
name|x
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|ASM_OPERANDS_INPUT
argument_list|(
name|x
argument_list|,
name|j
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Tail recursive case: save a function call level.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_function
specifier|static
name|int
name|try_pre_increment_1
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Find the next use of this reg.  If in same basic block,      make it do pre-increment or pre-decrement if appropriate.  */
name|rtx
name|x
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|amount
init|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|y
init|=
name|reg_next_use
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
name|BLOCK_NUM
argument_list|(
name|y
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
comment|/* Don't do this if the reg dies, or gets set in y; a standard addressing 	 mode would be better.  */
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|y
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|try_pre_increment
argument_list|(
name|y
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|amount
argument_list|)
condition|)
block|{
comment|/* We have found a suitable auto-increment 	 and already changed insn Y to do it. 	 So flush this increment-instruction.  */
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Count a reference to this reg for the increment 	 insn we are deleting.  When a reg is incremented. 	 spilling it is worse, so we want to make that 	 less likely.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to change INSN so that it does pre-increment or pre-decrement    addressing on register REG in order to add AMOUNT to REG.    AMOUNT is negative for pre-decrement.    Returns 1 if the change could be made.    This checks all about the validity of the result of modifying INSN.  */
end_comment

begin_function
specifier|static
name|int
name|try_pre_increment
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|,
name|amount
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|;
name|HOST_WIDE_INT
name|amount
decl_stmt|;
block|{
specifier|register
name|rtx
name|use
decl_stmt|;
comment|/* Nonzero if we can try to make a pre-increment or pre-decrement.      For example, addl $4,r1; movl (r1),... can become movl +(r1),...  */
name|int
name|pre_ok
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if we can try to make a post-increment or post-decrement.      For example, addl $4,r1; movl -4(r1),... can become movl (r1)+,...      It is possible for both PRE_OK and POST_OK to be nonzero if the machine      supports both pre-inc and post-inc, or both pre-dec and post-dec.  */
name|int
name|post_ok
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if the opportunity actually requires post-inc or post-dec.  */
name|int
name|do_post
init|=
literal|0
decl_stmt|;
comment|/* From the sign of increment, see which possibilities are conceivable      on this target machine.  */
if|if
condition|(
name|HAVE_PRE_INCREMENT
operator|&&
name|amount
operator|>
literal|0
condition|)
name|pre_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|HAVE_POST_INCREMENT
operator|&&
name|amount
operator|>
literal|0
condition|)
name|post_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|HAVE_PRE_DECREMENT
operator|&&
name|amount
operator|<
literal|0
condition|)
name|pre_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|HAVE_POST_DECREMENT
operator|&&
name|amount
operator|<
literal|0
condition|)
name|post_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pre_ok
operator|||
name|post_ok
operator|)
condition|)
return|return
literal|0
return|;
comment|/* It is not safe to add a side effect to a jump insn      because if the incremented register is spilled and must be reloaded      there would be no way to store the incremented value back in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
name|use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pre_ok
condition|)
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_ok
operator|&&
operator|(
name|use
operator|==
literal|0
operator|||
name|use
operator|==
operator|(
name|rtx
operator|)
literal|1
operator|)
condition|)
block|{
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|,
operator|-
name|amount
argument_list|)
expr_stmt|;
name|do_post
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|use
operator|==
literal|0
operator|||
name|use
operator|==
operator|(
name|rtx
operator|)
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|use
argument_list|)
argument_list|)
operator|!=
operator|(
name|amount
operator|>
literal|0
condition|?
name|amount
else|:
operator|-
name|amount
operator|)
condition|)
return|return
literal|0
return|;
comment|/* See if this combination of instruction and addressing mode exists.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|use
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|amount
operator|>
literal|0
condition|?
operator|(
name|do_post
condition|?
name|POST_INC
else|:
name|PRE_INC
operator|)
else|:
operator|(
name|do_post
condition|?
name|POST_DEC
else|:
name|PRE_DEC
operator|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Record that this insn now has an implicit side effect on X.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTO_INC_DEC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Find the place in the rtx X where REG is used as a memory address.    Return the MEM rtx that so uses it.    If PLUSCONST is nonzero, search instead for a memory address equivalent to    (plus REG (const_int PLUSCONST)).     If such an address does not appear, return 0.    If REG appears more than once, or is used other than in such an address,    return (rtx)1.  */
end_comment

begin_function
name|rtx
name|find_use_as_address
parameter_list|(
name|x
parameter_list|,
name|reg
parameter_list|,
name|plusconst
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|HOST_WIDE_INT
name|plusconst
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|value
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|plusconst
operator|==
literal|0
condition|)
return|return
name|x
return|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|plusconst
condition|)
return|return
name|x
return|;
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
operator|||
name|code
operator|==
name|ZERO_EXTRACT
condition|)
block|{
comment|/* If REG occurs inside a MEM used in a bit-field reference, 	 that is unacceptable.  */
if|if
condition|(
name|find_use_as_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
block|}
if|if
condition|(
name|x
operator|==
name|reg
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|tem
operator|=
name|find_use_as_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|reg
argument_list|,
name|plusconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
block|}
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tem
operator|=
name|find_use_as_address
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg
argument_list|,
name|plusconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
block|}
block|}
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write information about registers and basic blocks into FILE.    This is part of making a debugging dump.  */
end_comment

begin_function
name|void
name|dump_flow_info
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d registers.\n"
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|enum
name|reg_class
name|class
decl_stmt|,
name|altclass
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegister %d used %d times across %d insns"
argument_list|,
name|i
argument_list|,
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
argument_list|,
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" in block %d"
argument_list|,
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; set %d time%s"
argument_list|,
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_USERVAR_P
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; user var"
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_DEATHS
argument_list|(
name|i
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; dies in %d places"
argument_list|,
name|REG_N_DEATHS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses 1 call"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses %d calls"
argument_list|,
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
operator|!=
name|UNITS_PER_WORD
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %d bytes"
argument_list|,
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|class
operator|=
name|reg_preferred_class
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|altclass
operator|=
name|reg_alternate_class
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|GENERAL_REGS
operator|||
name|altclass
operator|!=
name|ALL_REGS
condition|)
block|{
if|if
condition|(
name|altclass
operator|==
name|ALL_REGS
operator|||
name|class
operator|==
name|ALL_REGS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pref %s"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|altclass
operator|==
name|NO_REGS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %s or none"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pref %s, else %s"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|altclass
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REGNO_POINTER_FLAG
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pointer"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%d basic blocks.\n"
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|edge
name|e
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nBasic block %d: first insn %d, last %d.\n"
argument_list|,
name|i
argument_list|,
name|INSN_UID
argument_list|(
name|bb
operator|->
name|head
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|bb
operator|->
name|end
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Predecessors: "
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|pred
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|pred_next
control|)
name|dump_edge_info
argument_list|(
name|file
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nSuccessors: "
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|dump_edge_info
argument_list|(
name|file
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegisters live at start:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|global_live_at_start
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_regno
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|bb
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" n/a"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegisters live at end:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|global_live_at_end
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_regno
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|bb
operator|->
name|global_live_at_end
argument_list|,
name|regno
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" n/a"
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_edge_info
parameter_list|(
name|file
parameter_list|,
name|e
parameter_list|,
name|do_succ
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|int
name|do_succ
decl_stmt|;
block|{
name|basic_block
name|side
init|=
operator|(
name|do_succ
condition|?
name|e
operator|->
name|dest
else|:
name|e
operator|->
name|src
operator|)
decl_stmt|;
if|if
condition|(
name|side
operator|==
name|ENTRY_BLOCK_PTR
condition|)
name|fputs
argument_list|(
literal|" ENTRY"
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|side
operator|==
name|EXIT_BLOCK_PTR
condition|)
name|fputs
argument_list|(
literal|" EXIT"
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|side
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
condition|)
block|{
specifier|static
name|char
modifier|*
name|bitnames
index|[]
init|=
block|{
literal|"fallthru"
block|,
literal|"crit"
block|,
literal|"ab"
block|,
literal|"abcall"
block|,
literal|"eh"
block|,
literal|"fake"
block|}
decl_stmt|;
name|int
name|comma
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|flags
init|=
name|e
operator|->
name|flags
decl_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'('
argument_list|,
name|file
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|flags
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|flags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|comma
condition|)
name|fputc
argument_list|(
literal|','
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|bitnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|bitnames
argument_list|)
argument_list|)
condition|)
name|fputs
argument_list|(
name|bitnames
index|[
name|i
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
name|fputc
argument_list|(
literal|')'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like print_rtl, but also print out live information for the start of each    basic block.  */
end_comment

begin_function
name|void
name|print_rtl_with_bb
parameter_list|(
name|outf
parameter_list|,
name|rtx_first
parameter_list|)
name|FILE
modifier|*
name|outf
decl_stmt|;
name|rtx
name|rtx_first
decl_stmt|;
block|{
specifier|register
name|rtx
name|tmp_rtx
decl_stmt|;
if|if
condition|(
name|rtx_first
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"(nil)\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
enum|enum
name|bb_state
block|{
name|NOT_IN_BB
block|,
name|IN_ONE_BB
block|,
name|IN_MULTIPLE_BB
block|}
enum|;
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
name|basic_block
modifier|*
name|start
init|=
operator|(
name|basic_block
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|end
init|=
operator|(
name|basic_block
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
decl_stmt|;
name|enum
name|bb_state
modifier|*
name|in_bb_p
init|=
operator|(
expr|enum
name|bb_state
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|bb_state
argument_list|)
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|start
argument_list|,
literal|0
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|end
argument_list|,
literal|0
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|in_bb_p
argument_list|,
literal|0
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|bb_state
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|start
index|[
name|INSN_UID
argument_list|(
name|bb
operator|->
name|head
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
name|end
index|[
name|INSN_UID
argument_list|(
name|bb
operator|->
name|end
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
for|for
control|(
name|x
operator|=
name|bb
operator|->
name|head
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|enum
name|bb_state
name|state
init|=
name|IN_MULTIPLE_BB
decl_stmt|;
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|NOT_IN_BB
condition|)
name|state
operator|=
name|IN_ONE_BB
expr_stmt|;
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
block|}
block|}
for|for
control|(
name|tmp_rtx
operator|=
name|rtx_first
init|;
name|NULL
operator|!=
name|tmp_rtx
condition|;
name|tmp_rtx
operator|=
name|NEXT_INSN
argument_list|(
name|tmp_rtx
argument_list|)
control|)
block|{
name|int
name|did_output
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|start
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Start of basic block %d, registers live:"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|bb->global_live_at_start
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 					   fprintf (outf,
literal|" %d"
argument|, i); 					   if (i< FIRST_PSEUDO_REGISTER) 					     fprintf (outf,
literal|" [%s]"
argument|, 						      reg_names[i]); 					 }
argument_list|)
empty_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|==
name|NOT_IN_BB
operator|&&
name|GET_CODE
argument_list|(
name|tmp_rtx
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|tmp_rtx
argument_list|)
operator|!=
name|BARRIER
operator|&&
operator|!
name|obey_regdecls
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Insn is not within a basic block\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|==
name|IN_MULTIPLE_BB
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Insn is in multiple basic blocks\n"
argument_list|)
expr_stmt|;
name|did_output
operator|=
name|print_rtl_single
argument_list|(
name|outf
argument_list|,
name|tmp_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|end
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; End of basic block %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_output
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Integer list support.  */
end_comment

begin_comment
comment|/* Allocate a node from list *HEAD_PTR.  */
end_comment

begin_function
specifier|static
name|int_list_ptr
name|alloc_int_list_node
parameter_list|(
name|head_ptr
parameter_list|)
name|int_list_block
modifier|*
modifier|*
name|head_ptr
decl_stmt|;
block|{
name|struct
name|int_list_block
modifier|*
name|first_blk
init|=
operator|*
name|head_ptr
decl_stmt|;
if|if
condition|(
name|first_blk
operator|==
name|NULL
operator|||
name|first_blk
operator|->
name|nodes_left
operator|<=
literal|0
condition|)
block|{
name|first_blk
operator|=
operator|(
expr|struct
name|int_list_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|int_list_block
argument_list|)
argument_list|)
expr_stmt|;
name|first_blk
operator|->
name|nodes_left
operator|=
name|INT_LIST_NODES_IN_BLK
expr_stmt|;
name|first_blk
operator|->
name|next
operator|=
operator|*
name|head_ptr
expr_stmt|;
operator|*
name|head_ptr
operator|=
name|first_blk
expr_stmt|;
block|}
name|first_blk
operator|->
name|nodes_left
operator|--
expr_stmt|;
return|return
operator|&
name|first_blk
operator|->
name|nodes
index|[
name|first_blk
operator|->
name|nodes_left
index|]
return|;
block|}
end_function

begin_comment
comment|/* Pointer to head of predecessor/successor block list.  */
end_comment

begin_decl_stmt
specifier|static
name|int_list_block
modifier|*
name|pred_int_list_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add a new node to integer list LIST with value VAL.    LIST is a pointer to a list object to allow for different implementations.    If *LIST is initially NULL, the list is empty.    The caller must not care whether the element is added to the front or    to the end of the list (to allow for different implementations).  */
end_comment

begin_function
specifier|static
name|int_list_ptr
name|add_int_list_node
parameter_list|(
name|blk_list
parameter_list|,
name|list
parameter_list|,
name|val
parameter_list|)
name|int_list_block
modifier|*
modifier|*
name|blk_list
decl_stmt|;
name|int_list
modifier|*
modifier|*
name|list
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|int_list_ptr
name|p
init|=
name|alloc_int_list_node
argument_list|(
name|blk_list
argument_list|)
decl_stmt|;
name|p
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Free the blocks of lists at BLK_LIST.  */
end_comment

begin_function
name|void
name|free_int_list
parameter_list|(
name|blk_list
parameter_list|)
name|int_list_block
modifier|*
modifier|*
name|blk_list
decl_stmt|;
block|{
name|int_list_block
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|blk_list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Mark list as empty for the next function we compile.  */
operator|*
name|blk_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Predecessor/successor computation.  */
end_comment

begin_comment
comment|/* Mark PRED_BB a precessor of SUCC_BB,    and conversely SUCC_BB a successor of PRED_BB.  */
end_comment

begin_function
specifier|static
name|void
name|add_pred_succ
parameter_list|(
name|pred_bb
parameter_list|,
name|succ_bb
parameter_list|,
name|s_preds
parameter_list|,
name|s_succs
parameter_list|,
name|num_preds
parameter_list|,
name|num_succs
parameter_list|)
name|int
name|pred_bb
decl_stmt|;
name|int
name|succ_bb
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|int
modifier|*
name|num_preds
decl_stmt|;
name|int
modifier|*
name|num_succs
decl_stmt|;
block|{
if|if
condition|(
name|succ_bb
operator|!=
name|EXIT_BLOCK
condition|)
block|{
name|add_int_list_node
argument_list|(
operator|&
name|pred_int_list_blocks
argument_list|,
operator|&
name|s_preds
index|[
name|succ_bb
index|]
argument_list|,
name|pred_bb
argument_list|)
expr_stmt|;
name|num_preds
index|[
name|succ_bb
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pred_bb
operator|!=
name|ENTRY_BLOCK
condition|)
block|{
name|add_int_list_node
argument_list|(
operator|&
name|pred_int_list_blocks
argument_list|,
operator|&
name|s_succs
index|[
name|pred_bb
index|]
argument_list|,
name|succ_bb
argument_list|)
expr_stmt|;
name|num_succs
index|[
name|pred_bb
index|]
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert edge lists into pred/succ lists for backward compatibility.  */
end_comment

begin_function
name|void
name|compute_preds_succs
parameter_list|(
name|s_preds
parameter_list|,
name|s_succs
parameter_list|,
name|num_preds
parameter_list|,
name|num_succs
parameter_list|)
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|int
modifier|*
name|num_preds
decl_stmt|;
name|int
modifier|*
name|num_succs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
name|n_basic_blocks
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|memset
argument_list|(
name|s_preds
argument_list|,
literal|0
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int_list_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|s_succs
argument_list|,
literal|0
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int_list_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|num_preds
argument_list|,
literal|0
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|num_succs
argument_list|,
literal|0
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|e
operator|=
name|bb
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|add_pred_succ
argument_list|(
name|i
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|s_preds
argument_list|,
name|s_succs
argument_list|,
name|num_preds
argument_list|,
name|num_succs
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|e
operator|=
name|ENTRY_BLOCK_PTR
operator|->
name|succ
init|;
name|e
condition|;
name|e
operator|=
name|e
operator|->
name|succ_next
control|)
name|add_pred_succ
argument_list|(
name|ENTRY_BLOCK
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|s_preds
argument_list|,
name|s_succs
argument_list|,
name|num_preds
argument_list|,
name|num_succs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_bb_data
parameter_list|(
name|file
parameter_list|,
name|preds
parameter_list|,
name|succs
parameter_list|,
name|live_info
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int_list_ptr
modifier|*
name|preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|succs
decl_stmt|;
name|int
name|live_info
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
name|int_list_ptr
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"BB data\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"BB %d, start %d, end %d\n"
argument_list|,
name|bb
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  preds:"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|preds
index|[
name|bb
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|int
name|pred_bb
init|=
name|INT_LIST_VAL
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|pred_bb
operator|==
name|ENTRY_BLOCK
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" entry"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|pred_bb
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  succs:"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|succs
index|[
name|bb
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|int
name|succ_bb
init|=
name|INT_LIST_VAL
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|succ_bb
operator|==
name|EXIT_BLOCK
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" exit"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|succ_bb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|live_info
condition|)
block|{
name|int
name|regno
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegisters live at start:"
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_regno
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
operator|->
name|global_live_at_start
argument_list|,
name|regno
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free basic block data storage.  */
end_comment

begin_function
name|void
name|free_bb_mem
parameter_list|()
block|{
name|free_int_list
argument_list|(
operator|&
name|pred_int_list_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute dominator relationships.  */
end_comment

begin_function
name|void
name|compute_dominators
parameter_list|(
name|dominators
parameter_list|,
name|post_dominators
parameter_list|,
name|s_preds
parameter_list|,
name|s_succs
parameter_list|)
name|sbitmap
modifier|*
name|dominators
decl_stmt|;
name|sbitmap
modifier|*
name|post_dominators
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap
modifier|*
name|temp_bitmap
decl_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|dominators
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|post_dominators
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|temp_bitmap
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|dominators
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|dominators
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|post_dominators
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|post_dominators
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|1
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|sbitmap_intersect_of_predecessors
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|dominators
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_a_and_b
argument_list|(
name|dominators
index|[
name|bb
index|]
argument_list|,
name|dominators
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|sbitmap_intersect_of_successors
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|post_dominators
argument_list|,
name|bb
argument_list|,
name|s_succs
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_a_and_b
argument_list|(
name|post_dominators
index|[
name|bb
index|]
argument_list|,
name|post_dominators
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given DOMINATORS, compute the immediate dominators into IDOM.  */
end_comment

begin_function
name|void
name|compute_immediate_dominators
parameter_list|(
name|idom
parameter_list|,
name|dominators
parameter_list|)
name|int
modifier|*
name|idom
decl_stmt|;
name|sbitmap
modifier|*
name|dominators
decl_stmt|;
block|{
name|sbitmap
modifier|*
name|tmp
decl_stmt|;
name|int
name|b
decl_stmt|;
name|tmp
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
comment|/* Begin with tmp(n) = dom(n) - { n }.  */
for|for
control|(
name|b
operator|=
name|n_basic_blocks
init|;
operator|--
name|b
operator|>=
literal|0
condition|;
control|)
block|{
name|sbitmap_copy
argument_list|(
name|tmp
index|[
name|b
index|]
argument_list|,
name|dominators
index|[
name|b
index|]
argument_list|)
expr_stmt|;
name|RESET_BIT
argument_list|(
name|tmp
index|[
name|b
index|]
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
comment|/* Subtract out all of our dominator's dominators.  */
for|for
control|(
name|b
operator|=
name|n_basic_blocks
init|;
operator|--
name|b
operator|>=
literal|0
condition|;
control|)
block|{
name|sbitmap
name|tmp_b
init|=
name|tmp
index|[
name|b
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|n_basic_blocks
init|;
operator|--
name|s
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|TEST_BIT
argument_list|(
name|tmp_b
argument_list|,
name|s
argument_list|)
condition|)
name|sbitmap_difference
argument_list|(
name|tmp_b
argument_list|,
name|tmp_b
argument_list|,
name|tmp
index|[
name|s
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Find the one bit set in the bitmap and put it in the output array.  */
for|for
control|(
name|b
operator|=
name|n_basic_blocks
init|;
operator|--
name|b
operator|>=
literal|0
condition|;
control|)
block|{
name|int
name|t
decl_stmt|;
name|EXECUTE_IF_SET_IN_SBITMAP
argument_list|(
argument|tmp[b]
argument_list|,
literal|0
argument_list|,
argument|t
argument_list|,
argument|{ idom[b] = t; }
argument_list|)
empty_stmt|;
block|}
name|sbitmap_vector_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count for a single SET rtx, X.  */
end_comment

begin_function
specifier|static
name|void
name|count_reg_sets_1
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Find the register that's set/clobbered.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_MODE
argument_list|(
name|reg
argument_list|)
operator|==
name|BLKmode
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|count_reg_sets_1
argument_list|(
name|XVECEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Count (weighted) references, stores, etc.  This counts a 	     register twice if it is modified, but that is correct.  */
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Increment REG_N_SETS for each SET or CLOBBER found in X; also increment    REG_N_REFS by the current loop depth for each SET or CLOBBER found.  */
end_comment

begin_function
specifier|static
name|void
name|count_reg_sets
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|count_reg_sets_1
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|count_reg_sets_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Increment REG_N_REFS by the current loop depth each register reference    found in X.  */
end_comment

begin_function
specifier|static
name|void
name|count_reg_references
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|retry
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|PC
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|ASM_INPUT
case|:
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
return|return;
endif|#
directive|endif
case|case
name|CLOBBER
case|:
comment|/* If we are clobbering a MEM, mark any registers inside the address 	 as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|count_reg_references
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SUBREG
case|:
comment|/* While we're here, optimize this case.  */
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* In case the SUBREG is not of a register, don't optimize */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|count_reg_references
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ... fall through ...  */
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
return|return;
case|case
name|SET
case|:
block|{
specifier|register
name|rtx
name|testreg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|mark_dest
init|=
literal|0
decl_stmt|;
comment|/* If storing into MEM, don't show it as being used.  But do 	   show the address as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|count_reg_references
argument_list|(
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|count_reg_references
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Storing in STRICT_LOW_PART is like storing in a reg 	   in that this SET might be dead, so ignore it in TESTREG. 	   but in some other ways it is like using the reg.  	   Storing in a SUBREG or a bit field is like storing the entire 	   register in that if the register's value is not used 	   then this SET is not needed.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Modifying a single register in an alternate mode 	       does not use any of the old value.  But these other 	       ways of storing in a register do use the old value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|!
operator|(
name|REG_SIZE
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|>
name|REG_SIZE
argument_list|(
name|testreg
argument_list|)
operator|)
condition|)
empty_stmt|;
else|else
name|mark_dest
operator|=
literal|1
expr_stmt|;
name|testreg
operator|=
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a store into a register, 	   recursively scan the value being stored.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|PARALLEL
operator|&&
name|GET_MODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|BLKmode
operator|)
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|count_reg_references
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_dest
condition|)
name|count_reg_references
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Tail recursive case: save a function call level.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|count_reg_references
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|count_reg_references
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Recompute register set/reference counts immediately prior to register    allocation.     This avoids problems with set/reference counts changing to/from values    which have special meanings to the register allocators.     Additionally, the reference counts are the primary component used by the    register allocators to prioritize pseudos for allocation to hard regs.    More accurate reference counts generally lead to better register allocation.     F is the first insn to be scanned.    LOOP_STEP denotes how much loop_depth should be incremented per    loop nesting level in order to increase the ref count more for references    in a loop.     It might be worthwhile to update REG_LIVE_LENGTH, REG_BASIC_BLOCK and    possibly other information which is used by the register allocators.  */
end_comment

begin_function
name|void
name|recompute_reg_usage
parameter_list|(
name|f
parameter_list|,
name|loop_step
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|loop_step
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|max_reg
decl_stmt|;
comment|/* Clear out the old data.  */
name|max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
block|{
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Scan each insn in the chain and count how many times each register is      set/used.  */
name|loop_depth
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Keep track of loop depth.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* Look for loop boundaries.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|-=
name|loop_step
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|+=
name|loop_step
expr_stmt|;
comment|/* If we have LOOP_DEPTH == 0, there has been a bookkeeping error.  	     Abort now rather than setting register status incorrectly.  */
if|if
condition|(
name|loop_depth
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|links
decl_stmt|;
comment|/* This call will increment REG_N_SETS for each SET or CLOBBER 	     of a register in INSN.  It will also increment REG_N_REFS 	     by the loop depth for each set of a register in INSN.  */
name|count_reg_sets
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* count_reg_sets does not detect autoincrement address modes, so 	     detect them here by looking at the notes attached to INSN.  */
for|for
control|(
name|links
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|links
condition|;
name|links
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|links
argument_list|)
operator|==
name|REG_INC
condition|)
comment|/* Count (weighted) references, stores, etc.  This counts a 		   register twice if it is modified, but that is correct.  */
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
comment|/* This call will increment REG_N_REFS by the current loop depth for 	     each reference to a register in INSN.  */
name|count_reg_references
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* count_reg_references will not include counts for arguments to 	     function calls, so detect them here by examining the 	     CALL_INSN_FUNCTION_USAGE data.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|count_reg_references
argument_list|(
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record INSN's block as BB.  */
end_comment

begin_function
name|void
name|set_block_for_insn
parameter_list|(
name|insn
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
block|{
name|size_t
name|uid
init|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|uid
operator|>=
name|basic_block_for_insn
operator|->
name|num_elements
condition|)
block|{
name|int
name|new_size
decl_stmt|;
comment|/* Add one-eighth the size so we don't keep calling xrealloc.  */
name|new_size
operator|=
name|uid
operator|+
operator|(
name|uid
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|VARRAY_GROW
argument_list|(
name|basic_block_for_insn
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
block|}
name|VARRAY_BB
argument_list|(
name|basic_block_for_insn
argument_list|,
name|uid
argument_list|)
operator|=
name|bb
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record INSN's block number as BB.  */
end_comment

begin_comment
comment|/* ??? This has got to go.  */
end_comment

begin_function
name|void
name|set_block_num
parameter_list|(
name|insn
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|bb
decl_stmt|;
block|{
name|set_block_for_insn
argument_list|(
name|insn
argument_list|,
name|BASIC_BLOCK
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Verify the CFG consistency.  This function check some CFG invariants and    aborts when something is wrong.  Hope that this function will help to    convert many optimization passes to preserve CFG consistent.     Currently it does following checks:      - test head/end pointers    - overlapping of basic blocks    - edge list corectness    - headers of basic blocks (the NOTE_INSN_BASIC_BLOCK note)    - tails of basic blocks (ensure that boundary is necesary)    - scans body of the basic block for JUMP_INSN, CODE_LABEL      and NOTE_INSN_BASIC_BLOCK    - check that all insns are in the basic blocks     (except the switch handling code, barriers and notes)     In future it can be extended check a lot of other stuff as well    (reachability of basic blocks, life information, etc. etc.).  */
end_comment

begin_function
name|void
name|verify_flow_info
parameter_list|()
block|{
specifier|const
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
specifier|const
name|rtx
name|rtx_first
init|=
name|get_insns
argument_list|()
decl_stmt|;
name|basic_block
modifier|*
name|bb_info
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bb_info
operator|=
operator|(
name|basic_block
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|bb_info
argument_list|,
literal|0
argument_list|,
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|basic_block
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First pass check head/end pointers and set bb_info array used by      later passes.  */
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* Check the head pointer and make sure that it is pointing into          insn list.  */
for|for
control|(
name|x
operator|=
name|rtx_first
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|x
operator|==
name|bb
operator|->
name|head
condition|)
break|break;
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|fatal
argument_list|(
literal|"verify_flow_info: Head insn %d for block %d not found in the insn stream.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|bb
operator|->
name|head
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Check the end pointer and make sure that it is pointing into          insn list.  */
for|for
control|(
name|x
operator|=
name|bb
operator|->
name|head
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|!=
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"verify_flow_info: Insn %d is in multiple basic blocks (%d and %d)"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|fatal
argument_list|(
literal|"verify_flow_info: End insn %d for block %d not found in the insn stream.\n"
argument_list|,
name|INSN_UID
argument_list|(
name|bb
operator|->
name|end
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now check the basic blocks (boundaries etc.) */
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|basic_block
name|bb
init|=
name|BASIC_BLOCK
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* Check corectness of edge lists */
name|edge
name|e
decl_stmt|;
name|e
operator|=
name|bb
operator|->
name|succ
expr_stmt|;
while|while
condition|(
name|e
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|bb
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"verify_flow_info: Basic block %d succ edge is corrupted\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Predecessor: "
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nSuccessor: "
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|EXIT_BLOCK_PTR
condition|)
block|{
name|edge
name|e2
init|=
name|e
operator|->
name|dest
operator|->
name|pred
decl_stmt|;
while|while
condition|(
name|e2
operator|&&
name|e2
operator|!=
name|e
condition|)
name|e2
operator|=
name|e2
operator|->
name|pred_next
expr_stmt|;
if|if
condition|(
operator|!
name|e2
condition|)
block|{
name|fatal
argument_list|(
literal|"verify_flow_info: Basic block %i edge lists are corrupted\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|=
name|e
operator|->
name|succ_next
expr_stmt|;
block|}
name|e
operator|=
name|bb
operator|->
name|pred
expr_stmt|;
while|while
condition|(
name|e
condition|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|bb
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"verify_flow_info: Basic block %d pred edge is corrupted\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Predecessor: "
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nSuccessor: "
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|ENTRY_BLOCK_PTR
condition|)
block|{
name|edge
name|e2
init|=
name|e
operator|->
name|src
operator|->
name|succ
decl_stmt|;
while|while
condition|(
name|e2
operator|&&
name|e2
operator|!=
name|e
condition|)
name|e2
operator|=
name|e2
operator|->
name|succ_next
expr_stmt|;
if|if
condition|(
operator|!
name|e2
condition|)
block|{
name|fatal
argument_list|(
literal|"verify_flow_info: Basic block %i edge lists are corrupted\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
name|e
operator|=
name|e
operator|->
name|pred_next
expr_stmt|;
block|}
comment|/* OK pointers are correct.  Now check the header of basic          block.  It ought to contain optional CODE_LABEL followed 	 by NOTE_BASIC_BLOCK.  */
name|x
operator|=
name|bb
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|x
condition|)
block|{
name|fatal
argument_list|(
literal|"verify_flow_info: Basic block contains only CODE_LABEL and no NOTE_INSN_BASIC_BLOCK note\n"
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
operator|!=
name|NOTE_INSN_BASIC_BLOCK
operator|||
name|NOTE_BASIC_BLOCK
argument_list|(
name|x
argument_list|)
operator|!=
name|bb
condition|)
block|{
name|fatal
argument_list|(
literal|"verify_flow_info: NOTE_INSN_BASIC_BLOCK is missing for block %d\n"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|end
operator|==
name|x
condition|)
block|{
comment|/* Do checks for empty blocks here */
block|}
else|else
block|{
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|x
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|NOTE
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|x
argument_list|)
operator|==
name|NOTE_INSN_BASIC_BLOCK
condition|)
block|{
name|fatal
argument_list|(
literal|"verify_flow_info: NOTE_INSN_BASIC_BLOCK %d in the middle of basic block %d\n"
argument_list|,
name|INSN_UID
argument_list|(
name|x
argument_list|)
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
name|bb
operator|->
name|end
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|JUMP_INSN
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CODE_LABEL
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|BARRIER
condition|)
block|{
name|fatal_insn
argument_list|(
literal|"verify_flow_info: Incorrect insn in the middle of basic block %d\n"
argument_list|,
name|x
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|x
operator|=
name|rtx_first
expr_stmt|;
while|while
condition|(
name|x
condition|)
block|{
if|if
condition|(
operator|!
name|bb_info
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
condition|)
block|{
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|BARRIER
case|:
case|case
name|NOTE
case|:
break|break;
case|case
name|CODE_LABEL
case|:
comment|/* An addr_vec is placed outside any block block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_DIFF_VEC
operator|||
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|ADDR_VEC
operator|)
condition|)
block|{
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* But in any case, non-deletable labels can appear anywhere.  */
break|break;
default|default:
name|fatal_insn
argument_list|(
literal|"verify_flow_info: Insn outside basic block\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

