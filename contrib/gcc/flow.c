begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Data flow analysis for GNU compiler.    Copyright (C) 1987, 88, 92-97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains the data flow analysis pass of the compiler.    It computes data flow information    which tells combine_instructions which insns to consider combining    and controls register allocation.     Additional data flow information that is too bulky to record    is generated during the analysis, and is used at that time to    create autoincrement and autodecrement addressing.     The first step is dividing the function into basic blocks.    find_basic_blocks does this.  Then life_analysis determines    where each register is live and where it is dead.     ** find_basic_blocks **     find_basic_blocks divides the current function's rtl    into basic blocks.  It records the beginnings and ends of the    basic blocks in the vectors basic_block_head and basic_block_end,    and the number of blocks in n_basic_blocks.     find_basic_blocks also finds any unreachable loops    and deletes them.     ** life_analysis **     life_analysis is called immediately after find_basic_blocks.    It uses the basic block information to determine where each    hard or pseudo register is live.     ** live-register info **     The information about where each register is live is in two parts:    the REG_NOTES of insns, and the vector basic_block_live_at_start.     basic_block_live_at_start has an element for each basic block,    and the element is a bit-vector with a bit for each hard or pseudo    register.  The bit is 1 if the register is live at the beginning    of the basic block.     Two types of elements can be added to an insn's REG_NOTES.      A REG_DEAD note is added to an insn's REG_NOTES for any register    that meets both of two conditions:  The value in the register is not    needed in subsequent insns and the insn does not replace the value in    the register (in the case of multi-word hard registers, the value in    each register must be replaced by the insn to avoid a REG_DEAD note).     In the vast majority of cases, an object in a REG_DEAD note will be    used somewhere in the insn.  The (rare) exception to this is if an    insn uses a multi-word hard register and only some of the registers are    needed in subsequent insns.  In that case, REG_DEAD notes will be    provided for those hard registers that are not subsequently needed.    Partial REG_DEAD notes of this type do not occur when an insn sets    only some of the hard registers used in such a multi-word operand;    omitting REG_DEAD notes for objects stored in an insn is optional and    the desire to do so does not justify the complexity of the partial    REG_DEAD notes.     REG_UNUSED notes are added for each register that is set by the insn    but is unused subsequently (if every register set by the insn is unused    and the insn does not reference memory or have some other side-effect,    the insn is deleted instead).  If only part of a multi-word hard    register is used in a subsequent insn, REG_UNUSED notes are made for    the parts that will not be used.     To determine which registers are live after any insn, one can    start from the beginning of the basic block and scan insns, noting    which registers are set by each insn and which die there.     ** Other actions of life_analysis **     life_analysis sets up the LOG_LINKS fields of insns because the    information needed to do so is readily available.     life_analysis deletes insns whose only effect is to store a value    that is never used.     life_analysis notices cases where a reference to a register as    a memory address can be combined with a preceding or following    incrementation or decrementation of the register.  The separate    instruction to increment or decrement is deleted and the address    is changed to a POST_INC or similar rtx.     Each time an incrementing or decrementing address is created,    a REG_INC element is added to the insn's REG_NOTES list.     life_analysis fills in certain vectors containing information about    register usage: reg_n_refs, reg_n_deaths, reg_n_sets, reg_live_length,    reg_n_calls_crosses and reg_basic_block.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* The contents of the current function definition are allocated    in this obstack, and all are freed at the end of the function.    For top-level functions, this is temporary_obstack.    Separate obstacks are made for nested functions.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|function_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of labels that must never be deleted.  */
end_comment

begin_decl_stmt
specifier|extern
name|rtx
name|forced_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get the basic block number of an insn.    This info should not be expected to remain available    after the end of life_analysis.  */
end_comment

begin_comment
comment|/* This is the limit of the allocated space in the following two arrays.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_uid_for_flow
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BLOCK_NUM
parameter_list|(
name|INSN
parameter_list|)
value|uid_block_number[INSN_UID (INSN)]
end_define

begin_comment
comment|/* This is where the BLOCK_NUM values are really stored.    This is set up by find_basic_blocks and used there and in life_analysis,    and then freed.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|uid_block_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INSN_VOLATILE (insn) is 1 if the insn refers to anything volatile.  */
end_comment

begin_define
define|#
directive|define
name|INSN_VOLATILE
parameter_list|(
name|INSN
parameter_list|)
value|uid_volatile[INSN_UID (INSN)]
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|uid_volatile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of basic blocks in the current function.  */
end_comment

begin_decl_stmt
name|int
name|n_basic_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum register number used in this function, plus one.  */
end_comment

begin_decl_stmt
name|int
name|max_regno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of SCRATCH rtx's used in any basic block of this    function.  */
end_comment

begin_decl_stmt
name|int
name|max_scratch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of SCRATCH rtx's in the current block.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_scratch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indexed by n, giving various register information */
end_comment

begin_decl_stmt
name|varray_type
name|reg_n_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of the reg_n_info table.  */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|reg_n_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is the next insn that uses (hard or pseudo) register number N    within the current basic block; or zero, if there is no such insn.    This is valid only during the final backward scan in propagate_block.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
modifier|*
name|reg_next_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of a regset for the current function,    in (1) bytes and (2) elements.  */
end_comment

begin_decl_stmt
name|int
name|regset_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regset_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is first insn in basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|basic_block_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is last insn in basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
name|rtx
modifier|*
name|basic_block_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N indicates whether basic block N can be reached through a    computed jump.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|basic_block_computed_jump_target
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is a regset describing the registers live    at the start of basic block N.    This info lasts until we finish compiling the function.  */
end_comment

begin_decl_stmt
name|regset
modifier|*
name|basic_block_live_at_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regset of regs live when calls to `setjmp'-like functions happen.  */
end_comment

begin_decl_stmt
name|regset
name|regs_live_at_setjmp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List made of EXPR_LIST rtx's which gives pairs of pseudo registers    that have to go in the same hard reg.    The first two regs in the list are a pair, and the next two    are another pair, etc.  */
end_comment

begin_decl_stmt
name|rtx
name|regs_may_share
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is nonzero if control can drop into basic block N    from the preceding basic block.  Freed after life_analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|basic_block_drops_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N is depth within loops of the last insn in basic block number N.    Freed after life_analysis.  */
end_comment

begin_decl_stmt
specifier|static
name|short
modifier|*
name|basic_block_loop_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Element N nonzero if basic block N can actually be reached.    Vector exists only during find_basic_blocks.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|block_live_static
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Depth within loops of basic block being scanned for lifetime analysis,    plus one.  This is the weight attached to references to registers.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loop_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During propagate_block, this is non-zero if the value of CC0 is live.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cc0_live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During propagate_block, this contains the last MEM stored into.  It    is used to eliminate consecutive stores to the same location.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|last_mem_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set of registers that may be eliminable.  These are handled specially    in updating regs_ever_live.  */
end_comment

begin_decl_stmt
specifier|static
name|HARD_REG_SET
name|elim_reg_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_decl_stmt
specifier|static
name|void
name|find_basic_blocks_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_label_ref
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|life_analysis_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|propagate_block
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|int
operator|,
name|regset
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|flow_delete_insn
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|insn_dead_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|regset
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|libcall_dead_p
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_set_regs
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|regset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mark_set_1
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|,
name|regset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|find_auto_inc
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|rtx
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_pre_increment_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|try_pre_increment
name|PROTO
argument_list|(
operator|(
name|rtx
operator|,
name|rtx
operator|,
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|mark_used_regs
name|PROTO
argument_list|(
operator|(
name|regset
operator|,
name|regset
operator|,
name|rtx
operator|,
name|int
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dump_flow_info
name|PROTO
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_pred_succ
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int_list_ptr
operator|*
operator|,
name|int_list_ptr
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int_list_ptr
name|alloc_int_list_node
name|PROTO
argument_list|(
operator|(
name|int_list_block
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int_list_ptr
name|add_int_list_node
name|PROTO
argument_list|(
operator|(
name|int_list_block
operator|*
operator|*
operator|,
name|int_list
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_regset_vector
name|PROTO
argument_list|(
operator|(
name|regset
operator|*
operator|,
name|int
operator|,
expr|struct
name|obstack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_reg_sets_1
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_reg_sets
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|count_reg_references
name|PROTO
argument_list|(
operator|(
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Find basic blocks of the current function.    F is the first insn of the function and NREGS the number of register numbers    in use.    LIVE_REACHABLE_P is non-zero if the caller needs all live blocks to    be reachable.  This turns on a kludge that causes the control flow    information to be inaccurate and not suitable for passes like GCSE.  */
end_comment

begin_function
name|void
name|find_basic_blocks
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|file
parameter_list|,
name|live_reachable_p
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|live_reachable_p
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|nonlocal_label_list
init|=
name|nonlocal_label_rtx_list
argument_list|()
decl_stmt|;
name|int
name|in_libcall_block
init|=
literal|0
decl_stmt|;
comment|/* Count the basic blocks.  Also find maximum insn uid value used.  */
block|{
specifier|register
name|RTX_CODE
name|prev_code
init|=
name|JUMP_INSN
decl_stmt|;
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
name|int
name|eh_region
init|=
literal|0
decl_stmt|;
name|max_uid_for_flow
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
operator|,
name|i
operator|=
literal|0
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Track when we are inside in LIBCALL block.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|1
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>
name|max_uid_for_flow
condition|)
name|max_uid_for_flow
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|prev_code
operator|==
name|JUMP_INSN
operator|||
operator|(
name|prev_code
operator|==
name|CALL_INSN
operator|&&
operator|(
name|nonlocal_label_list
operator|!=
literal|0
operator|||
name|eh_region
operator|)
operator|&&
operator|!
name|in_libcall_block
operator|)
operator|||
name|prev_code
operator|==
name|BARRIER
operator|)
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CALL_INSN
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|code
operator|=
name|INSN
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
operator|++
name|eh_region
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
operator|--
name|eh_region
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|n_basic_blocks
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
comment|/* Leave space for insns life_analysis makes in some cases for auto-inc.      These cases are rare, so we don't need too much space.  */
name|max_uid_for_flow
operator|+=
name|max_uid_for_flow
operator|/
literal|10
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate some tables that last till end of compiling this function      and some needed only in find_basic_blocks and life_analysis.  */
name|basic_block_head
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|basic_block_end
operator|=
operator|(
name|rtx
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|basic_block_drops_in
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|basic_block_computed_jump_target
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|basic_block_loop_depth
operator|=
operator|(
name|short
operator|*
operator|)
name|xmalloc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|uid_block_number
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|max_uid_for_flow
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|uid_volatile
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_uid_for_flow
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|uid_volatile
argument_list|,
name|max_uid_for_flow
operator|+
literal|1
argument_list|)
expr_stmt|;
name|find_basic_blocks_1
argument_list|(
name|f
argument_list|,
name|nonlocal_label_list
argument_list|,
name|live_reachable_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find all basic blocks of the function whose first insn is F.    Store the correct data in the tables that describe the basic blocks,    set up the chains of references for each CODE_LABEL, and    delete any entire basic blocks that cannot be reached.     NONLOCAL_LABEL_LIST is a list of non-local labels in the function.    Blocks that are otherwise unreachable may be reachable with a non-local    goto.    LIVE_REACHABLE_P is non-zero if the caller needs all live blocks to    be reachable.  This turns on a kludge that causes the control flow    information to be inaccurate and not suitable for passes like GCSE.  */
end_comment

begin_function
specifier|static
name|void
name|find_basic_blocks_1
parameter_list|(
name|f
parameter_list|,
name|nonlocal_label_list
parameter_list|,
name|live_reachable_p
parameter_list|)
name|rtx
name|f
decl_stmt|,
name|nonlocal_label_list
decl_stmt|;
name|int
name|live_reachable_p
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|block_live
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|block_marked
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
decl_stmt|;
comment|/* An array of CODE_LABELs, indexed by UID for the start of the active      EH handler for each insn in F.  */
name|int
modifier|*
name|active_eh_region
decl_stmt|;
name|int
modifier|*
name|nested_eh_region
decl_stmt|;
comment|/* List of label_refs to all labels whose addresses are taken      and used as data.  */
name|rtx
name|label_value_list
decl_stmt|;
name|rtx
name|x
decl_stmt|,
name|note
decl_stmt|,
name|eh_note
decl_stmt|;
name|enum
name|rtx_code
name|prev_code
decl_stmt|,
name|code
decl_stmt|;
name|int
name|depth
decl_stmt|,
name|pass
decl_stmt|;
name|int
name|in_libcall_block
init|=
literal|0
decl_stmt|;
name|int
name|deleted_handler
init|=
literal|0
decl_stmt|;
name|pass
operator|=
literal|1
expr_stmt|;
name|active_eh_region
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_uid_for_flow
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|nested_eh_region
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_label_num
argument_list|()
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|restart
label|:
name|label_value_list
operator|=
literal|0
expr_stmt|;
name|block_live_static
operator|=
name|block_live
expr_stmt|;
name|bzero
argument_list|(
name|block_live
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|block_marked
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|basic_block_computed_jump_target
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|active_eh_region
argument_list|,
operator|(
name|max_uid_for_flow
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nested_eh_region
argument_list|,
operator|(
name|max_label_num
argument_list|()
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|current_function_has_computed_jump
operator|=
literal|0
expr_stmt|;
comment|/* Initialize with just block 0 reachable and no blocks marked.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
name|block_live
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Initialize the ref chain of each label to 0.  Record where all the      blocks start and end and their depth in loops.  For each insn, record      the block it is in.   Also mark as reachable any blocks headed by labels      that must not be deleted.  */
for|for
control|(
name|eh_note
operator|=
name|NULL_RTX
operator|,
name|insn
operator|=
name|f
operator|,
name|i
operator|=
operator|-
literal|1
operator|,
name|prev_code
operator|=
name|JUMP_INSN
operator|,
name|depth
operator|=
literal|1
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Track when we are inside in LIBCALL block.  */
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_LIBCALL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|1
expr_stmt|;
name|code
operator|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|depth
operator|--
expr_stmt|;
block|}
comment|/* A basic block starts at label, or after something that can jump.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
operator|||
operator|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
operator|&&
operator|(
name|prev_code
operator|==
name|JUMP_INSN
operator|||
operator|(
name|prev_code
operator|==
name|CALL_INSN
operator|&&
operator|(
name|nonlocal_label_list
operator|!=
literal|0
operator|||
name|eh_note
operator|)
operator|&&
operator|!
name|in_libcall_block
operator|)
operator|||
name|prev_code
operator|==
name|BARRIER
operator|)
operator|)
condition|)
block|{
name|basic_block_head
index|[
operator|++
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|basic_block_end
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|basic_block_loop_depth
index|[
name|i
index|]
operator|=
name|depth
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CODE_LABEL
condition|)
block|{
name|LABEL_REFS
argument_list|(
name|insn
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* Any label that cannot be deleted 		   is considered to start a reachable block.  */
if|if
condition|(
name|LABEL_PRESERVE_P
argument_list|(
name|insn
argument_list|)
condition|)
name|block_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|basic_block_end
index|[
name|i
index|]
operator|=
name|insn
expr_stmt|;
name|basic_block_loop_depth
index|[
name|i
index|]
operator|=
name|depth
expr_stmt|;
block|}
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|code
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* Make a list of all labels referred to other than by jumps.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
condition|)
name|label_value_list
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|,
name|label_value_list
argument_list|)
expr_stmt|;
block|}
comment|/* Keep a lifo list of the currently active exception notes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
condition|)
block|{
if|if
condition|(
name|eh_note
condition|)
name|nested_eh_region
index|[
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|NOTE_BLOCK_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|eh_note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|nested_eh_region
index|[
name|NOTE_BLOCK_NUMBER
argument_list|(
name|insn
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|eh_note
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|eh_note
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
condition|)
name|eh_note
operator|=
name|XEXP
argument_list|(
name|eh_note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we encounter a CALL_INSN, note which exception handler it 	 might pass control to.  	 If doing asynchronous exceptions, record the active EH handler 	 for every insn, since most insns can throw.  */
elseif|else
if|if
condition|(
name|eh_note
operator|&&
operator|(
name|asynchronous_exceptions
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|in_libcall_block
operator|)
operator|)
condition|)
name|active_eh_region
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|NOTE_BLOCK_NUMBER
argument_list|(
name|XEXP
argument_list|(
name|eh_note
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|NOTE
condition|)
name|prev_code
operator|=
name|code
expr_stmt|;
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
operator|&&
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|in_libcall_block
operator|=
literal|0
expr_stmt|;
block|}
comment|/* During the second pass, `n_basic_blocks' is only an upper bound.      Only perform the sanity check for the first pass, and on the second      pass ensure `n_basic_blocks' is set to the correct value.  */
if|if
condition|(
name|pass
operator|==
literal|1
operator|&&
name|i
operator|+
literal|1
operator|!=
name|n_basic_blocks
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n_basic_blocks
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* Record which basic blocks control can drop in to.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
init|;
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
name|basic_block_drops_in
index|[
name|i
index|]
operator|=
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
expr_stmt|;
block|}
comment|/* Now find which basic blocks can actually be reached      and put all jump insns' LABEL_REFS onto the ref-chains      of their target labels.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
block|{
name|int
name|something_marked
init|=
literal|1
decl_stmt|;
name|int
name|deleted
decl_stmt|;
comment|/* Pass over all blocks, marking each block that is reachable 	 and has not yet been marked. 	 Keep doing this until, in one pass, no blocks have been marked. 	 Then blocks_live and blocks_marked are identical and correct. 	 In addition, all jumps actually reachable have been marked.  */
while|while
condition|(
name|something_marked
condition|)
block|{
name|something_marked
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|block_live
index|[
name|i
index|]
operator|&&
operator|!
name|block_marked
index|[
name|i
index|]
condition|)
block|{
name|block_marked
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|something_marked
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|n_basic_blocks
operator|&&
name|basic_block_drops_in
index|[
name|i
operator|+
literal|1
index|]
condition|)
name|block_live
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|insn
operator|=
name|basic_block_end
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
name|mark_label_ref
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we have any forced labels, mark them as potentially 		   reachable from this block.  */
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
operator|!
name|LABEL_REF_NONLOCAL_P
argument_list|(
name|x
argument_list|)
condition|)
name|mark_label_ref
argument_list|(
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now scan the insns for this block, we may need to make 		   edges for some of them to various non-obvious locations 		   (exception handlers, nonlocal labels, etc).  */
for|for
control|(
name|insn
operator|=
name|basic_block_head
index|[
name|i
index|]
init|;
name|insn
operator|!=
name|NEXT_INSN
argument_list|(
name|basic_block_end
index|[
name|i
index|]
argument_list|)
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* References to labels in non-jumping insns have 			   REG_LABEL notes attached to them.  			   This can happen for computed gotos; we don't care 			   about them here since the values are also on the 			   label_value_list and will be marked live if we find 			   a live computed goto.  			   This can also happen when we take the address of 			   a label to pass as an argument to __throw.  Note 			   throw only uses the value to determine what handler 			   should be called -- ie the label is not used as 			   a jump target, it just marks regions in the code.  			   In theory we should be able to ignore the REG_LABEL 			   notes, but we have to make sure that the label and 			   associated insns aren't marked dead, so we make 			   the block in question live and create an edge from 			   this insn to the label.  This is not strictly 			   correct, but it is close enough for now.  */
for|for
control|(
name|note
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|note
argument_list|)
operator|==
name|REG_LABEL
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|block_live
index|[
name|BLOCK_NUM
argument_list|(
name|x
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
name|mark_label_ref
argument_list|(
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|x
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a computed jump, then mark it as 			   reaching everything on the label_value_list 			   and forced_labels list.  */
if|if
condition|(
name|computed_jump_p
argument_list|(
name|insn
argument_list|)
condition|)
block|{
name|current_function_has_computed_jump
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
name|label_value_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|int
name|b
init|=
name|BLOCK_NUM
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block_computed_jump_target
index|[
name|b
index|]
operator|=
literal|1
expr_stmt|;
name|mark_label_ref
argument_list|(
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|x
operator|=
name|forced_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|int
name|b
init|=
name|BLOCK_NUM
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
name|basic_block_computed_jump_target
index|[
name|b
index|]
operator|=
literal|1
expr_stmt|;
name|mark_label_ref
argument_list|(
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a CALL_INSN, then mark it as reaching 			   the active EH handler for this CALL_INSN.  If 			   we're handling asynchronous exceptions mark every 			   insn as reaching the active EH handler.  			   Also mark the CALL_INSN as reaching any nonlocal 			   goto sites.  */
elseif|else
if|if
condition|(
name|asynchronous_exceptions
operator|||
operator|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|active_eh_region
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
condition|)
block|{
name|int
name|region
decl_stmt|;
name|handler_info
modifier|*
name|ptr
decl_stmt|;
name|region
operator|=
name|active_eh_region
index|[
name|INSN_UID
argument_list|(
name|insn
argument_list|)
index|]
expr_stmt|;
for|for
control|(
init|;
name|region
condition|;
name|region
operator|=
name|nested_eh_region
index|[
name|region
index|]
control|)
block|{
name|ptr
operator|=
name|get_first_handler
argument_list|(
name|region
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
name|mark_label_ref
argument_list|(
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|ptr
operator|->
name|handler_label
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|asynchronous_exceptions
condition|)
block|{
for|for
control|(
name|x
operator|=
name|nonlocal_label_list
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
name|mark_label_ref
argument_list|(
name|gen_rtx_LABEL_REF
argument_list|(
name|VOIDmode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* ??? This could be made smarter: 			       in some cases it's possible to tell that 			       certain calls will not do a nonlocal goto.  			       For example, if the nested functions that 			       do the nonlocal gotos do not have their 			       addresses taken, then only calls to those 			       functions or to other nested functions that 			       use them could possibly do nonlocal gotos.  */
block|}
block|}
block|}
block|}
block|}
comment|/* This should never happen.  If it does that means we've computed an 	 incorrect flow graph, which can lead to aborts/crashes later in the 	 compiler or incorrect code generation.  	 We used to try and continue here, but that's just asking for trouble 	 later during the compile or at runtime.  It's easier to debug the 	 problem here than later!  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|block_live
index|[
name|i
index|]
operator|&&
operator|!
name|basic_block_drops_in
index|[
name|i
index|]
operator|&&
name|GET_CODE
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
operator|==
name|CODE_LABEL
operator|&&
name|LABEL_REFS
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
operator|==
name|basic_block_head
index|[
name|i
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Now delete the code for any basic blocks that can't be reached. 	 They can occur because jump_optimize does not recognize 	 unreachable loops as unreachable.  */
name|deleted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|block_live
index|[
name|i
index|]
condition|)
block|{
name|deleted
operator|++
expr_stmt|;
comment|/* Delete the insns in a (non-live) block.  We physically delete 	       every non-note insn except the start and end (so 	       basic_block_head/end needn't be updated), we turn the latter 	       into NOTE_INSN_DELETED notes. 	       We use to "delete" the insns by turning them into notes, but 	       we may be deleting lots of insns that subsequent passes would 	       otherwise have to process.  Secondly, lots of deleted blocks in 	       a row can really slow down propagate_block since it will 	       otherwise process insn-turned-notes multiple times when it 	       looks for loop begin/end notes.  */
if|if
condition|(
name|basic_block_head
index|[
name|i
index|]
operator|!=
name|basic_block_end
index|[
name|i
index|]
condition|)
block|{
comment|/* It would be quicker to delete all of these with a single 		   unchaining, rather than one at a time, but we need to keep 		   the NOTE's.  */
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|insn
operator|!=
name|basic_block_end
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
name|insn
operator|=
name|flow_delete_insn
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
name|insn
operator|=
name|basic_block_head
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
comment|/* Turn the head into a deleted insn note.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the head of this block is a CODE_LABEL, then it might 		   be the label for an exception handler which can't be 		   reached.  		   We need to remove the label from the exception_handler_label 		   list and remove the associated NOTE_EH_REGION_BEG and 		   NOTE_EH_REGION_END notes.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CODE_LABEL
condition|)
block|{
name|rtx
name|x
decl_stmt|,
modifier|*
name|prev
init|=
operator|&
name|exception_handler_labels
decl_stmt|;
for|for
control|(
name|x
operator|=
name|exception_handler_labels
init|;
name|x
condition|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|insn
condition|)
block|{
comment|/* Found a match, splice this label out of the 			       EH label list.  */
operator|*
name|prev
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|=
name|NULL_RTX
expr_stmt|;
comment|/* Remove the handler from all regions */
name|remove_handler
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|deleted_handler
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|prev
operator|=
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|insn
operator|=
name|basic_block_end
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|NOTE
condition|)
block|{
comment|/* Turn the tail into a deleted insn note.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* BARRIERs are between basic blocks, not part of one. 	       Delete a BARRIER if the preceding jump is deleted. 	       We cannot alter a BARRIER into a NOTE 	       because it is too short; but we can really delete 	       it because it is not part of a basic block.  */
if|if
condition|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|BARRIER
condition|)
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Each time we delete some basic blocks, 	       see if there is a jump around them that is 	       being turned into a no-op.  If so, delete it.  */
if|if
condition|(
name|block_live
index|[
name|i
operator|-
literal|1
index|]
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n_basic_blocks
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|block_live
index|[
name|j
index|]
condition|)
block|{
name|rtx
name|label
decl_stmt|;
name|insn
operator|=
name|basic_block_end
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
comment|/* An unconditional jump is the only possibility 			     we must check for, since a conditional one 			     would make these blocks live.  */
operator|&&
name|simplejump_p
argument_list|(
name|insn
argument_list|)
operator|&&
operator|(
name|label
operator|=
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|,
literal|1
operator|)
operator|&&
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|!=
literal|0
operator|&&
name|BLOCK_NUM
argument_list|(
name|label
argument_list|)
operator|==
name|j
condition|)
block|{
name|int
name|k
decl_stmt|;
comment|/* The deleted blocks still show up in the cfg, 			     so we must set basic_block_drops_in for blocks 			     I to J inclusive to keep the cfg accurate.  */
for|for
control|(
name|k
operator|=
name|i
init|;
name|k
operator|<=
name|j
condition|;
name|k
operator|++
control|)
name|basic_block_drops_in
index|[
name|k
index|]
operator|=
literal|1
expr_stmt|;
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|BARRIER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|delete_insn
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/* If we deleted an exception handler, we may have EH region          begin/end blocks to remove as well. */
if|if
condition|(
name|deleted_handler
condition|)
for|for
control|(
name|insn
operator|=
name|get_insns
argument_list|()
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
if|if
condition|(
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_BEG
operator|)
operator|||
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_EH_REGION_END
operator|)
condition|)
block|{
name|int
name|num
init|=
name|CODE_LABEL_NUMBER
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* A NULL handler indicates a region is no longer needed */
if|if
condition|(
name|get_first_handler
argument_list|(
name|num
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* There are pathological cases where one function calling hundreds of 	 nested inline functions can generate lots and lots of unreachable 	 blocks that jump can't delete.  Since we don't use sparse matrices 	 a lot of memory will be needed to compile such functions. 	 Implementing sparse matrices is a fair bit of work and it is not 	 clear that they win more than they lose (we don't want to 	 unnecessarily slow down compilation of normal code).  By making 	 another pass for the pathological case, we can greatly speed up 	 their compilation without hurting normal code.  This works because 	 all the insns in the unreachable blocks have either been deleted or 	 turned into notes. 	 Note that we're talking about reducing memory usage by 10's of 	 megabytes and reducing compilation time by several minutes.  */
comment|/* ??? The choice of when to make another pass is a bit arbitrary, 	 and was derived from empirical data.  */
if|if
condition|(
name|pass
operator|==
literal|1
operator|&&
name|deleted
operator|>
literal|200
condition|)
block|{
name|pass
operator|++
expr_stmt|;
name|n_basic_blocks
operator|-=
name|deleted
expr_stmt|;
comment|/* `n_basic_blocks' may not be correct at this point: two previously 	     separate blocks may now be merged.  That's ok though as we 	     recalculate it during the second pass.  It certainly can't be 	     any larger than the current value.  */
goto|goto
name|restart
goto|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Record INSN's block number as BB.  */
end_comment

begin_function
name|void
name|set_block_num
parameter_list|(
name|insn
parameter_list|,
name|bb
parameter_list|)
name|rtx
name|insn
decl_stmt|;
name|int
name|bb
decl_stmt|;
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|>=
name|max_uid_for_flow
condition|)
block|{
comment|/* Add one-eighth the size so we don't keep calling xrealloc.  */
name|max_uid_for_flow
operator|=
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|+
operator|(
name|INSN_UID
argument_list|(
name|insn
argument_list|)
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|uid_block_number
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|uid_block_number
argument_list|,
operator|(
name|max_uid_for_flow
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
operator|=
name|bb
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of find_basic_blocks.  */
end_comment

begin_comment
comment|/* Check expression X for label references;    if one is found, add INSN to the label's chain of references.     CHECKDUP means check for and avoid creating duplicate references    from the same insn.  Such duplicates do no serious harm but    can slow life analysis.  CHECKDUP is set only when duplicates    are likely.  */
end_comment

begin_function
specifier|static
name|void
name|mark_label_ref
parameter_list|(
name|x
parameter_list|,
name|insn
parameter_list|,
name|checkdup
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|insn
decl_stmt|;
name|int
name|checkdup
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* We can be called with NULL when scanning label_value_list.  */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return;
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|LABEL_REF
condition|)
block|{
specifier|register
name|rtx
name|label
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|y
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|label
argument_list|)
operator|!=
name|CODE_LABEL
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If the label was never emitted, this insn is junk, 	 but avoid a crash trying to refer to BLOCK_NUM (label). 	 This can happen as a result of a syntax error 	 and a diagnostic has already been printed.  */
if|if
condition|(
name|INSN_UID
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|CONTAINING_INSN
argument_list|(
name|x
argument_list|)
operator|=
name|insn
expr_stmt|;
comment|/* if CHECKDUP is set, check for duplicate ref from same insn 	 and don't insert.  */
if|if
condition|(
name|checkdup
condition|)
for|for
control|(
name|y
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
init|;
name|y
operator|!=
name|label
condition|;
name|y
operator|=
name|LABEL_NEXTREF
argument_list|(
name|y
argument_list|)
control|)
if|if
condition|(
name|CONTAINING_INSN
argument_list|(
name|y
argument_list|)
operator|==
name|insn
condition|)
return|return;
name|LABEL_NEXTREF
argument_list|(
name|x
argument_list|)
operator|=
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|LABEL_REFS
argument_list|(
name|label
argument_list|)
operator|=
name|x
expr_stmt|;
name|block_live_static
index|[
name|BLOCK_NUM
argument_list|(
name|label
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|fmt
operator|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
name|mark_label_ref
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_label_ref
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|insn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Delete INSN by patching it out.    Return the next insn.  */
end_comment

begin_function
specifier|static
name|rtx
name|flow_delete_insn
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* ??? For the moment we assume we don't have to watch for NULLs here      since the start/end of basic blocks aren't deleted like this.  */
name|NEXT_INSN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|PREV_INSN
argument_list|(
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
return|return
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform data flow analysis.    F is the first insn of the function and NREGS the number of register numbers    in use.  */
end_comment

begin_function
name|void
name|life_analysis
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|,
name|file
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
specifier|register
name|size_t
name|i
decl_stmt|;
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|}
name|eliminables
index|[]
init|=
name|ELIMINABLE_REGS
struct|;
endif|#
directive|endif
comment|/* Record which registers will be eliminated.  We use this in      mark_used_regs.  */
name|CLEAR_HARD_REG_SET
argument_list|(
name|elim_reg_set
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ELIMINABLE_REGS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|eliminables
operator|/
sizeof|sizeof
name|eliminables
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
name|SET_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|eliminables
index|[
name|i
index|]
operator|.
name|from
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|life_analysis_1
argument_list|(
name|f
argument_list|,
name|nregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|dump_flow_info
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free_basic_block_vars
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the variables allocated by find_basic_blocks.     KEEP_HEAD_END_P is non-zero if basic_block_head and basic_block_end    are not to be freed.  */
end_comment

begin_function
name|void
name|free_basic_block_vars
parameter_list|(
name|keep_head_end_p
parameter_list|)
name|int
name|keep_head_end_p
decl_stmt|;
block|{
if|if
condition|(
name|basic_block_drops_in
condition|)
block|{
name|free
argument_list|(
name|basic_block_drops_in
argument_list|)
expr_stmt|;
comment|/* Tell dump_flow_info this isn't available anymore.  */
name|basic_block_drops_in
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|basic_block_loop_depth
condition|)
block|{
name|free
argument_list|(
name|basic_block_loop_depth
argument_list|)
expr_stmt|;
name|basic_block_loop_depth
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|uid_block_number
condition|)
block|{
name|free
argument_list|(
name|uid_block_number
argument_list|)
expr_stmt|;
name|uid_block_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|uid_volatile
condition|)
block|{
name|free
argument_list|(
name|uid_volatile
argument_list|)
expr_stmt|;
name|uid_volatile
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|keep_head_end_p
operator|&&
name|basic_block_head
condition|)
block|{
name|free
argument_list|(
name|basic_block_head
argument_list|)
expr_stmt|;
name|basic_block_head
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|basic_block_end
argument_list|)
expr_stmt|;
name|basic_block_end
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine which registers are live at the start of each    basic block of the function whose first insn is F.    NREGS is the number of registers used in F.    We allocate the vector basic_block_live_at_start    and the regsets that it points to, and fill them with the data.    regset_size and regset_bytes are also set here.  */
end_comment

begin_function
specifier|static
name|void
name|life_analysis_1
parameter_list|(
name|f
parameter_list|,
name|nregs
parameter_list|)
name|rtx
name|f
decl_stmt|;
name|int
name|nregs
decl_stmt|;
block|{
name|int
name|first_pass
decl_stmt|;
name|int
name|changed
decl_stmt|;
comment|/* For each basic block, a bitmask of regs      live on exit from the block.  */
name|regset
modifier|*
name|basic_block_live_at_end
decl_stmt|;
comment|/* For each basic block, a bitmask of regs      live on entry to a successor-block of this block.      If this does not match basic_block_live_at_end,      that must be updated, and the block must be rescanned.  */
name|regset
modifier|*
name|basic_block_new_live_at_end
decl_stmt|;
comment|/* For each basic block, a bitmask of regs      whose liveness at the end of the basic block      can make a difference in which regs are live on entry to the block.      These are the regs that are set within the basic block,      possibly excluding those that are used after they are set.  */
name|regset
modifier|*
name|basic_block_significant
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|struct
name|obstack
name|flow_obstack
decl_stmt|;
name|gcc_obstack_init
argument_list|(
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|max_regno
operator|=
name|nregs
expr_stmt|;
name|bzero
argument_list|(
name|regs_ever_live
argument_list|,
sizeof|sizeof
name|regs_ever_live
argument_list|)
expr_stmt|;
comment|/* Allocate and zero out many data structures      that will record the data from lifetime analysis.  */
name|allocate_for_life_analysis
argument_list|()
expr_stmt|;
name|reg_next_use
operator|=
operator|(
name|rtx
operator|*
operator|)
name|alloca
argument_list|(
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|reg_next_use
argument_list|,
name|nregs
operator|*
sizeof|sizeof
argument_list|(
name|rtx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up several regset-vectors used internally within this function.      Their meanings are documented above, with their declarations.  */
name|basic_block_live_at_end
operator|=
operator|(
name|regset
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't use alloca since that leads to a crash rather than an error message      if there isn't enough space.      Don't use oballoc since we may need to allocate other things during      this function on the temporary obstack.  */
name|init_regset_vector
argument_list|(
name|basic_block_live_at_end
argument_list|,
name|n_basic_blocks
argument_list|,
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|basic_block_new_live_at_end
operator|=
operator|(
name|regset
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|basic_block_new_live_at_end
argument_list|,
name|n_basic_blocks
argument_list|,
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
name|basic_block_significant
operator|=
operator|(
name|regset
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|basic_block_significant
argument_list|,
name|n_basic_blocks
argument_list|,
operator|&
name|flow_obstack
argument_list|)
expr_stmt|;
comment|/* Record which insns refer to any volatile memory      or for any reason can't be deleted just because they are dead stores.      Also, delete any insns that copy a register to itself.  */
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
name|enum
name|rtx_code
name|code1
init|=
name|GET_CODE
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|code1
operator|==
name|CALL_INSN
condition|)
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|code1
operator|==
name|INSN
operator|||
name|code1
operator|==
name|JUMP_INSN
condition|)
block|{
comment|/* Delete (in effect) any obvious no-op moves.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|)
comment|/* Insns carrying these notes are useful later on.  */
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Delete (in effect) any obvious no-op moves.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|SUBREG_WORD
argument_list|(
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SUBREG_WORD
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
comment|/* Insns carrying these notes are useful later on.  */
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
comment|/* If nothing but SETs of registers to themselves, 		 this insn can also be deleted.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|rtx
name|tem
init|=
name|XVECEXP
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|USE
operator|||
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|CLOBBER
condition|)
continue|continue;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|SET
operator|||
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
name|REG
operator|||
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
name|REGNO
argument_list|(
name|SET_SRC
argument_list|(
name|tem
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|XVECLEN
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
literal|0
argument_list|)
comment|/* Insns carrying these notes are useful later on.  */
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_EQUAL
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|=
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
name|USE
condition|)
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|=
name|volatile_refs_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A SET that makes space on the stack cannot be dead. 	     (Such SETs occur only for allocating variable-size data, 	     so they will always have a PLUS or MINUS according to the 	     direction of stack growth.) 	     Even if this function never uses this stack pointer value, 	     signal handlers do!  */
elseif|else
if|if
condition|(
name|code1
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|MINUS
else|#
directive|else
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
endif|#
directive|endif
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
condition|)
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
operator|||
operator|(
operator|!
name|FRAME_POINTER_REQUIRED
operator|&&
operator|!
name|current_function_calls_alloca
operator|&&
name|flag_omit_frame_pointer
operator|)
condition|)
endif|#
directive|endif
block|{
comment|/* If exiting needs the right stack value, 	   consider the stack pointer live at the end of the function.  */
name|SET_REGNO_REG_SET
argument_list|(
name|basic_block_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|basic_block_new_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
block|}
comment|/* Mark the frame pointer is needed at the end of the function.  If      we end up eliminating it, it will be removed from the live list      of each basic block by reload.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|basic_block_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|basic_block_new_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|,
name|FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
comment|/* If they are different, also mark the hard frame pointer as live */
name|SET_REGNO_REG_SET
argument_list|(
name|basic_block_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|basic_block_new_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|,
name|HARD_FRAME_POINTER_REGNUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Mark all global registers and all registers used by the epilogue      as being live at the end of the function since they may be      referenced by our caller.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
ifdef|#
directive|ifdef
name|EPILOGUE_USES
operator|||
name|EPILOGUE_USES
argument_list|(
name|i
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|SET_REGNO_REG_SET
argument_list|(
name|basic_block_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|basic_block_new_live_at_end
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Propagate life info through the basic blocks      around the graph of basic blocks.       This is a relaxation process: each time a new register      is live at the end of the basic block, we must scan the block      to determine which registers are, as a consequence, live at the beginning      of that block.  These registers must then be marked live at the ends      of all the blocks that can transfer control to that block.      The process continues until it reaches a fixed point.  */
name|first_pass
operator|=
literal|1
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|consider
init|=
name|first_pass
decl_stmt|;
name|int
name|must_rescan
init|=
name|first_pass
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|first_pass
condition|)
block|{
comment|/* Set CONSIDER if this block needs thinking about at all 		 (that is, if the regs live now at the end of it 		 are not the same as were live at the end of it when 		 we last thought about it). 		 Set must_rescan if it needs to be thought about 		 instruction by instruction (that is, if any additional 		 reg that is live at the end now but was not live there before 		 is one of the significant regs of this basic block).  */
name|EXECUTE_IF_AND_COMPL_IN_REG_SET
argument_list|(
argument|basic_block_new_live_at_end[i]
argument_list|,
argument|basic_block_live_at_end[i]
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|{ 		   consider =
literal|1
argument|; 		   if (REGNO_REG_SET_P (basic_block_significant[i], j)) 		     { 		       must_rescan =
literal|1
argument|; 		       goto done; 		     } 		 }
argument_list|)
empty_stmt|;
name|done
label|:
if|if
condition|(
operator|!
name|consider
condition|)
continue|continue;
block|}
comment|/* The live_at_start of this block may be changing, 	     so another pass will be required after this one.  */
name|changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|must_rescan
condition|)
block|{
comment|/* No complete rescan needed; 		 just record those variables newly known live at end 		 as live at start as well.  */
name|IOR_AND_COMPL_REG_SET
argument_list|(
name|basic_block_live_at_start
index|[
name|i
index|]
argument_list|,
name|basic_block_new_live_at_end
index|[
name|i
index|]
argument_list|,
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IOR_AND_COMPL_REG_SET
argument_list|(
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|,
name|basic_block_new_live_at_end
index|[
name|i
index|]
argument_list|,
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update the basic_block_live_at_start 		 by propagation backwards through the block.  */
name|COPY_REG_SET
argument_list|(
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|,
name|basic_block_new_live_at_end
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|basic_block_live_at_start
index|[
name|i
index|]
argument_list|,
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|propagate_block
argument_list|(
name|basic_block_live_at_start
index|[
name|i
index|]
argument_list|,
name|basic_block_head
index|[
name|i
index|]
argument_list|,
name|basic_block_end
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|first_pass
condition|?
name|basic_block_significant
index|[
name|i
index|]
else|:
operator|(
name|regset
operator|)
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|{
specifier|register
name|rtx
name|jump
decl_stmt|,
name|head
decl_stmt|;
comment|/* Update the basic_block_new_live_at_end's of the block 	       that falls through into this one (if any).  */
name|head
operator|=
name|basic_block_head
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|basic_block_drops_in
index|[
name|i
index|]
condition|)
name|IOR_REG_SET
argument_list|(
name|basic_block_new_live_at_end
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|basic_block_live_at_start
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Update the basic_block_new_live_at_end's of 	       all the blocks that jump to this one.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
for|for
control|(
name|jump
operator|=
name|LABEL_REFS
argument_list|(
name|head
argument_list|)
init|;
name|jump
operator|!=
name|head
condition|;
name|jump
operator|=
name|LABEL_NEXTREF
argument_list|(
name|jump
argument_list|)
control|)
block|{
specifier|register
name|int
name|from_block
init|=
name|BLOCK_NUM
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
decl_stmt|;
name|IOR_REG_SET
argument_list|(
name|basic_block_new_live_at_end
index|[
name|from_block
index|]
argument_list|,
name|basic_block_live_at_start
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|first_pass
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The only pseudos that are live at the beginning of the function are      those that were not set anywhere in the function.  local-alloc doesn't      know how to handle these correctly, so mark them as not local to any      one basic block.  */
if|if
condition|(
name|n_basic_blocks
operator|>
literal|0
condition|)
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|basic_block_live_at_start[
literal|0
argument|]
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 				 REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; 			       }
argument_list|)
empty_stmt|;
comment|/* Now the life information is accurate.      Make one more pass over each basic block      to delete dead stores, create autoincrement addressing      and record how many times each register is used, is set, or dies.       To save time, we operate directly in basic_block_live_at_end[i],      thus destroying it (in fact, converting it into a copy of      basic_block_live_at_start[i]).  This is ok now because      basic_block_live_at_end[i] is no longer used past this point.  */
name|max_scratch
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
name|propagate_block
argument_list|(
name|basic_block_live_at_end
index|[
name|i
index|]
argument_list|,
name|basic_block_head
index|[
name|i
index|]
argument_list|,
name|basic_block_end
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
operator|(
name|regset
operator|)
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
comment|/* Something live during a setjmp should not be put in a register      on certain machines which restore regs from stack frames      rather than from the jmpbuf.      But we don't need to do this for the user's variables, since      ANSI says only volatile variables need this.  */
ifdef|#
directive|ifdef
name|LONGJMP_RESTORE_FROM_STACK
block|EXECUTE_IF_SET_IN_REG_SET (regs_live_at_setjmp, 			     FIRST_PSEUDO_REGISTER, i, 			     { 			       if (regno_reg_rtx[i] != 0&& ! REG_USERVAR_P (regno_reg_rtx[i])) 				 { 				   REG_LIVE_LENGTH (i) = -1; 				   REG_BASIC_BLOCK (i) = -1; 				 } 			     });
endif|#
directive|endif
endif|#
directive|endif
comment|/* We have a problem with any pseudoreg that      lives across the setjmp.  ANSI says that if a      user variable does not change in value      between the setjmp and the longjmp, then the longjmp preserves it.      This includes longjmp from a place where the pseudo appears dead.      (In principle, the value still exists if it is in scope.)      If the pseudo goes in a hard reg, some other value may occupy      that hard reg where this pseudo is dead, thus clobbering the pseudo.      Conclusion: such a pseudo must not go in a hard reg.  */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|regs_live_at_setjmp
argument_list|,
argument|FIRST_PSEUDO_REGISTER
argument_list|,
argument|i
argument_list|,
argument|{ 			       if (regno_reg_rtx[i] !=
literal|0
argument|) 				 { 				   REG_LIVE_LENGTH (i) = -
literal|1
argument|; 				   REG_BASIC_BLOCK (i) = -
literal|1
argument|; 				 } 			     }
argument_list|)
empty_stmt|;
name|free_regset_vector
argument_list|(
name|basic_block_live_at_end
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|free_regset_vector
argument_list|(
name|basic_block_new_live_at_end
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|free_regset_vector
argument_list|(
name|basic_block_significant
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|basic_block_live_at_end
operator|=
operator|(
name|regset
operator|*
operator|)
literal|0
expr_stmt|;
name|basic_block_new_live_at_end
operator|=
operator|(
name|regset
operator|*
operator|)
literal|0
expr_stmt|;
name|basic_block_significant
operator|=
operator|(
name|regset
operator|*
operator|)
literal|0
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|flow_obstack
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutines of life analysis.  */
end_comment

begin_comment
comment|/* Allocate the permanent data structures that represent the results    of life analysis.  Not static since used also for stupid life analysis.  */
end_comment

begin_function
name|void
name|allocate_for_life_analysis
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Recalculate the register space, in case it has grown.  Old style      vector oriented regsets would set regset_{size,bytes} here also.  */
name|allocate_reg_info
argument_list|(
name|max_regno
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Because both reg_scan and flow_analysis want to set up the REG_N_SETS      information, explicitly reset it here.  The allocation should have      already happened on the previous reg_scan pass.  Make sure in case      some more registers were allocated.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|basic_block_live_at_start
operator|=
operator|(
name|regset
operator|*
operator|)
name|oballoc
argument_list|(
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
expr_stmt|;
name|init_regset_vector
argument_list|(
name|basic_block_live_at_start
argument_list|,
name|n_basic_blocks
argument_list|,
name|function_obstack
argument_list|)
expr_stmt|;
name|regs_live_at_setjmp
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|function_obstack
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|regs_live_at_setjmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make each element of VECTOR point at a regset.  The vector has    NELTS elements, and space is allocated from the ALLOC_OBSTACK    obstack.  */
end_comment

begin_function
specifier|static
name|void
name|init_regset_vector
parameter_list|(
name|vector
parameter_list|,
name|nelts
parameter_list|,
name|alloc_obstack
parameter_list|)
name|regset
modifier|*
name|vector
decl_stmt|;
name|int
name|nelts
decl_stmt|;
name|struct
name|obstack
modifier|*
name|alloc_obstack
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|vector
index|[
name|i
index|]
operator|=
name|OBSTACK_ALLOC_REG_SET
argument_list|(
name|alloc_obstack
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|vector
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Release any additional space allocated for each element of VECTOR point    other than the regset header itself.  The vector has NELTS elements.  */
end_comment

begin_function
name|void
name|free_regset_vector
parameter_list|(
name|vector
parameter_list|,
name|nelts
parameter_list|)
name|regset
modifier|*
name|vector
decl_stmt|;
name|int
name|nelts
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelts
condition|;
name|i
operator|++
control|)
name|FREE_REG_SET
argument_list|(
name|vector
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the registers live at the beginning of a basic block    from those live at the end.     When called, OLD contains those live at the end.    On return, it contains those live at the beginning.    FIRST and LAST are the first and last insns of the basic block.     FINAL is nonzero if we are doing the final pass which is not    for computing the life info (since that has already been done)    but for acting on it.  On this pass, we delete dead stores,    set up the logical links and dead-variables lists of instructions,    and merge instructions for autoincrement and autodecrement addresses.     SIGNIFICANT is nonzero only the first time for each basic block.    If it is nonzero, it points to a regset in which we store    a 1 for each register that is set within the block.     BNUM is the number of the basic block.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_block
parameter_list|(
name|old
parameter_list|,
name|first
parameter_list|,
name|last
parameter_list|,
name|final
parameter_list|,
name|significant
parameter_list|,
name|bnum
parameter_list|)
specifier|register
name|regset
name|old
decl_stmt|;
name|rtx
name|first
decl_stmt|;
name|rtx
name|last
decl_stmt|;
name|int
name|final
decl_stmt|;
name|regset
name|significant
decl_stmt|;
name|int
name|bnum
decl_stmt|;
block|{
specifier|register
name|rtx
name|insn
decl_stmt|;
name|rtx
name|prev
decl_stmt|;
name|regset
name|live
decl_stmt|;
name|regset
name|dead
decl_stmt|;
comment|/* The following variables are used only if FINAL is nonzero.  */
comment|/* This vector gets one element for each reg that has been live      at any point in the basic block that has been scanned so far.      SOMETIMES_MAX says how many elements are in use so far.  */
specifier|register
name|int
modifier|*
name|regs_sometimes_live
decl_stmt|;
name|int
name|sometimes_max
init|=
literal|0
decl_stmt|;
comment|/* This regset has 1 for each reg that we have seen live so far.      It and REGS_SOMETIMES_LIVE are updated together.  */
name|regset
name|maxlive
decl_stmt|;
comment|/* The loop depth may change in the middle of a basic block.  Since we      scan from end to beginning, we start with the depth at the end of the      current basic block, and adjust as we pass ends and starts of loops.  */
name|loop_depth
operator|=
name|basic_block_loop_depth
index|[
name|bnum
index|]
expr_stmt|;
name|dead
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|live
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|cc0_live
operator|=
literal|0
expr_stmt|;
name|last_mem_set
operator|=
literal|0
expr_stmt|;
comment|/* Include any notes at the end of the block in the scan.      This is in case the block ends with a call to setjmp.  */
while|while
condition|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* Look for loop boundaries, we are going forward here.  */
name|last
operator|=
name|NEXT_INSN
argument_list|(
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|last
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|last
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|final
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|num_scratch
operator|=
literal|0
expr_stmt|;
name|maxlive
operator|=
name|ALLOCA_REG_SET
argument_list|()
expr_stmt|;
name|COPY_REG_SET
argument_list|(
name|maxlive
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|regs_sometimes_live
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process the regs live at the end of the block. 	 Enter them in MAXLIVE and REGS_SOMETIMES_LIVE. 	 Also mark them as not local to any one basic block. */
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|old
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 				   REG_BASIC_BLOCK (i) = REG_BLOCK_GLOBAL; 				   regs_sometimes_live[sometimes_max] = i; 				   sometimes_max++; 				 }
argument_list|)
empty_stmt|;
block|}
comment|/* Scan the block an insn at a time from end to beginning.  */
for|for
control|(
name|insn
operator|=
name|last
init|;
condition|;
name|insn
operator|=
name|prev
control|)
block|{
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* Look for loop boundaries, remembering that we are going 	     backwards.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|--
expr_stmt|;
comment|/* If we have LOOP_DEPTH == 0, there has been a bookkeeping error.  	     Abort now rather than setting register status incorrectly.  */
if|if
condition|(
name|loop_depth
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If this is a call to `setjmp' et al, 	     warn if any non-volatile datum is live.  */
if|if
condition|(
name|final
operator|&&
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_SETJMP
condition|)
name|IOR_REG_SET
argument_list|(
name|regs_live_at_setjmp
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
comment|/* Update the life-status of regs for this insn. 	 First DEAD gets which regs are set in this insn 	 then LIVE gets which regs are used in this insn. 	 Then the regs live before the insn 	 are those live after, with DEAD regs turned off, 	 and then LIVE regs turned on.  */
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|note
init|=
name|find_reg_note
argument_list|(
name|insn
argument_list|,
name|REG_RETVAL
argument_list|,
name|NULL_RTX
argument_list|)
decl_stmt|;
name|int
name|insn_is_dead
init|=
operator|(
name|insn_dead_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|,
literal|0
argument_list|)
comment|/* Don't delete something that refers to volatile storage!  */
operator|&&
operator|!
name|INSN_VOLATILE
argument_list|(
name|insn
argument_list|)
operator|)
decl_stmt|;
name|int
name|libcall_is_dead
init|=
operator|(
name|insn_is_dead
operator|&&
name|note
operator|!=
literal|0
operator|&&
name|libcall_dead_p
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|old
argument_list|,
name|note
argument_list|,
name|insn
argument_list|)
operator|)
decl_stmt|;
comment|/* If an instruction consists of just dead store(s) on final pass, 	     "delete" it by turning it into a NOTE of type NOTE_INSN_DELETED. 	     We could really delete it with delete_insn, but that 	     can cause trouble for first or last insn in a basic block.  */
if|if
condition|(
name|final
operator|&&
name|insn_is_dead
condition|)
block|{
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* CC0 is now known to be dead.  Either this insn used it, 		 in which case it doesn't anymore, or clobbered it, 		 so the next insn can't use it.  */
name|cc0_live
operator|=
literal|0
expr_stmt|;
comment|/* If this insn is copying the return value from a library call, 		 delete the entire library call.  */
if|if
condition|(
name|libcall_is_dead
condition|)
block|{
name|rtx
name|first
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|rtx
name|p
init|=
name|insn
decl_stmt|;
while|while
condition|(
name|INSN_DELETED_P
argument_list|(
name|first
argument_list|)
condition|)
name|first
operator|=
name|NEXT_INSN
argument_list|(
name|first
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|first
condition|)
block|{
name|p
operator|=
name|PREV_INSN
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PUT_CODE
argument_list|(
name|p
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|p
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|p
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
goto|goto
name|flushed
goto|;
block|}
name|CLEAR_REG_SET
argument_list|(
name|dead
argument_list|)
expr_stmt|;
name|CLEAR_REG_SET
argument_list|(
name|live
argument_list|)
expr_stmt|;
comment|/* See if this is an increment or decrement that can be 	     merged into a following memory address.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
block|{
specifier|register
name|rtx
name|x
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* Does this instruction increment or decrement a register?  */
if|if
condition|(
name|final
operator|&&
name|x
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MINUS
operator|)
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|SET_DEST
argument_list|(
name|x
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
comment|/* Ok, look for a following memory ref we can combine with. 		   If one is found, change the memory ref to a PRE_INC 		   or PRE_DEC, cancel this insn, and return 1. 		   Return 0 if nothing has been done.  */
operator|&&
name|try_pre_increment_1
argument_list|(
name|insn
argument_list|)
condition|)
goto|goto
name|flushed
goto|;
block|}
endif|#
directive|endif
comment|/* AUTO_INC_DEC */
comment|/* If this is not the final pass, and this insn is copying the 	     value of a library call and it's dead, don't scan the 	     insns that perform the library call, so that the call's 	     arguments are not marked live.  */
if|if
condition|(
name|libcall_is_dead
condition|)
block|{
comment|/* Mark the dest reg as `significant'.  */
name|mark_set_regs
argument_list|(
name|old
argument_list|,
name|dead
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
name|significant
argument_list|)
expr_stmt|;
name|insn
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_DEST
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|stack_pointer_rtx
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
comment|/* We have an insn to pop a constant amount off the stack. 	       (Such insns use PLUS regardless of the direction of the stack, 	       and any insn to adjust the stack by a constant is always a pop.) 	       These insns, if not dead stores, have no effect on life.  */
empty_stmt|;
else|else
block|{
comment|/* LIVE gets the regs used in INSN; 		 DEAD gets those set by it.  Dead insns don't make anything 		 live.  */
name|mark_set_regs
argument_list|(
name|old
argument_list|,
name|dead
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|final
condition|?
name|insn
else|:
name|NULL_RTX
argument_list|,
name|significant
argument_list|)
expr_stmt|;
comment|/* If an insn doesn't use CC0, it becomes dead since we  		 assume that every insn clobbers it.  So show it dead here; 		 mark_used_regs will set it live if it is referenced.  */
name|cc0_live
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|insn_is_dead
condition|)
name|mark_used_regs
argument_list|(
name|old
argument_list|,
name|live
argument_list|,
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Sometimes we may have inserted something before INSN (such as 		 a move) when we make an auto-inc.  So ensure we will scan 		 those insns.  */
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
name|prev
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|insn_is_dead
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|mark_used_regs
argument_list|(
name|old
argument_list|,
name|live
argument_list|,
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Each call clobbers all call-clobbered regs that are not 		     global or fixed.  Note that the function-value reg is a 		     call-clobbered reg, and mark_set_regs has already had 		     a chance to handle it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|call_used_regs
index|[
name|i
index|]
operator|&&
operator|!
name|global_regs
index|[
name|i
index|]
operator|&&
operator|!
name|fixed_regs
index|[
name|i
index|]
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|dead
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The stack ptr is used (honorarily) by a CALL insn.  */
name|SET_REGNO_REG_SET
argument_list|(
name|live
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
comment|/* Calls may also reference any of the global registers, 		     so they are made live.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
condition|)
name|mark_used_regs
argument_list|(
name|old
argument_list|,
name|live
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
comment|/* Calls also clobber memory.  */
name|last_mem_set
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Update OLD for the registers used or set.  */
name|AND_COMPL_REG_SET
argument_list|(
name|old
argument_list|,
name|dead
argument_list|)
expr_stmt|;
name|IOR_REG_SET
argument_list|(
name|old
argument_list|,
name|live
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
operator|&&
name|final
condition|)
block|{
comment|/* Any regs live at the time of a call instruction 		     must not go in a register clobbered by calls. 		     Find all regs now live and record this for them.  */
specifier|register
name|int
modifier|*
name|p
init|=
name|regs_sometimes_live
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|old
argument_list|,
operator|*
name|p
argument_list|)
condition|)
name|REG_N_CALLS_CROSSED
argument_list|(
operator|*
name|p
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
comment|/* On final pass, add any additional sometimes-live regs 	     into MAXLIVE and REGS_SOMETIMES_LIVE. 	     Also update counts of how many insns each reg is live at.  */
if|if
condition|(
name|final
condition|)
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|int
modifier|*
name|p
decl_stmt|;
name|EXECUTE_IF_AND_COMPL_IN_REG_SET
argument_list|(
argument|live
argument_list|,
argument|maxlive
argument_list|,
literal|0
argument_list|,
argument|regno
argument_list|,
argument|{ 		   regs_sometimes_live[sometimes_max++] = regno; 		   SET_REGNO_REG_SET (maxlive, regno); 		 }
argument_list|)
empty_stmt|;
name|p
operator|=
name|regs_sometimes_live
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sometimes_max
condition|;
name|i
operator|++
control|)
block|{
name|regno
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|old
argument_list|,
name|regno
argument_list|)
condition|)
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
block|}
name|flushed
label|:
empty_stmt|;
if|if
condition|(
name|insn
operator|==
name|first
condition|)
break|break;
block|}
name|FREE_REG_SET
argument_list|(
name|dead
argument_list|)
expr_stmt|;
name|FREE_REG_SET
argument_list|(
name|live
argument_list|)
expr_stmt|;
if|if
condition|(
name|final
condition|)
name|FREE_REG_SET
argument_list|(
name|maxlive
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_scratch
operator|>
name|max_scratch
condition|)
name|max_scratch
operator|=
name|num_scratch
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return 1 if X (the body of an insn, or part of it) is just dead stores    (SET expressions whose destinations are registers dead after the insn).    NEEDED is the regset that says which regs are alive after the insn.     Unless CALL_OK is non-zero, an insn is needed if it contains a CALL.  */
end_comment

begin_function
specifier|static
name|int
name|insn_dead_p
parameter_list|(
name|x
parameter_list|,
name|needed
parameter_list|,
name|call_ok
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|regset
name|needed
decl_stmt|;
name|int
name|call_ok
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* If setting something that's a reg or part of one,      see if that register's altered value will be live.  */
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
name|rtx
name|r
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* A SET that is a subroutine call cannot be dead.  */
if|if
condition|(
operator|!
name|call_ok
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|HAVE_cc0
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|CC0
condition|)
return|return
operator|!
name|cc0_live
return|;
endif|#
directive|endif
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|MEM
operator|&&
name|last_mem_set
operator|&&
operator|!
name|MEM_VOLATILE_P
argument_list|(
name|r
argument_list|)
operator|&&
name|rtx_equal_p
argument_list|(
name|r
argument_list|,
name|last_mem_set
argument_list|)
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|ZERO_EXTRACT
condition|)
name|r
operator|=
name|SUBREG_REG
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|r
argument_list|)
decl_stmt|;
comment|/* Don't delete insns to set global regs.  */
if|if
condition|(
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
comment|/* Make sure insns to set frame pointer aren't deleted.  */
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
comment|/* Make sure insns to set arg pointer are never deleted 		 (if the arg pointer isn't fixed, there will be a USE for 		 it, so we can treat it normally).  */
operator|||
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|||
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If this is a hard register, verify that subsequent words are 	     not needed.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|r
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
operator|+
name|n
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
block|}
comment|/* If performing several activities,      insn is dead if each activity is individually dead.      Also, CLOBBERs and USEs can be ignored; a CLOBBER or USE      that's inside a PARALLEL doesn't make the insn worth keeping.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
name|int
name|i
init|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|!=
name|USE
operator|&&
operator|!
name|insn_dead_p
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|needed
argument_list|,
name|call_ok
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
comment|/* A CLOBBER of a pseudo-register that is dead serves no purpose.  That      is not necessarily true for hard registers.  */
elseif|else
if|if
condition|(
name|code
operator|==
name|CLOBBER
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* We do not check other CLOBBER or USE here.  An insn consisting of just      a CLOBBER or just a USE should not be deleted.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If X is the pattern of the last insn in a libcall, and assuming X is dead,    return 1 if the entire library call is dead.    This is true if X copies a register (hard or pseudo)    and if the hard return  reg of the call insn is dead.    (The caller should have tested the destination of X already for death.)     If this insn doesn't just copy a register, then we don't    have an ordinary libcall.  In that case, cse could not have    managed to substitute the source for the dest later on,    so we can assume the libcall is dead.     NEEDED is the bit vector of pseudoregs live before this insn.    NOTE is the REG_RETVAL note of the insn.  INSN is the insn itself.  */
end_comment

begin_function
specifier|static
name|int
name|libcall_dead_p
parameter_list|(
name|x
parameter_list|,
name|needed
parameter_list|,
name|note
parameter_list|,
name|insn
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|regset
name|needed
decl_stmt|;
name|rtx
name|note
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
condition|)
block|{
specifier|register
name|rtx
name|r
init|=
name|SET_SRC
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|r
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|call
init|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Find the call insn.  */
while|while
condition|(
name|call
operator|!=
name|insn
operator|&&
name|GET_CODE
argument_list|(
name|call
argument_list|)
operator|!=
name|CALL_INSN
condition|)
name|call
operator|=
name|NEXT_INSN
argument_list|(
name|call
argument_list|)
expr_stmt|;
comment|/* If there is none, do nothing special, 	     since ordinary death handling can understand these insns.  */
if|if
condition|(
name|call
operator|==
name|insn
condition|)
return|return
literal|0
return|;
comment|/* See if the hard reg holding the value is dead. 	     If this is a PARALLEL, find the call within it.  */
name|call
operator|=
name|PATTERN
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|call
argument_list|)
operator|==
name|PARALLEL
condition|)
block|{
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|call
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|call
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|XVECEXP
argument_list|(
name|call
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
operator|==
name|CALL
condition|)
break|break;
comment|/* This may be a library call that is returning a value 		 via invisible pointer.  Do nothing special, since 		 ordinary death handling can understand these insns.  */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|call
operator|=
name|XVECEXP
argument_list|(
name|call
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|insn_dead_p
argument_list|(
name|call
argument_list|,
name|needed
argument_list|,
literal|1
argument_list|)
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if register REGNO was used before it was set.    In other words, if it is live at function entry.    Don't count global register variables or variables in registers    that can be used for function arg passing, though.  */
end_comment

begin_function
name|int
name|regno_uninitialized
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
operator|||
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|global_regs
index|[
name|regno
index|]
operator|||
name|FUNCTION_ARG_REGNO_P
argument_list|(
name|regno
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|REGNO_REG_SET_P
argument_list|(
name|basic_block_live_at_start
index|[
literal|0
index|]
argument_list|,
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* 1 if register REGNO was alive at a place where `setjmp' was called    and was set more than once or is an argument.    Such regs may be clobbered by `longjmp'.  */
end_comment

begin_function
name|int
name|regno_clobbered_at_setjmp
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|n_basic_blocks
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|>
literal|1
operator|||
name|REGNO_REG_SET_P
argument_list|(
name|basic_block_live_at_start
index|[
literal|0
index|]
argument_list|,
name|regno
argument_list|)
operator|)
operator|&&
name|REGNO_REG_SET_P
argument_list|(
name|regs_live_at_setjmp
argument_list|,
name|regno
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the registers that are set within X.    Their bits are set to 1 in the regset DEAD,    because they are dead prior to this insn.     If INSN is nonzero, it is the insn being processed    and the fact that it is nonzero implies this is the FINAL pass    in propagate_block.  In this case, various info about register    usage is stored, LOG_LINKS fields of insns are set up.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set_regs
parameter_list|(
name|needed
parameter_list|,
name|dead
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|,
name|significant
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|dead
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|regset
name|significant
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|mark_set_1
argument_list|(
name|needed
argument_list|,
name|dead
argument_list|,
name|x
argument_list|,
name|insn
argument_list|,
name|significant
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|mark_set_1
argument_list|(
name|needed
argument_list|,
name|dead
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|,
name|insn
argument_list|,
name|significant
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process a single SET rtx, X.  */
end_comment

begin_function
specifier|static
name|void
name|mark_set_1
parameter_list|(
name|needed
parameter_list|,
name|dead
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|,
name|significant
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|dead
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
name|regset
name|significant
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Modifying just one hardware register of a multi-reg value      or just a byte field of a register      does not mean the value from before this insn is now dead.      But it does mean liveness of that register at the end of the block      is significant.       Within mark_set_1, however, we treat it as if the register is      indeed modified.  mark_used_regs will, however, also treat this      register as being used.  Thus, we treat these insns as setting a      new value for the register as a function of its old value.  This      cases LOG_LINKS to be made appropriately and this will help combine.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we are writing into memory or into a register mentioned in the      address of the last thing stored into memory, show we don't know      what the last store was.  If we are writing memory, save the address      unless it is volatile.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
name|last_mem_set
operator|!=
literal|0
operator|&&
name|reg_overlap_mentioned_p
argument_list|(
name|reg
argument_list|,
name|last_mem_set
argument_list|)
operator|)
condition|)
name|last_mem_set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|side_effects_p
argument_list|(
name|reg
argument_list|)
comment|/* There are no REG_INC notes for SP, so we can't assume we'll see  	 everything that invalidates it.  To be safe, don't eliminate any 	 stores though SP; none of them should be redundant anyway.  */
operator|&&
operator|!
name|reg_mentioned_p
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|reg
argument_list|)
condition|)
name|last_mem_set
operator|=
name|reg
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
operator|,
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|&&
operator|!
operator|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|global_regs
index|[
name|regno
index|]
operator|)
condition|)
comment|/*&& regno != STACK_POINTER_REGNUM) -- let's try without this.  */
block|{
name|int
name|some_needed
init|=
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|int
name|some_not_needed
init|=
operator|!
name|some_needed
decl_stmt|;
comment|/* Mark it as a significant register for this basic block.  */
if|if
condition|(
name|significant
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|significant
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* Mark it as dead before this insn.  */
name|SET_REGNO_REG_SET
argument_list|(
name|dead
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers. 	 If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* Nothing below is needed for the stack pointer; get out asap. 	     Eg, log links aren't needed, since combine won't use them.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
condition|)
return|return;
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|regno_n
init|=
name|regno
operator|+
name|n
decl_stmt|;
name|int
name|needed_regno
init|=
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno_n
argument_list|)
decl_stmt|;
if|if
condition|(
name|significant
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|significant
argument_list|,
name|regno_n
argument_list|)
expr_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|dead
argument_list|,
name|regno_n
argument_list|)
expr_stmt|;
name|some_needed
operator||=
name|needed_regno
expr_stmt|;
name|some_not_needed
operator||=
operator|!
name|needed_regno
expr_stmt|;
block|}
block|}
comment|/* Additional data to record if this is the final pass.  */
if|if
condition|(
name|insn
condition|)
block|{
specifier|register
name|rtx
name|y
init|=
name|reg_next_use
index|[
name|regno
index|]
decl_stmt|;
specifier|register
name|int
name|blocknum
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
comment|/* If this is a hard reg, record this function uses the reg.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|endregno
init|=
name|regno
operator|+
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
name|regno
init|;
name|i
operator|<
name|endregno
condition|;
name|i
operator|++
control|)
block|{
comment|/* The next use is no longer "next", since a store 		     intervenes.  */
name|reg_next_use
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|regs_ever_live
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The next use is no longer "next", since a store 		 intervenes.  */
name|reg_next_use
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Keep track of which basic blocks each reg appears in.  */
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|=
name|blocknum
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|!=
name|blocknum
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
comment|/* Count (weighted) references, stores, etc.  This counts a 		 register twice if it is modified, but that is correct.  */
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
comment|/* The insns where a reg is live are normally counted 		 elsewhere, but we want the count to include the insn 		 where the reg is set, and the normal counting mechanism 		 would not count it.  */
name|REG_LIVE_LENGTH
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|some_not_needed
condition|)
block|{
comment|/* Make a logical link from the next following insn 		 that uses this register, back to this insn. 		 The following insns have already been processed.  		 We don't build a LOG_LINK for hard registers containing 		 in ASM_OPERANDs.  If these registers get replaced, 		 we might wind up changing the semantics of the insn, 		 even if reload can make what appear to be valid assignments 		 later.  */
if|if
condition|(
name|y
operator|&&
operator|(
name|BLOCK_NUM
argument_list|(
name|y
argument_list|)
operator|==
name|blocknum
operator|)
operator|&&
operator|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|||
name|asm_noperands
argument_list|(
name|PATTERN
argument_list|(
name|y
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|LOG_LINKS
argument_list|(
name|y
argument_list|)
operator|=
name|gen_rtx_INSN_LIST
argument_list|(
name|VOIDmode
argument_list|,
name|insn
argument_list|,
name|LOG_LINKS
argument_list|(
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|some_needed
condition|)
block|{
comment|/* Note that dead stores have already been deleted when possible 		 If we get here, we have found a dead store that cannot 		 be eliminated (because the same insn does something useful). 		 Indicate this by marking the reg being set as dying here.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|REGNO
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a case where we have a multi-word hard register 		 and some, but not all, of the words of the register are 		 needed in subsequent insns.  Write REG_UNUSED notes 		 for those parts that were not needed.  This case should 		 be rare.  */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|reg
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
name|reg_next_use
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If this is the last pass and this is a SCRATCH, show it will be dying      here and count it.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SCRATCH
operator|&&
name|insn
operator|!=
literal|0
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_UNUSED
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|num_scratch
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_comment
comment|/* X is a MEM found in INSN.  See if we can convert it into an auto-increment    reference.  */
end_comment

begin_function
specifier|static
name|void
name|find_auto_inc
parameter_list|(
name|needed
parameter_list|,
name|x
parameter_list|,
name|insn
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|offset
init|=
literal|0
decl_stmt|;
name|rtx
name|set
decl_stmt|;
comment|/* Here we detect use of an index register which might be good for      postincrement, postdecrement, preincrement, or predecrement.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|,
name|addr
operator|=
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|REG
condition|)
block|{
specifier|register
name|rtx
name|y
decl_stmt|;
specifier|register
name|int
name|size
init|=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|use
decl_stmt|;
name|rtx
name|incr
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|addr
argument_list|)
decl_stmt|;
comment|/* Is the next use an increment that might make auto-increment? */
if|if
condition|(
operator|(
name|incr
operator|=
name|reg_next_use
index|[
name|regno
index|]
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|set
operator|=
name|single_set
argument_list|(
name|incr
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|set
argument_list|)
operator|==
name|SET
operator|&&
name|BLOCK_NUM
argument_list|(
name|incr
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
comment|/* Can't add side effects to jumps; if reg is spilled and 	     reloaded, there's no way to store back the altered value.  */
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|JUMP_INSN
operator|&&
operator|(
name|y
operator|=
name|SET_SRC
argument_list|(
name|set
argument_list|)
operator|,
name|GET_CODE
argument_list|(
name|y
argument_list|)
operator|==
name|PLUS
operator|)
operator|&&
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
operator|==
name|addr
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|(
literal|0
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
operator|&&
name|offset
operator|==
literal|0
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_DECREMENT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|size
operator|&&
name|offset
operator|==
literal|0
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PRE_INCREMENT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
operator|&&
name|offset
operator|==
name|size
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
operator|||
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
operator|-
name|size
operator|&&
name|offset
operator|==
operator|-
name|size
operator|)
endif|#
directive|endif
operator|)
comment|/* Make sure this reg appears only once in this insn.  */
operator|&&
operator|(
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
operator|,
name|use
operator|!=
literal|0
operator|&&
name|use
operator|!=
operator|(
name|rtx
operator|)
literal|1
operator|)
condition|)
block|{
name|rtx
name|q
init|=
name|SET_DEST
argument_list|(
name|set
argument_list|)
decl_stmt|;
name|enum
name|rtx_code
name|inc_code
init|=
operator|(
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|size
condition|?
operator|(
name|offset
condition|?
name|PRE_INC
else|:
name|POST_INC
operator|)
else|:
operator|(
name|offset
condition|?
name|PRE_DEC
else|:
name|POST_DEC
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|dead_or_set_p
argument_list|(
name|incr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
comment|/* This is the simple case.  Try to make the auto-inc.  If 		 we can't, we are done.  Otherwise, we will do any 		 needed updates below.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|inc_code
argument_list|,
name|Pmode
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|q
argument_list|)
operator|==
name|REG
comment|/* PREV_INSN used here to check the semi-open interval 		      [insn,incr).  */
operator|&&
operator|!
name|reg_used_between_p
argument_list|(
name|q
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|incr
argument_list|)
comment|/* We must also check for sets of q as q may be 		      a call clobbered hard register and there may 		      be a call between PREV_INSN (insn) and incr.  */
operator|&&
operator|!
name|reg_set_between_p
argument_list|(
name|q
argument_list|,
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|incr
argument_list|)
condition|)
block|{
comment|/* We have *p followed sometime later by q = p+size. 		 Both p and q must be live afterward, 		 and q is not used between INSN and its assignment. 		 Change it to q = p, ...*q..., q = q+size. 		 Then fall into the usual case.  */
name|rtx
name|insns
decl_stmt|,
name|temp
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
name|emit_move_insn
argument_list|(
name|q
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|insns
operator|=
name|get_insns
argument_list|()
expr_stmt|;
name|end_sequence
argument_list|()
expr_stmt|;
comment|/* If anything in INSNS have UID's that don't fit within the 		 extra space we allocate earlier, we can't make this auto-inc. 		 This should never happen.  */
for|for
control|(
name|temp
operator|=
name|insns
init|;
name|temp
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
block|{
if|if
condition|(
name|INSN_UID
argument_list|(
name|temp
argument_list|)
operator|>
name|max_uid_for_flow
condition|)
return|return;
name|BLOCK_NUM
argument_list|(
name|temp
argument_list|)
operator|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
comment|/* If we can't make the auto-inc, or can't make the 		 replacement into Y, exit.  There's no point in making 		 the change below if we can't do the auto-inc and doing 		 so is not correct in the pre-inc case.  */
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|inc_code
argument_list|,
name|Pmode
argument_list|,
name|q
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|validate_change
argument_list|(
name|incr
argument_list|,
operator|&
name|XEXP
argument_list|(
name|y
argument_list|,
literal|0
argument_list|)
argument_list|,
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apply_change_group
argument_list|()
condition|)
return|return;
comment|/* We now know we'll be doing this change, so emit the 		 new insn(s) and do the updates.  */
name|emit_insns_before
argument_list|(
name|insns
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|basic_block_head
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
operator|==
name|insn
condition|)
name|basic_block_head
index|[
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
index|]
operator|=
name|insns
expr_stmt|;
comment|/* INCR will become a NOTE and INSN won't contain a 		 use of ADDR.  If a use of ADDR was just placed in 		 the insn before INSN, make that the next use.  		 Otherwise, invalidate it.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
name|INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SET
operator|&&
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
argument_list|)
argument_list|)
operator|==
name|addr
condition|)
name|reg_next_use
index|[
name|regno
index|]
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
name|reg_next_use
index|[
name|regno
index|]
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|q
expr_stmt|;
name|regno
operator|=
name|REGNO
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* REGNO is now used in INCR which is below INSN, but 		 it previously wasn't live here.  If we don't mark 		 it as needed, we'll put a REG_DEAD note for it 		 on this insn, which is incorrect.  */
name|SET_REGNO_REG_SET
argument_list|(
name|needed
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* If there are any calls between INSN and INCR, show 		 that REGNO now crosses them.  */
for|for
control|(
name|temp
operator|=
name|insn
init|;
name|temp
operator|!=
name|incr
condition|;
name|temp
operator|=
name|NEXT_INSN
argument_list|(
name|temp
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|CALL_INSN
condition|)
name|REG_N_CALLS_CROSSED
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
else|else
return|return;
comment|/* If we haven't returned, it means we were able to make the 	     auto-inc, so update the status.  First, record that this insn 	     has an implicit side effect.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|addr
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Modify the old increment-insn to simply copy 	     the already-incremented value of our register.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|incr
argument_list|,
operator|&
name|SET_SRC
argument_list|(
name|set
argument_list|)
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* If that makes it a no-op (copying the register into itself) delete 	     it so it won't appear to be a "use" and a "set" of this 	     register.  */
if|if
condition|(
name|SET_DEST
argument_list|(
name|set
argument_list|)
operator|==
name|addr
condition|)
block|{
name|PUT_CODE
argument_list|(
name|incr
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|incr
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|incr
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Count an extra reference to the reg.  When a reg is 		 incremented, spilling it is worse, so we want to make 		 that less likely.  */
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
comment|/* Count the increment as a setting of the register, 		 even though it isn't a SET in rtl.  */
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTO_INC_DEC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Scan expression X and store a 1-bit in LIVE for each reg it uses.    This is done assuming the registers needed from X    are those that have 1-bits in NEEDED.     On the final pass, FINAL is 1.  This means try for autoincrement    and count the uses and deaths of each pseudo-reg.     INSN is the containing instruction.  If INSN is dead, this function is not    called.  */
end_comment

begin_function
specifier|static
name|void
name|mark_used_regs
parameter_list|(
name|needed
parameter_list|,
name|live
parameter_list|,
name|x
parameter_list|,
name|final
parameter_list|,
name|insn
parameter_list|)
name|regset
name|needed
decl_stmt|;
name|regset
name|live
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|int
name|final
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|retry
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|PC
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|ASM_INPUT
case|:
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
name|cc0_live
operator|=
literal|1
expr_stmt|;
return|return;
endif|#
directive|endif
case|case
name|CLOBBER
case|:
comment|/* If we are clobbering a MEM, mark any registers inside the address 	 as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
case|case
name|MEM
case|:
comment|/* Invalidate the data for the last MEM stored, but only if MEM is 	 something that can be stored into.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
empty_stmt|;
comment|/* needn't clear last_mem_set */
else|else
name|last_mem_set
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
if|if
condition|(
name|final
condition|)
name|find_auto_inc
argument_list|(
name|needed
argument_list|,
name|x
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SUBREG
case|:
if|if
condition|(
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|REG_CHANGES_SIZE
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* While we're here, optimize this case.  */
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* In case the SUBREG is not of a register, don't optimize */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|x
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ... fall through ...  */
case|case
name|REG
case|:
comment|/* See a register other than being set 	 => mark it as needed.  */
name|regno
operator|=
name|REGNO
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|{
name|int
name|some_needed
init|=
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
argument_list|)
decl_stmt|;
name|int
name|some_not_needed
init|=
operator|!
name|some_needed
decl_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|live
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* A hard reg in a wide mode may really be multiple registers. 	   If so, mark all of them just like the first.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|int
name|n
decl_stmt|;
comment|/* For stack ptr or fixed arg pointer, 	       nothing below can be necessary, so waste no more time.  */
if|if
condition|(
name|regno
operator|==
name|STACK_POINTER_REGNUM
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|||
name|regno
operator|==
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|||
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
operator|||
name|regno
operator|==
name|FRAME_POINTER_REGNUM
condition|)
block|{
comment|/* If this is a register we are going to try to eliminate, 		   don't mark it live here.  If we are successful in 		   eliminating it, it need not be live unless it is used for 		   pseudos, in which case it will have been set live when 		   it was allocated to the pseudos.  If the register will not 		   be eliminated, reload will set it live at that point.  */
if|if
condition|(
operator|!
name|TEST_HARD_REG_BIT
argument_list|(
name|elim_reg_set
argument_list|,
name|regno
argument_list|)
condition|)
name|regs_ever_live
index|[
name|regno
index|]
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* No death notes for global register variables; 	       their values are live after this function exits.  */
if|if
condition|(
name|global_regs
index|[
name|regno
index|]
condition|)
block|{
if|if
condition|(
name|final
condition|)
name|reg_next_use
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
block|{
name|int
name|regno_n
init|=
name|regno
operator|+
name|n
decl_stmt|;
name|int
name|needed_regno
init|=
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno_n
argument_list|)
decl_stmt|;
name|SET_REGNO_REG_SET
argument_list|(
name|live
argument_list|,
name|regno_n
argument_list|)
expr_stmt|;
name|some_needed
operator||=
name|needed_regno
expr_stmt|;
name|some_not_needed
operator||=
operator|!
name|needed_regno
expr_stmt|;
block|}
block|}
if|if
condition|(
name|final
condition|)
block|{
comment|/* Record where each reg is used, so when the reg 	       is set we know the next insn that uses it.  */
name|reg_next_use
index|[
name|regno
index|]
operator|=
name|insn
expr_stmt|;
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* If a hard reg is being used, 		   record that this function does use it.  */
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
do|do
name|regs_ever_live
index|[
name|regno
operator|+
operator|--
name|i
index|]
operator|=
literal|1
expr_stmt|;
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|/* Keep track of which basic block each reg appears in.  */
specifier|register
name|int
name|blocknum
init|=
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
decl_stmt|;
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|==
name|REG_BLOCK_UNKNOWN
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|=
name|blocknum
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|!=
name|blocknum
condition|)
name|REG_BASIC_BLOCK
argument_list|(
name|regno
argument_list|)
operator|=
name|REG_BLOCK_GLOBAL
expr_stmt|;
comment|/* Count (weighted) number of uses of each reg.  */
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
block|}
comment|/* Record and count the insns in which a reg dies. 	       If it is used in this insn and was dead below the insn 	       then it dies in this insn.  If it was set in this insn, 	       we do not make a REG_DEAD note; likewise if we already 	       made such a note.  */
if|if
condition|(
name|some_not_needed
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|insn
argument_list|,
name|x
argument_list|)
if|#
directive|if
literal|0
condition|&& (regno>= FIRST_PSEUDO_REGISTER || ! fixed_regs[regno])
endif|#
directive|endif
condition|)
block|{
comment|/* Check for the case where the register dying partially 		   overlaps the register set by this insn.  */
if|if
condition|(
name|regno
operator|<
name|FIRST_PSEUDO_REGISTER
operator|&&
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|>
literal|1
condition|)
block|{
name|int
name|n
init|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|some_needed
operator||=
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* If none of the words in X is needed, make a REG_DEAD 		   note.  Otherwise, we must make partial REG_DEAD notes.  */
if|if
condition|(
operator|!
name|some_needed
condition|)
block|{
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|x
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|REG_N_DEATHS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
comment|/* Don't make a REG_DEAD note for a part of a register 		       that is set in the insn.  */
for|for
control|(
name|i
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|regno
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|REGNO_REG_SET_P
argument_list|(
name|needed
argument_list|,
name|regno
operator|+
name|i
argument_list|)
operator|&&
operator|!
name|dead_or_set_regno_p
argument_list|(
name|insn
argument_list|,
name|regno
operator|+
name|i
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_DEAD
argument_list|,
name|gen_rtx_REG
argument_list|(
name|reg_raw_mode
index|[
name|regno
operator|+
name|i
index|]
argument_list|,
name|regno
operator|+
name|i
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return;
case|case
name|SET
case|:
block|{
specifier|register
name|rtx
name|testreg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|mark_dest
init|=
literal|0
decl_stmt|;
comment|/* If storing into MEM, don't show it as being used.  But do 	   show the address as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|MEM
condition|)
block|{
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
if|if
condition|(
name|final
condition|)
name|find_auto_inc
argument_list|(
name|needed
argument_list|,
name|testreg
argument_list|,
name|insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Storing in STRICT_LOW_PART is like storing in a reg 	   in that this SET might be dead, so ignore it in TESTREG. 	   but in some other ways it is like using the reg.  	   Storing in a SUBREG or a bit field is like storing the entire 	   register in that if the register's value is not used 	   then this SET is not needed.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_CODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
operator|&&
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|!=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|REG_CHANGES_SIZE
argument_list|(
name|REGNO
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Modifying a single register in an alternate mode 	       does not use any of the old value.  But these other 	       ways of storing in a register do use the old value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|!
operator|(
name|REG_SIZE
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|>
name|REG_SIZE
argument_list|(
name|testreg
argument_list|)
operator|)
condition|)
empty_stmt|;
else|else
name|mark_dest
operator|=
literal|1
expr_stmt|;
name|testreg
operator|=
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a store into a register, 	   recursively scan the value being stored.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|REG
operator|&&
operator|(
name|regno
operator|=
name|REGNO
argument_list|(
name|testreg
argument_list|)
operator|,
name|regno
operator|!=
name|FRAME_POINTER_REGNUM
operator|)
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|regno
operator|!=
name|HARD_FRAME_POINTER_REGNUM
endif|#
directive|endif
if|#
directive|if
name|FRAME_POINTER_REGNUM
operator|!=
name|ARG_POINTER_REGNUM
operator|&&
operator|!
operator|(
name|regno
operator|==
name|ARG_POINTER_REGNUM
operator|&&
name|fixed_regs
index|[
name|regno
index|]
operator|)
endif|#
directive|endif
condition|)
comment|/* We used to exclude global_regs here, but that seems wrong. 	     Storing in them is like storing in mem.  */
block|{
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_dest
condition|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|RETURN
case|:
comment|/* If exiting needs the right stack value, consider this insn as 	 using the stack pointer.  In any event, consider it as using 	 all global registers and all registers used by return.  */
ifdef|#
directive|ifdef
name|EXIT_IGNORE_STACK
if|if
condition|(
operator|!
name|EXIT_IGNORE_STACK
operator|||
operator|(
operator|!
name|FRAME_POINTER_REQUIRED
operator|&&
operator|!
name|current_function_calls_alloca
operator|&&
name|flag_omit_frame_pointer
operator|)
condition|)
endif|#
directive|endif
name|SET_REGNO_REG_SET
argument_list|(
name|live
argument_list|,
name|STACK_POINTER_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|global_regs
index|[
name|i
index|]
ifdef|#
directive|ifdef
name|EPILOGUE_USES
operator|||
name|EPILOGUE_USES
argument_list|(
name|i
argument_list|)
endif|#
directive|endif
condition|)
name|SET_REGNO_REG_SET
argument_list|(
name|live
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Tail recursive case: save a function call level.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|mark_used_regs
argument_list|(
name|needed
argument_list|,
name|live
argument_list|,
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|final
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|AUTO_INC_DEC
end_ifdef

begin_function
specifier|static
name|int
name|try_pre_increment_1
parameter_list|(
name|insn
parameter_list|)
name|rtx
name|insn
decl_stmt|;
block|{
comment|/* Find the next use of this reg.  If in same basic block,      make it do pre-increment or pre-decrement if appropriate.  */
name|rtx
name|x
init|=
name|single_set
argument_list|(
name|insn
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|amount
init|=
operator|(
operator|(
name|GET_CODE
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|PLUS
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
operator|*
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|int
name|regno
init|=
name|REGNO
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|y
init|=
name|reg_next_use
index|[
name|regno
index|]
decl_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
operator|&&
name|BLOCK_NUM
argument_list|(
name|y
argument_list|)
operator|==
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
comment|/* Don't do this if the reg dies, or gets set in y; a standard addressing 	 mode would be better.  */
operator|&&
operator|!
name|dead_or_set_p
argument_list|(
name|y
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
operator|&&
name|try_pre_increment
argument_list|(
name|y
argument_list|,
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|,
name|amount
argument_list|)
condition|)
block|{
comment|/* We have found a suitable auto-increment 	 and already changed insn Y to do it. 	 So flush this increment-instruction.  */
name|PUT_CODE
argument_list|(
name|insn
argument_list|,
name|NOTE
argument_list|)
expr_stmt|;
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|=
name|NOTE_INSN_DELETED
expr_stmt|;
name|NOTE_SOURCE_FILE
argument_list|(
name|insn
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Count a reference to this reg for the increment 	 insn we are deleting.  When a reg is incremented. 	 spilling it is worse, so we want to make that 	 less likely.  */
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Try to change INSN so that it does pre-increment or pre-decrement    addressing on register REG in order to add AMOUNT to REG.    AMOUNT is negative for pre-decrement.    Returns 1 if the change could be made.    This checks all about the validity of the result of modifying INSN.  */
end_comment

begin_function
specifier|static
name|int
name|try_pre_increment
parameter_list|(
name|insn
parameter_list|,
name|reg
parameter_list|,
name|amount
parameter_list|)
name|rtx
name|insn
decl_stmt|,
name|reg
decl_stmt|;
name|HOST_WIDE_INT
name|amount
decl_stmt|;
block|{
specifier|register
name|rtx
name|use
decl_stmt|;
comment|/* Nonzero if we can try to make a pre-increment or pre-decrement.      For example, addl $4,r1; movl (r1),... can become movl +(r1),...  */
name|int
name|pre_ok
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if we can try to make a post-increment or post-decrement.      For example, addl $4,r1; movl -4(r1),... can become movl (r1)+,...      It is possible for both PRE_OK and POST_OK to be nonzero if the machine      supports both pre-inc and post-inc, or both pre-dec and post-dec.  */
name|int
name|post_ok
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if the opportunity actually requires post-inc or post-dec.  */
name|int
name|do_post
init|=
literal|0
decl_stmt|;
comment|/* From the sign of increment, see which possibilities are conceivable      on this target machine.  */
ifdef|#
directive|ifdef
name|HAVE_PRE_INCREMENT
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
name|pre_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_INCREMENT
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
name|post_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_PRE_DECREMENT
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
name|pre_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_POST_DECREMENT
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
name|post_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|pre_ok
operator|||
name|post_ok
operator|)
condition|)
return|return
literal|0
return|;
comment|/* It is not safe to add a side effect to a jump insn      because if the incremented register is spilled and must be reloaded      there would be no way to store the incremented value back in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|JUMP_INSN
condition|)
return|return
literal|0
return|;
name|use
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pre_ok
condition|)
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_ok
operator|&&
operator|(
name|use
operator|==
literal|0
operator|||
name|use
operator|==
operator|(
name|rtx
operator|)
literal|1
operator|)
condition|)
block|{
name|use
operator|=
name|find_use_as_address
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|,
operator|-
name|amount
argument_list|)
expr_stmt|;
name|do_post
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|use
operator|==
literal|0
operator|||
name|use
operator|==
operator|(
name|rtx
operator|)
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|use
argument_list|)
argument_list|)
operator|!=
operator|(
name|amount
operator|>
literal|0
condition|?
name|amount
else|:
operator|-
name|amount
operator|)
condition|)
return|return
literal|0
return|;
comment|/* See if this combination of instruction and addressing mode exists.  */
if|if
condition|(
operator|!
name|validate_change
argument_list|(
name|insn
argument_list|,
operator|&
name|XEXP
argument_list|(
name|use
argument_list|,
literal|0
argument_list|)
argument_list|,
name|gen_rtx_fmt_e
argument_list|(
name|amount
operator|>
literal|0
condition|?
operator|(
name|do_post
condition|?
name|POST_INC
else|:
name|PRE_INC
operator|)
else|:
operator|(
name|do_post
condition|?
name|POST_DEC
else|:
name|PRE_DEC
operator|)
argument_list|,
name|Pmode
argument_list|,
name|reg
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Record that this insn now has an implicit side effect on X.  */
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx_EXPR_LIST
argument_list|(
name|REG_INC
argument_list|,
name|reg
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AUTO_INC_DEC */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Find the place in the rtx X where REG is used as a memory address.    Return the MEM rtx that so uses it.    If PLUSCONST is nonzero, search instead for a memory address equivalent to    (plus REG (const_int PLUSCONST)).     If such an address does not appear, return 0.    If REG appears more than once, or is used other than in such an address,    return (rtx)1.  */
end_comment

begin_function
name|rtx
name|find_use_as_address
parameter_list|(
name|x
parameter_list|,
name|reg
parameter_list|,
name|plusconst
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
name|rtx
name|reg
decl_stmt|;
name|HOST_WIDE_INT
name|plusconst
decl_stmt|;
block|{
name|enum
name|rtx_code
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|rtx
name|value
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|plusconst
operator|==
literal|0
condition|)
return|return
name|x
return|;
if|if
condition|(
name|code
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|reg
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|plusconst
condition|)
return|return
name|x
return|;
if|if
condition|(
name|code
operator|==
name|SIGN_EXTRACT
operator|||
name|code
operator|==
name|ZERO_EXTRACT
condition|)
block|{
comment|/* If REG occurs inside a MEM used in a bit-field reference, 	 that is unacceptable.  */
if|if
condition|(
name|find_use_as_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
block|}
if|if
condition|(
name|x
operator|==
name|reg
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
name|tem
operator|=
name|find_use_as_address
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|,
name|reg
argument_list|,
name|plusconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
block|}
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|tem
operator|=
name|find_use_as_address
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|,
name|reg
argument_list|,
name|plusconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|value
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
return|return
call|(
name|rtx
call|)
argument_list|(
name|HOST_WIDE_INT
argument_list|)
literal|1
return|;
block|}
block|}
block|}
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write information about registers and basic blocks into FILE.    This is part of making a debugging dump.  */
end_comment

begin_function
name|void
name|dump_flow_info
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
name|reg_class_names
index|[]
init|=
name|REG_CLASS_NAMES
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d registers.\n"
argument_list|,
name|max_regno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_regno
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|enum
name|reg_class
name|class
decl_stmt|,
name|altclass
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegister %d used %d times across %d insns"
argument_list|,
name|i
argument_list|,
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
argument_list|,
name|REG_LIVE_LENGTH
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" in block %d"
argument_list|,
name|REG_BASIC_BLOCK
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; set %d time%s"
argument_list|,
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_USERVAR_P
argument_list|(
name|regno_reg_rtx
index|[
name|i
index|]
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; user var"
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_DEATHS
argument_list|(
name|i
argument_list|)
operator|!=
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; dies in %d places"
argument_list|,
name|REG_N_DEATHS
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
operator|==
literal|1
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses 1 call"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; crosses %d calls"
argument_list|,
name|REG_N_CALLS_CROSSED
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
operator|!=
name|UNITS_PER_WORD
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %d bytes"
argument_list|,
name|PSEUDO_REGNO_BYTES
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|class
operator|=
name|reg_preferred_class
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|altclass
operator|=
name|reg_alternate_class
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|GENERAL_REGS
operator|||
name|altclass
operator|!=
name|ALL_REGS
condition|)
block|{
if|if
condition|(
name|altclass
operator|==
name|ALL_REGS
operator|||
name|class
operator|==
name|ALL_REGS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pref %s"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|altclass
operator|==
name|NO_REGS
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; %s or none"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pref %s, else %s"
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|class
index|]
argument_list|,
name|reg_class_names
index|[
operator|(
name|int
operator|)
name|altclass
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REGNO_POINTER_FLAG
argument_list|(
name|i
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"; pointer"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n%d basic blocks.\n"
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_basic_blocks
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|rtx
name|head
decl_stmt|,
name|jump
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nBasic block %d: first insn %d, last %d.\n"
argument_list|,
name|i
argument_list|,
name|INSN_UID
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|basic_block_end
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The control flow graph's storage is freed 	 now when flow_analysis returns. 	 Don't try to print it if it is gone.  */
if|if
condition|(
name|basic_block_drops_in
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Reached from blocks: "
argument_list|)
expr_stmt|;
name|head
operator|=
name|basic_block_head
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
for|for
control|(
name|jump
operator|=
name|LABEL_REFS
argument_list|(
name|head
argument_list|)
init|;
name|jump
operator|!=
name|head
condition|;
name|jump
operator|=
name|LABEL_NEXTREF
argument_list|(
name|jump
argument_list|)
control|)
block|{
specifier|register
name|int
name|from_block
init|=
name|BLOCK_NUM
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|from_block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basic_block_drops_in
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" previous"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nRegisters live at start:"
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|max_regno
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|REGNO_REG_SET_P
argument_list|(
name|basic_block_live_at_start
index|[
name|i
index|]
argument_list|,
name|regno
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Like print_rtl, but also print out live information for the start of each    basic block.  */
end_comment

begin_function
name|void
name|print_rtl_with_bb
parameter_list|(
name|outf
parameter_list|,
name|rtx_first
parameter_list|)
name|FILE
modifier|*
name|outf
decl_stmt|;
name|rtx
name|rtx_first
decl_stmt|;
block|{
specifier|extern
name|int
name|flag_dump_unnumbered
decl_stmt|;
specifier|register
name|rtx
name|tmp_rtx
decl_stmt|;
if|if
condition|(
name|rtx_first
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"(nil)\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|,
name|bb
decl_stmt|;
enum|enum
name|bb_state
block|{
name|NOT_IN_BB
block|,
name|IN_ONE_BB
block|,
name|IN_MULTIPLE_BB
block|}
enum|;
name|int
name|max_uid
init|=
name|get_max_uid
argument_list|()
decl_stmt|;
name|int
modifier|*
name|start
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
name|end
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|in_bb_p
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_uid
operator|*
sizeof|sizeof
argument_list|(
expr|enum
name|bb_state
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_uid
condition|;
name|i
operator|++
control|)
block|{
name|start
index|[
name|i
index|]
operator|=
name|end
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|in_bb_p
index|[
name|i
index|]
operator|=
name|NOT_IN_BB
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|n_basic_blocks
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|rtx
name|x
decl_stmt|;
name|start
index|[
name|INSN_UID
argument_list|(
name|basic_block_head
index|[
name|i
index|]
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
name|end
index|[
name|INSN_UID
argument_list|(
name|basic_block_end
index|[
name|i
index|]
argument_list|)
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|x
operator|=
name|basic_block_head
index|[
name|i
index|]
init|;
name|x
operator|!=
name|NULL_RTX
condition|;
name|x
operator|=
name|NEXT_INSN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|=
operator|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|x
argument_list|)
index|]
operator|==
name|NOT_IN_BB
operator|)
condition|?
name|IN_ONE_BB
else|:
name|IN_MULTIPLE_BB
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|basic_block_end
index|[
name|i
index|]
condition|)
break|break;
block|}
block|}
for|for
control|(
name|tmp_rtx
operator|=
name|rtx_first
init|;
name|NULL
operator|!=
name|tmp_rtx
condition|;
name|tmp_rtx
operator|=
name|NEXT_INSN
argument_list|(
name|tmp_rtx
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|bb
operator|=
name|start
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Start of basic block %d, registers live:"
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_REG_SET
argument_list|(
argument|basic_block_live_at_start[bb]
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|{ 					   fprintf (outf,
literal|" %d"
argument|, i); 					   if (i< FIRST_PSEUDO_REGISTER) 					     fprintf (outf,
literal|" [%s]"
argument|, 						      reg_names[i]); 					 }
argument_list|)
empty_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|==
name|NOT_IN_BB
operator|&&
name|GET_CODE
argument_list|(
name|tmp_rtx
argument_list|)
operator|!=
name|NOTE
operator|&&
name|GET_CODE
argument_list|(
name|tmp_rtx
argument_list|)
operator|!=
name|BARRIER
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Insn is not within a basic block\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_bb_p
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|==
name|IN_MULTIPLE_BB
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; Insn is in multiple basic blocks\n"
argument_list|)
expr_stmt|;
name|print_rtl_single
argument_list|(
name|outf
argument_list|,
name|tmp_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bb
operator|=
name|end
index|[
name|INSN_UID
argument_list|(
name|tmp_rtx
argument_list|)
index|]
operator|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";; End of basic block %d\n"
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_dump_unnumbered
operator|||
name|GET_CODE
argument_list|(
name|tmp_rtx
argument_list|)
operator|!=
name|NOTE
operator|||
name|NOTE_LINE_NUMBER
argument_list|(
name|tmp_rtx
argument_list|)
operator|<
literal|0
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Integer list support.  */
end_comment

begin_comment
comment|/* Allocate a node from list *HEAD_PTR.  */
end_comment

begin_function
specifier|static
name|int_list_ptr
name|alloc_int_list_node
parameter_list|(
name|head_ptr
parameter_list|)
name|int_list_block
modifier|*
modifier|*
name|head_ptr
decl_stmt|;
block|{
name|struct
name|int_list_block
modifier|*
name|first_blk
init|=
operator|*
name|head_ptr
decl_stmt|;
if|if
condition|(
name|first_blk
operator|==
name|NULL
operator|||
name|first_blk
operator|->
name|nodes_left
operator|<=
literal|0
condition|)
block|{
name|first_blk
operator|=
operator|(
expr|struct
name|int_list_block
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|int_list_block
argument_list|)
argument_list|)
expr_stmt|;
name|first_blk
operator|->
name|nodes_left
operator|=
name|INT_LIST_NODES_IN_BLK
expr_stmt|;
name|first_blk
operator|->
name|next
operator|=
operator|*
name|head_ptr
expr_stmt|;
operator|*
name|head_ptr
operator|=
name|first_blk
expr_stmt|;
block|}
name|first_blk
operator|->
name|nodes_left
operator|--
expr_stmt|;
return|return
operator|&
name|first_blk
operator|->
name|nodes
index|[
name|first_blk
operator|->
name|nodes_left
index|]
return|;
block|}
end_function

begin_comment
comment|/* Pointer to head of predecessor/successor block list.  */
end_comment

begin_decl_stmt
specifier|static
name|int_list_block
modifier|*
name|pred_int_list_blocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add a new node to integer list LIST with value VAL.    LIST is a pointer to a list object to allow for different implementations.    If *LIST is initially NULL, the list is empty.    The caller must not care whether the element is added to the front or    to the end of the list (to allow for different implementations).  */
end_comment

begin_function
specifier|static
name|int_list_ptr
name|add_int_list_node
parameter_list|(
name|blk_list
parameter_list|,
name|list
parameter_list|,
name|val
parameter_list|)
name|int_list_block
modifier|*
modifier|*
name|blk_list
decl_stmt|;
name|int_list
modifier|*
modifier|*
name|list
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|int_list_ptr
name|p
init|=
name|alloc_int_list_node
argument_list|(
name|blk_list
argument_list|)
decl_stmt|;
name|p
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Free the blocks of lists at BLK_LIST.  */
end_comment

begin_function
name|void
name|free_int_list
parameter_list|(
name|blk_list
parameter_list|)
name|int_list_block
modifier|*
modifier|*
name|blk_list
decl_stmt|;
block|{
name|int_list_block
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|blk_list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Mark list as empty for the next function we compile.  */
operator|*
name|blk_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Predecessor/successor computation.  */
end_comment

begin_comment
comment|/* Mark PRED_BB a precessor of SUCC_BB,    and conversely SUCC_BB a successor of PRED_BB.  */
end_comment

begin_function
specifier|static
name|void
name|add_pred_succ
parameter_list|(
name|pred_bb
parameter_list|,
name|succ_bb
parameter_list|,
name|s_preds
parameter_list|,
name|s_succs
parameter_list|,
name|num_preds
parameter_list|,
name|num_succs
parameter_list|)
name|int
name|pred_bb
decl_stmt|;
name|int
name|succ_bb
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|int
modifier|*
name|num_preds
decl_stmt|;
name|int
modifier|*
name|num_succs
decl_stmt|;
block|{
if|if
condition|(
name|succ_bb
operator|!=
name|EXIT_BLOCK
condition|)
block|{
name|add_int_list_node
argument_list|(
operator|&
name|pred_int_list_blocks
argument_list|,
operator|&
name|s_preds
index|[
name|succ_bb
index|]
argument_list|,
name|pred_bb
argument_list|)
expr_stmt|;
name|num_preds
index|[
name|succ_bb
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pred_bb
operator|!=
name|ENTRY_BLOCK
condition|)
block|{
name|add_int_list_node
argument_list|(
operator|&
name|pred_int_list_blocks
argument_list|,
operator|&
name|s_succs
index|[
name|pred_bb
index|]
argument_list|,
name|succ_bb
argument_list|)
expr_stmt|;
name|num_succs
index|[
name|pred_bb
index|]
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute the predecessors and successors for each block.  */
end_comment

begin_function
name|void
name|compute_preds_succs
parameter_list|(
name|s_preds
parameter_list|,
name|s_succs
parameter_list|,
name|num_preds
parameter_list|,
name|num_succs
parameter_list|)
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
name|int
modifier|*
name|num_preds
decl_stmt|;
name|int
modifier|*
name|num_succs
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|clear_local_bb_vars
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s_preds
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int_list_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|s_succs
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int_list_ptr
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num_preds
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|num_succs
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This routine can be called after life analysis; in that case      basic_block_drops_in and uid_block_number will not be available      and we must recompute their values.  */
if|if
condition|(
name|basic_block_drops_in
operator|==
name|NULL
operator|||
name|uid_block_number
operator|==
name|NULL
condition|)
block|{
name|clear_local_bb_vars
operator|=
literal|1
expr_stmt|;
name|basic_block_drops_in
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|uid_block_number
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|get_max_uid
argument_list|()
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|basic_block_drops_in
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|uid_block_number
argument_list|,
name|n_basic_blocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Scan each basic block setting basic_block_drops_in and 	 uid_block_number as needed.  */
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|insn
decl_stmt|,
name|stop_insn
decl_stmt|;
if|if
condition|(
name|bb
operator|==
literal|0
condition|)
name|stop_insn
operator|=
name|NULL_RTX
expr_stmt|;
else|else
name|stop_insn
operator|=
name|basic_block_end
index|[
name|bb
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Look backwards from the start of this block.  Stop if we 	     hit the start of the function or the end of a previous 	     block.  Don't walk backwards through blocks that are just 	     deleted insns!  */
for|for
control|(
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|basic_block_head
index|[
name|bb
index|]
argument_list|)
init|;
name|insn
operator|&&
name|insn
operator|!=
name|stop_insn
operator|&&
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|;
name|insn
operator|=
name|PREV_INSN
argument_list|(
name|insn
argument_list|)
control|)
empty_stmt|;
comment|/* Never set basic_block_drops_in for the first block.  It is 	     implicit.  	     If we stopped on anything other than a BARRIER, then this 	     block drops in.  */
if|if
condition|(
name|bb
operator|!=
literal|0
condition|)
name|basic_block_drops_in
index|[
name|bb
index|]
operator|=
operator|(
name|insn
condition|?
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|!=
name|BARRIER
else|:
literal|1
operator|)
expr_stmt|;
name|insn
operator|=
name|basic_block_head
index|[
name|bb
index|]
expr_stmt|;
while|while
condition|(
name|insn
condition|)
block|{
name|BLOCK_NUM
argument_list|(
name|insn
argument_list|)
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|insn
operator|==
name|basic_block_end
index|[
name|bb
index|]
condition|)
break|break;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|rtx
name|head
decl_stmt|;
name|rtx
name|jump
decl_stmt|;
name|head
operator|=
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|head
argument_list|)
operator|==
name|CODE_LABEL
condition|)
for|for
control|(
name|jump
operator|=
name|LABEL_REFS
argument_list|(
name|head
argument_list|)
init|;
name|jump
operator|!=
name|head
condition|;
name|jump
operator|=
name|LABEL_NEXTREF
argument_list|(
name|jump
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|INSN_DELETED_P
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|!=
name|NOTE
operator|||
operator|(
name|NOTE_LINE_NUMBER
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|!=
name|NOTE_INSN_DELETED
operator|)
operator|)
condition|)
name|add_pred_succ
argument_list|(
name|BLOCK_NUM
argument_list|(
name|CONTAINING_INSN
argument_list|(
name|jump
argument_list|)
argument_list|)
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|,
name|s_succs
argument_list|,
name|num_preds
argument_list|,
name|num_succs
argument_list|)
expr_stmt|;
block|}
name|jump
operator|=
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* If this is a RETURN insn or a conditional jump in the last 	 basic block, or a non-jump insn in the last basic block, then 	 this block reaches the exit block.  */
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|GET_CODE
argument_list|(
name|PATTERN
argument_list|(
name|jump
argument_list|)
argument_list|)
operator|==
name|RETURN
operator|)
operator|||
operator|(
operator|(
operator|(
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|==
name|JUMP_INSN
operator|&&
name|condjump_p
argument_list|(
name|jump
argument_list|)
operator|&&
operator|!
name|simplejump_p
argument_list|(
name|jump
argument_list|)
operator|)
operator|||
name|GET_CODE
argument_list|(
name|jump
argument_list|)
operator|!=
name|JUMP_INSN
operator|)
operator|&&
operator|(
name|bb
operator|==
name|n_basic_blocks
operator|-
literal|1
operator|)
operator|)
condition|)
name|add_pred_succ
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK
argument_list|,
name|s_preds
argument_list|,
name|s_succs
argument_list|,
name|num_preds
argument_list|,
name|num_succs
argument_list|)
expr_stmt|;
if|if
condition|(
name|basic_block_drops_in
index|[
name|bb
index|]
condition|)
name|add_pred_succ
argument_list|(
name|bb
operator|-
literal|1
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|,
name|s_succs
argument_list|,
name|num_preds
argument_list|,
name|num_succs
argument_list|)
expr_stmt|;
block|}
name|add_pred_succ
argument_list|(
name|ENTRY_BLOCK
argument_list|,
literal|0
argument_list|,
name|s_preds
argument_list|,
name|s_succs
argument_list|,
name|num_preds
argument_list|,
name|num_succs
argument_list|)
expr_stmt|;
comment|/* If we allocated any variables in temporary storage, clear out the      pointer to the local storage to avoid dangling pointers.  */
if|if
condition|(
name|clear_local_bb_vars
condition|)
block|{
name|basic_block_drops_in
operator|=
name|NULL
expr_stmt|;
name|uid_block_number
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dump_bb_data
parameter_list|(
name|file
parameter_list|,
name|preds
parameter_list|,
name|succs
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int_list_ptr
modifier|*
name|preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|succs
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|;
name|int_list_ptr
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"BB data\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"BB %d, start %d, end %d\n"
argument_list|,
name|bb
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_HEAD
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|,
name|INSN_UID
argument_list|(
name|BLOCK_END
argument_list|(
name|bb
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  preds:"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|preds
index|[
name|bb
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|int
name|pred_bb
init|=
name|INT_LIST_VAL
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|pred_bb
operator|==
name|ENTRY_BLOCK
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" entry"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|pred_bb
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  succs:"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|succs
index|[
name|bb
index|]
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|int
name|succ_bb
init|=
name|INT_LIST_VAL
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|succ_bb
operator|==
name|EXIT_BLOCK
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" exit"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|succ_bb
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_sbitmap
parameter_list|(
name|file
parameter_list|,
name|bmap
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|sbitmap
name|bmap
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|int
name|set_size
init|=
name|bmap
operator|->
name|size
decl_stmt|;
name|int
name|total_bits
init|=
name|bmap
operator|->
name|n_bits
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|=
literal|0
init|;
name|i
operator|<
name|set_size
operator|&&
name|n
operator|<
name|total_bits
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SBITMAP_ELT_BITS
operator|&&
name|n
operator|<
name|total_bits
condition|;
name|j
operator|++
operator|,
name|n
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|!=
literal|0
operator|&&
name|n
operator|%
literal|10
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|bmap
operator|->
name|elms
index|[
name|i
index|]
operator|&
operator|(
literal|1L
operator|<<
name|j
operator|)
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_sbitmap_vector
parameter_list|(
name|file
parameter_list|,
name|title
parameter_list|,
name|subtitle
parameter_list|,
name|bmaps
parameter_list|,
name|n_maps
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|,
decl|*
name|subtitle
decl_stmt|;
end_function

begin_decl_stmt
name|sbitmap
modifier|*
name|bmaps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n_maps
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|bb
decl_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\n"
argument_list|,
name|title
argument_list|)
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|0
init|;
name|bb
operator|<
name|n_maps
condition|;
name|bb
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s %d\n"
argument_list|,
name|subtitle
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|dump_sbitmap
argument_list|(
name|file
argument_list|,
name|bmaps
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Free basic block data storage.  */
end_comment

begin_function
name|void
name|free_bb_mem
parameter_list|()
block|{
name|free_int_list
argument_list|(
operator|&
name|pred_int_list_blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Bitmap manipulation routines.  */
end_comment

begin_comment
comment|/* Allocate a simple bitmap of N_ELMS bits.  */
end_comment

begin_function
name|sbitmap
name|sbitmap_alloc
parameter_list|(
name|n_elms
parameter_list|)
name|int
name|n_elms
decl_stmt|;
block|{
name|int
name|bytes
decl_stmt|,
name|size
decl_stmt|,
name|amt
decl_stmt|;
name|sbitmap
name|bmap
decl_stmt|;
name|size
operator|=
name|SBITMAP_SET_SIZE
argument_list|(
name|n_elms
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|size
operator|*
sizeof|sizeof
argument_list|(
name|SBITMAP_ELT_TYPE
argument_list|)
expr_stmt|;
name|amt
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|simple_bitmap_def
argument_list|)
operator|+
name|bytes
operator|-
sizeof|sizeof
argument_list|(
name|SBITMAP_ELT_TYPE
argument_list|)
operator|)
expr_stmt|;
name|bmap
operator|=
operator|(
name|sbitmap
operator|)
name|xmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
name|bmap
operator|->
name|n_bits
operator|=
name|n_elms
expr_stmt|;
name|bmap
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|bmap
operator|->
name|bytes
operator|=
name|bytes
expr_stmt|;
return|return
name|bmap
return|;
block|}
end_function

begin_comment
comment|/* Allocate a vector of N_VECS bitmaps of N_ELMS bits.  */
end_comment

begin_function
name|sbitmap
modifier|*
name|sbitmap_vector_alloc
parameter_list|(
name|n_vecs
parameter_list|,
name|n_elms
parameter_list|)
name|int
name|n_vecs
decl_stmt|,
name|n_elms
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|bytes
decl_stmt|,
name|offset
decl_stmt|,
name|elm_bytes
decl_stmt|,
name|size
decl_stmt|,
name|amt
decl_stmt|,
name|vector_bytes
decl_stmt|;
name|sbitmap
modifier|*
name|bitmap_vector
decl_stmt|;
name|size
operator|=
name|SBITMAP_SET_SIZE
argument_list|(
name|n_elms
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|size
operator|*
sizeof|sizeof
argument_list|(
name|SBITMAP_ELT_TYPE
argument_list|)
expr_stmt|;
name|elm_bytes
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|simple_bitmap_def
argument_list|)
operator|+
name|bytes
operator|-
sizeof|sizeof
argument_list|(
name|SBITMAP_ELT_TYPE
argument_list|)
operator|)
expr_stmt|;
name|vector_bytes
operator|=
name|n_vecs
operator|*
sizeof|sizeof
argument_list|(
name|sbitmap
operator|*
argument_list|)
expr_stmt|;
comment|/* Round up `vector_bytes' to account for the alignment requirements      of an sbitmap.  One could allocate the vector-table and set of sbitmaps      separately, but that requires maintaining two pointers or creating      a cover struct to hold both pointers (so our result is still just      one pointer).  Neither is a bad idea, but this is simpler for now.  */
block|{
comment|/* Based on DEFAULT_ALIGNMENT computation in obstack.c.  */
struct|struct
block|{
name|char
name|x
decl_stmt|;
name|SBITMAP_ELT_TYPE
name|y
decl_stmt|;
block|}
name|align
struct|;
name|int
name|alignment
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|align
operator|.
name|y
operator|-
operator|&
name|align
operator|.
name|x
decl_stmt|;
name|vector_bytes
operator|=
operator|(
name|vector_bytes
operator|+
name|alignment
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|amt
operator|=
name|vector_bytes
operator|+
operator|(
name|n_vecs
operator|*
name|elm_bytes
operator|)
expr_stmt|;
name|bitmap_vector
operator|=
operator|(
name|sbitmap
operator|*
operator|)
name|xmalloc
argument_list|(
name|amt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|offset
operator|=
name|vector_bytes
init|;
name|i
operator|<
name|n_vecs
condition|;
name|i
operator|++
operator|,
name|offset
operator|+=
name|elm_bytes
control|)
block|{
name|sbitmap
name|b
init|=
call|(
name|sbitmap
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bitmap_vector
operator|+
name|offset
argument_list|)
decl_stmt|;
name|bitmap_vector
index|[
name|i
index|]
operator|=
name|b
expr_stmt|;
name|b
operator|->
name|n_bits
operator|=
name|n_elms
expr_stmt|;
name|b
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|b
operator|->
name|bytes
operator|=
name|bytes
expr_stmt|;
block|}
return|return
name|bitmap_vector
return|;
block|}
end_function

begin_comment
comment|/* Copy sbitmap SRC to DST.  */
end_comment

begin_function
name|void
name|sbitmap_copy
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|sbitmap
name|dst
decl_stmt|,
name|src
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|sbitmap_ptr
name|d
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|src
operator|->
name|elms
expr_stmt|;
name|d
operator|=
name|dst
operator|->
name|elms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dst
operator|->
name|size
condition|;
name|i
operator|++
control|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Zero all elements in a bitmap.  */
end_comment

begin_function
name|void
name|sbitmap_zero
parameter_list|(
name|bmap
parameter_list|)
name|sbitmap
name|bmap
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bmap
operator|->
name|elms
argument_list|,
name|bmap
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set to ones all elements in a bitmap.  */
end_comment

begin_function
name|void
name|sbitmap_ones
parameter_list|(
name|bmap
parameter_list|)
name|sbitmap
name|bmap
decl_stmt|;
block|{
name|memset
argument_list|(
name|bmap
operator|->
name|elms
argument_list|,
operator|-
literal|1
argument_list|,
name|bmap
operator|->
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Zero a vector of N_VECS bitmaps.  */
end_comment

begin_function
name|void
name|sbitmap_vector_zero
parameter_list|(
name|bmap
parameter_list|,
name|n_vecs
parameter_list|)
name|sbitmap
modifier|*
name|bmap
decl_stmt|;
name|int
name|n_vecs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_vecs
condition|;
name|i
operator|++
control|)
name|sbitmap_zero
argument_list|(
name|bmap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set to ones a vector of N_VECS bitmaps.  */
end_comment

begin_function
name|void
name|sbitmap_vector_ones
parameter_list|(
name|bmap
parameter_list|,
name|n_vecs
parameter_list|)
name|sbitmap
modifier|*
name|bmap
decl_stmt|;
name|int
name|n_vecs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_vecs
condition|;
name|i
operator|++
control|)
name|sbitmap_ones
argument_list|(
name|bmap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set DST to be A union (B - C).    DST = A | (B& ~C).    Return non-zero if any change is made.  */
end_comment

begin_function
name|int
name|sbitmap_union_of_diff
parameter_list|(
name|dst
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|sbitmap
name|dst
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|changed
decl_stmt|;
name|sbitmap_ptr
name|dstp
decl_stmt|,
name|ap
decl_stmt|,
name|bp
decl_stmt|,
name|cp
decl_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|dstp
operator|=
name|dst
operator|->
name|elms
expr_stmt|;
name|ap
operator|=
name|a
operator|->
name|elms
expr_stmt|;
name|bp
operator|=
name|b
operator|->
name|elms
expr_stmt|;
name|cp
operator|=
name|c
operator|->
name|elms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dst
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|SBITMAP_ELT_TYPE
name|tmp
init|=
operator|*
name|ap
operator||
operator|(
operator|*
name|bp
operator|&
operator|~
operator|*
name|cp
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|dstp
operator|!=
name|tmp
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
operator|*
name|dstp
operator|=
name|tmp
expr_stmt|;
name|dstp
operator|++
expr_stmt|;
name|ap
operator|++
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Set bitmap DST to the bitwise negation of the bitmap SRC.  */
end_comment

begin_function
name|void
name|sbitmap_not
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|sbitmap
name|dst
decl_stmt|,
name|src
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|sbitmap_ptr
name|dstp
decl_stmt|,
name|ap
decl_stmt|;
name|dstp
operator|=
name|dst
operator|->
name|elms
expr_stmt|;
name|ap
operator|=
name|src
operator|->
name|elms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dst
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|SBITMAP_ELT_TYPE
name|tmp
init|=
operator|~
operator|(
operator|*
name|ap
operator|)
decl_stmt|;
operator|*
name|dstp
operator|=
name|tmp
expr_stmt|;
name|dstp
operator|++
expr_stmt|;
name|ap
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the bits in DST to be the difference between the bits    in A and the bits in B. i.e. dst = a - b.    The - operator is implemented as a& (~b).  */
end_comment

begin_function
name|void
name|sbitmap_difference
parameter_list|(
name|dst
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
name|sbitmap
name|dst
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|sbitmap_ptr
name|dstp
decl_stmt|,
name|ap
decl_stmt|,
name|bp
decl_stmt|;
name|dstp
operator|=
name|dst
operator|->
name|elms
expr_stmt|;
name|ap
operator|=
name|a
operator|->
name|elms
expr_stmt|;
name|bp
operator|=
name|b
operator|->
name|elms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dst
operator|->
name|size
condition|;
name|i
operator|++
control|)
operator|*
name|dstp
operator|++
operator|=
operator|*
name|ap
operator|++
operator|&
operator|(
operator|~
operator|*
name|bp
operator|++
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set DST to be (A and B)).    Return non-zero if any change is made.  */
end_comment

begin_function
name|int
name|sbitmap_a_and_b
parameter_list|(
name|dst
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
name|sbitmap
name|dst
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|changed
decl_stmt|;
name|sbitmap_ptr
name|dstp
decl_stmt|,
name|ap
decl_stmt|,
name|bp
decl_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|dstp
operator|=
name|dst
operator|->
name|elms
expr_stmt|;
name|ap
operator|=
name|a
operator|->
name|elms
expr_stmt|;
name|bp
operator|=
name|b
operator|->
name|elms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dst
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|SBITMAP_ELT_TYPE
name|tmp
init|=
operator|*
name|ap
operator|&
operator|*
name|bp
decl_stmt|;
if|if
condition|(
operator|*
name|dstp
operator|!=
name|tmp
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
operator|*
name|dstp
operator|=
name|tmp
expr_stmt|;
name|dstp
operator|++
expr_stmt|;
name|ap
operator|++
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Set DST to be (A or B)).    Return non-zero if any change is made.  */
end_comment

begin_function
name|int
name|sbitmap_a_or_b
parameter_list|(
name|dst
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
name|sbitmap
name|dst
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|changed
decl_stmt|;
name|sbitmap_ptr
name|dstp
decl_stmt|,
name|ap
decl_stmt|,
name|bp
decl_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|dstp
operator|=
name|dst
operator|->
name|elms
expr_stmt|;
name|ap
operator|=
name|a
operator|->
name|elms
expr_stmt|;
name|bp
operator|=
name|b
operator|->
name|elms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dst
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|SBITMAP_ELT_TYPE
name|tmp
init|=
operator|*
name|ap
operator||
operator|*
name|bp
decl_stmt|;
if|if
condition|(
operator|*
name|dstp
operator|!=
name|tmp
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
operator|*
name|dstp
operator|=
name|tmp
expr_stmt|;
name|dstp
operator|++
expr_stmt|;
name|ap
operator|++
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Set DST to be (A or (B and C)).    Return non-zero if any change is made.  */
end_comment

begin_function
name|int
name|sbitmap_a_or_b_and_c
parameter_list|(
name|dst
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|sbitmap
name|dst
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|changed
decl_stmt|;
name|sbitmap_ptr
name|dstp
decl_stmt|,
name|ap
decl_stmt|,
name|bp
decl_stmt|,
name|cp
decl_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|dstp
operator|=
name|dst
operator|->
name|elms
expr_stmt|;
name|ap
operator|=
name|a
operator|->
name|elms
expr_stmt|;
name|bp
operator|=
name|b
operator|->
name|elms
expr_stmt|;
name|cp
operator|=
name|c
operator|->
name|elms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dst
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|SBITMAP_ELT_TYPE
name|tmp
init|=
operator|*
name|ap
operator||
operator|(
operator|*
name|bp
operator|&
operator|*
name|cp
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|dstp
operator|!=
name|tmp
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
operator|*
name|dstp
operator|=
name|tmp
expr_stmt|;
name|dstp
operator|++
expr_stmt|;
name|ap
operator|++
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Set DST to be (A ann (B or C)).    Return non-zero if any change is made.  */
end_comment

begin_function
name|int
name|sbitmap_a_and_b_or_c
parameter_list|(
name|dst
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
name|sbitmap
name|dst
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|changed
decl_stmt|;
name|sbitmap_ptr
name|dstp
decl_stmt|,
name|ap
decl_stmt|,
name|bp
decl_stmt|,
name|cp
decl_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|dstp
operator|=
name|dst
operator|->
name|elms
expr_stmt|;
name|ap
operator|=
name|a
operator|->
name|elms
expr_stmt|;
name|bp
operator|=
name|b
operator|->
name|elms
expr_stmt|;
name|cp
operator|=
name|c
operator|->
name|elms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dst
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|SBITMAP_ELT_TYPE
name|tmp
init|=
operator|*
name|ap
operator|&
operator|(
operator|*
name|bp
operator||
operator|*
name|cp
operator|)
decl_stmt|;
if|if
condition|(
operator|*
name|dstp
operator|!=
name|tmp
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
operator|*
name|dstp
operator|=
name|tmp
expr_stmt|;
name|dstp
operator|++
expr_stmt|;
name|ap
operator|++
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_comment
comment|/* Set the bitmap DST to the intersection of SRC of all predecessors or    successors of block number BB (PRED_SUCC says which).  */
end_comment

begin_function
name|void
name|sbitmap_intersect_of_predsucc
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|bb
parameter_list|,
name|pred_succ
parameter_list|)
name|sbitmap
name|dst
decl_stmt|;
name|sbitmap
modifier|*
name|src
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int_list_ptr
modifier|*
name|pred_succ
decl_stmt|;
block|{
name|int_list_ptr
name|ps
decl_stmt|;
name|int
name|ps_bb
decl_stmt|;
name|int
name|set_size
init|=
name|dst
operator|->
name|size
decl_stmt|;
name|ps
operator|=
name|pred_succ
index|[
name|bb
index|]
expr_stmt|;
comment|/* It is possible that there are no predecessors(/successors).      This can happen for example in unreachable code.  */
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
block|{
comment|/* In APL-speak this is the `and' reduction of the empty set and thus 	 the result is the identity for `and'.  */
name|sbitmap_ones
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set result to first predecessor/successor.  */
for|for
control|(
init|;
name|ps
operator|!=
name|NULL
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
name|ps_bb
operator|=
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps_bb
operator|==
name|ENTRY_BLOCK
operator|||
name|ps_bb
operator|==
name|EXIT_BLOCK
condition|)
continue|continue;
name|sbitmap_copy
argument_list|(
name|dst
argument_list|,
name|src
index|[
name|ps_bb
index|]
argument_list|)
expr_stmt|;
comment|/* Break out since we're only doing first predecessor.  */
break|break;
block|}
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
return|return;
comment|/* Now do the remaining predecessors/successors.  */
for|for
control|(
name|ps
operator|=
name|ps
operator|->
name|next
init|;
name|ps
operator|!=
name|NULL
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
name|int
name|i
decl_stmt|;
name|sbitmap_ptr
name|p
decl_stmt|,
name|r
decl_stmt|;
name|ps_bb
operator|=
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps_bb
operator|==
name|ENTRY_BLOCK
operator|||
name|ps_bb
operator|==
name|EXIT_BLOCK
condition|)
continue|continue;
name|p
operator|=
name|src
index|[
name|ps_bb
index|]
operator|->
name|elms
expr_stmt|;
name|r
operator|=
name|dst
operator|->
name|elms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set_size
condition|;
name|i
operator|++
control|)
operator|*
name|r
operator|++
operator|&=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the bitmap DST to the intersection of SRC of all predecessors    of block number BB.  */
end_comment

begin_function
name|void
name|sbitmap_intersect_of_predecessors
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|bb
parameter_list|,
name|s_preds
parameter_list|)
name|sbitmap
name|dst
decl_stmt|;
name|sbitmap
modifier|*
name|src
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
block|{
name|sbitmap_intersect_of_predsucc
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the bitmap DST to the intersection of SRC of all successors    of block number BB.  */
end_comment

begin_function
name|void
name|sbitmap_intersect_of_successors
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|bb
parameter_list|,
name|s_succs
parameter_list|)
name|sbitmap
name|dst
decl_stmt|;
name|sbitmap
modifier|*
name|src
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
block|{
name|sbitmap_intersect_of_predsucc
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|bb
argument_list|,
name|s_succs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the bitmap DST to the union of SRC of all predecessors/successors of    block number BB.  */
end_comment

begin_function
name|void
name|sbitmap_union_of_predsucc
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|bb
parameter_list|,
name|pred_succ
parameter_list|)
name|sbitmap
name|dst
decl_stmt|;
name|sbitmap
modifier|*
name|src
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int_list_ptr
modifier|*
name|pred_succ
decl_stmt|;
block|{
name|int_list_ptr
name|ps
decl_stmt|;
name|int
name|ps_bb
decl_stmt|;
name|int
name|set_size
init|=
name|dst
operator|->
name|size
decl_stmt|;
name|ps
operator|=
name|pred_succ
index|[
name|bb
index|]
expr_stmt|;
comment|/* It is possible that there are no predecessors(/successors).      This can happen for example in unreachable code.  */
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
block|{
comment|/* In APL-speak this is the `or' reduction of the empty set and thus 	 the result is the identity for `or'.  */
name|sbitmap_zero
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Set result to first predecessor/successor.  */
for|for
control|(
init|;
name|ps
operator|!=
name|NULL
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
name|ps_bb
operator|=
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps_bb
operator|==
name|ENTRY_BLOCK
operator|||
name|ps_bb
operator|==
name|EXIT_BLOCK
condition|)
continue|continue;
name|sbitmap_copy
argument_list|(
name|dst
argument_list|,
name|src
index|[
name|ps_bb
index|]
argument_list|)
expr_stmt|;
comment|/* Break out since we're only doing first predecessor.  */
break|break;
block|}
if|if
condition|(
name|ps
operator|==
name|NULL
condition|)
return|return;
comment|/* Now do the remaining predecessors/successors.  */
for|for
control|(
name|ps
operator|=
name|ps
operator|->
name|next
init|;
name|ps
operator|!=
name|NULL
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
name|int
name|i
decl_stmt|;
name|sbitmap_ptr
name|p
decl_stmt|,
name|r
decl_stmt|;
name|ps_bb
operator|=
name|INT_LIST_VAL
argument_list|(
name|ps
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps_bb
operator|==
name|ENTRY_BLOCK
operator|||
name|ps_bb
operator|==
name|EXIT_BLOCK
condition|)
continue|continue;
name|p
operator|=
name|src
index|[
name|ps_bb
index|]
operator|->
name|elms
expr_stmt|;
name|r
operator|=
name|dst
operator|->
name|elms
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set_size
condition|;
name|i
operator|++
control|)
operator|*
name|r
operator|++
operator||=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set the bitmap DST to the union of SRC of all predecessors of    block number BB.  */
end_comment

begin_function
name|void
name|sbitmap_union_of_predecessors
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|bb
parameter_list|,
name|s_preds
parameter_list|)
name|sbitmap
name|dst
decl_stmt|;
name|sbitmap
modifier|*
name|src
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
block|{
name|sbitmap_union_of_predsucc
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the bitmap DST to the union of SRC of all predecessors of    block number BB.  */
end_comment

begin_function
name|void
name|sbitmap_union_of_successors
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|bb
parameter_list|,
name|s_succ
parameter_list|)
name|sbitmap
name|dst
decl_stmt|;
name|sbitmap
modifier|*
name|src
decl_stmt|;
name|int
name|bb
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succ
decl_stmt|;
block|{
name|sbitmap_union_of_predsucc
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|bb
argument_list|,
name|s_succ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute dominator relationships.  */
end_comment

begin_function
name|void
name|compute_dominators
parameter_list|(
name|dominators
parameter_list|,
name|post_dominators
parameter_list|,
name|s_preds
parameter_list|,
name|s_succs
parameter_list|)
name|sbitmap
modifier|*
name|dominators
decl_stmt|;
name|sbitmap
modifier|*
name|post_dominators
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_preds
decl_stmt|;
name|int_list_ptr
modifier|*
name|s_succs
decl_stmt|;
block|{
name|int
name|bb
decl_stmt|,
name|changed
decl_stmt|,
name|passes
decl_stmt|;
name|sbitmap
modifier|*
name|temp_bitmap
decl_stmt|;
name|temp_bitmap
operator|=
name|sbitmap_vector_alloc
argument_list|(
name|n_basic_blocks
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|dominators
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_ones
argument_list|(
name|post_dominators
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_vector_zero
argument_list|(
name|temp_bitmap
argument_list|,
name|n_basic_blocks
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|dominators
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|dominators
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbitmap_zero
argument_list|(
name|post_dominators
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|post_dominators
index|[
name|n_basic_blocks
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|passes
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|changed
condition|)
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bb
operator|=
literal|1
init|;
name|bb
operator|<
name|n_basic_blocks
condition|;
name|bb
operator|++
control|)
block|{
name|sbitmap_intersect_of_predecessors
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|dominators
argument_list|,
name|bb
argument_list|,
name|s_preds
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_a_and_b
argument_list|(
name|dominators
index|[
name|bb
index|]
argument_list|,
name|dominators
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
name|sbitmap_intersect_of_successors
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|post_dominators
argument_list|,
name|bb
argument_list|,
name|s_succs
argument_list|)
expr_stmt|;
name|SET_BIT
argument_list|(
name|temp_bitmap
index|[
name|bb
index|]
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|changed
operator||=
name|sbitmap_a_and_b
argument_list|(
name|post_dominators
index|[
name|bb
index|]
argument_list|,
name|post_dominators
index|[
name|bb
index|]
argument_list|,
name|temp_bitmap
index|[
name|bb
index|]
argument_list|)
expr_stmt|;
block|}
name|passes
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|temp_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Count for a single SET rtx, X.  */
end_comment

begin_function
specifier|static
name|void
name|count_reg_sets_1
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|regno
decl_stmt|;
specifier|register
name|rtx
name|reg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Find the register that's set/clobbered.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|STRICT_LOW_PART
condition|)
name|reg
operator|=
name|XEXP
argument_list|(
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|reg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
comment|/* Count (weighted) references, stores, etc.  This counts a 	     register twice if it is modified, but that is correct.  */
name|REG_N_SETS
argument_list|(
name|regno
argument_list|)
operator|++
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|regno
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Increment REG_N_SETS for each SET or CLOBBER found in X; also increment    REG_N_REFS by the current loop depth for each SET or CLOBBER found.  */
end_comment

begin_function
specifier|static
name|void
name|count_reg_sets
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|count_reg_sets_1
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|PARALLEL
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|XVECLEN
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|code
operator|=
name|GET_CODE
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|SET
operator|||
name|code
operator|==
name|CLOBBER
condition|)
name|count_reg_sets_1
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Increment REG_N_REFS by the current loop depth each register reference    found in X.  */
end_comment

begin_function
specifier|static
name|void
name|count_reg_references
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
decl_stmt|;
specifier|register
name|int
name|regno
decl_stmt|;
name|int
name|i
decl_stmt|;
name|retry
label|:
name|code
operator|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LABEL_REF
case|:
case|case
name|SYMBOL_REF
case|:
case|case
name|CONST_INT
case|:
case|case
name|CONST
case|:
case|case
name|CONST_DOUBLE
case|:
case|case
name|PC
case|:
case|case
name|ADDR_VEC
case|:
case|case
name|ADDR_DIFF_VEC
case|:
case|case
name|ASM_INPUT
case|:
return|return;
ifdef|#
directive|ifdef
name|HAVE_cc0
case|case
name|CC0
case|:
return|return;
endif|#
directive|endif
case|case
name|CLOBBER
case|:
comment|/* If we are clobbering a MEM, mark any registers inside the address 	 as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|count_reg_references
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SUBREG
case|:
comment|/* While we're here, optimize this case.  */
name|x
operator|=
name|SUBREG_REG
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* In case the SUBREG is not of a register, don't optimize */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
block|{
name|count_reg_references
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ... fall through ...  */
case|case
name|REG
case|:
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
name|REG_N_REFS
argument_list|(
name|REGNO
argument_list|(
name|x
argument_list|)
argument_list|)
operator|+=
name|loop_depth
expr_stmt|;
return|return;
case|case
name|SET
case|:
block|{
specifier|register
name|rtx
name|testreg
init|=
name|SET_DEST
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|mark_dest
init|=
literal|0
decl_stmt|;
comment|/* If storing into MEM, don't show it as being used.  But do 	   show the address as being used.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|count_reg_references
argument_list|(
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|count_reg_references
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Storing in STRICT_LOW_PART is like storing in a reg 	   in that this SET might be dead, so ignore it in TESTREG. 	   but in some other ways it is like using the reg.  	   Storing in a SUBREG or a bit field is like storing the entire 	   register in that if the register's value is not used 	   then this SET is not needed.  */
while|while
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|STRICT_LOW_PART
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|ZERO_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SIGN_EXTRACT
operator|||
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* Modifying a single register in an alternate mode 	       does not use any of the old value.  But these other 	       ways of storing in a register do use the old value.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|SUBREG
operator|&&
operator|!
operator|(
name|REG_SIZE
argument_list|(
name|SUBREG_REG
argument_list|(
name|testreg
argument_list|)
argument_list|)
operator|>
name|REG_SIZE
argument_list|(
name|testreg
argument_list|)
operator|)
condition|)
empty_stmt|;
else|else
name|mark_dest
operator|=
literal|1
expr_stmt|;
name|testreg
operator|=
name|XEXP
argument_list|(
name|testreg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a store into a register, 	   recursively scan the value being stored.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|testreg
argument_list|)
operator|==
name|REG
condition|)
block|{
name|count_reg_references
argument_list|(
name|SET_SRC
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark_dest
condition|)
name|count_reg_references
argument_list|(
name|SET_DEST
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
break|break;
default|default:
break|break;
block|}
comment|/* Recursively scan the operands of this expression.  */
block|{
specifier|register
name|char
modifier|*
name|fmt
init|=
name|GET_RTX_FORMAT
argument_list|(
name|code
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|GET_RTX_LENGTH
argument_list|(
name|code
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'e'
condition|)
block|{
comment|/* Tail recursive case: save a function call level.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|count_reg_references
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
index|[
name|i
index|]
operator|==
literal|'E'
condition|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|XVECLEN
argument_list|(
name|x
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
name|count_reg_references
argument_list|(
name|XVECEXP
argument_list|(
name|x
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Recompute register set/reference counts immediately prior to register    allocation.     This avoids problems with set/reference counts changing to/from values    which have special meanings to the register allocators.     Additionally, the reference counts are the primary component used by the    register allocators to prioritize pseudos for allocation to hard regs.    More accurate reference counts generally lead to better register allocation.     It might be worthwhile to update REG_LIVE_LENGTH, REG_BASIC_BLOCK and    possibly other information which is used by the register allocators.  */
end_comment

begin_function
name|void
name|recompute_reg_usage
parameter_list|(
name|f
parameter_list|)
name|rtx
name|f
decl_stmt|;
block|{
name|rtx
name|insn
decl_stmt|;
name|int
name|i
decl_stmt|,
name|max_reg
decl_stmt|;
comment|/* Clear out the old data.  */
name|max_reg
operator|=
name|max_reg_num
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_PSEUDO_REGISTER
init|;
name|i
operator|<
name|max_reg
condition|;
name|i
operator|++
control|)
block|{
name|REG_N_SETS
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
name|REG_N_REFS
argument_list|(
name|i
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Scan each insn in the chain and count how many times each register is      set/used.  */
name|loop_depth
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|insn
operator|=
name|f
init|;
name|insn
condition|;
name|insn
operator|=
name|NEXT_INSN
argument_list|(
name|insn
argument_list|)
control|)
block|{
comment|/* Keep track of loop depth.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE
condition|)
block|{
comment|/* Look for loop boundaries.  */
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_END
condition|)
name|loop_depth
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|NOTE_LINE_NUMBER
argument_list|(
name|insn
argument_list|)
operator|==
name|NOTE_INSN_LOOP_BEG
condition|)
name|loop_depth
operator|++
expr_stmt|;
comment|/* If we have LOOP_DEPTH == 0, there has been a bookkeeping error.  	     Abort now rather than setting register status incorrectly.  */
if|if
condition|(
name|loop_depth
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_RTX_CLASS
argument_list|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|==
literal|'i'
condition|)
block|{
name|rtx
name|links
decl_stmt|;
comment|/* This call will increment REG_N_SETS for each SET or CLOBBER 	     of a register in INSN.  It will also increment REG_N_REFS 	     by the loop depth for each set of a register in INSN.  */
name|count_reg_sets
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* count_reg_sets does not detect autoincrement address modes, so 	     detect them here by looking at the notes attached to INSN.  */
for|for
control|(
name|links
operator|=
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
init|;
name|links
condition|;
name|links
operator|=
name|XEXP
argument_list|(
name|links
argument_list|,
literal|1
argument_list|)
control|)
block|{
if|if
condition|(
name|REG_NOTE_KIND
argument_list|(
name|links
argument_list|)
operator|==
name|REG_INC
condition|)
comment|/* Count (weighted) references, stores, etc.  This counts a 		   register twice if it is modified, but that is correct.  */
name|REG_N_SETS
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|links
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|++
expr_stmt|;
block|}
comment|/* This call will increment REG_N_REFS by the current loop depth for 	     each reference to a register in INSN.  */
name|count_reg_references
argument_list|(
name|PATTERN
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* count_reg_references will not include counts for arguments to 	     function calls, so detect them here by examining the 	     CALL_INSN_FUNCTION_USAGE data.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|insn
argument_list|)
operator|==
name|CALL_INSN
condition|)
block|{
name|rtx
name|note
decl_stmt|;
for|for
control|(
name|note
operator|=
name|CALL_INSN_FUNCTION_USAGE
argument_list|(
name|insn
argument_list|)
init|;
name|note
condition|;
name|note
operator|=
name|XEXP
argument_list|(
name|note
argument_list|,
literal|1
argument_list|)
control|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|USE
condition|)
name|count_reg_references
argument_list|(
name|SET_DEST
argument_list|(
name|XEXP
argument_list|(
name|note
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

end_unit

