begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Routines required for instrumenting a program.  */
end_comment

begin_comment
comment|/* Compile this one with gcc.  */
end_comment

begin_comment
comment|/* Copyright (C) 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002, 2003  Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  In addition to the permissions in the GNU General Public License, the Free Software Foundation gives you unlimited permission to link the compiled version of this file into combinations with other programs, and to distribute those combinations without any restriction coming from the use of this file.  (The General Public License restrictions do apply in other respects; for example, they cover modification of the file, and distribution when not linked into a combine executable.)  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* It is incorrect to include config.h here, because this file is being    compiled for the target, and hence definitions concerning only the host    do not apply.  */
end_comment

begin_include
include|#
directive|include
file|"tconfig.h"
end_include

begin_include
include|#
directive|include
file|"tsystem.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|inhibit_libc
argument_list|)
end_if

begin_define
define|#
directive|define
name|IN_LIBGCOV
value|(-1)
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_comment
comment|/* Avoid errors if stdio.h and our stddef.h mismatch.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|IN_LIBGCOV
value|1
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|L_gcov
argument_list|)
end_if

begin_define
define|#
directive|define
name|GCOV_LINKAGE
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gcov-io.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|inhibit_libc
argument_list|)
end_if

begin_comment
comment|/* If libc and its header files are not available, provide dummy functions.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|L_gcov
end_ifdef

begin_decl_stmt
name|void
name|__gcov_init
argument_list|(
expr|struct
name|gcov_info
operator|*
name|p
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{}
end_decl_stmt

begin_function
name|void
name|__gcov_flush
parameter_list|(
name|void
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_gcov_merge_add
end_ifdef

begin_decl_stmt
name|void
name|__gcov_merge_add
argument_list|(
name|gcov_type
operator|*
name|counters
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|unsigned
name|n_counters
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_gcov_merge_single
end_ifdef

begin_decl_stmt
name|void
name|__gcov_merge_single
argument_list|(
name|gcov_type
operator|*
name|counters
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|unsigned
name|n_counters
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_gcov_merge_delta
end_ifdef

begin_decl_stmt
name|void
name|__gcov_merge_delta
argument_list|(
name|gcov_type
operator|*
name|counters
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|,
name|unsigned
name|n_counters
name|__attribute__
argument_list|(
operator|(
name|unused
operator|)
argument_list|)
argument_list|)
block|{}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_if
if|#
directive|if
name|GCOV_LOCKED
end_if

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|L_gcov
end_ifdef

begin_include
include|#
directive|include
file|"gcov-io.c"
end_include

begin_comment
comment|/* Chain of per-object gcov structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gcov_info
modifier|*
name|gcov_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A program checksum allows us to distinguish program data for an    object file included in multiple programs.  */
end_comment

begin_decl_stmt
specifier|static
name|gcov_unsigned_t
name|gcov_crc32
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|gcov_version
parameter_list|(
name|struct
name|gcov_info
modifier|*
name|ptr
parameter_list|,
name|gcov_unsigned_t
name|version
parameter_list|)
block|{
if|if
condition|(
name|version
operator|!=
name|GCOV_VERSION
condition|)
block|{
name|char
name|v
index|[
literal|4
index|]
decl_stmt|,
name|e
index|[
literal|4
index|]
decl_stmt|;
name|GCOV_UNSIGNED2STRING
argument_list|(
name|v
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|GCOV_UNSIGNED2STRING
argument_list|(
name|e
argument_list|,
name|GCOV_VERSION
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"profiling:%s:Version mismatch - expected %.4s got %.4s\n"
argument_list|,
name|ptr
operator|->
name|filename
argument_list|,
name|e
argument_list|,
name|v
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Dump the coverage counts. We merge with existing counts when    possible, to avoid growing the .da files ad infinitum. We use this    program's checksum to make sure we only accumulate whole program    statistics to the correct summary. An object file might be embedded    in two separate programs, and we must keep the two program    summaries separate.  */
end_comment

begin_function
specifier|static
name|void
name|gcov_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gcov_info
modifier|*
name|gi_ptr
decl_stmt|;
name|struct
name|gcov_summary
name|this_program
decl_stmt|;
name|struct
name|gcov_summary
name|all
decl_stmt|;
name|struct
name|gcov_ctr_summary
modifier|*
name|cs_ptr
decl_stmt|;
specifier|const
name|struct
name|gcov_ctr_info
modifier|*
name|ci_ptr
decl_stmt|;
name|unsigned
name|t_ix
decl_stmt|;
name|gcov_unsigned_t
name|c_num
decl_stmt|;
name|memset
argument_list|(
operator|&
name|all
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|all
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the totals for this execution.  */
name|memset
argument_list|(
operator|&
name|this_program
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|this_program
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|gi_ptr
operator|=
name|gcov_list
init|;
name|gi_ptr
condition|;
name|gi_ptr
operator|=
name|gi_ptr
operator|->
name|next
control|)
block|{
name|ci_ptr
operator|=
name|gi_ptr
operator|->
name|counts
expr_stmt|;
for|for
control|(
name|t_ix
operator|=
literal|0
init|;
name|t_ix
operator|<
name|GCOV_COUNTERS_SUMMABLE
condition|;
name|t_ix
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
literal|1
operator|<<
name|t_ix
operator|)
operator|&
name|gi_ptr
operator|->
name|ctr_mask
operator|)
condition|)
continue|continue;
name|cs_ptr
operator|=
operator|&
name|this_program
operator|.
name|ctrs
index|[
name|t_ix
index|]
expr_stmt|;
name|cs_ptr
operator|->
name|num
operator|+=
name|ci_ptr
operator|->
name|num
expr_stmt|;
for|for
control|(
name|c_num
operator|=
literal|0
init|;
name|c_num
operator|<
name|ci_ptr
operator|->
name|num
condition|;
name|c_num
operator|++
control|)
block|{
name|cs_ptr
operator|->
name|sum_all
operator|+=
name|ci_ptr
operator|->
name|values
index|[
name|c_num
index|]
expr_stmt|;
if|if
condition|(
name|cs_ptr
operator|->
name|run_max
operator|<
name|ci_ptr
operator|->
name|values
index|[
name|c_num
index|]
condition|)
name|cs_ptr
operator|->
name|run_max
operator|=
name|ci_ptr
operator|->
name|values
index|[
name|c_num
index|]
expr_stmt|;
block|}
name|ci_ptr
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now merge each file.  */
for|for
control|(
name|gi_ptr
operator|=
name|gcov_list
init|;
name|gi_ptr
condition|;
name|gi_ptr
operator|=
name|gi_ptr
operator|->
name|next
control|)
block|{
name|struct
name|gcov_summary
name|this_object
decl_stmt|;
name|struct
name|gcov_summary
name|object
decl_stmt|,
name|program
decl_stmt|;
name|gcov_type
modifier|*
name|values
index|[
name|GCOV_COUNTERS
index|]
decl_stmt|;
specifier|const
name|struct
name|gcov_fn_info
modifier|*
name|fi_ptr
decl_stmt|;
name|unsigned
name|fi_stride
decl_stmt|;
name|unsigned
name|c_ix
decl_stmt|,
name|f_ix
decl_stmt|,
name|n_counts
decl_stmt|;
name|struct
name|gcov_ctr_summary
modifier|*
name|cs_obj
decl_stmt|,
modifier|*
name|cs_tobj
decl_stmt|,
modifier|*
name|cs_prg
decl_stmt|,
modifier|*
name|cs_tprg
decl_stmt|,
modifier|*
name|cs_all
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|gcov_unsigned_t
name|tag
decl_stmt|,
name|length
decl_stmt|;
name|gcov_position_t
name|summary_pos
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|this_object
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|this_object
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|object
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Totals for this object file.  */
name|ci_ptr
operator|=
name|gi_ptr
operator|->
name|counts
expr_stmt|;
for|for
control|(
name|t_ix
operator|=
literal|0
init|;
name|t_ix
operator|<
name|GCOV_COUNTERS_SUMMABLE
condition|;
name|t_ix
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
literal|1
operator|<<
name|t_ix
operator|)
operator|&
name|gi_ptr
operator|->
name|ctr_mask
operator|)
condition|)
continue|continue;
name|cs_ptr
operator|=
operator|&
name|this_object
operator|.
name|ctrs
index|[
name|t_ix
index|]
expr_stmt|;
name|cs_ptr
operator|->
name|num
operator|+=
name|ci_ptr
operator|->
name|num
expr_stmt|;
for|for
control|(
name|c_num
operator|=
literal|0
init|;
name|c_num
operator|<
name|ci_ptr
operator|->
name|num
condition|;
name|c_num
operator|++
control|)
block|{
name|cs_ptr
operator|->
name|sum_all
operator|+=
name|ci_ptr
operator|->
name|values
index|[
name|c_num
index|]
expr_stmt|;
if|if
condition|(
name|cs_ptr
operator|->
name|run_max
operator|<
name|ci_ptr
operator|->
name|values
index|[
name|c_num
index|]
condition|)
name|cs_ptr
operator|->
name|run_max
operator|=
name|ci_ptr
operator|->
name|values
index|[
name|c_num
index|]
expr_stmt|;
block|}
name|ci_ptr
operator|++
expr_stmt|;
block|}
name|c_ix
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t_ix
operator|=
literal|0
init|;
name|t_ix
operator|<
name|GCOV_COUNTERS
condition|;
name|t_ix
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|t_ix
operator|)
operator|&
name|gi_ptr
operator|->
name|ctr_mask
condition|)
block|{
name|values
index|[
name|c_ix
index|]
operator|=
name|gi_ptr
operator|->
name|counts
index|[
name|c_ix
index|]
operator|.
name|values
expr_stmt|;
name|c_ix
operator|++
expr_stmt|;
block|}
comment|/* Calculate the function_info stride. This depends on the 	 number of counter types being measured.  */
name|fi_stride
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|gcov_fn_info
argument_list|)
operator|+
name|c_ix
operator|*
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
expr_stmt|;
if|if
condition|(
name|__alignof__
argument_list|(
expr|struct
name|gcov_fn_info
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
condition|)
block|{
name|fi_stride
operator|+=
name|__alignof__
argument_list|(
expr|struct
name|gcov_fn_info
argument_list|)
operator|-
literal|1
expr_stmt|;
name|fi_stride
operator|&=
operator|~
operator|(
name|__alignof__
argument_list|(
expr|struct
name|gcov_fn_info
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gcov_open
argument_list|(
name|gi_ptr
operator|->
name|filename
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"profiling:%s:Cannot open\n"
argument_list|,
name|gi_ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|tag
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
comment|/* Merge data from file.  */
if|if
condition|(
name|tag
operator|!=
name|GCOV_DATA_MAGIC
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"profiling:%s:Not a gcov data file\n"
argument_list|,
name|gi_ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
name|read_fatal
label|:
empty_stmt|;
name|gcov_close
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|length
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gcov_version
argument_list|(
name|gi_ptr
argument_list|,
name|length
argument_list|)
condition|)
goto|goto
name|read_fatal
goto|;
name|length
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|gi_ptr
operator|->
name|stamp
condition|)
block|{
comment|/* Read from a different compilation. Overwrite the 		 file.  */
name|gcov_truncate
argument_list|()
expr_stmt|;
goto|goto
name|rewrite
goto|;
block|}
comment|/* Merge execution counts for each function.  */
for|for
control|(
name|f_ix
operator|=
literal|0
init|;
name|f_ix
operator|<
name|gi_ptr
operator|->
name|n_functions
condition|;
name|f_ix
operator|++
control|)
block|{
name|fi_ptr
operator|=
operator|(
specifier|const
expr|struct
name|gcov_fn_info
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|gi_ptr
operator|->
name|functions
operator|+
name|f_ix
operator|*
name|fi_stride
operator|)
expr_stmt|;
name|tag
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
name|length
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
comment|/* Check function.  */
if|if
condition|(
name|tag
operator|!=
name|GCOV_TAG_FUNCTION
operator|||
name|length
operator|!=
name|GCOV_TAG_FUNCTION_LENGTH
operator|||
name|gcov_read_unsigned
argument_list|()
operator|!=
name|fi_ptr
operator|->
name|ident
operator|||
name|gcov_read_unsigned
argument_list|()
operator|!=
name|fi_ptr
operator|->
name|checksum
condition|)
block|{
name|read_mismatch
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"profiling:%s:Merge mismatch for %s\n"
argument_list|,
name|gi_ptr
operator|->
name|filename
argument_list|,
name|f_ix
operator|+
literal|1
condition|?
literal|"function"
else|:
literal|"summaries"
argument_list|)
expr_stmt|;
goto|goto
name|read_fatal
goto|;
block|}
name|c_ix
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t_ix
operator|=
literal|0
init|;
name|t_ix
operator|<
name|GCOV_COUNTERS
condition|;
name|t_ix
operator|++
control|)
block|{
name|gcov_merge_fn
name|merge
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
literal|1
operator|<<
name|t_ix
operator|)
operator|&
name|gi_ptr
operator|->
name|ctr_mask
operator|)
condition|)
continue|continue;
name|n_counts
operator|=
name|fi_ptr
operator|->
name|n_ctrs
index|[
name|c_ix
index|]
expr_stmt|;
name|merge
operator|=
name|gi_ptr
operator|->
name|counts
index|[
name|c_ix
index|]
operator|.
name|merge
expr_stmt|;
name|tag
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
name|length
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|GCOV_TAG_FOR_COUNTER
argument_list|(
name|t_ix
argument_list|)
operator|||
name|length
operator|!=
name|GCOV_TAG_COUNTER_LENGTH
argument_list|(
name|n_counts
argument_list|)
condition|)
goto|goto
name|read_mismatch
goto|;
call|(
modifier|*
name|merge
call|)
argument_list|(
name|values
index|[
name|c_ix
index|]
argument_list|,
name|n_counts
argument_list|)
expr_stmt|;
name|values
index|[
name|c_ix
index|]
operator|+=
name|n_counts
expr_stmt|;
name|c_ix
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|gcov_is_error
argument_list|()
operator|)
condition|)
goto|goto
name|read_error
goto|;
block|}
name|f_ix
operator|=
operator|~
literal|0u
expr_stmt|;
comment|/* Check program& object summary */
while|while
condition|(
literal|1
condition|)
block|{
name|gcov_position_t
name|base
init|=
name|gcov_position
argument_list|()
decl_stmt|;
name|int
name|is_program
decl_stmt|;
name|tag
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|tag
condition|)
break|break;
name|length
operator|=
name|gcov_read_unsigned
argument_list|()
expr_stmt|;
name|is_program
operator|=
name|tag
operator|==
name|GCOV_TAG_PROGRAM_SUMMARY
expr_stmt|;
if|if
condition|(
name|length
operator|!=
name|GCOV_TAG_SUMMARY_LENGTH
operator|||
operator|(
operator|!
name|is_program
operator|&&
name|tag
operator|!=
name|GCOV_TAG_OBJECT_SUMMARY
operator|)
condition|)
goto|goto
name|read_mismatch
goto|;
name|gcov_read_summary
argument_list|(
name|is_program
condition|?
operator|&
name|program
else|:
operator|&
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|gcov_is_error
argument_list|()
operator|)
condition|)
goto|goto
name|read_error
goto|;
if|if
condition|(
name|is_program
operator|&&
name|program
operator|.
name|checksum
operator|==
name|gcov_crc32
condition|)
block|{
name|summary_pos
operator|=
name|base
expr_stmt|;
goto|goto
name|rewrite
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|gcov_is_eof
argument_list|()
condition|)
block|{
name|read_error
label|:
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|error
operator|<
literal|0
condition|?
literal|"profiling:%s:Overflow merging\n"
else|:
literal|"profiling:%s:Error merging\n"
argument_list|,
name|gi_ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
goto|goto
name|read_fatal
goto|;
block|}
name|rewrite
label|:
empty_stmt|;
name|gcov_rewrite
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|summary_pos
condition|)
name|memset
argument_list|(
operator|&
name|program
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|program
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Merge the summaries.  */
name|f_ix
operator|=
operator|~
literal|0u
expr_stmt|;
for|for
control|(
name|t_ix
operator|=
literal|0
init|;
name|t_ix
operator|<
name|GCOV_COUNTERS_SUMMABLE
condition|;
name|t_ix
operator|++
control|)
block|{
name|cs_obj
operator|=
operator|&
name|object
operator|.
name|ctrs
index|[
name|t_ix
index|]
expr_stmt|;
name|cs_tobj
operator|=
operator|&
name|this_object
operator|.
name|ctrs
index|[
name|t_ix
index|]
expr_stmt|;
name|cs_prg
operator|=
operator|&
name|program
operator|.
name|ctrs
index|[
name|t_ix
index|]
expr_stmt|;
name|cs_tprg
operator|=
operator|&
name|this_program
operator|.
name|ctrs
index|[
name|t_ix
index|]
expr_stmt|;
name|cs_all
operator|=
operator|&
name|all
operator|.
name|ctrs
index|[
name|t_ix
index|]
expr_stmt|;
if|if
condition|(
operator|(
literal|1
operator|<<
name|t_ix
operator|)
operator|&
name|gi_ptr
operator|->
name|ctr_mask
condition|)
block|{
if|if
condition|(
operator|!
name|cs_obj
operator|->
name|runs
operator|++
condition|)
name|cs_obj
operator|->
name|num
operator|=
name|cs_tobj
operator|->
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|cs_obj
operator|->
name|num
operator|!=
name|cs_tobj
operator|->
name|num
condition|)
goto|goto
name|read_mismatch
goto|;
name|cs_obj
operator|->
name|sum_all
operator|+=
name|cs_tobj
operator|->
name|sum_all
expr_stmt|;
if|if
condition|(
name|cs_obj
operator|->
name|run_max
operator|<
name|cs_tobj
operator|->
name|run_max
condition|)
name|cs_obj
operator|->
name|run_max
operator|=
name|cs_tobj
operator|->
name|run_max
expr_stmt|;
name|cs_obj
operator|->
name|sum_max
operator|+=
name|cs_tobj
operator|->
name|run_max
expr_stmt|;
if|if
condition|(
operator|!
name|cs_prg
operator|->
name|runs
operator|++
condition|)
name|cs_prg
operator|->
name|num
operator|=
name|cs_tprg
operator|->
name|num
expr_stmt|;
elseif|else
if|if
condition|(
name|cs_prg
operator|->
name|num
operator|!=
name|cs_tprg
operator|->
name|num
condition|)
goto|goto
name|read_mismatch
goto|;
name|cs_prg
operator|->
name|sum_all
operator|+=
name|cs_tprg
operator|->
name|sum_all
expr_stmt|;
if|if
condition|(
name|cs_prg
operator|->
name|run_max
operator|<
name|cs_tprg
operator|->
name|run_max
condition|)
name|cs_prg
operator|->
name|run_max
operator|=
name|cs_tprg
operator|->
name|run_max
expr_stmt|;
name|cs_prg
operator|->
name|sum_max
operator|+=
name|cs_tprg
operator|->
name|run_max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cs_obj
operator|->
name|num
operator|||
name|cs_prg
operator|->
name|num
condition|)
goto|goto
name|read_mismatch
goto|;
if|if
condition|(
operator|!
name|cs_all
operator|->
name|runs
operator|&&
name|cs_prg
operator|->
name|runs
condition|)
name|memcpy
argument_list|(
name|cs_all
argument_list|,
name|cs_prg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cs_all
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|all
operator|.
name|checksum
operator|&&
operator|(
operator|!
name|GCOV_LOCKED
operator|||
name|cs_all
operator|->
name|runs
operator|==
name|cs_prg
operator|->
name|runs
operator|)
operator|&&
name|memcmp
argument_list|(
name|cs_all
argument_list|,
name|cs_prg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cs_all
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"profiling:%s:Invocation mismatch - some data files may have been removed%s"
argument_list|,
name|gi_ptr
operator|->
name|filename
argument_list|,
name|GCOV_LOCKED
condition|?
literal|""
else|:
literal|" or concurrent update without locking support"
argument_list|)
expr_stmt|;
name|all
operator|.
name|checksum
operator|=
operator|~
literal|0u
expr_stmt|;
block|}
block|}
name|c_ix
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t_ix
operator|=
literal|0
init|;
name|t_ix
operator|<
name|GCOV_COUNTERS
condition|;
name|t_ix
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|t_ix
operator|)
operator|&
name|gi_ptr
operator|->
name|ctr_mask
condition|)
block|{
name|values
index|[
name|c_ix
index|]
operator|=
name|gi_ptr
operator|->
name|counts
index|[
name|c_ix
index|]
operator|.
name|values
expr_stmt|;
name|c_ix
operator|++
expr_stmt|;
block|}
name|program
operator|.
name|checksum
operator|=
name|gcov_crc32
expr_stmt|;
comment|/* Write out the data.  */
name|gcov_write_tag_length
argument_list|(
name|GCOV_DATA_MAGIC
argument_list|,
name|GCOV_VERSION
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|gi_ptr
operator|->
name|stamp
argument_list|)
expr_stmt|;
comment|/* Write execution counts for each function.  */
for|for
control|(
name|f_ix
operator|=
literal|0
init|;
name|f_ix
operator|<
name|gi_ptr
operator|->
name|n_functions
condition|;
name|f_ix
operator|++
control|)
block|{
name|fi_ptr
operator|=
operator|(
specifier|const
expr|struct
name|gcov_fn_info
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|gi_ptr
operator|->
name|functions
operator|+
name|f_ix
operator|*
name|fi_stride
operator|)
expr_stmt|;
comment|/* Announce function.  */
name|gcov_write_tag_length
argument_list|(
name|GCOV_TAG_FUNCTION
argument_list|,
name|GCOV_TAG_FUNCTION_LENGTH
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|fi_ptr
operator|->
name|ident
argument_list|)
expr_stmt|;
name|gcov_write_unsigned
argument_list|(
name|fi_ptr
operator|->
name|checksum
argument_list|)
expr_stmt|;
name|c_ix
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t_ix
operator|=
literal|0
init|;
name|t_ix
operator|<
name|GCOV_COUNTERS
condition|;
name|t_ix
operator|++
control|)
block|{
name|gcov_type
modifier|*
name|c_ptr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
literal|1
operator|<<
name|t_ix
operator|)
operator|&
name|gi_ptr
operator|->
name|ctr_mask
operator|)
condition|)
continue|continue;
name|n_counts
operator|=
name|fi_ptr
operator|->
name|n_ctrs
index|[
name|c_ix
index|]
expr_stmt|;
name|gcov_write_tag_length
argument_list|(
name|GCOV_TAG_FOR_COUNTER
argument_list|(
name|t_ix
argument_list|)
argument_list|,
name|GCOV_TAG_COUNTER_LENGTH
argument_list|(
name|n_counts
argument_list|)
argument_list|)
expr_stmt|;
name|c_ptr
operator|=
name|values
index|[
name|c_ix
index|]
expr_stmt|;
while|while
condition|(
name|n_counts
operator|--
condition|)
name|gcov_write_counter
argument_list|(
operator|*
name|c_ptr
operator|++
argument_list|)
expr_stmt|;
name|values
index|[
name|c_ix
index|]
operator|=
name|c_ptr
expr_stmt|;
name|c_ix
operator|++
expr_stmt|;
block|}
block|}
comment|/* Object file summary.  */
name|gcov_write_summary
argument_list|(
name|GCOV_TAG_OBJECT_SUMMARY
argument_list|,
operator|&
name|object
argument_list|)
expr_stmt|;
comment|/* Generate whole program statistics.  */
name|gcov_seek
argument_list|(
name|summary_pos
argument_list|)
expr_stmt|;
name|gcov_write_summary
argument_list|(
name|GCOV_TAG_PROGRAM_SUMMARY
argument_list|,
operator|&
name|program
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|gcov_close
argument_list|()
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|error
operator|<
literal|0
condition|?
literal|"profiling:%s:Overflow writing\n"
else|:
literal|"profiling:%s:Error writing\n"
argument_list|,
name|gi_ptr
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a new object file onto the bb chain.  Invoked automatically    when running an object file's global ctors.  */
end_comment

begin_function
name|void
name|__gcov_init
parameter_list|(
name|struct
name|gcov_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|version
condition|)
return|return;
if|if
condition|(
name|gcov_version
argument_list|(
name|info
argument_list|,
name|info
operator|->
name|version
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|ptr
init|=
name|info
operator|->
name|filename
decl_stmt|;
name|gcov_unsigned_t
name|crc32
init|=
name|gcov_crc32
decl_stmt|;
do|do
block|{
name|unsigned
name|ix
decl_stmt|;
name|gcov_unsigned_t
name|value
init|=
operator|*
name|ptr
operator|<<
literal|24
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|8
init|;
name|ix
operator|--
condition|;
name|value
operator|<<=
literal|1
control|)
block|{
name|gcov_unsigned_t
name|feedback
decl_stmt|;
name|feedback
operator|=
operator|(
name|value
operator|^
name|crc32
operator|)
operator|&
literal|0x80000000
condition|?
literal|0x04c11db7
else|:
literal|0
expr_stmt|;
name|crc32
operator|<<=
literal|1
expr_stmt|;
name|crc32
operator|^=
name|feedback
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|ptr
operator|++
condition|)
do|;
name|gcov_crc32
operator|=
name|crc32
expr_stmt|;
if|if
condition|(
operator|!
name|gcov_list
condition|)
name|atexit
argument_list|(
name|gcov_exit
argument_list|)
expr_stmt|;
name|info
operator|->
name|next
operator|=
name|gcov_list
expr_stmt|;
name|gcov_list
operator|=
name|info
expr_stmt|;
block|}
name|info
operator|->
name|version
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called before fork or exec - write out profile information gathered so    far and reset it to zero.  This avoids duplication or loss of the    profile information gathered so far.  */
end_comment

begin_function
name|void
name|__gcov_flush
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|gcov_info
modifier|*
name|gi_ptr
decl_stmt|;
name|gcov_exit
argument_list|()
expr_stmt|;
for|for
control|(
name|gi_ptr
operator|=
name|gcov_list
init|;
name|gi_ptr
condition|;
name|gi_ptr
operator|=
name|gi_ptr
operator|->
name|next
control|)
block|{
name|unsigned
name|t_ix
decl_stmt|;
specifier|const
name|struct
name|gcov_ctr_info
modifier|*
name|ci_ptr
decl_stmt|;
for|for
control|(
name|t_ix
operator|=
literal|0
operator|,
name|ci_ptr
operator|=
name|gi_ptr
operator|->
name|counts
init|;
name|t_ix
operator|!=
name|GCOV_COUNTERS
condition|;
name|t_ix
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|t_ix
operator|)
operator|&
name|gi_ptr
operator|->
name|ctr_mask
condition|)
block|{
name|memset
argument_list|(
name|ci_ptr
operator|->
name|values
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gcov_type
argument_list|)
operator|*
name|ci_ptr
operator|->
name|num
argument_list|)
expr_stmt|;
name|ci_ptr
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_gcov */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|L_gcov_merge_add
end_ifdef

begin_comment
comment|/* The profile merging function that just adds the counters.  It is given    an array COUNTERS of N_COUNTERS old counters and it reads the same number    of counters from the gcov file.  */
end_comment

begin_function
name|void
name|__gcov_merge_add
parameter_list|(
name|gcov_type
modifier|*
name|counters
parameter_list|,
name|unsigned
name|n_counters
parameter_list|)
block|{
for|for
control|(
init|;
name|n_counters
condition|;
name|counters
operator|++
operator|,
name|n_counters
operator|--
control|)
operator|*
name|counters
operator|+=
name|gcov_read_counter
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_gcov_merge_add */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|L_gcov_merge_single
end_ifdef

begin_comment
comment|/* The profile merging function for choosing the most common value.    It is given an array COUNTERS of N_COUNTERS old counters and it    reads the same number of counters from the gcov file.  The counters    are split into 3-tuples where the members of the tuple have    meanings:        -- the stored candidate on the most common value of the measured entity    -- counter    -- total number of evaluations of the value  */
end_comment

begin_function
name|void
name|__gcov_merge_single
parameter_list|(
name|gcov_type
modifier|*
name|counters
parameter_list|,
name|unsigned
name|n_counters
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|n_measures
decl_stmt|;
name|gcov_type
name|value
decl_stmt|,
name|counter
decl_stmt|,
name|all
decl_stmt|;
name|GCOV_CHECK
argument_list|(
operator|!
operator|(
name|n_counters
operator|%
literal|3
operator|)
argument_list|)
expr_stmt|;
name|n_measures
operator|=
name|n_counters
operator|/
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_measures
condition|;
name|i
operator|++
operator|,
name|counters
operator|+=
literal|3
control|)
block|{
name|value
operator|=
name|gcov_read_counter
argument_list|()
expr_stmt|;
name|counter
operator|=
name|gcov_read_counter
argument_list|()
expr_stmt|;
name|all
operator|=
name|gcov_read_counter
argument_list|()
expr_stmt|;
if|if
condition|(
name|counters
index|[
literal|0
index|]
operator|==
name|value
condition|)
name|counters
index|[
literal|1
index|]
operator|+=
name|counter
expr_stmt|;
elseif|else
if|if
condition|(
name|counter
operator|>
name|counters
index|[
literal|1
index|]
condition|)
block|{
name|counters
index|[
literal|0
index|]
operator|=
name|value
expr_stmt|;
name|counters
index|[
literal|1
index|]
operator|=
name|counter
operator|-
name|counters
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
name|counters
index|[
literal|1
index|]
operator|-=
name|counter
expr_stmt|;
name|counters
index|[
literal|2
index|]
operator|+=
name|all
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_gcov_merge_single */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|L_gcov_merge_delta
end_ifdef

begin_comment
comment|/* The profile merging function for choosing the most common    difference between two consecutive evaluations of the value.  It is    given an array COUNTERS of N_COUNTERS old counters and it reads the    same number of counters from the gcov file.  The counters are split    into 4-tuples where the members of the tuple have meanings:        -- the last value of the measured entity    -- the stored candidate on the most common difference    -- counter    -- total number of evaluations of the value  */
end_comment

begin_function
name|void
name|__gcov_merge_delta
parameter_list|(
name|gcov_type
modifier|*
name|counters
parameter_list|,
name|unsigned
name|n_counters
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|n_measures
decl_stmt|;
name|gcov_type
name|last
decl_stmt|,
name|value
decl_stmt|,
name|counter
decl_stmt|,
name|all
decl_stmt|;
name|GCOV_CHECK
argument_list|(
operator|!
operator|(
name|n_counters
operator|%
literal|4
operator|)
argument_list|)
expr_stmt|;
name|n_measures
operator|=
name|n_counters
operator|/
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_measures
condition|;
name|i
operator|++
operator|,
name|counters
operator|+=
literal|4
control|)
block|{
name|last
operator|=
name|gcov_read_counter
argument_list|()
expr_stmt|;
name|value
operator|=
name|gcov_read_counter
argument_list|()
expr_stmt|;
name|counter
operator|=
name|gcov_read_counter
argument_list|()
expr_stmt|;
name|all
operator|=
name|gcov_read_counter
argument_list|()
expr_stmt|;
if|if
condition|(
name|counters
index|[
literal|1
index|]
operator|==
name|value
condition|)
name|counters
index|[
literal|2
index|]
operator|+=
name|counter
expr_stmt|;
elseif|else
if|if
condition|(
name|counter
operator|>
name|counters
index|[
literal|2
index|]
condition|)
block|{
name|counters
index|[
literal|1
index|]
operator|=
name|value
expr_stmt|;
name|counters
index|[
literal|2
index|]
operator|=
name|counter
operator|-
name|counters
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
name|counters
index|[
literal|2
index|]
operator|-=
name|counter
expr_stmt|;
name|counters
index|[
literal|3
index|]
operator|+=
name|all
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L_gcov_merge_delta */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* inhibit_libc */
end_comment

end_unit

