begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Demangler for GNU C++     Copyright 1989, 1991, 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.    Written by James Clark (jjc@jclark.uucp)    Rewritten by Fred Fish (fnf@cygnus.com) for ARM and Lucid demangling     This file is part of the libiberty library. Libiberty is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  Libiberty is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public License for more details.  You should have received a copy of the GNU Library General Public License along with libiberty; see the file COPYING.LIB.  If not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file exports two functions; cplus_mangle_opname and cplus_demangle.     This file imports xmalloc and xrealloc, which are like malloc and    realloc except that they generate a fatal error if there is no    available memory.  */
end_comment

begin_comment
comment|/* This file lives in both GCC and libiberty.  When making changes, please    try not to break either.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<demangle.h>
end_include

begin_undef
undef|#
directive|undef
name|CURRENT_DEMANGLING_STYLE
end_undef

begin_define
define|#
directive|define
name|CURRENT_DEMANGLING_STYLE
value|work->options
end_define

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xmalloc
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|xrealloc
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mystrstr
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mystrstr
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|const
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
specifier|const
name|char
modifier|*
name|p
init|=
name|s1
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|;
for|for
control|(
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
operator|*
name|s2
argument_list|)
operator|)
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
name|s2
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* In order to allow a single demangler executable to demangle strings    using various common values of CPLUS_MARKER, as well as any specific    one set at compile time, we maintain a string containing all the    commonly used ones, and check to see if the marker we are looking for    is in that string.  CPLUS_MARKER is usually '$' on systems where the    assembler can deal with that.  Where the assembler can't, it's usually    '.' (but on many systems '.' is used for other things).  We put the    current defined CPLUS_MARKER first (which defaults to '$'), followed    by the next most common value, followed by an explicit '$' in case    the value of CPLUS_MARKER is not '$'.     We could avoid this if we could just get g++ to tell us what the actual    cplus marker character is as part of the debug information, perhaps by    ensuring that it is the character that terminates the gcc<n>_compiled    marker symbol (FIXME).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CPLUS_MARKER
argument_list|)
end_if

begin_define
define|#
directive|define
name|CPLUS_MARKER
value|'$'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|enum
name|demangling_styles
name|current_demangling_style
init|=
name|gnu_demangling
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cplus_markers
index|[]
init|=
block|{
name|CPLUS_MARKER
block|,
literal|'.'
block|,
literal|'$'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|set_cplus_marker_for_demangling
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
name|cplus_markers
index|[
literal|0
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|string
comment|/* Beware: these aren't required to be */
block|{
comment|/*  '\0' terminated.  */
name|char
modifier|*
name|b
decl_stmt|;
comment|/* pointer to start of string */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* pointer after last character */
name|char
modifier|*
name|e
decl_stmt|;
comment|/* pointer after end of allocated space */
block|}
name|string
typedef|;
end_typedef

begin_comment
comment|/* Stuff that is shared between sub-routines.    Using a shared structure allows cplus_demangle to be reentrant.  */
end_comment

begin_struct
struct|struct
name|work_stuff
block|{
name|int
name|options
decl_stmt|;
name|char
modifier|*
modifier|*
name|typevec
decl_stmt|;
name|char
modifier|*
modifier|*
name|ktypevec
decl_stmt|;
name|char
modifier|*
modifier|*
name|btypevec
decl_stmt|;
name|int
name|numk
decl_stmt|;
name|int
name|numb
decl_stmt|;
name|int
name|ksize
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|ntypes
decl_stmt|;
name|int
name|typevec_size
decl_stmt|;
name|int
name|constructor
decl_stmt|;
name|int
name|destructor
decl_stmt|;
name|int
name|static_type
decl_stmt|;
comment|/* A static member function */
name|int
name|const_type
decl_stmt|;
comment|/* A const member function */
name|int
name|volatile_type
decl_stmt|;
comment|/* A volatile member function */
name|char
modifier|*
modifier|*
name|tmpl_argvec
decl_stmt|;
comment|/* Template function arguments. */
name|int
name|ntmpl_args
decl_stmt|;
comment|/* The number of template function arguments. */
name|int
name|forgetting_types
decl_stmt|;
comment|/* Nonzero if we are not remembering the types 			   we see.  */
name|string
modifier|*
name|previous_argument
decl_stmt|;
comment|/* The last function argument demangled.  */
name|int
name|nrepeats
decl_stmt|;
comment|/* The number of times to repeat the previous 			   argument.  */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PRINT_ANSI_QUALIFIERS
value|(work -> options& DMGL_ANSI)
end_define

begin_define
define|#
directive|define
name|PRINT_ARG_TYPES
value|(work -> options& DMGL_PARAMS)
end_define

begin_struct
specifier|static
specifier|const
struct|struct
name|optable
block|{
specifier|const
name|char
modifier|*
name|in
decl_stmt|;
specifier|const
name|char
modifier|*
name|out
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
name|optable
index|[]
init|=
block|{
block|{
literal|"nw"
block|,
literal|" new"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* new (1.92,	 ansi) */
block|{
literal|"dl"
block|,
literal|" delete"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* new (1.92,	 ansi) */
block|{
literal|"new"
block|,
literal|" new"
block|,
literal|0
block|}
block|,
comment|/* old (1.91,	 and 1.x) */
block|{
literal|"delete"
block|,
literal|" delete"
block|,
literal|0
block|}
block|,
comment|/* old (1.91,	 and 1.x) */
block|{
literal|"vn"
block|,
literal|" new []"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* GNU, pending ansi */
block|{
literal|"vd"
block|,
literal|" delete []"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* GNU, pending ansi */
block|{
literal|"as"
block|,
literal|"="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"ne"
block|,
literal|"!="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old, ansi */
block|{
literal|"eq"
block|,
literal|"=="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"ge"
block|,
literal|">="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"gt"
block|,
literal|">"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"le"
block|,
literal|"<="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"lt"
block|,
literal|"<"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* old,	ansi */
block|{
literal|"plus"
block|,
literal|"+"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"pl"
block|,
literal|"+"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"apl"
block|,
literal|"+="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"minus"
block|,
literal|"-"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mi"
block|,
literal|"-"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"ami"
block|,
literal|"-="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"mult"
block|,
literal|"*"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"ml"
block|,
literal|"*"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"amu"
block|,
literal|"*="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi (ARM/Lucid) */
block|{
literal|"aml"
block|,
literal|"*="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi (GNU/g++) */
block|{
literal|"convert"
block|,
literal|"+"
block|,
literal|0
block|}
block|,
comment|/* old (unary +) */
block|{
literal|"negate"
block|,
literal|"-"
block|,
literal|0
block|}
block|,
comment|/* old (unary -) */
block|{
literal|"trunc_mod"
block|,
literal|"%"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"md"
block|,
literal|"%"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"amd"
block|,
literal|"%="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"trunc_div"
block|,
literal|"/"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"dv"
block|,
literal|"/"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"adv"
block|,
literal|"/="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"truth_andif"
block|,
literal|"&&"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"aa"
block|,
literal|"&&"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"truth_orif"
block|,
literal|"||"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"oo"
block|,
literal|"||"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"truth_not"
block|,
literal|"!"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"nt"
block|,
literal|"!"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"postincrement"
block|,
literal|"++"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"pp"
block|,
literal|"++"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"postdecrement"
block|,
literal|"--"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mm"
block|,
literal|"--"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_ior"
block|,
literal|"|"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"or"
block|,
literal|"|"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"aor"
block|,
literal|"|="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_xor"
block|,
literal|"^"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"er"
block|,
literal|"^"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"aer"
block|,
literal|"^="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_and"
block|,
literal|"&"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"ad"
block|,
literal|"&"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"aad"
block|,
literal|"&="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"bit_not"
block|,
literal|"~"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"co"
block|,
literal|"~"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"call"
block|,
literal|"()"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"cl"
block|,
literal|"()"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"alshift"
block|,
literal|"<<"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"ls"
block|,
literal|"<<"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"als"
block|,
literal|"<<="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"arshift"
block|,
literal|">>"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"rs"
block|,
literal|">>"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"ars"
block|,
literal|">>="
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"component"
block|,
literal|"->"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"pt"
block|,
literal|"->"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi; Lucid C++ form */
block|{
literal|"rf"
block|,
literal|"->"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi; ARM/GNU form */
block|{
literal|"indirect"
block|,
literal|"*"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"method_call"
block|,
literal|"->()"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"addr"
block|,
literal|"&"
block|,
literal|0
block|}
block|,
comment|/* old (unary&) */
block|{
literal|"array"
block|,
literal|"[]"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"vc"
block|,
literal|"[]"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"compound"
block|,
literal|", "
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"cm"
block|,
literal|", "
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"cond"
block|,
literal|"?:"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"cn"
block|,
literal|"?:"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* pseudo-ansi */
block|{
literal|"max"
block|,
literal|">?"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mx"
block|,
literal|">?"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* pseudo-ansi */
block|{
literal|"min"
block|,
literal|"<?"
block|,
literal|0
block|}
block|,
comment|/* old */
block|{
literal|"mn"
block|,
literal|"<?"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* pseudo-ansi */
block|{
literal|"nop"
block|,
literal|""
block|,
literal|0
block|}
block|,
comment|/* old (for operator=) */
block|{
literal|"rm"
block|,
literal|"->*"
block|,
name|DMGL_ANSI
block|}
block|,
comment|/* ansi */
block|{
literal|"sz"
block|,
literal|"sizeof "
block|,
name|DMGL_ANSI
block|}
comment|/* pseudo-ansi */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|STRING_EMPTY
parameter_list|(
name|str
parameter_list|)
value|((str) -> b == (str) -> p)
end_define

begin_define
define|#
directive|define
name|PREPEND_BLANK
parameter_list|(
name|str
parameter_list|)
value|{if (!STRING_EMPTY(str)) \     string_prepend(str, " ");}
end_define

begin_define
define|#
directive|define
name|APPEND_BLANK
parameter_list|(
name|str
parameter_list|)
value|{if (!STRING_EMPTY(str)) \     string_append(str, " ");}
end_define

begin_define
define|#
directive|define
name|LEN_STRING
parameter_list|(
name|str
parameter_list|)
value|( (STRING_EMPTY(str))?0:((str)->p - (str)->b))
end_define

begin_comment
comment|/* The scope separator appropriate for the language being demangled.  */
end_comment

begin_define
define|#
directive|define
name|SCOPE_STRING
parameter_list|(
name|work
parameter_list|)
value|"::"
end_define

begin_define
define|#
directive|define
name|ARM_VTABLE_STRING
value|"__vtbl__"
end_define

begin_comment
comment|/* Lucid/ARM virtual table prefix */
end_comment

begin_define
define|#
directive|define
name|ARM_VTABLE_STRLEN
value|8
end_define

begin_comment
comment|/* strlen (ARM_VTABLE_STRING) */
end_comment

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mop_up
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
name|string
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|squangle_mop_up
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int demangle_method_args PARAMS ((struct work_stuff *, const char **, string *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|internal_cplus_demangle
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_template_template_parm
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
name|work
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_template
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
name|work
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
name|string
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_pt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|demangle_arm_pt
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_class_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_qualified
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_class
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_fund_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_signature
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_prefix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gnu_special
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|arm_special
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_need
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_delete
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_init
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_clear
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int string_empty PARAMS ((string *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|string_append
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_appends
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_appendn
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_prepend
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_prependn
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_count
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|consume_count
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|consume_count_with_underscores
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_nested_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_arg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|demangle_function_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remember_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remember_Btype
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|register_Btype
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remember_Ktype
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forget_types
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|forget_B_and_K_types
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|string_prepends
name|PARAMS
argument_list|(
operator|(
name|string
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|demangle_template_value_parm
name|PARAMS
argument_list|(
operator|(
expr|struct
name|work_stuff
operator|*
operator|,
specifier|const
name|char
operator|*
operator|*
operator|,
name|string
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Translate count to integer, consuming tokens in the process.     Conversion terminates on the first non-digit character.     Trying to consume something that isn't a count results in     no consumption of input and a return of 0.  */
end_comment

begin_function
specifier|static
name|int
name|consume_count
parameter_list|(
name|type
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|type
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
block|{
name|count
operator|*=
literal|10
expr_stmt|;
name|count
operator|+=
operator|*
operator|*
name|type
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|type
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like consume_count, but for counts that are preceded and followed    by '_' if they are greater than 10.  Also, -1 is returned for    failure, since 0 can be a valid value.  */
end_comment

begin_function
specifier|static
name|int
name|consume_count_with_underscores
parameter_list|(
name|mangled
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|idx
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|)
comment|/* The trailing underscore was missing. */
return|return
operator|-
literal|1
return|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
operator|*
name|mangled
operator|<
literal|'0'
operator|||
operator|*
operator|*
name|mangled
operator|>
literal|'9'
condition|)
return|return
operator|-
literal|1
return|;
name|idx
operator|=
operator|*
operator|*
name|mangled
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
end_function

begin_function
name|int
name|cplus_demangle_opname
parameter_list|(
name|opname
parameter_list|,
name|result
parameter_list|,
name|options
parameter_list|)
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|len1
decl_stmt|,
name|ret
decl_stmt|;
name|string
name|type
decl_stmt|;
name|struct
name|work_stuff
name|work
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|tem
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|->
name|options
operator|=
name|options
expr_stmt|;
if|if
condition|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|opname
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|opname
index|[
literal|2
index|]
operator|==
literal|'o'
operator|&&
name|opname
index|[
literal|3
index|]
operator|==
literal|'p'
condition|)
block|{
comment|/* ANSI.  */
comment|/* type conversion operator.  */
name|tem
operator|=
name|opname
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|result
argument_list|,
name|type
operator|.
name|b
argument_list|,
name|type
operator|.
name|p
operator|-
name|type
operator|.
name|b
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|opname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|opname
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|opname
index|[
literal|2
index|]
operator|>=
literal|'a'
operator|&&
name|opname
index|[
literal|2
index|]
operator|<=
literal|'z'
operator|&&
name|opname
index|[
literal|3
index|]
operator|>=
literal|'a'
operator|&&
name|opname
index|[
literal|3
index|]
operator|<=
literal|'z'
condition|)
block|{
if|if
condition|(
name|opname
index|[
literal|4
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Operator.  */
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
literal|2
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|opname
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|opname
index|[
literal|2
index|]
operator|==
literal|'a'
operator|&&
name|opname
index|[
literal|5
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Assignment.  */
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
literal|3
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|opname
operator|+
literal|2
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|>=
literal|3
operator|&&
name|opname
index|[
literal|0
index|]
operator|==
literal|'o'
operator|&&
name|opname
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
name|opname
index|[
literal|2
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* see if it's an assignment expression */
if|if
condition|(
name|len
operator|>=
literal|10
comment|/* op$assign_ */
operator|&&
name|memcmp
argument_list|(
name|opname
operator|+
literal|3
argument_list|,
literal|"assign_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|len1
operator|=
name|len
operator|-
literal|10
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len1
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|opname
operator|+
literal|10
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|len1
operator|=
name|len
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len1
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|opname
operator|+
literal|3
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|>=
literal|5
operator|&&
name|memcmp
argument_list|(
name|opname
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
name|opname
index|[
literal|4
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* type conversion operator */
name|tem
operator|=
name|opname
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|result
argument_list|,
name|type
operator|.
name|b
argument_list|,
name|type
operator|.
name|p
operator|-
name|type
operator|.
name|b
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|squangle_mop_up
argument_list|(
name|work
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Takes operator name as e.g. "++" and returns mangled    operator name (e.g. "postincrement_expr"), or NULL if not found.     If OPTIONS& DMGL_ANSI == 1, return the ANSI name;    if OPTIONS& DMGL_ANSI == 0, return the old GNU name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cplus_mangle_opname
parameter_list|(
name|opname
parameter_list|,
name|options
parameter_list|)
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|opname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
operator|==
name|len
operator|&&
operator|(
name|options
operator|&
name|DMGL_ANSI
operator|)
operator|==
operator|(
name|optable
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|DMGL_ANSI
operator|)
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|,
name|opname
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|optable
index|[
name|i
index|]
operator|.
name|in
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* char *cplus_demangle (const char *mangled, int options)     If MANGLED is a mangled function name produced by GNU C++, then    a pointer to a malloced string giving a C++ representation    of the name will be returned; otherwise NULL will be returned.    It is the caller's responsibility to free the string which    is returned.     The OPTIONS arg may contain one or more of the following bits:     	DMGL_ANSI	ANSI qualifiers such as `const' and `void' are 			included. 	DMGL_PARAMS	Function parameters are included.     For example,        cplus_demangle ("foo__1Ai", DMGL_PARAMS)		=> "A::foo(int)"    cplus_demangle ("foo__1Ai", DMGL_PARAMS | DMGL_ANSI)	=> "A::foo(int)"    cplus_demangle ("foo__1Ai", 0)			=> "A::foo"     cplus_demangle ("foo__1Afe", DMGL_PARAMS)		=> "A::foo(float,...)"    cplus_demangle ("foo__1Afe", DMGL_PARAMS | DMGL_ANSI)=> "A::foo(float,...)"    cplus_demangle ("foo__1Afe", 0)			=> "A::foo"     Note that any leading underscores, or other such characters prepended by    the compilation system, are presumed to have already been stripped from    MANGLED.  */
end_comment

begin_function
name|char
modifier|*
name|cplus_demangle
parameter_list|(
name|mangled
parameter_list|,
name|options
parameter_list|)
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
name|int
name|options
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|struct
name|work_stuff
name|work
index|[
literal|1
index|]
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|->
name|options
operator|=
name|options
expr_stmt|;
if|if
condition|(
operator|(
name|work
operator|->
name|options
operator|&
name|DMGL_STYLE_MASK
operator|)
operator|==
literal|0
condition|)
name|work
operator|->
name|options
operator||=
operator|(
name|int
operator|)
name|current_demangling_style
operator|&
name|DMGL_STYLE_MASK
expr_stmt|;
name|ret
operator|=
name|internal_cplus_demangle
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|)
expr_stmt|;
name|squangle_mop_up
argument_list|(
name|work
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This function performs most of what cplus_demangle use to do, but     to be able to demangle a name with a B, K or n code, we need to    have a longer term memory of what types have been seen. The original    now intializes and cleans up the squangle code info, while internal    calls go directly to this routine to avoid resetting that info. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|internal_cplus_demangle
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
block|{
name|string
name|decl
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|demangled
init|=
name|NULL
decl_stmt|;
name|int
name|s1
decl_stmt|,
name|s2
decl_stmt|,
name|s3
decl_stmt|,
name|s4
decl_stmt|;
name|int
name|saved_volatile_type
decl_stmt|;
name|s1
operator|=
name|work
operator|->
name|constructor
expr_stmt|;
name|s2
operator|=
name|work
operator|->
name|destructor
expr_stmt|;
name|s3
operator|=
name|work
operator|->
name|static_type
expr_stmt|;
name|s4
operator|=
name|work
operator|->
name|const_type
expr_stmt|;
name|saved_volatile_type
operator|=
name|work
operator|->
name|volatile_type
expr_stmt|;
name|work
operator|->
name|constructor
operator|=
name|work
operator|->
name|destructor
operator|=
literal|0
expr_stmt|;
name|work
operator|->
name|static_type
operator|=
name|work
operator|->
name|const_type
operator|=
literal|0
expr_stmt|;
name|work
operator|->
name|volatile_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mangled
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|string_init
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
comment|/* First check to see if gnu style demangling is active and if the 	 string to be demangled contains a CPLUS_MARKER.  If so, attempt to 	 recognize one of the gnu special forms rather than looking for a 	 standard prefix.  In particular, don't worry about whether there 	 is a "__" string in the mangled string.  Consider "_$_5__foo" for 	 example.  */
if|if
condition|(
operator|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
operator|)
condition|)
block|{
name|success
operator|=
name|gnu_special
argument_list|(
name|work
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|success
operator|=
name|demangle_prefix
argument_list|(
name|work
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|&&
operator|(
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|success
operator|=
name|demangle_signature
argument_list|(
name|work
argument_list|,
operator|&
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|->
name|constructor
operator|==
literal|2
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"global constructors keyed to "
argument_list|)
expr_stmt|;
name|work
operator|->
name|constructor
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|work
operator|->
name|destructor
operator|==
literal|2
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"global destructors keyed to "
argument_list|)
expr_stmt|;
name|work
operator|->
name|destructor
operator|=
literal|0
expr_stmt|;
block|}
name|demangled
operator|=
name|mop_up
argument_list|(
name|work
argument_list|,
operator|&
name|decl
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
name|work
operator|->
name|constructor
operator|=
name|s1
expr_stmt|;
name|work
operator|->
name|destructor
operator|=
name|s2
expr_stmt|;
name|work
operator|->
name|static_type
operator|=
name|s3
expr_stmt|;
name|work
operator|->
name|const_type
operator|=
name|s4
expr_stmt|;
name|work
operator|->
name|volatile_type
operator|=
name|saved_volatile_type
expr_stmt|;
return|return
operator|(
name|demangled
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clear out and squangling related storage */
end_comment

begin_function
specifier|static
name|void
name|squangle_mop_up
parameter_list|(
name|work
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
block|{
comment|/* clean up the B and K type mangling types. */
name|forget_B_and_K_types
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|btypevec
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|btypevec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|->
name|ktypevec
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|ktypevec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear out any mangled storage */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mop_up
parameter_list|(
name|work
parameter_list|,
name|declp
parameter_list|,
name|success
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
name|int
name|success
decl_stmt|;
block|{
name|char
modifier|*
name|demangled
init|=
name|NULL
decl_stmt|;
comment|/* Discard the remembered types, if any.  */
name|forget_types
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|typevec
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|typevec
argument_list|)
expr_stmt|;
name|work
operator|->
name|typevec
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|->
name|tmpl_argvec
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|work
operator|->
name|ntmpl_args
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|tmpl_argvec
argument_list|)
expr_stmt|;
name|work
operator|->
name|tmpl_argvec
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|work
operator|->
name|previous_argument
condition|)
block|{
name|string_delete
argument_list|(
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
block|}
comment|/* If demangling was successful, ensure that the demangled string is null      terminated and return it.  Otherwise, free the demangling decl.  */
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|string_delete
argument_list|(
name|declp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|string_appendn
argument_list|(
name|declp
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demangled
operator|=
name|declp
operator|->
name|b
expr_stmt|;
block|}
return|return
operator|(
name|demangled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_signature -- demangle the signature part of a mangled name  SYNOPSIS  	static int 	demangle_signature (struct work_stuff *work, const char **mangled, 			    string *declp);  DESCRIPTION  	Consume and demangle the signature portion of the mangled name.  	DECLP is the string where demangled output is being built.  At 	entry it contains the demangled root name from the mangled name 	prefix.  I.E. either a demangled operator name or the root function 	name.  In some special cases, it may contain nothing.  	*MANGLED points to the current unconsumed location in the mangled 	name.  As tokens are consumed and demangling is performed, the 	pointer is updated to continuously point at the next token to 	be consumed.  	Demangling GNU style mangled names is nasty because there is no 	explicit token that marks the start of the outermost function 	argument list.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_signature
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|success
init|=
literal|1
decl_stmt|;
name|int
name|func_done
init|=
literal|0
decl_stmt|;
name|int
name|expect_func
init|=
literal|0
decl_stmt|;
name|int
name|expect_return_type
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|oldmangled
init|=
name|NULL
decl_stmt|;
name|string
name|trawname
decl_stmt|;
name|string
name|tname
decl_stmt|;
while|while
condition|(
name|success
operator|&&
operator|(
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'Q'
case|:
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|remember_type
argument_list|(
name|work
argument_list|,
name|oldmangled
argument_list|,
operator|*
name|mangled
operator|-
name|oldmangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
name|expect_func
operator|=
literal|1
expr_stmt|;
name|oldmangled
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
name|expect_func
operator|=
literal|1
expr_stmt|;
block|}
name|oldmangled
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Static member function */
if|if
condition|(
name|oldmangled
operator|==
name|NULL
condition|)
block|{
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|work
operator|->
name|static_type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'V'
case|:
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'C'
condition|)
name|work
operator|->
name|const_type
operator|=
literal|1
expr_stmt|;
else|else
name|work
operator|->
name|volatile_type
operator|=
literal|1
expr_stmt|;
comment|/* a qualified member function */
if|if
condition|(
name|oldmangled
operator|==
name|NULL
condition|)
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|oldmangled
operator|==
name|NULL
condition|)
block|{
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
block|}
name|success
operator|=
name|demangle_class
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|remember_type
argument_list|(
name|work
argument_list|,
name|oldmangled
argument_list|,
operator|*
name|mangled
operator|-
name|oldmangled
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
name|expect_func
operator|=
literal|1
expr_stmt|;
block|}
name|oldmangled
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
block|{
name|string
name|s
decl_stmt|;
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|string_append
argument_list|(
operator|&
name|s
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
name|oldmangled
operator|=
name|NULL
expr_stmt|;
name|expect_func
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* Function */
comment|/* ARM style demangling includes a specific 'F' character after 	     the class name.  For GNU style, it is just implied.  So we can 	     safely just consume any 'F' at this point and be compatible 	     with either style.  */
name|oldmangled
operator|=
name|NULL
expr_stmt|;
name|func_done
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
comment|/* For lucid/ARM style we have to forget any types we might 	     have remembered up to this point, since they were not argument 	     types.  GNU style considers all types seen as available for 	     back references.  See comment in demangle_args() */
if|if
condition|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
condition|)
block|{
name|forget_types
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* G++ Template */
name|string_init
argument_list|(
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmangled
operator|==
name|NULL
condition|)
block|{
name|oldmangled
operator|=
operator|*
name|mangled
expr_stmt|;
block|}
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|tname
argument_list|,
operator|&
name|trawname
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|remember_type
argument_list|(
name|work
argument_list|,
name|oldmangled
argument_list|,
operator|*
name|mangled
operator|-
name|oldmangled
argument_list|)
expr_stmt|;
block|}
name|string_append
argument_list|(
operator|&
name|tname
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|destructor
operator|&
literal|1
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|trawname
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|work
operator|->
name|destructor
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|work
operator|->
name|constructor
operator|&
literal|1
operator|)
operator|||
operator|(
name|work
operator|->
name|destructor
operator|&
literal|1
operator|)
condition|)
block|{
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|work
operator|->
name|constructor
operator|-=
literal|1
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|trawname
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
name|oldmangled
operator|=
name|NULL
expr_stmt|;
name|expect_func
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
if|if
condition|(
name|GNU_DEMANGLING
operator|&&
name|expect_return_type
condition|)
block|{
comment|/* Read the return type. */
name|string
name|return_type
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|return_type
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|return_type
argument_list|)
expr_stmt|;
name|APPEND_BLANK
argument_list|(
operator|&
name|return_type
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|return_type
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|return_type
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
comment|/* At the outermost level, we cannot have a return type specified, 	       so if we run into another '_' at this point we are dealing with 	       a mangled name that is either bogus, or has been mangled by 	       some algorithm we don't know how to deal with.  So just 	       reject the entire demangling.  */
name|success
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|GNU_DEMANGLING
condition|)
block|{
comment|/* A G++ template function.  Read the template arguments. */
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|work
operator|->
name|constructor
operator|&
literal|1
operator|)
condition|)
name|expect_return_type
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
block|}
else|else
comment|/* fall through */
block|{
empty_stmt|;
block|}
default|default:
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
comment|/* Assume we have stumbled onto the first outermost function 		 argument token, and start processing args.  */
name|func_done
operator|=
literal|1
expr_stmt|;
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Non-GNU demanglers use a specific token to mark the start 		 of the outermost function argument tokens.  Typically 'F', 		 for ARM-demangling, for example.  So if we find something 		 we are not prepared for, it must be an error.  */
name|success
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	if (AUTO_DEMANGLING || GNU_DEMANGLING) 	*/
block|{
if|if
condition|(
name|success
operator|&&
name|expect_func
condition|)
block|{
name|func_done
operator|=
literal|1
expr_stmt|;
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
comment|/* Since template include the mangling of their return types, 	       we must set expect_func to 0 so that we don't try do 	       demangle more arguments the next time we get here.  */
name|expect_func
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|success
operator|&&
operator|!
name|func_done
condition|)
block|{
if|if
condition|(
name|AUTO_DEMANGLING
operator|||
name|GNU_DEMANGLING
condition|)
block|{
comment|/* With GNU style demangling, bar__3foo is 'foo::bar(void)', and 	     bar__3fooi is 'foo::bar(int)'.  We get here when we find the 	     first case, and need to ensure that the '(void)' gets added to 	     the current declp.  Note that with ARM, the first case 	     represents the name of a static data member 'foo::bar', 	     which is in the current declp, so we leave it alone.  */
name|success
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|success
operator|&&
name|work
operator|->
name|static_type
operator|&&
name|PRINT_ARG_TYPES
condition|)
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" static"
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
name|work
operator|->
name|const_type
operator|&&
name|PRINT_ARG_TYPES
condition|)
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" const"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|success
operator|&&
name|work
operator|->
name|volatile_type
operator|&&
name|PRINT_ARG_TYPES
condition|)
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" volatile"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int demangle_method_args (work, mangled, declp)      struct work_stuff *work;      const char **mangled;      string *declp; {   int success = 0;    if (work -> static_type)     {       string_append (declp, *mangled + 1);       *mangled += strlen (*mangled);       success = 1;     }   else     {       success = demangle_args (work, mangled, declp);     }   return (success); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|demangle_template_template_parm
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|tname
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|tname
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
name|string
name|temp
decl_stmt|;
name|string_append
argument_list|(
name|tname
argument_list|,
literal|"template<"
argument_list|)
expr_stmt|;
comment|/* get size of template parameter list */
if|if
condition|(
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|need_comma
condition|)
block|{
name|string_append
argument_list|(
name|tname
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
comment|/* Z for type parameters */
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'Z'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|string_append
argument_list|(
name|tname
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
block|}
comment|/* z for template parameters */
elseif|else
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'z'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|success
operator|=
name|demangle_template_template_parm
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
comment|/* temp is initialized in do_type */
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|string_appends
argument_list|(
name|tname
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
break|break;
block|}
block|}
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tname
operator|->
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
condition|)
name|string_append
argument_list|(
name|tname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|tname
argument_list|,
literal|"> class"
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|demangle_integral_value
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|s
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|success
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'E'
condition|)
block|{
name|int
name|need_operator
init|=
literal|0
decl_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"("
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
while|while
condition|(
name|success
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'W'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|need_operator
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|<=
name|len
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
operator|*
name|mangled
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|s
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|l
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|success
condition|)
break|break;
block|}
else|else
name|need_operator
operator|=
literal|1
expr_stmt|;
name|success
operator|=
name|demangle_template_value_parm
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'W'
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|")"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'Q'
operator|||
operator|*
operator|*
name|mangled
operator|==
literal|'K'
condition|)
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'m'
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
operator|*
name|mangled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
name|success
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|demangle_template_value_parm
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|s
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|s
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|old_p
init|=
operator|*
name|mangled
decl_stmt|;
name|int
name|is_pointer
init|=
literal|0
decl_stmt|;
name|int
name|is_real
init|=
literal|0
decl_stmt|;
name|int
name|is_integral
init|=
literal|0
decl_stmt|;
name|int
name|is_char
init|=
literal|0
decl_stmt|;
name|int
name|is_bool
init|=
literal|0
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|*
name|old_p
operator|&&
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
operator|*
name|old_p
condition|)
block|{
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
case|case
literal|'R'
case|:
name|done
operator|=
name|is_pointer
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* const */
case|case
literal|'S'
case|:
comment|/* explicitly signed [char] */
case|case
literal|'U'
case|:
comment|/* unsigned */
case|case
literal|'V'
case|:
comment|/* volatile */
case|case
literal|'F'
case|:
comment|/* function */
case|case
literal|'M'
case|:
comment|/* member function */
case|case
literal|'O'
case|:
comment|/* ??? */
case|case
literal|'J'
case|:
comment|/* complex */
name|old_p
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'E'
case|:
comment|/* expression */
case|case
literal|'Q'
case|:
comment|/* qualified name */
case|case
literal|'K'
case|:
comment|/* qualified name */
name|done
operator|=
name|is_integral
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* remembered type */
case|case
literal|'T'
case|:
comment|/* remembered type */
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* void */
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* long long */
case|case
literal|'l'
case|:
comment|/* long */
case|case
literal|'i'
case|:
comment|/* int */
case|case
literal|'s'
case|:
comment|/* short */
case|case
literal|'w'
case|:
comment|/* wchar_t */
name|done
operator|=
name|is_integral
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* bool */
name|done
operator|=
name|is_bool
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* char */
name|done
operator|=
name|is_char
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* long double */
case|case
literal|'d'
case|:
comment|/* double */
case|case
literal|'f'
case|:
comment|/* float */
name|done
operator|=
name|is_real
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* it's probably user defined type, let's assume 	     it's integral, it seems hard to figure out 	     what it really is */
name|done
operator|=
name|is_integral
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'Y'
condition|)
block|{
comment|/* The next argument is a template parameter. */
name|int
name|idx
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
operator|(
name|work
operator|->
name|tmpl_argvec
operator|&&
name|idx
operator|>=
name|work
operator|->
name|ntmpl_args
operator|)
operator|||
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|work
operator|->
name|tmpl_argvec
condition|)
name|string_append
argument_list|(
name|s
argument_list|,
name|work
operator|->
name|tmpl_argvec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"T%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|s
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_integral
condition|)
name|success
operator|=
name|demangle_integral_value
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_char
condition|)
block|{
name|char
name|tmp
index|[
literal|2
index|]
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'m'
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|val
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|tmp
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|val
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|string_appendn
argument_list|(
name|s
argument_list|,
operator|&
name|tmp
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_bool
condition|)
block|{
name|int
name|val
init|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"false"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|1
condition|)
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"true"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|success
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_real
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'m'
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
operator|*
name|mangled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'.'
condition|)
comment|/* fraction */
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
operator|*
name|mangled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'e'
condition|)
comment|/* exponent */
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"e"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|string_appendn
argument_list|(
name|s
argument_list|,
operator|*
name|mangled
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|is_pointer
condition|)
block|{
name|int
name|symbol_len
init|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
decl_stmt|;
if|if
condition|(
name|symbol_len
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|symbol_len
operator|==
literal|0
condition|)
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
init|=
name|xmalloc
argument_list|(
name|symbol_len
operator|+
literal|1
argument_list|)
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
operator|*
name|mangled
argument_list|,
name|symbol_len
argument_list|)
expr_stmt|;
name|p
index|[
name|symbol_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|q
operator|=
name|internal_cplus_demangle
argument_list|(
name|work
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|s
argument_list|,
literal|"&"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
name|string_append
argument_list|(
name|s
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|string_append
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
operator|*
name|mangled
operator|+=
name|symbol_len
expr_stmt|;
block|}
return|return
name|success
return|;
block|}
end_function

begin_comment
comment|/* Demangle the template name in MANGLED.  The full name of the    template (e.g., S<int>) is placed in TNAME.  The name without the    template parameters (e.g. S) is placed in TRAWNAME if TRAWNAME is    non-NULL.  If IS_TYPE is nonzero, this template is a type template,    not a function template.  If both IS_TYPE and REMEMBER are nonzero,    the tmeplate is remembered in the list of back-referenceable    types.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_template
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|tname
parameter_list|,
name|trawname
parameter_list|,
name|is_type
parameter_list|,
name|remember
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|tname
decl_stmt|;
name|string
modifier|*
name|trawname
decl_stmt|;
name|int
name|is_type
decl_stmt|;
name|int
name|remember
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|string
name|temp
decl_stmt|;
name|int
name|bindex
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|is_type
condition|)
block|{
if|if
condition|(
name|remember
condition|)
name|bindex
operator|=
name|register_Btype
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|start
operator|=
operator|*
name|mangled
expr_stmt|;
comment|/* get template name */
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'z'
condition|)
block|{
name|int
name|idx
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
operator|(
name|work
operator|->
name|tmpl_argvec
operator|&&
name|idx
operator|>=
name|work
operator|->
name|ntmpl_args
operator|)
operator|||
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|work
operator|->
name|tmpl_argvec
condition|)
block|{
name|string_append
argument_list|(
name|tname
argument_list|,
name|work
operator|->
name|tmpl_argvec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|trawname
condition|)
name|string_append
argument_list|(
name|trawname
argument_list|,
name|work
operator|->
name|tmpl_argvec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"T%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|tname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|trawname
condition|)
name|string_append
argument_list|(
name|trawname
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
operator|)
operator|==
literal|0
operator|||
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|<
name|r
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|string_appendn
argument_list|(
name|tname
argument_list|,
operator|*
name|mangled
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|trawname
condition|)
name|string_appendn
argument_list|(
name|trawname
argument_list|,
operator|*
name|mangled
argument_list|,
name|r
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|r
expr_stmt|;
block|}
block|}
name|string_append
argument_list|(
name|tname
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
comment|/* get size of template parameter list */
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
comment|/* Create an array for saving the template argument values. */
name|work
operator|->
name|tmpl_argvec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|r
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|work
operator|->
name|ntmpl_args
operator|=
name|r
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
condition|;
name|i
operator|++
control|)
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|need_comma
condition|)
block|{
name|string_append
argument_list|(
name|tname
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
comment|/* Z for type parameters */
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'Z'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
comment|/* temp is initialized in do_type */
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|string_appends
argument_list|(
name|tname
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
comment|/* Save the template argument. */
name|int
name|len
init|=
name|temp
operator|.
name|p
operator|-
name|temp
operator|.
name|b
decl_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
argument_list|,
name|temp
operator|.
name|b
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|string_delete
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
break|break;
block|}
block|}
comment|/* z for template parameters */
elseif|else
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'z'
condition|)
block|{
name|int
name|r2
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|success
operator|=
name|demangle_template_template_parm
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
operator|(
name|r2
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
operator|)
operator|>
literal|0
operator|&&
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|>=
name|r2
condition|)
block|{
name|string_append
argument_list|(
name|tname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|tname
argument_list|,
operator|*
name|mangled
argument_list|,
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
comment|/* Save the template argument. */
name|int
name|len
init|=
name|r2
decl_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
argument_list|,
operator|*
name|mangled
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|mangled
operator|+=
name|r2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|string
name|param
decl_stmt|;
name|string
modifier|*
name|s
decl_stmt|;
comment|/* otherwise, value parameter */
comment|/* temp is initialized in do_type */
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
comment|/* 	    if (success) 	    { 	    string_appends (s,&temp); 	    } 	    */
name|string_delete
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
break|break;
block|}
comment|/* 	    string_append (s, "="); 	    */
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
name|s
operator|=
operator|&
name|param
expr_stmt|;
name|string_init
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|=
name|tname
expr_stmt|;
name|success
operator|=
name|demangle_template_value_parm
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
if|if
condition|(
operator|!
name|is_type
condition|)
name|string_delete
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|is_type
condition|)
block|{
name|int
name|len
init|=
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
decl_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
argument_list|,
name|s
operator|->
name|b
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|work
operator|->
name|tmpl_argvec
index|[
name|i
index|]
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|string_appends
argument_list|(
name|tname
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tname
operator|->
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
condition|)
name|string_append
argument_list|(
name|tname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|tname
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_type
operator|&&
name|remember
condition|)
name|remember_Btype
argument_list|(
name|work
argument_list|,
name|tname
operator|->
name|b
argument_list|,
name|LEN_STRING
argument_list|(
name|tname
argument_list|)
argument_list|,
name|bindex
argument_list|)
expr_stmt|;
comment|/*     if (work -> static_type)     {     string_append (declp, *mangled + 1);     *mangled += strlen (*mangled);     success = 1;     }     else     {     success = demangle_args (work, mangled, declp);     }     }     */
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_pt
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|n
parameter_list|,
name|anchor
parameter_list|,
name|args
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
name|mangled
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|anchor
decl_stmt|,
decl|*
modifier|*
name|args
decl_stmt|;
end_function

begin_block
block|{
comment|/* ARM template? */
if|if
condition|(
name|ARM_DEMANGLING
operator|&&
operator|(
operator|*
name|anchor
operator|=
name|mystrstr
argument_list|(
name|mangled
argument_list|,
literal|"__pt__"
argument_list|)
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
operator|*
name|args
operator|=
operator|*
name|anchor
operator|+
literal|6
expr_stmt|;
name|len
operator|=
name|consume_count
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|+
name|len
operator|==
name|mangled
operator|+
name|n
operator|&&
operator|*
operator|*
name|args
operator|==
literal|'_'
condition|)
block|{
operator|++
operator|*
name|args
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|demangle_arm_pt
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|n
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|int
name|n
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|e
init|=
operator|*
name|mangled
operator|+
name|n
decl_stmt|;
comment|/* ARM template? */
if|if
condition|(
name|arm_pt
argument_list|(
name|work
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|args
argument_list|)
condition|)
block|{
name|string
name|arg
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|p
operator|-
operator|*
name|mangled
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
comment|/* should do error checking here */
while|while
condition|(
name|args
operator|<
name|e
condition|)
block|{
name|string_clear
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
operator|--
name|declp
operator|->
name|p
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
operator|*
name|mangled
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|demangle_class_name
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|success
init|=
literal|0
decl_stmt|;
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|>=
name|n
condition|)
block|{
name|demangle_arm_pt
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|n
argument_list|,
name|declp
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_class -- demangle a mangled class sequence  SYNOPSIS  	static int 	demangle_class (struct work_stuff *work, const char **mangled, 			strint *declp)  DESCRIPTION  	DECLP points to the buffer into which demangling is being done.  	*MANGLED points to the current token to be demangled.  On input, 	it points to a mangled class (I.E. "3foo", "13verylongclass", etc.) 	On exit, it points to the next token after the mangled class on 	success, or the first unconsumed token on failure.  	If the CONSTRUCTOR or DESTRUCTOR flags are set in WORK, then 	we are demangling a constructor or destructor.  In this case 	we prepend "class::class" or "class::~class" to DECLP.  	Otherwise, we prepend "class::" to the current DECLP.  	Reset the constructor/destructor flags once they have been 	"consumed".  This allows demangle_class to be called later during 	the same demangling, to do normal class demangling.  	Returns 1 if demangling is successful, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_class
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|success
init|=
literal|0
decl_stmt|;
name|int
name|btype
decl_stmt|;
name|string
name|class_name
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|class_name
argument_list|)
expr_stmt|;
name|btype
operator|=
name|register_Btype
argument_list|(
name|work
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangle_class_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|class_name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|work
operator|->
name|constructor
operator|&
literal|1
operator|)
operator|||
operator|(
name|work
operator|->
name|destructor
operator|&
literal|1
operator|)
condition|)
block|{
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|class_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|destructor
operator|&
literal|1
condition|)
block|{
name|string_prepend
argument_list|(
name|declp
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
name|work
operator|->
name|destructor
operator|-=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|work
operator|->
name|constructor
operator|-=
literal|1
expr_stmt|;
block|}
block|}
name|remember_Ktype
argument_list|(
name|work
argument_list|,
name|class_name
operator|.
name|b
argument_list|,
name|LEN_STRING
argument_list|(
operator|&
name|class_name
argument_list|)
argument_list|)
expr_stmt|;
name|remember_Btype
argument_list|(
name|work
argument_list|,
name|class_name
operator|.
name|b
argument_list|,
name|LEN_STRING
argument_list|(
operator|&
name|class_name
argument_list|)
argument_list|,
name|btype
argument_list|)
expr_stmt|;
name|string_prepend
argument_list|(
name|declp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|declp
argument_list|,
operator|&
name|class_name
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|class_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_prefix -- consume the mangled name prefix and find signature  SYNOPSIS  	static int 	demangle_prefix (struct work_stuff *work, const char **mangled, 			 string *declp);  DESCRIPTION  	Consume and demangle the prefix of the mangled name.  	DECLP points to the string buffer into which demangled output is 	placed.  On entry, the buffer is empty.  On exit it contains 	the root function name, the demangled operator name, or in some 	special cases either nothing or the completely demangled result.  	MANGLED points to the current pointer into the mangled name.  As each 	token of the mangled name is consumed, it is updated.  Upon entry 	the current mangled name pointer points to the first character of 	the mangled name.  Upon exit, it should point to the first character 	of the signature if demangling was successful, or to the first 	unconsumed character if demangling of the prefix was unsuccessful. 	 	Returns 1 on success, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_prefix
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|success
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|>=
literal|11
operator|&&
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"_GLOBAL_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|marker
init|=
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|8
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|marker
operator|!=
name|NULL
operator|&&
operator|*
name|marker
operator|==
operator|(
operator|*
name|mangled
operator|)
index|[
literal|10
index|]
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|9
index|]
operator|==
literal|'D'
condition|)
block|{
comment|/* it's a GNU global destructor to be executed at program exit */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|11
expr_stmt|;
name|work
operator|->
name|destructor
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|gnu_special
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
condition|)
return|return
name|success
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|9
index|]
operator|==
literal|'I'
condition|)
block|{
comment|/* it's a GNU global constructor to be executed at program init */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|11
expr_stmt|;
name|work
operator|->
name|constructor
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|gnu_special
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
condition|)
return|return
name|success
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ARM_DEMANGLING
operator|&&
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"__std__"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's a ARM global destructor to be executed at program exit */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|7
expr_stmt|;
name|work
operator|->
name|destructor
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ARM_DEMANGLING
operator|&&
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"__sti__"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's a ARM global constructor to be executed at program initial */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|7
expr_stmt|;
name|work
operator|->
name|constructor
operator|=
literal|2
expr_stmt|;
block|}
comment|/*  This block of code is a reduction in strength time optimization       of:       scan = mystrstr (*mangled, "__"); */
block|{
name|scan
operator|=
operator|*
name|mangled
expr_stmt|;
do|do
block|{
name|scan
operator|=
name|strchr
argument_list|(
name|scan
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|scan
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|scan
operator|!=
literal|'_'
condition|)
do|;
if|if
condition|(
name|scan
operator|!=
name|NULL
condition|)
operator|--
name|scan
expr_stmt|;
block|}
if|if
condition|(
name|scan
operator|!=
name|NULL
condition|)
block|{
comment|/* We found a sequence of two or more '_', ensure that we start at 	 the last pair in the sequence.  */
name|i
operator|=
name|strspn
argument_list|(
name|scan
argument_list|,
literal|"_"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
condition|)
block|{
name|scan
operator|+=
operator|(
name|i
operator|-
literal|2
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scan
operator|==
name|NULL
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|work
operator|->
name|static_type
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|scan
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|scan
index|[
literal|0
index|]
operator|!=
literal|'t'
operator|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|scan
operator|==
operator|*
name|mangled
operator|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|scan
index|[
literal|2
index|]
argument_list|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'Q'
operator|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'t'
operator|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'K'
operator|)
operator|||
operator|(
name|scan
index|[
literal|2
index|]
operator|==
literal|'H'
operator|)
operator|)
condition|)
block|{
comment|/* The ARM says nothing about the mangling of local variables. 	 But cfront mangles local variables by prepending __<nesting_level> 	 to them. As an extension to ARM demangling we handle this case.  */
if|if
condition|(
operator|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
operator|)
operator|&&
name|isdigit
argument_list|(
name|scan
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
operator|*
name|mangled
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* A GNU style constructor starts with __[0-9Qt].  But cfront uses 	     names like __Q2_3foo3bar for nested type names.  So don't accept 	     this style of constructor for cfront demangling.  A GNU 	     style member-template constructor starts with 'H'. */
if|if
condition|(
operator|!
operator|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
operator|)
condition|)
name|work
operator|->
name|constructor
operator|+=
literal|1
expr_stmt|;
operator|*
name|mangled
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|scan
operator|==
operator|*
name|mangled
operator|)
operator|&&
operator|!
name|isdigit
argument_list|(
name|scan
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|scan
index|[
literal|2
index|]
operator|!=
literal|'t'
operator|)
condition|)
block|{
comment|/* Mangled name starts with "__".  Skip over any leading '_' characters, 	 then find the next "__" that separates the prefix from the signature. 	 */
if|if
condition|(
operator|!
operator|(
name|ARM_DEMANGLING
operator|||
name|LUCID_DEMANGLING
operator|)
operator|||
operator|(
name|arm_special
argument_list|(
name|mangled
argument_list|,
name|declp
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|scan
operator|==
literal|'_'
condition|)
block|{
name|scan
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scan
operator|=
name|mystrstr
argument_list|(
name|scan
argument_list|,
literal|"__"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
operator|*
operator|(
name|scan
operator|+
literal|2
operator|)
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* No separator (I.E. "__not_mangled"), or empty signature 		 (I.E. "__not_mangled_either__") */
name|success
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|tmp
decl_stmt|;
comment|/* Look for the LAST occurrence of __, allowing names to have                  the '__' sequence embedded in them.*/
while|while
condition|(
operator|(
name|tmp
operator|=
name|mystrstr
argument_list|(
name|scan
operator|+
literal|2
argument_list|,
literal|"__"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|scan
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|scan
operator|+
literal|2
operator|)
operator|==
literal|'\0'
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
name|demangle_function_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
name|scan
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ARM_DEMANGLING
operator|&&
name|scan
index|[
literal|2
index|]
operator|==
literal|'p'
operator|&&
name|scan
index|[
literal|3
index|]
operator|==
literal|'t'
condition|)
block|{
comment|/* Cfront-style parameterized type.  Handled later as a signature.  */
name|success
operator|=
literal|1
expr_stmt|;
comment|/* ARM template? */
name|demangle_arm_pt
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
argument_list|,
name|declp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|scan
operator|+
literal|2
operator|)
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Mangled name does not start with "__" but does have one somewhere 	 in there with non empty stuff after it.  Looks like a global 	 function name.  */
name|demangle_function_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
name|scan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Doesn't look like a mangled name */
name|success
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
operator|&&
operator|(
name|work
operator|->
name|constructor
operator|==
literal|2
operator|||
name|work
operator|->
name|destructor
operator|==
literal|2
operator|)
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	gnu_special -- special handling of gnu mangled strings  SYNOPSIS  	static int 	gnu_special (struct work_stuff *work, const char **mangled, 		     string *declp);   DESCRIPTION  	Process some special GNU style mangling forms that don't fit 	the normal pattern.  For example:  		_$_3foo		(destructor for class foo) 		_vt$foo		(foo virtual table) 		_vt$foo$bar	(foo::bar virtual table) 		__vt_foo	(foo virtual table, new style with thunks) 		_3foo$varname	(static data member) 		_Q22rs2tu$vw	(static data member) 		__t6vector1Zii	(constructor with template) 		__thunk_4__$_7ostream (virtual function thunk)  */
end_comment

begin_function
specifier|static
name|int
name|gnu_special
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
comment|/* Found a GNU style destructor, get past "_<CPLUS_MARKER>_" */
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|3
expr_stmt|;
name|work
operator|->
name|destructor
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'v'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|3
index|]
operator|==
literal|'t'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|4
index|]
operator|==
literal|'_'
operator|)
operator|||
operator|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
operator|==
literal|'v'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|3
index|]
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
comment|/* Found a GNU style virtual table, get past "_vt<CPLUS_MARKER>"          and create the decl.  Note that we consume the entire mangled 	 input string, which means that demangle_signature has no work 	 to do.  */
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'v'
condition|)
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|5
expr_stmt|;
comment|/* New style, with thunks: "__vt_" */
else|else
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|4
expr_stmt|;
comment|/* Old style, no thunks: "_vt<CPLUS_MARKER>" */
while|while
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|=
name|strpbrk
argument_list|(
operator|*
name|mangled
argument_list|,
name|cplus_markers
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'Q'
case|:
case|case
literal|'K'
case|:
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|mangled
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
comment|/* We may be seeing a too-large size, or else a 		     ".<digits>" indicating a static local symbol.  In 		     any case, declare victory and move on; *don't* try 		     to use n to allocate.  */
if|if
condition|(
name|n
operator|>
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|success
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|n
operator|=
name|strcspn
argument_list|(
operator|*
name|mangled
argument_list|,
name|cplus_markers
argument_list|)
expr_stmt|;
block|}
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|&&
operator|(
operator|(
name|p
operator|==
name|NULL
operator|)
operator|||
operator|(
name|p
operator|==
operator|*
name|mangled
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|success
condition|)
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" virtual table"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
name|strchr
argument_list|(
literal|"0123456789Qt"
argument_list|,
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
argument_list|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|p
operator|=
name|strpbrk
argument_list|(
operator|*
name|mangled
argument_list|,
name|cplus_markers
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* static data member, "_3foo$varname" for example */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'Q'
case|:
case|case
literal|'K'
case|:
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|success
operator|&&
operator|(
name|p
operator|==
operator|*
name|mangled
operator|)
condition|)
block|{
comment|/* Consumed everything up to the cplus_marker, append the 	     variable name.  */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"__thunk_"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|delta
init|=
operator|(
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|8
expr|,
name|consume_count
argument_list|(
name|mangled
argument_list|)
operator|)
decl_stmt|;
name|char
modifier|*
name|method
init|=
name|internal_cplus_demangle
argument_list|(
name|work
argument_list|,
operator|++
operator|*
name|mangled
argument_list|)
decl_stmt|;
if|if
condition|(
name|method
condition|)
block|{
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"virtual function thunk (delta:%d) for "
argument_list|,
operator|-
name|delta
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
literal|"__t"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|3
index|]
operator|==
literal|'i'
operator|||
operator|(
operator|*
name|mangled
operator|)
index|[
literal|3
index|]
operator|==
literal|'f'
operator|)
condition|)
block|{
name|p
operator|=
operator|(
operator|*
name|mangled
operator|)
index|[
literal|3
index|]
operator|==
literal|'i'
condition|?
literal|" type_info node"
else|:
literal|" type_info function"
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|4
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'Q'
case|:
case|case
literal|'K'
case|:
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|success
operator|=
name|demangle_fund_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
condition|)
name|success
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|success
condition|)
name|string_append
argument_list|(
name|declp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	arm_special -- special handling of ARM/lucid mangled strings  SYNOPSIS  	static int 	arm_special (const char **mangled, 		     string *declp);   DESCRIPTION  	Process some special ARM style mangling forms that don't fit 	the normal pattern.  For example:  		__vtbl__3foo		(foo virtual table) 		__vtbl__3foo__3bar	(bar::foo virtual table)   */
end_comment

begin_function
specifier|static
name|int
name|arm_special
parameter_list|(
name|mangled
parameter_list|,
name|declp
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|mangled
argument_list|,
name|ARM_VTABLE_STRING
argument_list|,
name|ARM_VTABLE_STRLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found a ARM style virtual table, get past ARM_VTABLE_STRING          and create the decl.  Note that we consume the entire mangled 	 input string, which means that demangle_signature has no work 	 to do.  */
name|scan
operator|=
operator|*
name|mangled
operator|+
name|ARM_VTABLE_STRLEN
expr_stmt|;
while|while
condition|(
operator|*
name|scan
operator|!=
literal|'\0'
condition|)
comment|/* first check it can be demangled */
block|{
name|n
operator|=
name|consume_count
argument_list|(
operator|&
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no good */
block|}
name|scan
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|scan
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|scan
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|scan
operator|+=
literal|2
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|ARM_VTABLE_STRLEN
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
condition|)
block|{
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
name|string_prependn
argument_list|(
name|declp
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|string_prepend
argument_list|(
name|declp
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|string_append
argument_list|(
name|declp
argument_list|,
literal|" virtual table"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	demangle_qualified -- demangle 'Q' qualified name strings  SYNOPSIS  	static int 	demangle_qualified (struct work_stuff *, const char *mangled, 			    string *result, int isfuncname, int append);  DESCRIPTION  	Demangle a qualified name, such as "Q25Outer5Inner" which is 	the mangled form of "Outer::Inner".  The demangled output is 	prepended or appended to the result string according to the 	state of the append flag.  	If isfuncname is nonzero, then the qualified name we are building 	is going to be used as a member function name, so if it is a 	constructor or destructor function, append an appropriate 	constructor or destructor name.  I.E. for the above example, 	the result for use as a constructor is "Outer::Inner::Inner" 	and the result for use as a destructor is "Outer::Inner::~Inner".  BUGS  	Numeric conversion is ASCII dependent (FIXME).   */
end_comment

begin_function
specifier|static
name|int
name|demangle_qualified
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|,
name|isfuncname
parameter_list|,
name|append
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
name|int
name|isfuncname
decl_stmt|;
name|int
name|append
decl_stmt|;
block|{
name|int
name|qualifiers
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|num
index|[
literal|2
index|]
decl_stmt|;
name|string
name|temp
decl_stmt|;
name|string
name|last_name
decl_stmt|;
name|int
name|bindex
init|=
name|register_Btype
argument_list|(
name|work
argument_list|)
decl_stmt|;
comment|/* We only make use of ISFUNCNAME if the entity is a constructor or      destructor.  */
name|isfuncname
operator|=
operator|(
name|isfuncname
operator|&&
operator|(
operator|(
name|work
operator|->
name|constructor
operator|&
literal|1
operator|)
operator|||
operator|(
name|work
operator|->
name|destructor
operator|&
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
name|string_init
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
operator|&
name|last_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|0
index|]
operator|==
literal|'K'
condition|)
block|{
comment|/* Squangling qualified name reuse */
name|int
name|idx
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|idx
operator|>
name|work
operator|->
name|numk
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
name|work
operator|->
name|ktypevec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'_'
case|:
comment|/* GNU mangled name with more than 9 classes.  The count is preceded 	 by an underscore (to distinguish it from the<= 9 case) and followed 	 by an underscore.  */
name|p
operator|=
operator|*
name|mangled
operator|+
literal|2
expr_stmt|;
name|qualifiers
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'0'
condition|)
name|success
operator|=
literal|0
expr_stmt|;
comment|/* Skip the digits.  */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'_'
condition|)
name|success
operator|=
literal|0
expr_stmt|;
operator|*
name|mangled
operator|=
name|p
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* The count is in a single digit.  */
name|num
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|mangled
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|num
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qualifiers
operator|=
name|atoi
argument_list|(
name|num
argument_list|)
expr_stmt|;
comment|/* If there is an underscore after the digit, skip it.  This is 	 said to be for ARM-qualified names, but the ARM makes no 	 mention of such an underscore.  Perhaps cfront uses one.  */
if|if
condition|(
operator|(
operator|*
name|mangled
operator|)
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
default|default:
name|success
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|success
condition|)
return|return
name|success
return|;
comment|/* Pick off the names and collect them in the temp buffer in the order      in which they are found, separated by '::'.  */
while|while
condition|(
name|qualifiers
operator|--
operator|>
literal|0
condition|)
block|{
name|int
name|remember_K
init|=
literal|1
decl_stmt|;
name|string_clear
argument_list|(
operator|&
name|last_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mangled
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|mangled
index|[
literal|0
index|]
operator|==
literal|'t'
condition|)
block|{
comment|/* Here we always append to TEMP since we will want to use 	     the template name without the template parameters as a 	     constructor or destructor name.  The appropriate 	     (parameter-less) value is returned by demangle_template 	     in LAST_NAME.  We do not remember the template type here, 	     in order to match the G++ mangling algorithm.  */
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|,
operator|&
name|last_name
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|mangled
index|[
literal|0
index|]
operator|==
literal|'K'
condition|)
block|{
name|int
name|idx
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|idx
operator|>
name|work
operator|->
name|numk
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
name|work
operator|->
name|ktypevec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|remember_K
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
break|break;
block|}
else|else
block|{
name|success
operator|=
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|last_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
break|break;
name|string_appends
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|last_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remember_K
condition|)
name|remember_Ktype
argument_list|(
name|work
argument_list|,
name|temp
operator|.
name|b
argument_list|,
name|LEN_STRING
argument_list|(
operator|&
name|temp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qualifiers
operator|>
literal|0
condition|)
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|remember_Btype
argument_list|(
name|work
argument_list|,
name|temp
operator|.
name|b
argument_list|,
name|LEN_STRING
argument_list|(
operator|&
name|temp
argument_list|)
argument_list|,
name|bindex
argument_list|)
expr_stmt|;
comment|/* If we are using the result as a function name, we need to append      the appropriate '::' separated constructor or destructor name.      We do this here because this is the most convenient place, where      we already have a pointer to the name and the length of the name.  */
if|if
condition|(
name|isfuncname
condition|)
block|{
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|destructor
operator|&
literal|1
condition|)
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|last_name
argument_list|)
expr_stmt|;
block|}
comment|/* Now either prepend the temp buffer to the result, or append it,       depending upon the state of the append flag.  */
if|if
condition|(
name|append
condition|)
name|string_appends
argument_list|(
name|result
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
name|result
argument_list|)
condition|)
name|string_append
argument_list|(
operator|&
name|temp
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|string_prepends
argument_list|(
name|result
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|last_name
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	get_count -- convert an ascii count to integer, consuming tokens  SYNOPSIS  	static int 	get_count (const char **type, int *count)  DESCRIPTION  	Return 0 if no conversion is performed, 1 if a string is converted. */
end_comment

begin_function
specifier|static
name|int
name|get_count
parameter_list|(
name|type
parameter_list|,
name|count
parameter_list|)
specifier|const
name|char
modifier|*
modifier|*
name|type
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
operator|*
name|count
operator|=
operator|*
operator|*
name|type
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|type
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|type
argument_list|)
condition|)
block|{
name|p
operator|=
operator|*
name|type
expr_stmt|;
name|n
operator|=
operator|*
name|count
expr_stmt|;
do|do
block|{
name|n
operator|*=
literal|10
expr_stmt|;
name|n
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'_'
condition|)
block|{
operator|*
name|type
operator|=
name|p
operator|+
literal|1
expr_stmt|;
operator|*
name|count
operator|=
name|n
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* result will be initialised here; it will be freed on failure */
end_comment

begin_function
specifier|static
name|int
name|do_type
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|done
decl_stmt|;
name|int
name|success
decl_stmt|;
name|string
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|remembered_type
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|string
name|btype
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|btype
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|success
operator|&&
operator|!
name|done
condition|)
block|{
name|int
name|member
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
comment|/* A pointer type */
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
comment|/* A reference type */
case|case
literal|'R'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
break|break;
comment|/* An array */
case|case
literal|'A'
case|:
block|{
specifier|const
name|char
modifier|*
name|p
init|=
operator|++
operator|(
operator|*
name|mangled
operator|)
decl_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|")["
argument_list|)
expr_stmt|;
comment|/* Copy anything up until the next underscore (the size of the 	       array).  */
while|while
condition|(
operator|*
operator|*
name|mangled
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|)
operator|++
operator|(
operator|*
name|mangled
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
condition|)
block|{
name|string_appendn
argument_list|(
operator|&
name|decl
argument_list|,
name|p
argument_list|,
operator|*
name|mangled
operator|-
name|p
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* A back reference to a previously seen type */
case|case
literal|'T'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|n
argument_list|)
operator|||
name|n
operator|>=
name|work
operator|->
name|ntypes
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|remembered_type
operator|=
name|work
operator|->
name|typevec
index|[
name|n
index|]
expr_stmt|;
name|mangled
operator|=
operator|&
name|remembered_type
expr_stmt|;
block|}
break|break;
comment|/* A function */
case|case
literal|'F'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
operator|&
name|decl
argument_list|)
operator|&&
name|decl
operator|.
name|b
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/* After picking off the function args, we expect to either find the 	     function return type (preceded by an '_') or the end of the 	     string.  */
if|if
condition|(
operator|!
name|demangle_nested_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
operator|||
operator|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
operator|&&
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'_'
operator|)
condition|)
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'O'
case|:
block|{
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|member
operator|=
operator|*
operator|*
name|mangled
operator|==
literal|'M'
expr_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'t'
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
name|SCOPE_STRING
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|n
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
operator|*
name|mangled
argument_list|)
operator|<
name|n
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|string_prependn
argument_list|(
operator|&
name|decl
argument_list|,
operator|*
name|mangled
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|mangled
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|string
name|temp
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|string_prependn
argument_list|(
operator|&
name|decl
argument_list|,
name|temp
operator|.
name|b
argument_list|,
name|temp
operator|.
name|p
operator|-
name|temp
operator|.
name|b
argument_list|)
expr_stmt|;
name|string_clear
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|member
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'C'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|constp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'V'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|volatilep
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
operator|*
name|mangled
operator|)
operator|++
operator|!=
literal|'F'
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|member
operator|&&
operator|!
name|demangle_nested_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|decl
argument_list|)
operator|)
operator|||
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|PRINT_ANSI_QUALIFIERS
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|constp
condition|)
block|{
name|APPEND_BLANK
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|volatilep
condition|)
block|{
name|APPEND_BLANK
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
operator|&
name|decl
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'G'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
case|case
literal|'V'
case|:
comment|/* 	    if ((*mangled)[1] == 'P') 	    { 	    */
if|if
condition|(
name|PRINT_ANSI_QUALIFIERS
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
operator|&
name|decl
argument_list|)
condition|)
block|{
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|string_prepend
argument_list|(
operator|&
name|decl
argument_list|,
operator|(
operator|*
operator|*
name|mangled
operator|)
operator|==
literal|'C'
condition|?
literal|"const"
else|:
literal|"volatile"
argument_list|)
expr_stmt|;
block|}
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
break|break;
comment|/* 	    } 	    */
comment|/* fall through */
default|default:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
comment|/* A qualified name, such as "Outer::Inner".  */
case|case
literal|'Q'
case|:
case|case
literal|'K'
case|:
block|{
name|success
operator|=
name|demangle_qualified
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|result
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* A back reference to a previously seen squangled type */
case|case
literal|'B'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|n
argument_list|)
operator|||
name|n
operator|>=
name|work
operator|->
name|numb
condition|)
name|success
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|string_append
argument_list|(
name|result
argument_list|,
name|work
operator|->
name|btypevec
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
comment|/* A template parm.  We substitute the corresponding argument. */
block|{
name|int
name|idx
decl_stmt|;
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|idx
operator|=
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
operator|(
name|work
operator|->
name|tmpl_argvec
operator|&&
name|idx
operator|>=
name|work
operator|->
name|ntmpl_args
operator|)
operator|||
name|consume_count_with_underscores
argument_list|(
name|mangled
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|work
operator|->
name|tmpl_argvec
condition|)
name|string_append
argument_list|(
name|result
argument_list|,
name|work
operator|->
name|tmpl_argvec
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"T%d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|success
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|success
operator|=
name|demangle_fund_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|result
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
condition|)
block|{
if|if
condition|(
operator|!
name|STRING_EMPTY
argument_list|(
operator|&
name|decl
argument_list|)
condition|)
block|{
name|string_append
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|result
argument_list|,
operator|&
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|string_delete
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|decl
argument_list|)
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a type string that represents a fundamental type    argument (int, long, unsigned int, etc) in TYPE, a pointer to the    string in which the demangled output is being built in RESULT, and    the WORK structure, decode the types and add them to the result.     For example:     	"Ci"	=>	"const int" 	"Sl"	=>	"signed long" 	"CUs"	=>	"const unsigned short"     */
end_comment

begin_function
specifier|static
name|int
name|demangle_fund_type
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|success
init|=
literal|1
decl_stmt|;
name|string
name|btype
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|btype
argument_list|)
expr_stmt|;
comment|/* First pick off any type qualifiers.  There can be more than one.  */
while|while
condition|(
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'C'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|PRINT_ANSI_QUALIFIERS
condition|)
block|{
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'U'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"unsigned"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* signed char only */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"signed"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|PRINT_ANSI_QUALIFIERS
condition|)
block|{
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'J'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"__complex"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now pick off the fundamental type.  There can be only one.  */
switch|switch
condition|(
operator|*
operator|*
name|mangled
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|'_'
case|:
break|break;
case|case
literal|'v'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long long"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"bool"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"char"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"wchar_t"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"long double"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"double"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|result
argument_list|,
literal|"float"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
operator|*
name|mangled
argument_list|)
condition|)
block|{
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* fall through */
comment|/* An explicit type, such as "6mytype" or "7integer" */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|int
name|bindex
init|=
name|register_Btype
argument_list|(
name|work
argument_list|)
decl_stmt|;
name|string
name|btype
decl_stmt|;
name|string_init
argument_list|(
operator|&
name|btype
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangle_class_name
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|btype
argument_list|)
condition|)
block|{
name|remember_Btype
argument_list|(
name|work
argument_list|,
name|btype
operator|.
name|b
argument_list|,
name|LEN_STRING
argument_list|(
operator|&
name|btype
argument_list|)
argument_list|,
name|bindex
argument_list|)
expr_stmt|;
name|APPEND_BLANK
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|result
argument_list|,
operator|&
name|btype
argument_list|)
expr_stmt|;
block|}
else|else
name|success
operator|=
literal|0
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|btype
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'t'
case|:
block|{
name|success
operator|=
name|demangle_template
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|btype
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|result
argument_list|,
operator|&
name|btype
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|success
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Demangle the next argument, given by MANGLED into RESULT, which    *should be an uninitialized* string.  It will be initialized here,    and free'd should anything go wrong.  */
end_comment

begin_function
specifier|static
name|int
name|do_arg
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|result
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|result
decl_stmt|;
block|{
comment|/* Remember where we started so that we can record the type, for      non-squangling type remembering.  */
specifier|const
name|char
modifier|*
name|start
init|=
operator|*
name|mangled
decl_stmt|;
name|string_init
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|nrepeats
operator|>
literal|0
condition|)
block|{
operator|--
name|work
operator|->
name|nrepeats
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|previous_argument
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* We want to reissue the previous type in this argument list.  */
name|string_appends
argument_list|(
name|result
argument_list|,
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'n'
condition|)
block|{
comment|/* A squangling-style repeat.  */
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
name|work
operator|->
name|nrepeats
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|nrepeats
operator|==
literal|0
condition|)
comment|/* This was not a repeat count after all.  */
return|return
literal|0
return|;
if|if
condition|(
name|work
operator|->
name|nrepeats
operator|>
literal|9
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
condition|)
comment|/* The repeat count should be followed by an '_' in this 	       case.  */
return|return
literal|0
return|;
else|else
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Now, the repeat is all set up.  */
return|return
name|do_arg
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|result
argument_list|)
return|;
block|}
comment|/* Save the result in WORK->previous_argument so that we can find it      if it's repeated.  Note that saving START is not good enough: we      do not want to add additional types to the back-referenceable      type vector when processing a repeated type.  */
if|if
condition|(
name|work
operator|->
name|previous_argument
condition|)
name|string_clear
argument_list|(
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
else|else
block|{
name|work
operator|->
name|previous_argument
operator|=
operator|(
name|string
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|string_init
argument_list|(
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_type
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|work
operator|->
name|previous_argument
argument_list|)
condition|)
return|return
literal|0
return|;
name|string_appends
argument_list|(
name|result
argument_list|,
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
name|remember_type
argument_list|(
name|work
argument_list|,
name|start
argument_list|,
operator|*
name|mangled
operator|-
name|start
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remember_type
parameter_list|(
name|work
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|work
operator|->
name|forgetting_types
condition|)
return|return;
if|if
condition|(
name|work
operator|->
name|ntypes
operator|>=
name|work
operator|->
name|typevec_size
condition|)
block|{
if|if
condition|(
name|work
operator|->
name|typevec_size
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|typevec_size
operator|=
literal|3
expr_stmt|;
name|work
operator|->
name|typevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|typevec_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|work
operator|->
name|typevec_size
operator|*=
literal|2
expr_stmt|;
name|work
operator|->
name|typevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|typevec
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|typevec_size
argument_list|)
expr_stmt|;
block|}
block|}
name|tem
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tem
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tem
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|work
operator|->
name|typevec
index|[
name|work
operator|->
name|ntypes
operator|++
index|]
operator|=
name|tem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remember a K type class qualifier. */
end_comment

begin_function
specifier|static
name|void
name|remember_Ktype
parameter_list|(
name|work
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|tem
decl_stmt|;
if|if
condition|(
name|work
operator|->
name|numk
operator|>=
name|work
operator|->
name|ksize
condition|)
block|{
if|if
condition|(
name|work
operator|->
name|ksize
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|ksize
operator|=
literal|5
expr_stmt|;
name|work
operator|->
name|ktypevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|ksize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|work
operator|->
name|ksize
operator|*=
literal|2
expr_stmt|;
name|work
operator|->
name|ktypevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|ktypevec
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|ksize
argument_list|)
expr_stmt|;
block|}
block|}
name|tem
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tem
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tem
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|work
operator|->
name|ktypevec
index|[
name|work
operator|->
name|numk
operator|++
index|]
operator|=
name|tem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register a B code, and get an index for it. B codes are registered    as they are seen, rather than as they are completed, so map<temp<char>>      registers map<temp<char>> as B0, and temp<char> as B1 */
end_comment

begin_function
specifier|static
name|int
name|register_Btype
parameter_list|(
name|work
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|work
operator|->
name|numb
operator|>=
name|work
operator|->
name|bsize
condition|)
block|{
if|if
condition|(
name|work
operator|->
name|bsize
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|bsize
operator|=
literal|5
expr_stmt|;
name|work
operator|->
name|btypevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|bsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|work
operator|->
name|bsize
operator|*=
literal|2
expr_stmt|;
name|work
operator|->
name|btypevec
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
operator|->
name|btypevec
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|work
operator|->
name|bsize
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|work
operator|->
name|numb
operator|++
expr_stmt|;
name|work
operator|->
name|btypevec
index|[
name|ret
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Store a value into a previously registered B code type. */
end_comment

begin_function
specifier|static
name|void
name|remember_Btype
parameter_list|(
name|work
parameter_list|,
name|start
parameter_list|,
name|len
parameter_list|,
name|index
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|,
name|index
decl_stmt|;
block|{
name|char
modifier|*
name|tem
decl_stmt|;
name|tem
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tem
argument_list|,
name|start
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tem
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|work
operator|->
name|btypevec
index|[
name|index
index|]
operator|=
name|tem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lose all the info related to B and K type codes. */
end_comment

begin_function
specifier|static
name|void
name|forget_B_and_K_types
parameter_list|(
name|work
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
name|work
operator|->
name|numk
operator|>
literal|0
condition|)
block|{
name|i
operator|=
operator|--
operator|(
name|work
operator|->
name|numk
operator|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|ktypevec
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|work
operator|->
name|ktypevec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|work
operator|->
name|ktypevec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
while|while
condition|(
name|work
operator|->
name|numb
operator|>
literal|0
condition|)
block|{
name|i
operator|=
operator|--
operator|(
name|work
operator|->
name|numb
operator|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|btypevec
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|work
operator|->
name|btypevec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|work
operator|->
name|btypevec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Forget the remembered types, but not the type vector itself.  */
end_comment

begin_function
specifier|static
name|void
name|forget_types
parameter_list|(
name|work
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
name|work
operator|->
name|ntypes
operator|>
literal|0
condition|)
block|{
name|i
operator|=
operator|--
operator|(
name|work
operator|->
name|ntypes
operator|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|typevec
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|work
operator|->
name|typevec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|work
operator|->
name|typevec
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Process the argument list part of the signature, after any class spec    has been consumed, as well as the first 'F' character (if any).  For    example:     "__als__3fooRT0"		=>	process "RT0"    "complexfunc5__FPFPc_PFl_i"	=>	process "PFPc_PFl_i"     DECLP must be already initialised, usually non-empty.  It won't be freed    on failure.     Note that g++ differs significantly from ARM and lucid style mangling    with regards to references to previously seen types.  For example, given    the source fragment:       class foo {        public:        foo::foo (int, foo&ia, int, foo&ib, int, foo&ic);      };       foo::foo (int, foo&ia, int, foo&ib, int, foo&ic) { ia = ib = ic; }      void foo (int, foo&ia, int, foo&ib, int, foo&ic) { ia = ib = ic; }     g++ produces the names:       __3fooiRT0iT2iT2      foo__FiR3fooiT1iT1     while lcc (and presumably other ARM style compilers as well) produces:       foo__FiR3fooT1T2T1T2      __ct__3fooFiR3fooT1T2T1T2     Note that g++ bases its type numbers starting at zero and counts all    previously seen types, while lucid/ARM bases its type numbers starting    at one and only considers types after it has seen the 'F' character    indicating the start of the function args.  For lucid/ARM style, we    account for this difference by discarding any previously seen types when    we see the 'F' character, and subtracting one from the type number    reference.   */
end_comment

begin_function
specifier|static
name|int
name|demangle_args
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|string
name|arg
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|tem
decl_stmt|;
name|char
name|temptype
decl_stmt|;
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'\0'
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
operator|*
operator|*
name|mangled
operator|!=
literal|'_'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'\0'
operator|&&
operator|*
operator|*
name|mangled
operator|!=
literal|'e'
operator|)
operator|||
name|work
operator|->
name|nrepeats
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'N'
operator|)
operator|||
operator|(
operator|*
operator|*
name|mangled
operator|==
literal|'T'
operator|)
condition|)
block|{
name|temptype
operator|=
operator|*
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|temptype
operator|==
literal|'N'
condition|)
block|{
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|r
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|r
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ARM_DEMANGLING
operator|&&
name|work
operator|->
name|ntypes
operator|>=
literal|10
condition|)
block|{
comment|/* If we have 10 or more types we might have more than a 1 digit                  index so we'll have to consume the whole count here. This                  will lose if the next thing is a type name preceded by a                  count but it's impossible to demangle that case properly                  anyway. Eg if we already have 12 types is T12Pc "(..., type1,                  Pc, ...)"  or "(..., type12, char *, ...)" */
if|if
condition|(
operator|(
name|t
operator|=
name|consume_count
argument_list|(
name|mangled
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|get_count
argument_list|(
name|mangled
argument_list|,
operator|&
name|t
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
condition|)
block|{
name|t
operator|--
expr_stmt|;
block|}
comment|/* Validate the type index.  Protect against illegal indices from 	     malformed type strings.  */
if|if
condition|(
operator|(
name|t
operator|<
literal|0
operator|)
operator|||
operator|(
name|t
operator|>=
name|work
operator|->
name|ntypes
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|work
operator|->
name|nrepeats
operator|>
literal|0
operator|||
operator|--
name|r
operator|>=
literal|0
condition|)
block|{
name|tem
operator|=
name|work
operator|->
name|typevec
index|[
name|t
index|]
expr_stmt|;
if|if
condition|(
name|need_comma
operator|&&
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|do_arg
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|need_comma
operator|&&
name|PRINT_ARG_TYPES
condition|)
name|string_append
argument_list|(
name|declp
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_arg
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
operator|&
name|arg
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
operator|*
name|mangled
operator|==
literal|'e'
condition|)
block|{
operator|(
operator|*
name|mangled
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
if|if
condition|(
name|need_comma
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|PRINT_ARG_TYPES
condition|)
block|{
name|string_append
argument_list|(
name|declp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like demangle_args, but for demangling the argument lists of function    and method pointers or references, not top-level declarations.  */
end_comment

begin_function
specifier|static
name|int
name|demangle_nested_args
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
block|{
name|string
modifier|*
name|saved_previous_argument
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|saved_nrepeats
decl_stmt|;
comment|/* The G++ name-mangling algorithm does not remember types on nested      argument lists, unless -fsquangling is used, and in that case the      type vector updated by remember_type is not used.  So, we turn      off remembering of types here.  */
operator|++
name|work
operator|->
name|forgetting_types
expr_stmt|;
comment|/* For the repeat codes used with -fsquangling, we must keep track of      the last argument.  */
name|saved_previous_argument
operator|=
name|work
operator|->
name|previous_argument
expr_stmt|;
name|saved_nrepeats
operator|=
name|work
operator|->
name|nrepeats
expr_stmt|;
name|work
operator|->
name|previous_argument
operator|=
literal|0
expr_stmt|;
name|work
operator|->
name|nrepeats
operator|=
literal|0
expr_stmt|;
comment|/* Actually demangle the arguments.  */
name|result
operator|=
name|demangle_args
argument_list|(
name|work
argument_list|,
name|mangled
argument_list|,
name|declp
argument_list|)
expr_stmt|;
comment|/* Restore the previous_argument field.  */
if|if
condition|(
name|work
operator|->
name|previous_argument
condition|)
name|string_delete
argument_list|(
name|work
operator|->
name|previous_argument
argument_list|)
expr_stmt|;
name|work
operator|->
name|previous_argument
operator|=
name|saved_previous_argument
expr_stmt|;
name|work
operator|->
name|nrepeats
operator|=
name|saved_nrepeats
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|demangle_function_name
parameter_list|(
name|work
parameter_list|,
name|mangled
parameter_list|,
name|declp
parameter_list|,
name|scan
parameter_list|)
name|struct
name|work_stuff
modifier|*
name|work
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|mangled
decl_stmt|;
name|string
modifier|*
name|declp
decl_stmt|;
specifier|const
name|char
modifier|*
name|scan
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|;
name|string
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|tem
decl_stmt|;
name|string_appendn
argument_list|(
name|declp
argument_list|,
operator|(
operator|*
name|mangled
operator|)
argument_list|,
name|scan
operator|-
operator|(
operator|*
name|mangled
operator|)
argument_list|)
expr_stmt|;
name|string_need
argument_list|(
name|declp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
operator|(
name|declp
operator|->
name|p
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* Consume the function name, including the "__" separating the name      from the signature.  We are guaranteed that SCAN points to the      separator.  */
operator|(
operator|*
name|mangled
operator|)
operator|=
name|scan
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|LUCID_DEMANGLING
operator|||
name|ARM_DEMANGLING
condition|)
block|{
comment|/* See if we have an ARM style constructor or destructor operator. 	 If so, then just record it, clear the decl, and return. 	 We can't build the actual constructor/destructor decl until later, 	 when we recover the class name from the signature.  */
if|if
condition|(
name|strcmp
argument_list|(
name|declp
operator|->
name|b
argument_list|,
literal|"__ct"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|constructor
operator|+=
literal|1
expr_stmt|;
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|declp
operator|->
name|b
argument_list|,
literal|"__dt"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|->
name|destructor
operator|+=
literal|1
expr_stmt|;
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|>=
literal|3
operator|&&
name|declp
operator|->
name|b
index|[
literal|0
index|]
operator|==
literal|'o'
operator|&&
name|declp
operator|->
name|b
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
name|declp
operator|->
name|b
index|[
literal|2
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* see if it's an assignment expression */
if|if
condition|(
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|>=
literal|10
comment|/* op$assign_ */
operator|&&
name|memcmp
argument_list|(
name|declp
operator|->
name|b
operator|+
literal|3
argument_list|,
literal|"assign_"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|-
literal|10
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|10
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|-
literal|3
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
name|len
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|3
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|declp
operator|->
name|p
operator|-
name|declp
operator|->
name|b
operator|>=
literal|5
operator|&&
name|memcmp
argument_list|(
name|declp
operator|->
name|b
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
name|declp
operator|->
name|b
index|[
literal|4
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* type conversion operator */
name|tem
operator|=
name|declp
operator|->
name|b
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|declp
operator|->
name|b
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|declp
operator|->
name|b
index|[
literal|2
index|]
operator|==
literal|'o'
operator|&&
name|declp
operator|->
name|b
index|[
literal|3
index|]
operator|==
literal|'p'
condition|)
block|{
comment|/* ANSI.  */
comment|/* type conversion operator.  */
name|tem
operator|=
name|declp
operator|->
name|b
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|do_type
argument_list|(
name|work
argument_list|,
operator|&
name|tem
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator "
argument_list|)
expr_stmt|;
name|string_appends
argument_list|(
name|declp
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
name|string_delete
argument_list|(
operator|&
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|declp
operator|->
name|b
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|declp
operator|->
name|b
index|[
literal|2
index|]
operator|>=
literal|'a'
operator|&&
name|declp
operator|->
name|b
index|[
literal|2
index|]
operator|<=
literal|'z'
operator|&&
name|declp
operator|->
name|b
index|[
literal|3
index|]
operator|>=
literal|'a'
operator|&&
name|declp
operator|->
name|b
index|[
literal|3
index|]
operator|<=
literal|'z'
condition|)
block|{
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|4
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Operator.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
literal|2
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|declp
operator|->
name|b
index|[
literal|2
index|]
operator|==
literal|'a'
operator|&&
name|declp
operator|->
name|b
index|[
literal|5
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Assignment.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|optable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|optable
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|)
operator|==
literal|3
operator|&&
name|memcmp
argument_list|(
name|optable
index|[
name|i
index|]
operator|.
name|in
argument_list|,
name|declp
operator|->
name|b
operator|+
literal|2
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|string_clear
argument_list|(
name|declp
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
literal|"operator"
argument_list|)
expr_stmt|;
name|string_append
argument_list|(
name|declp
argument_list|,
name|optable
index|[
name|i
index|]
operator|.
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* a mini string-handling package */
end_comment

begin_function
specifier|static
name|void
name|string_need
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|tem
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|b
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|32
condition|)
block|{
name|n
operator|=
literal|32
expr_stmt|;
block|}
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|b
operator|+
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|e
operator|-
name|s
operator|->
name|p
operator|<
name|n
condition|)
block|{
name|tem
operator|=
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
expr_stmt|;
name|n
operator|+=
name|tem
expr_stmt|;
name|n
operator|*=
literal|2
expr_stmt|;
name|s
operator|->
name|b
operator|=
name|xrealloc
argument_list|(
name|s
operator|->
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
operator|+
name|tem
expr_stmt|;
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|b
operator|+
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_delete
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|b
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|s
operator|->
name|b
argument_list|)
expr_stmt|;
name|s
operator|->
name|b
operator|=
name|s
operator|->
name|e
operator|=
name|s
operator|->
name|p
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_init
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
name|s
operator|->
name|b
operator|=
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|e
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|string_clear
parameter_list|(
name|s
parameter_list|)
name|string
modifier|*
name|s
decl_stmt|;
block|{
name|s
operator|->
name|p
operator|=
name|s
operator|->
name|b
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int string_empty (s)      string *s; {   return (s->b == s->p); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|string_append
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
return|return;
name|n
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|string_appends
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|b
operator|!=
name|s
operator|->
name|p
condition|)
block|{
name|n
operator|=
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
expr_stmt|;
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
operator|->
name|b
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|string_appendn
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
operator|->
name|p
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_prepend
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|!=
name|NULL
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|string_prependn
argument_list|(
name|p
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|string_prepends
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|,
decl|*
name|s
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|s
operator|->
name|b
operator|!=
name|s
operator|->
name|p
condition|)
block|{
name|string_prependn
argument_list|(
name|p
argument_list|,
name|s
operator|->
name|b
argument_list|,
name|s
operator|->
name|p
operator|-
name|s
operator|->
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|string_prependn
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
name|string
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|string_need
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|p
operator|-
literal|1
init|;
name|q
operator|>=
name|p
operator|->
name|b
condition|;
name|q
operator|--
control|)
block|{
name|q
index|[
name|n
index|]
operator|=
name|q
index|[
literal|0
index|]
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|p
operator|->
name|b
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|p
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* To generate a standalone demangler program for testing purposes,    just compile and link this file with -DMAIN and libiberty.a.  When    run, it demangles each command line arg, or each stdin string, and    prints the result on stdout.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAIN
end_ifdef

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|program_version
init|=
name|VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flags
init|=
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|demangle_it
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fatal
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|demangle_it
parameter_list|(
name|mangled_name
parameter_list|)
name|char
modifier|*
name|mangled_name
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|cplus_demangle
argument_list|(
name|mangled_name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|mangled_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|stream
parameter_list|,
name|status
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"\ Usage: %s [-_] [-n] [-s {gnu,lucid,arm}] [--strip-underscores]\n\       [--no-strip-underscores] [--format={gnu,lucid,arm}]\n\       [--help] [--version] [arg...]\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MBUF_SIZE
value|32767
end_define

begin_decl_stmt
name|char
name|mbuffer
index|[
name|MBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defined in the automatically-generated underscore.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|prepends_underscore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strip_underscore
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"strip-underscores"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'_'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'h'
block|}
block|,
block|{
literal|"no-strip-underscores"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|c
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|strip_underscore
operator|=
name|prepends_underscore
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"_ns:j"
argument_list|,
name|long_options
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|stderr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|usage
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
name|strip_underscore
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|printf
argument_list|(
literal|"GNU %s version %s\n"
argument_list|,
name|program_name
argument_list|,
name|program_version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'_'
case|:
name|strip_underscore
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"gnu"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_demangling_style
operator|=
name|gnu_demangling
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"lucid"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_demangling_style
operator|=
name|lucid_demangling
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"arm"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|current_demangling_style
operator|=
name|arm_demangling
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unknown demangling style `%s'\n"
argument_list|,
name|program_name
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|demangle_it
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
comment|/* Try to read a label.  */
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
operator|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|MBUF_SIZE
operator|-
literal|1
condition|)
break|break;
name|mbuffer
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|int
name|skip_first
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mbuffer
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
operator|++
name|skip_first
expr_stmt|;
if|if
condition|(
name|strip_underscore
operator|&&
name|mbuffer
index|[
name|skip_first
index|]
operator|==
literal|'_'
condition|)
operator|++
name|skip_first
expr_stmt|;
if|if
condition|(
name|skip_first
operator|>
name|i
condition|)
name|skip_first
operator|=
name|i
expr_stmt|;
name|mbuffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|cplus_demangle
argument_list|(
name|mbuffer
operator|+
name|skip_first
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
if|if
condition|(
name|mbuffer
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|putc
argument_list|(
literal|'.'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|result
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|mbuffer
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|program_name
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* main */
end_comment

end_unit

