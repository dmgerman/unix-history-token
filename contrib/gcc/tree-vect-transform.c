begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Transformation Utilities for Loop Vectorization.    Copyright (C) 2003,2004,2005,2006 Free Software Foundation, Inc.    Contributed by Dorit Naishlos<dorit@il.ibm.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_include
include|#
directive|include
file|"tree-data-ref.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"tree-vectorizer.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_comment
comment|/* Utility functions for the code transformation.  */
end_comment

begin_function_decl
specifier|static
name|bool
name|vect_transform_stmt
parameter_list|(
name|tree
parameter_list|,
name|block_stmt_iterator
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vect_align_data_ref
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vect_create_destination_var
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vect_create_data_ref_ptr
parameter_list|(
name|tree
parameter_list|,
name|block_stmt_iterator
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vect_create_addr_base_for_vector_ref
parameter_list|(
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vect_get_new_vect_var
parameter_list|(
name|tree
parameter_list|,
name|enum
name|vect_var_kind
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vect_get_vec_def_for_operand
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vect_init_vector
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vect_finish_stmt_generation
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|vec_stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|vect_is_simple_cond
parameter_list|(
name|tree
parameter_list|,
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_vuses_to_preheader
parameter_list|(
name|tree
parameter_list|,
name|struct
name|loop
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vect_create_epilog_for_reduction
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|enum
name|tree_code
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|get_initial_def_for_reduction
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utility function dealing with loop peeling (not peeling itself).  */
end_comment

begin_function_decl
specifier|static
name|void
name|vect_generate_tmps_on_preheader
parameter_list|(
name|loop_vec_info
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vect_build_loop_niters
parameter_list|(
name|loop_vec_info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vect_update_ivs_after_vectorizer
parameter_list|(
name|loop_vec_info
parameter_list|,
name|tree
parameter_list|,
name|edge
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|vect_gen_niters_for_prolog_loop
parameter_list|(
name|loop_vec_info
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vect_update_init_of_dr
parameter_list|(
name|struct
name|data_reference
modifier|*
parameter_list|,
name|tree
name|niters
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vect_update_inits_of_drs
parameter_list|(
name|loop_vec_info
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vect_do_peeling_for_alignment
parameter_list|(
name|loop_vec_info
parameter_list|,
name|struct
name|loops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vect_do_peeling_for_loop_bound
parameter_list|(
name|loop_vec_info
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|struct
name|loops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vect_min_worthwhile_factor
parameter_list|(
name|enum
name|tree_code
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Function vect_get_new_vect_var.     Returns a name for a new variable. The current naming scheme appends the     prefix "vect_" or "vect_p" (depending on the value of VAR_KIND) to     the name of vectorizer generated variables, and appends that to NAME if     provided.  */
end_comment

begin_function
specifier|static
name|tree
name|vect_get_new_vect_var
parameter_list|(
name|tree
name|type
parameter_list|,
name|enum
name|vect_var_kind
name|var_kind
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
name|tree
name|new_vect_var
decl_stmt|;
switch|switch
condition|(
name|var_kind
condition|)
block|{
case|case
name|vect_simple_var
case|:
name|prefix
operator|=
literal|"vect_"
expr_stmt|;
break|break;
case|case
name|vect_scalar_var
case|:
name|prefix
operator|=
literal|"stmp_"
expr_stmt|;
break|break;
case|case
name|vect_pointer_var
case|:
name|prefix
operator|=
literal|"vect_p"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
name|new_vect_var
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
name|concat
argument_list|(
name|prefix
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_vect_var
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
return|return
name|new_vect_var
return|;
block|}
end_function

begin_comment
comment|/* Function vect_create_addr_base_for_vector_ref.     Create an expression that computes the address of the first memory location    that will be accessed for a data reference.     Input:    STMT: The statement containing the data reference.    NEW_STMT_LIST: Must be initialized to NULL_TREE or a statement list.    OFFSET: Optional. If supplied, it is be added to the initial address.     Output:    1. Return an SSA_NAME whose value is the address of the memory location of        the first vector of the data reference.    2. If new_stmt_list is not NULL_TREE after return then the caller must insert       these statement(s) which define the returned SSA_NAME.     FORNOW: We are only handling array accesses with step 1.  */
end_comment

begin_function
specifier|static
name|tree
name|vect_create_addr_base_for_vector_ref
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|new_stmt_list
parameter_list|,
name|tree
name|offset
parameter_list|)
block|{
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
init|=
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|tree
name|data_ref_base
init|=
name|unshare_expr
argument_list|(
name|DR_BASE_ADDRESS
argument_list|(
name|dr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|base_name
init|=
name|build_fold_indirect_ref
argument_list|(
name|data_ref_base
argument_list|)
decl_stmt|;
name|tree
name|ref
init|=
name|DR_REF
argument_list|(
name|dr
argument_list|)
decl_stmt|;
name|tree
name|scalar_type
init|=
name|TREE_TYPE
argument_list|(
name|ref
argument_list|)
decl_stmt|;
name|tree
name|scalar_ptr_type
init|=
name|build_pointer_type
argument_list|(
name|scalar_type
argument_list|)
decl_stmt|;
name|tree
name|vec_stmt
decl_stmt|;
name|tree
name|new_temp
decl_stmt|;
name|tree
name|addr_base
decl_stmt|,
name|addr_expr
decl_stmt|;
name|tree
name|dest
decl_stmt|,
name|new_stmt
decl_stmt|;
name|tree
name|base_offset
init|=
name|unshare_expr
argument_list|(
name|DR_OFFSET
argument_list|(
name|dr
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|unshare_expr
argument_list|(
name|DR_INIT
argument_list|(
name|dr
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Create base_offset */
name|base_offset
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|base_offset
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|dest
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_offset
argument_list|)
argument_list|,
literal|"base_off"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|dest
argument_list|)
expr_stmt|;
name|base_offset
operator|=
name|force_gimple_operand
argument_list|(
name|base_offset
argument_list|,
operator|&
name|new_stmt
argument_list|,
name|false
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|append_to_statement_list_force
argument_list|(
name|new_stmt
argument_list|,
name|new_stmt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|tree
name|tmp
init|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|base_offset
argument_list|)
argument_list|,
literal|"offset"
argument_list|)
decl_stmt|;
name|add_referenced_var
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|offset
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset
argument_list|)
argument_list|,
name|offset
argument_list|,
name|DR_STEP
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|base_offset
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|base_offset
argument_list|)
argument_list|,
name|base_offset
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|base_offset
operator|=
name|force_gimple_operand
argument_list|(
name|base_offset
argument_list|,
operator|&
name|new_stmt
argument_list|,
name|false
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|append_to_statement_list_force
argument_list|(
name|new_stmt
argument_list|,
name|new_stmt_list
argument_list|)
expr_stmt|;
block|}
comment|/* base + base_offset */
name|addr_base
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|data_ref_base
argument_list|)
argument_list|,
name|data_ref_base
argument_list|,
name|base_offset
argument_list|)
expr_stmt|;
comment|/* addr_expr = addr_base */
name|addr_expr
operator|=
name|vect_get_new_vect_var
argument_list|(
name|scalar_ptr_type
argument_list|,
name|vect_pointer_var
argument_list|,
name|get_name
argument_list|(
name|base_name
argument_list|)
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|addr_expr
argument_list|)
expr_stmt|;
name|vec_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|addr_expr
argument_list|,
name|addr_base
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|addr_expr
argument_list|,
name|vec_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|vec_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|append_to_statement_list_force
argument_list|(
name|vec_stmt
argument_list|,
name|new_stmt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"created "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|vec_stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
return|return
name|new_temp
return|;
block|}
end_function

begin_comment
comment|/* Function vect_align_data_ref.     Handle misalignment of a memory accesses.     FORNOW: Can't handle misaligned accesses.     Make sure that the dataref is aligned.  */
end_comment

begin_function
specifier|static
name|void
name|vect_align_data_ref
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
init|=
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
comment|/* FORNOW: can't handle misaligned accesses;               all accesses expected to be aligned.  */
name|gcc_assert
argument_list|(
name|aligned_access_p
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function vect_create_data_ref_ptr.     Create a memory reference expression for vector access, to be used in a    vector load/store stmt. The reference is based on a new pointer to vector    type (vp).     Input:    1. STMT: a stmt that references memory. Expected to be of the form          MODIFY_EXPR<name, data-ref> or MODIFY_EXPR<data-ref, name>.    2. BSI: block_stmt_iterator where new stmts can be added.    3. OFFSET (optional): an offset to be added to the initial address accessed         by the data-ref in STMT.    4. ONLY_INIT: indicate if vp is to be updated in the loop, or remain         pointing to the initial address.     Output:    1. Declare a new ptr to vector_type, and have it point to the base of the       data reference (initial addressed accessed by the data reference).       For example, for vector of type V8HI, the following code is generated:        v8hi *vp;       vp = (v8hi *)initial_address;        if OFFSET is not supplied:          initial_address =&a[init];       if OFFSET is supplied:          initial_address =&a[init + OFFSET];        Return the initial_address in INITIAL_ADDRESS.     2. If ONLY_INIT is true, return the initial pointer.  Otherwise, create       a data-reference in the loop based on the new vector pointer vp.  This       new data reference will by some means be updated each iteration of       the loop.  Return the pointer vp'.     FORNOW: handle only aligned and consecutive accesses.  */
end_comment

begin_function
specifier|static
name|tree
name|vect_create_data_ref_ptr
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
name|offset
parameter_list|,
name|tree
modifier|*
name|initial_address
parameter_list|,
name|bool
name|only_init
parameter_list|)
block|{
name|tree
name|base_name
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|tree
name|vect_ptr_type
decl_stmt|;
name|tree
name|vect_ptr
decl_stmt|;
name|tree
name|tag
decl_stmt|;
name|tree
name|new_temp
decl_stmt|;
name|tree
name|vec_stmt
decl_stmt|;
name|tree
name|new_stmt_list
init|=
name|NULL_TREE
decl_stmt|;
name|edge
name|pe
init|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|;
name|tree
name|vect_ptr_init
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
init|=
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|base_name
operator|=
name|build_fold_indirect_ref
argument_list|(
name|unshare_expr
argument_list|(
name|DR_BASE_ADDRESS
argument_list|(
name|dr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|tree
name|data_ref_base
init|=
name|base_name
decl_stmt|;
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"create vector-pointer variable to type: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|vectype
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|data_ref_base
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"  vectorizing a one dimensional array ref: "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|data_ref_base
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"  vectorizing a multidimensional array ref: "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|data_ref_base
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"  vectorizing a record based array ref: "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|data_ref_base
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"  vectorizing a pointer ref: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|base_name
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/** (1) Create the new vector-pointer variable:  **/
name|vect_ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
name|vect_ptr
operator|=
name|vect_get_new_vect_var
argument_list|(
name|vect_ptr_type
argument_list|,
name|vect_pointer_var
argument_list|,
name|get_name
argument_list|(
name|base_name
argument_list|)
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|vect_ptr
argument_list|)
expr_stmt|;
comment|/** (2) Add aliasing information to the new vector-pointer:           (The points-to info (DR_PTR_INFO) may be defined later.)  **/
name|tag
operator|=
name|DR_MEMTAG
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* If tag is a variable (and NOT_A_TAG) than a new symbol memory      tag must be created with tag added to its may alias list.  */
if|if
condition|(
operator|!
name|MTAG_P
argument_list|(
name|tag
argument_list|)
condition|)
name|new_type_alias
argument_list|(
name|vect_ptr
argument_list|,
name|tag
argument_list|,
name|DR_REF
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|var_ann
argument_list|(
name|vect_ptr
argument_list|)
operator|->
name|symbol_mem_tag
operator|=
name|tag
expr_stmt|;
name|var_ann
argument_list|(
name|vect_ptr
argument_list|)
operator|->
name|subvars
operator|=
name|DR_SUBVARS
argument_list|(
name|dr
argument_list|)
expr_stmt|;
comment|/** (3) Calculate the initial address the vector-pointer, and set           the vector-pointer to point to it before the loop:  **/
comment|/* Create: (&(base[init_val+offset]) in the loop preheader.  */
name|new_temp
operator|=
name|vect_create_addr_base_for_vector_ref
argument_list|(
name|stmt
argument_list|,
operator|&
name|new_stmt_list
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|pe
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|bsi_insert_on_edge_immediate
argument_list|(
name|pe
argument_list|,
name|new_stmt_list
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|new_bb
argument_list|)
expr_stmt|;
operator|*
name|initial_address
operator|=
name|new_temp
expr_stmt|;
comment|/* Create: p = (vectype *) initial_base  */
name|vec_stmt
operator|=
name|fold_convert
argument_list|(
name|vect_ptr_type
argument_list|,
name|new_temp
argument_list|)
expr_stmt|;
name|vec_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|vect_ptr
argument_list|,
name|vec_stmt
argument_list|)
expr_stmt|;
name|vect_ptr_init
operator|=
name|make_ssa_name
argument_list|(
name|vect_ptr
argument_list|,
name|vec_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|vec_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|vect_ptr_init
expr_stmt|;
name|new_bb
operator|=
name|bsi_insert_on_edge_immediate
argument_list|(
name|pe
argument_list|,
name|vec_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|new_bb
argument_list|)
expr_stmt|;
comment|/** (4) Handle the updating of the vector-pointer inside the loop: **/
if|if
condition|(
name|only_init
condition|)
comment|/* No update in loop is required.  */
block|{
comment|/* Copy the points-to information if it exists. */
if|if
condition|(
name|DR_PTR_INFO
argument_list|(
name|dr
argument_list|)
condition|)
name|duplicate_ssa_name_ptr_info
argument_list|(
name|vect_ptr_init
argument_list|,
name|DR_PTR_INFO
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|vect_ptr_init
return|;
block|}
else|else
block|{
name|block_stmt_iterator
name|incr_bsi
decl_stmt|;
name|bool
name|insert_after
decl_stmt|;
name|tree
name|indx_before_incr
decl_stmt|,
name|indx_after_incr
decl_stmt|;
name|tree
name|incr
decl_stmt|;
name|standard_iv_increment_position
argument_list|(
name|loop
argument_list|,
operator|&
name|incr_bsi
argument_list|,
operator|&
name|insert_after
argument_list|)
expr_stmt|;
name|create_iv
argument_list|(
name|vect_ptr_init
argument_list|,
name|fold_convert
argument_list|(
name|vect_ptr_type
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|vectype
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|loop
argument_list|,
operator|&
name|incr_bsi
argument_list|,
name|insert_after
argument_list|,
operator|&
name|indx_before_incr
argument_list|,
operator|&
name|indx_after_incr
argument_list|)
expr_stmt|;
name|incr
operator|=
name|bsi_stmt
argument_list|(
name|incr_bsi
argument_list|)
expr_stmt|;
name|set_stmt_info
argument_list|(
name|stmt_ann
argument_list|(
name|incr
argument_list|)
argument_list|,
name|new_stmt_vec_info
argument_list|(
name|incr
argument_list|,
name|loop_vinfo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the points-to information if it exists. */
if|if
condition|(
name|DR_PTR_INFO
argument_list|(
name|dr
argument_list|)
condition|)
block|{
name|duplicate_ssa_name_ptr_info
argument_list|(
name|indx_before_incr
argument_list|,
name|DR_PTR_INFO
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|duplicate_ssa_name_ptr_info
argument_list|(
name|indx_after_incr
argument_list|,
name|DR_PTR_INFO
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|merge_alias_info
argument_list|(
name|vect_ptr_init
argument_list|,
name|indx_before_incr
argument_list|)
expr_stmt|;
name|merge_alias_info
argument_list|(
name|vect_ptr_init
argument_list|,
name|indx_after_incr
argument_list|)
expr_stmt|;
return|return
name|indx_before_incr
return|;
block|}
block|}
end_function

begin_comment
comment|/* Function vect_create_destination_var.     Create a new temporary of type VECTYPE.  */
end_comment

begin_function
specifier|static
name|tree
name|vect_create_destination_var
parameter_list|(
name|tree
name|scalar_dest
parameter_list|,
name|tree
name|vectype
parameter_list|)
block|{
name|tree
name|vec_dest
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_name
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|vect_var_kind
name|kind
decl_stmt|;
name|kind
operator|=
name|vectype
condition|?
name|vect_simple_var
else|:
name|vect_scalar_var
expr_stmt|;
name|type
operator|=
name|vectype
condition|?
name|vectype
else|:
name|TREE_TYPE
argument_list|(
name|scalar_dest
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|scalar_dest
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
name|new_name
operator|=
name|get_name
argument_list|(
name|scalar_dest
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_name
condition|)
name|new_name
operator|=
literal|"var_"
expr_stmt|;
name|vec_dest
operator|=
name|vect_get_new_vect_var
argument_list|(
name|type
argument_list|,
name|vect_simple_var
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|vec_dest
argument_list|)
expr_stmt|;
return|return
name|vec_dest
return|;
block|}
end_function

begin_comment
comment|/* Function vect_init_vector.     Insert a new stmt (INIT_STMT) that initializes a new vector variable with    the vector elements of VECTOR_VAR. Return the DEF of INIT_STMT. It will be    used in the vectorization of STMT.  */
end_comment

begin_function
specifier|static
name|tree
name|vect_init_vector
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|vector_var
parameter_list|)
block|{
name|stmt_vec_info
name|stmt_vinfo
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_vinfo
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|tree
name|new_var
decl_stmt|;
name|tree
name|init_stmt
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_vinfo
argument_list|)
decl_stmt|;
name|tree
name|vec_oprnd
decl_stmt|;
name|edge
name|pe
decl_stmt|;
name|tree
name|new_temp
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|;
name|new_var
operator|=
name|vect_get_new_vect_var
argument_list|(
name|vectype
argument_list|,
name|vect_simple_var
argument_list|,
literal|"cst_"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|new_var
argument_list|)
expr_stmt|;
name|init_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|new_var
argument_list|,
name|vector_var
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|new_var
argument_list|,
name|init_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|init_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|pe
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|bsi_insert_on_edge_immediate
argument_list|(
name|pe
argument_list|,
name|init_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|new_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"created new init_stmt: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|init_stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|vec_oprnd
operator|=
name|TREE_OPERAND
argument_list|(
name|init_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|vec_oprnd
return|;
block|}
end_function

begin_comment
comment|/* Function vect_get_vec_def_for_operand.     OP is an operand in STMT. This function returns a (vector) def that will be    used in the vectorized stmt for STMT.     In the case that OP is an SSA_NAME which is defined in the loop, then    STMT_VINFO_VEC_STMT of the defining stmt holds the relevant def.     In case OP is an invariant or constant, a new stmt that creates a vector def    needs to be introduced.  */
end_comment

begin_function
specifier|static
name|tree
name|vect_get_vec_def_for_operand
parameter_list|(
name|tree
name|op
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|scalar_def
parameter_list|)
block|{
name|tree
name|vec_oprnd
decl_stmt|;
name|tree
name|vec_stmt
decl_stmt|;
name|tree
name|def_stmt
decl_stmt|;
name|stmt_vec_info
name|def_stmt_info
init|=
name|NULL
decl_stmt|;
name|stmt_vec_info
name|stmt_vinfo
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_vinfo
argument_list|)
decl_stmt|;
name|int
name|nunits
init|=
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|vectype
argument_list|)
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_vinfo
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|tree
name|vec_inv
decl_stmt|;
name|tree
name|vec_cst
decl_stmt|;
name|tree
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|def
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|vect_def_type
name|dt
decl_stmt|;
name|bool
name|is_simple_use
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vect_get_vec_def_for_operand: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|op
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|is_simple_use
operator|=
name|vect_is_simple_use
argument_list|(
name|op
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|is_simple_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
if|if
condition|(
name|def
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"def =  "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|def
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|def_stmt
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"  def_stmt =  "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|def_stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|dt
condition|)
block|{
comment|/* Case 1: operand is a constant.  */
case|case
name|vect_constant_def
case|:
block|{
if|if
condition|(
name|scalar_def
condition|)
operator|*
name|scalar_def
operator|=
name|op
expr_stmt|;
comment|/* Create 'vect_cst_ = {cst,cst,...,cst}'  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Create vector_cst. nunits = %d"
argument_list|,
name|nunits
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nunits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|op
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|vec_cst
operator|=
name|build_vector
argument_list|(
name|vectype
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|vect_init_vector
argument_list|(
name|stmt
argument_list|,
name|vec_cst
argument_list|)
return|;
block|}
comment|/* Case 2: operand is defined outside the loop - loop invariant.  */
case|case
name|vect_invariant_def
case|:
block|{
if|if
condition|(
name|scalar_def
condition|)
operator|*
name|scalar_def
operator|=
name|def
expr_stmt|;
comment|/* Create 'vec_inv = {inv,inv,..,inv}'  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Create vector_inv."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nunits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|def
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: use build_constructor directly.  */
name|vec_inv
operator|=
name|build_constructor_from_list
argument_list|(
name|vectype
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|vect_init_vector
argument_list|(
name|stmt
argument_list|,
name|vec_inv
argument_list|)
return|;
block|}
comment|/* Case 3: operand is defined inside the loop.  */
case|case
name|vect_loop_def
case|:
block|{
if|if
condition|(
name|scalar_def
condition|)
operator|*
name|scalar_def
operator|=
name|def_stmt
expr_stmt|;
comment|/* Get the def from the vectorized stmt.  */
name|def_stmt_info
operator|=
name|vinfo_for_stmt
argument_list|(
name|def_stmt
argument_list|)
expr_stmt|;
name|vec_stmt
operator|=
name|STMT_VINFO_VEC_STMT
argument_list|(
name|def_stmt_info
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|vec_stmt
argument_list|)
expr_stmt|;
name|vec_oprnd
operator|=
name|TREE_OPERAND
argument_list|(
name|vec_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|vec_oprnd
return|;
block|}
comment|/* Case 4: operand is defined by a loop header phi - reduction  */
case|case
name|vect_reduction_def
case|:
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
operator|==
name|PHI_NODE
argument_list|)
expr_stmt|;
comment|/* Get the def before the loop  */
name|op
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|def_stmt
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_initial_def_for_reduction
argument_list|(
name|stmt
argument_list|,
name|op
argument_list|,
name|scalar_def
argument_list|)
return|;
block|}
comment|/* Case 5: operand is defined by loop-header phi - induction.  */
case|case
name|vect_induction_def
case|:
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"induction - unsupported."
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"no support for induction"
argument_list|)
expr_stmt|;
comment|/* FORNOW */
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function vect_finish_stmt_generation.     Insert a new stmt.  */
end_comment

begin_function
specifier|static
name|void
name|vect_finish_stmt_generation
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|vec_stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|vec_stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"add new stmt: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|vec_stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure bsi points to the stmt that is being vectorized.  */
name|gcc_assert
argument_list|(
name|stmt
operator|==
name|bsi_stmt
argument_list|(
operator|*
name|bsi
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|SET_EXPR_LOCATION
argument_list|(
name|vec_stmt
argument_list|,
name|EXPR_LOCATION
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SET_EXPR_LOCUS
argument_list|(
name|vec_stmt
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|ADJUST_IN_EPILOG
value|1
end_define

begin_comment
comment|/* Function get_initial_def_for_reduction     Input:    STMT - a stmt that performs a reduction operation in the loop.    INIT_VAL - the initial value of the reduction variable     Output:    SCALAR_DEF - a tree that holds a value to be added to the final result 	of the reduction (used for "ADJUST_IN_EPILOG" - see below).    Return a vector variable, initialized according to the operation that STMT 	performs. This vector will be used as the initial value of the 	vector of partial results.     Option1 ("ADJUST_IN_EPILOG"): Initialize the vector as follows:      add:         [0,0,...,0,0]      mult:        [1,1,...,1,1]      min/max:     [init_val,init_val,..,init_val,init_val]      bit and/or:  [init_val,init_val,..,init_val,init_val]    and when necessary (e.g. add/mult case) let the caller know     that it needs to adjust the result by init_val.     Option2: Initialize the vector as follows:      add:         [0,0,...,0,init_val]      mult:        [1,1,...,1,init_val]      min/max:     [init_val,init_val,...,init_val]      bit and/or:  [init_val,init_val,...,init_val]    and no adjustments are needed.     For example, for the following code:     s = init_val;    for (i=0;i<n;i++)      s = s + a[i];     STMT is 's = s + a[i]', and the reduction variable is 's'.    For a vector of 4 units, we want to return either [0,0,0,init_val],    or [0,0,0,0] and let the caller know that it needs to adjust    the result at the end by 'init_val'.     FORNOW: We use the "ADJUST_IN_EPILOG" scheme.    TODO: Use some cost-model to estimate which scheme is more profitable. */
end_comment

begin_function
specifier|static
name|tree
name|get_initial_def_for_reduction
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
name|init_val
parameter_list|,
name|tree
modifier|*
name|scalar_def
parameter_list|)
block|{
name|stmt_vec_info
name|stmt_vinfo
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_vinfo
argument_list|)
decl_stmt|;
name|int
name|nunits
init|=
name|GET_MODE_NUNITS
argument_list|(
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nelements
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|init_val
argument_list|)
decl_stmt|;
name|tree
name|def
decl_stmt|;
name|tree
name|vec
decl_stmt|,
name|t
init|=
name|NULL_TREE
decl_stmt|;
name|bool
name|need_epilog_adjust
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gcc_assert
argument_list|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|WIDEN_SUM_EXPR
case|:
case|case
name|DOT_PROD_EXPR
case|:
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
name|def
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|def
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADJUST_IN_EPILOG
comment|/* All the 'nunits' elements are set to 0. The final result will be        adjusted by 'init_val' at the loop epilog.  */
name|nelements
operator|=
name|nunits
expr_stmt|;
name|need_epilog_adjust
operator|=
name|true
expr_stmt|;
else|#
directive|else
comment|/* 'nunits - 1' elements are set to 0; The last element is set to          'init_val'.  No further adjustments at the epilog are needed.  */
name|nelements
operator|=
name|nunits
operator|-
literal|1
expr_stmt|;
name|need_epilog_adjust
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|MIN_EXPR
case|:
case|case
name|MAX_EXPR
case|:
name|def
operator|=
name|init_val
expr_stmt|;
name|nelements
operator|=
name|nunits
expr_stmt|;
name|need_epilog_adjust
operator|=
name|false
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|nelements
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|def
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|nelements
operator|==
name|nunits
operator|-
literal|1
condition|)
block|{
comment|/* Set the last element of the vector.  */
name|t
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|init_val
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|nelements
operator|+=
literal|1
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|nelements
operator|==
name|nunits
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|init_val
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|init_val
argument_list|)
operator|==
name|REAL_CST
condition|)
name|vec
operator|=
name|build_vector
argument_list|(
name|vectype
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|vec
operator|=
name|build_constructor_from_list
argument_list|(
name|vectype
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_epilog_adjust
condition|)
operator|*
name|scalar_def
operator|=
name|NULL_TREE
expr_stmt|;
else|else
operator|*
name|scalar_def
operator|=
name|init_val
expr_stmt|;
return|return
name|vect_init_vector
argument_list|(
name|stmt
argument_list|,
name|vec
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function vect_create_epilog_for_reduction         Create code at the loop-epilog to finalize the result of a reduction    computation.        VECT_DEF is a vector of partial results.     REDUC_CODE is the tree-code for the epilog reduction.    STMT is the scalar reduction stmt that is being vectorized.    REDUCTION_PHI is the phi-node that carries the reduction computation.     This function:    1. Creates the reduction def-use cycle: sets the the arguments for        REDUCTION_PHI:       The loop-entry argument is the vectorized initial-value of the reduction.       The loop-latch argument is VECT_DEF - the vector of partial sums.    2. "Reduces" the vector of partial results VECT_DEF into a single result,       by applying the operation specified by REDUC_CODE if available, or by        other means (whole-vector shifts or a scalar loop).       The function also creates a new phi node at the loop exit to preserve        loop-closed form, as illustrated below.         The flow at the entry to this function:              loop:           vec_def = phi<null, null>            # REDUCTION_PHI           VECT_DEF = vector_stmt                # vectorized form of STMT                  s_loop = scalar_stmt                  # (scalar) STMT         loop_exit:           s_out0 = phi<s_loop>                 # (scalar) EXIT_PHI           use<s_out0>           use<s_out0>       The above is transformed by this function into:          loop:           vec_def = phi<vec_init, VECT_DEF>    # REDUCTION_PHI           VECT_DEF = vector_stmt                # vectorized form of STMT           s_loop = scalar_stmt                  # (scalar) STMT          loop_exit:           s_out0 = phi<s_loop>                 # (scalar) EXIT_PHI           v_out1 = phi<VECT_DEF>               # NEW_EXIT_PHI           v_out2 = reduce<v_out1>           s_out3 = extract_field<v_out2, 0>           s_out4 = adjust_result<s_out3>           use<s_out4>           use<s_out4> */
end_comment

begin_function
specifier|static
name|void
name|vect_create_epilog_for_reduction
parameter_list|(
name|tree
name|vect_def
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|enum
name|tree_code
name|reduc_code
parameter_list|,
name|tree
name|reduction_phi
parameter_list|)
block|{
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|vectype
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|basic_block
name|exit_bb
decl_stmt|;
name|tree
name|scalar_dest
decl_stmt|;
name|tree
name|scalar_type
decl_stmt|;
name|tree
name|new_phi
decl_stmt|;
name|block_stmt_iterator
name|exit_bsi
decl_stmt|;
name|tree
name|vec_dest
decl_stmt|;
name|tree
name|new_temp
decl_stmt|;
name|tree
name|new_name
decl_stmt|;
name|tree
name|epilog_stmt
decl_stmt|;
name|tree
name|new_scalar_dest
decl_stmt|,
name|exit_phi
decl_stmt|;
name|tree
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|,
name|bytesize
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|scalar_initial_def
decl_stmt|;
name|tree
name|vec_initial_def
decl_stmt|;
name|tree
name|orig_name
decl_stmt|;
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|bool
name|extract_scalar_result
decl_stmt|;
name|tree
name|reduction_op
decl_stmt|;
name|tree
name|orig_stmt
decl_stmt|;
name|tree
name|use_stmt
decl_stmt|;
name|tree
name|operation
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|op_type
decl_stmt|;
name|op_type
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|operation
argument_list|)
argument_list|)
expr_stmt|;
name|reduction_op
operator|=
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
name|op_type
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vectype
operator|=
name|get_vectype_for_scalar_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|reduction_op
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
comment|/*** 1. Create the reduction def-use cycle  ***/
comment|/* 1.1 set the loop-entry arg of the reduction-phi:  */
comment|/* For the case of reduction, vect_get_vec_def_for_operand returns      the scalar def before the loop, that defines the initial value      of the reduction variable.  */
name|vec_initial_def
operator|=
name|vect_get_vec_def_for_operand
argument_list|(
name|reduction_op
argument_list|,
name|stmt
argument_list|,
operator|&
name|scalar_initial_def
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|reduction_phi
argument_list|,
name|vec_initial_def
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1.2 set the loop-latch arg for the reduction-phi:  */
name|add_phi_arg
argument_list|(
name|reduction_phi
argument_list|,
name|vect_def
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"transform reduction: created def-use cycle:"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|reduction_phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|vect_def
argument_list|)
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/*** 2. Create epilog code 	  The reduction epilog code operates across the elements of the vector           of partial results computed by the vectorized loop.           The reduction epilog code consists of:           step 1: compute the scalar result in a vector (v_out2)           step 2: extract the scalar result (s_out3) from the vector (v_out2)           step 3: adjust the scalar result (s_out3) if needed.            Step 1 can be accomplished using one the following three schemes:           (scheme 1) using reduc_code, if available.           (scheme 2) using whole-vector shifts, if available.           (scheme 3) using a scalar loop. In this case steps 1+2 above are                       combined.                            The overall epilog code looks like this:            s_out0 = phi<s_loop>         # original EXIT_PHI           v_out1 = phi<VECT_DEF>       # NEW_EXIT_PHI           v_out2 = reduce<v_out1>              # step 1           s_out3 = extract_field<v_out2, 0>    # step 2           s_out4 = adjust_result<s_out3>       # step 3            (step 3 is optional, and step2 1 and 2 may be combined).           Lastly, the uses of s_out0 are replaced by s_out4.  	  ***/
comment|/* 2.1 Create new loop-exit-phi to preserve loop-closed form:         v_out1 = phi<v_loop>  */
name|exit_bb
operator|=
name|loop
operator|->
name|single_exit
operator|->
name|dest
expr_stmt|;
name|new_phi
operator|=
name|create_phi_node
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|vect_def
argument_list|)
argument_list|,
name|exit_bb
argument_list|)
expr_stmt|;
name|SET_PHI_ARG_DEF
argument_list|(
name|new_phi
argument_list|,
name|loop
operator|->
name|single_exit
operator|->
name|dest_idx
argument_list|,
name|vect_def
argument_list|)
expr_stmt|;
name|exit_bsi
operator|=
name|bsi_start
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
comment|/* 2.2 Get the relevant tree-code to use in the epilog for schemes 2,3           (i.e. when reduc_code is not available) and in the final adjustment code          (if needed).  Also get the original scalar reduction variable as          defined in the loop.  In case STMT is a "pattern-stmt" (i.e. - it           represents a reduction pattern), the tree-code and scalar-def are           taken from the original stmt that the pattern-stmt (STMT) replaces.            Otherwise (it is a regular reduction) - the tree-code and scalar-def          are taken from STMT.  */
name|orig_stmt
operator|=
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|orig_stmt
condition|)
block|{
comment|/* Regular reduction  */
name|orig_stmt
operator|=
name|stmt
expr_stmt|;
block|}
else|else
block|{
comment|/* Reduction pattern  */
name|stmt_vec_info
name|stmt_vinfo
init|=
name|vinfo_for_stmt
argument_list|(
name|orig_stmt
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|STMT_VINFO_IN_PATTERN_P
argument_list|(
name|stmt_vinfo
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|stmt_vinfo
argument_list|)
operator|==
name|stmt
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|orig_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|scalar_dest
operator|=
name|TREE_OPERAND
argument_list|(
name|orig_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scalar_type
operator|=
name|TREE_TYPE
argument_list|(
name|scalar_dest
argument_list|)
expr_stmt|;
name|new_scalar_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bitsize
operator|=
name|TYPE_SIZE
argument_list|(
name|scalar_type
argument_list|)
expr_stmt|;
name|bytesize
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|scalar_type
argument_list|)
expr_stmt|;
comment|/* 2.3 Create the reduction code, using one of the three schemes described          above.  */
if|if
condition|(
name|reduc_code
operator|<
name|NUM_TREE_CODES
condition|)
block|{
comment|/*** Case 1:  Create: 	   v_out2 = reduc_expr<v_out1>  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Reduce using direct vector reduction."
argument_list|)
expr_stmt|;
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
name|epilog_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|build1
argument_list|(
name|reduc_code
argument_list|,
name|vectype
argument_list|,
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
name|epilog_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|epilog_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|exit_bsi
argument_list|,
name|epilog_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|extract_scalar_result
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|enum
name|tree_code
name|shift_code
init|=
literal|0
decl_stmt|;
name|bool
name|have_whole_vector_shift
init|=
name|true
decl_stmt|;
name|int
name|bit_offset
decl_stmt|;
name|int
name|element_bitsize
init|=
name|tree_low_cst
argument_list|(
name|bitsize
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|vec_size_in_bits
init|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|vectype
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|vec_temp
decl_stmt|;
if|if
condition|(
name|vec_shr_optab
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
name|shift_code
operator|=
name|VEC_RSHIFT_EXPR
expr_stmt|;
else|else
name|have_whole_vector_shift
operator|=
name|false
expr_stmt|;
comment|/* Regardless of whether we have a whole vector shift, if we're 	 emulating the operation via tree-vect-generic, we don't want 	 to use it.  Only the first round of the reduction is likely 	 to still be profitable via emulation.  */
comment|/* ??? It might be better to emit a reduction tree code here, so that 	 tree-vect-generic can expand the first round via bit tricks.  */
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
name|have_whole_vector_shift
operator|=
name|false
expr_stmt|;
else|else
block|{
name|optab
name|optab
init|=
name|optab_for_tree_code
argument_list|(
name|code
argument_list|,
name|vectype
argument_list|)
decl_stmt|;
if|if
condition|(
name|optab
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
condition|)
name|have_whole_vector_shift
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|have_whole_vector_shift
condition|)
block|{
comment|/*** Case 2: Create: 	     for (offset = VS/2; offset>= element_size; offset/=2) 	        { 	          Create:  va' = vec_shift<va, offset> 	          Create:  va = vop<va, va'> 	        }  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Reduce using vector shifts"
argument_list|)
expr_stmt|;
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
expr_stmt|;
for|for
control|(
name|bit_offset
operator|=
name|vec_size_in_bits
operator|/
literal|2
init|;
name|bit_offset
operator|>=
name|element_bitsize
condition|;
name|bit_offset
operator|/=
literal|2
control|)
block|{
name|tree
name|bitpos
init|=
name|size_int
argument_list|(
name|bit_offset
argument_list|)
decl_stmt|;
name|epilog_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|build2
argument_list|(
name|shift_code
argument_list|,
name|vectype
argument_list|,
name|new_temp
argument_list|,
name|bitpos
argument_list|)
argument_list|)
expr_stmt|;
name|new_name
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
name|epilog_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|epilog_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_name
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|exit_bsi
argument_list|,
name|epilog_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|epilog_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|build2
argument_list|(
name|code
argument_list|,
name|vectype
argument_list|,
name|new_name
argument_list|,
name|new_temp
argument_list|)
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
name|epilog_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|epilog_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|exit_bsi
argument_list|,
name|epilog_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
name|extract_scalar_result
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|tree
name|rhs
decl_stmt|;
comment|/*** Case 3: Create:   	     s = extract_field<v_out2, 0> 	     for (offset = element_size;  		  offset< vector_size;  		  offset += element_size;) 	       { 	         Create:  s' = extract_field<v_out2, offset> 	         Create:  s = op<s, s'> 	       }  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Reduce using scalar code. "
argument_list|)
expr_stmt|;
name|vec_temp
operator|=
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
expr_stmt|;
name|vec_size_in_bits
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|vectype
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|build3
argument_list|(
name|BIT_FIELD_REF
argument_list|,
name|scalar_type
argument_list|,
name|vec_temp
argument_list|,
name|bitsize
argument_list|,
name|bitsize_zero_node
argument_list|)
expr_stmt|;
name|BIT_FIELD_REF_UNSIGNED
argument_list|(
name|rhs
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|scalar_type
argument_list|)
expr_stmt|;
name|epilog_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|scalar_type
argument_list|,
name|new_scalar_dest
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|new_scalar_dest
argument_list|,
name|epilog_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|epilog_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|exit_bsi
argument_list|,
name|epilog_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
for|for
control|(
name|bit_offset
operator|=
name|element_bitsize
init|;
name|bit_offset
operator|<
name|vec_size_in_bits
condition|;
name|bit_offset
operator|+=
name|element_bitsize
control|)
block|{
name|tree
name|bitpos
init|=
name|bitsize_int
argument_list|(
name|bit_offset
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|build3
argument_list|(
name|BIT_FIELD_REF
argument_list|,
name|scalar_type
argument_list|,
name|vec_temp
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|)
decl_stmt|;
name|BIT_FIELD_REF_UNSIGNED
argument_list|(
name|rhs
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|scalar_type
argument_list|)
expr_stmt|;
name|epilog_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|scalar_type
argument_list|,
name|new_scalar_dest
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|new_name
operator|=
name|make_ssa_name
argument_list|(
name|new_scalar_dest
argument_list|,
name|epilog_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|epilog_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_name
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|exit_bsi
argument_list|,
name|epilog_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|epilog_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|scalar_type
argument_list|,
name|new_scalar_dest
argument_list|,
name|build2
argument_list|(
name|code
argument_list|,
name|scalar_type
argument_list|,
name|new_name
argument_list|,
name|new_temp
argument_list|)
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|new_scalar_dest
argument_list|,
name|epilog_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|epilog_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|exit_bsi
argument_list|,
name|epilog_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
name|extract_scalar_result
operator|=
name|false
expr_stmt|;
block|}
block|}
comment|/* 2.4  Extract the final scalar result.  Create:          s_out3 = extract_field<v_out2, bitpos>  */
if|if
condition|(
name|extract_scalar_result
condition|)
block|{
name|tree
name|rhs
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"extract scalar result"
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
name|bitpos
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|bitsize_int
argument_list|(
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|vectype
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|scalar_type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bitpos
operator|=
name|bitsize_zero_node
expr_stmt|;
name|rhs
operator|=
name|build3
argument_list|(
name|BIT_FIELD_REF
argument_list|,
name|scalar_type
argument_list|,
name|new_temp
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
name|BIT_FIELD_REF_UNSIGNED
argument_list|(
name|rhs
argument_list|)
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|scalar_type
argument_list|)
expr_stmt|;
name|epilog_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|scalar_type
argument_list|,
name|new_scalar_dest
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|new_scalar_dest
argument_list|,
name|epilog_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|epilog_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|exit_bsi
argument_list|,
name|epilog_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
comment|/* 2.4 Adjust the final result by the initial value of the reduction 	 variable. (When such adjustment is not needed, then 	 'scalar_initial_def' is zero).  	 Create:  	 s_out4 = scalar_expr<s_out3, scalar_initial_def>  */
if|if
condition|(
name|scalar_initial_def
condition|)
block|{
name|epilog_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|scalar_type
argument_list|,
name|new_scalar_dest
argument_list|,
name|build2
argument_list|(
name|code
argument_list|,
name|scalar_type
argument_list|,
name|new_temp
argument_list|,
name|scalar_initial_def
argument_list|)
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|new_scalar_dest
argument_list|,
name|epilog_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|epilog_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|bsi_insert_after
argument_list|(
operator|&
name|exit_bsi
argument_list|,
name|epilog_stmt
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
block|}
comment|/* 2.6 Replace uses of s_out0 with uses of s_out3  */
comment|/* Find the loop-closed-use at the loop exit of the original scalar result.        (The reduction result is expected to have two immediate uses - one at the       latch block, and one at the loop exit).  */
name|exit_phi
operator|=
name|NULL
expr_stmt|;
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|imm_iter
argument_list|,
argument|scalar_dest
argument_list|)
block|{
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb_for_stmt
argument_list|(
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|exit_phi
operator|=
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* We expect to have found an exit_phi because of loop-closed-ssa form.  */
name|gcc_assert
argument_list|(
name|exit_phi
argument_list|)
expr_stmt|;
comment|/* Replace the uses:  */
name|orig_name
operator|=
name|PHI_RESULT
argument_list|(
name|exit_phi
argument_list|)
expr_stmt|;
name|FOR_EACH_IMM_USE_STMT
argument_list|(
argument|use_stmt
argument_list|,
argument|imm_iter
argument_list|,
argument|orig_name
argument_list|)
name|FOR_EACH_IMM_USE_ON_STMT
argument_list|(
argument|use_p
argument_list|,
argument|imm_iter
argument_list|)
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|new_temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function vectorizable_reduction.     Check if STMT performs a reduction operation that can be vectorized.    If VEC_STMT is also passed, vectorize the STMT: create a vectorized    stmt to replace it, put it in VEC_STMT, and insert it at BSI.    Return FALSE if not a vectorizable STMT, TRUE otherwise.     This function also handles reduction idioms (patterns) that have been     recognized in advance during vect_pattern_recog. In this case, STMT may be    of this form:      X = pattern_expr (arg0, arg1, ..., X)    and it's STMT_VINFO_RELATED_STMT points to the last stmt in the original    sequence that had been detected and replaced by the pattern-stmt (STMT).       In some cases of reduction patterns, the type of the reduction variable X is     different than the type of the other arguments of STMT.    In such cases, the vectype that is used when transforming STMT into a vector    stmt is different than the vectype that is used to determine the     vectorization factor, because it consists of a different number of elements     than the actual number of elements that are being operated upon in parallel.     For example, consider an accumulation of shorts into an int accumulator.     On some targets it's possible to vectorize this pattern operating on 8    shorts at a time (hence, the vectype for purposes of determining the    vectorization factor should be V8HI); on the other hand, the vectype that    is used to create the vector form is actually V4SI (the type of the result).      Upon entry to this function, STMT_VINFO_VECTYPE records the vectype that     indicates what is the actual level of parallelism (V8HI in the example), so     that the right vectorization factor would be derived. This vectype     corresponds to the type of arguments to the reduction stmt, and should *NOT*     be used to create the vectorized stmt. The right vectype for the vectorized    stmt is obtained from the type of the result X:          get_vectype_for_scalar_type (TREE_TYPE (X))     This means that, contrary to "regular" reductions (or "regular" stmts in     general), the following equation:       STMT_VINFO_VECTYPE == get_vectype_for_scalar_type (TREE_TYPE (X))    does *NOT* necessarily hold for reduction patterns.  */
end_comment

begin_function
name|bool
name|vectorizable_reduction
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
modifier|*
name|vec_stmt
parameter_list|)
block|{
name|tree
name|vec_dest
decl_stmt|;
name|tree
name|scalar_dest
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|tree
name|loop_vec_def0
decl_stmt|,
name|loop_vec_def1
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|tree
name|operation
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|,
name|orig_code
decl_stmt|,
name|epilog_reduc_code
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|vec_mode
decl_stmt|;
name|int
name|op_type
decl_stmt|;
name|optab
name|optab
decl_stmt|,
name|reduc_optab
decl_stmt|;
name|tree
name|new_temp
decl_stmt|;
name|tree
name|def
decl_stmt|,
name|def_stmt
decl_stmt|;
name|enum
name|vect_def_type
name|dt
decl_stmt|;
name|tree
name|new_phi
decl_stmt|;
name|tree
name|scalar_type
decl_stmt|;
name|bool
name|is_simple_use
decl_stmt|;
name|tree
name|orig_stmt
decl_stmt|;
name|stmt_vec_info
name|orig_stmt_info
decl_stmt|;
name|tree
name|expr
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 1. Is vectorizable reduction?  */
comment|/* Not supportable if the reduction variable is used in the loop.  */
if|if
condition|(
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Make sure it was already recognized as a reduction computation.  */
if|if
condition|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_info
argument_list|)
operator|!=
name|vect_reduction_def
condition|)
return|return
name|false
return|;
comment|/* 2. Has this been recognized as a reduction pattern?        Check if STMT represents a pattern that has been recognized      in earlier analysis stages.  For stmts that represent a pattern,      the STMT_VINFO_RELATED_STMT field records the last stmt in      the original sequence that constitutes the pattern.  */
name|orig_stmt
operator|=
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stmt
condition|)
block|{
name|orig_stmt_info
operator|=
name|vinfo_for_stmt
argument_list|(
name|orig_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|orig_stmt_info
argument_list|)
operator|==
name|stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|STMT_VINFO_IN_PATTERN_P
argument_list|(
name|orig_stmt_info
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|STMT_VINFO_IN_PATTERN_P
argument_list|(
name|stmt_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 3. Check the operands of the operation. The first operands are defined         inside the loop body. The last operand is the reduction variable,         which is defined by the loop-header-phi.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|operation
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|operation
argument_list|)
expr_stmt|;
name|op_type
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_type
operator|!=
name|binary_op
operator|&&
name|op_type
operator|!=
name|ternary_op
condition|)
return|return
name|false
return|;
name|scalar_dest
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scalar_type
operator|=
name|TREE_TYPE
argument_list|(
name|scalar_dest
argument_list|)
expr_stmt|;
comment|/* All uses but the last are expected to be defined in the loop.      The last use is the reduction variable.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op_type
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|is_simple_use
operator|=
name|vect_is_simple_use
argument_list|(
name|op
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|is_simple_use
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|dt
operator|==
name|vect_loop_def
operator|||
name|dt
operator|==
name|vect_invariant_def
operator|||
name|dt
operator|==
name|vect_constant_def
argument_list|)
expr_stmt|;
block|}
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|is_simple_use
operator|=
name|vect_is_simple_use
argument_list|(
name|op
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|is_simple_use
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|dt
operator|==
name|vect_reduction_def
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|def_stmt
argument_list|)
operator|==
name|PHI_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stmt
condition|)
name|gcc_assert
argument_list|(
name|orig_stmt
operator|==
name|vect_is_simple_reduction
argument_list|(
name|loop
argument_list|,
name|def_stmt
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|gcc_assert
argument_list|(
name|stmt
operator|==
name|vect_is_simple_reduction
argument_list|(
name|loop
argument_list|,
name|def_stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|STMT_VINFO_LIVE_P
argument_list|(
name|vinfo_for_stmt
argument_list|(
name|def_stmt
argument_list|)
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* 4. Supportable by target?  */
comment|/* 4.1. check support for the operation in the loop  */
name|optab
operator|=
name|optab_for_tree_code
argument_list|(
name|code
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|optab
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"no optab."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|vec_mode
operator|=
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
if|if
condition|(
name|optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|vec_mode
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"op not supported by target."
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|vec_mode
argument_list|)
operator|!=
name|UNITS_PER_WORD
operator|||
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
operator|<
name|vect_min_worthwhile_factor
argument_list|(
name|code
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"proceeding using word mode."
argument_list|)
expr_stmt|;
block|}
comment|/* Worthwhile without SIMD support?  */
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
argument_list|)
operator|&&
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
operator|<
name|vect_min_worthwhile_factor
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not worthwhile without SIMD support."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* 4.2. Check support for the epilog operation.            If STMT represents a reduction pattern, then the type of the           reduction variable may be different than the type of the rest           of the arguments.  For example, consider the case of accumulation           of shorts into an int accumulator; The original code:                         S1: int_a = (int) short_a;           orig_stmt->   S2: int_acc = plus<int_a ,int_acc>;            was replaced with:                         STMT: int_acc = widen_sum<short_a, int_acc>            This means that:           1. The tree-code that is used to create the vector operation in the               epilog code (that reduces the partial results) is not the               tree-code of STMT, but is rather the tree-code of the original               stmt from the pattern that STMT is replacing. I.e, in the example               above we want to use 'widen_sum' in the loop, but 'plus' in the               epilog.           2. The type (mode) we use to check available target support              for the vector operation to be created in the *epilog*, is               determined by the type of the reduction variable (in the example               above we'd check this: plus_optab[vect_int_mode]).              However the type (mode) we use to check available target support              for the vector operation to be created *inside the loop*, is              determined by the type of the other arguments to STMT (in the              example we'd check this: widen_sum_optab[vect_short_mode]).              This is contrary to "regular" reductions, in which the types of all            the arguments are the same as the type of the reduction variable.            For "regular" reductions we can therefore use the same vector type            (and also the same tree-code) when generating the epilog code and           when generating the code inside the loop.  */
if|if
condition|(
name|orig_stmt
condition|)
block|{
comment|/* This is a reduction pattern: get the vectype from the type of the          reduction variable, and get the tree-code from orig_stmt.  */
name|orig_code
operator|=
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|orig_stmt
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|vectype
operator|=
name|get_vectype_for_scalar_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
name|vec_mode
operator|=
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Regular reduction: use the same vectype and tree-code as used for          the vector code inside the loop can be used for the epilog code. */
name|orig_code
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reduction_code_for_scalar_code
argument_list|(
name|orig_code
argument_list|,
operator|&
name|epilog_reduc_code
argument_list|)
condition|)
return|return
name|false
return|;
name|reduc_optab
operator|=
name|optab_for_tree_code
argument_list|(
name|epilog_reduc_code
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reduc_optab
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"no optab for reduction."
argument_list|)
expr_stmt|;
name|epilog_reduc_code
operator|=
name|NUM_TREE_CODES
expr_stmt|;
block|}
if|if
condition|(
name|reduc_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|vec_mode
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduc op not supported by target."
argument_list|)
expr_stmt|;
name|epilog_reduc_code
operator|=
name|NUM_TREE_CODES
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vec_stmt
condition|)
comment|/* transformation not required.  */
block|{
name|STMT_VINFO_TYPE
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|reduc_vec_info_type
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/** Transform.  **/
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"transform reduction."
argument_list|)
expr_stmt|;
comment|/* Create the destination vector  */
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
comment|/* Create the reduction-phi that defines the reduction-operand.  */
name|new_phi
operator|=
name|create_phi_node
argument_list|(
name|vec_dest
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
comment|/* Prepare the operand that is defined inside the loop body  */
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loop_vec_def0
operator|=
name|vect_get_vec_def_for_operand
argument_list|(
name|op
argument_list|,
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_type
operator|==
name|binary_op
condition|)
name|expr
operator|=
name|build2
argument_list|(
name|code
argument_list|,
name|vectype
argument_list|,
name|loop_vec_def0
argument_list|,
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op_type
operator|==
name|ternary_op
condition|)
block|{
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|loop_vec_def1
operator|=
name|vect_get_vec_def_for_operand
argument_list|(
name|op
argument_list|,
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build3
argument_list|(
name|code
argument_list|,
name|vectype
argument_list|,
name|loop_vec_def0
argument_list|,
name|loop_vec_def1
argument_list|,
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Create the vectorized operation that computes the partial results  */
operator|*
name|vec_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
operator|*
name|vec_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|vec_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|vect_finish_stmt_generation
argument_list|(
name|stmt
argument_list|,
operator|*
name|vec_stmt
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
comment|/* Finalize the reduction-phi (set it's arguments) and create the      epilog reduction code.  */
name|vect_create_epilog_for_reduction
argument_list|(
name|new_temp
argument_list|,
name|stmt
argument_list|,
name|epilog_reduc_code
argument_list|,
name|new_phi
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vectorizable_assignment.     Check if STMT performs an assignment (copy) that can be vectorized.     If VEC_STMT is also passed, vectorize the STMT: create a vectorized     stmt to replace it, put it in VEC_STMT, and insert it at BSI.    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */
end_comment

begin_function
name|bool
name|vectorizable_assignment
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
modifier|*
name|vec_stmt
parameter_list|)
block|{
name|tree
name|vec_dest
decl_stmt|;
name|tree
name|scalar_dest
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|tree
name|vec_oprnd
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|tree
name|new_temp
decl_stmt|;
name|tree
name|def
decl_stmt|,
name|def_stmt
decl_stmt|;
name|enum
name|vect_def_type
name|dt
decl_stmt|;
comment|/* Is vectorizable assignment?  */
if|if
condition|(
operator|!
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
return|return
name|false
return|;
name|gcc_assert
argument_list|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_info
argument_list|)
operator|==
name|vect_loop_def
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|scalar_dest
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scalar_dest
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vect_is_simple_use
argument_list|(
name|op
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"use not simple."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|vec_stmt
condition|)
comment|/* transformation not required.  */
block|{
name|STMT_VINFO_TYPE
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|assignment_vec_info_type
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/** Transform.  **/
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"transform assignment."
argument_list|)
expr_stmt|;
comment|/* Handle def.  */
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
comment|/* Handle use.  */
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vec_oprnd
operator|=
name|vect_get_vec_def_for_operand
argument_list|(
name|op
argument_list|,
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Arguments are ready. create the new vector stmt.  */
operator|*
name|vec_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|vec_oprnd
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
operator|*
name|vec_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|vec_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|vect_finish_stmt_generation
argument_list|(
name|stmt
argument_list|,
operator|*
name|vec_stmt
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_min_worthwhile_factor.     For a loop where we could vectorize the operation indicated by CODE,    return the minimum vectorization factor that makes it worthwhile    to use generic vectors.  */
end_comment

begin_function
specifier|static
name|int
name|vect_min_worthwhile_factor
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|)
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
case|case
name|NEGATE_EXPR
case|:
return|return
literal|4
return|;
case|case
name|BIT_AND_EXPR
case|:
case|case
name|BIT_IOR_EXPR
case|:
case|case
name|BIT_XOR_EXPR
case|:
case|case
name|BIT_NOT_EXPR
case|:
return|return
literal|2
return|;
default|default:
return|return
name|INT_MAX
return|;
block|}
block|}
end_function

begin_comment
comment|/* Function vectorizable_operation.     Check if STMT performs a binary or unary operation that can be vectorized.     If VEC_STMT is also passed, vectorize the STMT: create a vectorized     stmt to replace it, put it in VEC_STMT, and insert it at BSI.    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */
end_comment

begin_function
name|bool
name|vectorizable_operation
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
modifier|*
name|vec_stmt
parameter_list|)
block|{
name|tree
name|vec_dest
decl_stmt|;
name|tree
name|scalar_dest
decl_stmt|;
name|tree
name|operation
decl_stmt|;
name|tree
name|op0
decl_stmt|,
name|op1
init|=
name|NULL
decl_stmt|;
name|tree
name|vec_oprnd0
decl_stmt|,
name|vec_oprnd1
init|=
name|NULL
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|vec_mode
decl_stmt|;
name|tree
name|new_temp
decl_stmt|;
name|int
name|op_type
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|optab
name|optab
decl_stmt|;
name|int
name|icode
decl_stmt|;
name|enum
name|machine_mode
name|optab_op2_mode
decl_stmt|;
name|tree
name|def
decl_stmt|,
name|def_stmt
decl_stmt|;
name|enum
name|vect_def_type
name|dt
decl_stmt|;
comment|/* Is STMT a vectorizable binary/unary operation?   */
if|if
condition|(
operator|!
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
return|return
name|false
return|;
name|gcc_assert
argument_list|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_info
argument_list|)
operator|==
name|vect_loop_def
argument_list|)
expr_stmt|;
if|if
condition|(
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
comment|/* FORNOW: not yet supported.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"value used after loop."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
name|operation
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|operation
argument_list|)
expr_stmt|;
name|optab
operator|=
name|optab_for_tree_code
argument_list|(
name|code
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
comment|/* Support only unary or binary operations.  */
name|op_type
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_type
operator|!=
name|unary_op
operator|&&
name|op_type
operator|!=
name|binary_op
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"num. args = %d (not unary/binary op)."
argument_list|,
name|op_type
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op_type
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vect_is_simple_use
argument_list|(
name|op
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"use not simple."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Supportable by target?  */
if|if
condition|(
operator|!
name|optab
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"no optab."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|vec_mode
operator|=
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
name|icode
operator|=
operator|(
name|int
operator|)
name|optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|vec_mode
index|]
operator|.
name|insn_code
expr_stmt|;
if|if
condition|(
name|icode
operator|==
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"op not supported by target."
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|vec_mode
argument_list|)
operator|!=
name|UNITS_PER_WORD
operator|||
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
operator|<
name|vect_min_worthwhile_factor
argument_list|(
name|code
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"proceeding using word mode."
argument_list|)
expr_stmt|;
block|}
comment|/* Worthwhile without SIMD support?  */
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
argument_list|)
operator|&&
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
operator|<
name|vect_min_worthwhile_factor
argument_list|(
name|code
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"not worthwhile without SIMD support."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|code
operator|==
name|LSHIFT_EXPR
operator|||
name|code
operator|==
name|RSHIFT_EXPR
condition|)
block|{
comment|/* FORNOW: not yet supported.  */
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|vec_mode
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* Invariant argument is needed for a vector shift 	 by a scalar shift operand.  */
name|optab_op2_mode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|VECTOR_MODE_P
argument_list|(
name|optab_op2_mode
argument_list|)
operator|||
name|dt
operator|==
name|vect_constant_def
operator|||
name|dt
operator|==
name|vect_invariant_def
operator|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"operand mode requires invariant argument."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|vec_stmt
condition|)
comment|/* transformation not required.  */
block|{
name|STMT_VINFO_TYPE
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|op_vec_info_type
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/** Transform.  **/
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"transform binary/unary operation."
argument_list|)
expr_stmt|;
comment|/* Handle def.  */
name|scalar_dest
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
comment|/* Handle uses.  */
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vec_oprnd0
operator|=
name|vect_get_vec_def_for_operand
argument_list|(
name|op0
argument_list|,
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_type
operator|==
name|binary_op
condition|)
block|{
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|LSHIFT_EXPR
operator|||
name|code
operator|==
name|RSHIFT_EXPR
condition|)
block|{
comment|/* Vector shl and shr insn patterns can be defined with 	     scalar operand 2 (shift operand).  In this case, use 	     constant or loop invariant op1 directly, without 	     extending it to vector mode first.  */
name|optab_op2_mode
operator|=
name|insn_data
index|[
name|icode
index|]
operator|.
name|operand
index|[
literal|2
index|]
operator|.
name|mode
expr_stmt|;
if|if
condition|(
operator|!
name|VECTOR_MODE_P
argument_list|(
name|optab_op2_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"operand 1 using scalar mode."
argument_list|)
expr_stmt|;
name|vec_oprnd1
operator|=
name|op1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|vec_oprnd1
condition|)
name|vec_oprnd1
operator|=
name|vect_get_vec_def_for_operand
argument_list|(
name|op1
argument_list|,
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Arguments are ready. create the new vector stmt.  */
if|if
condition|(
name|op_type
operator|==
name|binary_op
condition|)
operator|*
name|vec_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|build2
argument_list|(
name|code
argument_list|,
name|vectype
argument_list|,
name|vec_oprnd0
argument_list|,
name|vec_oprnd1
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|vec_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|build1
argument_list|(
name|code
argument_list|,
name|vectype
argument_list|,
name|vec_oprnd0
argument_list|)
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
operator|*
name|vec_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|vec_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|vect_finish_stmt_generation
argument_list|(
name|stmt
argument_list|,
operator|*
name|vec_stmt
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vectorizable_store.     Check if STMT defines a non scalar data-ref (array/pointer/structure) that     can be vectorized.     If VEC_STMT is also passed, vectorize the STMT: create a vectorized     stmt to replace it, put it in VEC_STMT, and insert it at BSI.    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */
end_comment

begin_function
name|bool
name|vectorizable_store
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
modifier|*
name|vec_stmt
parameter_list|)
block|{
name|tree
name|scalar_dest
decl_stmt|;
name|tree
name|data_ref
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|tree
name|vec_oprnd1
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
init|=
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|vec_mode
decl_stmt|;
name|tree
name|dummy
decl_stmt|;
name|enum
name|dr_alignment_support
name|alignment_support_cheme
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|tree
name|def
decl_stmt|,
name|def_stmt
decl_stmt|;
name|enum
name|vect_def_type
name|dt
decl_stmt|;
comment|/* Is vectorizable store? */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|scalar_dest
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scalar_dest
argument_list|)
operator|!=
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|scalar_dest
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
return|return
name|false
return|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vect_is_simple_use
argument_list|(
name|op
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"use not simple."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|vec_mode
operator|=
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
comment|/* FORNOW. In some cases can vectorize even if data-type not supported      (e.g. - array initialization with 0).  */
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|vec_mode
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|vec_stmt
condition|)
comment|/* transformation not required.  */
block|{
name|STMT_VINFO_TYPE
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|store_vec_info_type
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/** Transform.  **/
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"transform store"
argument_list|)
expr_stmt|;
name|alignment_support_cheme
operator|=
name|vect_supportable_dr_alignment
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|alignment_support_cheme
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|alignment_support_cheme
operator|==
name|dr_aligned
argument_list|)
expr_stmt|;
comment|/* FORNOW */
comment|/* Handle use - get the vectorized def from the defining stmt.  */
name|vec_oprnd1
operator|=
name|vect_get_vec_def_for_operand
argument_list|(
name|op
argument_list|,
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Handle def.  */
comment|/* FORNOW: make sure the data reference is aligned.  */
name|vect_align_data_ref
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|data_ref
operator|=
name|vect_create_data_ref_ptr
argument_list|(
name|stmt
argument_list|,
name|bsi
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|dummy
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|data_ref
operator|=
name|build_fold_indirect_ref
argument_list|(
name|data_ref
argument_list|)
expr_stmt|;
comment|/* Arguments are ready. create the new vector stmt.  */
operator|*
name|vec_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|data_ref
argument_list|,
name|vec_oprnd1
argument_list|)
expr_stmt|;
name|vect_finish_stmt_generation
argument_list|(
name|stmt
argument_list|,
operator|*
name|vec_stmt
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
comment|/* Copy the V_MAY_DEFS representing the aliasing of the original array      element's definition to the vector's definition then update the      defining statement.  The original is being deleted so the same      SSA_NAMEs can be used.  */
name|copy_virtual_operands
argument_list|(
operator|*
name|vec_stmt
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|FOR_EACH_SSA_TREE_OPERAND
argument_list|(
argument|def
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VMAYDEF
argument_list|)
block|{
name|SSA_NAME_DEF_STMT
argument_list|(
name|def
argument_list|)
operator|=
operator|*
name|vec_stmt
expr_stmt|;
comment|/* If this virtual def has a use outside the loop and a loop peel is  	 performed then the def may be renamed by the peel.  Mark it for  	 renaming so the later use will also be renamed.  */
name|mark_sym_for_renaming
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|def
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* vectorizable_load.     Check if STMT reads a non scalar data-ref (array/pointer/structure) that     can be vectorized.     If VEC_STMT is also passed, vectorize the STMT: create a vectorized     stmt to replace it, put it in VEC_STMT, and insert it at BSI.    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */
end_comment

begin_function
name|bool
name|vectorizable_load
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
modifier|*
name|vec_stmt
parameter_list|)
block|{
name|tree
name|scalar_dest
decl_stmt|;
name|tree
name|vec_dest
init|=
name|NULL
decl_stmt|;
name|tree
name|data_ref
init|=
name|NULL
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
init|=
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|tree
name|new_temp
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|tree
name|init_addr
decl_stmt|;
name|tree
name|new_stmt
decl_stmt|;
name|tree
name|dummy
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|edge
name|pe
init|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|enum
name|dr_alignment_support
name|alignment_support_cheme
decl_stmt|;
comment|/* Is vectorizable load? */
if|if
condition|(
operator|!
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
return|return
name|false
return|;
name|gcc_assert
argument_list|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_info
argument_list|)
operator|==
name|vect_loop_def
argument_list|)
expr_stmt|;
if|if
condition|(
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
comment|/* FORNOW: not yet supported.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"value used after loop."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|scalar_dest
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scalar_dest
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|INDIRECT_REF
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|STMT_VINFO_DATA_REF
argument_list|(
name|stmt_info
argument_list|)
condition|)
return|return
name|false
return|;
name|mode
operator|=
operator|(
name|int
operator|)
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
comment|/* FORNOW. In some cases can vectorize even if data-type not supported     (e.g. - data copies).  */
if|if
condition|(
name|mov_optab
operator|->
name|handlers
index|[
name|mode
index|]
operator|.
name|insn_code
operator|==
name|CODE_FOR_nothing
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"Aligned load, but unsupported type."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
operator|!
name|vec_stmt
condition|)
comment|/* transformation not required.  */
block|{
name|STMT_VINFO_TYPE
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|load_vec_info_type
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/** Transform.  **/
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"transform load."
argument_list|)
expr_stmt|;
name|alignment_support_cheme
operator|=
name|vect_supportable_dr_alignment
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|alignment_support_cheme
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment_support_cheme
operator|==
name|dr_aligned
operator|||
name|alignment_support_cheme
operator|==
name|dr_unaligned_supported
condition|)
block|{
comment|/* Create:          p = initial_addr;          indx = 0;          loop {            vec_dest = *(p);            indx = indx + 1;          }       */
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
name|data_ref
operator|=
name|vect_create_data_ref_ptr
argument_list|(
name|stmt
argument_list|,
name|bsi
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|dummy
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|aligned_access_p
argument_list|(
name|dr
argument_list|)
condition|)
name|data_ref
operator|=
name|build_fold_indirect_ref
argument_list|(
name|data_ref
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|mis
init|=
name|DR_MISALIGNMENT
argument_list|(
name|dr
argument_list|)
decl_stmt|;
name|tree
name|tmis
init|=
operator|(
name|mis
operator|==
operator|-
literal|1
condition|?
name|size_zero_node
else|:
name|size_int
argument_list|(
name|mis
argument_list|)
operator|)
decl_stmt|;
name|tmis
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|tmis
argument_list|,
name|size_int
argument_list|(
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
name|data_ref
operator|=
name|build2
argument_list|(
name|MISALIGNED_INDIRECT_REF
argument_list|,
name|vectype
argument_list|,
name|data_ref
argument_list|,
name|tmis
argument_list|)
expr_stmt|;
block|}
name|new_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|data_ref
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
name|new_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|new_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|vect_finish_stmt_generation
argument_list|(
name|stmt
argument_list|,
name|new_stmt
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
name|copy_virtual_operands
argument_list|(
name|new_stmt
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alignment_support_cheme
operator|==
name|dr_unaligned_software_pipeline
condition|)
block|{
comment|/* Create: 	 p1 = initial_addr; 	 msq_init = *(floor(p1)) 	 p2 = initial_addr + VS - 1; 	 magic = have_builtin ? builtin_result : initial_address; 	 indx = 0; 	 loop { 	   p2' = p2 + indx * vectype_size 	   lsq = *(floor(p2')) 	   vec_dest = realign_load (msq, lsq, magic) 	   indx = indx + 1; 	   msq = lsq; 	 }       */
name|tree
name|offset
decl_stmt|;
name|tree
name|magic
decl_stmt|;
name|tree
name|phi_stmt
decl_stmt|;
name|tree
name|msq_init
decl_stmt|;
name|tree
name|msq
decl_stmt|,
name|lsq
decl_stmt|;
name|tree
name|dataref_ptr
decl_stmt|;
name|tree
name|params
decl_stmt|;
comment|/*<1> Create msq_init = *(floor(p1)) in the loop preheader  */
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
name|data_ref
operator|=
name|vect_create_data_ref_ptr
argument_list|(
name|stmt
argument_list|,
name|bsi
argument_list|,
name|NULL_TREE
argument_list|,
operator|&
name|init_addr
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|data_ref
operator|=
name|build1
argument_list|(
name|ALIGN_INDIRECT_REF
argument_list|,
name|vectype
argument_list|,
name|data_ref
argument_list|)
expr_stmt|;
name|new_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|data_ref
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
name|new_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|new_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|new_bb
operator|=
name|bsi_insert_on_edge_immediate
argument_list|(
name|pe
argument_list|,
name|new_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|new_bb
argument_list|)
expr_stmt|;
name|msq_init
operator|=
name|TREE_OPERAND
argument_list|(
name|new_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_virtual_operands
argument_list|(
name|new_stmt
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|update_vuses_to_preheader
argument_list|(
name|new_stmt
argument_list|,
name|loop
argument_list|)
expr_stmt|;
comment|/*<2> Create lsq = *(floor(p2')) in the loop  */
name|offset
operator|=
name|size_int
argument_list|(
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|vectype
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
name|dataref_ptr
operator|=
name|vect_create_data_ref_ptr
argument_list|(
name|stmt
argument_list|,
name|bsi
argument_list|,
name|offset
argument_list|,
operator|&
name|dummy
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|data_ref
operator|=
name|build1
argument_list|(
name|ALIGN_INDIRECT_REF
argument_list|,
name|vectype
argument_list|,
name|dataref_ptr
argument_list|)
expr_stmt|;
name|new_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|data_ref
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
name|new_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|new_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|vect_finish_stmt_generation
argument_list|(
name|stmt
argument_list|,
name|new_stmt
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
name|lsq
operator|=
name|TREE_OPERAND
argument_list|(
name|new_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|copy_virtual_operands
argument_list|(
name|new_stmt
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
comment|/*<3> */
if|if
condition|(
name|targetm
operator|.
name|vectorize
operator|.
name|builtin_mask_for_load
condition|)
block|{
comment|/* Create permutation mask, if required, in loop preheader.  */
name|tree
name|builtin_decl
decl_stmt|;
name|params
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|init_addr
argument_list|)
expr_stmt|;
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
name|builtin_decl
operator|=
name|targetm
operator|.
name|vectorize
operator|.
name|builtin_mask_for_load
argument_list|()
expr_stmt|;
name|new_stmt
operator|=
name|build_function_call_expr
argument_list|(
name|builtin_decl
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|new_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|new_stmt
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
name|new_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|new_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|new_bb
operator|=
name|bsi_insert_on_edge_immediate
argument_list|(
name|pe
argument_list|,
name|new_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|new_bb
argument_list|)
expr_stmt|;
name|magic
operator|=
name|TREE_OPERAND
argument_list|(
name|new_stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The result of the CALL_EXPR to this builtin is determined from 	     the value of the parameter and no global variables are touched 	     which makes the builtin a "const" function.  Requiring the 	     builtin to have the "const" attribute makes it unnecessary 	     to call mark_call_clobbered.  */
name|gcc_assert
argument_list|(
name|TREE_READONLY
argument_list|(
name|builtin_decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use current address instead of init_addr for reduced reg pressure. 	   */
name|magic
operator|=
name|dataref_ptr
expr_stmt|;
block|}
comment|/*<4> Create msq = phi<msq_init, lsq> in loop  */
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
name|msq
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|phi_stmt
operator|=
name|create_phi_node
argument_list|(
name|msq
argument_list|,
name|loop
operator|->
name|header
argument_list|)
expr_stmt|;
comment|/* CHECKME */
name|SSA_NAME_DEF_STMT
argument_list|(
name|msq
argument_list|)
operator|=
name|phi_stmt
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi_stmt
argument_list|,
name|msq_init
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|phi_stmt
argument_list|,
name|lsq
argument_list|,
name|loop_latch_edge
argument_list|(
name|loop
argument_list|)
argument_list|)
expr_stmt|;
comment|/*<5> Create<vec_dest = realign_load (msq, lsq, magic)> in loop  */
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
name|new_stmt
operator|=
name|build3
argument_list|(
name|REALIGN_LOAD_EXPR
argument_list|,
name|vectype
argument_list|,
name|msq
argument_list|,
name|lsq
argument_list|,
name|magic
argument_list|)
expr_stmt|;
name|new_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|new_stmt
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
name|new_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|new_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|vect_finish_stmt_generation
argument_list|(
name|stmt
argument_list|,
name|new_stmt
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
operator|*
name|vec_stmt
operator|=
name|new_stmt
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vectorizable_live_operation.     STMT computes a value that is used outside the loop. Check if     it can be supported.  */
end_comment

begin_function
name|bool
name|vectorizable_live_operation
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
name|ATTRIBUTE_UNUSED
parameter_list|,
name|tree
modifier|*
name|vec_stmt
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|operation
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|op_type
decl_stmt|;
name|tree
name|op
decl_stmt|;
name|tree
name|def
decl_stmt|,
name|def_stmt
decl_stmt|;
name|enum
name|vect_def_type
name|dt
decl_stmt|;
if|if
condition|(
operator|!
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|false
return|;
name|operation
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|operation
argument_list|)
expr_stmt|;
name|op_type
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* FORNOW: support only if all uses are invariant. This means      that the scalar operations can remain in place, unvectorized.      The original last scalar value that they compute will be used.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op_type
condition|;
name|i
operator|++
control|)
block|{
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|operation
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vect_is_simple_use
argument_list|(
name|op
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"use not simple."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|dt
operator|!=
name|vect_invariant_def
operator|&&
name|dt
operator|!=
name|vect_constant_def
condition|)
return|return
name|false
return|;
block|}
comment|/* No transformation is required for the cases we currently support.  */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_is_simple_cond.       Input:    LOOP - the loop that is being vectorized.    COND - Condition that is checked for simple use.     Returns whether a COND can be vectorized.  Checks whether    condition operands are supportable using vec_is_simple_use.  */
end_comment

begin_function
specifier|static
name|bool
name|vect_is_simple_cond
parameter_list|(
name|tree
name|cond
parameter_list|,
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|;
name|tree
name|def
decl_stmt|;
name|enum
name|vect_def_type
name|dt
decl_stmt|;
if|if
condition|(
operator|!
name|COMPARISON_CLASS_P
argument_list|(
name|cond
argument_list|)
condition|)
return|return
name|false
return|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|lhs_def_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vect_is_simple_use
argument_list|(
name|lhs
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|lhs_def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
operator|!=
name|REAL_CST
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|rhs_def_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vect_is_simple_use
argument_list|(
name|rhs
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|rhs_def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|!=
name|REAL_CST
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* vectorizable_condition.     Check if STMT is conditional modify expression that can be vectorized.     If VEC_STMT is also passed, vectorize the STMT: create a vectorized     stmt using VEC_COND_EXPR  to replace it, put it in VEC_STMT, and insert it     at BSI.     Return FALSE if not a vectorizable STMT, TRUE otherwise.  */
end_comment

begin_function
name|bool
name|vectorizable_condition
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
modifier|*
name|vec_stmt
parameter_list|)
block|{
name|tree
name|scalar_dest
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|vec_dest
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|op
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|cond_expr
decl_stmt|,
name|then_clause
decl_stmt|,
name|else_clause
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|tree
name|vec_cond_lhs
decl_stmt|,
name|vec_cond_rhs
decl_stmt|,
name|vec_then_clause
decl_stmt|,
name|vec_else_clause
decl_stmt|;
name|tree
name|vec_compare
decl_stmt|,
name|vec_cond_expr
decl_stmt|;
name|tree
name|new_temp
decl_stmt|;
name|loop_vec_info
name|loop_vinfo
init|=
name|STMT_VINFO_LOOP_VINFO
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|vec_mode
decl_stmt|;
name|tree
name|def
decl_stmt|;
name|enum
name|vect_def_type
name|dt
decl_stmt|;
if|if
condition|(
operator|!
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
return|return
name|false
return|;
name|gcc_assert
argument_list|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|stmt_info
argument_list|)
operator|==
name|vect_loop_def
argument_list|)
expr_stmt|;
if|if
condition|(
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
comment|/* FORNOW: not yet supported.  */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"value used after loop."
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
return|return
name|false
return|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
name|false
return|;
name|cond_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|then_clause
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|else_clause
operator|=
name|TREE_OPERAND
argument_list|(
name|op
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vect_is_simple_cond
argument_list|(
name|cond_expr
argument_list|,
name|loop_vinfo
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* We do not handle two different vector types for the condition      and the values.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond_expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|vectype
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|then_clause
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|then_def_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|then_clause
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vect_is_simple_use
argument_list|(
name|then_clause
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|then_def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|then_clause
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|then_clause
argument_list|)
operator|!=
name|REAL_CST
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|else_clause
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|else_def_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|else_clause
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vect_is_simple_use
argument_list|(
name|else_clause
argument_list|,
name|loop_vinfo
argument_list|,
operator|&
name|else_def_stmt
argument_list|,
operator|&
name|def
argument_list|,
operator|&
name|dt
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|else_clause
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|else_clause
argument_list|)
operator|!=
name|REAL_CST
condition|)
return|return
name|false
return|;
name|vec_mode
operator|=
name|TYPE_MODE
argument_list|(
name|vectype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vec_stmt
condition|)
block|{
name|STMT_VINFO_TYPE
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|condition_vec_info_type
expr_stmt|;
return|return
name|expand_vec_cond_expr_p
argument_list|(
name|op
argument_list|,
name|vec_mode
argument_list|)
return|;
block|}
comment|/* Transform */
comment|/* Handle def.  */
name|scalar_dest
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vec_dest
operator|=
name|vect_create_destination_var
argument_list|(
name|scalar_dest
argument_list|,
name|vectype
argument_list|)
expr_stmt|;
comment|/* Handle cond expr.  */
name|vec_cond_lhs
operator|=
name|vect_get_vec_def_for_operand
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond_expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vec_cond_rhs
operator|=
name|vect_get_vec_def_for_operand
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond_expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vec_then_clause
operator|=
name|vect_get_vec_def_for_operand
argument_list|(
name|then_clause
argument_list|,
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vec_else_clause
operator|=
name|vect_get_vec_def_for_operand
argument_list|(
name|else_clause
argument_list|,
name|stmt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Arguments are ready. create the new vector stmt.  */
name|vec_compare
operator|=
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|cond_expr
argument_list|)
argument_list|,
name|vectype
argument_list|,
name|vec_cond_lhs
argument_list|,
name|vec_cond_rhs
argument_list|)
expr_stmt|;
name|vec_cond_expr
operator|=
name|build3
argument_list|(
name|VEC_COND_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_compare
argument_list|,
name|vec_then_clause
argument_list|,
name|vec_else_clause
argument_list|)
expr_stmt|;
operator|*
name|vec_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|vectype
argument_list|,
name|vec_dest
argument_list|,
name|vec_cond_expr
argument_list|)
expr_stmt|;
name|new_temp
operator|=
name|make_ssa_name
argument_list|(
name|vec_dest
argument_list|,
operator|*
name|vec_stmt
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|vec_stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|new_temp
expr_stmt|;
name|vect_finish_stmt_generation
argument_list|(
name|stmt
argument_list|,
operator|*
name|vec_stmt
argument_list|,
name|bsi
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Function vect_transform_stmt.     Create a vectorized stmt to replace STMT, and insert it at BSI.  */
end_comment

begin_function
name|bool
name|vect_transform_stmt
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|)
block|{
name|bool
name|is_store
init|=
name|false
decl_stmt|;
name|tree
name|vec_stmt
init|=
name|NULL_TREE
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|orig_stmt_in_pattern
decl_stmt|;
name|bool
name|done
decl_stmt|;
if|if
condition|(
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|STMT_VINFO_TYPE
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
case|case
name|op_vec_info_type
case|:
name|done
operator|=
name|vectorizable_operation
argument_list|(
name|stmt
argument_list|,
name|bsi
argument_list|,
operator|&
name|vec_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|done
argument_list|)
expr_stmt|;
break|break;
case|case
name|assignment_vec_info_type
case|:
name|done
operator|=
name|vectorizable_assignment
argument_list|(
name|stmt
argument_list|,
name|bsi
argument_list|,
operator|&
name|vec_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|done
argument_list|)
expr_stmt|;
break|break;
case|case
name|load_vec_info_type
case|:
name|done
operator|=
name|vectorizable_load
argument_list|(
name|stmt
argument_list|,
name|bsi
argument_list|,
operator|&
name|vec_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|done
argument_list|)
expr_stmt|;
break|break;
case|case
name|store_vec_info_type
case|:
name|done
operator|=
name|vectorizable_store
argument_list|(
name|stmt
argument_list|,
name|bsi
argument_list|,
operator|&
name|vec_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|done
argument_list|)
expr_stmt|;
name|is_store
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|condition_vec_info_type
case|:
name|done
operator|=
name|vectorizable_condition
argument_list|(
name|stmt
argument_list|,
name|bsi
argument_list|,
operator|&
name|vec_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|done
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"stmt not supported."
argument_list|)
expr_stmt|;
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|vec_stmt
argument_list|)
expr_stmt|;
name|STMT_VINFO_VEC_STMT
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|vec_stmt
expr_stmt|;
name|orig_stmt_in_pattern
operator|=
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_stmt_in_pattern
condition|)
block|{
name|stmt_vec_info
name|stmt_vinfo
init|=
name|vinfo_for_stmt
argument_list|(
name|orig_stmt_in_pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|STMT_VINFO_IN_PATTERN_P
argument_list|(
name|stmt_vinfo
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
name|STMT_VINFO_RELATED_STMT
argument_list|(
name|stmt_vinfo
argument_list|)
operator|==
name|stmt
argument_list|)
expr_stmt|;
comment|/* STMT was inserted by the vectorizer to replace a computation                   idiom.  ORIG_STMT_IN_PATTERN is a stmt in the original                  sequence that computed this idiom.  We need to record a pointer                  to VEC_STMT in the stmt_info of ORIG_STMT_IN_PATTERN.  See more                  detail in the documentation of vect_pattern_recog.  */
name|STMT_VINFO_VEC_STMT
argument_list|(
name|stmt_vinfo
argument_list|)
operator|=
name|vec_stmt
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|STMT_VINFO_TYPE
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
case|case
name|reduc_vec_info_type
case|:
name|done
operator|=
name|vectorizable_reduction
argument_list|(
name|stmt
argument_list|,
name|bsi
argument_list|,
operator|&
name|vec_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|done
argument_list|)
expr_stmt|;
break|break;
default|default:
name|done
operator|=
name|vectorizable_live_operation
argument_list|(
name|stmt
argument_list|,
name|bsi
argument_list|,
operator|&
name|vec_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|done
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vec_stmt
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|STMT_VINFO_VEC_STMT
argument_list|(
name|stmt_info
argument_list|)
argument_list|)
expr_stmt|;
name|STMT_VINFO_VEC_STMT
argument_list|(
name|stmt_info
argument_list|)
operator|=
name|vec_stmt
expr_stmt|;
block|}
block|}
return|return
name|is_store
return|;
block|}
end_function

begin_comment
comment|/* This function builds ni_name = number of iterations loop executes    on the loop preheader.  */
end_comment

begin_function
specifier|static
name|tree
name|vect_build_loop_niters
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|)
block|{
name|tree
name|ni_name
decl_stmt|,
name|stmt
decl_stmt|,
name|var
decl_stmt|;
name|edge
name|pe
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|tree
name|ni
init|=
name|unshare_expr
argument_list|(
name|LOOP_VINFO_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
decl_stmt|;
name|var
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|ni
argument_list|)
argument_list|,
literal|"niters"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ni_name
operator|=
name|force_gimple_operand
argument_list|(
name|ni
argument_list|,
operator|&
name|stmt
argument_list|,
name|false
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|pe
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
condition|)
block|{
name|basic_block
name|new_bb
init|=
name|bsi_insert_on_edge_immediate
argument_list|(
name|pe
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|new_bb
argument_list|)
expr_stmt|;
block|}
return|return
name|ni_name
return|;
block|}
end_function

begin_comment
comment|/* This function generates the following statements:   ni_name = number of iterations loop executes  ratio = ni_name / vf  ratio_mult_vf_name = ratio * vf   and places them at the loop preheader edge.  */
end_comment

begin_function
specifier|static
name|void
name|vect_generate_tmps_on_preheader
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|,
name|tree
modifier|*
name|ni_name_ptr
parameter_list|,
name|tree
modifier|*
name|ratio_mult_vf_name_ptr
parameter_list|,
name|tree
modifier|*
name|ratio_name_ptr
parameter_list|)
block|{
name|edge
name|pe
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|ni_name
decl_stmt|;
name|tree
name|var
decl_stmt|;
name|tree
name|ratio_name
decl_stmt|;
name|tree
name|ratio_mult_vf_name
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|tree
name|ni
init|=
name|LOOP_VINFO_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|int
name|vf
init|=
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|tree
name|log_vf
decl_stmt|;
name|pe
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
comment|/* Generate temporary variable that contains       number of iterations loop executes.  */
name|ni_name
operator|=
name|vect_build_loop_niters
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|log_vf
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|ni
argument_list|)
argument_list|,
name|exact_log2
argument_list|(
name|vf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create: ratio = ni>> log2(vf) */
name|var
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|ni
argument_list|)
argument_list|,
literal|"bnd"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ratio_name
operator|=
name|make_ssa_name
argument_list|(
name|var
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ratio_name
argument_list|,
name|build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ni_name
argument_list|)
argument_list|,
name|ni_name
argument_list|,
name|log_vf
argument_list|)
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|ratio_name
argument_list|)
operator|=
name|stmt
expr_stmt|;
name|pe
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|bsi_insert_on_edge_immediate
argument_list|(
name|pe
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|new_bb
argument_list|)
expr_stmt|;
comment|/* Create: ratio_mult_vf = ratio<< log2 (vf).  */
name|var
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|ni
argument_list|)
argument_list|,
literal|"ratio_mult_vf"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ratio_mult_vf_name
operator|=
name|make_ssa_name
argument_list|(
name|var
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|ratio_mult_vf_name
argument_list|,
name|build2
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|ratio_name
argument_list|)
argument_list|,
name|ratio_name
argument_list|,
name|log_vf
argument_list|)
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|ratio_mult_vf_name
argument_list|)
operator|=
name|stmt
expr_stmt|;
name|pe
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|bsi_insert_on_edge_immediate
argument_list|(
name|pe
argument_list|,
name|stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|new_bb
argument_list|)
expr_stmt|;
operator|*
name|ni_name_ptr
operator|=
name|ni_name
expr_stmt|;
operator|*
name|ratio_mult_vf_name_ptr
operator|=
name|ratio_mult_vf_name
expr_stmt|;
operator|*
name|ratio_name_ptr
operator|=
name|ratio_name
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Function update_vuses_to_preheader.     Input:    STMT - a statement with potential VUSEs.    LOOP - the loop whose preheader will contain STMT.     It's possible to vectorize a loop even though an SSA_NAME from a VUSE    appears to be defined in a V_MAY_DEF in another statement in a loop.    One such case is when the VUSE is at the dereference of a __restricted__    pointer in a load and the V_MAY_DEF is at the dereference of a different    __restricted__ pointer in a store.  Vectorization may result in    copy_virtual_uses being called to copy the problematic VUSE to a new    statement that is being inserted in the loop preheader.  This procedure    is called to change the SSA_NAME in the new statement's VUSE from the    SSA_NAME updated in the loop to the related SSA_NAME available on the    path entering the loop.     When this function is called, we have the following situation:          # vuse<name1>         S1: vload     do {         # name1 = phi< name0 , name2>          # vuse<name1>         S2: vload          # name2 = vdef<name1>         S3: vstore      }while...     Stmt S1 was created in the loop preheader block as part of misaligned-load    handling. This function fixes the name of the vuse of S1 from 'name1' to    'name0'.  */
end_comment

begin_function
specifier|static
name|void
name|update_vuses_to_preheader
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|basic_block
name|header_bb
init|=
name|loop
operator|->
name|header
decl_stmt|;
name|edge
name|preheader_e
init|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
decl_stmt|;
name|ssa_op_iter
name|iter
decl_stmt|;
name|use_operand_p
name|use_p
decl_stmt|;
name|FOR_EACH_SSA_USE_OPERAND
argument_list|(
argument|use_p
argument_list|,
argument|stmt
argument_list|,
argument|iter
argument_list|,
argument|SSA_OP_VUSE
argument_list|)
block|{
name|tree
name|ssa_name
init|=
name|USE_FROM_PTR
argument_list|(
name|use_p
argument_list|)
decl_stmt|;
name|tree
name|def_stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|ssa_name
argument_list|)
decl_stmt|;
name|tree
name|name_var
init|=
name|SSA_NAME_VAR
argument_list|(
name|ssa_name
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|def_stmt
argument_list|)
decl_stmt|;
comment|/* For a use before any definitions, def_stmt is a NOP_EXPR.  */
if|if
condition|(
operator|!
name|IS_EMPTY_STMT
argument_list|(
name|def_stmt
argument_list|)
operator|&&
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
block|{
comment|/* If the block containing the statement defining the SSA_NAME              is in the loop then it's necessary to find the definition              outside the loop using the PHI nodes of the header.  */
name|tree
name|phi
decl_stmt|;
name|bool
name|updated
init|=
name|false
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|header_bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|TREE_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
if|if
condition|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
operator|==
name|name_var
condition|)
block|{
name|SET_USE
argument_list|(
name|use_p
argument_list|,
name|PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|preheader_e
operator|->
name|dest_idx
argument_list|)
argument_list|)
expr_stmt|;
name|updated
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|gcc_assert
argument_list|(
name|updated
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   Function vect_update_ivs_after_vectorizer.       "Advance" the induction variables of LOOP to the value they should take      after the execution of LOOP.  This is currently necessary because the      vectorizer does not handle induction variables that are used after the      loop.  Such a situation occurs when the last iterations of LOOP are      peeled, because:      1. We introduced new uses after LOOP for IVs that were not originally used         after LOOP: the IVs of LOOP are now used by an epilog loop.      2. LOOP is going to be vectorized; this means that it will iterate N/VF         times, whereas the loop IVs should be bumped N times.       Input:      - LOOP - a loop that is going to be vectorized. The last few iterations               of LOOP were peeled.      - NITERS - the number of iterations that LOOP executes (before it is                 vectorized). i.e, the number of times the ivs should be bumped.      - UPDATE_E - a successor edge of LOOP->exit that is on the (only) path                   coming out from LOOP on which there are uses of the LOOP ivs 		  (this is the path from LOOP->exit to epilog_loop->preheader).                    The new definitions of the ivs are placed in LOOP->exit.                   The phi args associated with the edge UPDATE_E in the bb                   UPDATE_E->dest are updated accordingly.       Assumption 1: Like the rest of the vectorizer, this function assumes      a single loop exit that has a single predecessor.       Assumption 2: The phi nodes in the LOOP header and in update_bb are      organized in the same order.       Assumption 3: The access function of the ivs is simple enough (see      vect_can_advance_ivs_p).  This assumption will be relaxed in the future.       Assumption 4: Exactly one of the successors of LOOP exit-bb is on a path      coming out of LOOP on which the ivs of LOOP are used (this is the path       that leads to the epilog loop; other paths skip the epilog loop).  This      path starts with the edge UPDATE_E, and its destination (denoted update_bb)      needs to have its phis updated.  */
end_comment

begin_function
specifier|static
name|void
name|vect_update_ivs_after_vectorizer
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|,
name|tree
name|niters
parameter_list|,
name|edge
name|update_e
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|basic_block
name|exit_bb
init|=
name|loop
operator|->
name|single_exit
operator|->
name|dest
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|phi1
decl_stmt|;
name|basic_block
name|update_bb
init|=
name|update_e
operator|->
name|dest
decl_stmt|;
comment|/* gcc_assert (vect_can_advance_ivs_p (loop_vinfo)); */
comment|/* Make sure there exists a single-predecessor exit bb:  */
name|gcc_assert
argument_list|(
name|single_pred_p
argument_list|(
name|exit_bb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|loop
operator|->
name|header
argument_list|)
operator|,
name|phi1
operator|=
name|phi_nodes
argument_list|(
name|update_bb
argument_list|)
init|;
name|phi
operator|&&
name|phi1
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
operator|,
name|phi1
operator|=
name|PHI_CHAIN
argument_list|(
name|phi1
argument_list|)
control|)
block|{
name|tree
name|access_fn
init|=
name|NULL
decl_stmt|;
name|tree
name|evolution_part
decl_stmt|;
name|tree
name|init_expr
decl_stmt|;
name|tree
name|step_expr
decl_stmt|;
name|tree
name|var
decl_stmt|,
name|stmt
decl_stmt|,
name|ni
decl_stmt|,
name|ni_name
decl_stmt|;
name|block_stmt_iterator
name|last_bsi
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"vect_update_ivs_after_vectorizer: phi: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|phi
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
comment|/* Skip virtual phi's.  */
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"virtual phi. skip."
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Skip reduction phis.  */
if|if
condition|(
name|STMT_VINFO_DEF_TYPE
argument_list|(
name|vinfo_for_stmt
argument_list|(
name|phi
argument_list|)
argument_list|)
operator|==
name|vect_reduction_def
condition|)
block|{
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"reduc phi. skip."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|access_fn
operator|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|access_fn
argument_list|)
expr_stmt|;
name|evolution_part
operator|=
name|unshare_expr
argument_list|(
name|evolution_part_in_loop_num
argument_list|(
name|access_fn
argument_list|,
name|loop
operator|->
name|num
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|evolution_part
operator|!=
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* FORNOW: We do not support IVs whose evolution function is a polynomial          of degree>= 2 or exponential.  */
name|gcc_assert
argument_list|(
operator|!
name|tree_is_chrec
argument_list|(
name|evolution_part
argument_list|)
argument_list|)
expr_stmt|;
name|step_expr
operator|=
name|evolution_part
expr_stmt|;
name|init_expr
operator|=
name|unshare_expr
argument_list|(
name|initial_condition_in_loop_num
argument_list|(
name|access_fn
argument_list|,
name|loop
operator|->
name|num
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|init_expr
argument_list|)
argument_list|,
name|build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|niters
argument_list|)
argument_list|,
name|niters
argument_list|,
name|step_expr
argument_list|)
argument_list|,
name|init_expr
argument_list|)
expr_stmt|;
name|var
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|init_expr
argument_list|)
argument_list|,
literal|"tmp"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ni_name
operator|=
name|force_gimple_operand
argument_list|(
name|ni
argument_list|,
operator|&
name|stmt
argument_list|,
name|false
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* Insert stmt into exit_bb.  */
name|last_bsi
operator|=
name|bsi_last
argument_list|(
name|exit_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmt
condition|)
name|bsi_insert_before
argument_list|(
operator|&
name|last_bsi
argument_list|,
name|stmt
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
comment|/* Fix phi expressions in the successor bb.  */
name|SET_PHI_ARG_DEF
argument_list|(
name|phi1
argument_list|,
name|update_e
operator|->
name|dest_idx
argument_list|,
name|ni_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function vect_do_peeling_for_loop_bound     Peel the last iterations of the loop represented by LOOP_VINFO.    The peeled iterations form a new epilog loop.  Given that the loop now     iterates NITERS times, the new epilog loop iterates    NITERS % VECTORIZATION_FACTOR times.        The original loop will later be made to iterate     NITERS / VECTORIZATION_FACTOR times (this value is placed into RATIO).  */
end_comment

begin_function
specifier|static
name|void
name|vect_do_peeling_for_loop_bound
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|,
name|tree
modifier|*
name|ratio
parameter_list|,
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|tree
name|ni_name
decl_stmt|,
name|ratio_mult_vf_name
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|new_loop
decl_stmt|;
name|edge
name|update_e
decl_stmt|;
name|basic_block
name|preheader
decl_stmt|;
name|int
name|loop_num
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_do_peeling_for_loop_bound ==="
argument_list|)
expr_stmt|;
name|initialize_original_copy_tables
argument_list|()
expr_stmt|;
comment|/* Generate the following variables on the preheader of original loop: 	       ni_name = number of iteration the original loop executes      ratio = ni_name / vf      ratio_mult_vf_name = ratio * vf  */
name|vect_generate_tmps_on_preheader
argument_list|(
name|loop_vinfo
argument_list|,
operator|&
name|ni_name
argument_list|,
operator|&
name|ratio_mult_vf_name
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|loop_num
operator|=
name|loop
operator|->
name|num
expr_stmt|;
name|new_loop
operator|=
name|slpeel_tree_peel_loop_to_edge
argument_list|(
name|loop
argument_list|,
name|loops
argument_list|,
name|loop
operator|->
name|single_exit
argument_list|,
name|ratio_mult_vf_name
argument_list|,
name|ni_name
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|new_loop
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|loop_num
operator|==
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|slpeel_verify_cfg_after_peeling
argument_list|(
name|loop
argument_list|,
name|new_loop
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A guard that controls whether the new_loop is to be executed or skipped      is placed in LOOP->exit.  LOOP->exit therefore has two successors - one      is the preheader of NEW_LOOP, where the IVs from LOOP are used.  The other      is a bb after NEW_LOOP, where these IVs are not used.  Find the edge that      is on the path where the LOOP IVs are used and need to be updated.  */
name|preheader
operator|=
name|loop_preheader_edge
argument_list|(
name|new_loop
argument_list|)
operator|->
name|src
expr_stmt|;
if|if
condition|(
name|EDGE_PRED
argument_list|(
name|preheader
argument_list|,
literal|0
argument_list|)
operator|->
name|src
operator|==
name|loop
operator|->
name|single_exit
operator|->
name|dest
condition|)
name|update_e
operator|=
name|EDGE_PRED
argument_list|(
name|preheader
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|update_e
operator|=
name|EDGE_PRED
argument_list|(
name|preheader
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Update IVs of original loop as if they were advanced       by ratio_mult_vf_name steps.  */
name|vect_update_ivs_after_vectorizer
argument_list|(
name|loop_vinfo
argument_list|,
name|ratio_mult_vf_name
argument_list|,
name|update_e
argument_list|)
expr_stmt|;
comment|/* After peeling we have to reset scalar evolution analyzer.  */
name|scev_reset
argument_list|()
expr_stmt|;
name|free_original_copy_tables
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function vect_gen_niters_for_prolog_loop     Set the number of iterations for the loop represented by LOOP_VINFO    to the minimum between LOOP_NITERS (the original iteration count of the loop)    and the misalignment of DR - the data reference recorded in    LOOP_VINFO_UNALIGNED_DR (LOOP_VINFO).  As a result, after the execution of     this loop, the data reference DR will refer to an aligned location.     The following computation is generated:     If the misalignment of DR is known at compile time:      addr_mis = int mis = DR_MISALIGNMENT (dr);    Else, compute address misalignment in bytes:      addr_mis = addr& (vectype_size - 1)     prolog_niters = min ( LOOP_NITERS , (VF - addr_mis/elem_size)&(VF-1) )        (elem_size = element type size; an element is the scalar element  	whose type is the inner type of the vectype)  */
end_comment

begin_function
specifier|static
name|tree
name|vect_gen_niters_for_prolog_loop
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|,
name|tree
name|loop_niters
parameter_list|)
block|{
name|struct
name|data_reference
modifier|*
name|dr
init|=
name|LOOP_VINFO_UNALIGNED_DR
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|int
name|vf
init|=
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|tree
name|var
decl_stmt|,
name|stmt
decl_stmt|;
name|tree
name|iters
decl_stmt|,
name|iters_name
decl_stmt|;
name|edge
name|pe
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|;
name|tree
name|dr_stmt
init|=
name|DR_STMT
argument_list|(
name|dr
argument_list|)
decl_stmt|;
name|stmt_vec_info
name|stmt_info
init|=
name|vinfo_for_stmt
argument_list|(
name|dr_stmt
argument_list|)
decl_stmt|;
name|tree
name|vectype
init|=
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
decl_stmt|;
name|int
name|vectype_align
init|=
name|TYPE_ALIGN
argument_list|(
name|vectype
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|tree
name|niters_type
init|=
name|TREE_TYPE
argument_list|(
name|loop_niters
argument_list|)
decl_stmt|;
name|pe
operator|=
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOOP_PEELING_FOR_ALIGNMENT
argument_list|(
name|loop_vinfo
argument_list|)
operator|>
literal|0
condition|)
block|{
name|int
name|byte_misalign
init|=
name|LOOP_PEELING_FOR_ALIGNMENT
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|int
name|element_size
init|=
name|vectype_align
operator|/
name|vf
decl_stmt|;
name|int
name|elem_misalign
init|=
name|byte_misalign
operator|/
name|element_size
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"known alignment = %d."
argument_list|,
name|byte_misalign
argument_list|)
expr_stmt|;
name|iters
operator|=
name|build_int_cst
argument_list|(
name|niters_type
argument_list|,
operator|(
name|vf
operator|-
name|elem_misalign
operator|)
operator|&
operator|(
name|vf
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tree
name|new_stmts
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|start_addr
init|=
name|vect_create_addr_base_for_vector_ref
argument_list|(
name|dr_stmt
argument_list|,
operator|&
name|new_stmts
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|ptr_type
init|=
name|TREE_TYPE
argument_list|(
name|start_addr
argument_list|)
decl_stmt|;
name|tree
name|size
init|=
name|TYPE_SIZE
argument_list|(
name|ptr_type
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|tree_low_cst
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|vectype_size_minus_1
init|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|vectype_align
operator|-
literal|1
argument_list|)
decl_stmt|;
name|tree
name|elem_size_log
init|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|exact_log2
argument_list|(
name|vectype_align
operator|/
name|vf
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|vf_minus_1
init|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|vf
operator|-
literal|1
argument_list|)
decl_stmt|;
name|tree
name|vf_tree
init|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
name|vf
argument_list|)
decl_stmt|;
name|tree
name|byte_misalign
decl_stmt|;
name|tree
name|elem_misalign
decl_stmt|;
name|new_bb
operator|=
name|bsi_insert_on_edge_immediate
argument_list|(
name|pe
argument_list|,
name|new_stmts
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|new_bb
argument_list|)
expr_stmt|;
comment|/* Create:  byte_misalign = addr& (vectype_size - 1)  */
name|byte_misalign
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|start_addr
argument_list|,
name|vectype_size_minus_1
argument_list|)
expr_stmt|;
comment|/* Create:  elem_misalign = byte_misalign / element_size  */
name|elem_misalign
operator|=
name|build2
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|byte_misalign
argument_list|,
name|elem_size_log
argument_list|)
expr_stmt|;
comment|/* Create:  (niters_type) (VF - elem_misalign)&(VF - 1)  */
name|iters
operator|=
name|build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|vf_tree
argument_list|,
name|elem_misalign
argument_list|)
expr_stmt|;
name|iters
operator|=
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|type
argument_list|,
name|iters
argument_list|,
name|vf_minus_1
argument_list|)
expr_stmt|;
name|iters
operator|=
name|fold_convert
argument_list|(
name|niters_type
argument_list|,
name|iters
argument_list|)
expr_stmt|;
block|}
comment|/* Create:  prolog_loop_niters = min (iters, loop_niters) */
comment|/* If the loop bound is known at compile time we already verified that it is      greater than vf; since the misalignment ('iters') is at most vf, there's      no need to generate the MIN_EXPR in this case.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|loop_niters
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|iters
operator|=
name|build2
argument_list|(
name|MIN_EXPR
argument_list|,
name|niters_type
argument_list|,
name|iters
argument_list|,
name|loop_niters
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"niters for prolog loop: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|iters
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|var
operator|=
name|create_tmp_var
argument_list|(
name|niters_type
argument_list|,
literal|"prolog_loop_niters"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|iters_name
operator|=
name|force_gimple_operand
argument_list|(
name|iters
argument_list|,
operator|&
name|stmt
argument_list|,
name|false
argument_list|,
name|var
argument_list|)
expr_stmt|;
comment|/* Insert stmt on loop preheader edge.  */
if|if
condition|(
name|stmt
condition|)
block|{
name|basic_block
name|new_bb
init|=
name|bsi_insert_on_edge_immediate
argument_list|(
name|pe
argument_list|,
name|stmt
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|new_bb
argument_list|)
expr_stmt|;
block|}
return|return
name|iters_name
return|;
block|}
end_function

begin_comment
comment|/* Function vect_update_init_of_dr     NITERS iterations were peeled from LOOP.  DR represents a data reference    in LOOP.  This function updates the information recorded in DR to    account for the fact that the first NITERS iterations had already been     executed.  Specifically, it updates the OFFSET field of DR.  */
end_comment

begin_function
specifier|static
name|void
name|vect_update_init_of_dr
parameter_list|(
name|struct
name|data_reference
modifier|*
name|dr
parameter_list|,
name|tree
name|niters
parameter_list|)
block|{
name|tree
name|offset
init|=
name|DR_OFFSET
argument_list|(
name|dr
argument_list|)
decl_stmt|;
name|niters
operator|=
name|fold_build2
argument_list|(
name|MULT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|niters
argument_list|)
argument_list|,
name|niters
argument_list|,
name|DR_STEP
argument_list|(
name|dr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|fold_build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|offset
argument_list|)
argument_list|,
name|offset
argument_list|,
name|niters
argument_list|)
expr_stmt|;
name|DR_OFFSET
argument_list|(
name|dr
argument_list|)
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function vect_update_inits_of_drs     NITERS iterations were peeled from the loop represented by LOOP_VINFO.      This function updates the information recorded for the data references in     the loop to account for the fact that the first NITERS iterations had     already been executed.  Specifically, it updates the initial_condition of the    access_function of all the data_references in the loop.  */
end_comment

begin_function
specifier|static
name|void
name|vect_update_inits_of_drs
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|,
name|tree
name|niters
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|VEC
argument_list|(
name|data_reference_p
argument_list|,
name|heap
argument_list|)
operator|*
name|datarefs
operator|=
name|LOOP_VINFO_DATAREFS
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|struct
name|data_reference
modifier|*
name|dr
decl_stmt|;
if|if
condition|(
name|vect_dump
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_update_inits_of_dr ==="
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|data_reference_p
argument_list|,
name|datarefs
argument_list|,
name|i
argument_list|,
name|dr
argument_list|)
condition|;
name|i
operator|++
control|)
name|vect_update_init_of_dr
argument_list|(
name|dr
argument_list|,
name|niters
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function vect_do_peeling_for_alignment     Peel the first 'niters' iterations of the loop represented by LOOP_VINFO.    'niters' is set to the misalignment of one of the data references in the    loop, thereby forcing it to refer to an aligned location at the beginning    of the execution of this loop.  The data reference for which we are    peeling is recorded in LOOP_VINFO_UNALIGNED_DR.  */
end_comment

begin_function
specifier|static
name|void
name|vect_do_peeling_for_alignment
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|,
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|tree
name|niters_of_prolog_loop
decl_stmt|,
name|ni_name
decl_stmt|;
name|tree
name|n_iters
decl_stmt|;
name|struct
name|loop
modifier|*
name|new_loop
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vect_do_peeling_for_alignment ==="
argument_list|)
expr_stmt|;
name|initialize_original_copy_tables
argument_list|()
expr_stmt|;
name|ni_name
operator|=
name|vect_build_loop_niters
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|niters_of_prolog_loop
operator|=
name|vect_gen_niters_for_prolog_loop
argument_list|(
name|loop_vinfo
argument_list|,
name|ni_name
argument_list|)
expr_stmt|;
comment|/* Peel the prolog loop and iterate it niters_of_prolog_loop.  */
name|new_loop
operator|=
name|slpeel_tree_peel_loop_to_edge
argument_list|(
name|loop
argument_list|,
name|loops
argument_list|,
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|niters_of_prolog_loop
argument_list|,
name|ni_name
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|new_loop
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|slpeel_verify_cfg_after_peeling
argument_list|(
name|new_loop
argument_list|,
name|loop
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Update number of times loop executes.  */
name|n_iters
operator|=
name|LOOP_VINFO_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|LOOP_VINFO_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
operator|=
name|fold_build2
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|n_iters
argument_list|)
argument_list|,
name|n_iters
argument_list|,
name|niters_of_prolog_loop
argument_list|)
expr_stmt|;
comment|/* Update the init conditions of the access functions of all data refs.  */
name|vect_update_inits_of_drs
argument_list|(
name|loop_vinfo
argument_list|,
name|niters_of_prolog_loop
argument_list|)
expr_stmt|;
comment|/* After peeling we have to reset scalar evolution analyzer.  */
name|scev_reset
argument_list|()
expr_stmt|;
name|free_original_copy_tables
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function vect_create_cond_for_align_checks.     Create a conditional expression that represents the alignment checks for    all of data references (array element references) whose alignment must be    checked at runtime.     Input:    LOOP_VINFO - two fields of the loop information are used.                 LOOP_VINFO_PTR_MASK is the mask used to check the alignment.                 LOOP_VINFO_MAY_MISALIGN_STMTS contains the refs to be checked.     Output:    COND_EXPR_STMT_LIST - statements needed to construct the conditional                          expression.    The returned value is the conditional expression to be used in the if    statement that controls which version of the loop gets executed at runtime.     The algorithm makes two assumptions:      1) The number of bytes "n" in a vector is a power of 2.      2) An address "a" is aligned if a%n is zero and that this         test can be done as a&(n-1) == 0.  For example, for 16         byte vectors the test is a&0xf == 0.  */
end_comment

begin_function
specifier|static
name|tree
name|vect_create_cond_for_align_checks
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|,
name|tree
modifier|*
name|cond_expr_stmt_list
parameter_list|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|may_misalign_stmts
operator|=
name|LOOP_VINFO_MAY_MISALIGN_STMTS
argument_list|(
name|loop_vinfo
argument_list|)
expr_stmt|;
name|tree
name|ref_stmt
decl_stmt|;
name|int
name|mask
init|=
name|LOOP_VINFO_PTR_MASK
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|tree
name|mask_cst
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|tree
name|psize
decl_stmt|;
name|tree
name|int_ptrsize_type
decl_stmt|;
name|char
name|tmp_name
index|[
literal|20
index|]
decl_stmt|;
name|tree
name|or_tmp_name
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|and_tmp
decl_stmt|,
name|and_tmp_name
decl_stmt|,
name|and_stmt
decl_stmt|;
name|tree
name|ptrsize_zero
decl_stmt|;
comment|/* Check that mask is one less than a power of 2, i.e., mask is      all zeros followed by all ones.  */
name|gcc_assert
argument_list|(
operator|(
name|mask
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|mask
operator|&
operator|(
name|mask
operator|+
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* CHECKME: what is the best integer or unsigned type to use to hold a      cast from a pointer value?  */
name|psize
operator|=
name|TYPE_SIZE
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|int_ptrsize_type
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|tree_low_cst
argument_list|(
name|psize
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Create expression (mask& (dr_1 || ... || dr_n)) where dr_i is the address      of the first vector of the i'th data reference. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|may_misalign_stmts
argument_list|,
name|i
argument_list|,
name|ref_stmt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|new_stmt_list
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|addr_base
decl_stmt|;
name|tree
name|addr_tmp
decl_stmt|,
name|addr_tmp_name
decl_stmt|,
name|addr_stmt
decl_stmt|;
name|tree
name|or_tmp
decl_stmt|,
name|new_or_tmp_name
decl_stmt|,
name|or_stmt
decl_stmt|;
comment|/* create: addr_tmp = (int)(address_of_first_vector) */
name|addr_base
operator|=
name|vect_create_addr_base_for_vector_ref
argument_list|(
name|ref_stmt
argument_list|,
operator|&
name|new_stmt_list
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_stmt_list
operator|!=
name|NULL_TREE
condition|)
name|append_to_statement_list_force
argument_list|(
name|new_stmt_list
argument_list|,
name|cond_expr_stmt_list
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
literal|"%s%d"
argument_list|,
literal|"addr2int"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|addr_tmp
operator|=
name|create_tmp_var
argument_list|(
name|int_ptrsize_type
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|addr_tmp
argument_list|)
expr_stmt|;
name|addr_tmp_name
operator|=
name|make_ssa_name
argument_list|(
name|addr_tmp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|addr_stmt
operator|=
name|fold_convert
argument_list|(
name|int_ptrsize_type
argument_list|,
name|addr_base
argument_list|)
expr_stmt|;
name|addr_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|addr_tmp_name
argument_list|,
name|addr_stmt
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|addr_tmp_name
argument_list|)
operator|=
name|addr_stmt
expr_stmt|;
name|append_to_statement_list_force
argument_list|(
name|addr_stmt
argument_list|,
name|cond_expr_stmt_list
argument_list|)
expr_stmt|;
comment|/* The addresses are OR together.  */
if|if
condition|(
name|or_tmp_name
operator|!=
name|NULL_TREE
condition|)
block|{
comment|/* create: or_tmp = or_tmp | addr_tmp */
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
literal|"%s%d"
argument_list|,
literal|"orptrs"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|or_tmp
operator|=
name|create_tmp_var
argument_list|(
name|int_ptrsize_type
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|or_tmp
argument_list|)
expr_stmt|;
name|new_or_tmp_name
operator|=
name|make_ssa_name
argument_list|(
name|or_tmp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|or_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|new_or_tmp_name
argument_list|,
name|build2
argument_list|(
name|BIT_IOR_EXPR
argument_list|,
name|int_ptrsize_type
argument_list|,
name|or_tmp_name
argument_list|,
name|addr_tmp_name
argument_list|)
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|new_or_tmp_name
argument_list|)
operator|=
name|or_stmt
expr_stmt|;
name|append_to_statement_list_force
argument_list|(
name|or_stmt
argument_list|,
name|cond_expr_stmt_list
argument_list|)
expr_stmt|;
name|or_tmp_name
operator|=
name|new_or_tmp_name
expr_stmt|;
block|}
else|else
name|or_tmp_name
operator|=
name|addr_tmp_name
expr_stmt|;
block|}
comment|/* end for i */
name|mask_cst
operator|=
name|build_int_cst
argument_list|(
name|int_ptrsize_type
argument_list|,
name|mask
argument_list|)
expr_stmt|;
comment|/* create: and_tmp = or_tmp& mask  */
name|and_tmp
operator|=
name|create_tmp_var
argument_list|(
name|int_ptrsize_type
argument_list|,
literal|"andmask"
argument_list|)
expr_stmt|;
name|add_referenced_var
argument_list|(
name|and_tmp
argument_list|)
expr_stmt|;
name|and_tmp_name
operator|=
name|make_ssa_name
argument_list|(
name|and_tmp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|and_stmt
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|and_tmp_name
argument_list|,
name|build2
argument_list|(
name|BIT_AND_EXPR
argument_list|,
name|int_ptrsize_type
argument_list|,
name|or_tmp_name
argument_list|,
name|mask_cst
argument_list|)
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|and_tmp_name
argument_list|)
operator|=
name|and_stmt
expr_stmt|;
name|append_to_statement_list_force
argument_list|(
name|and_stmt
argument_list|,
name|cond_expr_stmt_list
argument_list|)
expr_stmt|;
comment|/* Make and_tmp the left operand of the conditional test against zero.      if and_tmp has a nonzero bit then some address is unaligned.  */
name|ptrsize_zero
operator|=
name|build_int_cst
argument_list|(
name|int_ptrsize_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|and_tmp_name
argument_list|,
name|ptrsize_zero
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function vect_transform_loop.     The analysis phase has determined that the loop is vectorizable.    Vectorize the loop - created vectorized stmts to replace the scalar    stmts in the loop, and update the loop exit condition.  */
end_comment

begin_function
name|void
name|vect_transform_loop
parameter_list|(
name|loop_vec_info
name|loop_vinfo
parameter_list|,
name|struct
name|loops
modifier|*
name|loops
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|LOOP_VINFO_LOOP
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|basic_block
modifier|*
name|bbs
init|=
name|LOOP_VINFO_BBS
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|int
name|nbbs
init|=
name|loop
operator|->
name|num_nodes
decl_stmt|;
name|block_stmt_iterator
name|si
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|ratio
init|=
name|NULL
decl_stmt|;
name|int
name|vectorization_factor
init|=
name|LOOP_VINFO_VECT_FACTOR
argument_list|(
name|loop_vinfo
argument_list|)
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"=== vec_transform_loop ==="
argument_list|)
expr_stmt|;
comment|/* If the loop has data references that may or may not be aligned then      two versions of the loop need to be generated, one which is vectorized      and one which isn't.  A test is then generated to control which of the      loops is executed.  The test checks for the alignment of all of the      data references that may or may not be aligned. */
if|if
condition|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|LOOP_VINFO_MAY_MISALIGN_STMTS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|loop
modifier|*
name|nloop
decl_stmt|;
name|tree
name|cond_expr
decl_stmt|;
name|tree
name|cond_expr_stmt_list
init|=
name|NULL_TREE
decl_stmt|;
name|basic_block
name|condition_bb
decl_stmt|;
name|block_stmt_iterator
name|cond_exp_bsi
decl_stmt|;
name|basic_block
name|merge_bb
decl_stmt|;
name|basic_block
name|new_exit_bb
decl_stmt|;
name|edge
name|new_exit_e
decl_stmt|,
name|e
decl_stmt|;
name|tree
name|orig_phi
decl_stmt|,
name|new_phi
decl_stmt|,
name|arg
decl_stmt|;
name|cond_expr
operator|=
name|vect_create_cond_for_align_checks
argument_list|(
name|loop_vinfo
argument_list|,
operator|&
name|cond_expr_stmt_list
argument_list|)
expr_stmt|;
name|initialize_original_copy_tables
argument_list|()
expr_stmt|;
name|nloop
operator|=
name|loop_version
argument_list|(
name|loops
argument_list|,
name|loop
argument_list|,
name|cond_expr
argument_list|,
operator|&
name|condition_bb
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|free_original_copy_tables
argument_list|()
expr_stmt|;
comment|/** Loop versioning violates an assumption we try to maintain during  	 vectorization - that the loop exit block has a single predecessor. 	 After versioning, the exit block of both loop versions is the same 	 basic block (i.e. it has two predecessors). Just in order to simplify 	 following transformations in the vectorizer, we fix this situation 	 here by adding a new (empty) block on the exit-edge of the loop, 	 with the proper loop-exit phis to maintain loop-closed-form.  **/
name|merge_bb
operator|=
name|loop
operator|->
name|single_exit
operator|->
name|dest
expr_stmt|;
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|merge_bb
operator|->
name|preds
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
name|new_exit_bb
operator|=
name|split_edge
argument_list|(
name|loop
operator|->
name|single_exit
argument_list|)
expr_stmt|;
name|add_bb_to_loop
argument_list|(
name|new_exit_bb
argument_list|,
name|loop
operator|->
name|outer
argument_list|)
expr_stmt|;
name|new_exit_e
operator|=
name|loop
operator|->
name|single_exit
expr_stmt|;
name|e
operator|=
name|EDGE_SUCC
argument_list|(
name|new_exit_bb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|orig_phi
operator|=
name|phi_nodes
argument_list|(
name|merge_bb
argument_list|)
init|;
name|orig_phi
condition|;
name|orig_phi
operator|=
name|PHI_CHAIN
argument_list|(
name|orig_phi
argument_list|)
control|)
block|{
name|new_phi
operator|=
name|create_phi_node
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|PHI_RESULT
argument_list|(
name|orig_phi
argument_list|)
argument_list|)
argument_list|,
name|new_exit_bb
argument_list|)
expr_stmt|;
name|arg
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|orig_phi
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|add_phi_arg
argument_list|(
name|new_phi
argument_list|,
name|arg
argument_list|,
name|new_exit_e
argument_list|)
expr_stmt|;
name|SET_PHI_ARG_DEF
argument_list|(
name|orig_phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|,
name|PHI_RESULT
argument_list|(
name|new_phi
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/** end loop-exit-fixes after versioning  **/
name|update_ssa
argument_list|(
name|TODO_update_ssa
argument_list|)
expr_stmt|;
name|cond_exp_bsi
operator|=
name|bsi_last
argument_list|(
name|condition_bb
argument_list|)
expr_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|cond_exp_bsi
argument_list|,
name|cond_expr_stmt_list
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
block|}
comment|/* CHECKME: we wouldn't need this if we called update_ssa once      for all loops.  */
name|bitmap_zero
argument_list|(
name|vect_vnames_to_rename
argument_list|)
expr_stmt|;
comment|/* Peel the loop if there are data refs with unknown alignment.      Only one data ref with unknown store is allowed.  */
if|if
condition|(
name|LOOP_PEELING_FOR_ALIGNMENT
argument_list|(
name|loop_vinfo
argument_list|)
condition|)
name|vect_do_peeling_for_alignment
argument_list|(
name|loop_vinfo
argument_list|,
name|loops
argument_list|)
expr_stmt|;
comment|/* If the loop has a symbolic number of iterations 'n' (i.e. it's not a      compile time constant), or it is a constant that doesn't divide by the      vectorization factor, then an epilog loop needs to be created.      We therefore duplicate the loop: the original loop will be vectorized,      and will compute the first (n/VF) iterations. The second copy of the loop      will remain scalar and will compute the remaining (n%VF) iterations.      (VF is the vectorization factor).  */
if|if
condition|(
operator|!
name|LOOP_VINFO_NITERS_KNOWN_P
argument_list|(
name|loop_vinfo
argument_list|)
operator|||
operator|(
name|LOOP_VINFO_NITERS_KNOWN_P
argument_list|(
name|loop_vinfo
argument_list|)
operator|&&
name|LOOP_VINFO_INT_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
operator|%
name|vectorization_factor
operator|!=
literal|0
operator|)
condition|)
name|vect_do_peeling_for_loop_bound
argument_list|(
name|loop_vinfo
argument_list|,
operator|&
name|ratio
argument_list|,
name|loops
argument_list|)
expr_stmt|;
else|else
name|ratio
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|LOOP_VINFO_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
argument_list|)
argument_list|,
name|LOOP_VINFO_INT_NITERS
argument_list|(
name|loop_vinfo
argument_list|)
operator|/
name|vectorization_factor
argument_list|)
expr_stmt|;
comment|/* 1) Make sure the loop header has exactly two entries      2) Make sure we have a preheader basic block.  */
name|gcc_assert
argument_list|(
name|EDGE_COUNT
argument_list|(
name|loop
operator|->
name|header
operator|->
name|preds
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
name|loop_split_edge_with
argument_list|(
name|loop_preheader_edge
argument_list|(
name|loop
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FORNOW: the vectorizer supports only loops which body consist      of one basic block (header + empty latch). When the vectorizer will       support more involved loop forms, the order by which the BBs are       traversed need to be reconsidered.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbbs
condition|;
name|i
operator|++
control|)
block|{
name|basic_block
name|bb
init|=
name|bbs
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|si
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|si
argument_list|)
condition|;
control|)
block|{
name|tree
name|stmt
init|=
name|bsi_stmt
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|stmt_vec_info
name|stmt_info
decl_stmt|;
name|bool
name|is_store
decl_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"------>vectorizing statement: "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|vect_dump
argument_list|,
name|stmt
argument_list|,
name|TDF_SLIM
argument_list|)
expr_stmt|;
block|}
name|stmt_info
operator|=
name|vinfo_for_stmt
argument_list|(
name|stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|STMT_VINFO_RELEVANT_P
argument_list|(
name|stmt_info
argument_list|)
operator|&&
operator|!
name|STMT_VINFO_LIVE_P
argument_list|(
name|stmt_info
argument_list|)
condition|)
block|{
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* FORNOW: Verify that all stmts operate on the same number of 	             units and no inner unrolling is necessary.  */
name|gcc_assert
argument_list|(
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|STMT_VINFO_VECTYPE
argument_list|(
name|stmt_info
argument_list|)
argument_list|)
operator|==
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|vectorization_factor
argument_list|)
expr_stmt|;
comment|/* -------- vectorize statement ------------ */
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_DETAILS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"transform statement."
argument_list|)
expr_stmt|;
name|is_store
operator|=
name|vect_transform_stmt
argument_list|(
name|stmt
argument_list|,
operator|&
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_store
condition|)
block|{
comment|/* Free the attached stmt_vec_info and remove the stmt.  */
name|stmt_ann_t
name|ann
init|=
name|stmt_ann
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|stmt_info
argument_list|)
expr_stmt|;
name|set_stmt_info
argument_list|(
name|ann
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bsi_remove
argument_list|(
operator|&
name|si
argument_list|,
name|true
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bsi_next
argument_list|(
operator|&
name|si
argument_list|)
expr_stmt|;
block|}
comment|/* stmts in BB */
block|}
comment|/* BBs in loop */
name|slpeel_make_loop_iterate_ntimes
argument_list|(
name|loop
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|vect_vnames_to_rename
argument_list|,
literal|0
argument_list|,
argument|j
argument_list|,
argument|bi
argument_list|)
name|mark_sym_for_renaming
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ssa_name
argument_list|(
name|j
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The memory tags and pointers in vectorized statements need to      have their SSA forms updated.  FIXME, why can't this be delayed      until all the loops have been transformed?  */
name|update_ssa
argument_list|(
name|TODO_update_ssa
argument_list|)
expr_stmt|;
if|if
condition|(
name|vect_print_dump_info
argument_list|(
name|REPORT_VECTORIZED_LOOPS
argument_list|)
condition|)
name|fprintf
argument_list|(
name|vect_dump
argument_list|,
literal|"LOOP VECTORIZED."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

