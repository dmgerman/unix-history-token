begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dependency generator for Makefile fragments.    Copyright (C) 2000, 2001 Free Software Foundation, Inc.    Contributed by Zack Weinberg, Mar 2000  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"mkdeps.h"
end_include

begin_comment
comment|/* Keep this structure local to this file, so clients don't find it    easy to start making assumptions.  */
end_comment

begin_struct
struct|struct
name|deps
block|{
specifier|const
name|char
modifier|*
modifier|*
name|targetv
decl_stmt|;
name|unsigned
name|int
name|ntargets
decl_stmt|;
comment|/* number of slots actually occupied */
name|unsigned
name|int
name|targets_size
decl_stmt|;
comment|/* amt of allocated space - in words */
specifier|const
name|char
modifier|*
modifier|*
name|depv
decl_stmt|;
name|unsigned
name|int
name|ndeps
decl_stmt|;
name|unsigned
name|int
name|deps_size
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|munge
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a filename, quote characters in that filename which are    significant to Make.  Note that it's not possible to quote all such    characters - e.g. \n, %, *, ?, [, \ (in some contexts), and ~ are    not properly handled.  It isn't possible to get this right in any    current version of Make.  (??? Still true?  Old comment referred to    3.76.1.)  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|munge
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|buffer
decl_stmt|;
for|for
control|(
name|p
operator|=
name|filename
operator|,
name|len
operator|=
literal|0
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|len
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
comment|/* GNU make uses a weird quoting scheme for white space. 	     A space or tab preceded by 2N+1 backslashes represents 	     N backslashes followed by space; a space or tab 	     preceded by 2N backslashes represents N backslashes at 	     the end of a file name; and backslashes in other 	     contexts should not be doubled.  */
for|for
control|(
name|q
operator|=
name|p
operator|-
literal|1
init|;
name|filename
operator|<=
name|q
operator|&&
operator|*
name|q
operator|==
literal|'\\'
condition|;
name|q
operator|--
control|)
name|len
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* '$' is quoted by doubling it.  */
name|len
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now we know how big to make the buffer.  */
name|buffer
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|filename
operator|,
name|dst
operator|=
name|buffer
init|;
operator|*
name|p
condition|;
name|p
operator|++
operator|,
name|dst
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
for|for
control|(
name|q
operator|=
name|p
operator|-
literal|1
init|;
name|filename
operator|<=
name|q
operator|&&
operator|*
name|q
operator|==
literal|'\\'
condition|;
name|q
operator|--
control|)
operator|*
name|dst
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'$'
expr_stmt|;
break|break;
default|default:
comment|/* nothing */
empty_stmt|;
block|}
operator|*
name|dst
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Public routines.  */
end_comment

begin_function
name|struct
name|deps
modifier|*
name|deps_init
parameter_list|()
block|{
name|struct
name|deps
modifier|*
name|d
init|=
operator|(
expr|struct
name|deps
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|deps
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Allocate space for the vectors only if we need it.  */
name|d
operator|->
name|targetv
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|depv
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|ntargets
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|targets_size
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|ndeps
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|deps_size
operator|=
literal|0
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_function
name|void
name|deps_free
parameter_list|(
name|d
parameter_list|)
name|struct
name|deps
modifier|*
name|d
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|targetv
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|ntargets
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|d
operator|->
name|targetv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|targetv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|depv
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|ndeps
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|d
operator|->
name|depv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
operator|->
name|depv
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adds a target T.  We make a copy, so it need not be a permanent    string.  QUOTE is true if the string should be quoted.  */
end_comment

begin_function
name|void
name|deps_add_target
parameter_list|(
name|d
parameter_list|,
name|t
parameter_list|,
name|quote
parameter_list|)
name|struct
name|deps
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|quote
decl_stmt|;
block|{
if|if
condition|(
name|d
operator|->
name|ntargets
operator|==
name|d
operator|->
name|targets_size
condition|)
block|{
name|d
operator|->
name|targets_size
operator|=
name|d
operator|->
name|targets_size
operator|*
literal|2
operator|+
literal|4
expr_stmt|;
name|d
operator|->
name|targetv
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|d
operator|->
name|targetv
argument_list|,
name|d
operator|->
name|targets_size
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quote
condition|)
name|t
operator|=
name|munge
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Also makes permanent copy.  */
else|else
name|t
operator|=
name|xstrdup
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|d
operator|->
name|targetv
index|[
name|d
operator|->
name|ntargets
operator|++
index|]
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sets the default target if none has been given already.  An empty    string as the default target in interpreted as stdin.  The string    is quoted for MAKE.  */
end_comment

begin_function
name|void
name|deps_add_default_target
parameter_list|(
name|d
parameter_list|,
name|tgt
parameter_list|)
name|struct
name|deps
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|tgt
decl_stmt|;
block|{
comment|/* Only if we have no targets.  */
if|if
condition|(
name|d
operator|->
name|ntargets
condition|)
return|return;
if|if
condition|(
name|tgt
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|deps_add_target
argument_list|(
name|d
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
ifndef|#
directive|ifndef
name|TARGET_OBJECT_SUFFIX
define|#
directive|define
name|TARGET_OBJECT_SUFFIX
value|".o"
endif|#
directive|endif
specifier|const
name|char
modifier|*
name|start
init|=
name|lbasename
argument_list|(
name|tgt
argument_list|)
decl_stmt|;
name|char
modifier|*
name|o
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|start
argument_list|)
operator|+
name|strlen
argument_list|(
name|TARGET_OBJECT_SUFFIX
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|strcpy
argument_list|(
name|o
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|strrchr
argument_list|(
name|o
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|suffix
condition|)
name|suffix
operator|=
name|o
operator|+
name|strlen
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|suffix
argument_list|,
name|TARGET_OBJECT_SUFFIX
argument_list|)
expr_stmt|;
name|deps_add_target
argument_list|(
name|d
argument_list|,
name|o
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|deps_add_dep
parameter_list|(
name|d
parameter_list|,
name|t
parameter_list|)
name|struct
name|deps
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
decl_stmt|;
block|{
name|t
operator|=
name|munge
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Also makes permanent copy.  */
if|if
condition|(
name|d
operator|->
name|ndeps
operator|==
name|d
operator|->
name|deps_size
condition|)
block|{
name|d
operator|->
name|deps_size
operator|=
name|d
operator|->
name|deps_size
operator|*
literal|2
operator|+
literal|8
expr_stmt|;
name|d
operator|->
name|depv
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|d
operator|->
name|depv
argument_list|,
name|d
operator|->
name|deps_size
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|depv
index|[
name|d
operator|->
name|ndeps
operator|++
index|]
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deps_write
parameter_list|(
name|d
parameter_list|,
name|fp
parameter_list|,
name|colmax
parameter_list|)
specifier|const
name|struct
name|deps
modifier|*
name|d
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|unsigned
name|int
name|colmax
decl_stmt|;
block|{
name|unsigned
name|int
name|size
decl_stmt|,
name|i
decl_stmt|,
name|column
decl_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|colmax
operator|&&
name|colmax
operator|<
literal|34
condition|)
name|colmax
operator|=
literal|34
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|ntargets
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|strlen
argument_list|(
name|d
operator|->
name|targetv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|column
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|colmax
operator|&&
name|column
operator|>
name|colmax
condition|)
block|{
name|fputs
argument_list|(
literal|" \\\n "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|column
operator|=
literal|1
operator|+
name|size
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
name|fputs
argument_list|(
name|d
operator|->
name|targetv
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|':'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|column
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|ndeps
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|strlen
argument_list|(
name|d
operator|->
name|depv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|column
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|colmax
operator|&&
name|column
operator|>
name|colmax
condition|)
block|{
name|fputs
argument_list|(
literal|" \\\n "
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|column
operator|=
literal|1
operator|+
name|size
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|column
operator|++
expr_stmt|;
block|}
name|fputs
argument_list|(
name|d
operator|->
name|depv
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|deps_phony_targets
parameter_list|(
name|d
parameter_list|,
name|fp
parameter_list|)
specifier|const
name|struct
name|deps
modifier|*
name|d
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|d
operator|->
name|ndeps
condition|;
name|i
operator|++
control|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|d
operator|->
name|depv
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|':'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

