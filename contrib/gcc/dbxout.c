begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output dbx-format symbol table information from GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Output dbx-format symbol table data.    This consists of many symbol table entries, each of them    a .stabs assembler pseudo-op with four operands:    a "name" which is really a description of one symbol and its type,    a "code", which is a symbol defined in stab.h whose name starts with N_,    an unused operand always 0,    and a "value" which is an address or an offset.    The name is enclosed in doublequote characters.     Each function, variable, typedef, and structure tag    has a symbol table entry to define it.    The beginning and end of each level of name scoping within    a function are also marked by special symbol table entries.     The "name" consists of the symbol name, a colon, a kind-of-symbol letter,    and a data type number.  The data type number may be followed by    "=" and a type definition; normally this will happen the first time    the type number is mentioned.  The type definition may refer to    other types by number, and those type numbers may be followed    by "=" and nested definitions.     This can make the "name" quite long.    When a name is more than 80 characters, we split the .stabs pseudo-op    into two .stabs pseudo-ops, both sharing the same "code" and "value".    The first one is marked as continued with a double-backslash at the    end of its "name".     The kind-of-symbol letter distinguished function names from global    variables from file-scope variables from parameters from auto    variables in memory from typedef names from register variables.    See `dbxout_symbol'.     The "code" is mostly redundant with the kind-of-symbol letter    that goes in the "name", but not entirely: for symbols located    in static storage, the "code" says which segment the address is in,    which controls how it is relocated.     The "value" for a symbol in static storage    is the core address of the symbol (actually, the assembler    label for the symbol).  For a symbol located in a stack slot    it is the stack offset; for one in a register, the register number.    For a typedef symbol, it is zero.     If DEBUG_SYMS_TEXT is defined, all debugging symbols must be    output while in the text section.     For more on data type definitions, see `dbxout_type'.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_comment
comment|/* ASM_OUTPUT_SOURCE_LINE may refer to sdb functions.  */
end_comment

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_STABS_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_STABS_OP
value|"\t.stabs\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_STABN_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_STABN_OP
value|"\t.stabn\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_TYPE_DECL_STABS_CODE
end_ifndef

begin_define
define|#
directive|define
name|DBX_TYPE_DECL_STABS_CODE
value|N_LSYM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_STATIC_CONST_VAR_CODE
end_ifndef

begin_define
define|#
directive|define
name|DBX_STATIC_CONST_VAR_CODE
value|N_FUN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_REGPARM_STABS_CODE
end_ifndef

begin_define
define|#
directive|define
name|DBX_REGPARM_STABS_CODE
value|N_RSYM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_REGPARM_STABS_LETTER
end_ifndef

begin_define
define|#
directive|define
name|DBX_REGPARM_STABS_LETTER
value|'P'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is used for parameters passed by invisible reference in a register.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GDB_INV_REF_REGPARM_STABS_LETTER
end_ifndef

begin_define
define|#
directive|define
name|GDB_INV_REF_REGPARM_STABS_LETTER
value|'a'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_MEMPARM_STABS_LETTER
end_ifndef

begin_define
define|#
directive|define
name|DBX_MEMPARM_STABS_LETTER
value|'p'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FILE_NAME_JOINER
end_ifndef

begin_define
define|#
directive|define
name|FILE_NAME_JOINER
value|"/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GDB needs to know that the stabs were generated by GCC.  We emit an    N_OPT stab at the beginning of the source file to indicate this.    The string is historical, and different on a very few targets.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STABS_GCC_MARKER
end_ifndef

begin_define
define|#
directive|define
name|STABS_GCC_MARKER
value|"gcc2_compiled."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Typical USG systems don't have stab.h, and they also have    no use for DBX-format debugging info.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_comment
comment|/* Nonzero if we have actually used any of the GDB extensions    to the debugging format.  The idea is that we use them for the    first time only if there's a strong reason, but once we have done that,    we use them whenever convenient.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_used_extensions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number for the next N_SOL filename stabs label.  The number 0 is reserved    for the N_SO filename stabs label.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DBX_OUTPUT_SOURCE_FILENAME
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|source_label_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_SYMS_TEXT
end_ifdef

begin_define
define|#
directive|define
name|FORCE_TEXT
value|text_section ();
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_TEXT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_define
define|#
directive|define
name|STAB_CODE_TYPE
value|enum __stab_debug_code
end_define

begin_comment
comment|/* 1 if PARM is passed to this function in memory.  */
end_comment

begin_define
define|#
directive|define
name|PARM_PASSED_IN_MEMORY
parameter_list|(
name|PARM
parameter_list|)
define|\
value|(GET_CODE (DECL_INCOMING_RTL (PARM)) == MEM)
end_define

begin_comment
comment|/* A C expression for the integer offset value of an automatic variable    (N_LSYM) having address X (an RTX).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUGGER_AUTO_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|DEBUGGER_AUTO_OFFSET
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A C expression for the integer offset value of an argument (N_PSYM)    having address X (an RTX).  The nominal offset is OFFSET.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUGGER_ARG_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|DEBUGGER_ARG_OFFSET
parameter_list|(
name|OFFSET
parameter_list|,
name|X
parameter_list|)
value|(OFFSET)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Stream for writing to assembler file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|asmfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last source file name mentioned in a NOTE insn.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lastfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current working directory.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cwd
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|typestatus
block|{
name|TYPE_UNSEEN
block|,
name|TYPE_XREF
block|,
name|TYPE_DEFINED
block|}
enum|;
end_enum

begin_comment
comment|/* Structure recording information about a C data type.    The status element says whether we have yet output    the definition of the type.  TYPE_XREF says we have    output it as a cross-reference only.    The file_number and type_number elements are used if DBX_USE_BINCL    is defined.  */
end_comment

begin_struct
struct|struct
name|typeinfo
block|{
name|enum
name|typestatus
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
name|int
name|file_number
decl_stmt|;
name|int
name|type_number
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* Vector recording information about C data types.    When we first notice a data type (a tree node),    we assign it a number using next_type_number.    That is its index in this vector.  */
end_comment

begin_decl_stmt
name|struct
name|typeinfo
modifier|*
name|typevec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements of space allocated in `typevec'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|typevec_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In dbx output, each type gets a unique number.    This is the number for the next type output.    The number, once assigned, is in the TYPE_SYMTAB_ADDRESS field.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_type_number
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
end_ifdef

begin_comment
comment|/* When using N_BINCL in dbx output, each type number is actually a    pair of the file number and the type number within the file.    This is a stack of input files.  */
end_comment

begin_struct
struct|struct
name|dbx_file
block|{
name|struct
name|dbx_file
modifier|*
name|next
decl_stmt|;
name|int
name|file_number
decl_stmt|;
name|int
name|next_type_number
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the top of the stack.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dbx_file
modifier|*
name|current_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the next file number to use.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_file_number
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_USE_BINCL */
end_comment

begin_comment
comment|/* These variables are for dbxout_symbol to communicate to    dbxout_finish_symbol.    current_sym_code is the symbol-type-code, a symbol N_... define in stab.h.    current_sym_value and current_sym_addr are two ways to address the    value to store in the symtab entry.    current_sym_addr if nonzero represents the value as an rtx.    If that is zero, current_sym_value is used.  This is used    when the value is an offset (such as for auto variables,    register variables and parms).  */
end_comment

begin_decl_stmt
specifier|static
name|STAB_CODE_TYPE
name|current_sym_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_sym_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|current_sym_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chars of symbol-description generated so far for the    current symbol.  Used by CHARS and CONTIN.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_sym_nchars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report having output N chars of the current symbol-description.  */
end_comment

begin_define
define|#
directive|define
name|CHARS
parameter_list|(
name|N
parameter_list|)
value|(current_sym_nchars += (N))
end_define

begin_comment
comment|/* Break the current symbol-description, generating a continuation,    if it has become long.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_CONTIN_LENGTH
end_ifndef

begin_define
define|#
directive|define
name|DBX_CONTIN_LENGTH
value|80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DBX_CONTIN_LENGTH
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|CONTIN
define|\
value|do {if (current_sym_nchars> DBX_CONTIN_LENGTH) dbxout_continue ();} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONTIN
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|dbxout_init
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_finish
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_start_source_file
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_end_source_file
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_typedefs
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_fptype_value
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_type_index
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|DBX_CONTIN_LENGTH
operator|>
literal|0
end_if

begin_decl_stmt
specifier|static
name|void
name|dbxout_continue
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|dbxout_args
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_type_fields
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_type_method_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_type_methods
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_range_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_type
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_int_cst_octal
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_octal
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_wide_int
name|PARAMS
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_type_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dbxout_symbol_location
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|rtx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_symbol_name
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_prepare_symbol
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_finish_symbol
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_block
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_global_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The debug hooks structure.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|dbxout_source_line
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_source_file
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_function_end
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_begin_function
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_begin_block
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_end_block
name|PARAMS
argument_list|(
operator|(
name|unsigned
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dbxout_function_decl
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|gcc_debug_hooks
name|dbx_debug_hooks
init|=
block|{
name|dbxout_init
block|,
name|dbxout_finish
block|,
name|debug_nothing_int_charstar
block|,
name|debug_nothing_int_charstar
block|,
name|dbxout_start_source_file
block|,
name|dbxout_end_source_file
block|,
name|dbxout_begin_block
block|,
name|dbxout_end_block
block|,
name|debug_true_tree
block|,
comment|/* ignore_block */
name|dbxout_source_line
block|,
comment|/* source_line */
name|dbxout_source_line
block|,
comment|/* begin_prologue: just output line info */
name|debug_nothing_int
block|,
comment|/* end_prologue */
name|debug_nothing_void
block|,
comment|/* end_epilogue */
ifdef|#
directive|ifdef
name|DBX_FUNCTION_FIRST
name|dbxout_begin_function
block|,
else|#
directive|else
name|debug_nothing_tree
block|,
comment|/* begin_function */
endif|#
directive|endif
name|debug_nothing_int
block|,
comment|/* end_function */
name|dbxout_function_decl
block|,
name|dbxout_global_decl
block|,
comment|/* global_decl */
name|debug_nothing_tree
block|,
comment|/* deferred_inline_function */
name|debug_nothing_tree
block|,
comment|/* outlining_inline_function */
name|debug_nothing_rtx
comment|/* label */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_decl_stmt
name|struct
name|gcc_debug_hooks
name|xcoff_debug_hooks
init|=
block|{
name|dbxout_init
block|,
name|dbxout_finish
block|,
name|debug_nothing_int_charstar
block|,
name|debug_nothing_int_charstar
block|,
name|dbxout_start_source_file
block|,
name|dbxout_end_source_file
block|,
name|xcoffout_begin_block
block|,
name|xcoffout_end_block
block|,
name|debug_true_tree
block|,
comment|/* ignore_block */
name|xcoffout_source_line
block|,
name|xcoffout_begin_prologue
block|,
comment|/* begin_prologue */
name|debug_nothing_int
block|,
comment|/* end_prologue */
name|xcoffout_end_epilogue
block|,
name|debug_nothing_tree
block|,
comment|/* begin_function */
name|xcoffout_end_function
block|,
name|debug_nothing_tree
block|,
comment|/* function_decl */
name|dbxout_global_decl
block|,
comment|/* global_decl */
name|debug_nothing_tree
block|,
comment|/* deferred_inline_function */
name|debug_nothing_tree
block|,
comment|/* outlining_inline_function */
name|debug_nothing_rtx
comment|/* label */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XCOFF_DEBUGGING_INFO  */
end_comment

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
end_if

begin_function
specifier|static
name|void
name|dbxout_function_end
parameter_list|()
block|{
specifier|static
name|int
name|scope_labelno
init|=
literal|0
decl_stmt|;
name|char
name|lscope_label_name
index|[
literal|100
index|]
decl_stmt|;
comment|/* Convert Ltext into the appropriate format for local labels in case      the system doesn't insert underscores in front of user generated      labels.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|lscope_label_name
argument_list|,
literal|"Lscope"
argument_list|,
name|scope_labelno
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asmfile
argument_list|,
literal|"Lscope"
argument_list|,
name|scope_labelno
argument_list|)
expr_stmt|;
name|scope_labelno
operator|++
expr_stmt|;
comment|/* By convention, GCC will mark the end of a function with an N_FUN      symbol and an empty string.  */
ifdef|#
directive|ifdef
name|DBX_OUTPUT_NFUN
name|DBX_OUTPUT_NFUN
argument_list|(
name|asmfile
argument_list|,
name|lscope_label_name
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"\",%d,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|N_FUN
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|lscope_label_name
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO */
end_comment

begin_comment
comment|/* At the beginning of compilation, start writing the symbol table.    Initialize `typevec' and output the standard data types of C.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_init
parameter_list|(
name|input_file_name
parameter_list|)
specifier|const
name|char
modifier|*
name|input_file_name
decl_stmt|;
block|{
name|char
name|ltext_label_name
index|[
literal|100
index|]
decl_stmt|;
name|tree
name|syms
init|=
name|getdecls
argument_list|()
decl_stmt|;
name|asmfile
operator|=
name|asm_out_file
expr_stmt|;
name|typevec_len
operator|=
literal|100
expr_stmt|;
name|typevec
operator|=
operator|(
expr|struct
name|typeinfo
operator|*
operator|)
name|xcalloc
argument_list|(
name|typevec_len
argument_list|,
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Convert Ltext into the appropriate format for local labels in case      the system doesn't insert underscores in front of user generated      labels.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ltext_label_name
argument_list|,
literal|"Ltext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put the current working directory in an N_SO symbol.  */
ifndef|#
directive|ifndef
name|DBX_WORKING_DIRECTORY
comment|/* Only some versions of DBX want this, 				 but GDB always does.  */
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|cwd
operator|&&
operator|(
name|cwd
operator|=
name|getpwd
argument_list|()
operator|)
operator|&&
operator|(
operator|!
operator|*
name|cwd
operator|||
name|cwd
index|[
name|strlen
argument_list|(
name|cwd
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
name|cwd
operator|=
name|concat
argument_list|(
name|cwd
argument_list|,
name|FILE_NAME_JOINER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwd
condition|)
block|{
ifdef|#
directive|ifdef
name|DBX_OUTPUT_MAIN_SOURCE_DIRECTORY
name|DBX_OUTPUT_MAIN_SOURCE_DIRECTORY
argument_list|(
name|asmfile
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asmfile
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,0,0,"
argument_list|,
name|N_SO
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|ltext_label_name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */
block|}
block|}
ifdef|#
directive|ifdef
name|DBX_OUTPUT_MAIN_SOURCE_FILENAME
comment|/* This should NOT be DBX_OUTPUT_SOURCE_FILENAME. That      would give us an N_SOL, and we want an N_SO.  */
name|DBX_OUTPUT_MAIN_SOURCE_FILENAME
argument_list|(
name|asmfile
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no DBX_OUTPUT_MAIN_SOURCE_FILENAME */
comment|/* We include outputting `Ltext:' here,      because that gives you a way to override it.  */
comment|/* Used to put `Ltext:' before the reference, but that loses on sun 4.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asmfile
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,0,0,"
argument_list|,
name|N_SO
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|ltext_label_name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asmfile
argument_list|,
literal|"Ltext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no DBX_OUTPUT_MAIN_SOURCE_FILENAME */
ifdef|#
directive|ifdef
name|DBX_OUTPUT_GCC_MARKER
name|DBX_OUTPUT_GCC_MARKER
argument_list|(
name|asmfile
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Emit an N_OPT stab to indicate that this file was compiled by GCC.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s\",%d,0,0,0\n"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|STABS_GCC_MARKER
argument_list|,
name|N_OPT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lastfile
operator|=
name|input_file_name
expr_stmt|;
name|next_type_number
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
name|current_file
operator|=
operator|(
expr|struct
name|dbx_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|current_file
argument_list|)
expr_stmt|;
name|current_file
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|current_file
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|current_file
operator|->
name|next_type_number
operator|=
literal|1
expr_stmt|;
name|next_file_number
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Make sure that types `int' and `char' have numbers 1 and 2.      Definitions of other integer types will refer to those numbers.      (Actually it should no longer matter what their numbers are.      Also, if any types with tags have been defined, dbxout_symbol      will output them first, so the numbers won't be 1 and 2.  That      happens in C++.  So it's a good thing it should no longer matter).  */
ifdef|#
directive|ifdef
name|DBX_OUTPUT_STANDARD_TYPES
name|DBX_OUTPUT_STANDARD_TYPES
argument_list|(
name|syms
argument_list|)
expr_stmt|;
else|#
directive|else
name|dbxout_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|char_type_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get all permanent types that have typedef names,      and output them all, except for those already output.  */
name|dbxout_typedefs
argument_list|(
name|syms
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output any typedef names for types described by TYPE_DECLs in SYMS,    in the reverse order from that which is found in SYMS.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_typedefs
parameter_list|(
name|syms
parameter_list|)
name|tree
name|syms
decl_stmt|;
block|{
if|if
condition|(
name|syms
condition|)
block|{
name|dbxout_typedefs
argument_list|(
name|TREE_CHAIN
argument_list|(
name|syms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|syms
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|syms
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|dbxout_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Change to reading from a new source file.  Generate a N_BINCL stab.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_start_source_file
parameter_list|(
name|line
parameter_list|,
name|filename
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
name|struct
name|dbx_file
modifier|*
name|n
init|=
operator|(
expr|struct
name|dbx_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|n
argument_list|)
decl_stmt|;
name|n
operator|->
name|next
operator|=
name|current_file
expr_stmt|;
name|n
operator|->
name|file_number
operator|=
name|next_file_number
operator|++
expr_stmt|;
name|n
operator|->
name|next_type_number
operator|=
literal|1
expr_stmt|;
name|current_file
operator|=
name|n
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asmfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,0,0,0\n"
argument_list|,
name|N_BINCL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Revert to reading a previous source file.  Generate a N_EINCL stab.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_end_source_file
parameter_list|(
name|line
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
name|struct
name|dbx_file
modifier|*
name|next
decl_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s%d,0,0,0\n"
argument_list|,
name|ASM_STABN_OP
argument_list|,
name|N_EINCL
argument_list|)
expr_stmt|;
name|next
operator|=
name|current_file
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|current_file
argument_list|)
expr_stmt|;
name|current_file
operator|=
name|next
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
end_if

begin_comment
comment|/* Output debugging info to FILE to switch to sourcefile FILENAME.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_source_file
parameter_list|(
name|file
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|filename
operator|&&
operator|(
name|lastfile
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|filename
argument_list|,
name|lastfile
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DBX_OUTPUT_SOURCE_FILENAME
name|DBX_OUTPUT_SOURCE_FILENAME
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
name|ltext_label_name
index|[
literal|100
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ltext_label_name
argument_list|,
literal|"Ltext"
argument_list|,
name|source_label_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,0,0,"
argument_list|,
name|N_SOL
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|ltext_label_name
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
empty_stmt|;
comment|/* Don't change section amid function.  */
else|else
name|text_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"Ltext"
argument_list|,
name|source_label_number
argument_list|)
expr_stmt|;
name|source_label_number
operator|++
expr_stmt|;
endif|#
directive|endif
name|lastfile
operator|=
name|filename
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a line number symbol entry for source file FILENAME and line    number LINENO.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_source_line
parameter_list|(
name|lineno
parameter_list|,
name|filename
parameter_list|)
name|unsigned
name|int
name|lineno
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|dbxout_source_file
argument_list|(
name|asmfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_LINE
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|asmfile
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s%d,0,%d\n"
argument_list|,
name|ASM_STABD_OP
argument_list|,
name|N_SLINE
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Describe the beginning of an internal block within a function.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_begin_block
parameter_list|(
name|line
parameter_list|,
name|n
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asmfile
argument_list|,
literal|"LBB"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Describe the end line-number of an internal block within a function.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_end_block
parameter_list|(
name|line
parameter_list|,
name|n
parameter_list|)
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
block|{
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asmfile
argument_list|,
literal|"LBE"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output dbx data for a function definition.    This includes a definition of the function name itself (a symbol),    definitions of the parameters (locating them in the parameter list)    and then output the block that makes up the function's body    (including all the auto variables of the function).  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_function_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|DBX_FUNCTION_FIRST
name|dbxout_begin_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dbxout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_OUTPUT_FUNCTION_END
name|DBX_OUTPUT_FUNCTION_END
argument_list|(
name|asmfile
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|use_gnu_debug_info_extensions
if|#
directive|if
name|defined
argument_list|(
name|NO_DBX_FUNCTION_END
argument_list|)
operator|&&
operator|!
name|NO_DBX_FUNCTION_END
endif|#
directive|endif
operator|&&
name|targetm
operator|.
name|have_named_sections
condition|)
name|dbxout_function_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO  */
end_comment

begin_comment
comment|/* Debug information for a global DECL.  Called from toplev.c after    compilation proper has finished.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_global_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Not necessary?  */
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* At the end of compilation, finish writing the symbol table.    Unless you define DBX_OUTPUT_MAIN_SOURCE_FILE_END, the default is    to do nothing.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_finish
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DBX_OUTPUT_MAIN_SOURCE_FILE_END
name|DBX_OUTPUT_MAIN_SOURCE_FILE_END
argument_list|(
name|asmfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBX_OUTPUT_MAIN_SOURCE_FILE_END */
block|}
end_function

begin_comment
comment|/* Output floating point type values used by the 'R' stab letter.    These numbers come from include/aout/stab_gnu.h in binutils/gdb.     There are only 3 real/complex types defined, and we need 7/6.    We use NF_SINGLE as a generic float type, and NF_COMPLEX as a generic    complex type.  Since we have the type size anyways, we don't really need    to distinguish between different FP types, we only need to distinguish    between float and complex.  This works fine with gdb.     We only use this for complex types, to avoid breaking backwards    compatibility for real types.  complex types aren't in ISO C90, so it is    OK if old debuggers don't understand the debug info we emit for them.  */
end_comment

begin_comment
comment|/* ??? These are supposed to be IEEE types, but we don't check for that.    We could perhaps add additional numbers for non-IEEE types if we need    them.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_fptype_value
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|char
name|value
init|=
literal|'0'
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|SFmode
condition|)
name|value
operator|=
literal|'1'
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DFmode
condition|)
name|value
operator|=
literal|'2'
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|TFmode
operator|||
name|mode
operator|==
name|XFmode
condition|)
name|value
operator|=
literal|'6'
expr_stmt|;
else|else
comment|/* Use NF_SINGLE as a generic real type for other sizes.  */
name|value
operator|=
literal|'1'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|SCmode
condition|)
name|value
operator|=
literal|'3'
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|DCmode
condition|)
name|value
operator|=
literal|'4'
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|TCmode
operator|||
name|mode
operator|==
name|XCmode
condition|)
name|value
operator|=
literal|'5'
expr_stmt|;
else|else
comment|/* Use NF_COMPLEX as a generic complex type for other sizes.  */
name|value
operator|=
literal|'3'
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|putc
argument_list|(
name|value
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the index of a type.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_index
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|DBX_USE_BINCL
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%d"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|typeinfo
modifier|*
name|t
init|=
operator|&
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
decl_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"(%d,%d)"
argument_list|,
name|t
operator|->
name|file_number
argument_list|,
name|t
operator|->
name|type_number
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|9
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|DBX_CONTIN_LENGTH
operator|>
literal|0
end_if

begin_comment
comment|/* Continue a symbol-description that gets too big.    End one symbol table entry with a double-backslash    and start a new one, eventually producing something like    .stabs "start......\\",code,0,value    .stabs "...rest",code,0,value   */
end_comment

begin_function
specifier|static
name|void
name|dbxout_continue
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DBX_CONTIN_CHAR
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%c"
argument_list|,
name|DBX_CONTIN_CHAR
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dbxout_finish_symbol
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\""
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|current_sym_nchars
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_CONTIN_LENGTH> 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `dbxout_type'.  Output the type fields of TYPE.    This must be a separate function because anonymous unions require    recursive calls.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_fields
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|tem
decl_stmt|;
comment|/* Output the name, type, position (in bits), size (in bits) of each      field that we can support.  */
for|for
control|(
name|tem
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
block|{
comment|/* Omit here local type decls until we know how to support them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|TYPE_DECL
comment|/* Omit fields whose position or size are variable or too large to 	     represent.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
operator|!
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
comment|/* Omit here the nameless fields that are used to skip bits.  */
operator|||
name|DECL_IGNORED_P
argument_list|(
name|tem
argument_list|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|CONST_DECL
condition|)
block|{
comment|/* Continue the line if necessary, 	     but not before the first field.  */
if|if
condition|(
name|tem
operator|!=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
condition|)
name|CONTIN
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s:"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
operator|(
name|TREE_PRIVATE
argument_list|(
name|tem
argument_list|)
operator|||
name|TREE_PROTECTED
argument_list|(
name|tem
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|FIELD_DECL
operator|)
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
literal|'/'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|TREE_PRIVATE
argument_list|(
name|tem
argument_list|)
condition|?
literal|'0'
else|:
name|TREE_PROTECTED
argument_list|(
name|tem
argument_list|)
condition|?
literal|'1'
else|:
literal|'2'
operator|)
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|tem
argument_list|)
operator|)
condition|?
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|tem
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|tem
argument_list|)
operator|&&
name|use_gnu_debug_info_extensions
condition|)
block|{
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":%s;"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If TEM is non-static, GDB won't understand it.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",0,0;"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|int_bit_position
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `dbxout_type_methods'.  Output debug info about the    method described DECL.  DEBUG_NAME is an encoding of the method's    type signature.  ??? We may be able to do without DEBUG_NAME altogether    now.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_method_1
parameter_list|(
name|decl
parameter_list|,
name|debug_name
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|debug_name
decl_stmt|;
block|{
name|char
name|c1
init|=
literal|'A'
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|c2
operator|=
literal|'?'
expr_stmt|;
else|else
comment|/* it's a METHOD_TYPE.  */
block|{
name|tree
name|firstarg
init|=
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* A for normal functions. 	 B for `const' member functions. 	 C for `volatile' member functions. 	 D for `const volatile' member functions.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
condition|)
name|c1
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
condition|)
name|c1
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|c2
operator|=
literal|'*'
expr_stmt|;
else|else
name|c2
operator|=
literal|'.'
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":%s;%c%c%c"
argument_list|,
name|debug_name
argument_list|,
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|?
literal|'0'
else|:
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|?
literal|'1'
else|:
literal|'2'
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|+
literal|6
operator|-
operator|(
name|debug_name
operator|-
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|print_wide_int
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `dbxout_type'.  Output debug info about the methods defined    in TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_methods
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
comment|/* C++: put out the method names and their parameter lists */
name|tree
name|methods
init|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|type_encoding
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|tree
name|last
decl_stmt|;
name|char
name|formatted_type_identifier_length
index|[
literal|16
index|]
decl_stmt|;
name|int
name|type_identifier_length
decl_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL_TREE
condition|)
return|return;
name|type_encoding
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* C++: Template classes break some assumptions made by this code about      the class names, constructor names, and encodings for assembler      label names.  For now, disable output of dbx info for them.  */
block|{     const char *ptr = IDENTIFIER_POINTER (type_encoding);
comment|/* This should use index.  (mrs) */
block|while (*ptr&& *ptr != '<') ptr++;     if (*ptr != 0)       { 	static int warned; 	if (!warned) 	    warned = 1; 	return;       }   }
endif|#
directive|endif
name|type_identifier_length
operator|=
name|IDENTIFIER_LENGTH
argument_list|(
name|type_encoding
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|formatted_type_identifier_length
argument_list|,
literal|"%d"
argument_list|,
name|type_identifier_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|methods
argument_list|)
operator|!=
name|TREE_VEC
condition|)
name|fndecl
operator|=
name|methods
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|fndecl
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fndecl
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|fndecl
condition|)
block|{
name|int
name|need_prefix
init|=
literal|1
decl_stmt|;
comment|/* Group together all the methods for the same operation. 	 These differ in the types of the arguments.  */
for|for
control|(
name|last
operator|=
name|NULL_TREE
init|;
name|fndecl
operator|&&
operator|(
name|last
operator|==
name|NULL_TREE
operator|||
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|last
argument_list|)
operator|)
condition|;
name|fndecl
operator|=
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
control|)
comment|/* Output the name of the field (after overloading), as 	   well as the name of the field before overloading, along 	   with its parameter list */
block|{
comment|/* This is the "mangled" name of the method. 	     It encodes the argument types.  */
specifier|const
name|char
modifier|*
name|debug_name
decl_stmt|;
comment|/* Skip methods that aren't FUNCTION_DECLs.  (In C++, these 	     include TEMPLATE_DECLs.)  The debugger doesn't know what 	     to do with such entities anyhow.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
continue|continue;
name|debug_name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|CONTIN
expr_stmt|;
name|last
operator|=
name|fndecl
expr_stmt|;
comment|/* Also ignore abstract methods; those are only interesting to 	     the DWARF backends.  */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DECL_ABSTRACT
argument_list|(
name|fndecl
argument_list|)
condition|)
continue|continue;
comment|/* Redundantly output the plain name, since that's what gdb 	     expects.  */
if|if
condition|(
name|need_prefix
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s::"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|need_prefix
operator|=
literal|0
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_type_method_1
argument_list|(
name|fndecl
argument_list|,
name|debug_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_prefix
condition|)
block|{
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Emit a "range" type specification, which has the form:    "r<index type>;<lower bound>;<upper bound>;".    TYPE is an INTEGER_TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_range_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* E.g. Pascal's ARRAY [BOOLEAN] of INTEGER */
else|else
block|{
comment|/* Traditionally, we made sure 'int' was type 1, and builtin types 	 were defined to be sub-ranges of int.  Unfortunately, this 	 does not allow us to distinguish true sub-ranges from integer 	 types.  So, instead we define integer (non-sub-range) types as 	 sub-ranges of themselves.  This matters for Chill.  If this isn't 	 a subrange type, then we want to define it in terms of itself. 	 However, in C, this may be an anonymous integer type, and we don't 	 want to emit debug info referring to it.  Just calling 	 dbxout_type_index won't work anyways, because the type hasn't been 	 defined yet.  We make this work for both cases by checked to see 	 whether this is a defined type, referring to it if it is, and using 	 'int' otherwise.  */
if|if
condition|(
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|dbxout_type_index
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|dbxout_type_index
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";0"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";-1;"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a reference to a type.  If the type has not yet been    described in the dbx output, output its definition now.    For a type already defined, just refer to its definition    using the type number.     If FULL is nonzero, and the type has been described only with    a forward-reference, output the definition now.    If FULL is zero in this case, just refer to the forward-reference    using the number previously allocated.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type
parameter_list|(
name|type
parameter_list|,
name|full
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|full
decl_stmt|;
block|{
name|tree
name|tem
decl_stmt|;
name|tree
name|main_variant
decl_stmt|;
specifier|static
name|int
name|anonymous_type_number
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
name|type
operator|=
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If there was an input error and we don't really have a type,      avoid crashing and write something that is at least valid      by assuming `int'.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|full
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Try to find the "main variant" with the same name.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|main_variant
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|main_variant
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If we are not using extensions, stabs does not distinguish const and      volatile, so there is no need to make them separate types.  */
if|if
condition|(
operator|!
name|use_gnu_debug_info_extensions
condition|)
name|type
operator|=
name|main_variant
expr_stmt|;
if|if
condition|(
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Type has no dbx number assigned.  Assign next available number.  */
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
operator|=
name|next_type_number
operator|++
expr_stmt|;
comment|/* Make sure type vector is long enough to record about this type.  */
if|if
condition|(
name|next_type_number
operator|==
name|typevec_len
condition|)
block|{
name|typevec
operator|=
operator|(
expr|struct
name|typeinfo
operator|*
operator|)
name|xrealloc
argument_list|(
name|typevec
argument_list|,
name|typevec_len
operator|*
literal|2
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|typevec
operator|+
name|typevec_len
operator|)
argument_list|,
literal|0
argument_list|,
name|typevec_len
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|typevec_len
operator|*=
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|file_number
operator|=
name|current_file
operator|->
name|file_number
expr_stmt|;
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|type_number
operator|=
name|current_file
operator|->
name|next_type_number
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Output the number of this type, to refer to it.  */
name|dbxout_type_index
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_TYPE_DEFINED
if|if
condition|(
name|DBX_TYPE_DEFINED
argument_list|(
name|type
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* If this type's definition has been output or is now being output,      that is all.  */
switch|switch
condition|(
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|status
condition|)
block|{
case|case
name|TYPE_UNSEEN
case|:
break|break;
case|case
name|TYPE_XREF
case|:
comment|/* If we have already had a cross reference, 	 and either that's all we want or that's the best we could do, 	 don't repeat the cross reference. 	 Sun dbx crashes if we do.  */
if|if
condition|(
operator|!
name|full
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
comment|/* No way in DBX fmt to describe a variable size.  */
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
break|break;
case|case
name|TYPE_DEFINED
case|:
return|return;
block|}
ifdef|#
directive|ifdef
name|DBX_NO_XREFS
comment|/* For systems where dbx output does not allow the `=xsNAME:' syntax,      leave the type-number completely undefined rather than output      a cross-reference.  If we have already used GNU debug info extensions,      then it is OK to output a cross reference.  This is necessary to get      proper C++ debug output.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|!
name|use_gnu_debug_info_extensions
condition|)
comment|/* We must use the same test here as we use twice below when deciding        whether to emit a cross-reference.  */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|full
operator|)
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
comment|/* No way in DBX fmt to describe a variable size.  */
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|status
operator|=
name|TYPE_XREF
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Output a definition now.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Mark it as defined, so that if it is self-referent      we will not get into an infinite recursion of definitions.  */
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|status
operator|=
name|TYPE_DEFINED
expr_stmt|;
comment|/* If this type is a variant of some other, hand off.  Types with      different names are usefully distinguished.  We only distinguish      cv-qualified types if we're using extensions.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_READONLY
argument_list|(
name|main_variant
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|'k'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|build_type_variant
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_VOLATILE
argument_list|(
name|main_variant
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|'B'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|main_variant
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* 'type' is a typedef; output the type it refers to.  */
name|dbxout_type
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else continue.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|LANG_TYPE
case|:
comment|/* For a void type, just define it as itself; ie, "5=5". 	 This makes us consider it defined 	 without saying what it is.  The debugger will make it 	 a void type when the reference is seen, and nothing will 	 ever override that default.  */
name|dbxout_type_index
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|type
operator|==
name|char_type_node
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Output the type `char' as a subrange of itself! 	     I don't understand this definition, just copied it 	     from the output of pcc. 	     This used to use `r2' explicitly and we used to 	     take care to make sure that `char' was type number 2.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type_index
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";0;127;"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a subtype of another integer type, always prefer to 	 write it as a subtype.  */
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* If the size is non-standard, say what it is if we can use 	     GDB extensions.  */
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"@s%d;"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|dbxout_range_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the size is non-standard, say what it is if we can use 	     GDB extensions.  */
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"@s%d;"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* If we can use GDB extensions and the size is wider than a 	     long (the size used by GDB to read them) or we may have 	     trouble writing the bounds the usual way, write them in 	     octal.  Note the test is for the *target's* size of "long", 	     not that of the host.  The host test is just to make sure we 	     can write it out in case the host wide int is narrower than the 	     target "long".  */
comment|/* For unsigned types, we use octal if they are the same size or 	     larger.  This is because we print the bounds as signed decimal, 	     and hence they can't span same size unsigned types.  */
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|||
operator|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type_index
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|print_int_cst_octal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|print_int_cst_octal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Output other integer types as subranges of `int'.  */
name|dbxout_range_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REAL_TYPE
case|:
comment|/* This used to say `r1' and we used to take care 	 to make sure that `int' was type number 1.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type_index
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";0;"
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
literal|"@s"
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|BITS_PER_UNIT
operator|*
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";-20;"
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output the type `char' as a subrange of itself. 	     That is what pcc seems to do.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type_index
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";0;%d;"
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|255
else|:
literal|127
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BOOLEAN_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
literal|"@s"
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|BITS_PER_UNIT
operator|*
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";-16;"
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Define as enumeral type (False, True) */
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"eFalse:0,True:1,;"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|17
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FILE_TYPE
case|:
name|putc
argument_list|(
literal|'d'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
comment|/* Differs from the REAL_TYPE by its new data type number */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
name|putc
argument_list|(
literal|'R'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_fptype_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
literal|2
operator|*
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|";0;"
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output a complex integer type as a structure, 	     pending some other way to do it.  */
name|putc
argument_list|(
literal|'s'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"real:"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",0,%d;"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"imag:"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,%d;;"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SET_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
literal|"@s"
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|BITS_PER_UNIT
operator|*
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Check if a bitstring type, which in Chill is 	     different from a [power]set.  */
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"@S;"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
name|putc
argument_list|(
literal|'S'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Make arrays of packed bits look like bitstrings for chill.  */
if|if
condition|(
name|TYPE_PACKED
argument_list|(
name|type
argument_list|)
operator|&&
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fputs
argument_list|(
literal|"@s"
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|BITS_PER_UNIT
operator|*
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";@S;S"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Output "a" followed by a range type definition 	 for the index type of the array 	 followed by a reference to the target-type. 	 ar1;0;N;M for a C array of type M and size N+1.  */
comment|/* Check if a character string type, which in Chill is 	 different from an array of characters.  */
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
operator|&&
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"@S;"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|tem
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"ar"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dbxout_type_index
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";0;-1;"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_range_type
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TREE_VEC
operator|&&
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|n_baseclasses
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output a structure type.  We must use the same test here as we 	   use in the DBX_NO_XREFS case above.  */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|full
operator|)
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
comment|/* No way in DBX fmt to describe a variable size.  */
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If the type is just a cross reference, output one 	       and mark the type as partially described. 	       If it later becomes defined, we will output 	       its real definition. 	       If the type has a name, don't nest its definition within 	       another type's definition; instead, output an xref 	       and let the definition come when the name is defined.  */
name|fputs
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|?
literal|"xs"
else|:
literal|"xu"
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This assertion is legitimately false in C++.  */
comment|/* We shouldn't be outputting a reference to a type before its 	       definition unless the type has a tag name. 	       A typedef name without a tag name should be impossible.  */
block|if (TREE_CODE (TYPE_NAME (type)) != IDENTIFIER_NODE) 	      abort ();
endif|#
directive|endif
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|dbxout_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"$$%d"
argument_list|,
name|anonymous_type_number
operator|++
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|status
operator|=
name|TYPE_XREF
expr_stmt|;
break|break;
block|}
comment|/* Identify record or union, and print its size.  */
name|putc
argument_list|(
operator|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|?
literal|'s'
else|:
literal|'u'
operator|)
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
if|if
condition|(
name|n_baseclasses
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"!%d,"
argument_list|,
name|n_baseclasses
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|child
init|=
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|child
argument_list|)
condition|?
literal|'1'
else|:
literal|'0'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|TREE_VIA_PUBLIC
argument_list|(
name|child
argument_list|)
condition|?
literal|'2'
else|:
literal|'0'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|child
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
condition|)
comment|/* For a virtual base, print the (negative) offset within 		     the vtable where we must look to find the necessary 		     adjustment.  */
name|print_wide_int
argument_list|(
name|tree_low_cst
argument_list|(
name|BINFO_VPTR_FIELD
argument_list|(
name|child
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|print_wide_int
argument_list|(
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|child
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Print out the base class information with fields 		   which have the same names at the types they hold.  */
name|dbxout_type_name
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|':'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|,
name|full
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|child
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|print_wide_int
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|TYPE_NAME
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Write out the field declarations.  */
name|dbxout_type_fields
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|dbxout_type_methods
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
comment|/* Avoid the ~ if we don't really need it--it confuses dbx.  */
operator|&&
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
comment|/* Tell GDB+ that it may keep reading.  */
name|putc
argument_list|(
literal|'~'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* We need to write out info about what field this class 	     uses as its "main" vtable pointer field, because if this 	     field is inherited from a base class, GDB cannot necessarily 	     figure out which field it's using in time.  */
if|if
condition|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|'%'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|DECL_FCONTEXT
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENUMERAL_TYPE
case|:
comment|/* We must use the same test here as we use in the DBX_NO_XREFS case 	 above.  We simplify it a bit since an enum will never have a variable 	 size.  */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|full
operator|)
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"xe"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dbxout_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|status
operator|=
name|TYPE_XREF
expr_stmt|;
name|putc
argument_list|(
literal|':'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DBX_OUTPUT_ENUM
name|DBX_OUTPUT_ENUM
argument_list|(
name|asmfile
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"@s%d;"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'e'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s:"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|print_wide_int
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|print_wide_int
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|print_int_cst_octal
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|CONTIN
expr_stmt|;
block|}
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|POINTER_TYPE
case|:
name|putc
argument_list|(
literal|'*'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
literal|'#'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Write the argument types out longhand.  */
name|dbxout_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_args
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Treat it as a function type.  */
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
literal|'@'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Should print as an int, because it is really just an offset.  */
name|dbxout_type
argument_list|(
name|integer_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
name|use_gnu_debug_info_extensions
condition|?
literal|'&'
else|:
literal|'*'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|putc
argument_list|(
literal|'f'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the value of integer constant C, in octal,    handling double precision.  */
end_comment

begin_function
specifier|static
name|void
name|print_int_cst_octal
parameter_list|(
name|c
parameter_list|)
name|tree
name|c
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|high
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|int
name|excess
init|=
operator|(
literal|3
operator|-
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|%
literal|3
operator|)
operator|)
decl_stmt|;
name|unsigned
name|int
name|width
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
argument_list|)
decl_stmt|;
comment|/* GDB wants constants with no extra leading "1" bits, so      we need to remove any sign-extension that might be      present.  */
if|if
condition|(
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|&=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|=
literal|0
expr_stmt|;
else|else
name|high
operator|=
literal|0
operator|,
name|low
operator|&=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|excess
operator|==
literal|3
condition|)
block|{
name|print_octal
argument_list|(
name|high
argument_list|,
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|3
argument_list|)
expr_stmt|;
name|print_octal
argument_list|(
name|low
argument_list|,
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|beg
init|=
name|high
operator|>>
name|excess
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|middle
init|=
operator|(
operator|(
name|high
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|excess
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
literal|3
operator|-
name|excess
operator|)
operator||
operator|(
name|low
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|3
operator|*
literal|3
operator|)
operator|)
operator|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|end
init|=
name|low
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|3
operator|*
literal|3
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%o%01o"
argument_list|,
operator|(
name|int
operator|)
name|beg
argument_list|,
operator|(
name|int
operator|)
name|middle
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|print_octal
argument_list|(
name|end
argument_list|,
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_octal
parameter_list|(
name|value
parameter_list|,
name|digits
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|int
name|digits
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|digits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%01o"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|value
operator|>>
operator|(
literal|3
operator|*
name|i
operator|)
operator|)
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
name|digits
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output C in decimal while adjusting the number of digits written.  */
end_comment

begin_function
specifier|static
name|void
name|print_wide_int
parameter_list|(
name|c
parameter_list|)
name|HOST_WIDE_INT
name|c
decl_stmt|;
block|{
name|int
name|digs
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|digs
operator|++
operator|,
name|c
operator|=
operator|-
name|c
expr_stmt|;
while|while
condition|(
name|c
operator|>
literal|0
condition|)
name|c
operator|/=
literal|10
expr_stmt|;
name|digs
operator|++
expr_stmt|;
name|CHARS
argument_list|(
name|digs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the name of type TYPE, with no punctuation.    Such names can be set up either by typedef declarations    or by struct, enum and union tags.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_name
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|t
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a .stabs for the symbol defined by DECL,    which must be a ..._DECL node in the normal namespace.    It may be a CONST_DECL, a FUNCTION_DECL, a PARM_DECL or a VAR_DECL.    LOCAL is nonzero if the scope is less than the entire file.    Return 1 if a stabs might have been emitted.  */
end_comment

begin_function
name|int
name|dbxout_symbol
parameter_list|(
name|decl
parameter_list|,
name|local
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|local
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* Cast avoids warning in old compilers.  */
name|current_sym_code
operator|=
operator|(
name|STAB_CODE_TYPE
operator|)
literal|0
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
comment|/* Ignore nameless syms, but don't ignore type tags.  */
if|if
condition|(
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
operator|||
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
name|dbxout_prepare_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The output will always start with the symbol name,      so always count that in the length-output-so-far.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|CONST_DECL
case|:
comment|/* Enum values are defined by defining the enum type.  */
break|break;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
comment|/* Don't mention a nested function under its parent.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|current_function_decl
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
break|break;
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s:%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|?
literal|'F'
else|:
literal|'f'
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
name|current_sym_code
operator|=
name|N_FUN
expr_stmt|;
name|current_sym_addr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dbxout_type
argument_list|(
name|void_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For a nested function, when that function is compiled, 	 mention the containing function name 	 as well as (since dbx wants it) our own assembler-name.  */
if|if
condition|(
name|context
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%s,%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|#
directive|if
literal|0
comment|/* This seems all wrong.  Outputting most kinds of types gives no name 	 at all.  A true definition gives no name; a cross-ref for a 	 structure can give the tag name, but not a type name. 	 It seems that no typedef name is defined by outputting a type.  */
comment|/* If this typedef name was defined by outputting the type, 	 don't duplicate it.  */
block|if (typevec[TYPE_SYMTAB_ADDRESS (type)].status == TYPE_DEFINED&& TYPE_NAME (TREE_TYPE (decl)) == decl) 	return 0;
endif|#
directive|endif
comment|/* Don't output the same typedef twice.          And don't output what language-specific stuff doesn't want output.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|||
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
name|FORCE_TEXT
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|{
name|int
name|tag_needed
init|=
literal|1
decl_stmt|;
name|int
name|did_output
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Nonzero means we must output a tag as well as a typedef.  */
name|tag_needed
operator|=
literal|0
expr_stmt|;
comment|/* Handle the case of a C++ structure or union 	       where the TYPE_NAME is a TYPE_DECL 	       which gives both a typedef name and a tag.  */
comment|/* dbx requires the tag first and the typedef second.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|decl
operator|&&
operator|!
operator|(
name|use_gnu_debug_info_extensions
operator|&&
name|have_used_extensions
operator|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
comment|/* Distinguish the implicit typedefs of C++ 		   from explicit ones that might be found in C.  */
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
comment|/* Do not generate a tag for records of variable size, 		   since this type can not be properly described in the 		   DBX format, and it confuses some tools such as objdump.  */
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|current_sym_code
operator|=
name|DBX_TYPE_DECL_STABS_CODE
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s:T"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* Output typedef name.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s:"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Short cut way to output a tag also.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|decl
comment|/* Distinguish the implicit typedefs of C++ 		   from explicit ones that might be found in C.  */
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|have_used_extensions
condition|)
block|{
name|putc
argument_list|(
literal|'T'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Now we generate the tag for this case up above.  */
block|else 		  tag_needed = 1;
endif|#
directive|endif
block|}
name|putc
argument_list|(
literal|'t'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|current_sym_code
operator|=
name|DBX_TYPE_DECL_STABS_CODE
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Don't output a tag if this is an incomplete type.  This prevents 	   the sun4 Sun OS 4.x dbx from crashing.  */
if|if
condition|(
name|tag_needed
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* For a TYPE_DECL with no name, but the type has a name, 	       output a tag. 	       This is what represents `struct foo' with no typedef.  */
comment|/* In C++, the name of a type is the corresponding typedef. 	       In C, it is an IDENTIFIER_NODE.  */
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|current_sym_code
operator|=
name|DBX_TYPE_DECL_STABS_CODE
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s:T"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If an enum type has no name, it cannot be referred to, 	   but we must output it anyway, since the enumeration constants 	   can be referred to.  */
if|if
condition|(
operator|!
name|did_output
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|current_sym_code
operator|=
name|DBX_TYPE_DECL_STABS_CODE
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
expr_stmt|;
comment|/* Some debuggers fail when given NULL names, so give this a 	       harmless name of ` '.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\" :T"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* Prevent duplicate output of a typedef.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|PARM_DECL
case|:
comment|/* Parm decls go in their own separate chains 	 and are output by dbxout_reg_parms and dbxout_parms.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|RESULT_DECL
case|:
comment|/* Named return value, treat like a VAR_DECL.  */
case|case
name|VAR_DECL
case|:
if|if
condition|(
operator|!
name|DECL_RTL_SET_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Don't mention a variable that is external. 	 Let the file that defines it describe it.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
comment|/* If the variable is really a constant 	 and not written in memory, inform the debugger.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BLOCK
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The sun4 assembler does not grok this.  */
specifier|const
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|ival
init|=
name|tree_low_cst
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DBX_OUTPUT_CONSTANT_SYMBOL
name|DBX_OUTPUT_CONSTANT_SYMBOL
argument_list|(
name|asmfile
argument_list|,
name|name
argument_list|,
name|ival
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s:c=i"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
name|HOST_WIDE_INT_PRINT_DEC
argument_list|,
name|ival
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\",0x%x,0,0,0\n"
argument_list|,
name|N_LSYM
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
comment|/* don't know how to do this yet.  */
block|}
break|break;
block|}
comment|/* else it is something we handle like a normal variable.  */
block|}
name|SET_DECL_RTL
argument_list|(
name|decl
argument_list|,
name|eliminate_regs
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the stab for DECL, a VAR_DECL, RESULT_DECL or PARM_DECL.    Add SUFFIX to its name, if SUFFIX is not 0.    Describe the variable as residing in HOME    (usually HOME is DECL_RTL (DECL), but not always).    Returns 1 if the stab was really emitted.  */
end_comment

begin_function
specifier|static
name|int
name|dbxout_symbol_location
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|,
name|suffix
parameter_list|,
name|home
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|rtx
name|home
decl_stmt|;
block|{
name|int
name|letter
init|=
literal|0
decl_stmt|;
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Don't mention a variable at all      if it was completely optimized into nothingness.            If the decl was from an inline function, then its rtl      is not identically the rtl that was used in this      particular compilation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|value
init|=
name|home
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
condition|)
name|value
operator|=
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|value
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
name|home
operator|=
name|alter_subreg
argument_list|(
operator|&
name|home
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|home
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
comment|/* The kind-of-variable letter depends on where      the variable is and on the scope of its name:      G and N_GSYM for static storage and global scope,      S for static storage and file scope,      V for static storage and local scope,      for those two, use N_LCSYM if data is in bss segment,      N_STSYM if in data segment, N_FUN otherwise.      (We used N_FUN originally, then changed to N_STSYM      to please GDB.  However, it seems that confused ld.      Now GDB has been fixed to like N_FUN, says Kingdon.)      no letter at all, and N_LSYM, for auto variable,      r and N_RSYM for register variable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|letter
operator|=
literal|'G'
expr_stmt|;
name|current_sym_code
operator|=
name|N_GSYM
expr_stmt|;
block|}
else|else
block|{
name|current_sym_addr
operator|=
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|letter
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|?
literal|'V'
else|:
literal|'S'
expr_stmt|;
comment|/* This should be the same condition as in assemble_variable, but 	     we don't have access to dont_output_data here.  So, instead, 	     we rely on the fact that error_mark_node initializers always 	     end up in bss for C++ and never end up in bss for C.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C++"
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
name|current_sym_code
operator|=
name|N_LCSYM
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_IN_TEXT_SECTION
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* This is not quite right, but it's the closest 	       of all the codes that Unix defines.  */
name|current_sym_code
operator|=
name|DBX_STATIC_CONST_VAR_CODE
expr_stmt|;
else|else
block|{
comment|/* Some ports can transform a symbol ref into a label ref, 		 because the symbol ref is too far away and has to be 		 dumped into a constant pool.  Alternatively, the symbol 		 in the constant pool might be referenced by a different 		 symbol.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|current_sym_addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|current_sym_addr
argument_list|)
condition|)
block|{
name|rtx
name|tmp
init|=
name|get_pool_constant
argument_list|(
name|current_sym_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|LABEL_REF
condition|)
name|current_sym_addr
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* Ultrix `as' seems to need this.  */
ifdef|#
directive|ifdef
name|DBX_STATIC_STAB_DATA_SECTION
name|data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|current_sym_code
operator|=
name|N_STSYM
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|letter
operator|=
literal|'r'
expr_stmt|;
name|current_sym_code
operator|=
name|N_RSYM
expr_stmt|;
name|current_sym_value
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|)
operator|)
condition|)
comment|/* If the value is indirect by memory or by a register        that isn't the frame pointer        then it means the object is variable-sized and address through        that register or stack slot.  DBX has no way to represent this        so all we can do is output the variable as a pointer.        If it's not a parameter, ignore it.        (VAR_DECLs like this can be made by integrate.c.)  */
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|letter
operator|=
literal|'r'
expr_stmt|;
name|current_sym_code
operator|=
name|N_RSYM
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
name|current_sym_value
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
comment|/* RTL looks like (MEM (MEM (PLUS (REG...) (CONST_INT...)))). 	     We want the value of that CONST_INT.  */
name|current_sym_value
operator|=
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Effectively do build_pointer_type, but don't cache this type, 	 since it might be temporary whereas the type it points to 	 might have been saved for inlining.  */
comment|/* Don't use REFERENCE_TYPE because dbx can't handle that.  */
name|type
operator|=
name|make_node
argument_list|(
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
name|current_sym_value
operator|=
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
comment|/* RTL looks like (MEM (PLUS (REG...) (CONST_INT...))) 	 We want the value of that CONST_INT.  */
name|current_sym_value
operator|=
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
condition|)
block|{
comment|/* Handle an obscure case which can arise when optimizing and 	 when there are few available registers.  (This is *always* 	 the case for i386/i486 targets).  The RTL looks like 	 (MEM (CONST ...)) even though this variable is a local `auto' 	 or a local `register' variable.  In effect, what has happened 	 is that the reload pass has seen that all assignments and 	 references for one such a local variable can be replaced by 	 equivalent assignments and references to some static storage 	 variable, thereby avoiding the need for a register.  In such 	 cases we're forced to lie to debuggers and tell them that 	 this variable was itself `static'.  */
name|current_sym_code
operator|=
name|N_LCSYM
expr_stmt|;
name|letter
operator|=
literal|'V'
expr_stmt|;
name|current_sym_addr
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|tree
name|subtype
decl_stmt|;
comment|/* If TYPE is not a COMPLEX_TYPE (it might be a RECORD_TYPE, 	 for example), then there is no easy way to figure out 	 what SUBTYPE should be.  So, we give up.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return
literal|0
return|;
name|subtype
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If the variable's storage is in two parts, 	 output each as a separate stab with a modified name.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$imag"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$real"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cast avoids warning in old compilers.  */
name|current_sym_code
operator|=
operator|(
name|STAB_CODE_TYPE
operator|)
literal|0
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|dbxout_prepare_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$real"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$imag"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
comment|/* Address might be a MEM, when DECL is a variable-sized object.        Or it might be const0_rtx, meaning previous passes        want us to ignore this variable.  */
return|return
literal|0
return|;
comment|/* Ok, start a symtab entry and output the variable name.  */
name|FORCE_TEXT
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_STATIC_BLOCK_START
name|DBX_STATIC_BLOCK_START
argument_list|(
name|asmfile
argument_list|,
name|current_sym_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dbxout_symbol_name
argument_list|(
name|decl
argument_list|,
name|suffix
argument_list|,
name|letter
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_STATIC_BLOCK_END
name|DBX_STATIC_BLOCK_END
argument_list|(
name|asmfile
argument_list|,
name|current_sym_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the symbol name of DECL for a stabs, with suffix SUFFIX.    Then output LETTER to indicate the kind of location the symbol has.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_symbol_name
parameter_list|(
name|decl
parameter_list|,
name|suffix
parameter_list|,
name|letter
parameter_list|)
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
name|int
name|letter
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
comment|/* One slight hitch: if this is a VAR_DECL which is a static        class member, we must put out the mangled name instead of the        DECL_NAME.  Note also that static member (variable) names DO NOT begin        with underscores in .stabs directives.  */
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* ...but if we're function-local, we don't want to include the junk        added by ASM_FORMAT_PRIVATE_NAME.  */
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|name
operator|=
literal|"(anon)"
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s%s:"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|name
argument_list|,
operator|(
name|suffix
condition|?
name|suffix
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|letter
condition|)
name|putc
argument_list|(
name|letter
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dbxout_prepare_symbol
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|WINNING_GDB
specifier|const
name|char
modifier|*
name|filename
init|=
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|dbxout_source_file
argument_list|(
name|asmfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|dbxout_finish_symbol
parameter_list|(
name|sym
parameter_list|)
name|tree
name|sym
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DBX_FINISH_SYMBOL
name|DBX_FINISH_SYMBOL
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|line
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|sym
operator|!=
literal|0
condition|)
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\",%d,0,%d,"
argument_list|,
name|current_sym_code
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_sym_addr
condition|)
name|output_addr_const
argument_list|(
name|asmfile
argument_list|,
name|current_sym_addr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%d"
argument_list|,
name|current_sym_value
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output definitions of all the decls in a chain. Return non-zero if    anything was output */
end_comment

begin_function
name|int
name|dbxout_syms
parameter_list|(
name|syms
parameter_list|)
name|tree
name|syms
decl_stmt|;
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|syms
condition|)
block|{
name|result
operator|+=
name|dbxout_symbol
argument_list|(
name|syms
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|syms
operator|=
name|TREE_CHAIN
argument_list|(
name|syms
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following two functions output definitions of function parameters.    Each parameter gets a definition locating it in the parameter list.    Each parameter that is a register variable gets a second definition    locating it in the register.     Printing or argument lists in gdb uses the definitions that    locate in the parameter list.  But reference to the variable in    expressions uses preferentially the definition as a register.  */
end_comment

begin_comment
comment|/* Output definitions, referring to storage in the parmlist,    of all the parms in PARMS, which is a chain of PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|dbxout_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|dbxout_prepare_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* Perform any necessary register eliminations on the parameter's rtl, 	   so that the debugging output will be accurate.  */
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parms
argument_list|,
name|eliminate_regs
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
block|{
name|leaf_renumber_regs_insn
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|leaf_renumber_regs_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|PARM_PASSED_IN_MEMORY
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* ??? Here we assume that the parm address is indexed 	       off the frame pointer or arg pointer. 	       If that is not true, we produce meaningless results, 	       but do not crash.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|current_sym_value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_code
operator|=
name|N_PSYM
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s:%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|DBX_MEMPARM_STABS_LETTER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_sym_nchars
operator|=
literal|8
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"(anon):%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|DBX_MEMPARM_STABS_LETTER
argument_list|)
expr_stmt|;
block|}
comment|/* It is quite tempting to use: 	        	           dbxout_type (TREE_TYPE (parms), 0);  	       as the next statement, rather than using DECL_ARG_TYPE(), so 	       that gcc reports the actual type of the parameter, rather 	       than the promoted type.  This certainly makes GDB's life 	       easier, at least for some ports.  The change is a bad idea 	       however, since GDB expects to be able access the type without 	       performing any conversions.  So for example, if we were 	       passing a float to an unprototyped function, gcc will store a 	       double on the stack, but if we emit a stab saying the type is a 	       float, then gdb will only read in a single value, and this will 	       produce an erroneous value.  */
name|dbxout_type
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_sym_value
operator|=
name|DEBUGGER_ARG_OFFSET
argument_list|(
name|current_sym_value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|best_rtl
decl_stmt|;
name|char
name|regparm_letter
decl_stmt|;
name|tree
name|parm_type
decl_stmt|;
comment|/* Parm passed in registers and lives in registers or nowhere.  */
name|current_sym_code
operator|=
name|DBX_REGPARM_STABS_CODE
expr_stmt|;
name|regparm_letter
operator|=
name|DBX_REGPARM_STABS_LETTER
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
comment|/* If parm lives in a register, use that register; 	       pretend the parm was passed there.  It would be more consistent 	       to describe the register where the parm was passed, 	       but in practice that register usually holds something else.  	       If we use DECL_RTL, then we must use the declared type of 	       the variable, not the type that it arrived in.  */
if|if
condition|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|best_rtl
operator|=
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parm_type
operator|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
comment|/* If the parm lives nowhere, use the register where it was 	       passed.  It is also better to use the declared type here.  */
else|else
block|{
name|best_rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parm_type
operator|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
name|current_sym_value
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|best_rtl
argument_list|)
argument_list|)
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s:%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|regparm_letter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_sym_nchars
operator|=
literal|8
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"(anon):%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|regparm_letter
argument_list|)
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
name|parm_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ARG_POINTER_REGNUM
endif|#
directive|endif
condition|)
block|{
comment|/* Parm was passed via invisible reference. 	       That is, its address was passed in a register. 	       Output it as if it lived in that register. 	       The debugger will know from the type 	       that it was actually passed by invisible reference.  */
name|char
name|regparm_letter
decl_stmt|;
comment|/* Parm passed in registers and lives in registers or nowhere.  */
name|current_sym_code
operator|=
name|DBX_REGPARM_STABS_CODE
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
name|regparm_letter
operator|=
name|GDB_INV_REF_REGPARM_STABS_LETTER
expr_stmt|;
else|else
name|regparm_letter
operator|=
name|DBX_REGPARM_STABS_LETTER
expr_stmt|;
comment|/* DECL_RTL looks like (MEM (REG...).  Get the register number. 	       If it is an unallocated pseudo-reg, then use the register where 	       it was passed instead.  */
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|current_sym_value
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|current_sym_value
operator|=
name|REGNO
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|current_sym_nchars
operator|=
literal|2
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s:%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|regparm_letter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_sym_nchars
operator|=
literal|8
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"(anon):%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|regparm_letter
argument_list|)
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Parm was passed via invisible reference, with the reference 	       living on the stack.  DECL_RTL looks like 	       (MEM (MEM (PLUS (REG ...) (CONST_INT ...)))) or it 	       could look like (MEM (MEM (REG))).  */
specifier|const
name|char
modifier|*
specifier|const
name|decl_name
init|=
operator|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|?
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
else|:
literal|"(anon)"
operator|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|current_sym_value
operator|=
literal|0
expr_stmt|;
else|else
name|current_sym_value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s:v"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|decl_name
argument_list|)
expr_stmt|;
name|current_sym_value
operator|=
name|DEBUGGER_ARG_OFFSET
argument_list|(
name|current_sym_value
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|const0_rtx
comment|/* ??? A constant address for a parm can happen 		    when the reg it lives in is equiv to a constant in memory. 		    Should make this not happen, after 2.4.  */
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Parm was passed in registers but lives on the stack.  */
name|current_sym_code
operator|=
name|N_PSYM
expr_stmt|;
comment|/* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))), 	       in which case we want the value of that CONST_INT, 	       or (MEM (REG ...)), 	       in which case we use a value of zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
name|current_sym_value
operator|=
literal|0
expr_stmt|;
else|else
name|current_sym_value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
comment|/* Make a big endian correction if the mode of the type of the 	       parameter is not the same as the mode of the rtl.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|current_sym_value
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FORCE_TEXT
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|current_sym_nchars
operator|=
literal|2
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s:%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|DBX_MEMPARM_STABS_LETTER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_sym_nchars
operator|=
literal|8
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"(anon):%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|DBX_MEMPARM_STABS_LETTER
argument_list|)
expr_stmt|;
block|}
name|current_sym_value
operator|=
name|DEBUGGER_ARG_OFFSET
argument_list|(
name|current_sym_value
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output definitions for the places where parms live during the function,    when different from where they were passed, when the parms were passed    in memory.     It is not useful to do this for parms passed in registers    that live during the function in different registers, because it is    impossible to look in the passed register for the passed value,    so we use the within-the-function register to begin with.     PARMS is a chain of PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|dbxout_reg_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
operator|&&
name|PARM_PASSED_IN_MEMORY
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|dbxout_prepare_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* Report parms that live in registers during the function 	   but were passed in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|dbxout_symbol_location
argument_list|(
name|parms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|CONCAT
condition|)
name|dbxout_symbol_location
argument_list|(
name|parms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Report parms that live in memory but not where they were passed.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
name|dbxout_symbol_location
argument_list|(
name|parms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a chain of ..._TYPE nodes (as come in a parameter list),    output definitions of those names, in raw form */
end_comment

begin_function
specifier|static
name|void
name|dbxout_args
parameter_list|(
name|args
parameter_list|)
name|tree
name|args
decl_stmt|;
block|{
while|while
condition|(
name|args
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output everything about a symbol block (a BLOCK node    that represents a scope level),    including recursive output of contained blocks.     BLOCK is the BLOCK node.    DEPTH is its depth within containing symbol blocks.    ARGS is usually zero; but for the outermost block of the    body of a function, it is a chain of PARM_DECLs for the function parameters.    We output definitions of all the register parms    as if they were local variables of that block.     If -g1 was used, we count blocks just the same, but output nothing    except for the outermost block.     Actually, BLOCK may be several blocks chained together.    We handle them all in sequence.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_block
parameter_list|(
name|block
parameter_list|,
name|depth
parameter_list|,
name|args
parameter_list|)
name|tree
name|block
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|int
name|blocknum
init|=
operator|-
literal|1
decl_stmt|;
if|#
directive|if
name|DBX_BLOCKS_FUNCTION_RELATIVE
specifier|const
name|char
modifier|*
name|begin_label
decl_stmt|;
if|if
condition|(
name|current_function_func_begin_label
operator|!=
name|NULL_TREE
condition|)
name|begin_label
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|current_function_func_begin_label
argument_list|)
expr_stmt|;
else|else
name|begin_label
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|block
condition|)
block|{
comment|/* Ignore blocks never expanded or otherwise marked as real.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|int
name|did_output
decl_stmt|;
ifdef|#
directive|ifdef
name|DBX_LBRAC_FIRST
name|did_output
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* In dbx format, the syms of a block come before the N_LBRAC. 	     If nothing is output, we don't need the N_LBRAC, either.  */
name|did_output
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
operator|||
name|depth
operator|==
literal|0
condition|)
name|did_output
operator|=
name|dbxout_syms
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|dbxout_reg_parms
argument_list|(
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now output an N_LBRAC symbol to represent the beginning of 	     the block.  Use the block's tree-walk order to generate 	     the assembler symbols LBBn and LBEn 	     that final will define around the code in this block.  */
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
name|did_output
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|blocknum
operator|=
name|BLOCK_NUMBER
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LBB"
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_HANDLER_BLOCK
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|/* A catch block.  Must precede N_LBRAC.  */
name|tree
name|decl
init|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
decl_stmt|;
while|while
condition|(
name|decl
condition|)
block|{
ifdef|#
directive|ifdef
name|DBX_OUTPUT_CATCH
name|DBX_OUTPUT_CATCH
argument_list|(
name|asmfile
argument_list|,
name|decl
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s\"%s:C1\",%d,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|N_CATCH
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DBX_OUTPUT_LBRAC
name|DBX_OUTPUT_LBRAC
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s%d,0,0,"
argument_list|,
name|ASM_STABN_OP
argument_list|,
name|N_LBRAC
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
name|DBX_BLOCKS_FUNCTION_RELATIVE
name|putc
argument_list|(
literal|'-'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DBX_LBRAC_FIRST
comment|/* On some weird machines, the syms of a block 	     come after the N_LBRAC.  */
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
operator|||
name|depth
operator|==
literal|0
condition|)
name|dbxout_syms
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|dbxout_reg_parms
argument_list|(
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Output the subblocks.  */
name|dbxout_block
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Refer to the marker for the end of the block.  */
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
name|did_output
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LBE"
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_OUTPUT_RBRAC
name|DBX_OUTPUT_RBRAC
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s%d,0,0,"
argument_list|,
name|ASM_STABN_OP
argument_list|,
name|N_RBRAC
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
name|DBX_BLOCKS_FUNCTION_RELATIVE
name|putc
argument_list|(
literal|'-'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the information about a function and its arguments and result.    Usually this follows the function's code,    but on some systems, it comes before.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
end_if

begin_function
specifier|static
name|void
name|dbxout_begin_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_parms
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|dbxout_symbol
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
end_comment

end_unit

