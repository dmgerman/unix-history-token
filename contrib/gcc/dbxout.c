begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output dbx-format symbol table information from GNU compiler.    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/* Output dbx-format symbol table data.    This consists of many symbol table entries, each of them    a .stabs assembler pseudo-op with four operands:    a "name" which is really a description of one symbol and its type,    a "code", which is a symbol defined in stab.h whose name starts with N_,    an unused operand always 0,    and a "value" which is an address or an offset.    The name is enclosed in doublequote characters.     Each function, variable, typedef, and structure tag    has a symbol table entry to define it.    The beginning and end of each level of name scoping within    a function are also marked by special symbol table entries.     The "name" consists of the symbol name, a colon, a kind-of-symbol letter,    and a data type number.  The data type number may be followed by    "=" and a type definition; normally this will happen the first time    the type number is mentioned.  The type definition may refer to    other types by number, and those type numbers may be followed    by "=" and nested definitions.     This can make the "name" quite long.    When a name is more than 80 characters, we split the .stabs pseudo-op    into two .stabs pseudo-ops, both sharing the same "code" and "value".    The first one is marked as continued with a double-backslash at the    end of its "name".     The kind-of-symbol letter distinguished function names from global    variables from file-scope variables from parameters from auto    variables in memory from typedef names from register variables.    See `dbxout_symbol'.     The "code" is mostly redundant with the kind-of-symbol letter    that goes in the "name", but not entirely: for symbols located    in static storage, the "code" says which segment the address is in,    which controls how it is relocated.     The "value" for a symbol in static storage    is the core address of the symbol (actually, the assembler    label for the symbol).  For a symbol located in a stack slot    it is the stack offset; for one in a register, the register number.    For a typedef symbol, it is zero.     If DEBUG_SYMS_TEXT is defined, all debugging symbols must be    output while in the text section.     For more on data type definitions, see `dbxout_type'.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"dbxout.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DBXOUT_DECR_NESTING
define|\
value|if (--debug_nesting == 0&& symbol_queue_index> 0) \     { emit_pending_bincls_if_required (); debug_flush_symbol_queue (); }
end_define

begin_define
define|#
directive|define
name|DBXOUT_DECR_NESTING_AND_RETURN
parameter_list|(
name|x
parameter_list|)
define|\
value|do {--debug_nesting; return (x);} while (0)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_STABS_OP
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_define
define|#
directive|define
name|ASM_STABS_OP
value|"\t.stabx\t"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ASM_STABS_OP
value|"\t.stabs\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_STABN_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_STABN_OP
value|"\t.stabn\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_STABD_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_STABD_OP
value|"\t.stabd\t"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_TYPE_DECL_STABS_CODE
end_ifndef

begin_define
define|#
directive|define
name|DBX_TYPE_DECL_STABS_CODE
value|N_LSYM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_STATIC_CONST_VAR_CODE
end_ifndef

begin_define
define|#
directive|define
name|DBX_STATIC_CONST_VAR_CODE
value|N_FUN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_REGPARM_STABS_CODE
end_ifndef

begin_define
define|#
directive|define
name|DBX_REGPARM_STABS_CODE
value|N_RSYM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_REGPARM_STABS_LETTER
end_ifndef

begin_define
define|#
directive|define
name|DBX_REGPARM_STABS_LETTER
value|'P'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DBX_FUNCTION_END
end_ifndef

begin_define
define|#
directive|define
name|NO_DBX_FUNCTION_END
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DBX_BNSYM_ENSYM
end_ifndef

begin_define
define|#
directive|define
name|NO_DBX_BNSYM_ENSYM
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DBX_MAIN_SOURCE_DIRECTORY
end_ifndef

begin_define
define|#
directive|define
name|NO_DBX_MAIN_SOURCE_DIRECTORY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_BLOCKS_FUNCTION_RELATIVE
end_ifndef

begin_define
define|#
directive|define
name|DBX_BLOCKS_FUNCTION_RELATIVE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_LINES_FUNCTION_RELATIVE
end_ifndef

begin_define
define|#
directive|define
name|DBX_LINES_FUNCTION_RELATIVE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_CONTIN_LENGTH
end_ifndef

begin_define
define|#
directive|define
name|DBX_CONTIN_LENGTH
value|80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_CONTIN_CHAR
end_ifndef

begin_define
define|#
directive|define
name|DBX_CONTIN_CHAR
value|'\\'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|typestatus
block|{
name|TYPE_UNSEEN
block|,
name|TYPE_XREF
block|,
name|TYPE_DEFINED
block|}
enum|;
end_enum

begin_comment
comment|/* Structure recording information about a C data type.    The status element says whether we have yet output    the definition of the type.  TYPE_XREF says we have    output it as a cross-reference only.    The file_number and type_number elements are used if DBX_USE_BINCL    is defined.  */
end_comment

begin_decl_stmt
name|struct
name|typeinfo
name|GTY
argument_list|(
operator|(
operator|)
argument_list|)
block|{
name|enum
name|typestatus
name|status
decl_stmt|;
name|int
name|file_number
decl_stmt|;
name|int
name|type_number
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Vector recording information about C data types.    When we first notice a data type (a tree node),    we assign it a number using next_type_number.    That is its index in this vector.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(length (
literal|"typevec_len"
argument|))
argument_list|)
expr|struct
name|typeinfo
operator|*
name|typevec
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of elements of space allocated in `typevec'.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|typevec_len
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* In dbx output, each type gets a unique number.    This is the number for the next type output.    The number, once assigned, is in the TYPE_SYMTAB_ADDRESS field.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|next_type_number
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The C front end may call dbxout_symbol before dbxout_init runs.    We save all such decls in this list and output them when we get    to dbxout_init.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|preinit_symbols
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
name|binclstatus
block|{
name|BINCL_NOT_REQUIRED
block|,
name|BINCL_PENDING
block|,
name|BINCL_PROCESSED
block|}
enum|;
end_enum

begin_comment
comment|/* When using N_BINCL in dbx output, each type number is actually a    pair of the file number and the type number within the file.    This is a stack of input files.  */
end_comment

begin_struct
struct|struct
name|dbx_file
block|{
name|struct
name|dbx_file
modifier|*
name|next
decl_stmt|;
name|int
name|file_number
decl_stmt|;
name|int
name|next_type_number
decl_stmt|;
name|enum
name|binclstatus
name|bincl_status
decl_stmt|;
comment|/* Keep track of lazy bincl.  */
specifier|const
name|char
modifier|*
name|pending_bincl_name
decl_stmt|;
comment|/* Name of bincl.  */
name|struct
name|dbx_file
modifier|*
name|prev
decl_stmt|;
comment|/* Chain to traverse all pending bincls.  */
block|}
struct|;
end_struct

begin_comment
comment|/* This is the top of the stack.          This is not saved for PCH, because restoring a PCH should not change it.    next_file_number does have to be saved, because the PCH may use some    file numbers; however, just before restoring a PCH, next_file_number    should always be 0 because we should not have needed any file numbers    yet.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
operator|)
expr|\
operator|&&
name|defined
argument_list|(
name|DBX_USE_BINCL
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|dbx_file
modifier|*
name|current_file
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the next file number to use.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|next_file_number
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A counter for dbxout_function_end.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|scope_labelno
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A counter for dbxout_source_line.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|dbxout_source_line_counter
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number for the next N_SOL filename stabs label.  The number 0 is reserved    for the N_SO filename stabs label.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|source_label_number
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Last source file name mentioned in a NOTE insn.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
specifier|const
name|char
operator|*
name|lastfile
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Used by PCH machinery to detect if 'lastfile' should be reset to    base_input_file.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|lastfile_is_base
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Typical USG systems don't have stab.h, and they also have    no use for DBX-format debugging info.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
end_ifdef

begin_comment
comment|/* If zero then there is no pending BINCL.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pending_bincls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The original input file name.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|base_input_file
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_SYMS_TEXT
end_ifdef

begin_define
define|#
directive|define
name|FORCE_TEXT
value|switch_to_section (current_function_section ())
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_TEXT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_define
define|#
directive|define
name|STAB_CODE_TYPE
value|enum __stab_debug_code
end_define

begin_comment
comment|/* 1 if PARM is passed to this function in memory.  */
end_comment

begin_define
define|#
directive|define
name|PARM_PASSED_IN_MEMORY
parameter_list|(
name|PARM
parameter_list|)
define|\
value|(MEM_P (DECL_INCOMING_RTL (PARM)))
end_define

begin_comment
comment|/* A C expression for the integer offset value of an automatic variable    (N_LSYM) having address X (an RTX).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUGGER_AUTO_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|DEBUGGER_AUTO_OFFSET
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A C expression for the integer offset value of an argument (N_PSYM)    having address X (an RTX).  The nominal offset is OFFSET.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUGGER_ARG_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|DEBUGGER_ARG_OFFSET
parameter_list|(
name|OFFSET
parameter_list|,
name|X
parameter_list|)
value|(OFFSET)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This obstack holds the stab string currently being constructed.  We    build it up here, then write it out, so we can split long lines up    properly (see dbxout_finish_complex_stabs).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|stabstr_ob
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|stabstr_last_contin_point
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
end_ifdef

begin_function_decl
specifier|static
name|void
name|emit_bincl_stab
parameter_list|(
specifier|const
name|char
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|emit_pending_bincls
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
specifier|inline
name|void
name|emit_pending_bincls_if_required
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_init
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_finish
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_start_source_file
parameter_list|(
name|unsigned
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_end_source_file
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_typedefs
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_type_index
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_args
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_type_fields
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_type_method_1
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_type_methods
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_range_type
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_type
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|print_int_cst_bounds_in_octal_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_type_name
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_class_name_qualifiers
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dbxout_symbol_location
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|rtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_symbol_name
parameter_list|(
name|tree
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_block
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_global_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_type_decl
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_handle_pch
parameter_list|(
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* The debug hooks structure.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|dbxout_source_line
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_begin_prologue
parameter_list|(
name|unsigned
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_source_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_function_end
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_begin_function
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_begin_block
parameter_list|(
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_end_block
parameter_list|(
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_function_decl
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|struct
name|gcc_debug_hooks
name|dbx_debug_hooks
init|=
block|{
name|dbxout_init
block|,
name|dbxout_finish
block|,
name|debug_nothing_int_charstar
block|,
name|debug_nothing_int_charstar
block|,
name|dbxout_start_source_file
block|,
name|dbxout_end_source_file
block|,
name|dbxout_begin_block
block|,
name|dbxout_end_block
block|,
name|debug_true_tree
block|,
comment|/* ignore_block */
name|dbxout_source_line
block|,
comment|/* source_line */
name|dbxout_begin_prologue
block|,
comment|/* begin_prologue */
name|debug_nothing_int_charstar
block|,
comment|/* end_prologue */
name|debug_nothing_int_charstar
block|,
comment|/* end_epilogue */
ifdef|#
directive|ifdef
name|DBX_FUNCTION_FIRST
name|dbxout_begin_function
block|,
else|#
directive|else
name|debug_nothing_tree
block|,
comment|/* begin_function */
endif|#
directive|endif
name|debug_nothing_int
block|,
comment|/* end_function */
name|dbxout_function_decl
block|,
name|dbxout_global_decl
block|,
comment|/* global_decl */
name|dbxout_type_decl
block|,
comment|/* type_decl */
name|debug_nothing_tree_tree
block|,
comment|/* imported_module_or_decl */
name|debug_nothing_tree
block|,
comment|/* deferred_inline_function */
name|debug_nothing_tree
block|,
comment|/* outlining_inline_function */
name|debug_nothing_rtx
block|,
comment|/* label */
name|dbxout_handle_pch
block|,
comment|/* handle_pch */
name|debug_nothing_rtx
block|,
comment|/* var_location */
name|debug_nothing_void
block|,
comment|/* switch_text_section */
literal|0
comment|/* start_end_main_source_file */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_decl_stmt
specifier|const
name|struct
name|gcc_debug_hooks
name|xcoff_debug_hooks
init|=
block|{
name|dbxout_init
block|,
name|dbxout_finish
block|,
name|debug_nothing_int_charstar
block|,
name|debug_nothing_int_charstar
block|,
name|dbxout_start_source_file
block|,
name|dbxout_end_source_file
block|,
name|xcoffout_begin_block
block|,
name|xcoffout_end_block
block|,
name|debug_true_tree
block|,
comment|/* ignore_block */
name|xcoffout_source_line
block|,
name|xcoffout_begin_prologue
block|,
comment|/* begin_prologue */
name|debug_nothing_int_charstar
block|,
comment|/* end_prologue */
name|xcoffout_end_epilogue
block|,
name|debug_nothing_tree
block|,
comment|/* begin_function */
name|xcoffout_end_function
block|,
name|debug_nothing_tree
block|,
comment|/* function_decl */
name|dbxout_global_decl
block|,
comment|/* global_decl */
name|dbxout_type_decl
block|,
comment|/* type_decl */
name|debug_nothing_tree_tree
block|,
comment|/* imported_module_or_decl */
name|debug_nothing_tree
block|,
comment|/* deferred_inline_function */
name|debug_nothing_tree
block|,
comment|/* outlining_inline_function */
name|debug_nothing_rtx
block|,
comment|/* label */
name|dbxout_handle_pch
block|,
comment|/* handle_pch */
name|debug_nothing_rtx
block|,
comment|/* var_location */
name|debug_nothing_void
block|,
comment|/* switch_text_section */
literal|0
comment|/* start_end_main_source_file */
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XCOFF_DEBUGGING_INFO  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Numeric formatting helper macro.  Note that this does not handle    hexadecimal.  */
end_comment

begin_define
define|#
directive|define
name|NUMBER_FMT_LOOP
parameter_list|(
name|P
parameter_list|,
name|NUM
parameter_list|,
name|BASE
parameter_list|)
define|\
value|do						\     {						\       int digit = NUM % BASE;			\       NUM /= BASE;				\       *--P = digit + '0';			\     }						\   while (NUM> 0)
end_define

begin_comment
comment|/* Utility: write a decimal integer NUM to asm_out_file.  */
end_comment

begin_function
name|void
name|dbxout_int
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
operator|+
sizeof|sizeof
name|buf
decl_stmt|;
name|unsigned
name|int
name|unum
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'0'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'-'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|unum
operator|=
operator|-
name|num
expr_stmt|;
block|}
else|else
name|unum
operator|=
name|num
expr_stmt|;
name|NUMBER_FMT_LOOP
argument_list|(
name|p
argument_list|,
name|unum
argument_list|,
literal|10
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|buf
operator|+
sizeof|sizeof
name|buf
condition|)
block|{
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Primitives for emitting simple stabs directives.  All other stabs    routines should use these functions instead of directly emitting    stabs.  They are exported because machine-dependent code may need    to invoke them, e.g. in a DBX_OUTPUT_* macro whose definition    forwards to code in CPU.c.  */
end_comment

begin_comment
comment|/* The following functions should all be called immediately after one    of the dbxout_begin_stab* functions (below).  They write out    various things as the value of a stab.  */
end_comment

begin_comment
comment|/* Write out a literal zero as the value of a stab.  */
end_comment

begin_function
name|void
name|dbxout_stab_value_zero
parameter_list|(
name|void
parameter_list|)
block|{
name|fputs
argument_list|(
literal|"0\n"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the label LABEL as the value of a stab.  */
end_comment

begin_function
name|void
name|dbxout_stab_value_label
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the difference of two labels, LABEL - BASE, as the value    of a stab.  */
end_comment

begin_function
name|void
name|dbxout_stab_value_label_diff
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|)
block|{
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'-'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asm_out_file
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out an internal label as the value of a stab, and immediately    emit that internal label.  This should be used only when    dbxout_stabd will not work.  STEM is the name stem of the label,    COUNTERP is a pointer to a counter variable which will be used to    guarantee label uniqueness.  */
end_comment

begin_function
name|void
name|dbxout_stab_value_internal_label
parameter_list|(
specifier|const
name|char
modifier|*
name|stem
parameter_list|,
name|int
modifier|*
name|counterp
parameter_list|)
block|{
name|char
name|label
index|[
literal|100
index|]
decl_stmt|;
name|int
name|counter
init|=
name|counterp
condition|?
operator|(
operator|*
name|counterp
operator|)
operator|++
else|:
literal|0
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|stem
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|dbxout_stab_value_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
name|stem
argument_list|,
name|counter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out the difference between BASE and an internal label as the    value of a stab, and immediately emit that internal label.  STEM and    COUNTERP are as for dbxout_stab_value_internal_label.  */
end_comment

begin_function
name|void
name|dbxout_stab_value_internal_label_diff
parameter_list|(
specifier|const
name|char
modifier|*
name|stem
parameter_list|,
name|int
modifier|*
name|counterp
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|)
block|{
name|char
name|label
index|[
literal|100
index|]
decl_stmt|;
name|int
name|counter
init|=
name|counterp
condition|?
operator|(
operator|*
name|counterp
operator|)
operator|++
else|:
literal|0
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
name|stem
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|dbxout_stab_value_label_diff
argument_list|(
name|label
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
name|stem
argument_list|,
name|counter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The following functions produce specific kinds of stab directives.  */
end_comment

begin_comment
comment|/* Write a .stabd directive with type STYPE and desc SDESC to asm_out_file.  */
end_comment

begin_function
name|void
name|dbxout_stabd
parameter_list|(
name|int
name|stype
parameter_list|,
name|int
name|sdesc
parameter_list|)
block|{
name|fputs
argument_list|(
name|ASM_STABD_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|dbxout_int
argument_list|(
name|stype
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",0,"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|dbxout_int
argument_list|(
name|sdesc
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a .stabn directive with type STYPE.  This function stops    short of emitting the value field, which is the responsibility of    the caller (normally it will be either a symbol or the difference    of two symbols).  */
end_comment

begin_function
name|void
name|dbxout_begin_stabn
parameter_list|(
name|int
name|stype
parameter_list|)
block|{
name|fputs
argument_list|(
name|ASM_STABN_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|dbxout_int
argument_list|(
name|stype
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",0,0,"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write a .stabn directive with type N_SLINE and desc LINE.  As above,    the value field is the responsibility of the caller.  */
end_comment

begin_function
name|void
name|dbxout_begin_stabn_sline
parameter_list|(
name|int
name|lineno
parameter_list|)
block|{
name|fputs
argument_list|(
name|ASM_STABN_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|dbxout_int
argument_list|(
name|N_SLINE
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",0,"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|dbxout_int
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a .stabs directive with string "", type STYPE, and desc and    other fields 0.  The value field is the responsibility of the    caller.  This function cannot be used for .stabx directives.  */
end_comment

begin_function
name|void
name|dbxout_begin_empty_stabs
parameter_list|(
name|int
name|stype
parameter_list|)
block|{
name|fputs
argument_list|(
name|ASM_STABS_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\"\","
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|dbxout_int
argument_list|(
name|stype
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",0,0,"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin a .stabs directive with string STR, type STYPE, and desc 0.    The value field is the responsibility of the caller.  */
end_comment

begin_function
name|void
name|dbxout_begin_simple_stabs
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|stype
parameter_list|)
block|{
name|fputs
argument_list|(
name|ASM_STABS_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asm_out_file
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|dbxout_int
argument_list|(
name|stype
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",0,0,"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As above but use SDESC for the desc field.  */
end_comment

begin_function
name|void
name|dbxout_begin_simple_stabs_desc
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|stype
parameter_list|,
name|int
name|sdesc
parameter_list|)
block|{
name|fputs
argument_list|(
name|ASM_STABS_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asm_out_file
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|dbxout_int
argument_list|(
name|stype
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|",0,"
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|dbxout_int
argument_list|(
name|sdesc
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The next set of functions are entirely concerned with production of    "complex" .stabs directives: that is, .stabs directives whose    strings have to be constructed piecemeal.  dbxout_type,    dbxout_symbol, etc. use these routines heavily.  The string is queued    up in an obstack, then written out by dbxout_finish_complex_stabs, which    is also responsible for splitting it up if it exceeds DBX_CONTIN_LENGTH.    (You might think it would be more efficient to go straight to stdio    when DBX_CONTIN_LENGTH is 0 (i.e. no length limit) but that turns    out not to be the case, and anyway this needs fewer #ifdefs.)  */
end_comment

begin_comment
comment|/* Begin a complex .stabs directive.  If we can, write the initial    ASM_STABS_OP to the asm_out_file.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_begin_complex_stabs
parameter_list|(
name|void
parameter_list|)
block|{
name|emit_pending_bincls_if_required
argument_list|()
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
name|fputs
argument_list|(
name|ASM_STABS_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'"'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stabstr_last_contin_point
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* As above, but do not force text or emit pending bincls.  This is    used by dbxout_symbol_location, which needs to do something else.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_begin_complex_stabs_noforcetext
parameter_list|(
name|void
parameter_list|)
block|{
name|fputs
argument_list|(
name|ASM_STABS_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'"'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|stabstr_last_contin_point
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add CHR, a single character, to the string being built.  */
end_comment

begin_define
define|#
directive|define
name|stabstr_C
parameter_list|(
name|chr
parameter_list|)
value|obstack_1grow (&stabstr_ob, chr)
end_define

begin_comment
comment|/* Add STR, a normal C string, to the string being built.  */
end_comment

begin_define
define|#
directive|define
name|stabstr_S
parameter_list|(
name|str
parameter_list|)
value|obstack_grow (&stabstr_ob, str, strlen(str))
end_define

begin_comment
comment|/* Add the text of ID, an IDENTIFIER_NODE, to the string being built.  */
end_comment

begin_define
define|#
directive|define
name|stabstr_I
parameter_list|(
name|id
parameter_list|)
value|obstack_grow (&stabstr_ob, \                                     IDENTIFIER_POINTER (id), \                                     IDENTIFIER_LENGTH (id))
end_define

begin_comment
comment|/* Add NUM, a signed decimal number, to the string being built.  */
end_comment

begin_function
specifier|static
name|void
name|stabstr_D
parameter_list|(
name|HOST_WIDE_INT
name|num
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
operator|+
sizeof|sizeof
name|buf
decl_stmt|;
name|unsigned
name|int
name|unum
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|unum
operator|=
operator|-
name|num
expr_stmt|;
block|}
else|else
name|unum
operator|=
name|num
expr_stmt|;
name|NUMBER_FMT_LOOP
argument_list|(
name|p
argument_list|,
name|unum
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
name|p
argument_list|,
operator|(
name|buf
operator|+
sizeof|sizeof
name|buf
operator|)
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add NUM, an unsigned decimal number, to the string being built.  */
end_comment

begin_function
specifier|static
name|void
name|stabstr_U
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|num
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
operator|+
sizeof|sizeof
name|buf
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
return|return;
block|}
name|NUMBER_FMT_LOOP
argument_list|(
name|p
argument_list|,
name|num
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
name|p
argument_list|,
operator|(
name|buf
operator|+
sizeof|sizeof
name|buf
operator|)
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add CST, an INTEGER_CST tree, to the string being built as an    unsigned octal number.  This routine handles values which are    larger than a single HOST_WIDE_INT.  */
end_comment

begin_function
specifier|static
name|void
name|stabstr_O
parameter_list|(
name|tree
name|cst
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|high
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|cst
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|cst
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
operator|+
sizeof|sizeof
name|buf
decl_stmt|;
comment|/* GDB wants constants with no extra leading "1" bits, so      we need to remove any sign-extension that might be      present.  */
block|{
specifier|const
name|unsigned
name|int
name|width
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|cst
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|&=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|=
literal|0
expr_stmt|;
else|else
name|high
operator|=
literal|0
operator|,
name|low
operator|&=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* Leading zero for base indicator.  */
name|stabstr_C
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
comment|/* If the value is zero, the base indicator will serve as the value      all by itself.  */
if|if
condition|(
name|high
operator|==
literal|0
operator|&&
name|low
operator|==
literal|0
condition|)
return|return;
comment|/* If the high half is zero, we need only print the low half normally.  */
if|if
condition|(
name|high
operator|==
literal|0
condition|)
name|NUMBER_FMT_LOOP
argument_list|(
name|p
argument_list|,
name|low
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* When high != 0, we need to print enough zeroes from low to 	 give the digits from high their proper place-values.  Hence 	 NUMBER_FMT_LOOP cannot be used.  */
specifier|const
name|int
name|n_digits
init|=
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|3
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_digits
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|digit
init|=
name|low
operator|%
literal|8
decl_stmt|;
name|low
operator|/=
literal|8
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'0'
operator|+
name|digit
expr_stmt|;
block|}
comment|/* Octal digits carry exactly three bits of information.  The 	 width of a HOST_WIDE_INT is not normally a multiple of three. 	 Therefore, the next digit printed probably needs to carry 	 information from both low and high.  */
if|if
condition|(
name|HOST_BITS_PER_WIDE_INT
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
specifier|const
name|int
name|n_leftover_bits
init|=
name|HOST_BITS_PER_WIDE_INT
operator|%
literal|3
decl_stmt|;
specifier|const
name|int
name|n_bits_from_high
init|=
literal|3
operator|-
name|n_leftover_bits
decl_stmt|;
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|low_mask
init|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|n_leftover_bits
operator|)
operator|-
literal|1
decl_stmt|;
specifier|const
name|unsigned
name|HOST_WIDE_INT
name|high_mask
init|=
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|)
operator|<<
name|n_bits_from_high
operator|)
operator|-
literal|1
decl_stmt|;
name|unsigned
name|int
name|digit
decl_stmt|;
comment|/* At this point, only the bottom n_leftover_bits bits of low 	     should be set.  */
name|gcc_assert
argument_list|(
operator|!
operator|(
name|low
operator|&
operator|~
name|low_mask
operator|)
argument_list|)
expr_stmt|;
name|digit
operator|=
operator|(
name|low
operator||
operator|(
operator|(
name|high
operator|&
name|high_mask
operator|)
operator|<<
name|n_leftover_bits
operator|)
operator|)
expr_stmt|;
name|high
operator|>>=
name|n_bits_from_high
expr_stmt|;
operator|*
operator|--
name|p
operator|=
literal|'0'
operator|+
name|digit
expr_stmt|;
block|}
comment|/* Now we can format high in the normal manner.  However, if 	 the only bits of high that were set were handled by the 	 digit split between low and high, high will now be zero, and 	 we don't want to print extra digits in that case.  */
if|if
condition|(
name|high
condition|)
name|NUMBER_FMT_LOOP
argument_list|(
name|p
argument_list|,
name|high
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|obstack_grow
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
name|p
argument_list|,
operator|(
name|buf
operator|+
sizeof|sizeof
name|buf
operator|)
operator|-
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called whenever it is safe to break a stabs string into multiple    .stabs directives.  If the current string has exceeded the limit    set by DBX_CONTIN_LENGTH, mark the current position in the buffer    as a continuation point by inserting DBX_CONTIN_CHAR (doubled if    it is a backslash) and a null character.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|stabstr_continue
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|DBX_CONTIN_LENGTH
operator|>
literal|0
operator|&&
name|obstack_object_size
argument_list|(
operator|&
name|stabstr_ob
argument_list|)
operator|-
name|stabstr_last_contin_point
operator|>
name|DBX_CONTIN_LENGTH
condition|)
block|{
if|if
condition|(
name|DBX_CONTIN_CHAR
operator|==
literal|'\\'
condition|)
name|obstack_1grow
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
name|DBX_CONTIN_CHAR
argument_list|)
expr_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|stabstr_last_contin_point
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|stabstr_ob
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|CONTIN
value|stabstr_continue ()
end_define

begin_comment
comment|/* Macro subroutine of dbxout_finish_complex_stabs, which emits    all of the arguments to the .stabs directive after the string.    Overridden by xcoffout.h.  CODE is the stabs code for this symbol;    LINE is the source line to write into the desc field (in extended    mode); SYM is the symbol itself.     ADDR, LABEL, and NUMBER are three different ways to represent the    stabs value field.  At most one of these should be nonzero.       ADDR is used most of the time; it represents the value as an      RTL address constant.       LABEL is used (currently) only for N_CATCH stabs; it represents      the value as a string suitable for assemble_name.       NUMBER is used when the value is an offset from an implicit base      pointer (e.g. for a stack variable), or an index (e.g. for a      register variable).  It represents the value as a decimal integer.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_FINISH_STABS
end_ifndef

begin_define
define|#
directive|define
name|DBX_FINISH_STABS
parameter_list|(
name|SYM
parameter_list|,
name|CODE
parameter_list|,
name|LINE
parameter_list|,
name|ADDR
parameter_list|,
name|LABEL
parameter_list|,
name|NUMBER
parameter_list|)
define|\
value|do {								\   int line_ = use_gnu_debug_info_extensions ? LINE : 0;		\ 								\   dbxout_int (CODE);						\   fputs (",0,", asm_out_file);					\   dbxout_int (line_);						\   putc (',', asm_out_file);					\   if (ADDR)							\     output_addr_const (asm_out_file, ADDR);			\   else if (LABEL)						\     assemble_name (asm_out_file, LABEL);			\   else								\     dbxout_int (NUMBER);					\   putc ('\n', asm_out_file);					\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Finish the emission of a complex .stabs directive.  When DBX_CONTIN_LENGTH    is zero, this has only to emit the close quote and the remainder of    the arguments.  When it is nonzero, the string has been marshalled in    stabstr_ob, and this routine is responsible for breaking it up into    DBX_CONTIN_LENGTH-sized chunks.     SYM is the DECL of the symbol under consideration; it is used only    for its DECL_SOURCE_LINE.  The other arguments are all passed directly    to DBX_FINISH_STABS; see above for details.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_finish_complex_stabs
parameter_list|(
name|tree
name|sym
parameter_list|,
name|STAB_CODE_TYPE
name|code
parameter_list|,
name|rtx
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|int
name|number
parameter_list|)
block|{
name|int
name|line
name|ATTRIBUTE_UNUSED
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|line
operator|=
name|sym
condition|?
name|DECL_SOURCE_LINE
argument_list|(
name|sym
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|DBX_CONTIN_LENGTH
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|chunklen
decl_stmt|;
comment|/* Nul-terminate the growing string, then get its size and 	 address.  */
name|obstack_1grow
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|len
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|stabstr_ob
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|str
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* Within the buffer are a sequence of NUL-separated strings, 	 each of which is to be written out as a separate stab 	 directive.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|chunklen
operator|=
name|strlen
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|chunk
argument_list|,
literal|1
argument_list|,
name|chunklen
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\","
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
comment|/* Must add an extra byte to account for the NUL separator.  */
name|chunk
operator|+=
name|chunklen
operator|+
literal|1
expr_stmt|;
name|len
operator|-=
name|chunklen
operator|+
literal|1
expr_stmt|;
comment|/* Only put a line number on the last stab in the sequence.  */
name|DBX_FINISH_STABS
argument_list|(
name|sym
argument_list|,
name|code
argument_list|,
name|len
operator|==
literal|0
condition|?
name|line
else|:
literal|0
argument_list|,
name|addr
argument_list|,
name|label
argument_list|,
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|fputs
argument_list|(
name|ASM_STABS_OP
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'"'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
block|}
name|stabstr_last_contin_point
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* No continuations - we can put the whole string out at once. 	 It is faster to augment the string with the close quote and 	 comma than to do a two-character fputs.  */
name|obstack_grow
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
literal|"\","
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|obstack_object_size
argument_list|(
operator|&
name|stabstr_ob
argument_list|)
expr_stmt|;
name|str
operator|=
name|XOBFINISH
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
name|DBX_FINISH_STABS
argument_list|(
name|sym
argument_list|,
name|code
argument_list|,
name|line
argument_list|,
name|addr
argument_list|,
name|label
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
name|obstack_free
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
end_if

begin_function
specifier|static
name|void
name|dbxout_function_end
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|char
name|lscope_label_name
index|[
literal|100
index|]
decl_stmt|;
comment|/* The Lscope label must be emitted even if we aren't doing anything      else; dbxout_block needs it.  */
name|switch_to_section
argument_list|(
name|function_section
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert Lscope into the appropriate format for local labels in case      the system doesn't insert underscores in front of user generated      labels.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|lscope_label_name
argument_list|,
literal|"Lscope"
argument_list|,
name|scope_labelno
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
literal|"Lscope"
argument_list|,
name|scope_labelno
argument_list|)
expr_stmt|;
comment|/* The N_FUN tag at the end of the function is a GNU extension,      which may be undesirable, and is unnecessary if we do not have      named sections.  */
if|if
condition|(
operator|!
name|use_gnu_debug_info_extensions
operator|||
name|NO_DBX_FUNCTION_END
operator|||
operator|!
name|targetm
operator|.
name|have_named_sections
operator|||
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* By convention, GCC will mark the end of a function with an N_FUN      symbol and an empty string.  */
if|if
condition|(
name|flag_reorder_blocks_and_partition
condition|)
block|{
name|dbxout_begin_empty_stabs
argument_list|(
name|N_FUN
argument_list|)
expr_stmt|;
name|dbxout_stab_value_label_diff
argument_list|(
name|cfun
operator|->
name|hot_section_end_label
argument_list|,
name|cfun
operator|->
name|hot_section_label
argument_list|)
expr_stmt|;
name|dbxout_begin_empty_stabs
argument_list|(
name|N_FUN
argument_list|)
expr_stmt|;
name|dbxout_stab_value_label_diff
argument_list|(
name|cfun
operator|->
name|cold_section_end_label
argument_list|,
name|cfun
operator|->
name|cold_section_label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|begin_label
index|[
literal|20
index|]
decl_stmt|;
comment|/* Reference current function start using LFBB.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|begin_label
argument_list|,
literal|"LFBB"
argument_list|,
name|scope_labelno
argument_list|)
expr_stmt|;
name|dbxout_begin_empty_stabs
argument_list|(
name|N_FUN
argument_list|)
expr_stmt|;
name|dbxout_stab_value_label_diff
argument_list|(
name|lscope_label_name
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NO_DBX_BNSYM_ENSYM
operator|&&
operator|!
name|flag_debug_only_used_symbols
condition|)
name|dbxout_stabd
argument_list|(
name|N_ENSYM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO */
end_comment

begin_comment
comment|/* Get lang description for N_SO stab.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|ATTRIBUTE_UNUSED
name|get_lang_number
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|language_string
init|=
name|lang_hooks
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|N_SO_C
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|N_SO_CC
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F77"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|N_SO_FORTRAN
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU F95"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|N_SO_FORTRAN90
return|;
comment|/* CHECKME */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Pascal"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|N_SO_PASCAL
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Objective-C"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|N_SO_OBJC
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|language_string
argument_list|,
literal|"GNU Objective-C++"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|N_SO_OBJCPLUS
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* At the beginning of compilation, start writing the symbol table.    Initialize `typevec' and output the standard data types of C.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_init
parameter_list|(
specifier|const
name|char
modifier|*
name|input_file_name
parameter_list|)
block|{
name|char
name|ltext_label_name
index|[
literal|100
index|]
decl_stmt|;
name|bool
name|used_ltext_label_name
init|=
name|false
decl_stmt|;
name|tree
name|syms
init|=
name|lang_hooks
operator|.
name|decls
operator|.
name|getdecls
argument_list|()
decl_stmt|;
name|typevec_len
operator|=
literal|100
expr_stmt|;
name|typevec
operator|=
name|ggc_calloc
argument_list|(
name|typevec_len
argument_list|,
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* stabstr_ob contains one string, which will be just fine with      1-byte alignment.  */
name|obstack_specify_allocation
argument_list|(
operator|&
name|stabstr_ob
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
comment|/* Convert Ltext into the appropriate format for local labels in case      the system doesn't insert underscores in front of user generated      labels.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ltext_label_name
argument_list|,
literal|"Ltext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put the current working directory in an N_SO symbol.  */
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
operator|!
name|NO_DBX_MAIN_SOURCE_DIRECTORY
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|cwd
decl_stmt|;
if|if
condition|(
operator|!
name|cwd
condition|)
block|{
name|cwd
operator|=
name|get_src_pwd
argument_list|()
expr_stmt|;
if|if
condition|(
name|cwd
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|cwd
operator|=
literal|"/"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
name|cwd
index|[
name|strlen
argument_list|(
name|cwd
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cwd
operator|=
name|concat
argument_list|(
name|cwd
argument_list|,
literal|"/"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DBX_OUTPUT_MAIN_SOURCE_DIRECTORY
name|DBX_OUTPUT_MAIN_SOURCE_DIRECTORY
argument_list|(
name|asm_out_file
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */
name|dbxout_begin_simple_stabs_desc
argument_list|(
name|cwd
argument_list|,
name|N_SO
argument_list|,
name|get_lang_number
argument_list|()
argument_list|)
expr_stmt|;
name|dbxout_stab_value_label
argument_list|(
name|ltext_label_name
argument_list|)
expr_stmt|;
name|used_ltext_label_name
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
comment|/* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */
block|}
ifdef|#
directive|ifdef
name|DBX_OUTPUT_MAIN_SOURCE_FILENAME
name|DBX_OUTPUT_MAIN_SOURCE_FILENAME
argument_list|(
name|asm_out_file
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|dbxout_begin_simple_stabs_desc
argument_list|(
name|input_file_name
argument_list|,
name|N_SO
argument_list|,
name|get_lang_number
argument_list|()
argument_list|)
expr_stmt|;
name|dbxout_stab_value_label
argument_list|(
name|ltext_label_name
argument_list|)
expr_stmt|;
name|used_ltext_label_name
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|used_ltext_label_name
condition|)
block|{
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
literal|"Ltext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Emit an N_OPT stab to indicate that this file was compiled by GCC.      The string used is historical.  */
ifndef|#
directive|ifndef
name|NO_DBX_GCC_MARKER
name|dbxout_begin_simple_stabs
argument_list|(
literal|"gcc2_compiled."
argument_list|,
name|N_OPT
argument_list|)
expr_stmt|;
name|dbxout_stab_value_zero
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|base_input_file
operator|=
name|lastfile
operator|=
name|input_file_name
expr_stmt|;
name|next_type_number
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
name|current_file
operator|=
name|XNEW
argument_list|(
expr|struct
name|dbx_file
argument_list|)
expr_stmt|;
name|current_file
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|current_file
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|current_file
operator|->
name|next_type_number
operator|=
literal|1
expr_stmt|;
name|next_file_number
operator|=
literal|1
expr_stmt|;
name|current_file
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|current_file
operator|->
name|bincl_status
operator|=
name|BINCL_NOT_REQUIRED
expr_stmt|;
name|current_file
operator|->
name|pending_bincl_name
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* Get all permanent types that have typedef names, and output them      all, except for those already output.  Some language front ends      put these declarations in the top-level scope; some do not;      the latter are responsible for calling debug_hooks->type_decl from      their record_builtin_type function.  */
name|dbxout_typedefs
argument_list|(
name|syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|preinit_symbols
condition|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|nreverse
argument_list|(
name|preinit_symbols
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|dbxout_symbol
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|preinit_symbols
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output any typedef names for types described by TYPE_DECLs in SYMS.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_typedefs
parameter_list|(
name|tree
name|syms
parameter_list|)
block|{
for|for
control|(
init|;
name|syms
operator|!=
name|NULL_TREE
condition|;
name|syms
operator|=
name|TREE_CHAIN
argument_list|(
name|syms
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|syms
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|syms
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|dbxout_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
end_ifdef

begin_comment
comment|/* Emit BINCL stab using given name.  */
end_comment

begin_function
specifier|static
name|void
name|emit_bincl_stab
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dbxout_begin_simple_stabs
argument_list|(
name|name
argument_list|,
name|N_BINCL
argument_list|)
expr_stmt|;
name|dbxout_stab_value_zero
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If there are pending bincls then it is time to emit all of them.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|emit_pending_bincls_if_required
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|pending_bincls
condition|)
name|emit_pending_bincls
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Emit all pending bincls.  */
end_comment

begin_function
specifier|static
name|void
name|emit_pending_bincls
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dbx_file
modifier|*
name|f
init|=
name|current_file
decl_stmt|;
comment|/* Find first pending bincl.  */
while|while
condition|(
name|f
operator|->
name|bincl_status
operator|==
name|BINCL_PENDING
condition|)
name|f
operator|=
name|f
operator|->
name|next
expr_stmt|;
comment|/* Now emit all bincls.  */
name|f
operator|=
name|f
operator|->
name|prev
expr_stmt|;
while|while
condition|(
name|f
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|bincl_status
operator|==
name|BINCL_PENDING
condition|)
block|{
name|emit_bincl_stab
argument_list|(
name|f
operator|->
name|pending_bincl_name
argument_list|)
expr_stmt|;
comment|/* Update file number and status.  */
name|f
operator|->
name|file_number
operator|=
name|next_file_number
operator|++
expr_stmt|;
name|f
operator|->
name|bincl_status
operator|=
name|BINCL_PROCESSED
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|current_file
condition|)
break|break;
name|f
operator|=
name|f
operator|->
name|prev
expr_stmt|;
block|}
comment|/* All pending bincls have been emitted.  */
name|pending_bincls
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
specifier|inline
name|void
name|emit_pending_bincls_if_required
parameter_list|(
name|void
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Change to reading from a new source file.  Generate a N_BINCL stab.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_start_source_file
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
name|struct
name|dbx_file
modifier|*
name|n
init|=
name|XNEW
argument_list|(
expr|struct
name|dbx_file
argument_list|)
decl_stmt|;
name|n
operator|->
name|next
operator|=
name|current_file
expr_stmt|;
name|n
operator|->
name|next_type_number
operator|=
literal|1
expr_stmt|;
comment|/* Do not assign file number now.       Delay it until we actually emit BINCL.  */
name|n
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|n
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|current_file
operator|->
name|prev
operator|=
name|n
expr_stmt|;
name|n
operator|->
name|bincl_status
operator|=
name|BINCL_PENDING
expr_stmt|;
name|n
operator|->
name|pending_bincl_name
operator|=
name|filename
expr_stmt|;
name|pending_bincls
operator|=
literal|1
expr_stmt|;
name|current_file
operator|=
name|n
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Revert to reading a previous source file.  Generate a N_EINCL stab.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_end_source_file
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
comment|/* Emit EINCL stab only if BINCL is not pending.  */
if|if
condition|(
name|current_file
operator|->
name|bincl_status
operator|==
name|BINCL_PROCESSED
condition|)
block|{
name|dbxout_begin_stabn
argument_list|(
name|N_EINCL
argument_list|)
expr_stmt|;
name|dbxout_stab_value_zero
argument_list|()
expr_stmt|;
block|}
name|current_file
operator|->
name|bincl_status
operator|=
name|BINCL_NOT_REQUIRED
expr_stmt|;
name|current_file
operator|=
name|current_file
operator|->
name|next
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Handle a few odd cases that occur when trying to make PCH files work.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_handle_pch
parameter_list|(
name|unsigned
name|at_end
parameter_list|)
block|{
if|if
condition|(
operator|!
name|at_end
condition|)
block|{
comment|/* When using the PCH, this file will be included, so we need to output 	 a BINCL.  */
name|dbxout_start_source_file
argument_list|(
literal|0
argument_list|,
name|lastfile
argument_list|)
expr_stmt|;
comment|/* The base file when using the PCH won't be the same as 	 the base file when it's being generated.  */
name|lastfile
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* ... and an EINCL.  */
name|dbxout_end_source_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Deal with cases where 'lastfile' was never actually changed.  */
name|lastfile_is_base
operator|=
name|lastfile
operator|==
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
end_if

begin_comment
comment|/* Output debugging info to FILE to switch to sourcefile FILENAME.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_source_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|lastfile
operator|==
literal|0
operator|&&
name|lastfile_is_base
condition|)
block|{
name|lastfile
operator|=
name|base_input_file
expr_stmt|;
name|lastfile_is_base
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|filename
operator|&&
operator|(
name|lastfile
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|filename
argument_list|,
name|lastfile
argument_list|)
operator|)
condition|)
block|{
comment|/* Don't change section amid function.  */
if|if
condition|(
name|current_function_decl
operator|==
name|NULL_TREE
condition|)
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
name|dbxout_begin_simple_stabs
argument_list|(
name|filename
argument_list|,
name|N_SOL
argument_list|)
expr_stmt|;
name|dbxout_stab_value_internal_label
argument_list|(
literal|"Ltext"
argument_list|,
operator|&
name|source_label_number
argument_list|)
expr_stmt|;
name|lastfile
operator|=
name|filename
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output N_BNSYM, line number symbol entry, and local symbol at     function scope  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_begin_prologue
parameter_list|(
name|unsigned
name|int
name|lineno
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
operator|!
name|NO_DBX_FUNCTION_END
operator|&&
operator|!
name|NO_DBX_BNSYM_ENSYM
operator|&&
operator|!
name|flag_debug_only_used_symbols
condition|)
name|dbxout_stabd
argument_list|(
name|N_BNSYM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* pre-increment the scope counter */
name|scope_labelno
operator|++
expr_stmt|;
name|dbxout_source_line
argument_list|(
name|lineno
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Output function begin block at function scope, referenced       by dbxout_block, dbxout_source_line and dbxout_function_end.  */
name|emit_pending_bincls_if_required
argument_list|()
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
literal|"LFBB"
argument_list|,
name|scope_labelno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a line number symbol entry for source file FILENAME and line    number LINENO.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_source_line
parameter_list|(
name|unsigned
name|int
name|lineno
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|dbxout_source_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_OUTPUT_SOURCE_LINE
name|DBX_OUTPUT_SOURCE_LINE
argument_list|(
name|asm_out_file
argument_list|,
name|lineno
argument_list|,
name|dbxout_source_line_counter
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|DBX_LINES_FUNCTION_RELATIVE
condition|)
block|{
name|char
name|begin_label
index|[
literal|20
index|]
decl_stmt|;
name|dbxout_begin_stabn_sline
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
comment|/* Reference current function start using LFBB.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|begin_label
argument_list|,
literal|"LFBB"
argument_list|,
name|scope_labelno
argument_list|)
expr_stmt|;
name|dbxout_stab_value_internal_label_diff
argument_list|(
literal|"LM"
argument_list|,
operator|&
name|dbxout_source_line_counter
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
block|}
else|else
name|dbxout_stabd
argument_list|(
name|N_SLINE
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Describe the beginning of an internal block within a function.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_begin_block
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|emit_pending_bincls_if_required
argument_list|()
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
literal|"LBB"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Describe the end line-number of an internal block within a function.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_end_block
parameter_list|(
name|unsigned
name|int
name|line
name|ATTRIBUTE_UNUSED
parameter_list|,
name|unsigned
name|int
name|n
parameter_list|)
block|{
name|emit_pending_bincls_if_required
argument_list|()
expr_stmt|;
name|targetm
operator|.
name|asm_out
operator|.
name|internal_label
argument_list|(
name|asm_out_file
argument_list|,
literal|"LBE"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output dbx data for a function definition.    This includes a definition of the function name itself (a symbol),    definitions of the parameters (locating them in the parameter list)    and then output the block that makes up the function's body    (including all the auto variables of the function).  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_function_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|emit_pending_bincls_if_required
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|DBX_FUNCTION_FIRST
name|dbxout_begin_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dbxout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_function_end
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO  */
end_comment

begin_comment
comment|/* Debug information for a global DECL.  Called from toplev.c after    compilation proper has finished.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_global_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|int
name|saved_tree_used
init|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
name|saved_tree_used
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is just a function-type adapter; dbxout_symbol does exactly    what we want but returns an int.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_decl
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
name|local
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* At the end of compilation, finish writing the symbol table.    The default is to call debug_free_queue but do nothing else.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_finish
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DBX_OUTPUT_MAIN_SOURCE_FILE_END
name|DBX_OUTPUT_MAIN_SOURCE_FILE_END
argument_list|(
name|asm_out_file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
name|DBX_OUTPUT_NULL_N_SO_AT_MAIN_SOURCE_FILE_END
block|{
name|switch_to_section
argument_list|(
name|text_section
argument_list|)
expr_stmt|;
name|dbxout_begin_empty_stabs
argument_list|(
name|N_SO
argument_list|)
expr_stmt|;
name|dbxout_stab_value_internal_label
argument_list|(
literal|"Letext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|debug_free_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the index of a type.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_index
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|DBX_USE_BINCL
name|stabstr_D
argument_list|(
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|struct
name|typeinfo
modifier|*
name|t
init|=
operator|&
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
decl_stmt|;
name|stabstr_C
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|t
operator|->
name|file_number
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|t
operator|->
name|type_number
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used in several places: evaluates to '0' for a private decl,    '1' for a protected decl, '2' for a public decl.  */
end_comment

begin_define
define|#
directive|define
name|DECL_ACCESSIBILITY_CHAR
parameter_list|(
name|DECL
parameter_list|)
define|\
value|(TREE_PRIVATE (DECL) ? '0' : TREE_PROTECTED (DECL) ? '1' : '2')
end_define

begin_comment
comment|/* Subroutine of `dbxout_type'.  Output the type fields of TYPE.    This must be a separate function because anonymous unions require    recursive calls.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_fields
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
comment|/* Output the name, type, position (in bits), size (in bits) of each      field that we can support.  */
for|for
control|(
name|tem
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
block|{
comment|/* If one of the nodes is an error_mark or its type is then 	 return early.  */
if|if
condition|(
name|tem
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Omit here local type decls until we know how to support them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|TYPE_DECL
comment|/* Omit here the nameless fields that are used to skip bits.  */
operator|||
name|DECL_IGNORED_P
argument_list|(
name|tem
argument_list|)
comment|/* Omit fields whose position or size are variable or too large to 	     represent.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
operator|!
name|host_integerp
argument_list|(
name|bit_position
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|CONST_DECL
condition|)
block|{
comment|/* Continue the line if necessary, 	     but not before the first field.  */
if|if
condition|(
name|tem
operator|!=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
condition|)
name|CONTIN
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
condition|)
name|stabstr_I
argument_list|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
operator|(
name|TREE_PRIVATE
argument_list|(
name|tem
argument_list|)
operator|||
name|TREE_PROTECTED
argument_list|(
name|tem
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|FIELD_DECL
operator|)
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
name|DECL_ACCESSIBILITY_CHAR
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|tem
argument_list|)
operator|)
condition|?
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|tem
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|tem
argument_list|)
operator|&&
name|use_gnu_debug_info_extensions
condition|)
block|{
name|tree
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|tem
argument_list|)
decl_stmt|;
name|stabstr_C
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|stabstr_I
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* If TEM is non-static, GDB won't understand it.  */
name|stabstr_S
argument_list|(
literal|",0,0;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|int_bit_position
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `dbxout_type_methods'.  Output debug info about the    method described DECL.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_method_1
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|char
name|c1
init|=
literal|'A'
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|c2
operator|=
literal|'?'
expr_stmt|;
else|else
comment|/* it's a METHOD_TYPE.  */
block|{
name|tree
name|firstarg
init|=
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* A for normal functions. 	 B for `const' member functions. 	 C for `volatile' member functions. 	 D for `const volatile' member functions.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
condition|)
name|c1
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
condition|)
name|c1
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|c2
operator|=
literal|'*'
expr_stmt|;
else|else
name|c2
operator|=
literal|'.'
expr_stmt|;
block|}
comment|/* ??? Output the mangled name, which contains an encoding of the      method's type signature.  May not be necessary anymore.  */
name|stabstr_C
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|stabstr_I
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
name|DECL_ACCESSIBILITY_CHAR
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|stabstr_D
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `dbxout_type'.  Output debug info about the methods defined    in TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_methods
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* C++: put out the method names and their parameter lists */
name|tree
name|methods
init|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
name|tree
name|last
decl_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL_TREE
condition|)
return|return;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|methods
argument_list|)
operator|!=
name|TREE_VEC
condition|)
name|fndecl
operator|=
name|methods
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|fndecl
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fndecl
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|fndecl
condition|)
block|{
name|int
name|need_prefix
init|=
literal|1
decl_stmt|;
comment|/* Group together all the methods for the same operation. 	 These differ in the types of the arguments.  */
for|for
control|(
name|last
operator|=
name|NULL_TREE
init|;
name|fndecl
operator|&&
operator|(
name|last
operator|==
name|NULL_TREE
operator|||
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|last
argument_list|)
operator|)
condition|;
name|fndecl
operator|=
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
control|)
comment|/* Output the name of the field (after overloading), as 	   well as the name of the field before overloading, along 	   with its parameter list */
block|{
comment|/* Skip methods that aren't FUNCTION_DECLs.  (In C++, these 	     include TEMPLATE_DECLs.)  The debugger doesn't know what 	     to do with such entities anyhow.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fndecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
continue|continue;
name|CONTIN
expr_stmt|;
name|last
operator|=
name|fndecl
expr_stmt|;
comment|/* Also ignore abstract methods; those are only interesting to 	     the DWARF backends.  */
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|fndecl
argument_list|)
operator|||
name|DECL_ABSTRACT
argument_list|(
name|fndecl
argument_list|)
condition|)
continue|continue;
comment|/* Redundantly output the plain name, since that's what gdb 	     expects.  */
if|if
condition|(
name|need_prefix
condition|)
block|{
name|stabstr_I
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
name|need_prefix
operator|=
literal|0
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_type_method_1
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_prefix
condition|)
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Emit a "range" type specification, which has the form:    "r<index type>;<lower bound>;<upper bound>;".    TYPE is an INTEGER_TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_range_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|stabstr_C
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* E.g. Pascal's ARRAY [BOOLEAN] of INTEGER */
else|else
block|{
comment|/* Traditionally, we made sure 'int' was type 1, and builtin types 	 were defined to be sub-ranges of int.  Unfortunately, this 	 does not allow us to distinguish true sub-ranges from integer 	 types.  So, instead we define integer (non-sub-range) types as 	 sub-ranges of themselves.  This matters for Chill.  If this isn't 	 a subrange type, then we want to define it in terms of itself. 	 However, in C, this may be an anonymous integer type, and we don't 	 want to emit debug info referring to it.  Just calling 	 dbxout_type_index won't work anyways, because the type hasn't been 	 defined yet.  We make this work for both cases by checked to see 	 whether this is a defined type, referring to it if it is, and using 	 'int' otherwise.  */
if|if
condition|(
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|dbxout_type_index
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|dbxout_type_index
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
block|}
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|print_int_cst_bounds_in_octal_p
argument_list|(
name|type
argument_list|)
condition|)
name|stabstr_O
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|stabstr_D
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|stabstr_C
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|print_int_cst_bounds_in_octal_p
argument_list|(
name|type
argument_list|)
condition|)
name|stabstr_O
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|stabstr_D
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
else|else
name|stabstr_S
argument_list|(
literal|"-1;"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a reference to a type.  If the type has not yet been    described in the dbx output, output its definition now.    For a type already defined, just refer to its definition    using the type number.     If FULL is nonzero, and the type has been described only with    a forward-reference, output the definition now.    If FULL is zero in this case, just refer to the forward-reference    using the number previously allocated.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|tree
name|tem
decl_stmt|;
name|tree
name|main_variant
decl_stmt|;
specifier|static
name|int
name|anonymous_type_number
init|=
literal|0
decl_stmt|;
name|bool
name|vector_type
init|=
name|false
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
block|{
comment|/* The frontend feeds us a representation for the vector as a struct 	 containing an array.  Pull out the array type.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|TYPE_DEBUG_REPRESENTATION_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|vector_type
operator|=
name|true
expr_stmt|;
block|}
comment|/* If there was an input error and we don't really have a type,      avoid crashing and write something that is at least valid      by assuming `int'.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|full
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Try to find the "main variant" with the same name.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|main_variant
operator|=
name|TREE_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|main_variant
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If we are not using extensions, stabs does not distinguish const and      volatile, so there is no need to make them separate types.  */
if|if
condition|(
operator|!
name|use_gnu_debug_info_extensions
condition|)
name|type
operator|=
name|main_variant
expr_stmt|;
if|if
condition|(
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Type has no dbx number assigned.  Assign next available number.  */
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
operator|=
name|next_type_number
operator|++
expr_stmt|;
comment|/* Make sure type vector is long enough to record about this type.  */
if|if
condition|(
name|next_type_number
operator|==
name|typevec_len
condition|)
block|{
name|typevec
operator|=
name|ggc_realloc
argument_list|(
name|typevec
argument_list|,
operator|(
name|typevec_len
operator|*
literal|2
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|typevec
operator|+
name|typevec_len
argument_list|,
literal|0
argument_list|,
name|typevec_len
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|typevec_len
operator|*=
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DBX_USE_BINCL
name|emit_pending_bincls_if_required
argument_list|()
expr_stmt|;
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|file_number
operator|=
name|current_file
operator|->
name|file_number
expr_stmt|;
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|type_number
operator|=
name|current_file
operator|->
name|next_type_number
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|flag_debug_only_used_symbols
condition|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_P
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|debug_queue_symbol
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|debug_queue_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Output the number of this type, to refer to it.  */
name|dbxout_type_index
argument_list|(
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_TYPE_DEFINED
if|if
condition|(
name|DBX_TYPE_DEFINED
argument_list|(
name|type
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* If this type's definition has been output or is now being output,      that is all.  */
switch|switch
condition|(
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|status
condition|)
block|{
case|case
name|TYPE_UNSEEN
case|:
break|break;
case|case
name|TYPE_XREF
case|:
comment|/* If we have already had a cross reference, 	 and either that's all we want or that's the best we could do, 	 don't repeat the cross reference. 	 Sun dbx crashes if we do.  */
if|if
condition|(
operator|!
name|full
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
comment|/* No way in DBX fmt to describe a variable size.  */
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
break|break;
case|case
name|TYPE_DEFINED
case|:
return|return;
block|}
ifdef|#
directive|ifdef
name|DBX_NO_XREFS
comment|/* For systems where dbx output does not allow the `=xsNAME:' syntax,      leave the type-number completely undefined rather than output      a cross-reference.  If we have already used GNU debug info extensions,      then it is OK to output a cross reference.  This is necessary to get      proper C++ debug output.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|!
name|use_gnu_debug_info_extensions
condition|)
comment|/* We must use the same test here as we use twice below when deciding        whether to emit a cross-reference.  */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|full
operator|)
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
comment|/* No way in DBX fmt to describe a variable size.  */
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|status
operator|=
name|TYPE_XREF
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Output a definition now.  */
name|stabstr_C
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
comment|/* Mark it as defined, so that if it is self-referent      we will not get into an infinite recursion of definitions.  */
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|status
operator|=
name|TYPE_DEFINED
expr_stmt|;
comment|/* If this type is a variant of some other, hand off.  Types with      different names are usefully distinguished.  We only distinguish      cv-qualified types if we're using extensions.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_READONLY
argument_list|(
name|main_variant
argument_list|)
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'k'
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|build_type_variant
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_VOLATILE
argument_list|(
name|main_variant
argument_list|)
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'B'
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|main_variant
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag_debug_only_used_symbols
condition|)
block|{
name|tree
name|orig_type
init|=
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|orig_type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|orig_type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|orig_type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|orig_type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_STUB_DECL
argument_list|(
name|orig_type
argument_list|)
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|orig_type
argument_list|)
argument_list|)
condition|)
name|debug_queue_symbol
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|orig_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 'type' is a typedef; output the type it refers to.  */
name|dbxout_type
argument_list|(
name|DECL_ORIGINAL_TYPE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* else continue.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|LANG_TYPE
case|:
comment|/* APPLE LOCAL blocks 6034272 */
case|case
name|BLOCK_POINTER_TYPE
case|:
comment|/* For a void type, just define it as itself; i.e., "5=5". 	 This makes us consider it defined 	 without saying what it is.  The debugger will make it 	 a void type when the reference is seen, and nothing will 	 ever override that default.  */
name|dbxout_type_index
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|type
operator|==
name|char_type_node
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Output the type `char' as a subrange of itself! 	     I don't understand this definition, just copied it 	     from the output of pcc. 	     This used to use `r2' explicitly and we used to 	     take care to make sure that `char' was type number 2.  */
name|stabstr_C
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
name|dbxout_type_index
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|";0;127;"
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a subtype of another integer type, always prefer to 	 write it as a subtype.  */
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
comment|/* If the size is non-standard, say what it is if we can use 	     GDB extensions.  */
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
name|stabstr_S
argument_list|(
literal|"@s"
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
name|dbxout_range_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If the size is non-standard, say what it is if we can use 	     GDB extensions.  */
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
name|stabstr_S
argument_list|(
literal|"@s"
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_int_cst_bounds_in_octal_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
comment|/* If this type derives from another type, output type index of 		 parent type. This is particularly important when parent type 		 is an enumerated type, because not generating the parent type 		 index would transform the definition of this enumerated type 		 into a plain unsigned type.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|dbxout_type_index
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dbxout_type_index
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|stabstr_O
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|stabstr_O
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Output other integer types as subranges of `int'.  */
name|dbxout_range_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REAL_TYPE
case|:
comment|/* This used to say `r1' and we used to take care 	 to make sure that `int' was type number 1.  */
name|stabstr_C
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
name|dbxout_type_index
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|";0;"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOOLEAN_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|stabstr_S
argument_list|(
literal|"@s"
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|BITS_PER_UNIT
operator|*
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|";-16;"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Define as enumeral type (False, True) */
name|stabstr_S
argument_list|(
literal|"eFalse:0,True:1,;"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
comment|/* Differs from the REAL_TYPE by its new data type number. 	 R3 is NF_COMPLEX.  We don't try to use any of the other NF_* 	 codes since gdb doesn't care anyway.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
name|stabstr_S
argument_list|(
literal|"R3;"
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
literal|2
operator|*
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|";0;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output a complex integer type as a structure, 	     pending some other way to do it.  */
name|stabstr_C
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|"real:"
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|",0,"
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|";imag:"
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|";;"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Make arrays of packed bits look like bitstrings for chill.  */
if|if
condition|(
name|TYPE_PACKED
argument_list|(
name|type
argument_list|)
operator|&&
name|use_gnu_debug_info_extensions
condition|)
block|{
name|stabstr_S
argument_list|(
literal|"@s"
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|BITS_PER_UNIT
operator|*
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|";@S;S"
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|vector_type
condition|)
name|stabstr_S
argument_list|(
literal|"@V;"
argument_list|)
expr_stmt|;
comment|/* Output "a" followed by a range type definition 	 for the index type of the array 	 followed by a reference to the target-type. 	 ar1;0;N;M for a C array of type M and size N+1.  */
comment|/* Check if a character string type, which in Chill is 	 different from an array of characters.  */
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
operator|&&
name|use_gnu_debug_info_extensions
condition|)
block|{
name|stabstr_S
argument_list|(
literal|"@S;"
argument_list|)
expr_stmt|;
block|}
name|tem
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
name|NULL
condition|)
block|{
name|stabstr_S
argument_list|(
literal|"ar"
argument_list|)
expr_stmt|;
name|dbxout_type_index
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|";0;-1;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stabstr_C
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
name|dbxout_range_type
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|tree
name|binfo
init|=
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* Output a structure type.  We must use the same test here as we 	   use in the DBX_NO_XREFS case above.  */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|full
operator|)
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
comment|/* No way in DBX fmt to describe a variable size.  */
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* If the type is just a cross reference, output one 	       and mark the type as partially described. 	       If it later becomes defined, we will output 	       its real definition. 	       If the type has a name, don't nest its definition within 	       another type's definition; instead, output an xref 	       and let the definition come when the name is defined.  */
name|stabstr_S
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|?
literal|"xs"
else|:
literal|"xu"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|dbxout_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|stabstr_S
argument_list|(
literal|"$$"
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|anonymous_type_number
operator|++
argument_list|)
expr_stmt|;
block|}
name|stabstr_C
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|status
operator|=
name|TYPE_XREF
expr_stmt|;
break|break;
block|}
comment|/* Identify record or union, and print its size.  */
name|stabstr_C
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|?
literal|'s'
else|:
literal|'u'
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|binfo
condition|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|child
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|gc
argument_list|)
operator|*
name|accesses
operator|=
name|BINFO_BASE_ACCESSES
argument_list|(
name|binfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
if|if
condition|(
name|BINFO_N_BASE_BINFOS
argument_list|(
name|binfo
argument_list|)
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
name|stabstr_U
argument_list|(
name|BINFO_N_BASE_BINFOS
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|BINFO_BASE_ITERATE
argument_list|(
name|binfo
argument_list|,
name|i
argument_list|,
name|child
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|access
init|=
operator|(
name|accesses
condition|?
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|accesses
argument_list|,
name|i
argument_list|)
else|:
name|access_public_node
operator|)
decl_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|stabstr_C
argument_list|(
name|BINFO_VIRTUAL_P
argument_list|(
name|child
argument_list|)
condition|?
literal|'1'
else|:
literal|'0'
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
name|access
operator|==
name|access_public_node
condition|?
literal|'2'
else|:
name|access
operator|==
name|access_protected_node
condition|?
literal|'1'
else|:
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|BINFO_VIRTUAL_P
argument_list|(
name|child
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C++"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU Objective-C++"
argument_list|)
operator|==
literal|0
operator|)
condition|)
comment|/* For a virtual base, print the (negative) 		     	 offset within the vtable where we must look 		     	 to find the necessary adjustment.  */
name|stabstr_D
argument_list|(
name|tree_low_cst
argument_list|(
name|BINFO_VPTR_FIELD
argument_list|(
name|child
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|stabstr_D
argument_list|(
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|child
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Print out the base class information with 		       fields which have the same names at the types 		       they hold.  */
name|dbxout_type_name
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|,
name|full
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|tree_low_cst
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|child
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|tree_low_cst
argument_list|(
name|TYPE_SIZE
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Write out the field declarations.  */
name|dbxout_type_fields
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|dbxout_type_methods
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
comment|/* Avoid the ~ if we don't really need it--it confuses dbx.  */
operator|&&
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* We need to write out info about what field this class 	     uses as its "main" vtable pointer field, because if this 	     field is inherited from a base class, GDB cannot necessarily 	     figure out which field it's using in time.  */
name|stabstr_S
argument_list|(
literal|"~%"
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|DECL_FCONTEXT
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENUMERAL_TYPE
case|:
comment|/* We must use the same test here as we use in the DBX_NO_XREFS case 	 above.  We simplify it a bit since an enum will never have a variable 	 size.  */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|full
operator|)
operator|||
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|stabstr_S
argument_list|(
literal|"xe"
argument_list|)
expr_stmt|;
name|dbxout_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|.
name|status
operator|=
name|TYPE_XREF
expr_stmt|;
name|stabstr_C
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
block|{
name|stabstr_S
argument_list|(
literal|"@s"
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
name|stabstr_C
argument_list|(
literal|'e'
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
block|{
name|stabstr_I
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|stabstr_D
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|&&
operator|(
name|HOST_WIDE_INT
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|stabstr_D
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|stabstr_O
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|CONTIN
expr_stmt|;
block|}
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
break|break;
case|case
name|POINTER_TYPE
case|:
name|stabstr_C
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
comment|/* Write the argument types out longhand.  */
name|dbxout_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_args
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Treat it as a function type.  */
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Should print as an int, because it is really just an offset.  */
name|dbxout_type
argument_list|(
name|integer_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
block|}
else|else
name|stabstr_C
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|stabstr_C
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if the given type represents an integer whose bounds    should be printed in octal format.  */
end_comment

begin_function
specifier|static
name|bool
name|print_int_cst_bounds_in_octal_p
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
comment|/* If we can use GDB extensions and the size is wider than a long      (the size used by GDB to read them) or we may have trouble writing      the bounds the usual way, write them in octal.  Note the test is for      the *target's* size of "long", not that of the host.  The host test      is just to make sure we can write it out in case the host wide int      is narrower than the target "long".       For unsigned types, we use octal if they are the same size or larger.      This is because we print the bounds as signed decimal, and hence they      can't span same size unsigned types.  */
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|||
operator|(
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
operator|)
condition|)
return|return
name|TRUE
return|;
else|else
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Output the name of type TYPE, with no punctuation.    Such names can be set up either by typedef declarations    or by struct, enum and union tags.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_name
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|t
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|IDENTIFIER_NODE
case|:
break|break;
case|case
name|TYPE_DECL
case|:
name|t
operator|=
name|DECL_NAME
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|stabstr_I
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output leading leading struct or class names needed for qualifying    type whose scope is limited to a struct or class.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_class_name_qualifiers
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|context
init|=
name|decl_type_context
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|context
argument_list|)
operator|==
name|RECORD_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|dbxout_class_name_qualifiers
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|stabstr_I
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|"::"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is a specialized subset of expand_expr for use by dbxout_symbol in    evaluating DECL_VALUE_EXPR.  In particular, we stop if we find decls that    havn't been expanded, or if the expression is getting so complex we won't    be able to represent it in stabs anyway.  Returns NULL on failure.  */
end_comment

begin_function
specifier|static
name|rtx
name|dbxout_expand_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
if|if
condition|(
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|dbxout_expand_expr
argument_list|(
name|DECL_VALUE_EXPR
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
comment|/* FALLTHRU */
case|case
name|CONST_DECL
case|:
case|case
name|RESULT_DECL
case|:
return|return
name|DECL_RTL_IF_SET
argument_list|(
name|expr
argument_list|)
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|expand_expr
argument_list|(
name|expr
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_INITIALIZER
argument_list|)
return|;
case|case
name|COMPONENT_REF
case|:
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|BIT_FIELD_REF
case|:
block|{
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|HOST_WIDE_INT
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|tree
name|offset
decl_stmt|,
name|tem
decl_stmt|;
name|int
name|volatilep
init|=
literal|0
decl_stmt|,
name|unsignedp
init|=
literal|0
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|tem
operator|=
name|get_inner_reference
argument_list|(
name|expr
argument_list|,
operator|&
name|bitsize
argument_list|,
operator|&
name|bitpos
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|mode
argument_list|,
operator|&
name|unsignedp
argument_list|,
operator|&
name|volatilep
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|x
operator|=
name|dbxout_expand_expr
argument_list|(
name|tem
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
operator|||
operator|!
name|MEM_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|offset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NULL
return|;
name|x
operator|=
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|tree_low_cst
argument_list|(
name|offset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bitpos
operator|!=
literal|0
condition|)
name|x
operator|=
name|adjust_address_nv
argument_list|(
name|x
argument_list|,
name|mode
argument_list|,
name|bitpos
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
default|default:
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function for output_used_types.  Queue one entry from the    used types hash to be output.  */
end_comment

begin_function
specifier|static
name|int
name|output_used_types_helper
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|type
init|=
operator|*
name|slot
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|types_p
operator|=
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|&&
name|DECL_P
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
operator|*
name|types_p
argument_list|,
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|VEC_quick_push
argument_list|(
name|tree
argument_list|,
operator|*
name|types_p
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This is a qsort callback which sorts types and declarations into a    predictable order (types, then declarations, sorted by UID    within).  */
end_comment

begin_function
specifier|static
name|int
name|output_types_sort
parameter_list|(
specifier|const
name|void
modifier|*
name|pa
parameter_list|,
specifier|const
name|void
modifier|*
name|pb
parameter_list|)
block|{
specifier|const
name|tree
name|lhs
init|=
operator|*
operator|(
operator|(
specifier|const
name|tree
operator|*
operator|)
name|pa
operator|)
decl_stmt|;
specifier|const
name|tree
name|rhs
init|=
operator|*
operator|(
operator|(
specifier|const
name|tree
operator|*
operator|)
name|pb
operator|)
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
name|lhs
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
name|TYPE_UID
argument_list|(
name|lhs
argument_list|)
operator|-
name|TYPE_UID
argument_list|(
name|rhs
argument_list|)
return|;
else|else
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
name|rhs
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
name|DECL_UID
argument_list|(
name|lhs
argument_list|)
operator|-
name|DECL_UID
argument_list|(
name|rhs
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Force all types used by this function to be output in debug    information.  */
end_comment

begin_function
specifier|static
name|void
name|output_used_types
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cfun
operator|&&
name|cfun
operator|->
name|used_types_hash
condition|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|types
expr_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|types
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|htab_elements
argument_list|(
name|cfun
operator|->
name|used_types_hash
argument_list|)
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|cfun
operator|->
name|used_types_hash
argument_list|,
name|output_used_types_helper
argument_list|,
operator|&
name|types
argument_list|)
expr_stmt|;
comment|/* Sort by UID to prevent dependence on hash table ordering.  */
name|qsort
argument_list|(
name|VEC_address
argument_list|(
name|tree
argument_list|,
name|types
argument_list|)
argument_list|,
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|types
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|output_types_sort
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
name|types
argument_list|,
name|i
argument_list|,
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
name|debug_queue_symbol
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a .stabs for the symbol defined by DECL,    which must be a ..._DECL node in the normal namespace.    It may be a CONST_DECL, a FUNCTION_DECL, a PARM_DECL or a VAR_DECL.    LOCAL is nonzero if the scope is less than the entire file.    Return 1 if a stabs might have been emitted.  */
end_comment

begin_function
name|int
name|dbxout_symbol
parameter_list|(
name|tree
name|decl
parameter_list|,
name|int
name|local
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|rtx
name|decl_rtl
decl_stmt|;
comment|/* "Intercept" dbxout_symbol() calls like we do all debug_hooks.  */
operator|++
name|debug_nesting
expr_stmt|;
comment|/* Ignore nameless syms, but don't ignore type tags.  */
if|if
condition|(
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
operator|||
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
name|DBXOUT_DECR_NESTING_AND_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If we are to generate only the symbols actually used then such      symbol nodes are flagged with TREE_USED.  Ignore any that      aren't flaged as TREE_USED.  */
if|if
condition|(
name|flag_debug_only_used_symbols
operator|&&
operator|(
operator|!
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
operator|!
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|)
condition|)
name|DBXOUT_DECR_NESTING_AND_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If dbxout_init has not yet run, queue this symbol for later.  */
if|if
condition|(
operator|!
name|typevec
condition|)
block|{
name|preinit_symbols
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|decl
argument_list|,
name|preinit_symbols
argument_list|)
expr_stmt|;
name|DBXOUT_DECR_NESTING_AND_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_debug_only_used_symbols
condition|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* We now have a used symbol.  We need to generate the info for          the symbol's type in addition to the symbol itself.  These          type symbols are queued to be generated after were done with          the symbol itself (otherwise they would fight over the          stabstr obstack).           Note, because the TREE_TYPE(type) might be something like a          pointer to a named type we need to look for the first name          we see following the TREE_TYPE chain.  */
name|t
operator|=
name|type
expr_stmt|;
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, and ENUMERAL_TYPE          need special treatment.  The TYPE_STUB_DECL field in these          types generally represents the tag name type we want to          output.  In addition there  could be a typedef type with          a different name.  In that case we also want to output          that.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
if|if
condition|(
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
operator|!=
name|decl
operator|&&
name|DECL_P
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
operator|&&
operator|!
name|DECL_IGNORED_P
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
block|{
name|debug_queue_symbol
argument_list|(
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_STUB_DECL
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|!=
name|decl
operator|&&
name|DECL_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|debug_queue_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|!=
name|decl
operator|&&
name|DECL_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
name|debug_queue_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|emit_pending_bincls_if_required
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|CONST_DECL
case|:
comment|/* Enum values are defined by defining the enum type.  */
break|break;
case|case
name|FUNCTION_DECL
case|:
name|decl_rtl
operator|=
name|DECL_RTL_IF_SET
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl_rtl
condition|)
name|DBXOUT_DECR_NESTING_AND_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
comment|/* Don't mention a nested function under its parent.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|current_function_decl
condition|)
break|break;
comment|/* Don't mention an inline instance of a nested function.  */
if|if
condition|(
name|context
operator|&&
name|DECL_FROM_INLINE
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|MEM_P
argument_list|(
name|decl_rtl
argument_list|)
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
break|break;
if|if
condition|(
name|flag_debug_only_used_symbols
condition|)
name|output_used_types
argument_list|()
expr_stmt|;
name|dbxout_begin_complex_stabs
argument_list|()
expr_stmt|;
name|stabstr_I
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|?
literal|":F"
else|:
literal|":f"
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dbxout_type
argument_list|(
name|void_type_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For a nested function, when that function is compiled, 	 mention the containing function name 	 as well as (since dbx wants it) our own assembler-name.  */
if|if
condition|(
name|context
operator|!=
literal|0
condition|)
block|{
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|stabstr_I
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|stabstr_I
argument_list|(
name|DECL_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dbxout_finish_complex_stabs
argument_list|(
name|decl
argument_list|,
name|N_FUN
argument_list|,
name|XEXP
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
comment|/* Don't output the same typedef twice.          And don't output what language-specific stuff doesn't want output.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|||
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
condition|)
name|DBXOUT_DECR_NESTING_AND_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't output typedefs for types with magic type numbers (XCOFF).  */
ifdef|#
directive|ifdef
name|DBX_ASSIGN_FUNDAMENTAL_TYPE_NUMBER
block|{
name|int
name|fundamental_type_number
init|=
name|DBX_ASSIGN_FUNDAMENTAL_TYPE_NUMBER
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|fundamental_type_number
operator|!=
literal|0
condition|)
block|{
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|fundamental_type_number
expr_stmt|;
name|DBXOUT_DECR_NESTING_AND_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|FORCE_TEXT
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|{
name|int
name|tag_needed
init|=
literal|1
decl_stmt|;
name|int
name|did_output
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Nonzero means we must output a tag as well as a typedef.  */
name|tag_needed
operator|=
literal|0
expr_stmt|;
comment|/* Handle the case of a C++ structure or union 	       where the TYPE_NAME is a TYPE_DECL 	       which gives both a typedef name and a tag.  */
comment|/* dbx requires the tag first and the typedef second.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|decl
operator|&&
operator|!
name|use_gnu_debug_info_extensions
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
comment|/* Distinguish the implicit typedefs of C++ 		   from explicit ones that might be found in C.  */
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
comment|/* Do not generate a tag for incomplete records.  */
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
comment|/* Do not generate a tag for records of variable size, 		   since this type can not be properly described in the 		   DBX format, and it confuses some tools such as objdump.  */
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dbxout_begin_complex_stabs
argument_list|()
expr_stmt|;
name|stabstr_I
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|":T"
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbxout_finish_complex_stabs
argument_list|(
literal|0
argument_list|,
name|DBX_TYPE_DECL_STABS_CODE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dbxout_begin_complex_stabs
argument_list|()
expr_stmt|;
comment|/* Output leading class/struct qualifiers.  */
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
name|dbxout_class_name_qualifiers
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* Output typedef name.  */
name|stabstr_I
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
comment|/* Short cut way to output a tag also.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|decl
comment|/* Distinguish the implicit typedefs of C++ 		   from explicit ones that might be found in C.  */
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|stabstr_C
argument_list|(
literal|'T'
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|stabstr_C
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbxout_finish_complex_stabs
argument_list|(
name|decl
argument_list|,
name|DBX_TYPE_DECL_STABS_CODE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Don't output a tag if this is an incomplete type.  This prevents 	   the sun4 Sun OS 4.x dbx from crashing.  */
if|if
condition|(
name|tag_needed
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* For a TYPE_DECL with no name, but the type has a name, 	       output a tag. 	       This is what represents `struct foo' with no typedef.  */
comment|/* In C++, the name of a type is the corresponding typedef. 	       In C, it is an IDENTIFIER_NODE.  */
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|dbxout_begin_complex_stabs
argument_list|()
expr_stmt|;
name|stabstr_I
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|":T"
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbxout_finish_complex_stabs
argument_list|(
literal|0
argument_list|,
name|DBX_TYPE_DECL_STABS_CODE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If an enum type has no name, it cannot be referred to, but 	   we must output it anyway, to record the enumeration 	   constants.  */
if|if
condition|(
operator|!
name|did_output
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|dbxout_begin_complex_stabs
argument_list|()
expr_stmt|;
comment|/* Some debuggers fail when given NULL names, so give this a 	       harmless name of " " (Why not "(anon)"?).  */
name|stabstr_S
argument_list|(
literal|" :T"
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbxout_finish_complex_stabs
argument_list|(
literal|0
argument_list|,
name|DBX_TYPE_DECL_STABS_CODE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Prevent duplicate output of a typedef.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|PARM_DECL
case|:
comment|/* Parm decls go in their own separate chains 	 and are output by dbxout_reg_parms and dbxout_parms.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|RESULT_DECL
case|:
case|case
name|VAR_DECL
case|:
comment|/* Don't mention a variable that is external. 	 Let the file that defines it describe it.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
comment|/* If the variable is really a constant 	 and not written in memory, inform the debugger.  	 ??? Why do we skip emitting the type and location in this case?  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|host_integerp
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BLOCK
operator|||
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The sun4 assembler does not grok this.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|ival
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|dbxout_begin_complex_stabs
argument_list|()
expr_stmt|;
name|dbxout_symbol_name
argument_list|(
name|decl
argument_list|,
name|NULL
argument_list|,
literal|'c'
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|"=i"
argument_list|)
expr_stmt|;
name|stabstr_D
argument_list|(
name|ival
argument_list|)
expr_stmt|;
name|dbxout_finish_complex_stabs
argument_list|(
literal|0
argument_list|,
name|N_LSYM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DBXOUT_DECR_NESTING
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
break|break;
block|}
comment|/* else it is something we handle like a normal variable.  */
name|decl_rtl
operator|=
name|dbxout_expand_expr
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl_rtl
condition|)
name|DBXOUT_DECR_NESTING_AND_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|decl_rtl
operator|=
name|eliminate_regs
argument_list|(
name|decl_rtl
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|decl_rtl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|result
operator|=
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|decl_rtl
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|DBXOUT_DECR_NESTING
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the stab for DECL, a VAR_DECL, RESULT_DECL or PARM_DECL.    Add SUFFIX to its name, if SUFFIX is not 0.    Describe the variable as residing in HOME    (usually HOME is DECL_RTL (DECL), but not always).    Returns 1 if the stab was really emitted.  */
end_comment

begin_function
specifier|static
name|int
name|dbxout_symbol_location
parameter_list|(
name|tree
name|decl
parameter_list|,
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|rtx
name|home
parameter_list|)
block|{
name|int
name|letter
init|=
literal|0
decl_stmt|;
name|STAB_CODE_TYPE
name|code
decl_stmt|;
name|rtx
name|addr
init|=
literal|0
decl_stmt|;
name|int
name|number
init|=
literal|0
decl_stmt|;
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Don't mention a variable at all      if it was completely optimized into nothingness.       If the decl was from an inline function, then its rtl      is not identically the rtl that was used in this      particular compilation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|value
init|=
name|home
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
condition|)
name|value
operator|=
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|value
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
name|home
operator|=
name|alter_subreg
argument_list|(
operator|&
name|home
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|REG_P
argument_list|(
name|home
argument_list|)
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|home
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
block|}
comment|/* The kind-of-variable letter depends on where      the variable is and on the scope of its name:      G and N_GSYM for static storage and global scope,      S for static storage and file scope,      V for static storage and local scope,      for those two, use N_LCSYM if data is in bss segment,      N_STSYM if in data segment, N_FUN otherwise.      (We used N_FUN originally, then changed to N_STSYM      to please GDB.  However, it seems that confused ld.      Now GDB has been fixed to like N_FUN, says Kingdon.)      no letter at all, and N_LSYM, for auto variable,      r and N_RSYM for register variable.  */
if|if
condition|(
name|MEM_P
argument_list|(
name|home
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|letter
operator|=
literal|'G'
expr_stmt|;
name|code
operator|=
name|N_GSYM
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|letter
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|?
literal|'V'
else|:
literal|'S'
expr_stmt|;
comment|/* Some ports can transform a symbol ref into a label ref, 	     because the symbol ref is too far away and has to be 	     dumped into a constant pool.  Alternatively, the symbol 	     in the constant pool might be referenced by a different 	     symbol.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|SYMBOL_REF
operator|&&
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|bool
name|marked
decl_stmt|;
name|rtx
name|tmp
init|=
name|get_pool_constant_mark
argument_list|(
name|addr
argument_list|,
operator|&
name|marked
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
name|addr
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|addr
argument_list|)
condition|)
name|get_pool_constant_mark
argument_list|(
name|addr
argument_list|,
operator|&
name|marked
argument_list|)
expr_stmt|;
else|else
name|marked
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|tmp
argument_list|)
operator|==
name|LABEL_REF
condition|)
block|{
name|addr
operator|=
name|tmp
expr_stmt|;
name|marked
operator|=
name|true
expr_stmt|;
block|}
comment|/* If all references to the constant pool were optimized 		 out, we just ignore the symbol.  */
if|if
condition|(
operator|!
name|marked
condition|)
return|return
literal|0
return|;
block|}
comment|/* This should be the same condition as in assemble_variable, but 	     we don't have access to dont_output_data here.  So, instead, 	     we rely on the fact that error_mark_node initializers always 	     end up in bss for C++ and never end up in bss for C.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|lang_hooks
operator|.
name|name
argument_list|,
literal|"GNU C++"
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
name|code
operator|=
name|N_LCSYM
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_IN_TEXT_SECTION
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* This is not quite right, but it's the closest 	       of all the codes that Unix defines.  */
name|code
operator|=
name|DBX_STATIC_CONST_VAR_CODE
expr_stmt|;
else|else
block|{
comment|/* Ultrix `as' seems to need this.  */
ifdef|#
directive|ifdef
name|DBX_STATIC_STAB_DATA_SECTION
name|switch_to_section
argument_list|(
name|data_section
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|code
operator|=
name|N_STSYM
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|letter
operator|=
literal|'r'
expr_stmt|;
name|code
operator|=
name|N_RSYM
expr_stmt|;
name|number
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|home
argument_list|)
operator|&&
operator|(
name|MEM_P
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
operator|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ARG_POINTER_REGNUM
endif|#
directive|endif
operator|)
operator|)
condition|)
comment|/* If the value is indirect by memory or by a register        that isn't the frame pointer        then it means the object is variable-sized and address through        that register or stack slot.  DBX has no way to represent this        so all we can do is output the variable as a pointer.        If it's not a parameter, ignore it.  */
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|letter
operator|=
literal|'r'
expr_stmt|;
name|code
operator|=
name|N_RSYM
expr_stmt|;
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
literal|0
return|;
name|number
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
name|N_LSYM
expr_stmt|;
comment|/* RTL looks like (MEM (MEM (PLUS (REG...) (CONST_INT...)))). 	     We want the value of that CONST_INT.  */
name|number
operator|=
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Effectively do build_pointer_type, but don't cache this type, 	 since it might be temporary whereas the type it points to 	 might have been saved for inlining.  */
comment|/* Don't use REFERENCE_TYPE because dbx can't handle that.  */
name|type
operator|=
name|make_node
argument_list|(
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|home
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|code
operator|=
name|N_LSYM
expr_stmt|;
name|number
operator|=
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|home
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|code
operator|=
name|N_LSYM
expr_stmt|;
comment|/* RTL looks like (MEM (PLUS (REG...) (CONST_INT...))) 	 We want the value of that CONST_INT.  */
name|number
operator|=
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|home
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
condition|)
block|{
comment|/* Handle an obscure case which can arise when optimizing and 	 when there are few available registers.  (This is *always* 	 the case for i386/i486 targets).  The RTL looks like 	 (MEM (CONST ...)) even though this variable is a local `auto' 	 or a local `register' variable.  In effect, what has happened 	 is that the reload pass has seen that all assignments and 	 references for one such a local variable can be replaced by 	 equivalent assignments and references to some static storage 	 variable, thereby avoiding the need for a register.  In such 	 cases we're forced to lie to debuggers and tell them that 	 this variable was itself `static'.  */
name|code
operator|=
name|N_LCSYM
expr_stmt|;
name|letter
operator|=
literal|'V'
expr_stmt|;
name|addr
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|tree
name|subtype
decl_stmt|;
comment|/* If TYPE is not a COMPLEX_TYPE (it might be a RECORD_TYPE, 	 for example), then there is no easy way to figure out 	 what SUBTYPE should be.  So, we give up.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|COMPLEX_TYPE
condition|)
return|return
literal|0
return|;
name|subtype
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If the variable's storage is in two parts, 	 output each as a separate stab with a modified name.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$imag"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$real"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$real"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$imag"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
comment|/* Address might be a MEM, when DECL is a variable-sized object.        Or it might be const0_rtx, meaning previous passes        want us to ignore this variable.  */
return|return
literal|0
return|;
comment|/* Ok, start a symtab entry and output the variable name.  */
name|emit_pending_bincls_if_required
argument_list|()
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_STATIC_BLOCK_START
name|DBX_STATIC_BLOCK_START
argument_list|(
name|asm_out_file
argument_list|,
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dbxout_begin_complex_stabs_noforcetext
argument_list|()
expr_stmt|;
name|dbxout_symbol_name
argument_list|(
name|decl
argument_list|,
name|suffix
argument_list|,
name|letter
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_complex_stabs
argument_list|(
name|decl
argument_list|,
name|code
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
name|number
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_STATIC_BLOCK_END
name|DBX_STATIC_BLOCK_END
argument_list|(
name|asm_out_file
argument_list|,
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the symbol name of DECL for a stabs, with suffix SUFFIX.    Then output LETTER to indicate the kind of location the symbol has.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_symbol_name
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|int
name|letter
parameter_list|)
block|{
name|tree
name|name
decl_stmt|;
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|TYPE_P
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|NAMESPACE_DECL
operator|)
condition|)
comment|/* One slight hitch: if this is a VAR_DECL which is a class member        or a namespace member, we must put out the mangled name instead of the        DECL_NAME.  Note also that static member (variable) names DO NOT begin        with underscores in .stabs directives.  */
name|name
operator|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
comment|/* ...but if we're function-local, we don't want to include the junk        added by ASM_FORMAT_PRIVATE_NAME.  */
name|name
operator|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|stabstr_I
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|stabstr_S
argument_list|(
literal|"(anon)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffix
condition|)
name|stabstr_S
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|letter
condition|)
name|stabstr_C
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output definitions of all the decls in a chain. Return nonzero if    anything was output */
end_comment

begin_function
name|int
name|dbxout_syms
parameter_list|(
name|tree
name|syms
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|syms
condition|)
block|{
name|result
operator|+=
name|dbxout_symbol
argument_list|(
name|syms
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|syms
operator|=
name|TREE_CHAIN
argument_list|(
name|syms
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following two functions output definitions of function parameters.    Each parameter gets a definition locating it in the parameter list.    Each parameter that is a register variable gets a second definition    locating it in the register.     Printing or argument lists in gdb uses the definitions that    locate in the parameter list.  But reference to the variable in    expressions uses preferentially the definition as a register.  */
end_comment

begin_comment
comment|/* Output definitions, referring to storage in the parmlist,    of all the parms in PARMS, which is a chain of PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|dbxout_parms
parameter_list|(
name|tree
name|parms
parameter_list|)
block|{
operator|++
name|debug_nesting
expr_stmt|;
name|emit_pending_bincls_if_required
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_RTL_SET_P
argument_list|(
name|parms
argument_list|)
operator|&&
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|tree
name|eff_type
decl_stmt|;
name|char
name|letter
decl_stmt|;
name|STAB_CODE_TYPE
name|code
decl_stmt|;
name|int
name|number
decl_stmt|;
comment|/* Perform any necessary register eliminations on the parameter's rtl, 	   so that the debugging output will be accurate.  */
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|SET_DECL_RTL
argument_list|(
name|parms
argument_list|,
name|eliminate_regs
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|current_function_uses_only_leaf_regs
condition|)
block|{
name|leaf_renumber_regs_insn
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|leaf_renumber_regs_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|PARM_PASSED_IN_MEMORY
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|rtx
name|inrtl
init|=
name|XEXP
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* ??? Here we assume that the parm address is indexed 	       off the frame pointer or arg pointer. 	       If that is not true, we produce meaningless results, 	       but do not crash.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|inrtl
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|inrtl
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|number
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|inrtl
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|number
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|N_PSYM
expr_stmt|;
name|number
operator|=
name|DEBUGGER_ARG_OFFSET
argument_list|(
name|number
argument_list|,
name|inrtl
argument_list|)
expr_stmt|;
name|letter
operator|=
literal|'p'
expr_stmt|;
comment|/* It is quite tempting to use TREE_TYPE (parms) instead 	       of DECL_ARG_TYPE (parms) for the eff_type, so that gcc 	       reports the actual type of the parameter, rather than 	       the promoted type.  This certainly makes GDB's life 	       easier, at least for some ports.  The change is a bad 	       idea however, since GDB expects to be able access the 	       type without performing any conversions.  So for 	       example, if we were passing a float to an unprototyped 	       function, gcc will store a double on the stack, but if 	       we emit a stab saying the type is a float, then gdb 	       will only read in a single value, and this will produce 	       an erroneous value.  */
name|eff_type
operator|=
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
block|{
name|rtx
name|best_rtl
decl_stmt|;
comment|/* Parm passed in registers and lives in registers or nowhere.  */
name|code
operator|=
name|DBX_REGPARM_STABS_CODE
expr_stmt|;
name|letter
operator|=
name|DBX_REGPARM_STABS_LETTER
expr_stmt|;
comment|/* For parms passed in registers, it is better to use the 	       declared type of the variable, not the type it arrived in.  */
name|eff_type
operator|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* If parm lives in a register, use that register; pretend 	       the parm was passed there.  It would be more consistent 	       to describe the register where the parm was passed, but 	       in practice that register usually holds something else. 	       If the parm lives nowhere, use the register where it 	       was passed.  */
if|if
condition|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|best_rtl
operator|=
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
expr_stmt|;
else|else
name|best_rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|number
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|best_rtl
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|&&
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ARG_POINTER_REGNUM
endif|#
directive|endif
condition|)
block|{
comment|/* Parm was passed via invisible reference. 	       That is, its address was passed in a register. 	       Output it as if it lived in that register. 	       The debugger will know from the type 	       that it was actually passed by invisible reference.  */
name|code
operator|=
name|DBX_REGPARM_STABS_CODE
expr_stmt|;
comment|/* GDB likes this marked with a special letter.  */
name|letter
operator|=
operator|(
name|use_gnu_debug_info_extensions
condition|?
literal|'a'
else|:
name|DBX_REGPARM_STABS_LETTER
operator|)
expr_stmt|;
name|eff_type
operator|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* DECL_RTL looks like (MEM (REG...).  Get the register number. 	       If it is an unallocated pseudo-reg, then use the register where 	       it was passed instead. 	       ??? Why is DBX_REGISTER_NUMBER not used here?  */
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|number
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|number
operator|=
name|REGNO
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|&&
name|MEM_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Parm was passed via invisible reference, with the reference 	       living on the stack.  DECL_RTL looks like 	       (MEM (MEM (PLUS (REG ...) (CONST_INT ...)))) or it 	       could look like (MEM (MEM (REG))).  */
name|code
operator|=
name|N_PSYM
expr_stmt|;
name|letter
operator|=
literal|'v'
expr_stmt|;
name|eff_type
operator|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|number
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|number
operator|=
literal|0
expr_stmt|;
name|number
operator|=
name|DEBUGGER_ARG_OFFSET
argument_list|(
name|number
argument_list|,
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|&&
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|const0_rtx
comment|/* ??? A constant address for a parm can happen 		    when the reg it lives in is equiv to a constant in memory. 		    Should make this not happen, after 2.4.  */
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Parm was passed in registers but lives on the stack.  */
name|code
operator|=
name|N_PSYM
expr_stmt|;
name|letter
operator|=
literal|'p'
expr_stmt|;
name|eff_type
operator|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))), 	       in which case we want the value of that CONST_INT, 	       or (MEM (REG ...)), 	       in which case we use a value of zero.  */
if|if
condition|(
operator|!
name|REG_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|number
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|number
operator|=
literal|0
expr_stmt|;
comment|/* Make a big endian correction if the mode of the type of the 	       parameter is not the same as the mode of the rtl.  */
if|if
condition|(
name|BYTES_BIG_ENDIAN
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|!=
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
name|number
operator|+=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|-
name|GET_MODE_SIZE
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
comment|/* ??? We don't know how to represent this argument.  */
continue|continue;
name|dbxout_begin_complex_stabs
argument_list|()
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|stabstr_I
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
block|}
else|else
name|stabstr_S
argument_list|(
literal|"(anon):"
argument_list|)
expr_stmt|;
name|stabstr_C
argument_list|(
name|letter
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|eff_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_complex_stabs
argument_list|(
name|parms
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
name|DBXOUT_DECR_NESTING
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output definitions for the places where parms live during the function,    when different from where they were passed, when the parms were passed    in memory.     It is not useful to do this for parms passed in registers    that live during the function in different registers, because it is    impossible to look in the passed register for the passed value,    so we use the within-the-function register to begin with.     PARMS is a chain of PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|dbxout_reg_parms
parameter_list|(
name|tree
name|parms
parameter_list|)
block|{
operator|++
name|debug_nesting
expr_stmt|;
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
operator|&&
name|PARM_PASSED_IN_MEMORY
argument_list|(
name|parms
argument_list|)
condition|)
block|{
comment|/* Report parms that live in registers during the function 	   but were passed in memory.  */
if|if
condition|(
name|REG_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|dbxout_symbol_location
argument_list|(
name|parms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|CONCAT
condition|)
name|dbxout_symbol_location
argument_list|(
name|parms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Report parms that live in memory but not where they were passed.  */
elseif|else
if|if
condition|(
name|MEM_P
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
name|dbxout_symbol_location
argument_list|(
name|parms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DBXOUT_DECR_NESTING
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a chain of ..._TYPE nodes (as come in a parameter list),    output definitions of those names, in raw form */
end_comment

begin_function
specifier|static
name|void
name|dbxout_args
parameter_list|(
name|tree
name|args
parameter_list|)
block|{
while|while
condition|(
name|args
condition|)
block|{
name|stabstr_C
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of dbxout_block.  Emit an N_LBRAC stab referencing LABEL.    BEGIN_LABEL is the name of the beginning of the function, which may    be required.  */
end_comment

begin_function
specifier|static
name|void
name|dbx_output_lbrac
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
specifier|const
name|char
modifier|*
name|begin_label
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|dbxout_begin_stabn
argument_list|(
name|N_LBRAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|DBX_BLOCKS_FUNCTION_RELATIVE
condition|)
name|dbxout_stab_value_label_diff
argument_list|(
name|label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
else|else
name|dbxout_stab_value_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of dbxout_block.  Emit an N_RBRAC stab referencing LABEL.    BEGIN_LABEL is the name of the beginning of the function, which may    be required.  */
end_comment

begin_function
specifier|static
name|void
name|dbx_output_rbrac
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
specifier|const
name|char
modifier|*
name|begin_label
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|dbxout_begin_stabn
argument_list|(
name|N_RBRAC
argument_list|)
expr_stmt|;
if|if
condition|(
name|DBX_BLOCKS_FUNCTION_RELATIVE
condition|)
name|dbxout_stab_value_label_diff
argument_list|(
name|label
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
else|else
name|dbxout_stab_value_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output everything about a symbol block (a BLOCK node    that represents a scope level),    including recursive output of contained blocks.     BLOCK is the BLOCK node.    DEPTH is its depth within containing symbol blocks.    ARGS is usually zero; but for the outermost block of the    body of a function, it is a chain of PARM_DECLs for the function parameters.    We output definitions of all the register parms    as if they were local variables of that block.     If -g1 was used, we count blocks just the same, but output nothing    except for the outermost block.     Actually, BLOCK may be several blocks chained together.    We handle them all in sequence.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_block
parameter_list|(
name|tree
name|block
parameter_list|,
name|int
name|depth
parameter_list|,
name|tree
name|args
parameter_list|)
block|{
name|char
name|begin_label
index|[
literal|20
index|]
decl_stmt|;
comment|/* Reference current function start using LFBB.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|begin_label
argument_list|,
literal|"LFBB"
argument_list|,
name|scope_labelno
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
condition|)
block|{
comment|/* Ignore blocks never expanded or otherwise marked as real.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|block
argument_list|)
condition|)
block|{
name|int
name|did_output
decl_stmt|;
name|int
name|blocknum
init|=
name|BLOCK_NUMBER
argument_list|(
name|block
argument_list|)
decl_stmt|;
comment|/* In dbx format, the syms of a block come before the N_LBRAC. 	     If nothing is output, we don't need the N_LBRAC, either.  */
name|did_output
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
operator|||
name|depth
operator|==
literal|0
condition|)
name|did_output
operator|=
name|dbxout_syms
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|dbxout_reg_parms
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Now output an N_LBRAC symbol to represent the beginning of 	     the block.  Use the block's tree-walk order to generate 	     the assembler symbols LBBn and LBEn 	     that final will define around the code in this block.  */
if|if
condition|(
name|did_output
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|scope_start
decl_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
comment|/* The outermost block doesn't get LBB labels; use 		   the LFBB local symbol emitted by dbxout_begin_prologue.  */
name|scope_start
operator|=
name|begin_label
expr_stmt|;
else|else
block|{
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LBB"
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
name|scope_start
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|BLOCK_HANDLER_BLOCK
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|/* A catch block.  Must precede N_LBRAC.  */
name|tree
name|decl
init|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
decl_stmt|;
while|while
condition|(
name|decl
condition|)
block|{
name|dbxout_begin_complex_stabs
argument_list|()
expr_stmt|;
name|stabstr_I
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|stabstr_S
argument_list|(
literal|":C1"
argument_list|)
expr_stmt|;
name|dbxout_finish_complex_stabs
argument_list|(
literal|0
argument_list|,
name|N_CATCH
argument_list|,
literal|0
argument_list|,
name|scope_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
name|dbx_output_lbrac
argument_list|(
name|scope_start
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
block|}
comment|/* Output the subblocks.  */
name|dbxout_block
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Refer to the marker for the end of the block.  */
if|if
condition|(
name|did_output
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
comment|/* The outermost block doesn't get LBE labels; 		   use the "scope" label which will be emitted 		   by dbxout_function_end.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"Lscope"
argument_list|,
name|scope_labelno
argument_list|)
expr_stmt|;
else|else
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LBE"
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
name|dbx_output_rbrac
argument_list|(
name|buf
argument_list|,
name|begin_label
argument_list|)
expr_stmt|;
block|}
block|}
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the information about a function and its arguments and result.    Usually this follows the function's code,    but on some systems, it comes before.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
end_if

begin_function
specifier|static
name|void
name|dbxout_begin_function
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|int
name|saved_tree_used1
decl_stmt|;
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|saved_tree_used1
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|saved_tree_used2
init|=
name|TREE_USED
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|TREE_USED
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|saved_tree_used2
expr_stmt|;
block|}
else|else
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
name|saved_tree_used1
expr_stmt|;
name|dbxout_parms
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|dbxout_symbol
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO || XCOFF_DEBUGGING_INFO */
end_comment

begin_include
include|#
directive|include
file|"gt-dbxout.h"
end_include

end_unit

