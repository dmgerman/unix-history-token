begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output dbx-format symbol table information from GNU compiler.    Copyright (C) 1987, 88, 92, 93, 94, 1995 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Output dbx-format symbol table data.    This consists of many symbol table entries, each of them    a .stabs assembler pseudo-op with four operands:    a "name" which is really a description of one symbol and its type,    a "code", which is a symbol defined in stab.h whose name starts with N_,    an unused operand always 0,    and a "value" which is an address or an offset.    The name is enclosed in doublequote characters.     Each function, variable, typedef, and structure tag    has a symbol table entry to define it.    The beginning and end of each level of name scoping within    a function are also marked by special symbol table entries.     The "name" consists of the symbol name, a colon, a kind-of-symbol letter,    and a data type number.  The data type number may be followed by    "=" and a type definition; normally this will happen the first time    the type number is mentioned.  The type definition may refer to    other types by number, and those type numbers may be followed    by "=" and nested definitions.     This can make the "name" quite long.    When a name is more than 80 characters, we split the .stabs pseudo-op    into two .stabs pseudo-ops, both sharing the same "code" and "value".    The first one is marked as continued with a double-backslash at the    end of its "name".     The kind-of-symbol letter distinguished function names from global    variables from file-scope variables from parameters from auto    variables in memory from typedef names from register variables.    See `dbxout_symbol'.     The "code" is mostly redundant with the kind-of-symbol letter    that goes in the "name", but not entirely: for symbols located    in static storage, the "code" says which segment the address is in,    which controls how it is relocated.     The "value" for a symbol in static storage    is the core address of the symbol (actually, the assembler    label for the symbol).  For a symbol located in a stack slot    it is the stack offset; for one in a register, the register number.    For a typedef symbol, it is zero.     If DEBUG_SYMS_TEXT is defined, all debugging symbols must be    output while in the text section.     For more on data type definitions, see `dbxout_type'.  */
end_comment

begin_comment
comment|/* Include these first, because they may define MIN and MAX.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"regs.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"reload.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_comment
comment|/* ASM_OUTPUT_SOURCE_LINE may refer to sdb functions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XCOFF_DEBUGGING_INFO
end_ifdef

begin_include
include|#
directive|include
file|"xcoffout.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_STABS_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_STABS_OP
value|".stabs"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ASM_STABN_OP
end_ifndef

begin_define
define|#
directive|define
name|ASM_STABN_OP
value|".stabn"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_TYPE_DECL_STABS_CODE
end_ifndef

begin_define
define|#
directive|define
name|DBX_TYPE_DECL_STABS_CODE
value|N_LSYM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_STATIC_CONST_VAR_CODE
end_ifndef

begin_define
define|#
directive|define
name|DBX_STATIC_CONST_VAR_CODE
value|N_FUN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_REGPARM_STABS_CODE
end_ifndef

begin_define
define|#
directive|define
name|DBX_REGPARM_STABS_CODE
value|N_RSYM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_REGPARM_STABS_LETTER
end_ifndef

begin_define
define|#
directive|define
name|DBX_REGPARM_STABS_LETTER
value|'P'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is used for parameters passed by invisible reference in a register.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GDB_INV_REF_REGPARM_STABS_LETTER
end_ifndef

begin_define
define|#
directive|define
name|GDB_INV_REF_REGPARM_STABS_LETTER
value|'a'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_MEMPARM_STABS_LETTER
end_ifndef

begin_define
define|#
directive|define
name|DBX_MEMPARM_STABS_LETTER
value|'p'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FILE_NAME_JOINER
end_ifndef

begin_define
define|#
directive|define
name|FILE_NAME_JOINER
value|"/"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero means if the type has methods, only output debugging    information if methods are actually written to the asm file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flag_minimal_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we have actually used any of the GDB extensions    to the debugging format.  The idea is that we use them for the    first time only if there's a strong reason, but once we have done that,    we use them whenever convenient.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_used_extensions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number for the next N_SOL filename stabs label.  The number 0 is reserved    for the N_SO filename stabs label.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|source_label_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getpwd
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Typical USG systems don't have stab.h, and they also have    no use for DBX-format debugging info.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DBX_DEBUGGING_INFO
argument_list|)
operator|||
name|defined
argument_list|(
name|XCOFF_DEBUGGING_INFO
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_SYMS_TEXT
end_ifdef

begin_define
define|#
directive|define
name|FORCE_TEXT
value|text_section ();
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FORCE_TEXT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|NO_STAB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|"gstab.h"
end_include

begin_comment
comment|/* If doing DBX on sysV, use our own stab.h.  */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_comment
comment|/* On BSD, use the system's stab.h.  */
end_comment

begin_comment
comment|/* This is a GNU extension we need to reference in this file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_CATCH
end_ifndef

begin_define
define|#
directive|define
name|N_CATCH
value|0x54
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNU_STAB__
end_ifdef

begin_define
define|#
directive|define
name|STAB_CODE_TYPE
value|enum __stab_debug_code
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STAB_CODE_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 1 if PARM is passed to this function in memory.  */
end_comment

begin_define
define|#
directive|define
name|PARM_PASSED_IN_MEMORY
parameter_list|(
name|PARM
parameter_list|)
define|\
value|(GET_CODE (DECL_INCOMING_RTL (PARM)) == MEM)
end_define

begin_comment
comment|/* A C expression for the integer offset value of an automatic variable    (N_LSYM) having address X (an RTX).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUGGER_AUTO_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|DEBUGGER_AUTO_OFFSET
parameter_list|(
name|X
parameter_list|)
define|\
value|(GET_CODE (X) == PLUS ? INTVAL (XEXP (X, 1)) : 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A C expression for the integer offset value of an argument (N_PSYM)    having address X (an RTX).  The nominal offset is OFFSET.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUGGER_ARG_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|DEBUGGER_ARG_OFFSET
parameter_list|(
name|OFFSET
parameter_list|,
name|X
parameter_list|)
value|(OFFSET)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Stream for writing to assembler file.  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|asmfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last source file name mentioned in a NOTE insn.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current working directory.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cwd
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|typestatus
block|{
name|TYPE_UNSEEN
block|,
name|TYPE_XREF
block|,
name|TYPE_DEFINED
block|}
enum|;
end_enum

begin_comment
comment|/* Vector recording the status of describing C data types.    When we first notice a data type (a tree node),    we assign it a number using next_type_number.    That is its index in this vector.    The vector element says whether we have yet output    the definition of the type.  TYPE_XREF says we have    output it as a cross-reference only.  */
end_comment

begin_decl_stmt
name|enum
name|typestatus
modifier|*
name|typevec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements of space allocated in `typevec'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|typevec_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In dbx output, each type gets a unique number.    This is the number for the next type output.    The number, once assigned, is in the TYPE_SYMTAB_ADDRESS field.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_type_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In dbx output, we must assign symbol-blocks id numbers    in the order in which their beginnings are encountered.    We output debugging info that refers to the beginning and    end of the ranges of code in each block    with assembler labels LBBn and LBEn, where n is the block number.    The labels are generated in final, which assigns numbers to the    blocks in the same way.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next_block_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables are for dbxout_symbol to communicate to    dbxout_finish_symbol.    current_sym_code is the symbol-type-code, a symbol N_... define in stab.h.    current_sym_value and current_sym_addr are two ways to address the    value to store in the symtab entry.    current_sym_addr if nonzero represents the value as an rtx.    If that is zero, current_sym_value is used.  This is used    when the value is an offset (such as for auto variables,    register variables and parms).  */
end_comment

begin_decl_stmt
specifier|static
name|STAB_CODE_TYPE
name|current_sym_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_sym_value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|current_sym_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of chars of symbol-description generated so far for the    current symbol.  Used by CHARS and CONTIN.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_sym_nchars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Report having output N chars of the current symbol-description.  */
end_comment

begin_define
define|#
directive|define
name|CHARS
parameter_list|(
name|N
parameter_list|)
value|(current_sym_nchars += (N))
end_define

begin_comment
comment|/* Break the current symbol-description, generating a continuation,    if it has become long.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DBX_CONTIN_LENGTH
end_ifndef

begin_define
define|#
directive|define
name|DBX_CONTIN_LENGTH
value|80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|DBX_CONTIN_LENGTH
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|CONTIN
define|\
value|do {if (current_sym_nchars> DBX_CONTIN_LENGTH) dbxout_continue ();} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONTIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|dbxout_types
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dbxout_args
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dbxout_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_type_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_typedefs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_symbol_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_symbol_location
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_prepare_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_finish_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dbxout_continue
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_int_cst_octal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_octal
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not clear we will actually need this.  */
end_comment

begin_comment
comment|/* Return the absolutized filename for the given relative    filename.  Note that if that filename is already absolute, it may    still be returned in a modified form because this routine also    eliminates redundant slashes and single dots and eliminates double    dots to get a shortest possible filename from the given input    filename.  The absolutization of relative filenames is made by    assuming that the given filename is to be taken as relative to    the first argument (cwd) or to the current directory if cwd is    NULL.  */
end_comment

begin_comment
unit|static char * abspath (rel_filename)      char *rel_filename; {
comment|/* Setup the current working directory as needed.  */
end_comment

begin_comment
unit|char *abs_buffer     = (char *) alloca (strlen (cwd) + strlen (rel_filename) + 1);   char *endp = abs_buffer;   char *outp, *inp;   char *value;
comment|/* Copy the filename (possibly preceded by the current working      directory name) into the absolutization buffer.  */
end_comment

begin_comment
unit|{     char *src_p;      if (rel_filename[0] != '/')       {         src_p = cwd;         while (*endp++ = *src_p++)           continue;         *(endp-1) = '/';
comment|/* overwrite null */
end_comment

begin_comment
unit|}     src_p = rel_filename;     while (*endp++ = *src_p++)       continue;     if (endp[-1] == '/')       *endp = '\0';
comment|/* Now make a copy of abs_buffer into abs_buffer, shortening the      filename (by taking out slashes and dots) as we go.  */
end_comment

begin_comment
unit|outp = inp = abs_buffer;   *outp++ = *inp++;
comment|/* copy first slash */
end_comment

begin_comment
unit|for (;;)     {       if (!inp[0])         break;       else if (inp[0] == '/'&& outp[-1] == '/')         {           inp++;           continue;         }       else if (inp[0] == '.'&& outp[-1] == '/')         {           if (!inp[1])                   break;           else if (inp[1] == '/')             {                     inp += 2;                     continue;             }           else if ((inp[1] == '.')&& (inp[2] == 0 || inp[2] == '/'))             {                     inp += (inp[2] == '/') ? 3 : 2;                     outp -= 2;                     while (outp>= abs_buffer&& *outp != '/')               	outp--;                     if (outp< abs_buffer)                 {
comment|/* Catch cases like /.. where we try to backup to a                      point above the absolute root of the logical file                      system.  */
end_comment

begin_comment
unit|fprintf (stderr, "%s: invalid file name: %s\n", 			   pname, rel_filename);               	  exit (1);               	}                     *++outp = '\0';                     continue;             }         }       *outp++ = *inp++;     }
comment|/* On exit, make sure that there is a trailing null, and make sure that      the last character of the returned string is *not* a slash.  */
end_comment

begin_comment
unit|*outp = '\0';   if (outp[-1] == '/')     *--outp  = '\0';
comment|/* Make a copy (in the heap) of the stuff left in the absolutization      buffer and return a pointer to the copy.  */
end_comment

begin_endif
unit|value = (char *) oballoc (strlen (abs_buffer) + 1);   strcpy (value, abs_buffer);   return value; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* At the beginning of compilation, start writing the symbol table.    Initialize `typevec' and output the standard data types of C.  */
end_comment

begin_function
name|void
name|dbxout_init
parameter_list|(
name|asm_file
parameter_list|,
name|input_file_name
parameter_list|,
name|syms
parameter_list|)
name|FILE
modifier|*
name|asm_file
decl_stmt|;
name|char
modifier|*
name|input_file_name
decl_stmt|;
name|tree
name|syms
decl_stmt|;
block|{
name|char
name|ltext_label_name
index|[
literal|100
index|]
decl_stmt|;
name|asmfile
operator|=
name|asm_file
expr_stmt|;
name|typevec_len
operator|=
literal|100
expr_stmt|;
name|typevec
operator|=
operator|(
expr|enum
name|typestatus
operator|*
operator|)
name|xmalloc
argument_list|(
name|typevec_len
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|typevec
argument_list|,
name|typevec_len
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Convert Ltext into the appropriate format for local labels in case      the system doesn't insert underscores in front of user generated      labels.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ltext_label_name
argument_list|,
literal|"Ltext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put the current working directory in an N_SO symbol.  */
ifndef|#
directive|ifndef
name|DBX_WORKING_DIRECTORY
comment|/* Only some versions of DBX want this, 				 but GDB always does.  */
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|cwd
operator|&&
operator|(
name|cwd
operator|=
name|getpwd
argument_list|()
operator|)
operator|&&
operator|(
operator|!
operator|*
name|cwd
operator|||
name|cwd
index|[
name|strlen
argument_list|(
name|cwd
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
operator|)
condition|)
block|{
name|char
modifier|*
name|wdslash
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|cwd
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|FILE_NAME_JOINER
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|wdslash
argument_list|,
literal|"%s%s"
argument_list|,
name|cwd
argument_list|,
name|FILE_NAME_JOINER
argument_list|)
expr_stmt|;
name|cwd
operator|=
name|wdslash
expr_stmt|;
block|}
if|if
condition|(
name|cwd
condition|)
block|{
ifdef|#
directive|ifdef
name|DBX_OUTPUT_MAIN_SOURCE_DIRECTORY
name|DBX_OUTPUT_MAIN_SOURCE_DIRECTORY
argument_list|(
name|asmfile
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s "
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asmfile
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,0,0,%s\n"
argument_list|,
name|N_SO
argument_list|,
operator|&
name|ltext_label_name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no DBX_OUTPUT_MAIN_SOURCE_DIRECTORY */
block|}
block|}
ifdef|#
directive|ifdef
name|DBX_OUTPUT_MAIN_SOURCE_FILENAME
comment|/* This should NOT be DBX_OUTPUT_SOURCE_FILENAME. That      would give us an N_SOL, and we want an N_SO.  */
name|DBX_OUTPUT_MAIN_SOURCE_FILENAME
argument_list|(
name|asmfile
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no DBX_OUTPUT_MAIN_SOURCE_FILENAME */
comment|/* We include outputting `Ltext:' here,      because that gives you a way to override it.  */
comment|/* Used to put `Ltext:' before the reference, but that loses on sun 4.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s "
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|asmfile
argument_list|,
name|input_file_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,0,0,%s\n"
argument_list|,
name|N_SO
argument_list|,
operator|&
name|ltext_label_name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asmfile
argument_list|,
literal|"Ltext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no DBX_OUTPUT_MAIN_SOURCE_FILENAME */
comment|/* Possibly output something to inform GDB that this compilation was by      GCC.  It's easier for GDB to parse it when after the N_SO's.  This      is used in Solaris 2.  */
ifdef|#
directive|ifdef
name|ASM_IDENTIFY_GCC_AFTER_SOURCE
name|ASM_IDENTIFY_GCC_AFTER_SOURCE
argument_list|(
name|asmfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lastfile
operator|=
name|input_file_name
expr_stmt|;
name|next_type_number
operator|=
literal|1
expr_stmt|;
name|next_block_number
operator|=
literal|2
expr_stmt|;
comment|/* Make sure that types `int' and `char' have numbers 1 and 2.      Definitions of other integer types will refer to those numbers.      (Actually it should no longer matter what their numbers are.      Also, if any types with tags have been defined, dbxout_symbol      will output them first, so the numbers won't be 1 and 2.  That      happens in C++.  So it's a good thing it should no longer matter).  */
ifdef|#
directive|ifdef
name|DBX_OUTPUT_STANDARD_TYPES
name|DBX_OUTPUT_STANDARD_TYPES
argument_list|(
name|syms
argument_list|)
expr_stmt|;
else|#
directive|else
name|dbxout_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|char_type_node
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get all permanent types that have typedef names,      and output them all, except for those already output.  */
name|dbxout_typedefs
argument_list|(
name|syms
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output any typedef names for types described by TYPE_DECLs in SYMS,    in the reverse order from that which is found in SYMS.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_typedefs
parameter_list|(
name|syms
parameter_list|)
name|tree
name|syms
decl_stmt|;
block|{
if|if
condition|(
name|syms
condition|)
block|{
name|dbxout_typedefs
argument_list|(
name|TREE_CHAIN
argument_list|(
name|syms
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|syms
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|syms
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|dbxout_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output debugging info to FILE to switch to sourcefile FILENAME.  */
end_comment

begin_function
name|void
name|dbxout_source_file
parameter_list|(
name|file
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
name|ltext_label_name
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|filename
operator|&&
operator|(
name|lastfile
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|filename
argument_list|,
name|lastfile
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DBX_OUTPUT_SOURCE_FILENAME
name|DBX_OUTPUT_SOURCE_FILENAME
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|ltext_label_name
argument_list|,
literal|"Ltext"
argument_list|,
name|source_label_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s "
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|output_quoted_string
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|",%d,0,0,%s\n"
argument_list|,
name|N_SOL
argument_list|,
operator|&
name|ltext_label_name
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_function_decl
operator|!=
name|NULL_TREE
operator|&&
name|DECL_SECTION_NAME
argument_list|(
name|current_function_decl
argument_list|)
operator|!=
name|NULL_TREE
condition|)
empty_stmt|;
comment|/* Don't change section amid function.  */
else|else
name|text_section
argument_list|()
expr_stmt|;
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|file
argument_list|,
literal|"Ltext"
argument_list|,
name|source_label_number
argument_list|)
expr_stmt|;
name|source_label_number
operator|++
expr_stmt|;
endif|#
directive|endif
name|lastfile
operator|=
name|filename
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output a line number symbol entry into output stream FILE,     for source file FILENAME and line number LINENO.  */
end_comment

begin_function
name|void
name|dbxout_source_line
parameter_list|(
name|file
parameter_list|,
name|filename
parameter_list|,
name|lineno
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
name|dbxout_source_file
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SOURCE_LINE
name|ASM_OUTPUT_SOURCE_LINE
argument_list|(
name|file
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s %d,0,%d\n"
argument_list|,
name|ASM_STABD_OP
argument_list|,
name|N_SLINE
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* At the end of compilation, finish writing the symbol table.    Unless you define DBX_OUTPUT_MAIN_SOURCE_FILE_END, the default is    to do nothing. */
end_comment

begin_function
name|void
name|dbxout_finish
parameter_list|(
name|file
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DBX_OUTPUT_MAIN_SOURCE_FILE_END
name|DBX_OUTPUT_MAIN_SOURCE_FILE_END
argument_list|(
name|file
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DBX_OUTPUT_MAIN_SOURCE_FILE_END */
block|}
end_function

begin_comment
comment|/* Continue a symbol-description that gets too big.    End one symbol table entry with a double-backslash    and start a new one, eventually producing something like    .stabs "start......\\",code,0,value    .stabs "...rest",code,0,value   */
end_comment

begin_function
specifier|static
name|void
name|dbxout_continue
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DBX_CONTIN_CHAR
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%c"
argument_list|,
name|DBX_CONTIN_CHAR
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\\\\"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dbxout_finish_symbol
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \""
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|current_sym_nchars
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `dbxout_type'.  Output the type fields of TYPE.    This must be a separate function because anonymous unions require    recursive calls.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_fields
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|tem
decl_stmt|;
comment|/* Output the name, type, position (in bits), size (in bits) of each      field.  */
for|for
control|(
name|tem
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
block|{
comment|/* Omit here local type decls until we know how to support them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|TYPE_DECL
condition|)
continue|continue;
comment|/* Omit fields whose position or size are variable.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|)
condition|)
continue|continue;
comment|/* Omit here the nameless fields that are used to skip bits.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|CONST_DECL
condition|)
block|{
comment|/* Continue the line if necessary, 	     but not before the first field.  */
if|if
condition|(
name|tem
operator|!=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
condition|)
name|CONTIN
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|flag_minimal_debug
operator|&&
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_VIRTUAL_P
argument_list|(
name|tem
argument_list|)
operator|&&
name|DECL_ASSEMBLER_NAME
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|CHARS
argument_list|(
literal|3
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|DECL_FCONTEXT
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d;"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s:"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
operator|(
name|TREE_PRIVATE
argument_list|(
name|tem
argument_list|)
operator|||
name|TREE_PROTECTED
argument_list|(
name|tem
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|FIELD_DECL
operator|)
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
literal|'/'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|(
name|TREE_PRIVATE
argument_list|(
name|tem
argument_list|)
condition|?
literal|'0'
else|:
name|TREE_PROTECTED
argument_list|(
name|tem
argument_list|)
condition|?
literal|'1'
else|:
literal|'2'
operator|)
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|tem
argument_list|)
operator|)
condition|?
name|DECL_BIT_FIELD_TYPE
argument_list|(
name|tem
argument_list|)
else|:
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|tem
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|tem
argument_list|)
operator|&&
name|use_gnu_debug_info_extensions
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|tem
argument_list|)
argument_list|)
decl_stmt|;
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":%s;"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If TEM is non-static, GDB won't understand it.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",0,0;"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,%d;"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_FIELD_BITPOS
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CHARS
argument_list|(
literal|23
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `dbxout_type_methods'.  Output debug info about the    method described DECL.  DEBUG_NAME is an encoding of the method's    type signature.  ??? We may be able to do without DEBUG_NAME altogether    now.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_method_1
parameter_list|(
name|decl
parameter_list|,
name|debug_name
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|debug_name
decl_stmt|;
block|{
name|char
name|c1
init|=
literal|'A'
decl_stmt|,
name|c2
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|c2
operator|=
literal|'?'
expr_stmt|;
else|else
comment|/* it's a METHOD_TYPE.  */
block|{
name|tree
name|firstarg
init|=
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|/* A for normal functions. 	 B for `const' member functions. 	 C for `volatile' member functions. 	 D for `const volatile' member functions.  */
if|if
condition|(
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
condition|)
name|c1
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|firstarg
argument_list|)
argument_list|)
condition|)
name|c1
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
name|c2
operator|=
literal|'*'
expr_stmt|;
else|else
name|c2
operator|=
literal|'.'
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":%s;%c%c%c"
argument_list|,
name|debug_name
argument_list|,
name|TREE_PRIVATE
argument_list|(
name|decl
argument_list|)
condition|?
literal|'0'
else|:
name|TREE_PROTECTED
argument_list|(
name|decl
argument_list|)
condition|?
literal|'1'
else|:
literal|'2'
argument_list|,
name|c1
argument_list|,
name|c2
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|+
literal|6
operator|-
operator|(
name|debug_name
operator|-
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%d;"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_VINDEX
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of `dbxout_type'.  Output debug info about the methods defined    in TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_methods
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
comment|/* C++: put out the method names and their parameter lists */
name|tree
name|methods
init|=
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|type_encoding
decl_stmt|;
specifier|register
name|tree
name|fndecl
decl_stmt|;
specifier|register
name|tree
name|last
decl_stmt|;
name|char
name|formatted_type_identifier_length
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|int
name|type_identifier_length
decl_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL_TREE
condition|)
return|return;
name|type_encoding
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* C++: Template classes break some assumptions made by this code about      the class names, constructor names, and encodings for assembler      label names.  For now, disable output of dbx info for them.  */
block|{     char *ptr = IDENTIFIER_POINTER (type_encoding);
comment|/* This should use index.  (mrs) */
block|while (*ptr&& *ptr != '<') ptr++;     if (*ptr != 0)       { 	static int warned; 	if (!warned) 	  { 	    warned = 1;
ifdef|#
directive|ifdef
name|HAVE_TEMPLATES
block|if (warn_template_debugging) 	      warning ("dbx info for template class methods not yet supported");
endif|#
directive|endif
block|} 	return;       }   }
endif|#
directive|endif
name|type_identifier_length
operator|=
name|IDENTIFIER_LENGTH
argument_list|(
name|type_encoding
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|formatted_type_identifier_length
argument_list|,
literal|"%d"
argument_list|,
name|type_identifier_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|methods
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|fndecl
operator|=
name|methods
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|fndecl
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|fndecl
operator|=
name|TREE_VEC_ELT
argument_list|(
name|methods
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|fndecl
condition|)
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|int
name|need_prefix
init|=
literal|1
decl_stmt|;
comment|/* Group together all the methods for the same operation. 	 These differ in the types of the arguments.  */
for|for
control|(
name|last
operator|=
name|NULL_TREE
init|;
name|fndecl
operator|&&
operator|(
name|last
operator|==
name|NULL_TREE
operator|||
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|last
argument_list|)
operator|)
condition|;
name|fndecl
operator|=
name|TREE_CHAIN
argument_list|(
name|fndecl
argument_list|)
control|)
comment|/* Output the name of the field (after overloading), as 	   well as the name of the field before overloading, along 	   with its parameter list */
block|{
comment|/* This is the "mangled" name of the method. 	     It encodes the argument types.  */
name|char
modifier|*
name|debug_name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|destructor
init|=
literal|0
decl_stmt|;
name|CONTIN
expr_stmt|;
name|last
operator|=
name|fndecl
expr_stmt|;
if|if
condition|(
name|DECL_IGNORED_P
argument_list|(
name|fndecl
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|flag_minimal_debug
condition|)
block|{
comment|/* Detect ordinary methods because their mangled names 		 start with the operation name.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|debug_name
argument_list|,
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
block|{
name|debug_name
operator|+=
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|debug_name
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|method_name
init|=
name|debug_name
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|length_ptr
init|=
name|formatted_type_identifier_length
decl_stmt|;
comment|/* Get past const and volatile qualifiers.  */
while|while
condition|(
operator|*
name|method_name
operator|==
literal|'C'
operator|||
operator|*
name|method_name
operator|==
literal|'V'
condition|)
name|method_name
operator|++
expr_stmt|;
comment|/* Skip digits for length of type_encoding. */
while|while
condition|(
operator|*
name|method_name
operator|==
operator|*
name|length_ptr
operator|&&
operator|*
name|length_ptr
condition|)
name|length_ptr
operator|++
operator|,
name|method_name
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|method_name
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|type_encoding
argument_list|)
argument_list|,
name|type_identifier_length
argument_list|)
condition|)
name|method_name
operator|+=
name|type_identifier_length
expr_stmt|;
name|debug_name
operator|=
name|method_name
expr_stmt|;
block|}
block|}
comment|/* Detect constructors by their style of name mangling.  */
elseif|else
if|if
condition|(
name|debug_name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|debug_name
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|ctor_name
init|=
name|debug_name
operator|+
literal|2
decl_stmt|;
name|char
modifier|*
name|length_ptr
init|=
name|formatted_type_identifier_length
decl_stmt|;
while|while
condition|(
operator|*
name|ctor_name
operator|==
literal|'C'
operator|||
operator|*
name|ctor_name
operator|==
literal|'V'
condition|)
name|ctor_name
operator|++
expr_stmt|;
comment|/* Skip digits for length of type_encoding. */
while|while
condition|(
operator|*
name|ctor_name
operator|==
operator|*
name|length_ptr
operator|&&
operator|*
name|length_ptr
condition|)
name|length_ptr
operator|++
operator|,
name|ctor_name
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|type_encoding
argument_list|)
argument_list|,
name|ctor_name
argument_list|,
name|type_identifier_length
argument_list|)
condition|)
name|debug_name
operator|=
name|ctor_name
operator|+
name|type_identifier_length
expr_stmt|;
block|}
comment|/* The other alternative is a destructor.  */
else|else
name|destructor
operator|=
literal|1
expr_stmt|;
comment|/* Output the operation name just once, for the first method 		 that we output.  */
if|if
condition|(
name|need_prefix
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s::"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|need_prefix
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|destructor
argument_list|)
expr_stmt|;
name|dbxout_type_method_1
argument_list|(
name|fndecl
argument_list|,
name|debug_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|need_prefix
condition|)
block|{
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Emit a "range" type specification, which has the form:    "r<index type>;<lower bound>;<upper bound>;".    TYPE is an INTEGER_TYPE. */
end_comment

begin_function
specifier|static
name|void
name|dbxout_range_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* E.g. Pascal's ARRAY [BOOLEAN] of INTEGER */
else|else
block|{
comment|/* This used to say `r1' and we used to take care 	 to make sure that `int' was type number 1.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%d"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";%d"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";%d;"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";-1;"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a reference to a type.  If the type has not yet been    described in the dbx output, output its definition now.    For a type already defined, just refer to its definition    using the type number.     If FULL is nonzero, and the type has been described only with    a forward-reference, output the definition now.    If FULL is zero in this case, just refer to the forward-reference    using the number previously allocated.     If SHOW_ARG_TYPES is nonzero, we output a description of the argument    types for a METHOD_TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type
parameter_list|(
name|type
parameter_list|,
name|full
parameter_list|,
name|show_arg_types
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|full
decl_stmt|;
name|int
name|show_arg_types
decl_stmt|;
block|{
specifier|register
name|tree
name|tem
decl_stmt|;
specifier|static
name|int
name|anonymous_type_number
init|=
literal|0
decl_stmt|;
comment|/* If there was an input error and we don't really have a type,      avoid crashing and write something that is at least valid      by assuming `int'.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|integer_type_node
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|full
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Type has no dbx number assigned.  Assign next available number.  */
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
operator|=
name|next_type_number
operator|++
expr_stmt|;
comment|/* Make sure type vector is long enough to record about this type.  */
if|if
condition|(
name|next_type_number
operator|==
name|typevec_len
condition|)
block|{
name|typevec
operator|=
operator|(
expr|enum
name|typestatus
operator|*
operator|)
name|xrealloc
argument_list|(
name|typevec
argument_list|,
name|typevec_len
operator|*
literal|2
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|typevec
operator|+
name|typevec_len
operator|)
argument_list|,
name|typevec_len
operator|*
sizeof|sizeof
name|typevec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|typevec_len
operator|*=
literal|2
expr_stmt|;
block|}
block|}
comment|/* Output the number of this type, to refer to it.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%d"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_TYPE_DEFINED
if|if
condition|(
name|DBX_TYPE_DEFINED
argument_list|(
name|type
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* If this type's definition has been output or is now being output,      that is all.  */
switch|switch
condition|(
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
condition|)
block|{
case|case
name|TYPE_UNSEEN
case|:
break|break;
case|case
name|TYPE_XREF
case|:
comment|/* If we have already had a cross reference, 	 and either that's all we want or that's the best we could do, 	 don't repeat the cross reference. 	 Sun dbx crashes if we do.  */
if|if
condition|(
operator|!
name|full
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
comment|/* No way in DBX fmt to describe a variable size.  */
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return;
break|break;
case|case
name|TYPE_DEFINED
case|:
return|return;
block|}
ifdef|#
directive|ifdef
name|DBX_NO_XREFS
comment|/* For systems where dbx output does not allow the `=xsNAME:' syntax,      leave the type-number completely undefined rather than output      a cross-reference.  If we have already used GNU debug info extensions,      then it is OK to output a cross reference.  This is necessary to get      proper C++ debug output.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
operator|!
name|use_gnu_debug_info_extensions
condition|)
comment|/* We must use the same test here as we use twice below when deciding        whether to emit a cross-reference.  */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|full
operator|)
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
comment|/* No way in DBX fmt to describe a variable size.  */
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|=
name|TYPE_XREF
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Output a definition now.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Mark it as defined, so that if it is self-referent      we will not get into an infinite recursion of definitions.  */
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|=
name|TYPE_DEFINED
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|VOID_TYPE
case|:
case|case
name|LANG_TYPE
case|:
comment|/* For a void type, just define it as itself; ie, "5=5". 	 This makes us consider it defined 	 without saying what it is.  The debugger will make it 	 a void type when the reference is seen, and nothing will 	 ever override that default.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%d"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_TYPE
case|:
if|if
condition|(
name|type
operator|==
name|char_type_node
operator|&&
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
comment|/* Output the type `char' as a subrange of itself! 	   I don't understand this definition, just copied it 	   from the output of pcc. 	   This used to use `r2' explicitly and we used to 	   take care to make sure that `char' was type number 2.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r%d;0;127;"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>
name|HOST_BITS_PER_WIDE_INT
operator|)
condition|)
block|{
comment|/* This used to say `r1' and we used to take care 	     to make sure that `int' was type number 1.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r%d;"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|print_int_cst_octal
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
name|print_int_cst_octal
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Output other integer types as subranges of `int'.  */
name|dbxout_range_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|25
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
comment|/* This used to say `r1' and we used to take care 	 to make sure that `int' was type number 1.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r%d;%d;0;"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|integer_type_node
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|16
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAR_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"@s%d;-20;"
argument_list|,
name|BITS_PER_UNIT
operator|*
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Output the type `char' as a subrange of itself. 	   That is what pcc seems to do.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r%d;0;%d;"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|char_type_node
argument_list|)
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|255
else|:
literal|127
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|9
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOOLEAN_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"@s%d;-16;"
argument_list|,
name|BITS_PER_UNIT
operator|*
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Define as enumeral type (False, True) */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"eFalse:0,True:1,;"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|17
argument_list|)
expr_stmt|;
break|break;
case|case
name|FILE_TYPE
case|:
name|putc
argument_list|(
literal|'d'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_TYPE
case|:
comment|/* Differs from the REAL_TYPE by its new data type number */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"r%d;%d;0;"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* The number is probably incorrect here.  */
block|}
else|else
block|{
comment|/* Output a complex integer type as a structure, 	     pending some other way to do it.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"s%d"
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"real:"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,%d;"
argument_list|,
literal|0
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"imag:"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,%d;;"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SET_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"@s%d;"
argument_list|,
name|BITS_PER_UNIT
operator|*
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if a bitstring type, which in Chill is 	     different from a [power]set. */
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
condition|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"@S;"
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'S'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* Output "a" followed by a range type definition 	 for the index type of the array 	 followed by a reference to the target-type. 	 ar1;0;N;M for a C array of type M and size N+1.  */
comment|/* Check if a character string type, which in Chill is 	 different from an array of characters. */
if|if
condition|(
name|TYPE_STRING_FLAG
argument_list|(
name|type
argument_list|)
operator|&&
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"@S;"
argument_list|)
expr_stmt|;
block|}
name|tem
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"ar%d;0;-1;"
argument_list|,
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|dbxout_range_type
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
name|CHARS
argument_list|(
literal|17
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|n_baseclasses
operator|=
name|TREE_VEC_LENGTH
argument_list|(
name|TYPE_BINFO_BASETYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output a structure type.  We must use the same test here as we 	   use in the DBX_NO_XREFS case above.  */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|full
operator|)
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
comment|/* No way in DBX fmt to describe a variable size.  */
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* If the type is just a cross reference, output one 	       and mark the type as partially described. 	       If it later becomes defined, we will output 	       its real definition. 	       If the type has a name, don't nest its definition within 	       another type's definition; instead, output an xref 	       and let the definition come when the name is defined.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|?
literal|"xs"
else|:
literal|"xu"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This assertion is legitimately false in C++.  */
comment|/* We shouldn't be outputting a reference to a type before its 	       definition unless the type has a tag name. 	       A typedef name without a tag name should be impossible.  */
block|if (TREE_CODE (TYPE_NAME (type)) != IDENTIFIER_NODE) 	      abort ();
endif|#
directive|endif
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
name|dbxout_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"$$%d"
argument_list|,
name|anonymous_type_number
operator|++
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|=
name|TYPE_XREF
expr_stmt|;
break|break;
block|}
comment|/* Identify record or union, and print its size.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|)
condition|?
literal|"s%d"
else|:
literal|"u%d"
argument_list|,
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
if|if
condition|(
name|n_baseclasses
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"!%d,"
argument_list|,
name|n_baseclasses
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|child
init|=
name|TREE_VEC_ELT
argument_list|(
name|BINFO_BASETYPES
argument_list|(
name|TYPE_BINFO
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
name|TREE_VIA_VIRTUAL
argument_list|(
name|child
argument_list|)
condition|?
literal|'1'
else|:
literal|'0'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
name|TREE_VIA_PUBLIC
argument_list|(
name|child
argument_list|)
condition|?
literal|'2'
else|:
literal|'0'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%d,"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|child
argument_list|)
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Print out the base class information with fields 		   which have the same names at the types they hold.  */
name|dbxout_type_name
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|':'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|,
name|full
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%d,%d;"
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|BINFO_OFFSET
argument_list|(
name|child
argument_list|)
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|TYPE_NAME
argument_list|(
name|BINFO_TYPE
argument_list|(
name|child
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|20
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|CHARS
argument_list|(
literal|11
argument_list|)
expr_stmt|;
comment|/* Write out the field declarations.  */
name|dbxout_type_fields
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_METHODS
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|dbxout_type_methods
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
comment|/* Avoid the ~ if we don't really need it--it confuses dbx.  */
operator|&&
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
comment|/* Tell GDB+ that it may keep reading.  */
name|putc
argument_list|(
literal|'~'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
comment|/* We need to write out info about what field this class 	     uses as its "main" vtable pointer field, because if this 	     field is inherited from a base class, GDB cannot necessarily 	     figure out which field it's using in time.  */
if|if
condition|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|putc
argument_list|(
literal|'%'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|DECL_FCONTEXT
argument_list|(
name|TYPE_VFIELD
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENUMERAL_TYPE
case|:
comment|/* We must use the same test here as we use in the DBX_NO_XREFS case 	 above.  We simplify it a bit since an enum will never have a variable 	 size.  */
if|if
condition|(
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
operator|!
name|full
operator|)
operator|||
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"xe"
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|dbxout_type_name
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|typevec
index|[
name|TYPE_SYMTAB_ADDRESS
argument_list|(
name|type
argument_list|)
index|]
operator|=
name|TYPE_XREF
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DBX_OUTPUT_ENUM
name|DBX_OUTPUT_ENUM
argument_list|(
name|asmfile
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"@s%d;"
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'e'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
control|)
block|{
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s:"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|print_int_cst_octal
argument_list|(
name|TREE_VALUE
argument_list|(
name|tem
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|20
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|tem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|CONTIN
expr_stmt|;
block|}
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|POINTER_TYPE
case|:
name|putc
argument_list|(
literal|'*'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|METHOD_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
literal|'#'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_minimal_debug
operator|&&
operator|!
name|show_arg_types
condition|)
block|{
comment|/* Normally, just output the return type. 		 The argument types are encoded in the method name.  */
name|putc
argument_list|(
literal|'#'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* When outputting destructors, we need to write 		 the argument types out longhand.  */
name|dbxout_type
argument_list|(
name|TYPE_METHOD_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_args
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|';'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Treat it as a function type.  */
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OFFSET_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
block|{
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
literal|'@'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TYPE_OFFSET_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Should print as an int, because it is really 	     just an offset.  */
name|dbxout_type
argument_list|(
name|integer_type_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REFERENCE_TYPE
case|:
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
name|have_used_extensions
operator|=
literal|1
expr_stmt|;
name|putc
argument_list|(
name|use_gnu_debug_info_extensions
condition|?
literal|'&'
else|:
literal|'*'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FUNCTION_TYPE
case|:
name|putc
argument_list|(
literal|'f'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the value of integer constant C, in octal,    handling double precision.  */
end_comment

begin_function
specifier|static
name|void
name|print_int_cst_octal
parameter_list|(
name|c
parameter_list|)
name|tree
name|c
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|high
init|=
name|TREE_INT_CST_HIGH
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|low
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|int
name|excess
init|=
operator|(
literal|3
operator|-
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|%
literal|3
operator|)
operator|)
decl_stmt|;
name|int
name|width
init|=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|c
argument_list|)
argument_list|)
decl_stmt|;
comment|/* GDB wants constants with no extra leading "1" bits, so      we need to remove any sign-extension that might be      present.  */
if|if
condition|(
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|width
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|&=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|width
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|==
name|HOST_BITS_PER_WIDE_INT
condition|)
name|high
operator|=
literal|0
expr_stmt|;
else|else
name|high
operator|=
literal|0
operator|,
name|low
operator|&=
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|excess
operator|==
literal|3
condition|)
block|{
name|print_octal
argument_list|(
name|high
argument_list|,
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|3
argument_list|)
expr_stmt|;
name|print_octal
argument_list|(
name|low
argument_list|,
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|beg
init|=
name|high
operator|>>
name|excess
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|middle
init|=
operator|(
operator|(
name|high
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|excess
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
literal|3
operator|-
name|excess
operator|)
operator||
operator|(
name|low
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|3
operator|*
literal|3
operator|)
operator|)
operator|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|end
init|=
name|low
operator|&
operator|(
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|3
operator|*
literal|3
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%o%01o"
argument_list|,
name|beg
argument_list|,
name|middle
argument_list|)
expr_stmt|;
name|print_octal
argument_list|(
name|end
argument_list|,
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_octal
parameter_list|(
name|value
parameter_list|,
name|digits
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|int
name|digits
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|digits
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%01o"
argument_list|,
operator|(
operator|(
name|value
operator|>>
operator|(
literal|3
operator|*
name|i
operator|)
operator|)
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the name of type TYPE, with no punctuation.    Such names can be set up either by typedef declarations    or by struct, enum and union tags.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_type_name
parameter_list|(
name|type
parameter_list|)
specifier|register
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|t
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|t
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
name|IDENTIFIER_LENGTH
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a .stabs for the symbol defined by DECL,    which must be a ..._DECL node in the normal namespace.    It may be a CONST_DECL, a FUNCTION_DECL, a PARM_DECL or a VAR_DECL.    LOCAL is nonzero if the scope is less than the entire file.  */
end_comment

begin_function
name|void
name|dbxout_symbol
parameter_list|(
name|decl
parameter_list|,
name|local
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|local
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|tree
name|context
init|=
name|NULL_TREE
decl_stmt|;
comment|/* Cast avoids warning in old compilers.  */
name|current_sym_code
operator|=
operator|(
name|STAB_CODE_TYPE
operator|)
literal|0
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
comment|/* Ignore nameless syms, but don't ignore type tags.  */
if|if
condition|(
operator|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
operator|)
operator|||
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|dbxout_prepare_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* The output will always start with the symbol name,      so always count that in the length-output-so-far.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|CONST_DECL
case|:
comment|/* Enum values are defined by defining the enum type.  */
break|break;
case|case
name|FUNCTION_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
comment|/* Don't mention a nested function under its parent.  */
name|context
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|current_function_decl
condition|)
break|break;
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
break|break;
name|FORCE_TEXT
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"%s:%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|?
literal|'F'
else|:
literal|'f'
argument_list|)
expr_stmt|;
name|current_sym_code
operator|=
name|N_FUN
expr_stmt|;
name|current_sym_addr
operator|=
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dbxout_type
argument_list|(
name|void_type_node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For a nested function, when that function is compiled, 	 mention the containing function name 	 as well as (since dbx wants it) our own assembler-name.  */
if|if
condition|(
name|context
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|",%s,%s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|context
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_DECL
case|:
if|#
directive|if
literal|0
comment|/* This seems all wrong.  Outputting most kinds of types gives no name 	 at all.  A true definition gives no name; a cross-ref for a 	 structure can give the tag name, but not a type name. 	 It seems that no typedef name is defined by outputting a type.  */
comment|/* If this typedef name was defined by outputting the type, 	 don't duplicate it.  */
block|if (typevec[TYPE_SYMTAB_ADDRESS (type)] == TYPE_DEFINED&& TYPE_NAME (TREE_TYPE (decl)) == decl) 	return;
endif|#
directive|endif
comment|/* Don't output the same typedef twice.          And don't output what language-specific stuff doesn't want output.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|||
name|TYPE_DECL_SUPPRESS_DEBUG
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|FORCE_TEXT
expr_stmt|;
block|{
name|int
name|tag_needed
init|=
literal|1
decl_stmt|;
name|int
name|did_output
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Nonzero means we must output a tag as well as a typedef.  */
name|tag_needed
operator|=
literal|0
expr_stmt|;
comment|/* Handle the case of a C++ structure or union 	       where the TYPE_NAME is a TYPE_DECL 	       which gives both a typedef name and a tag.  */
comment|/* dbx requires the tag first and the typedef second.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|decl
operator|&&
operator|!
operator|(
name|use_gnu_debug_info_extensions
operator|&&
name|have_used_extensions
operator|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
comment|/* Distinguish the implicit typedefs of C++ 		   from explicit ones that might be found in C.  */
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|lang_identify
argument_list|()
argument_list|,
literal|"cplusplus"
argument_list|)
comment|/* The following line maybe unnecessary; 		       in 2.6, try removing it.  */
operator|||
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|current_sym_code
operator|=
name|DBX_TYPE_DECL_STABS_CODE
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"%s:T"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* Output typedef name.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"%s:"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Short cut way to output a tag also.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|QUAL_UNION_TYPE
operator|)
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|decl
condition|)
block|{
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|have_used_extensions
condition|)
block|{
name|putc
argument_list|(
literal|'T'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Now we generate the tag for this case up above.  */
block|else 		  tag_needed = 1;
endif|#
directive|endif
block|}
name|putc
argument_list|(
literal|'t'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|current_sym_code
operator|=
name|DBX_TYPE_DECL_STABS_CODE
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Don't output a tag if this is an incomplete type (TYPE_SIZE is 	   zero).  This prevents the sun4 Sun OS 4.x dbx from crashing.  */
if|if
condition|(
name|tag_needed
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
operator|||
operator|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* For a TYPE_DECL with no name, but the type has a name, 	       output a tag. 	       This is what represents `struct foo' with no typedef.  */
comment|/* In C++, the name of a type is the corresponding typedef. 	       In C, it is an IDENTIFIER_NODE.  */
name|tree
name|name
init|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|name
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|name
operator|=
name|DECL_NAME
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|current_sym_code
operator|=
name|DBX_TYPE_DECL_STABS_CODE
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"%s:T"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If an enum type has no name, it cannot be referred to, 	   but we must output it anyway, since the enumeration constants 	   can be referred to.  */
if|if
condition|(
operator|!
name|did_output
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|current_sym_code
operator|=
name|DBX_TYPE_DECL_STABS_CODE
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|current_sym_nchars
operator|=
literal|2
expr_stmt|;
comment|/* Some debuggers fail when given NULL names, so give this a 	       harmless name of ` '.  */
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \" :T"
argument_list|,
name|ASM_STABS_OP
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
comment|/* Prevent duplicate output of a typedef.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|PARM_DECL
case|:
comment|/* Parm decls go in their own separate chains 	 and are output by dbxout_reg_parms and dbxout_parms.  */
name|abort
argument_list|()
expr_stmt|;
case|case
name|RESULT_DECL
case|:
comment|/* Named return value, treat like a VAR_DECL.  */
case|case
name|VAR_DECL
case|:
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Don't mention a variable that is external. 	 Let the file that defines it describe it.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
break|break;
comment|/* If the variable is really a constant 	 and not written in memory, inform the debugger.  */
if|if
condition|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
operator|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|DECL_FIELD_CONTEXT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BLOCK
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The sun4 assembler does not grok this.  */
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
name|HOST_WIDE_INT
name|ival
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DBX_OUTPUT_CONSTANT_SYMBOL
name|DBX_OUTPUT_CONSTANT_SYMBOL
argument_list|(
name|asmfile
argument_list|,
name|name
argument_list|,
name|ival
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"%s:c=i%d\",0x%x,0,0,0\n"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|name
argument_list|,
name|ival
argument_list|,
name|N_LSYM
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
block|{
comment|/* don't know how to do this yet.  */
block|}
break|break;
block|}
comment|/* else it is something we handle like a normal variable.  */
block|}
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|leaf_function
condition|)
name|leaf_renumber_regs_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the stab for DECL, a VAR_DECL, RESULT_DECL or PARM_DECL.    Add SUFFIX to its name, if SUFFIX is not 0.    Describe the variable as residing in HOME    (usually HOME is DECL_RTL (DECL), but not always).  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_symbol_location
parameter_list|(
name|decl
parameter_list|,
name|type
parameter_list|,
name|suffix
parameter_list|,
name|home
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|rtx
name|home
decl_stmt|;
block|{
name|int
name|letter
init|=
literal|0
decl_stmt|;
name|int
name|regno
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Don't mention a variable at all      if it was completely optimized into nothingness.            If the decl was from an inline function, then it's rtl      is not identically the rtl that was used in this      particular compilation.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|home
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|rtx
name|value
init|=
name|home
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|SUBREG_REG
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
condition|)
block|{
name|regno
operator|=
name|REGNO
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
return|return;
name|regno
operator|+=
name|offset
expr_stmt|;
block|}
name|alter_subreg
argument_list|(
name|home
argument_list|)
expr_stmt|;
block|}
comment|/* The kind-of-variable letter depends on where      the variable is and on the scope of its name:      G and N_GSYM for static storage and global scope,      S for static storage and file scope,      V for static storage and local scope,      for those two, use N_LCSYM if data is in bss segment,      N_STSYM if in data segment, N_FUN otherwise.      (We used N_FUN originally, then changed to N_STSYM      to please GDB.  However, it seems that confused ld.      Now GDB has been fixed to like N_FUN, says Kingdon.)      no letter at all, and N_LSYM, for auto variable,      r and N_RSYM for register variable.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|letter
operator|=
literal|'G'
expr_stmt|;
name|current_sym_code
operator|=
name|N_GSYM
expr_stmt|;
block|}
else|else
block|{
name|current_sym_addr
operator|=
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|letter
operator|=
name|decl_function_context
argument_list|(
name|decl
argument_list|)
condition|?
literal|'V'
else|:
literal|'S'
expr_stmt|;
comment|/* This should be the same condition as in assemble_variable, but 	     we don't have access to dont_output_data here.  So, instead, 	     we rely on the fact that error_mark_node initializers always 	     end up in bss for C++ and never end up in bss for C.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|lang_identify
argument_list|()
argument_list|,
literal|"cplusplus"
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
name|current_sym_code
operator|=
name|N_LCSYM
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_IN_TEXT_SECTION
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* This is not quite right, but it's the closest 	       of all the codes that Unix defines.  */
name|current_sym_code
operator|=
name|DBX_STATIC_CONST_VAR_CODE
expr_stmt|;
else|else
block|{
comment|/* Ultrix `as' seems to need this.  */
ifdef|#
directive|ifdef
name|DBX_STATIC_STAB_DATA_SECTION
name|data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|current_sym_code
operator|=
name|N_STSYM
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|letter
operator|=
literal|'r'
expr_stmt|;
name|current_sym_code
operator|=
name|N_RSYM
expr_stmt|;
name|current_sym_value
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
operator|||
operator|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|)
operator|)
condition|)
comment|/* If the value is indirect by memory or by a register        that isn't the frame pointer        then it means the object is variable-sized and address through        that register or stack slot.  DBX has no way to represent this        so all we can do is output the variable as a pointer.        If it's not a parameter, ignore it.        (VAR_DECLs like this can be made by integrate.c.)  */
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|letter
operator|=
literal|'r'
expr_stmt|;
name|current_sym_code
operator|=
name|N_RSYM
expr_stmt|;
name|current_sym_value
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
comment|/* RTL looks like (MEM (MEM (PLUS (REG...) (CONST_INT...)))). 	     We want the value of that CONST_INT.  */
name|current_sym_value
operator|=
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Effectively do build_pointer_type, but don't cache this type, 	 since it might be temporary whereas the type it points to 	 might have been saved for inlining.  */
comment|/* Don't use REFERENCE_TYPE because dbx can't handle that.  */
name|type
operator|=
name|make_node
argument_list|(
name|POINTER_TYPE
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
name|current_sym_value
operator|=
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|current_sym_code
operator|=
name|N_LSYM
expr_stmt|;
comment|/* RTL looks like (MEM (PLUS (REG...) (CONST_INT...))) 	 We want the value of that CONST_INT.  */
name|current_sym_value
operator|=
name|DEBUGGER_AUTO_OFFSET
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST
condition|)
block|{
comment|/* Handle an obscure case which can arise when optimizing and 	 when there are few available registers.  (This is *always* 	 the case for i386/i486 targets).  The RTL looks like 	 (MEM (CONST ...)) even though this variable is a local `auto' 	 or a local `register' variable.  In effect, what has happened 	 is that the reload pass has seen that all assignments and 	 references for one such a local variable can be replaced by 	 equivalent assignments and references to some static storage 	 variable, thereby avoiding the need for a register.  In such 	 cases we're forced to lie to debuggers and tell them that 	 this variable was itself `static'.  */
name|current_sym_code
operator|=
name|N_LCSYM
expr_stmt|;
name|letter
operator|=
literal|'V'
expr_stmt|;
name|current_sym_addr
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|home
argument_list|)
operator|==
name|CONCAT
condition|)
block|{
name|tree
name|subtype
init|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* If the variable's storage is in two parts, 	 output each as a separate stab with a modified name.  */
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$imag"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$real"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cast avoids warning in old compilers.  */
name|current_sym_code
operator|=
operator|(
name|STAB_CODE_TYPE
operator|)
literal|0
expr_stmt|;
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|dbxout_prepare_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|WORDS_BIG_ENDIAN
condition|)
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$real"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|dbxout_symbol_location
argument_list|(
name|decl
argument_list|,
name|subtype
argument_list|,
literal|"$imag"
argument_list|,
name|XEXP
argument_list|(
name|home
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
comment|/* Address might be a MEM, when DECL is a variable-sized object.        Or it might be const0_rtx, meaning previous passes        want us to ignore this variable.  */
return|return;
comment|/* Ok, start a symtab entry and output the variable name.  */
name|FORCE_TEXT
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_STATIC_BLOCK_START
name|DBX_STATIC_BLOCK_START
argument_list|(
name|asmfile
argument_list|,
name|current_sym_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dbxout_symbol_name
argument_list|(
name|decl
argument_list|,
name|suffix
argument_list|,
name|letter
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|decl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_STATIC_BLOCK_END
name|DBX_STATIC_BLOCK_END
argument_list|(
name|asmfile
argument_list|,
name|current_sym_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output the symbol name of DECL for a stabs, with suffix SUFFIX.    Then output LETTER to indicate the kind of location the symbol has.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_symbol_name
parameter_list|(
name|decl
parameter_list|,
name|suffix
parameter_list|,
name|letter
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|suffix
decl_stmt|;
name|int
name|letter
decl_stmt|;
block|{
comment|/* One slight hitch: if this is a VAR_DECL which is a static      class member, we must put out the mangled name instead of the      DECL_NAME.  Note also that static member (variable) names DO NOT begin      with underscores in .stabs directives.  */
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|name
operator|=
literal|"(anon)"
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"%s%s:"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|name
argument_list|,
operator|(
name|suffix
condition|?
name|suffix
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|letter
condition|)
name|putc
argument_list|(
name|letter
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dbxout_prepare_symbol
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|WINNING_GDB
name|char
modifier|*
name|filename
init|=
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|dbxout_source_file
argument_list|(
name|asmfile
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|dbxout_finish_symbol
parameter_list|(
name|sym
parameter_list|)
name|tree
name|sym
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DBX_FINISH_SYMBOL
name|DBX_FINISH_SYMBOL
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|line
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
operator|&&
name|sym
operator|!=
literal|0
condition|)
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\",%d,0,%d,"
argument_list|,
name|current_sym_code
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_sym_addr
condition|)
name|output_addr_const
argument_list|(
name|asmfile
argument_list|,
name|current_sym_addr
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%d"
argument_list|,
name|current_sym_value
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output definitions of all the decls in a chain.  */
end_comment

begin_function
name|void
name|dbxout_syms
parameter_list|(
name|syms
parameter_list|)
name|tree
name|syms
decl_stmt|;
block|{
while|while
condition|(
name|syms
condition|)
block|{
name|dbxout_symbol
argument_list|(
name|syms
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|syms
operator|=
name|TREE_CHAIN
argument_list|(
name|syms
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following two functions output definitions of function parameters.    Each parameter gets a definition locating it in the parameter list.    Each parameter that is a register variable gets a second definition    locating it in the register.     Printing or argument lists in gdb uses the definitions that    locate in the parameter list.  But reference to the variable in    expressions uses preferentially the definition as a register.  */
end_comment

begin_comment
comment|/* Output definitions, referring to storage in the parmlist,    of all the parms in PARMS, which is a chain of PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|dbxout_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|dbxout_prepare_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* Perform any necessary register eliminations on the parameter's rtl, 	   so that the debugging output will be accurate.  */
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
operator|=
name|eliminate_regs
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAF_REG_REMAP
if|if
condition|(
name|leaf_function
condition|)
block|{
name|leaf_renumber_regs_insn
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|leaf_renumber_regs_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|PARM_PASSED_IN_MEMORY
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|rtx
name|addr
init|=
name|XEXP
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* ??? Here we assume that the parm address is indexed 	       off the frame pointer or arg pointer. 	       If that is not true, we produce meaningless results, 	       but do not crash.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
name|current_sym_value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|current_sym_value
operator|=
literal|0
expr_stmt|;
name|current_sym_code
operator|=
name|N_PSYM
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"%s:%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|DBX_MEMPARM_STABS_LETTER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_sym_nchars
operator|=
literal|8
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"(anon):%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|DBX_MEMPARM_STABS_LETTER
argument_list|)
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_sym_value
operator|=
name|DEBUGGER_ARG_OFFSET
argument_list|(
name|current_sym_value
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
block|{
name|rtx
name|best_rtl
decl_stmt|;
name|char
name|regparm_letter
decl_stmt|;
name|tree
name|parm_type
decl_stmt|;
comment|/* Parm passed in registers and lives in registers or nowhere.  */
name|current_sym_code
operator|=
name|DBX_REGPARM_STABS_CODE
expr_stmt|;
name|regparm_letter
operator|=
name|DBX_REGPARM_STABS_LETTER
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
comment|/* If parm lives in a register, use that register; 	       pretend the parm was passed there.  It would be more consistent 	       to describe the register where the parm was passed, 	       but in practice that register usually holds something else.  	       If we use DECL_RTL, then we must use the declared type of 	       the variable, not the type that it arrived in.  */
if|if
condition|(
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|best_rtl
operator|=
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parm_type
operator|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
comment|/* If the parm lives nowhere, use the register where it was 	       passed.  It is also better to use the declared type here.  */
else|else
block|{
name|best_rtl
operator|=
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
expr_stmt|;
name|parm_type
operator|=
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
name|current_sym_value
operator|=
name|DBX_REGISTER_NUMBER
argument_list|(
name|REGNO
argument_list|(
name|best_rtl
argument_list|)
argument_list|)
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|current_sym_nchars
operator|=
literal|2
operator|+
name|IDENTIFIER_LENGTH
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"%s:%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|regparm_letter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_sym_nchars
operator|=
literal|8
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"(anon):%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|regparm_letter
argument_list|)
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
name|parm_type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|STACK_POINTER_REGNUM
if|#
directive|if
name|ARG_POINTER_REGNUM
operator|!=
name|HARD_FRAME_POINTER_REGNUM
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|!=
name|ARG_POINTER_REGNUM
endif|#
directive|endif
condition|)
block|{
comment|/* Parm was passed via invisible reference. 	       That is, its address was passed in a register. 	       Output it as if it lived in that register. 	       The debugger will know from the type 	       that it was actually passed by invisible reference.  */
name|char
name|regparm_letter
decl_stmt|;
comment|/* Parm passed in registers and lives in registers or nowhere.  */
name|current_sym_code
operator|=
name|DBX_REGPARM_STABS_CODE
expr_stmt|;
if|if
condition|(
name|use_gnu_debug_info_extensions
condition|)
name|regparm_letter
operator|=
name|GDB_INV_REF_REGPARM_STABS_LETTER
expr_stmt|;
else|else
name|regparm_letter
operator|=
name|DBX_REGPARM_STABS_LETTER
expr_stmt|;
comment|/* DECL_RTL looks like (MEM (REG...).  Get the register number. 	       If it is an unallocated pseudo-reg, then use the register where 	       it was passed instead.  */
if|if
condition|(
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|current_sym_value
operator|=
name|REGNO
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|current_sym_value
operator|=
name|REGNO
argument_list|(
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|current_sym_nchars
operator|=
literal|2
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"%s:%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|regparm_letter
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_sym_nchars
operator|=
literal|8
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"(anon):%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|regparm_letter
argument_list|)
expr_stmt|;
block|}
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|const0_rtx
comment|/* ??? A constant address for a parm can happen 		    when the reg it lives in is equiv to a constant in memory. 		    Should make this not happen, after 2.4.  */
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Parm was passed in registers but lives on the stack.  */
name|current_sym_code
operator|=
name|N_PSYM
expr_stmt|;
comment|/* DECL_RTL looks like (MEM (PLUS (REG...) (CONST_INT...))), 	       in which case we want the value of that CONST_INT, 	       or (MEM (REG ...)) or (MEM (MEM ...)), 	       in which case we use a value of zero.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
name|current_sym_value
operator|=
literal|0
expr_stmt|;
else|else
name|current_sym_value
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|current_sym_addr
operator|=
literal|0
expr_stmt|;
name|FORCE_TEXT
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|current_sym_nchars
operator|=
literal|2
operator|+
name|strlen
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"%s:%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
argument_list|)
argument_list|,
name|DBX_MEMPARM_STABS_LETTER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_sym_nchars
operator|=
literal|8
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"(anon):%c"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|DBX_MEMPARM_STABS_LETTER
argument_list|)
expr_stmt|;
block|}
name|current_sym_value
operator|=
name|DEBUGGER_ARG_OFFSET
argument_list|(
name|current_sym_value
argument_list|,
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_finish_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output definitions for the places where parms live during the function,    when different from where they were passed, when the parms were passed    in memory.     It is not useful to do this for parms passed in registers    that live during the function in different registers, because it is    impossible to look in the passed register for the passed value,    so we use the within-the-function register to begin with.     PARMS is a chain of PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|dbxout_reg_parms
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
for|for
control|(
init|;
name|parms
condition|;
name|parms
operator|=
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
operator|&&
name|PARM_PASSED_IN_MEMORY
argument_list|(
name|parms
argument_list|)
condition|)
block|{
name|dbxout_prepare_symbol
argument_list|(
name|parms
argument_list|)
expr_stmt|;
comment|/* Report parms that live in registers during the function 	   but were passed in memory.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|>=
literal|0
operator|&&
name|REGNO
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|dbxout_symbol_location
argument_list|(
name|parms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|CONCAT
condition|)
name|dbxout_symbol_location
argument_list|(
name|parms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Report parms that live in memory but not where they were passed.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|rtx_equal_p
argument_list|(
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|,
name|DECL_INCOMING_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
condition|)
name|dbxout_symbol_location
argument_list|(
name|parms
argument_list|,
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_RTL
argument_list|(
name|parms
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a chain of ..._TYPE nodes (as come in a parameter list),    output definitions of those names, in raw form */
end_comment

begin_function
name|void
name|dbxout_args
parameter_list|(
name|args
parameter_list|)
name|tree
name|args
decl_stmt|;
block|{
while|while
condition|(
name|args
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|dbxout_type
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHARS
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a chain of ..._TYPE nodes,    find those which have typedef names and output those names.    This is to ensure those types get output.  */
end_comment

begin_function
name|void
name|dbxout_types
parameter_list|(
name|types
parameter_list|)
specifier|register
name|tree
name|types
decl_stmt|;
block|{
while|while
condition|(
name|types
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|types
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|types
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|TYPE_NAME
argument_list|(
name|types
argument_list|)
argument_list|)
condition|)
name|dbxout_symbol
argument_list|(
name|TYPE_NAME
argument_list|(
name|types
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|types
operator|=
name|TREE_CHAIN
argument_list|(
name|types
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output everything about a symbol block (a BLOCK node    that represents a scope level),    including recursive output of contained blocks.     BLOCK is the BLOCK node.    DEPTH is its depth within containing symbol blocks.    ARGS is usually zero; but for the outermost block of the    body of a function, it is a chain of PARM_DECLs for the function parameters.    We output definitions of all the register parms    as if they were local variables of that block.     If -g1 was used, we count blocks just the same, but output nothing    except for the outermost block.     Actually, BLOCK may be several blocks chained together.    We handle them all in sequence.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_block
parameter_list|(
name|block
parameter_list|,
name|depth
parameter_list|,
name|args
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|tree
name|args
decl_stmt|;
block|{
name|int
name|blocknum
decl_stmt|;
while|while
condition|(
name|block
condition|)
block|{
comment|/* Ignore blocks never expanded or otherwise marked as real.  */
if|if
condition|(
name|TREE_USED
argument_list|(
name|block
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|DBX_LBRAC_FIRST
comment|/* In dbx format, the syms of a block come before the N_LBRAC.  */
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
operator|||
name|depth
operator|==
literal|0
condition|)
name|dbxout_syms
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|dbxout_reg_parms
argument_list|(
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now output an N_LBRAC symbol to represent the beginning of 	     the block.  Use the block's tree-walk order to generate 	     the assembler symbols LBBn and LBEn 	     that final will define around the code in this block.  */
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|blocknum
operator|=
name|next_block_number
operator|++
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LBB"
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_HANDLER_BLOCK
argument_list|(
name|block
argument_list|)
condition|)
block|{
comment|/* A catch block.  Must precede N_LBRAC.  */
name|tree
name|decl
init|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
decl_stmt|;
while|while
condition|(
name|decl
condition|)
block|{
ifdef|#
directive|ifdef
name|DBX_OUTPUT_CATCH
name|DBX_OUTPUT_CATCH
argument_list|(
name|asmfile
argument_list|,
name|decl
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s \"%s:C1\",%d,0,0,"
argument_list|,
name|ASM_STABS_OP
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|N_CATCH
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DBX_OUTPUT_LBRAC
name|DBX_OUTPUT_LBRAC
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s %d,0,0,"
argument_list|,
name|ASM_STABN_OP
argument_list|,
name|N_LBRAC
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
name|DBX_BLOCKS_FUNCTION_RELATIVE
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|depth
operator|>
literal|0
condition|)
comment|/* Count blocks the same way regardless of debug_info_level.  */
name|next_block_number
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_LBRAC_FIRST
comment|/* On some weird machines, the syms of a block 	     come after the N_LBRAC.  */
if|if
condition|(
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
operator|||
name|depth
operator|==
literal|0
condition|)
name|dbxout_syms
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
name|dbxout_reg_parms
argument_list|(
name|args
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Output the subblocks.  */
name|dbxout_block
argument_list|(
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
argument_list|,
name|depth
operator|+
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* Refer to the marker for the end of the block.  */
if|if
condition|(
name|depth
operator|>
literal|0
operator|&&
name|debug_info_level
operator|!=
name|DINFO_LEVEL_TERSE
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|buf
argument_list|,
literal|"LBE"
argument_list|,
name|blocknum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_OUTPUT_RBRAC
name|DBX_OUTPUT_RBRAC
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"%s %d,0,0,"
argument_list|,
name|ASM_STABN_OP
argument_list|,
name|N_RBRAC
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
name|DBX_BLOCKS_FUNCTION_RELATIVE
name|fputc
argument_list|(
literal|'-'
argument_list|,
name|asmfile
argument_list|)
expr_stmt|;
name|assemble_name
argument_list|(
name|asmfile
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|asmfile
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|block
operator|=
name|BLOCK_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Output the information about a function and its arguments and result.    Usually this follows the function's code,    but on some systems, it comes before.  */
end_comment

begin_function
specifier|static
name|void
name|dbxout_really_begin_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dbxout_parms
argument_list|(
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|dbxout_symbol
argument_list|(
name|DECL_RESULT
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at beginning of output of function definition.  */
end_comment

begin_function
name|void
name|dbxout_begin_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DBX_FUNCTION_FIRST
name|dbxout_really_begin_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|DBX_CHECK_FUNCTION_FIRST
if|if
condition|(
name|DBX_CHECK_FUNCTION_FIRST
condition|)
name|dbxout_really_begin_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Output dbx data for a function definition.    This includes a definition of the function name itself (a symbol),    definitions of the parameters (locating them in the parameter list)    and then output the block that makes up the function's body    (including all the auto variables of the function).  */
end_comment

begin_function
name|void
name|dbxout_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|DBX_FUNCTION_FIRST
name|dbxout_really_begin_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|DBX_CHECK_FUNCTION_FIRST
if|if
condition|(
operator|!
operator|(
name|DBX_CHECK_FUNCTION_FIRST
operator|)
condition|)
name|dbxout_really_begin_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|dbxout_block
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_OUTPUT_FUNCTION_END
name|DBX_OUTPUT_FUNCTION_END
argument_list|(
name|asmfile
argument_list|,
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DBX_DEBUGGING_INFO */
end_comment

end_unit

