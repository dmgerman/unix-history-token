begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate the machine mode enumeration and associated tables.    Copyright (C) 2003, 2004    Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"bconfig.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"errors.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_comment
comment|/* enum mode_class is normally defined by machmode.h but we can't    include that header here.  */
end_comment

begin_include
include|#
directive|include
file|"mode-classes.def"
end_include

begin_define
define|#
directive|define
name|DEF_MODE_CLASS
parameter_list|(
name|M
parameter_list|)
value|M
end_define

begin_enum
enum|enum
name|mode_class
block|{
name|MODE_CLASSES
block|,
name|MAX_MODE_CLASS
block|}
enum|;
end_enum

begin_undef
undef|#
directive|undef
name|DEF_MODE_CLASS
end_undef

begin_comment
comment|/* Text names of mode classes, for output.  */
end_comment

begin_define
define|#
directive|define
name|DEF_MODE_CLASS
parameter_list|(
name|M
parameter_list|)
value|#M
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|mode_class_names
index|[
name|MAX_MODE_CLASS
index|]
init|=
block|{
name|MODE_CLASSES
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEF_MODE_CLASS
end_undef

begin_undef
undef|#
directive|undef
name|MODE_CLASSES
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_MODES_FILE
end_ifdef

begin_define
define|#
directive|define
name|HAVE_EXTRA_MODES
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HAVE_EXTRA_MODES
value|0
end_define

begin_define
define|#
directive|define
name|EXTRA_MODES_FILE
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Data structure for building up what we know about a mode.    They're clustered by mode class.  */
end_comment

begin_struct
struct|struct
name|mode_data
block|{
name|struct
name|mode_data
modifier|*
name|next
decl_stmt|;
comment|/* next this class - arbitrary order */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* printable mode name -- SI, not SImode */
name|enum
name|mode_class
name|cl
decl_stmt|;
comment|/* this mode class */
name|unsigned
name|int
name|precision
decl_stmt|;
comment|/* size in bits, equiv to TYPE_PRECISION */
name|unsigned
name|int
name|bytesize
decl_stmt|;
comment|/* storage size in addressable units */
name|unsigned
name|int
name|ncomponents
decl_stmt|;
comment|/* number of subunits */
name|unsigned
name|int
name|alignment
decl_stmt|;
comment|/* mode alignment */
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
comment|/* floating point format - float modes only */
name|struct
name|mode_data
modifier|*
name|component
decl_stmt|;
comment|/* mode of components */
name|struct
name|mode_data
modifier|*
name|wider
decl_stmt|;
comment|/* next wider mode */
name|struct
name|mode_data
modifier|*
name|wider_2x
decl_stmt|;
comment|/* 2x wider mode */
name|struct
name|mode_data
modifier|*
name|contained
decl_stmt|;
comment|/* Pointer to list of modes that have 				   this mode as a component.  */
name|struct
name|mode_data
modifier|*
name|next_cont
decl_stmt|;
comment|/* Next mode in that list.  */
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
comment|/* file and line of definition, */
name|unsigned
name|int
name|line
decl_stmt|;
comment|/* for error reporting */
name|unsigned
name|int
name|counter
decl_stmt|;
comment|/* Rank ordering of modes */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mode_data
modifier|*
name|modes
index|[
name|MAX_MODE_CLASS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|n_modes
index|[
name|MAX_MODE_CLASS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mode_data
modifier|*
name|void_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mode_data
name|blank_mode
init|=
block|{
literal|0
block|,
literal|"<unknown>"
block|,
name|MAX_MODE_CLASS
block|,
operator|-
literal|1U
block|,
operator|-
literal|1U
block|,
operator|-
literal|1U
block|,
operator|-
literal|1U
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"<unknown>"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|htab_t
name|modes_by_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structure for recording target-specified runtime adjustments    to a particular mode.  We support varying the byte size, the    alignment, and the floating point format.  */
end_comment

begin_struct
struct|struct
name|mode_adjust
block|{
name|struct
name|mode_adjust
modifier|*
name|next
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|adjustment
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mode_adjust
modifier|*
name|adj_bytesize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mode_adjust
modifier|*
name|adj_alignment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mode_adjust
modifier|*
name|adj_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mode class operations.  */
end_comment

begin_function
specifier|static
name|enum
name|mode_class
name|complex_class
parameter_list|(
name|enum
name|mode_class
name|c
parameter_list|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|MODE_INT
case|:
return|return
name|MODE_COMPLEX_INT
return|;
case|case
name|MODE_FLOAT
case|:
return|return
name|MODE_COMPLEX_FLOAT
return|;
default|default:
name|error
argument_list|(
literal|"no complex class for class %s"
argument_list|,
name|mode_class_names
index|[
name|c
index|]
argument_list|)
expr_stmt|;
return|return
name|MODE_RANDOM
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|mode_class
name|vector_class
parameter_list|(
name|enum
name|mode_class
name|cl
parameter_list|)
block|{
switch|switch
condition|(
name|cl
condition|)
block|{
case|case
name|MODE_INT
case|:
return|return
name|MODE_VECTOR_INT
return|;
case|case
name|MODE_FLOAT
case|:
return|return
name|MODE_VECTOR_FLOAT
return|;
default|default:
name|error
argument_list|(
literal|"no vector class for class %s"
argument_list|,
name|mode_class_names
index|[
name|cl
index|]
argument_list|)
expr_stmt|;
return|return
name|MODE_RANDOM
return|;
block|}
block|}
end_function

begin_comment
comment|/* Utility routines.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|mode_data
modifier|*
name|find_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|mode_data
name|key
decl_stmt|;
name|key
operator|.
name|name
operator|=
name|name
expr_stmt|;
return|return
operator|(
expr|struct
name|mode_data
operator|*
operator|)
name|htab_find
argument_list|(
name|modes_by_name
argument_list|,
operator|&
name|key
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mode_data
modifier|*
name|new_mode
parameter_list|(
name|enum
name|mode_class
name|cl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
specifier|static
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|m
operator|=
name|find_mode
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: duplicate definition of mode \"%s\""
argument_list|,
name|trim_filename
argument_list|(
name|file
argument_list|)
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%s:%d: previous definition here"
argument_list|,
name|m
operator|->
name|file
argument_list|,
name|m
operator|->
name|line
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
name|m
operator|=
name|XNEW
argument_list|(
expr|struct
name|mode_data
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|m
argument_list|,
operator|&
name|blank_mode
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mode_data
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|cl
operator|=
name|cl
expr_stmt|;
name|m
operator|->
name|name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|m
operator|->
name|file
operator|=
name|trim_filename
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|m
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|m
operator|->
name|counter
operator|=
name|count
operator|++
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|modes
index|[
name|cl
index|]
expr_stmt|;
name|modes
index|[
name|cl
index|]
operator|=
name|m
expr_stmt|;
name|n_modes
index|[
name|cl
index|]
operator|++
expr_stmt|;
operator|*
name|htab_find_slot
argument_list|(
name|modes_by_name
argument_list|,
name|m
argument_list|,
name|INSERT
argument_list|)
operator|=
name|m
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|hashval_t
name|hash_mode
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|struct
name|mode_data
modifier|*
name|m
init|=
operator|(
specifier|const
expr|struct
name|mode_data
operator|*
operator|)
name|p
decl_stmt|;
return|return
name|htab_hash_string
argument_list|(
name|m
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|eq_mode
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|q
parameter_list|)
block|{
specifier|const
name|struct
name|mode_data
modifier|*
name|a
init|=
operator|(
specifier|const
expr|struct
name|mode_data
operator|*
operator|)
name|p
decl_stmt|;
specifier|const
name|struct
name|mode_data
modifier|*
name|b
init|=
operator|(
specifier|const
expr|struct
name|mode_data
operator|*
operator|)
name|q
decl_stmt|;
return|return
operator|!
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|for_all_modes
parameter_list|(
name|C
parameter_list|,
name|M
parameter_list|)
define|\
value|for (C = 0; C< MAX_MODE_CLASS; C++)		\     for (M = modes[C]; M; M = M->next)
end_define

begin_function
specifier|static
name|void
name|ATTRIBUTE_UNUSED
name|new_adjust
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|mode_adjust
modifier|*
modifier|*
name|category
parameter_list|,
specifier|const
name|char
modifier|*
name|catname
parameter_list|,
specifier|const
name|char
modifier|*
name|adjustment
parameter_list|,
name|enum
name|mode_class
name|required_class
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|mode
init|=
name|find_mode
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|struct
name|mode_adjust
modifier|*
name|a
decl_stmt|;
name|file
operator|=
name|trim_filename
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: no mode \"%s\""
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|required_class
operator|!=
name|MODE_RANDOM
operator|&&
name|mode
operator|->
name|cl
operator|!=
name|required_class
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: mode \"%s\" is not class %s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|,
name|mode_class_names
index|[
name|required_class
index|]
operator|+
literal|5
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|a
operator|=
operator|*
name|category
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
if|if
condition|(
name|a
operator|->
name|mode
operator|==
name|mode
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: mode \"%s\" already has a %s adjustment"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|,
name|catname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%s:%d: previous adjustment here"
argument_list|,
name|a
operator|->
name|file
argument_list|,
name|a
operator|->
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
name|a
operator|=
name|XNEW
argument_list|(
expr|struct
name|mode_adjust
argument_list|)
expr_stmt|;
name|a
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|a
operator|->
name|adjustment
operator|=
name|adjustment
expr_stmt|;
name|a
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|a
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|a
operator|->
name|next
operator|=
operator|*
name|category
expr_stmt|;
operator|*
name|category
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Diagnose failure to meet expectations in a partially filled out    mode structure.  */
end_comment

begin_enum
enum|enum
name|requirement
block|{
name|SET
block|,
name|UNSET
block|,
name|OPTIONAL
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|validate_field_
parameter_list|(
name|mname
parameter_list|,
name|fname
parameter_list|,
name|req
parameter_list|,
name|val
parameter_list|,
name|unset
parameter_list|,
name|file
parameter_list|,
name|line
parameter_list|)
value|do {	\   switch (req)								\     {									\     case SET:								\       if (val == unset)							\ 	error ("%s:%d: (%s) field %s must be set",			\ 	       file, line, mname, fname);				\       break;								\     case UNSET:								\       if (val != unset)							\ 	error ("%s:%d: (%s) field %s must not be set",			\ 	       file, line, mname, fname);				\     case OPTIONAL:							\       break;								\     }									\ } while (0)
end_define

begin_define
define|#
directive|define
name|validate_field
parameter_list|(
name|M
parameter_list|,
name|F
parameter_list|)
define|\
value|validate_field_(M->name, #F, r_##F, M->F, blank_mode.F, M->file, M->line)
end_define

begin_function
specifier|static
name|void
name|validate_mode
parameter_list|(
name|struct
name|mode_data
modifier|*
name|m
parameter_list|,
name|enum
name|requirement
name|r_precision
parameter_list|,
name|enum
name|requirement
name|r_bytesize
parameter_list|,
name|enum
name|requirement
name|r_component
parameter_list|,
name|enum
name|requirement
name|r_ncomponents
parameter_list|,
name|enum
name|requirement
name|r_format
parameter_list|)
block|{
name|validate_field
argument_list|(
name|m
argument_list|,
name|precision
argument_list|)
expr_stmt|;
name|validate_field
argument_list|(
name|m
argument_list|,
name|bytesize
argument_list|)
expr_stmt|;
name|validate_field
argument_list|(
name|m
argument_list|,
name|component
argument_list|)
expr_stmt|;
name|validate_field
argument_list|(
name|m
argument_list|,
name|ncomponents
argument_list|)
expr_stmt|;
name|validate_field
argument_list|(
name|m
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|validate_field
end_undef

begin_undef
undef|#
directive|undef
name|validate_field_
end_undef

begin_comment
comment|/* Given a partially-filled-out mode structure, figure out what we can    and fill the rest of it in; die if it isn't enough.  */
end_comment

begin_function
specifier|static
name|void
name|complete_mode
parameter_list|(
name|struct
name|mode_data
modifier|*
name|m
parameter_list|)
block|{
name|unsigned
name|int
name|alignment
decl_stmt|;
if|if
condition|(
operator|!
name|m
operator|->
name|name
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: mode with no name"
argument_list|,
name|m
operator|->
name|file
argument_list|,
name|m
operator|->
name|line
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m
operator|->
name|cl
operator|==
name|MAX_MODE_CLASS
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: %smode has no mode class"
argument_list|,
name|m
operator|->
name|file
argument_list|,
name|m
operator|->
name|line
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|m
operator|->
name|cl
condition|)
block|{
case|case
name|MODE_RANDOM
case|:
comment|/* Nothing more need be said.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|m
operator|->
name|name
argument_list|,
literal|"VOID"
argument_list|)
condition|)
name|void_mode
operator|=
name|m
expr_stmt|;
name|validate_mode
argument_list|(
name|m
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|)
expr_stmt|;
name|m
operator|->
name|precision
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|bytesize
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|ncomponents
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|component
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODE_CC
case|:
comment|/* Again, nothing more need be said.  For historical reasons, 	 the size of a CC mode is four units.  */
name|validate_mode
argument_list|(
name|m
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|)
expr_stmt|;
name|m
operator|->
name|bytesize
operator|=
literal|4
expr_stmt|;
name|m
operator|->
name|ncomponents
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|component
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODE_INT
case|:
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_DECIMAL_FLOAT
case|:
comment|/* A scalar mode must have a byte size, may have a bit size, 	 and must not have components.   A float mode must have a          format.  */
name|validate_mode
argument_list|(
name|m
argument_list|,
name|OPTIONAL
argument_list|,
name|SET
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|,
name|m
operator|->
name|cl
operator|!=
name|MODE_INT
condition|?
name|SET
else|:
name|UNSET
argument_list|)
expr_stmt|;
name|m
operator|->
name|ncomponents
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|component
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MODE_PARTIAL_INT
case|:
comment|/* A partial integer mode uses ->component to say what the 	 corresponding full-size integer mode is, and may also 	 specify a bit size.  */
name|validate_mode
argument_list|(
name|m
argument_list|,
name|OPTIONAL
argument_list|,
name|UNSET
argument_list|,
name|SET
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|)
expr_stmt|;
name|m
operator|->
name|bytesize
operator|=
name|m
operator|->
name|component
operator|->
name|bytesize
expr_stmt|;
name|m
operator|->
name|ncomponents
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|component
operator|=
literal|0
expr_stmt|;
comment|/* ??? preserve this */
break|break;
case|case
name|MODE_COMPLEX_INT
case|:
case|case
name|MODE_COMPLEX_FLOAT
case|:
comment|/* Complex modes should have a component indicated, but no more.  */
name|validate_mode
argument_list|(
name|m
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|,
name|SET
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|)
expr_stmt|;
name|m
operator|->
name|ncomponents
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|component
operator|->
name|precision
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
name|m
operator|->
name|precision
operator|=
literal|2
operator|*
name|m
operator|->
name|component
operator|->
name|precision
expr_stmt|;
name|m
operator|->
name|bytesize
operator|=
literal|2
operator|*
name|m
operator|->
name|component
operator|->
name|bytesize
expr_stmt|;
break|break;
case|case
name|MODE_VECTOR_INT
case|:
case|case
name|MODE_VECTOR_FLOAT
case|:
comment|/* Vector modes should have a component and a number of components.  */
name|validate_mode
argument_list|(
name|m
argument_list|,
name|UNSET
argument_list|,
name|UNSET
argument_list|,
name|SET
argument_list|,
name|SET
argument_list|,
name|UNSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|component
operator|->
name|precision
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
name|m
operator|->
name|precision
operator|=
name|m
operator|->
name|ncomponents
operator|*
name|m
operator|->
name|component
operator|->
name|precision
expr_stmt|;
name|m
operator|->
name|bytesize
operator|=
name|m
operator|->
name|ncomponents
operator|*
name|m
operator|->
name|component
operator|->
name|bytesize
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
comment|/* If not already specified, the mode alignment defaults to the largest      power of two that divides the size of the object.  Complex types are      not more aligned than their contents.  */
if|if
condition|(
name|m
operator|->
name|cl
operator|==
name|MODE_COMPLEX_INT
operator|||
name|m
operator|->
name|cl
operator|==
name|MODE_COMPLEX_FLOAT
condition|)
name|alignment
operator|=
name|m
operator|->
name|component
operator|->
name|bytesize
expr_stmt|;
else|else
name|alignment
operator|=
name|m
operator|->
name|bytesize
expr_stmt|;
name|m
operator|->
name|alignment
operator|=
name|alignment
operator|&
operator|(
operator|~
name|alignment
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* If this mode has components, make the component mode point back      to this mode, for the sake of adjustments.  */
if|if
condition|(
name|m
operator|->
name|component
condition|)
block|{
name|m
operator|->
name|next_cont
operator|=
name|m
operator|->
name|component
operator|->
name|contained
expr_stmt|;
name|m
operator|->
name|component
operator|->
name|contained
operator|=
name|m
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|complete_all_modes
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|int
name|cl
decl_stmt|;
name|for_all_modes
argument_list|(
argument|cl
argument_list|,
argument|m
argument_list|)
name|complete_mode
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For each mode in class CLASS, construct a corresponding complex mode.  */
end_comment

begin_define
define|#
directive|define
name|COMPLEX_MODES
parameter_list|(
name|C
parameter_list|)
value|make_complex_modes(MODE_##C, __FILE__, __LINE__)
end_define

begin_function
specifier|static
name|void
name|make_complex_modes
parameter_list|(
name|enum
name|mode_class
name|cl
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|enum
name|mode_class
name|cclass
init|=
name|complex_class
argument_list|(
name|cl
argument_list|)
decl_stmt|;
if|if
condition|(
name|cclass
operator|==
name|MODE_RANDOM
condition|)
return|return;
for|for
control|(
name|m
operator|=
name|modes
index|[
name|cl
index|]
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
comment|/* Skip BImode.  FIXME: BImode probably shouldn't be MODE_INT.  */
if|if
condition|(
name|m
operator|->
name|precision
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|strlen
argument_list|(
name|m
operator|->
name|name
argument_list|)
operator|>=
sizeof|sizeof
name|buf
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d:mode name \"%s\" is too long"
argument_list|,
name|m
operator|->
name|file
argument_list|,
name|m
operator|->
name|line
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Float complex modes are named SCmode, etc. 	 Int complex modes are named CSImode, etc.          This inconsistency should be eliminated.  */
if|if
condition|(
name|cl
operator|==
name|MODE_FLOAT
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
init|=
literal|0
decl_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|m
operator|->
name|name
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'F'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|q
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'D'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
operator|&&
name|q
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: float mode \"%s\" has no 'F' or 'D'"
argument_list|,
name|m
operator|->
name|file
argument_list|,
name|m
operator|->
name|line
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
operator|*
name|p
operator|=
literal|'C'
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"C%s"
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"C%s"
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|c
operator|=
name|new_mode
argument_list|(
name|cclass
argument_list|,
name|xstrdup
argument_list|(
name|buf
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|c
operator|->
name|component
operator|=
name|m
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For all modes in class CL, construct vector modes of width    WIDTH, having as many components as necessary.  */
end_comment

begin_define
define|#
directive|define
name|VECTOR_MODES
parameter_list|(
name|C
parameter_list|,
name|W
parameter_list|)
value|make_vector_modes(MODE_##C, W, __FILE__, __LINE__)
end_define

begin_function
specifier|static
name|void
name|ATTRIBUTE_UNUSED
name|make_vector_modes
parameter_list|(
name|enum
name|mode_class
name|cl
parameter_list|,
name|unsigned
name|int
name|width
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|v
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|int
name|ncomponents
decl_stmt|;
name|enum
name|mode_class
name|vclass
init|=
name|vector_class
argument_list|(
name|cl
argument_list|)
decl_stmt|;
if|if
condition|(
name|vclass
operator|==
name|MODE_RANDOM
condition|)
return|return;
for|for
control|(
name|m
operator|=
name|modes
index|[
name|cl
index|]
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
comment|/* Do not construct vector modes with only one element, or 	 vector modes where the element size doesn't divide the full 	 size evenly.  */
name|ncomponents
operator|=
name|width
operator|/
name|m
operator|->
name|bytesize
expr_stmt|;
if|if
condition|(
name|ncomponents
operator|<
literal|2
condition|)
continue|continue;
if|if
condition|(
name|width
operator|%
name|m
operator|->
name|bytesize
condition|)
continue|continue;
comment|/* Skip QFmode and BImode.  FIXME: this special case should 	 not be necessary.  */
if|if
condition|(
name|cl
operator|==
name|MODE_FLOAT
operator|&&
name|m
operator|->
name|bytesize
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|cl
operator|==
name|MODE_INT
operator|&&
name|m
operator|->
name|precision
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|(
name|size_t
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"V%u%s"
argument_list|,
name|ncomponents
argument_list|,
name|m
operator|->
name|name
argument_list|)
operator|>=
sizeof|sizeof
name|buf
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: mode name \"%s\" is too long"
argument_list|,
name|m
operator|->
name|file
argument_list|,
name|m
operator|->
name|line
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|v
operator|=
name|new_mode
argument_list|(
name|vclass
argument_list|,
name|xstrdup
argument_list|(
name|buf
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|v
operator|->
name|component
operator|=
name|m
expr_stmt|;
name|v
operator|->
name|ncomponents
operator|=
name|ncomponents
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Input.  */
end_comment

begin_define
define|#
directive|define
name|_SPECIAL_MODE
parameter_list|(
name|C
parameter_list|,
name|N
parameter_list|)
value|make_special_mode(MODE_##C, #N, __FILE__, __LINE__)
end_define

begin_define
define|#
directive|define
name|RANDOM_MODE
parameter_list|(
name|N
parameter_list|)
value|_SPECIAL_MODE (RANDOM, N)
end_define

begin_define
define|#
directive|define
name|CC_MODE
parameter_list|(
name|N
parameter_list|)
value|_SPECIAL_MODE (CC, N)
end_define

begin_function
specifier|static
name|void
name|make_special_mode
parameter_list|(
name|enum
name|mode_class
name|cl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|new_mode
argument_list|(
name|cl
argument_list|,
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|INT_MODE
parameter_list|(
name|N
parameter_list|,
name|Y
parameter_list|)
value|FRACTIONAL_INT_MODE (N, -1U, Y)
end_define

begin_define
define|#
directive|define
name|FRACTIONAL_INT_MODE
parameter_list|(
name|N
parameter_list|,
name|B
parameter_list|,
name|Y
parameter_list|)
define|\
value|make_int_mode (#N, B, Y, __FILE__, __LINE__)
end_define

begin_function
specifier|static
name|void
name|make_int_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|precision
parameter_list|,
name|unsigned
name|int
name|bytesize
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m
init|=
name|new_mode
argument_list|(
name|MODE_INT
argument_list|,
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
decl_stmt|;
name|m
operator|->
name|bytesize
operator|=
name|bytesize
expr_stmt|;
name|m
operator|->
name|precision
operator|=
name|precision
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FLOAT_MODE
parameter_list|(
name|N
parameter_list|,
name|Y
parameter_list|,
name|F
parameter_list|)
value|FRACTIONAL_FLOAT_MODE (N, -1U, Y, F)
end_define

begin_define
define|#
directive|define
name|FRACTIONAL_FLOAT_MODE
parameter_list|(
name|N
parameter_list|,
name|B
parameter_list|,
name|Y
parameter_list|,
name|F
parameter_list|)
define|\
value|make_float_mode (#N, B, Y, #F, __FILE__, __LINE__)
end_define

begin_function
specifier|static
name|void
name|make_float_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|precision
parameter_list|,
name|unsigned
name|int
name|bytesize
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m
init|=
name|new_mode
argument_list|(
name|MODE_FLOAT
argument_list|,
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
decl_stmt|;
name|m
operator|->
name|bytesize
operator|=
name|bytesize
expr_stmt|;
name|m
operator|->
name|precision
operator|=
name|precision
expr_stmt|;
name|m
operator|->
name|format
operator|=
name|format
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DECIMAL_FLOAT_MODE
parameter_list|(
name|N
parameter_list|,
name|Y
parameter_list|,
name|F
parameter_list|)
define|\
value|FRACTIONAL_DECIMAL_FLOAT_MODE (N, -1U, Y, F)
end_define

begin_define
define|#
directive|define
name|FRACTIONAL_DECIMAL_FLOAT_MODE
parameter_list|(
name|N
parameter_list|,
name|B
parameter_list|,
name|Y
parameter_list|,
name|F
parameter_list|)
define|\
value|make_decimal_float_mode (#N, B, Y, #F, __FILE__, __LINE__)
end_define

begin_function
specifier|static
name|void
name|make_decimal_float_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|precision
parameter_list|,
name|unsigned
name|int
name|bytesize
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m
init|=
name|new_mode
argument_list|(
name|MODE_DECIMAL_FLOAT
argument_list|,
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
decl_stmt|;
name|m
operator|->
name|bytesize
operator|=
name|bytesize
expr_stmt|;
name|m
operator|->
name|precision
operator|=
name|precision
expr_stmt|;
name|m
operator|->
name|format
operator|=
name|format
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|RESET_FLOAT_FORMAT
parameter_list|(
name|N
parameter_list|,
name|F
parameter_list|)
define|\
value|reset_float_format (#N, #F, __FILE__, __LINE__)
end_define

begin_function
specifier|static
name|void
name|ATTRIBUTE_UNUSED
name|reset_float_format
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m
init|=
name|find_mode
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: no mode \"%s\""
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m
operator|->
name|cl
operator|!=
name|MODE_FLOAT
operator|&&
name|m
operator|->
name|cl
operator|!=
name|MODE_DECIMAL_FLOAT
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: mode \"%s\" is not a FLOAT class"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|format
operator|=
name|format
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Partial integer modes are specified by relation to a full integer mode.    For now, we do not attempt to narrow down their bit sizes.  */
end_comment

begin_define
define|#
directive|define
name|PARTIAL_INT_MODE
parameter_list|(
name|M
parameter_list|)
define|\
value|make_partial_integer_mode (#M, "P" #M, -1U, __FILE__, __LINE__)
end_define

begin_function
specifier|static
name|void
name|ATTRIBUTE_UNUSED
name|make_partial_integer_mode
parameter_list|(
specifier|const
name|char
modifier|*
name|base
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|precision
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|component
init|=
name|find_mode
argument_list|(
name|base
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|component
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: no mode \"%s\""
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|component
operator|->
name|cl
operator|!=
name|MODE_INT
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: mode \"%s\" is not class INT"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|new_mode
argument_list|(
name|MODE_PARTIAL_INT
argument_list|,
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|m
operator|->
name|precision
operator|=
name|precision
expr_stmt|;
name|m
operator|->
name|component
operator|=
name|component
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A single vector mode can be specified by naming its component    mode and the number of components.  */
end_comment

begin_define
define|#
directive|define
name|VECTOR_MODE
parameter_list|(
name|C
parameter_list|,
name|M
parameter_list|,
name|N
parameter_list|)
define|\
value|make_vector_mode (MODE_##C, #M, N, __FILE__, __LINE__);
end_define

begin_function
specifier|static
name|void
name|ATTRIBUTE_UNUSED
name|make_vector_mode
parameter_list|(
name|enum
name|mode_class
name|bclass
parameter_list|,
specifier|const
name|char
modifier|*
name|base
parameter_list|,
name|unsigned
name|int
name|ncomponents
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|line
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|v
decl_stmt|;
name|enum
name|mode_class
name|vclass
init|=
name|vector_class
argument_list|(
name|bclass
argument_list|)
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|component
init|=
name|find_mode
argument_list|(
name|base
argument_list|)
decl_stmt|;
name|char
name|namebuf
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|vclass
operator|==
name|MODE_RANDOM
condition|)
return|return;
if|if
condition|(
name|component
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: no mode \"%s\""
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|component
operator|->
name|cl
operator|!=
name|bclass
operator|&&
operator|(
name|component
operator|->
name|cl
operator|!=
name|MODE_PARTIAL_INT
operator|||
name|bclass
operator|!=
name|MODE_INT
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: mode \"%s\" is not class %s"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|base
argument_list|,
name|mode_class_names
index|[
name|bclass
index|]
operator|+
literal|5
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|snprintf
argument_list|(
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|,
literal|"V%u%s"
argument_list|,
name|ncomponents
argument_list|,
name|base
argument_list|)
operator|>=
sizeof|sizeof
name|namebuf
condition|)
block|{
name|error
argument_list|(
literal|"%s:%d: mode name \"%s\" is too long"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
name|v
operator|=
name|new_mode
argument_list|(
name|vclass
argument_list|,
name|xstrdup
argument_list|(
name|namebuf
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|v
operator|->
name|ncomponents
operator|=
name|ncomponents
expr_stmt|;
name|v
operator|->
name|component
operator|=
name|component
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Adjustability.  */
end_comment

begin_define
define|#
directive|define
name|_ADD_ADJUST
parameter_list|(
name|A
parameter_list|,
name|M
parameter_list|,
name|X
parameter_list|,
name|C
parameter_list|)
define|\
value|new_adjust (#M,&adj_##A, #A, #X, MODE_##C, __FILE__, __LINE__)
end_define

begin_define
define|#
directive|define
name|ADJUST_BYTESIZE
parameter_list|(
name|M
parameter_list|,
name|X
parameter_list|)
value|_ADD_ADJUST(bytesize, M, X, RANDOM)
end_define

begin_define
define|#
directive|define
name|ADJUST_ALIGNMENT
parameter_list|(
name|M
parameter_list|,
name|X
parameter_list|)
value|_ADD_ADJUST(alignment, M, X, RANDOM)
end_define

begin_define
define|#
directive|define
name|ADJUST_FLOAT_FORMAT
parameter_list|(
name|M
parameter_list|,
name|X
parameter_list|)
value|_ADD_ADJUST(format, M, X, FLOAT)
end_define

begin_function
specifier|static
name|void
name|create_modes
parameter_list|(
name|void
parameter_list|)
block|{
include|#
directive|include
file|"machmode.def"
block|}
end_function

begin_comment
comment|/* Processing.  */
end_comment

begin_comment
comment|/* Sort a list of modes into the order needed for the WIDER field:    major sort by precision, minor sort by component precision.     For instance:      QI< HI< SI< DI< TI      V4QI< V2HI< V8QI< V4HI< V2SI.     If the precision is not set, sort by the bytesize.  A mode with    precision set gets sorted before a mode without precision set, if    they have the same bytesize; this is the right thing because    the precision must always be smaller than the bytesize * BITS_PER_UNIT.    We don't have to do anything special to get this done -- an unset    precision shows up as (unsigned int)-1, i.e. UINT_MAX.  */
end_comment

begin_function
specifier|static
name|int
name|cmp_modes
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m
init|=
operator|*
operator|(
expr|struct
name|mode_data
operator|*
operator|*
operator|)
name|a
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|n
init|=
operator|*
operator|(
expr|struct
name|mode_data
operator|*
operator|*
operator|)
name|b
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|bytesize
operator|>
name|n
operator|->
name|bytesize
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|m
operator|->
name|bytesize
operator|<
name|n
operator|->
name|bytesize
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|m
operator|->
name|precision
operator|>
name|n
operator|->
name|precision
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|m
operator|->
name|precision
operator|<
name|n
operator|->
name|precision
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|m
operator|->
name|component
operator|&&
operator|!
name|n
operator|->
name|component
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|counter
operator|<
name|n
operator|->
name|counter
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
if|if
condition|(
name|m
operator|->
name|component
operator|->
name|bytesize
operator|>
name|n
operator|->
name|component
operator|->
name|bytesize
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|m
operator|->
name|component
operator|->
name|bytesize
operator|<
name|n
operator|->
name|component
operator|->
name|bytesize
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|m
operator|->
name|component
operator|->
name|precision
operator|>
name|n
operator|->
name|component
operator|->
name|precision
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|m
operator|->
name|component
operator|->
name|precision
operator|<
name|n
operator|->
name|component
operator|->
name|precision
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|m
operator|->
name|counter
operator|<
name|n
operator|->
name|counter
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|calc_wider_mode
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|struct
name|mode_data
modifier|*
modifier|*
name|sortbuf
decl_stmt|;
name|unsigned
name|int
name|max_n_modes
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|MAX_MODE_CLASS
condition|;
name|c
operator|++
control|)
name|max_n_modes
operator|=
name|MAX
argument_list|(
name|max_n_modes
argument_list|,
name|n_modes
index|[
name|c
index|]
argument_list|)
expr_stmt|;
comment|/* Allocate max_n_modes + 1 entries to leave room for the extra null      pointer assigned after the qsort call below.  */
name|sortbuf
operator|=
operator|(
expr|struct
name|mode_data
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|max_n_modes
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mode_data
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|MAX_MODE_CLASS
condition|;
name|c
operator|++
control|)
block|{
comment|/* "wider" is not meaningful for MODE_RANDOM and MODE_CC. 	 However, we want these in textual order, and we have 	 precisely the reverse.  */
if|if
condition|(
name|c
operator|==
name|MODE_RANDOM
operator|||
name|c
operator|==
name|MODE_CC
condition|)
block|{
name|struct
name|mode_data
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|prev
operator|=
literal|0
operator|,
name|m
operator|=
name|modes
index|[
name|c
index|]
init|;
name|m
condition|;
name|m
operator|=
name|next
control|)
block|{
name|m
operator|->
name|wider
operator|=
name|void_mode
expr_stmt|;
name|m
operator|->
name|wider_2x
operator|=
name|void_mode
expr_stmt|;
comment|/* this is nreverse */
name|next
operator|=
name|m
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|m
expr_stmt|;
block|}
name|modes
index|[
name|c
index|]
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|modes
index|[
name|c
index|]
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m
operator|=
name|modes
index|[
name|c
index|]
init|;
name|m
condition|;
name|i
operator|++
operator|,
name|m
operator|=
name|m
operator|->
name|next
control|)
name|sortbuf
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|qsort
argument_list|(
name|sortbuf
argument_list|,
name|i
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mode_data
operator|*
argument_list|)
argument_list|,
name|cmp_modes
argument_list|)
expr_stmt|;
name|sortbuf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|sortbuf
index|[
name|j
index|]
operator|->
name|next
operator|=
name|sortbuf
index|[
name|j
index|]
operator|->
name|wider
operator|=
name|sortbuf
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|modes
index|[
name|c
index|]
operator|=
name|sortbuf
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output routines.  */
end_comment

begin_define
define|#
directive|define
name|tagged_printf
parameter_list|(
name|FMT
parameter_list|,
name|ARG
parameter_list|,
name|TAG
parameter_list|)
value|do {		\   int count_;						\   printf ("  " FMT ",%n", ARG,&count_);		\   printf ("%*s/* %s */\n", 27 - count_, "", TAG);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|print_decl
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|ASIZE
parameter_list|)
define|\
value|puts ("\nconst " TYPE " " NAME "[" ASIZE "] =\n{");
end_define

begin_define
define|#
directive|define
name|print_maybe_const_decl
parameter_list|(
name|TYPE
parameter_list|,
name|NAME
parameter_list|,
name|ASIZE
parameter_list|,
name|CATEGORY
parameter_list|)
define|\
value|printf ("\n" TYPE " " NAME "[" ASIZE "] = \n{\n",		\ 	  adj_##CATEGORY ? "" : "const ")
end_define

begin_define
define|#
directive|define
name|print_closer
parameter_list|()
value|puts ("};")
end_define

begin_function
specifier|static
name|void
name|emit_insn_modes_h
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|,
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|printf
argument_list|(
literal|"/* Generated automatically from machmode.def%s%s\n"
argument_list|,
name|HAVE_EXTRA_MODES
condition|?
literal|" and "
else|:
literal|""
argument_list|,
name|EXTRA_MODES_FILE
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\    by genmodes.  */\n\ \n\ #ifndef GCC_INSN_MODES_H\n\ #define GCC_INSN_MODES_H\n\ \n\ enum machine_mode\n{"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|MAX_MODE_CLASS
condition|;
name|c
operator|++
control|)
for|for
control|(
name|m
operator|=
name|modes
index|[
name|c
index|]
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
name|int
name|count_
decl_stmt|;
name|printf
argument_list|(
literal|"  %smode,%n"
argument_list|,
name|m
operator|->
name|name
argument_list|,
operator|&
name|count_
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*s/* %s:%d */\n"
argument_list|,
literal|27
operator|-
name|count_
argument_list|,
literal|""
argument_list|,
name|trim_filename
argument_list|(
name|m
operator|->
name|file
argument_list|)
argument_list|,
name|m
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"  MAX_MACHINE_MODE,\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|MAX_MODE_CLASS
condition|;
name|c
operator|++
control|)
block|{
name|first
operator|=
name|modes
index|[
name|c
index|]
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|first
init|;
name|m
condition|;
name|last
operator|=
name|m
operator|,
name|m
operator|=
name|m
operator|->
name|next
control|)
empty_stmt|;
comment|/* Don't use BImode for MIN_MODE_INT, since otherwise the middle 	 end will try to use it for bitfields in structures and the 	 like, which we do not want.  Only the target md file should 	 generate BImode widgets.  */
if|if
condition|(
name|first
operator|&&
name|first
operator|->
name|precision
operator|==
literal|1
condition|)
name|first
operator|=
name|first
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|first
operator|&&
name|last
condition|)
name|printf
argument_list|(
literal|"  MIN_%s = %smode,\n  MAX_%s = %smode,\n\n"
argument_list|,
name|mode_class_names
index|[
name|c
index|]
argument_list|,
name|first
operator|->
name|name
argument_list|,
name|mode_class_names
index|[
name|c
index|]
argument_list|,
name|last
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  MIN_%s = %smode,\n  MAX_%s = %smode,\n\n"
argument_list|,
name|mode_class_names
index|[
name|c
index|]
argument_list|,
name|void_mode
operator|->
name|name
argument_list|,
name|mode_class_names
index|[
name|c
index|]
argument_list|,
name|void_mode
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|puts
argument_list|(
literal|"\   NUM_MACHINE_MODES = MAX_MACHINE_MODE\n\ };\n"
argument_list|)
expr_stmt|;
comment|/* I can't think of a better idea, can you?  */
name|printf
argument_list|(
literal|"#define CONST_MODE_SIZE%s\n"
argument_list|,
name|adj_bytesize
condition|?
literal|""
else|:
literal|" const"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"#define CONST_MODE_BASE_ALIGN%s\n"
argument_list|,
name|adj_alignment
condition|?
literal|""
else|:
literal|" const"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* disabled for backward compatibility, temporary */
block|printf ("#define CONST_REAL_FORMAT_FOR_MODE%s\n", adj_format ? "" :" const");
endif|#
directive|endif
name|puts
argument_list|(
literal|"\ \n\ #endif /* insn-modes.h */"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_insn_modes_c_header
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"/* Generated automatically from machmode.def%s%s\n"
argument_list|,
name|HAVE_EXTRA_MODES
condition|?
literal|" and "
else|:
literal|""
argument_list|,
name|EXTRA_MODES_FILE
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\    by genmodes.  */\n\ \n\ #include \"config.h\"\n\ #include \"system.h\"\n\ #include \"coretypes.h\"\n\ #include \"tm.h\"\n\ #include \"machmode.h\"\n\ #include \"real.h\""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_min_insn_modes_c_header
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"/* Generated automatically from machmode.def%s%s\n"
argument_list|,
name|HAVE_EXTRA_MODES
condition|?
literal|" and "
else|:
literal|""
argument_list|,
name|EXTRA_MODES_FILE
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\    by genmodes.  */\n\ \n\ #include \"bconfig.h\"\n\ #include \"system.h\"\n\ #include \"machmode.h\""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_mode_name
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|print_decl
argument_list|(
literal|"char *const"
argument_list|,
literal|"mode_name"
argument_list|,
literal|"NUM_MACHINE_MODES"
argument_list|)
expr_stmt|;
name|for_all_modes
argument_list|(
argument|c
argument_list|,
argument|m
argument_list|)
name|printf
argument_list|(
literal|"  \"%s\",\n"
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_closer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_mode_class
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|print_decl
argument_list|(
literal|"unsigned char"
argument_list|,
literal|"mode_class"
argument_list|,
literal|"NUM_MACHINE_MODES"
argument_list|)
expr_stmt|;
name|for_all_modes
argument_list|(
argument|c
argument_list|,
argument|m
argument_list|)
name|tagged_printf
argument_list|(
literal|"%s"
argument_list|,
name|mode_class_names
index|[
name|m
operator|->
name|cl
index|]
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_closer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_mode_precision
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|print_decl
argument_list|(
literal|"unsigned short"
argument_list|,
literal|"mode_precision"
argument_list|,
literal|"NUM_MACHINE_MODES"
argument_list|)
expr_stmt|;
name|for_all_modes
argument_list|(
argument|c
argument_list|,
argument|m
argument_list|)
if|if
condition|(
name|m
operator|->
name|precision
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
name|tagged_printf
argument_list|(
literal|"%u"
argument_list|,
name|m
operator|->
name|precision
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|tagged_printf
argument_list|(
literal|"%u*BITS_PER_UNIT"
argument_list|,
name|m
operator|->
name|bytesize
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_closer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_mode_size
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|print_maybe_const_decl
argument_list|(
literal|"%sunsigned char"
argument_list|,
literal|"mode_size"
argument_list|,
literal|"NUM_MACHINE_MODES"
argument_list|,
name|bytesize
argument_list|)
expr_stmt|;
name|for_all_modes
argument_list|(
argument|c
argument_list|,
argument|m
argument_list|)
name|tagged_printf
argument_list|(
literal|"%u"
argument_list|,
name|m
operator|->
name|bytesize
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_closer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_mode_nunits
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|print_decl
argument_list|(
literal|"unsigned char"
argument_list|,
literal|"mode_nunits"
argument_list|,
literal|"NUM_MACHINE_MODES"
argument_list|)
expr_stmt|;
name|for_all_modes
argument_list|(
argument|c
argument_list|,
argument|m
argument_list|)
name|tagged_printf
argument_list|(
literal|"%u"
argument_list|,
name|m
operator|->
name|ncomponents
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_closer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_mode_wider
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|print_decl
argument_list|(
literal|"unsigned char"
argument_list|,
literal|"mode_wider"
argument_list|,
literal|"NUM_MACHINE_MODES"
argument_list|)
expr_stmt|;
name|for_all_modes
argument_list|(
argument|c
argument_list|,
argument|m
argument_list|)
name|tagged_printf
argument_list|(
literal|"%smode"
argument_list|,
name|m
operator|->
name|wider
condition|?
name|m
operator|->
name|wider
operator|->
name|name
else|:
name|void_mode
operator|->
name|name
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_closer
argument_list|()
expr_stmt|;
name|print_decl
argument_list|(
literal|"unsigned char"
argument_list|,
literal|"mode_2xwider"
argument_list|,
literal|"NUM_MACHINE_MODES"
argument_list|)
expr_stmt|;
name|for_all_modes
argument_list|(
argument|c
argument_list|,
argument|m
argument_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m2
decl_stmt|;
for|for
control|(
name|m2
operator|=
name|m
init|;
name|m2
operator|&&
name|m2
operator|!=
name|void_mode
condition|;
name|m2
operator|=
name|m2
operator|->
name|wider
control|)
block|{
if|if
condition|(
name|m2
operator|->
name|bytesize
operator|<
literal|2
operator|*
name|m
operator|->
name|bytesize
condition|)
continue|continue;
if|if
condition|(
name|m
operator|->
name|precision
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|m2
operator|->
name|precision
operator|!=
literal|2
operator|*
name|m
operator|->
name|precision
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|m2
operator|->
name|precision
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|m2
operator|==
name|void_mode
condition|)
name|m2
operator|=
literal|0
expr_stmt|;
name|tagged_printf
argument_list|(
literal|"%smode"
argument_list|,
name|m2
condition|?
name|m2
operator|->
name|name
else|:
name|void_mode
operator|->
name|name
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|print_closer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_mode_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|print_decl
argument_list|(
literal|"unsigned HOST_WIDE_INT"
argument_list|,
literal|"mode_mask_array"
argument_list|,
literal|"NUM_MACHINE_MODES"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ #define MODE_MASK(m)                          \\\n\   ((m)>= HOST_BITS_PER_WIDE_INT)             \\\n\    ? ~(unsigned HOST_WIDE_INT) 0              \\\n\    : ((unsigned HOST_WIDE_INT) 1<< (m)) - 1\n"
argument_list|)
expr_stmt|;
name|for_all_modes
argument_list|(
argument|c
argument_list|,
argument|m
argument_list|)
if|if
condition|(
name|m
operator|->
name|precision
operator|!=
operator|(
name|unsigned
name|int
operator|)
operator|-
literal|1
condition|)
name|tagged_printf
argument_list|(
literal|"MODE_MASK (%u)"
argument_list|,
name|m
operator|->
name|precision
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|tagged_printf
argument_list|(
literal|"MODE_MASK (%u*BITS_PER_UNIT)"
argument_list|,
name|m
operator|->
name|bytesize
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"#undef MODE_MASK"
argument_list|)
expr_stmt|;
name|print_closer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_mode_inner
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|print_decl
argument_list|(
literal|"unsigned char"
argument_list|,
literal|"mode_inner"
argument_list|,
literal|"NUM_MACHINE_MODES"
argument_list|)
expr_stmt|;
name|for_all_modes
argument_list|(
argument|c
argument_list|,
argument|m
argument_list|)
name|tagged_printf
argument_list|(
literal|"%smode"
argument_list|,
name|m
operator|->
name|component
condition|?
name|m
operator|->
name|component
operator|->
name|name
else|:
name|void_mode
operator|->
name|name
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_closer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_mode_base_align
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|print_maybe_const_decl
argument_list|(
literal|"%sunsigned char"
argument_list|,
literal|"mode_base_align"
argument_list|,
literal|"NUM_MACHINE_MODES"
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|for_all_modes
argument_list|(
argument|c
argument_list|,
argument|m
argument_list|)
name|tagged_printf
argument_list|(
literal|"%u"
argument_list|,
name|m
operator|->
name|alignment
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_closer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_class_narrowest_mode
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|print_decl
argument_list|(
literal|"unsigned char"
argument_list|,
literal|"class_narrowest_mode"
argument_list|,
literal|"MAX_MODE_CLASS"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|MAX_MODE_CLASS
condition|;
name|c
operator|++
control|)
comment|/* Bleah, all this to get the comment right for MIN_MODE_INT.  */
name|tagged_printf
argument_list|(
literal|"MIN_%s"
argument_list|,
name|mode_class_names
index|[
name|c
index|]
argument_list|,
name|modes
index|[
name|c
index|]
condition|?
operator|(
name|modes
index|[
name|c
index|]
operator|->
name|precision
operator|!=
literal|1
condition|?
name|modes
index|[
name|c
index|]
operator|->
name|name
else|:
operator|(
name|modes
index|[
name|c
index|]
operator|->
name|next
condition|?
name|modes
index|[
name|c
index|]
operator|->
name|next
operator|->
name|name
else|:
name|void_mode
operator|->
name|name
operator|)
operator|)
else|:
name|void_mode
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_closer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_real_format_for_mode
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
comment|/* The entities pointed to by this table are constant, whether      or not the table itself is constant.       For backward compatibility this table is always writable      (several targets modify it in OVERRIDE_OPTIONS).   FIXME:      convert all said targets to use ADJUST_FORMAT instead.  */
if|#
directive|if
literal|0
block|print_maybe_const_decl ("const struct real_format *%s", 			  "real_format_for_mode", 			  "MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1", 			  format);
else|#
directive|else
name|print_decl
argument_list|(
literal|"struct real_format *\n"
argument_list|,
literal|"real_format_for_mode"
argument_list|,
literal|"MAX_MODE_FLOAT - MIN_MODE_FLOAT + 1 "
literal|"+ MAX_MODE_DECIMAL_FLOAT - MIN_MODE_DECIMAL_FLOAT + 1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The beginning of the table is entries for float modes.  */
for|for
control|(
name|m
operator|=
name|modes
index|[
name|MODE_FLOAT
index|]
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|m
operator|->
name|format
argument_list|,
literal|"0"
argument_list|)
condition|)
name|tagged_printf
argument_list|(
literal|"%s"
argument_list|,
name|m
operator|->
name|format
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|tagged_printf
argument_list|(
literal|"&%s"
argument_list|,
name|m
operator|->
name|format
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* The end of the table is entries for decimal float modes.  */
for|for
control|(
name|m
operator|=
name|modes
index|[
name|MODE_DECIMAL_FLOAT
index|]
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|m
operator|->
name|format
argument_list|,
literal|"0"
argument_list|)
condition|)
name|tagged_printf
argument_list|(
literal|"%s"
argument_list|,
name|m
operator|->
name|format
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|tagged_printf
argument_list|(
literal|"&%s"
argument_list|,
name|m
operator|->
name|format
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_closer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_mode_adjustments
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mode_adjust
modifier|*
name|a
decl_stmt|;
name|struct
name|mode_data
modifier|*
name|m
decl_stmt|;
name|puts
argument_list|(
literal|"\ \nvoid\ \ninit_adjust_machine_modes (void)\ \n{\ \n  size_t s ATTRIBUTE_UNUSED;"
argument_list|)
expr_stmt|;
comment|/* Size adjustments must be propagated to all containing modes.      A size adjustment forces us to recalculate the alignment too.  */
for|for
control|(
name|a
operator|=
name|adj_bytesize
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"\n  /* %s:%d */\n  s = %s;\n"
argument_list|,
name|a
operator|->
name|file
argument_list|,
name|a
operator|->
name|line
argument_list|,
name|a
operator|->
name|adjustment
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  mode_size[%smode] = s;\n"
argument_list|,
name|a
operator|->
name|mode
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  mode_base_align[%smode] = s& (~s + 1);\n"
argument_list|,
name|a
operator|->
name|mode
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|a
operator|->
name|mode
operator|->
name|contained
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next_cont
control|)
block|{
switch|switch
condition|(
name|m
operator|->
name|cl
condition|)
block|{
case|case
name|MODE_COMPLEX_INT
case|:
case|case
name|MODE_COMPLEX_FLOAT
case|:
name|printf
argument_list|(
literal|"  mode_size[%smode] = 2*s;\n"
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  mode_base_align[%smode] = s& (~s + 1);\n"
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_VECTOR_INT
case|:
case|case
name|MODE_VECTOR_FLOAT
case|:
name|printf
argument_list|(
literal|"  mode_size[%smode] = %d*s;\n"
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|m
operator|->
name|ncomponents
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  mode_base_align[%smode] = (%d*s)& (~(%d*s)+1);\n"
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|m
operator|->
name|ncomponents
argument_list|,
name|m
operator|->
name|ncomponents
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
literal|"mode %s is neither vector nor complex but contains %s"
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|a
operator|->
name|mode
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
comment|/* Alignment adjustments propagate too.      ??? This may not be the right thing for vector modes.  */
for|for
control|(
name|a
operator|=
name|adj_alignment
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"\n  /* %s:%d */\n  s = %s;\n"
argument_list|,
name|a
operator|->
name|file
argument_list|,
name|a
operator|->
name|line
argument_list|,
name|a
operator|->
name|adjustment
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  mode_base_align[%smode] = s;\n"
argument_list|,
name|a
operator|->
name|mode
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|a
operator|->
name|mode
operator|->
name|contained
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next_cont
control|)
block|{
switch|switch
condition|(
name|m
operator|->
name|cl
condition|)
block|{
case|case
name|MODE_COMPLEX_INT
case|:
case|case
name|MODE_COMPLEX_FLOAT
case|:
name|printf
argument_list|(
literal|"  mode_base_align[%smode] = s;\n"
argument_list|,
name|m
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_VECTOR_INT
case|:
case|case
name|MODE_VECTOR_FLOAT
case|:
name|printf
argument_list|(
literal|"  mode_base_align[%smode] = %d*s;\n"
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|m
operator|->
name|ncomponents
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
literal|"mode %s is neither vector nor complex but contains %s"
argument_list|,
name|m
operator|->
name|name
argument_list|,
name|a
operator|->
name|mode
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
comment|/* Real mode formats don't have to propagate anywhere.  */
for|for
control|(
name|a
operator|=
name|adj_format
init|;
name|a
condition|;
name|a
operator|=
name|a
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"\n  /* %s:%d */\n  REAL_MODE_FORMAT (%smode) = %s;\n"
argument_list|,
name|a
operator|->
name|file
argument_list|,
name|a
operator|->
name|line
argument_list|,
name|a
operator|->
name|mode
operator|->
name|name
argument_list|,
name|a
operator|->
name|adjustment
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_insn_modes_c
parameter_list|(
name|void
parameter_list|)
block|{
name|emit_insn_modes_c_header
argument_list|()
expr_stmt|;
name|emit_mode_name
argument_list|()
expr_stmt|;
name|emit_mode_class
argument_list|()
expr_stmt|;
name|emit_mode_precision
argument_list|()
expr_stmt|;
name|emit_mode_size
argument_list|()
expr_stmt|;
name|emit_mode_nunits
argument_list|()
expr_stmt|;
name|emit_mode_wider
argument_list|()
expr_stmt|;
name|emit_mode_mask
argument_list|()
expr_stmt|;
name|emit_mode_inner
argument_list|()
expr_stmt|;
name|emit_mode_base_align
argument_list|()
expr_stmt|;
name|emit_class_narrowest_mode
argument_list|()
expr_stmt|;
name|emit_real_format_for_mode
argument_list|()
expr_stmt|;
name|emit_mode_adjustments
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|emit_min_insn_modes_c
parameter_list|(
name|void
parameter_list|)
block|{
name|emit_min_insn_modes_c_header
argument_list|()
expr_stmt|;
name|emit_mode_name
argument_list|()
expr_stmt|;
name|emit_mode_class
argument_list|()
expr_stmt|;
name|emit_mode_wider
argument_list|()
expr_stmt|;
name|emit_class_narrowest_mode
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Master control.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|bool
name|gen_header
init|=
name|false
decl_stmt|,
name|gen_min
init|=
name|false
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-h"
argument_list|)
condition|)
name|gen_header
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-m"
argument_list|)
condition|)
name|gen_min
operator|=
name|true
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"usage: %s [-h|-m]> file"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
return|return
name|FATAL_EXIT_CODE
return|;
block|}
name|modes_by_name
operator|=
name|htab_create_alloc
argument_list|(
literal|64
argument_list|,
name|hash_mode
argument_list|,
name|eq_mode
argument_list|,
literal|0
argument_list|,
name|xcalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|create_modes
argument_list|()
expr_stmt|;
name|complete_all_modes
argument_list|()
expr_stmt|;
if|if
condition|(
name|have_error
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
name|calc_wider_mode
argument_list|()
expr_stmt|;
if|if
condition|(
name|gen_header
condition|)
name|emit_insn_modes_h
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|gen_min
condition|)
name|emit_min_insn_modes_c
argument_list|()
expr_stmt|;
else|else
name|emit_insn_modes_c
argument_list|()
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
condition|)
return|return
name|FATAL_EXIT_CODE
return|;
return|return
name|SUCCESS_EXIT_CODE
return|;
block|}
end_function

end_unit

