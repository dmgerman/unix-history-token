begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Scalar evolution detector.    Copyright (C) 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.    Contributed by Sebastian Pop<s.pop@laposte.net>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_comment
comment|/*     Description:         This pass analyzes the evolution of scalar variables in loop    structures.  The algorithm is based on the SSA representation,    and on the loop hierarchy tree.  This algorithm is not based on    the notion of versions of a variable, as it was the case for the    previous implementations of the scalar evolution algorithm, but    it assumes that each defined name is unique.     The notation used in this file is called "chains of recurrences",    and has been proposed by Eugene Zima, Robert Van Engelen, and    others for describing induction variables in programs.  For example    "b -> {0, +, 2}_1" means that the scalar variable "b" is equal to 0    when entering in the loop_1 and has a step 2 in this loop, in other    words "for (b = 0; b< N; b+=2);".  Note that the coefficients of    this chain of recurrence (or chrec [shrek]) can contain the name of    other variables, in which case they are called parametric chrecs.    For example, "b -> {a, +, 2}_1" means that the initial value of "b"    is the value of "a".  In most of the cases these parametric chrecs    are fully instantiated before their use because symbolic names can    hide some difficult cases such as self-references described later    (see the Fibonacci example).        A short sketch of the algorithm is:          Given a scalar variable to be analyzed, follow the SSA edge to    its definition:          - When the definition is a MODIFY_EXPR: if the right hand side    (RHS) of the definition cannot be statically analyzed, the answer    of the analyzer is: "don't know".      Otherwise, for all the variables that are not yet analyzed in the    RHS, try to determine their evolution, and finally try to    evaluate the operation of the RHS that gives the evolution    function of the analyzed variable.     - When the definition is a condition-phi-node: determine the    evolution function for all the branches of the phi node, and    finally merge these evolutions (see chrec_merge).     - When the definition is a loop-phi-node: determine its initial    condition, that is the SSA edge defined in an outer loop, and    keep it symbolic.  Then determine the SSA edges that are defined    in the body of the loop.  Follow the inner edges until ending on    another loop-phi-node of the same analyzed loop.  If the reached    loop-phi-node is not the starting loop-phi-node, then we keep    this definition under a symbolic form.  If the reached    loop-phi-node is the same as the starting one, then we compute a    symbolic stride on the return path.  The result is then the    symbolic chrec {initial_condition, +, symbolic_stride}_loop.     Examples:        Example 1: Illustration of the basic algorithm.        | a = 3    | loop_1    |   b = phi (a, c)    |   c = b + 1    |   if (c> 10) exit_loop    | endloop        Suppose that we want to know the number of iterations of the    loop_1.  The exit_loop is controlled by a COND_EXPR (c> 10).  We    ask the scalar evolution analyzer two questions: what's the    scalar evolution (scev) of "c", and what's the scev of "10".  For    "10" the answer is "10" since it is a scalar constant.  For the    scalar variable "c", it follows the SSA edge to its definition,    "c = b + 1", and then asks again what's the scev of "b".    Following the SSA edge, we end on a loop-phi-node "b = phi (a,    c)", where the initial condition is "a", and the inner loop edge    is "c".  The initial condition is kept under a symbolic form (it    may be the case that the copy constant propagation has done its    work and we end with the constant "3" as one of the edges of the    loop-phi-node).  The update edge is followed to the end of the    loop, and until reaching again the starting loop-phi-node: b -> c    -> b.  At this point we have drawn a path from "b" to "b" from    which we compute the stride in the loop: in this example it is    "+1".  The resulting scev for "b" is "b -> {a, +, 1}_1".  Now    that the scev for "b" is known, it is possible to compute the    scev for "c", that is "c -> {a + 1, +, 1}_1".  In order to    determine the number of iterations in the loop_1, we have to    instantiate_parameters ({a + 1, +, 1}_1), that gives after some    more analysis the scev {4, +, 1}_1, or in other words, this is    the function "f (x) = x + 4", where x is the iteration count of    the loop_1.  Now we have to solve the inequality "x + 4> 10",    and take the smallest iteration number for which the loop is    exited: x = 7.  This loop runs from x = 0 to x = 7, and in total    there are 8 iterations.  In terms of loop normalization, we have    created a variable that is implicitly defined, "x" or just "_1",    and all the other analyzed scalars of the loop are defined in    function of this variable:        a -> 3    b -> {3, +, 1}_1    c -> {4, +, 1}_1          or in terms of a C program:           | a = 3    | for (x = 0; x<= 7; x++)    |   {    |     b = x + 3    |     c = x + 4    |   }          Example 2: Illustration of the algorithm on nested loops.          | loop_1    |   a = phi (1, b)    |   c = a + 2    |   loop_2  10 times    |     b = phi (c, d)    |     d = b + 3    |   endloop    | endloop          For analyzing the scalar evolution of "a", the algorithm follows    the SSA edge into the loop's body: "a -> b".  "b" is an inner    loop-phi-node, and its analysis as in Example 1, gives:           b -> {c, +, 3}_2    d -> {c + 3, +, 3}_2          Following the SSA edge for the initial condition, we end on "c = a    + 2", and then on the starting loop-phi-node "a".  From this point,    the loop stride is computed: back on "c = a + 2" we get a "+2" in    the loop_1, then on the loop-phi-node "b" we compute the overall    effect of the inner loop that is "b = c + 30", and we get a "+30"    in the loop_1.  That means that the overall stride in loop_1 is    equal to "+32", and the result is:           a -> {1, +, 32}_1    c -> {3, +, 32}_1          Example 3: Higher degree polynomials.          | loop_1    |   a = phi (2, b)    |   c = phi (5, d)    |   b = a + 1    |   d = c + a    | endloop          a -> {2, +, 1}_1    b -> {3, +, 1}_1    c -> {5, +, a}_1    d -> {5 + a, +, a}_1          instantiate_parameters ({5, +, a}_1) -> {5, +, 2, +, 1}_1    instantiate_parameters ({5 + a, +, a}_1) -> {7, +, 3, +, 1}_1          Example 4: Lucas, Fibonacci, or mixers in general.          | loop_1    |   a = phi (1, b)    |   c = phi (3, d)    |   b = c    |   d = c + a    | endloop          a -> (1, c)_1    c -> {3, +, a}_1          The syntax "(1, c)_1" stands for a PEELED_CHREC that has the    following semantics: during the first iteration of the loop_1, the    variable contains the value 1, and then it contains the value "c".    Note that this syntax is close to the syntax of the loop-phi-node:    "a -> (1, c)_1" vs. "a = phi (1, c)".          The symbolic chrec representation contains all the semantics of the    original code.  What is more difficult is to use this information.          Example 5: Flip-flops, or exchangers.          | loop_1    |   a = phi (1, b)    |   c = phi (3, d)    |   b = c    |   d = a    | endloop          a -> (1, c)_1    c -> (3, a)_1          Based on these symbolic chrecs, it is possible to refine this    information into the more precise PERIODIC_CHRECs:           a -> |1, 3|_1    c -> |3, 1|_1          This transformation is not yet implemented.          Further readings:        You can find a more detailed description of the algorithm in:    http://icps.u-strasbg.fr/~pop/DEA_03_Pop.pdf    http://icps.u-strasbg.fr/~pop/DEA_03_Pop.ps.gz.  But note that    this is a preliminary report and some of the details of the    algorithm have changed.  I'm working on a research report that    updates the description of the algorithms to reflect the design    choices used in this implementation.          A set of slides show a high level overview of the algorithm and run    an example through the scalar evolution analyzer:    http://cri.ensmp.fr/~pop/gcc/mar04/slides.pdf     The slides that I have presented at the GCC Summit'04 are available    at: http://cri.ensmp.fr/~pop/gcc/20040604/gccsummit-lno-spop.pdf */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_comment
comment|/* These RTL headers are needed for basic-block.h.  */
end_comment

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-dump.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"cfgloop.h"
end_include

begin_include
include|#
directive|include
file|"tree-chrec.h"
end_include

begin_include
include|#
directive|include
file|"tree-scalar-evolution.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"params.h"
end_include

begin_function_decl
specifier|static
name|tree
name|analyze_scalar_evolution_1
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|resolve_mixers
parameter_list|(
name|struct
name|loop
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The cached information about a ssa name VAR, claiming that inside LOOP,    the value of VAR can be expressed as CHREC.  */
end_comment

begin_struct
struct|struct
name|scev_info_str
block|{
name|tree
name|var
decl_stmt|;
name|tree
name|chrec
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Counters for the scev database.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|nb_set_scev
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|nb_get_scev
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following trees are unique elements.  Thus the comparison of    another element to these elements should be done on the pointer to    these trees, and not on their value.  */
end_comment

begin_comment
comment|/* The SSA_NAMEs that are not yet analyzed are qualified with NULL_TREE.  */
end_comment

begin_decl_stmt
name|tree
name|chrec_not_analyzed_yet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reserved to the cases where the analyzer has detected an    undecidable property at compile time.  */
end_comment

begin_decl_stmt
name|tree
name|chrec_dont_know
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When the analyzer has detected that a property will never    happen, then it qualifies it with chrec_known.  */
end_comment

begin_decl_stmt
name|tree
name|chrec_known
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bitmap
name|already_instantiated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|htab_t
name|scalar_evolution_info
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Constructs a new SCEV_INFO_STR structure.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|scev_info_str
modifier|*
name|new_scev_info_str
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|struct
name|scev_info_str
modifier|*
name|res
decl_stmt|;
name|res
operator|=
name|XNEW
argument_list|(
expr|struct
name|scev_info_str
argument_list|)
expr_stmt|;
name|res
operator|->
name|var
operator|=
name|var
expr_stmt|;
name|res
operator|->
name|chrec
operator|=
name|chrec_not_analyzed_yet
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Computes a hash function for database element ELT.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|hash_scev_info
parameter_list|(
specifier|const
name|void
modifier|*
name|elt
parameter_list|)
block|{
return|return
name|SSA_NAME_VERSION
argument_list|(
operator|(
operator|(
expr|struct
name|scev_info_str
operator|*
operator|)
name|elt
operator|)
operator|->
name|var
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compares database elements E1 and E2.  */
end_comment

begin_function
specifier|static
name|int
name|eq_scev_info
parameter_list|(
specifier|const
name|void
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|e2
parameter_list|)
block|{
specifier|const
name|struct
name|scev_info_str
modifier|*
name|elt1
init|=
operator|(
specifier|const
expr|struct
name|scev_info_str
operator|*
operator|)
name|e1
decl_stmt|;
specifier|const
name|struct
name|scev_info_str
modifier|*
name|elt2
init|=
operator|(
specifier|const
expr|struct
name|scev_info_str
operator|*
operator|)
name|e2
decl_stmt|;
return|return
name|elt1
operator|->
name|var
operator|==
name|elt2
operator|->
name|var
return|;
block|}
end_function

begin_comment
comment|/* Deletes database element E.  */
end_comment

begin_function
specifier|static
name|void
name|del_scev_info
parameter_list|(
name|void
modifier|*
name|e
parameter_list|)
block|{
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the index corresponding to VAR in the current LOOP.  If    it's the first time we ask for this VAR, then we return    chrec_not_analyzed_yet for this VAR and return its index.  */
end_comment

begin_function
specifier|static
name|tree
modifier|*
name|find_var_scev_info
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|struct
name|scev_info_str
modifier|*
name|res
decl_stmt|;
name|struct
name|scev_info_str
name|tmp
decl_stmt|;
name|PTR
modifier|*
name|slot
decl_stmt|;
name|tmp
operator|.
name|var
operator|=
name|var
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|scalar_evolution_info
argument_list|,
operator|&
name|tmp
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|slot
condition|)
operator|*
name|slot
operator|=
name|new_scev_info_str
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
expr|struct
name|scev_info_str
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
return|return
operator|&
name|res
operator|->
name|chrec
return|;
block|}
end_function

begin_comment
comment|/* Return true when CHREC contains symbolic names defined in    LOOP_NB.  */
end_comment

begin_function
name|bool
name|chrec_contains_symbols_defined_in_loop
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|unsigned
name|loop_nb
parameter_list|)
block|{
if|if
condition|(
name|chrec
operator|==
name|NULL_TREE
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_INVARIANT
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|LABEL_DECL
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|FIELD_DECL
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|tree
name|def
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|chrec
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|def_loop
init|=
name|loop_containing_stmt
argument_list|(
name|def
argument_list|)
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|current_loops
operator|->
name|parray
index|[
name|loop_nb
index|]
decl_stmt|;
if|if
condition|(
name|def_loop
operator|==
name|NULL
condition|)
return|return
name|false
return|;
if|if
condition|(
name|loop
operator|==
name|def_loop
operator|||
name|flow_loop_nested_p
argument_list|(
name|loop
argument_list|,
name|def_loop
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|3
case|:
if|if
condition|(
name|chrec_contains_symbols_defined_in_loop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|2
argument_list|)
argument_list|,
name|loop_nb
argument_list|)
condition|)
return|return
name|true
return|;
case|case
literal|2
case|:
if|if
condition|(
name|chrec_contains_symbols_defined_in_loop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
argument_list|,
name|loop_nb
argument_list|)
condition|)
return|return
name|true
return|;
case|case
literal|1
case|:
if|if
condition|(
name|chrec_contains_symbols_defined_in_loop
argument_list|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|loop_nb
argument_list|)
condition|)
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return true when PHI is a loop-phi-node.  */
end_comment

begin_function
specifier|static
name|bool
name|loop_phi_node_p
parameter_list|(
name|tree
name|phi
parameter_list|)
block|{
comment|/* The implementation of this function is based on the following      property: "all the loop-phi-nodes of a loop are contained in the      loop's header basic block".  */
return|return
name|loop_containing_stmt
argument_list|(
name|phi
argument_list|)
operator|->
name|header
operator|==
name|bb_for_stmt
argument_list|(
name|phi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compute the scalar evolution for EVOLUTION_FN after crossing LOOP.    In general, in the case of multivariate evolutions we want to get    the evolution in different loops.  LOOP specifies the level for    which to get the evolution.        Example:        | for (j = 0; j< 100; j++)    |   {    |     for (k = 0; k< 100; k++)    |       {    |         i = k + j;   - Here the value of i is a function of j, k.     |       }    |      ... = i         - Here the value of i is a function of j.     |   }    | ... = i              - Here the value of i is a scalar.          Example:          | i_0 = ...    | loop_1 10 times    |   i_1 = phi (i_0, i_2)    |   i_2 = i_1 + 2    | endloop         This loop has the same effect as:    LOOP_1 has the same effect as:         | i_1 = i_0 + 20        The overall effect of the loop, "i_0 + 20" in the previous example,     is obtained by passing in the parameters: LOOP = 1,     EVOLUTION_FN = {i_0, +, 2}_1. */
end_comment

begin_function
specifier|static
name|tree
name|compute_overall_effect_of_inner_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|evolution_fn
parameter_list|)
block|{
name|bool
name|val
init|=
name|false
decl_stmt|;
if|if
condition|(
name|evolution_fn
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|evolution_fn
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
condition|)
block|{
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|evolution_fn
argument_list|)
operator|>=
operator|(
name|unsigned
operator|)
name|loop
operator|->
name|num
condition|)
block|{
name|struct
name|loop
modifier|*
name|inner_loop
init|=
name|current_loops
operator|->
name|parray
index|[
name|CHREC_VARIABLE
argument_list|(
name|evolution_fn
argument_list|)
index|]
decl_stmt|;
name|tree
name|nb_iter
init|=
name|number_of_iterations_in_loop
argument_list|(
name|inner_loop
argument_list|)
decl_stmt|;
if|if
condition|(
name|nb_iter
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
else|else
block|{
name|tree
name|res
decl_stmt|;
name|tree
name|type
init|=
name|chrec_type
argument_list|(
name|nb_iter
argument_list|)
decl_stmt|;
comment|/* Number of iterations is off by one (the ssa name we 		 analyze must be defined before the exit).  */
name|nb_iter
operator|=
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|nb_iter
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* evolution_fn is the evolution function in LOOP.  Get 		 its value in the nb_iter-th iteration.  */
name|res
operator|=
name|chrec_apply
argument_list|(
name|inner_loop
operator|->
name|num
argument_list|,
name|evolution_fn
argument_list|,
name|nb_iter
argument_list|)
expr_stmt|;
comment|/* Continue the computation until ending on a parent of LOOP.  */
return|return
name|compute_overall_effect_of_inner_loop
argument_list|(
name|loop
argument_list|,
name|res
argument_list|)
return|;
block|}
block|}
else|else
return|return
name|evolution_fn
return|;
block|}
comment|/* If the evolution function is an invariant, there is nothing to do.  */
elseif|else
if|if
condition|(
name|no_evolution_in_loop_p
argument_list|(
name|evolution_fn
argument_list|,
name|loop
operator|->
name|num
argument_list|,
operator|&
name|val
argument_list|)
operator|&&
name|val
condition|)
return|return
name|evolution_fn
return|;
else|else
return|return
name|chrec_dont_know
return|;
block|}
end_function

begin_comment
comment|/* Determine whether the CHREC is always positive/negative.  If the expression    cannot be statically analyzed, return false, otherwise set the answer into    VALUE.  */
end_comment

begin_function
name|bool
name|chrec_is_positive
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|bool
modifier|*
name|value
parameter_list|)
block|{
name|bool
name|value0
decl_stmt|,
name|value1
decl_stmt|,
name|value2
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|end_value
decl_stmt|,
name|nb_iter
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
if|if
condition|(
operator|!
name|chrec_is_positive
argument_list|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
operator|&
name|value0
argument_list|)
operator|||
operator|!
name|chrec_is_positive
argument_list|(
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|,
operator|&
name|value1
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* FIXME -- overflows.  */
if|if
condition|(
name|value0
operator|==
name|value1
condition|)
block|{
operator|*
name|value
operator|=
name|value0
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Otherwise the chrec is under the form: "{-197, +, 2}_1", 	 and the proof consists in showing that the sign never 	 changes during the execution of the loop, from 0 to 	 loop->nb_iterations.  */
if|if
condition|(
operator|!
name|evolution_function_is_affine_p
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|false
return|;
name|nb_iter
operator|=
name|number_of_iterations_in_loop
argument_list|(
name|current_loops
operator|->
name|parray
index|[
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|nb_iter
argument_list|)
condition|)
return|return
name|false
return|;
name|type
operator|=
name|chrec_type
argument_list|(
name|nb_iter
argument_list|)
expr_stmt|;
name|nb_iter
operator|=
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|nb_iter
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* TODO -- If the test is after the exit, we may decrease the number of 	 iterations by one.  */
block|if (after_exit) 	nb_iter = chrec_fold_minus (type, nb_iter, build_int_cst (type, 1));
endif|#
directive|endif
name|end_value
operator|=
name|chrec_apply
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|chrec
argument_list|,
name|nb_iter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chrec_is_positive
argument_list|(
name|end_value
argument_list|,
operator|&
name|value2
argument_list|)
condition|)
return|return
name|false
return|;
operator|*
name|value
operator|=
name|value0
expr_stmt|;
return|return
name|value0
operator|==
name|value1
return|;
case|case
name|INTEGER_CST
case|:
operator|*
name|value
operator|=
operator|(
name|tree_int_cst_sgn
argument_list|(
name|chrec
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_comment
comment|/* Associate CHREC to SCALAR.  */
end_comment

begin_function
specifier|static
name|void
name|set_scalar_evolution
parameter_list|(
name|tree
name|scalar
parameter_list|,
name|tree
name|chrec
parameter_list|)
block|{
name|tree
modifier|*
name|scalar_info
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|scalar
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return;
name|scalar_info
operator|=
name|find_var_scev_info
argument_list|(
name|scalar
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
if|if
condition|(
name|dump_flags
operator|&
name|TDF_DETAILS
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(set_scalar_evolution \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (scalar = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|scalar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n  (scalar_evolution = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|chrec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"))\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_flags
operator|&
name|TDF_STATS
condition|)
name|nb_set_scev
operator|++
expr_stmt|;
block|}
operator|*
name|scalar_info
operator|=
name|chrec
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve the chrec associated to SCALAR in the LOOP.  */
end_comment

begin_function
specifier|static
name|tree
name|get_scalar_evolution
parameter_list|(
name|tree
name|scalar
parameter_list|)
block|{
name|tree
name|res
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
if|if
condition|(
name|dump_flags
operator|&
name|TDF_DETAILS
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(get_scalar_evolution \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (scalar = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|scalar
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_flags
operator|&
name|TDF_STATS
condition|)
name|nb_get_scev
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|scalar
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
name|res
operator|=
operator|*
name|find_var_scev_info
argument_list|(
name|scalar
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
case|case
name|INTEGER_CST
case|:
name|res
operator|=
name|scalar
expr_stmt|;
break|break;
default|default:
name|res
operator|=
name|chrec_not_analyzed_yet
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (scalar_evolution = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"))\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Helper function for add_to_evolution.  Returns the evolution    function for an assignment of the form "a = b + c", where "a" and    "b" are on the strongly connected component.  CHREC_BEFORE is the    information that we already have collected up to this point.    TO_ADD is the evolution of "c".          When CHREC_BEFORE has an evolution part in LOOP_NB, add to this    evolution the expression TO_ADD, otherwise construct an evolution    part for this loop.  */
end_comment

begin_function
specifier|static
name|tree
name|add_to_evolution_1
parameter_list|(
name|unsigned
name|loop_nb
parameter_list|,
name|tree
name|chrec_before
parameter_list|,
name|tree
name|to_add
parameter_list|,
name|tree
name|at_stmt
parameter_list|)
block|{
name|tree
name|type
decl_stmt|,
name|left
decl_stmt|,
name|right
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec_before
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|chrec_before
argument_list|)
operator|<=
name|loop_nb
condition|)
block|{
name|unsigned
name|var
decl_stmt|;
name|type
operator|=
name|chrec_type
argument_list|(
name|chrec_before
argument_list|)
expr_stmt|;
comment|/* When there is no evolution part in this loop, build it.  */
if|if
condition|(
name|CHREC_VARIABLE
argument_list|(
name|chrec_before
argument_list|)
operator|<
name|loop_nb
condition|)
block|{
name|var
operator|=
name|loop_nb
expr_stmt|;
name|left
operator|=
name|chrec_before
expr_stmt|;
name|right
operator|=
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|?
name|build_real
argument_list|(
name|type
argument_list|,
name|dconst0
argument_list|)
else|:
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|var
operator|=
name|CHREC_VARIABLE
argument_list|(
name|chrec_before
argument_list|)
expr_stmt|;
name|left
operator|=
name|CHREC_LEFT
argument_list|(
name|chrec_before
argument_list|)
expr_stmt|;
name|right
operator|=
name|CHREC_RIGHT
argument_list|(
name|chrec_before
argument_list|)
expr_stmt|;
block|}
name|to_add
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|to_add
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
name|right
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|right
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
name|right
operator|=
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|right
argument_list|,
name|to_add
argument_list|)
expr_stmt|;
return|return
name|build_polynomial_chrec
argument_list|(
name|var
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Search the evolution in LOOP_NB.  */
name|left
operator|=
name|add_to_evolution_1
argument_list|(
name|loop_nb
argument_list|,
name|CHREC_LEFT
argument_list|(
name|chrec_before
argument_list|)
argument_list|,
name|to_add
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
name|right
operator|=
name|CHREC_RIGHT
argument_list|(
name|chrec_before
argument_list|)
expr_stmt|;
name|right
operator|=
name|chrec_convert
argument_list|(
name|chrec_type
argument_list|(
name|left
argument_list|)
argument_list|,
name|right
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec_before
argument_list|)
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
default|default:
comment|/* These nodes do not depend on a loop.  */
if|if
condition|(
name|chrec_before
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
name|left
operator|=
name|chrec_before
expr_stmt|;
name|right
operator|=
name|chrec_convert
argument_list|(
name|chrec_type
argument_list|(
name|left
argument_list|)
argument_list|,
name|to_add
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
return|return
name|build_polynomial_chrec
argument_list|(
name|loop_nb
argument_list|,
name|left
argument_list|,
name|right
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Add TO_ADD to the evolution part of CHREC_BEFORE in the dimension    of LOOP_NB.          Description (provided for completeness, for those who read code in    a plane, and for my poor 62 bytes brain that would have forgotten    all this in the next two or three months):        The algorithm of translation of programs from the SSA representation    into the chrecs syntax is based on a pattern matching.  After having    reconstructed the overall tree expression for a loop, there are only    two cases that can arise:        1. a = loop-phi (init, a + expr)    2. a = loop-phi (init, expr)        where EXPR is either a scalar constant with respect to the analyzed    loop (this is a degree 0 polynomial), or an expression containing    other loop-phi definitions (these are higher degree polynomials).        Examples:        1.     | init = ...    | loop_1    |   a = phi (init, a + 5)    | endloop        2.     | inita = ...    | initb = ...    | loop_1    |   a = phi (inita, 2 * b + 3)    |   b = phi (initb, b + 1)    | endloop        For the first case, the semantics of the SSA representation is:         | a (x) = init + \sum_{j = 0}^{x - 1} expr (j)        that is, there is a loop index "x" that determines the scalar value    of the variable during the loop execution.  During the first    iteration, the value is that of the initial condition INIT, while    during the subsequent iterations, it is the sum of the initial    condition with the sum of all the values of EXPR from the initial    iteration to the before last considered iteration.          For the second case, the semantics of the SSA program is:        | a (x) = init, if x = 0;    |         expr (x - 1), otherwise.        The second case corresponds to the PEELED_CHREC, whose syntax is    close to the syntax of a loop-phi-node:         | phi (init, expr)  vs.  (init, expr)_x        The proof of the translation algorithm for the first case is a    proof by structural induction based on the degree of EXPR.          Degree 0:    When EXPR is a constant with respect to the analyzed loop, or in    other words when EXPR is a polynomial of degree 0, the evolution of    the variable A in the loop is an affine function with an initial    condition INIT, and a step EXPR.  In order to show this, we start    from the semantics of the SSA representation:        f (x) = init + \sum_{j = 0}^{x - 1} expr (j)        and since "expr (j)" is a constant with respect to "j",        f (x) = init + x * expr         Finally, based on the semantics of the pure sum chrecs, by    identification we get the corresponding chrecs syntax:        f (x) = init * \binom{x}{0} + expr * \binom{x}{1}     f (x) -> {init, +, expr}_x        Higher degree:    Suppose that EXPR is a polynomial of degree N with respect to the    analyzed loop_x for which we have already determined that it is    written under the chrecs syntax:        | expr (x)  ->  {b_0, +, b_1, +, ..., +, b_{n-1}} (x)        We start from the semantics of the SSA program:        | f (x) = init + \sum_{j = 0}^{x - 1} expr (j)    |    | f (x) = init + \sum_{j = 0}^{x - 1}     |                (b_0 * \binom{j}{0} + ... + b_{n-1} * \binom{j}{n-1})    |    | f (x) = init + \sum_{j = 0}^{x - 1}     |                \sum_{k = 0}^{n - 1} (b_k * \binom{j}{k})     |    | f (x) = init + \sum_{k = 0}^{n - 1}     |                (b_k * \sum_{j = 0}^{x - 1} \binom{j}{k})     |    | f (x) = init + \sum_{k = 0}^{n - 1}     |                (b_k * \binom{x}{k + 1})     |    | f (x) = init + b_0 * \binom{x}{1} + ...     |              + b_{n-1} * \binom{x}{n}     |    | f (x) = init * \binom{x}{0} + b_0 * \binom{x}{1} + ...     |                             + b_{n-1} * \binom{x}{n}     |        And finally from the definition of the chrecs syntax, we identify:    | f (x)  ->  {init, +, b_0, +, ..., +, b_{n-1}}_x         This shows the mechanism that stands behind the add_to_evolution    function.  An important point is that the use of symbolic    parameters avoids the need of an analysis schedule.        Example:        | inita = ...    | initb = ...    | loop_1     |   a = phi (inita, a + 2 + b)    |   b = phi (initb, b + 1)    | endloop        When analyzing "a", the algorithm keeps "b" symbolically:        | a  ->  {inita, +, 2 + b}_1        Then, after instantiation, the analyzer ends on the evolution:        | a  ->  {inita, +, 2 + initb, +, 1}_1  */
end_comment

begin_function
specifier|static
name|tree
name|add_to_evolution
parameter_list|(
name|unsigned
name|loop_nb
parameter_list|,
name|tree
name|chrec_before
parameter_list|,
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|to_add
parameter_list|,
name|tree
name|at_stmt
parameter_list|)
block|{
name|tree
name|type
init|=
name|chrec_type
argument_list|(
name|to_add
argument_list|)
decl_stmt|;
name|tree
name|res
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|to_add
operator|==
name|NULL_TREE
condition|)
return|return
name|chrec_before
return|;
comment|/* TO_ADD is either a scalar, or a parameter.  TO_ADD is not      instantiated at this point.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|to_add
argument_list|)
operator|==
name|POLYNOMIAL_CHREC
condition|)
comment|/* This should not happen.  */
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(add_to_evolution \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (loop_nb = %d)\n"
argument_list|,
name|loop_nb
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (chrec_before = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|chrec_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n  (to_add = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|to_add
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|MINUS_EXPR
condition|)
name|to_add
operator|=
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|to_add
argument_list|,
name|SCALAR_FLOAT_TYPE_P
argument_list|(
name|type
argument_list|)
condition|?
name|build_real
argument_list|(
name|type
argument_list|,
name|dconstm1
argument_list|)
else|:
name|build_int_cst_type
argument_list|(
name|type
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|add_to_evolution_1
argument_list|(
name|loop_nb
argument_list|,
name|chrec_before
argument_list|,
name|to_add
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (res = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"))\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Helper function.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|set_nb_iterations_in_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|res
parameter_list|)
block|{
name|tree
name|type
init|=
name|chrec_type
argument_list|(
name|res
argument_list|)
decl_stmt|;
name|res
operator|=
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|res
argument_list|,
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME HWI: However we want to store one iteration less than the      count of the loop in order to be compatible with the other      nb_iter computations in loop-iv.  This also allows the      representation of nb_iters that are equal to MAX_INT.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|res
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|res
argument_list|)
operator|==
literal|0
operator|||
name|TREE_OVERFLOW
argument_list|(
name|res
argument_list|)
operator|)
condition|)
name|res
operator|=
name|chrec_dont_know
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (set_nb_iterations_in_loop = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"))\n"
argument_list|)
expr_stmt|;
block|}
name|loop
operator|->
name|nb_iterations
operator|=
name|res
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This section selects the loops that will be good candidates for the    scalar evolution analysis.  For the moment, greedily select all the    loop nests we could analyze.  */
end_comment

begin_comment
comment|/* Return true when it is possible to analyze the condition expression    EXPR.  */
end_comment

begin_function
specifier|static
name|bool
name|analyzable_condition
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|condition
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|COND_EXPR
condition|)
return|return
name|false
return|;
name|condition
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|condition
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
return|return
name|true
return|;
case|case
name|LT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* For a loop with a single exit edge, return the COND_EXPR that    guards the exit edge.  If the expression is too difficult to    analyze, then give up.  */
end_comment

begin_function
name|tree
name|get_loop_exit_condition
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|tree
name|res
init|=
name|NULL_TREE
decl_stmt|;
name|edge
name|exit_edge
init|=
name|loop
operator|->
name|single_exit
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(get_loop_exit_condition \n  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_edge
condition|)
block|{
name|tree
name|expr
decl_stmt|;
name|expr
operator|=
name|last_stmt
argument_list|(
name|exit_edge
operator|->
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|analyzable_condition
argument_list|(
name|expr
argument_list|)
condition|)
name|res
operator|=
name|expr
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Recursively determine and enqueue the exit conditions for a loop.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|get_exit_conditions_rec
argument_list|(
expr|struct
name|loop
operator|*
name|loop
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|exit_conditions
argument_list|)
block|{
if|if
condition|(
operator|!
name|loop
condition|)
return|return;
comment|/* Recurse on the inner loops, then on the next (sibling) loops.  */
name|get_exit_conditions_rec
argument_list|(
name|loop
operator|->
name|inner
argument_list|,
name|exit_conditions
argument_list|)
expr_stmt|;
name|get_exit_conditions_rec
argument_list|(
name|loop
operator|->
name|next
argument_list|,
name|exit_conditions
argument_list|)
expr_stmt|;
if|if
condition|(
name|loop
operator|->
name|single_exit
condition|)
block|{
name|tree
name|loop_condition
init|=
name|get_loop_exit_condition
argument_list|(
name|loop
argument_list|)
decl_stmt|;
if|if
condition|(
name|loop_condition
condition|)
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
operator|*
name|exit_conditions
argument_list|,
name|loop_condition
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Select the candidate loop nests for the analysis.  This function    initializes the EXIT_CONDITIONS array.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|select_loops_exit_conditions
argument_list|(
expr|struct
name|loops
operator|*
name|loops
argument_list|,
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|exit_conditions
argument_list|)
block|{
name|struct
name|loop
modifier|*
name|function_body
init|=
name|loops
operator|->
name|parray
index|[
literal|0
index|]
decl_stmt|;
name|get_exit_conditions_rec
argument_list|(
name|function_body
operator|->
name|inner
argument_list|,
name|exit_conditions
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Depth first search algorithm.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|t_bool
block|{
name|t_false
block|,
name|t_true
block|,
name|t_dont_know
block|}
name|t_bool
typedef|;
end_typedef

begin_function_decl
specifier|static
name|t_bool
name|follow_ssa_edge
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Follow the ssa edge into the right hand side RHS of an assignment.    Return true if the strongly connected component has been found.  */
end_comment

begin_function
specifier|static
name|t_bool
name|follow_ssa_edge_in_rhs
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|at_stmt
parameter_list|,
name|tree
name|rhs
parameter_list|,
name|tree
name|halting_phi
parameter_list|,
name|tree
modifier|*
name|evolution_of_loop
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|t_bool
name|res
init|=
name|t_false
decl_stmt|;
name|tree
name|rhs0
decl_stmt|,
name|rhs1
decl_stmt|;
name|tree
name|type_rhs
init|=
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
name|tree
name|evol
decl_stmt|;
comment|/* The RHS is one of the following cases:      - an SSA_NAME,       - an INTEGER_CST,      - a PLUS_EXPR,       - a MINUS_EXPR,      - an ASSERT_EXPR,      - other cases are not yet handled.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|NOP_EXPR
case|:
comment|/* This assignment is under the form "a_1 = (cast) rhs.  */
name|res
operator|=
name|follow_ssa_edge_in_rhs
argument_list|(
name|loop
argument_list|,
name|at_stmt
argument_list|,
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
expr_stmt|;
operator|*
name|evolution_of_loop
operator|=
name|chrec_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
operator|*
name|evolution_of_loop
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTEGER_CST
case|:
comment|/* This assignment is under the form "a_1 = 7".  */
name|res
operator|=
name|t_false
expr_stmt|;
break|break;
case|case
name|SSA_NAME
case|:
comment|/* This assignment is under the form: "a_1 = b_2".  */
name|res
operator|=
name|follow_ssa_edge
argument_list|(
name|loop
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLUS_EXPR
case|:
comment|/* This case is under the form "rhs0 + rhs1".  */
name|rhs0
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs1
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|rhs0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|rhs1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs0
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs1
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
comment|/* Match an assignment under the form:  		 "a = b + c".  */
name|evol
operator|=
operator|*
name|evolution_of_loop
expr_stmt|;
name|res
operator|=
name|follow_ssa_edge
argument_list|(
name|loop
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|rhs0
argument_list|)
argument_list|,
name|halting_phi
argument_list|,
operator|&
name|evol
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|t_true
condition|)
operator|*
name|evolution_of_loop
operator|=
name|add_to_evolution
argument_list|(
name|loop
operator|->
name|num
argument_list|,
name|chrec_convert
argument_list|(
name|type_rhs
argument_list|,
name|evol
argument_list|,
name|at_stmt
argument_list|)
argument_list|,
name|PLUS_EXPR
argument_list|,
name|rhs1
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|res
operator|==
name|t_false
condition|)
block|{
name|res
operator|=
name|follow_ssa_edge
argument_list|(
name|loop
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|rhs1
argument_list|)
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|t_true
condition|)
operator|*
name|evolution_of_loop
operator|=
name|add_to_evolution
argument_list|(
name|loop
operator|->
name|num
argument_list|,
name|chrec_convert
argument_list|(
name|type_rhs
argument_list|,
operator|*
name|evolution_of_loop
argument_list|,
name|at_stmt
argument_list|)
argument_list|,
name|PLUS_EXPR
argument_list|,
name|rhs0
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|res
operator|==
name|t_dont_know
condition|)
operator|*
name|evolution_of_loop
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|==
name|t_dont_know
condition|)
operator|*
name|evolution_of_loop
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
else|else
block|{
comment|/* Match an assignment under the form:  		 "a = b + ...".  */
name|res
operator|=
name|follow_ssa_edge
argument_list|(
name|loop
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|rhs0
argument_list|)
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|t_true
condition|)
operator|*
name|evolution_of_loop
operator|=
name|add_to_evolution
argument_list|(
name|loop
operator|->
name|num
argument_list|,
name|chrec_convert
argument_list|(
name|type_rhs
argument_list|,
operator|*
name|evolution_of_loop
argument_list|,
name|at_stmt
argument_list|)
argument_list|,
name|PLUS_EXPR
argument_list|,
name|rhs1
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|res
operator|==
name|t_dont_know
condition|)
operator|*
name|evolution_of_loop
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs1
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
comment|/* Match an assignment under the form:  	     "a = ... + c".  */
name|res
operator|=
name|follow_ssa_edge
argument_list|(
name|loop
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|rhs1
argument_list|)
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|t_true
condition|)
operator|*
name|evolution_of_loop
operator|=
name|add_to_evolution
argument_list|(
name|loop
operator|->
name|num
argument_list|,
name|chrec_convert
argument_list|(
name|type_rhs
argument_list|,
operator|*
name|evolution_of_loop
argument_list|,
name|at_stmt
argument_list|)
argument_list|,
name|PLUS_EXPR
argument_list|,
name|rhs0
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|res
operator|==
name|t_dont_know
condition|)
operator|*
name|evolution_of_loop
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
else|else
comment|/* Otherwise, match an assignment under the form:  	   "a = ... + ...".  */
comment|/* And there is nothing to do.  */
name|res
operator|=
name|t_false
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* This case is under the form "opnd0 = rhs0 - rhs1".  */
name|rhs0
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs1
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|rhs0
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|rhs1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs0
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
comment|/* Match an assignment under the form:  	     "a = b - ...".  */
name|res
operator|=
name|follow_ssa_edge
argument_list|(
name|loop
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|rhs0
argument_list|)
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|t_true
condition|)
operator|*
name|evolution_of_loop
operator|=
name|add_to_evolution
argument_list|(
name|loop
operator|->
name|num
argument_list|,
name|chrec_convert
argument_list|(
name|type_rhs
argument_list|,
operator|*
name|evolution_of_loop
argument_list|,
name|at_stmt
argument_list|)
argument_list|,
name|MINUS_EXPR
argument_list|,
name|rhs1
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|res
operator|==
name|t_dont_know
condition|)
operator|*
name|evolution_of_loop
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
else|else
comment|/* Otherwise, match an assignment under the form:  	   "a = ... - ...".  */
comment|/* And there is nothing to do.  */
name|res
operator|=
name|t_false
expr_stmt|;
break|break;
case|case
name|ASSERT_EXPR
case|:
block|{
comment|/* This assignment is of the form: "a_1 = ASSERT_EXPR<a_2, ...>" 	   It must be handled as a copy assignment of the form a_1 = a_2.  */
name|tree
name|op0
init|=
name|ASSERT_EXPR_VAR
argument_list|(
name|rhs
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|res
operator|=
name|follow_ssa_edge
argument_list|(
name|loop
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|op0
argument_list|)
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|t_false
expr_stmt|;
break|break;
block|}
default|default:
name|res
operator|=
name|t_false
expr_stmt|;
break|break;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Checks whether the I-th argument of a PHI comes from a backedge.  */
end_comment

begin_function
specifier|static
name|bool
name|backedge_phi_arg_p
parameter_list|(
name|tree
name|phi
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|edge
name|e
init|=
name|PHI_ARG_EDGE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* We would in fact like to test EDGE_DFS_BACK here, but we do not care      about updating it anywhere, and this should work as well most of the      time.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Helper function for one branch of the condition-phi-node.  Return    true if the strongly connected component has been found following    this path.  */
end_comment

begin_function
specifier|static
specifier|inline
name|t_bool
name|follow_ssa_edge_in_condition_phi_branch
parameter_list|(
name|int
name|i
parameter_list|,
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|condition_phi
parameter_list|,
name|tree
name|halting_phi
parameter_list|,
name|tree
modifier|*
name|evolution_of_branch
parameter_list|,
name|tree
name|init_cond
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|tree
name|branch
init|=
name|PHI_ARG_DEF
argument_list|(
name|condition_phi
argument_list|,
name|i
argument_list|)
decl_stmt|;
operator|*
name|evolution_of_branch
operator|=
name|chrec_dont_know
expr_stmt|;
comment|/* Do not follow back edges (they must belong to an irreducible loop, which      we really do not want to worry about).  */
if|if
condition|(
name|backedge_phi_arg_p
argument_list|(
name|condition_phi
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|t_false
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|branch
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
operator|*
name|evolution_of_branch
operator|=
name|init_cond
expr_stmt|;
return|return
name|follow_ssa_edge
argument_list|(
name|loop
argument_list|,
name|SSA_NAME_DEF_STMT
argument_list|(
name|branch
argument_list|)
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_branch
argument_list|,
name|limit
argument_list|)
return|;
block|}
comment|/* This case occurs when one of the condition branches sets       the variable to a constant: i.e. a phi-node like      "a_2 = PHI<a_7(5), 2(6)>;".   	       FIXME:  This case have to be refined correctly:       in some cases it is possible to say something better than      chrec_dont_know, for example using a wrap-around notation.  */
return|return
name|t_false
return|;
block|}
end_function

begin_comment
comment|/* This function merges the branches of a condition-phi-node in a    loop.  */
end_comment

begin_function
specifier|static
name|t_bool
name|follow_ssa_edge_in_condition_phi
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|condition_phi
parameter_list|,
name|tree
name|halting_phi
parameter_list|,
name|tree
modifier|*
name|evolution_of_loop
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|init
init|=
operator|*
name|evolution_of_loop
decl_stmt|;
name|tree
name|evolution_of_branch
decl_stmt|;
name|t_bool
name|res
init|=
name|follow_ssa_edge_in_condition_phi_branch
argument_list|(
literal|0
argument_list|,
name|loop
argument_list|,
name|condition_phi
argument_list|,
name|halting_phi
argument_list|,
operator|&
name|evolution_of_branch
argument_list|,
name|init
argument_list|,
name|limit
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|t_false
operator|||
name|res
operator|==
name|t_dont_know
condition|)
return|return
name|res
return|;
operator|*
name|evolution_of_loop
operator|=
name|evolution_of_branch
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|condition_phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Quickly give up when the evolution of one of the branches is 	 not known.  */
if|if
condition|(
operator|*
name|evolution_of_loop
operator|==
name|chrec_dont_know
condition|)
return|return
name|t_true
return|;
name|res
operator|=
name|follow_ssa_edge_in_condition_phi_branch
argument_list|(
name|i
argument_list|,
name|loop
argument_list|,
name|condition_phi
argument_list|,
name|halting_phi
argument_list|,
operator|&
name|evolution_of_branch
argument_list|,
name|init
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|t_false
operator|||
name|res
operator|==
name|t_dont_know
condition|)
return|return
name|res
return|;
operator|*
name|evolution_of_loop
operator|=
name|chrec_merge
argument_list|(
operator|*
name|evolution_of_loop
argument_list|,
name|evolution_of_branch
argument_list|)
expr_stmt|;
block|}
return|return
name|t_true
return|;
block|}
end_function

begin_comment
comment|/* Follow an SSA edge in an inner loop.  It computes the overall    effect of the loop, and following the symbolic initial conditions,    it follows the edges in the parent loop.  The inner loop is    considered as a single statement.  */
end_comment

begin_function
specifier|static
name|t_bool
name|follow_ssa_edge_inner_loop_phi
parameter_list|(
name|struct
name|loop
modifier|*
name|outer_loop
parameter_list|,
name|tree
name|loop_phi_node
parameter_list|,
name|tree
name|halting_phi
parameter_list|,
name|tree
modifier|*
name|evolution_of_loop
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
init|=
name|loop_containing_stmt
argument_list|(
name|loop_phi_node
argument_list|)
decl_stmt|;
name|tree
name|ev
init|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|PHI_RESULT
argument_list|(
name|loop_phi_node
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Sometimes, the inner loop is too difficult to analyze, and the      result of the analysis is a symbolic parameter.  */
if|if
condition|(
name|ev
operator|==
name|PHI_RESULT
argument_list|(
name|loop_phi_node
argument_list|)
condition|)
block|{
name|t_bool
name|res
init|=
name|t_false
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|loop_phi_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|loop_phi_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
comment|/* Follow the edges that exit the inner loop.  */
name|bb
operator|=
name|PHI_ARG_EDGE
argument_list|(
name|loop_phi_node
argument_list|,
name|i
argument_list|)
operator|->
name|src
expr_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
name|res
operator|=
name|follow_ssa_edge_in_rhs
argument_list|(
name|outer_loop
argument_list|,
name|loop_phi_node
argument_list|,
name|arg
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|t_true
condition|)
break|break;
block|}
comment|/* If the path crosses this loop-phi, give up.  */
if|if
condition|(
name|res
operator|==
name|t_true
condition|)
operator|*
name|evolution_of_loop
operator|=
name|chrec_dont_know
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* Otherwise, compute the overall effect of the inner loop.  */
name|ev
operator|=
name|compute_overall_effect_of_inner_loop
argument_list|(
name|loop
argument_list|,
name|ev
argument_list|)
expr_stmt|;
return|return
name|follow_ssa_edge_in_rhs
argument_list|(
name|outer_loop
argument_list|,
name|loop_phi_node
argument_list|,
name|ev
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Follow an SSA edge from a loop-phi-node to itself, constructing a    path that is analyzed on the return walk.  */
end_comment

begin_function
specifier|static
name|t_bool
name|follow_ssa_edge
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|def
parameter_list|,
name|tree
name|halting_phi
parameter_list|,
name|tree
modifier|*
name|evolution_of_loop
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|def_loop
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
operator|==
name|NOP_EXPR
condition|)
return|return
name|t_false
return|;
comment|/* Give up if the path is longer than the MAX that we allow.  */
if|if
condition|(
name|limit
operator|++
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_SCEV_MAX_EXPR_SIZE
argument_list|)
condition|)
return|return
name|t_dont_know
return|;
name|def_loop
operator|=
name|loop_containing_stmt
argument_list|(
name|def
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
condition|)
block|{
case|case
name|PHI_NODE
case|:
if|if
condition|(
operator|!
name|loop_phi_node_p
argument_list|(
name|def
argument_list|)
condition|)
comment|/* DEF is a condition-phi-node.  Follow the branches, and 	   record their evolutions.  Finally, merge the collected 	   information and set the approximation to the main 	   variable.  */
return|return
name|follow_ssa_edge_in_condition_phi
argument_list|(
name|loop
argument_list|,
name|def
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
return|;
comment|/* When the analyzed phi is the halting_phi, the 	 depth-first search is over: we have found a path from 	 the halting_phi to itself in the loop.  */
if|if
condition|(
name|def
operator|==
name|halting_phi
condition|)
return|return
name|t_true
return|;
comment|/* Otherwise, the evolution of the HALTING_PHI depends 	 on the evolution of another loop-phi-node, i.e. the 	 evolution function is a higher degree polynomial.  */
if|if
condition|(
name|def_loop
operator|==
name|loop
condition|)
return|return
name|t_false
return|;
comment|/* Inner loop.  */
if|if
condition|(
name|flow_loop_nested_p
argument_list|(
name|loop
argument_list|,
name|def_loop
argument_list|)
condition|)
return|return
name|follow_ssa_edge_inner_loop_phi
argument_list|(
name|loop
argument_list|,
name|def
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
return|;
comment|/* Outer loop.  */
return|return
name|t_false
return|;
case|case
name|MODIFY_EXPR
case|:
return|return
name|follow_ssa_edge_in_rhs
argument_list|(
name|loop
argument_list|,
name|def
argument_list|,
name|TREE_OPERAND
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|,
name|halting_phi
argument_list|,
name|evolution_of_loop
argument_list|,
name|limit
argument_list|)
return|;
default|default:
comment|/* At this level of abstraction, the program is just a set 	 of MODIFY_EXPRs and PHI_NODEs.  In principle there is no 	 other node to be handled.  */
return|return
name|t_false
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a LOOP_PHI_NODE, this function determines the evolution    function from LOOP_PHI_NODE to LOOP_PHI_NODE in the loop.  */
end_comment

begin_function
specifier|static
name|tree
name|analyze_evolution_in_loop
parameter_list|(
name|tree
name|loop_phi_node
parameter_list|,
name|tree
name|init_cond
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|evolution_function
init|=
name|chrec_not_analyzed_yet
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|loop_containing_stmt
argument_list|(
name|loop_phi_node
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(analyze_evolution_in_loop \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (loop_phi_node = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|loop_phi_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|loop_phi_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|arg
init|=
name|PHI_ARG_DEF
argument_list|(
name|loop_phi_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|ssa_chain
decl_stmt|,
name|ev_fn
decl_stmt|;
name|t_bool
name|res
decl_stmt|;
comment|/* Select the edges that enter the loop body.  */
name|bb
operator|=
name|PHI_ARG_EDGE
argument_list|(
name|loop_phi_node
argument_list|,
name|i
argument_list|)
operator|->
name|src
expr_stmt|;
if|if
condition|(
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|ssa_chain
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* Pass in the initial condition to the follow edge function.  */
name|ev_fn
operator|=
name|init_cond
expr_stmt|;
name|res
operator|=
name|follow_ssa_edge
argument_list|(
name|loop
argument_list|,
name|ssa_chain
argument_list|,
name|loop_phi_node
argument_list|,
operator|&
name|ev_fn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
name|t_false
expr_stmt|;
comment|/* When it is impossible to go back on the same 	 loop_phi_node by following the ssa edges, the 	 evolution is represented by a peeled chrec, i.e. the 	 first iteration, EV_FN has the value INIT_COND, then 	 all the other iterations it has the value of ARG.   	 For the moment, PEELED_CHREC nodes are not built.  */
if|if
condition|(
name|res
operator|!=
name|t_true
condition|)
name|ev_fn
operator|=
name|chrec_dont_know
expr_stmt|;
comment|/* When there are multiple back edges of the loop (which in fact never 	 happens currently, but nevertheless), merge their evolutions.  */
name|evolution_function
operator|=
name|chrec_merge
argument_list|(
name|evolution_function
argument_list|,
name|ev_fn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (evolution_function = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|evolution_function
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"))\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|evolution_function
return|;
block|}
end_function

begin_comment
comment|/* Given a loop-phi-node, return the initial conditions of the    variable on entry of the loop.  When the CCP has propagated    constants into the loop-phi-node, the initial condition is    instantiated, otherwise the initial condition is kept symbolic.    This analyzer does not analyze the evolution outside the current    loop, and leaves this task to the on-demand tree reconstructor.  */
end_comment

begin_function
specifier|static
name|tree
name|analyze_initial_condition
parameter_list|(
name|tree
name|loop_phi_node
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|init_cond
init|=
name|chrec_not_analyzed_yet
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
init|=
name|bb_for_stmt
argument_list|(
name|loop_phi_node
argument_list|)
operator|->
name|loop_father
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(analyze_initial_condition \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (loop_phi_node = \n"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|loop_phi_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|loop_phi_node
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|branch
init|=
name|PHI_ARG_DEF
argument_list|(
name|loop_phi_node
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|basic_block
name|bb
init|=
name|PHI_ARG_EDGE
argument_list|(
name|loop_phi_node
argument_list|,
name|i
argument_list|)
operator|->
name|src
decl_stmt|;
comment|/* When the branch is oriented to the loop's body, it does      	 not contribute to the initial condition.  */
if|if
condition|(
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|init_cond
operator|==
name|chrec_not_analyzed_yet
condition|)
block|{
name|init_cond
operator|=
name|branch
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|branch
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|init_cond
operator|=
name|chrec_dont_know
expr_stmt|;
break|break;
block|}
name|init_cond
operator|=
name|chrec_merge
argument_list|(
name|init_cond
argument_list|,
name|branch
argument_list|)
expr_stmt|;
block|}
comment|/* Ooops -- a loop without an entry???  */
if|if
condition|(
name|init_cond
operator|==
name|chrec_not_analyzed_yet
condition|)
name|init_cond
operator|=
name|chrec_dont_know
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (init_cond = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|init_cond
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"))\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|init_cond
return|;
block|}
end_function

begin_comment
comment|/* Analyze the scalar evolution for LOOP_PHI_NODE.  */
end_comment

begin_function
specifier|static
name|tree
name|interpret_loop_phi
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|loop_phi_node
parameter_list|)
block|{
name|tree
name|res
decl_stmt|;
name|struct
name|loop
modifier|*
name|phi_loop
init|=
name|loop_containing_stmt
argument_list|(
name|loop_phi_node
argument_list|)
decl_stmt|;
name|tree
name|init_cond
decl_stmt|;
if|if
condition|(
name|phi_loop
operator|!=
name|loop
condition|)
block|{
name|struct
name|loop
modifier|*
name|subloop
decl_stmt|;
name|tree
name|evolution_fn
init|=
name|analyze_scalar_evolution
argument_list|(
name|phi_loop
argument_list|,
name|PHI_RESULT
argument_list|(
name|loop_phi_node
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Dive one level deeper.  */
name|subloop
operator|=
name|superloop_at_depth
argument_list|(
name|phi_loop
argument_list|,
name|loop
operator|->
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Interpret the subloop.  */
name|res
operator|=
name|compute_overall_effect_of_inner_loop
argument_list|(
name|subloop
argument_list|,
name|evolution_fn
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* Otherwise really interpret the loop phi.  */
name|init_cond
operator|=
name|analyze_initial_condition
argument_list|(
name|loop_phi_node
argument_list|)
expr_stmt|;
name|res
operator|=
name|analyze_evolution_in_loop
argument_list|(
name|loop_phi_node
argument_list|,
name|init_cond
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* This function merges the branches of a condition-phi-node,    contained in the outermost loop, and whose arguments are already    analyzed.  */
end_comment

begin_function
specifier|static
name|tree
name|interpret_condition_phi
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|condition_phi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|tree
name|res
init|=
name|chrec_not_analyzed_yet
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|condition_phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|branch_chrec
decl_stmt|;
if|if
condition|(
name|backedge_phi_arg_p
argument_list|(
name|condition_phi
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|res
operator|=
name|chrec_dont_know
expr_stmt|;
break|break;
block|}
name|branch_chrec
operator|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|PHI_ARG_DEF
argument_list|(
name|condition_phi
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|chrec_merge
argument_list|(
name|res
argument_list|,
name|branch_chrec
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Interpret the right hand side of a modify_expr OPND1.  If we didn't    analyze this node before, follow the definitions until ending    either on an analyzed modify_expr, or on a loop-phi-node.  On the    return path, this function propagates evolutions (ala constant copy    propagation).  OPND1 is not a GIMPLE expression because we could    analyze the effect of an inner loop: see interpret_loop_phi.  */
end_comment

begin_function
specifier|static
name|tree
name|interpret_rhs_modify_expr
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|at_stmt
parameter_list|,
name|tree
name|opnd1
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
name|tree
name|res
decl_stmt|,
name|opnd10
decl_stmt|,
name|opnd11
decl_stmt|,
name|chrec10
decl_stmt|,
name|chrec11
decl_stmt|;
if|if
condition|(
name|is_gimple_min_invariant
argument_list|(
name|opnd1
argument_list|)
condition|)
return|return
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|opnd1
argument_list|,
name|at_stmt
argument_list|)
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|opnd1
argument_list|)
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|opnd10
operator|=
name|TREE_OPERAND
argument_list|(
name|opnd1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opnd11
operator|=
name|TREE_OPERAND
argument_list|(
name|opnd1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chrec10
operator|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|opnd10
argument_list|)
expr_stmt|;
name|chrec11
operator|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|opnd11
argument_list|)
expr_stmt|;
name|chrec10
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|chrec10
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
name|chrec11
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|chrec11
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
name|res
operator|=
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|chrec10
argument_list|,
name|chrec11
argument_list|)
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|opnd10
operator|=
name|TREE_OPERAND
argument_list|(
name|opnd1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opnd11
operator|=
name|TREE_OPERAND
argument_list|(
name|opnd1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chrec10
operator|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|opnd10
argument_list|)
expr_stmt|;
name|chrec11
operator|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|opnd11
argument_list|)
expr_stmt|;
name|chrec10
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|chrec10
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
name|chrec11
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|chrec11
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
name|res
operator|=
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|chrec10
argument_list|,
name|chrec11
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEGATE_EXPR
case|:
name|opnd10
operator|=
name|TREE_OPERAND
argument_list|(
name|opnd1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chrec10
operator|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|opnd10
argument_list|)
expr_stmt|;
name|chrec10
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|chrec10
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
comment|/* TYPE may be integer, real or complex, so use fold_convert.  */
name|res
operator|=
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|chrec10
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|integer_minus_one_node
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|opnd10
operator|=
name|TREE_OPERAND
argument_list|(
name|opnd1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|opnd11
operator|=
name|TREE_OPERAND
argument_list|(
name|opnd1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chrec10
operator|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|opnd10
argument_list|)
expr_stmt|;
name|chrec11
operator|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|opnd11
argument_list|)
expr_stmt|;
name|chrec10
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|chrec10
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
name|chrec11
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|chrec11
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
name|res
operator|=
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|chrec10
argument_list|,
name|chrec11
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSA_NAME
case|:
name|res
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|opnd1
argument_list|)
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASSERT_EXPR
case|:
name|opnd10
operator|=
name|ASSERT_EXPR_VAR
argument_list|(
name|opnd1
argument_list|)
expr_stmt|;
name|res
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|opnd10
argument_list|)
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
name|opnd10
operator|=
name|TREE_OPERAND
argument_list|(
name|opnd1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chrec10
operator|=
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|opnd10
argument_list|)
expr_stmt|;
name|res
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|chrec10
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|res
operator|=
name|chrec_dont_know
expr_stmt|;
break|break;
block|}
return|return
name|res
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This section contains all the entry points:     - number_of_iterations_in_loop,    - analyze_scalar_evolution,    - instantiate_parameters. */
end_comment

begin_comment
comment|/* Compute and return the evolution function in WRTO_LOOP, the nearest    common ancestor of DEF_LOOP and USE_LOOP.  */
end_comment

begin_function
specifier|static
name|tree
name|compute_scalar_evolution_in_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|wrto_loop
parameter_list|,
name|struct
name|loop
modifier|*
name|def_loop
parameter_list|,
name|tree
name|ev
parameter_list|)
block|{
name|tree
name|res
decl_stmt|;
if|if
condition|(
name|def_loop
operator|==
name|wrto_loop
condition|)
return|return
name|ev
return|;
name|def_loop
operator|=
name|superloop_at_depth
argument_list|(
name|def_loop
argument_list|,
name|wrto_loop
operator|->
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
name|res
operator|=
name|compute_overall_effect_of_inner_loop
argument_list|(
name|def_loop
argument_list|,
name|ev
argument_list|)
expr_stmt|;
return|return
name|analyze_scalar_evolution_1
argument_list|(
name|wrto_loop
argument_list|,
name|res
argument_list|,
name|chrec_not_analyzed_yet
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Folds EXPR, if it is a cast to pointer, assuming that the created    polynomial_chrec does not wrap.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_used_pointer_cast
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|op
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|inner_type
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|CONVERT_EXPR
condition|)
return|return
name|expr
return|;
name|op
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op
argument_list|)
operator|!=
name|POLYNOMIAL_CHREC
condition|)
return|return
name|expr
return|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|inner_type
operator|=
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|inner_type
argument_list|)
operator|||
name|TYPE_PRECISION
argument_list|(
name|inner_type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|expr
return|;
return|return
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|op
argument_list|)
argument_list|,
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|CHREC_LEFT
argument_list|(
name|op
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|op
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if EXPR is an expression corresponding to offset of pointer    in p + offset.  */
end_comment

begin_function
specifier|static
name|bool
name|pointer_offset_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* EXPR is a scalar evolution of a pointer that is dereferenced or used in    comparison.  This means that it must point to a part of some object in    memory, which enables us to argue about overflows and possibly simplify    the EXPR.  AT_STMT is the statement in which this conversion has to be    performed.  Returns the simplified value.     Currently, for     int i, n;    int *p;     for (i = -n; i< n; i++)      *(p + i) = ...;     We generate the following code (assuming that size of int and size_t is    4 bytes):     for (i = -n; i< n; i++)      {        size_t tmp1, tmp2;        int *tmp3, *tmp4;         tmp1 = (size_t) i;	(1)        tmp2 = 4 * tmp1;		(2)        tmp3 = (int *) tmp2;	(3)        tmp4 = p + tmp3;		(4)         *tmp4 = ...;      }     We in general assume that pointer arithmetics does not overflow (since its    behavior is undefined in that case).  One of the problems is that our    translation does not capture this property very well -- (int *) is    considered unsigned, hence the computation in (4) does overflow if i is    negative.     This impreciseness creates complications in scev analysis.  The scalar    evolution of i is [-n, +, 1].  Since int and size_t have the same precision    (in this example), and size_t is unsigned (so we do not care about    overflows), we succeed to derive that scev of tmp1 is [(size_t) -n, +, 1]    and scev of tmp2 is [4 * (size_t) -n, +, 4].  With tmp3, we run into    problem -- [(int *) (4 * (size_t) -n), +, 4] wraps, and since we on several    places assume that this is not the case for scevs with pointer type, we    cannot use this scev for tmp3; hence, its scev is    (int *) [(4 * (size_t) -n), +, 4], and scev of tmp4 is    p + (int *) [(4 * (size_t) -n), +, 4].  Most of the optimizers are unable to    work with scevs of this shape.     However, since tmp4 is dereferenced, all its values must belong to a single    object, and taking into account that the precision of int * and size_t is    the same, it is impossible for its scev to wrap.  Hence, we can derive that    its evolution is [p + (int *) (4 * (size_t) -n), +, 4], which the optimizers    can work with.     ??? Maybe we should use different representation for pointer arithmetics,    however that is a long-term project with a lot of potential for creating    bugs.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_used_pointer
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|at_stmt
parameter_list|)
block|{
name|tree
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|new0
decl_stmt|,
name|new1
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MINUS_EXPR
condition|)
block|{
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointer_offset_p
argument_list|(
name|op1
argument_list|)
condition|)
block|{
name|new0
operator|=
name|fold_used_pointer
argument_list|(
name|op0
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
name|new1
operator|=
name|fold_used_pointer_cast
argument_list|(
name|op1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|&&
name|pointer_offset_p
argument_list|(
name|op0
argument_list|)
condition|)
block|{
name|new0
operator|=
name|fold_used_pointer_cast
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|new1
operator|=
name|fold_used_pointer
argument_list|(
name|op1
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|expr
return|;
if|if
condition|(
name|new0
operator|==
name|op0
operator|&&
name|new1
operator|==
name|op1
condition|)
return|return
name|expr
return|;
name|new0
operator|=
name|chrec_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|new0
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
name|new1
operator|=
name|chrec_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|new1
argument_list|,
name|at_stmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
condition|)
name|expr
operator|=
name|chrec_fold_plus
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|new0
argument_list|,
name|new1
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|chrec_fold_minus
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|new0
argument_list|,
name|new1
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
else|else
return|return
name|fold_used_pointer_cast
argument_list|(
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns true if PTR is dereferenced, or used in comparison.  */
end_comment

begin_function
specifier|static
name|bool
name|pointer_used_p
parameter_list|(
name|tree
name|ptr
parameter_list|)
block|{
name|use_operand_p
name|use_p
decl_stmt|;
name|imm_use_iterator
name|imm_iter
decl_stmt|;
name|tree
name|stmt
decl_stmt|,
name|rhs
decl_stmt|;
name|struct
name|ptr_info_def
modifier|*
name|pi
init|=
name|get_ptr_info
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|var_ann_t
name|v_ann
init|=
name|var_ann
argument_list|(
name|SSA_NAME_VAR
argument_list|(
name|ptr
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Check whether the pointer has a memory tag; if it does, it is      (or at least used to be) dereferenced.  */
if|if
condition|(
operator|(
name|pi
operator|!=
name|NULL
operator|&&
name|pi
operator|->
name|name_mem_tag
operator|!=
name|NULL
operator|)
operator|||
name|v_ann
operator|->
name|symbol_mem_tag
condition|)
return|return
name|true
return|;
name|FOR_EACH_IMM_USE_FAST
argument_list|(
argument|use_p
argument_list|,
argument|imm_iter
argument_list|,
argument|ptr
argument_list|)
block|{
name|stmt
operator|=
name|USE_STMT
argument_list|(
name|use_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|COND_EXPR
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|!=
name|MODIFY_EXPR
condition|)
continue|continue;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|COMPARISON_CLASS_P
argument_list|(
name|rhs
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|==
name|ptr
operator|||
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
operator|==
name|ptr
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Helper recursive function.  */
end_comment

begin_function
specifier|static
name|tree
name|analyze_scalar_evolution_1
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|var
parameter_list|,
name|tree
name|res
parameter_list|)
block|{
name|tree
name|def
decl_stmt|,
name|type
init|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|struct
name|loop
modifier|*
name|def_loop
decl_stmt|;
if|if
condition|(
name|loop
operator|==
name|NULL
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|interpret_rhs_modify_expr
argument_list|(
name|loop
argument_list|,
name|NULL_TREE
argument_list|,
name|var
argument_list|,
name|type
argument_list|)
return|;
name|def
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb_for_stmt
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|def_loop
operator|=
name|bb
condition|?
name|bb
operator|->
name|loop_father
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|bb
operator|==
name|NULL
operator|||
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|bb
argument_list|)
condition|)
block|{
comment|/* Keep the symbolic form.  */
name|res
operator|=
name|var
expr_stmt|;
goto|goto
name|set_and_end
goto|;
block|}
if|if
condition|(
name|res
operator|!=
name|chrec_not_analyzed_yet
condition|)
block|{
if|if
condition|(
name|loop
operator|!=
name|bb
operator|->
name|loop_father
condition|)
name|res
operator|=
name|compute_scalar_evolution_in_loop
argument_list|(
name|find_common_loop
argument_list|(
name|loop
argument_list|,
name|bb
operator|->
name|loop_father
argument_list|)
argument_list|,
name|bb
operator|->
name|loop_father
argument_list|,
name|res
argument_list|)
expr_stmt|;
goto|goto
name|set_and_end
goto|;
block|}
if|if
condition|(
name|loop
operator|!=
name|def_loop
condition|)
block|{
name|res
operator|=
name|analyze_scalar_evolution_1
argument_list|(
name|def_loop
argument_list|,
name|var
argument_list|,
name|chrec_not_analyzed_yet
argument_list|)
expr_stmt|;
name|res
operator|=
name|compute_scalar_evolution_in_loop
argument_list|(
name|loop
argument_list|,
name|def_loop
argument_list|,
name|res
argument_list|)
expr_stmt|;
goto|goto
name|set_and_end
goto|;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|def
argument_list|)
condition|)
block|{
case|case
name|MODIFY_EXPR
case|:
name|res
operator|=
name|interpret_rhs_modify_expr
argument_list|(
name|loop
argument_list|,
name|def
argument_list|,
name|TREE_OPERAND
argument_list|(
name|def
argument_list|,
literal|1
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|automatically_generated_chrec_p
argument_list|(
name|res
argument_list|)
operator|&&
name|pointer_used_p
argument_list|(
name|var
argument_list|)
condition|)
name|res
operator|=
name|fold_used_pointer
argument_list|(
name|res
argument_list|,
name|def
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHI_NODE
case|:
if|if
condition|(
name|loop_phi_node_p
argument_list|(
name|def
argument_list|)
condition|)
name|res
operator|=
name|interpret_loop_phi
argument_list|(
name|loop
argument_list|,
name|def
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|interpret_condition_phi
argument_list|(
name|loop
argument_list|,
name|def
argument_list|)
expr_stmt|;
break|break;
default|default:
name|res
operator|=
name|chrec_dont_know
expr_stmt|;
break|break;
block|}
name|set_and_end
label|:
comment|/* Keep the symbolic form.  */
if|if
condition|(
name|res
operator|==
name|chrec_dont_know
condition|)
name|res
operator|=
name|var
expr_stmt|;
if|if
condition|(
name|loop
operator|==
name|def_loop
condition|)
name|set_scalar_evolution
argument_list|(
name|var
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Entry point for the scalar evolution analyzer.    Analyzes and returns the scalar evolution of the ssa_name VAR.    LOOP_NB is the identifier number of the loop in which the variable    is used.        Example of use: having a pointer VAR to a SSA_NAME node, STMT a    pointer to the statement that uses this variable, in order to    determine the evolution function of the variable, use the following    calls:        unsigned loop_nb = loop_containing_stmt (stmt)->num;    tree chrec_with_symbols = analyze_scalar_evolution (loop_nb, var);    tree chrec_instantiated = instantiate_parameters     (loop_nb, chrec_with_symbols); */
end_comment

begin_function
name|tree
name|analyze_scalar_evolution
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|tree
name|res
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(analyze_scalar_evolution \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (loop_nb = %d)\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (scalar = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|analyze_scalar_evolution_1
argument_list|(
name|loop
argument_list|,
name|var
argument_list|,
name|get_scalar_evolution
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|res
operator|==
name|chrec_dont_know
condition|)
name|res
operator|=
name|var
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Analyze scalar evolution of use of VERSION in USE_LOOP with respect to    WRTO_LOOP (which should be a superloop of both USE_LOOP and definition    of VERSION).     FOLDED_CASTS is set to true if resolve_mixers used    chrec_convert_aggressive (TODO -- not really, we are way too conservative    at the moment in order to keep things simple).  */
end_comment

begin_function
specifier|static
name|tree
name|analyze_scalar_evolution_in_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|wrto_loop
parameter_list|,
name|struct
name|loop
modifier|*
name|use_loop
parameter_list|,
name|tree
name|version
parameter_list|,
name|bool
modifier|*
name|folded_casts
parameter_list|)
block|{
name|bool
name|val
init|=
name|false
decl_stmt|;
name|tree
name|ev
init|=
name|version
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|folded_casts
condition|)
operator|*
name|folded_casts
operator|=
name|false
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tmp
operator|=
name|analyze_scalar_evolution
argument_list|(
name|use_loop
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|ev
operator|=
name|resolve_mixers
argument_list|(
name|use_loop
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded_casts
operator|&&
name|tmp
operator|!=
name|ev
condition|)
operator|*
name|folded_casts
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|use_loop
operator|==
name|wrto_loop
condition|)
return|return
name|ev
return|;
comment|/* If the value of the use changes in the inner loop, we cannot express 	 its value in the outer loop (we might try to return interval chrec, 	 but we do not have a user for it anyway)  */
if|if
condition|(
operator|!
name|no_evolution_in_loop_p
argument_list|(
name|ev
argument_list|,
name|use_loop
operator|->
name|num
argument_list|,
operator|&
name|val
argument_list|)
operator|||
operator|!
name|val
condition|)
return|return
name|chrec_dont_know
return|;
name|use_loop
operator|=
name|use_loop
operator|->
name|outer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Returns instantiated value for VERSION in CACHE.  */
end_comment

begin_function
specifier|static
name|tree
name|get_instantiated_value
parameter_list|(
name|htab_t
name|cache
parameter_list|,
name|tree
name|version
parameter_list|)
block|{
name|struct
name|scev_info_str
modifier|*
name|info
decl_stmt|,
name|pattern
decl_stmt|;
name|pattern
operator|.
name|var
operator|=
name|version
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|scev_info_str
operator|*
operator|)
name|htab_find
argument_list|(
name|cache
argument_list|,
operator|&
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
condition|)
return|return
name|info
operator|->
name|chrec
return|;
else|else
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Sets instantiated value for VERSION to VAL in CACHE.  */
end_comment

begin_function
specifier|static
name|void
name|set_instantiated_value
parameter_list|(
name|htab_t
name|cache
parameter_list|,
name|tree
name|version
parameter_list|,
name|tree
name|val
parameter_list|)
block|{
name|struct
name|scev_info_str
modifier|*
name|info
decl_stmt|,
name|pattern
decl_stmt|;
name|PTR
modifier|*
name|slot
decl_stmt|;
name|pattern
operator|.
name|var
operator|=
name|version
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|cache
argument_list|,
operator|&
name|pattern
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|slot
condition|)
operator|*
name|slot
operator|=
name|new_scev_info_str
argument_list|(
name|version
argument_list|)
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|scev_info_str
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
name|info
operator|->
name|chrec
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the closed_loop_phi node for VAR.  If there is none, return    NULL_TREE.  */
end_comment

begin_function
specifier|static
name|tree
name|loop_closed_phi_def
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|edge
name|exit
decl_stmt|;
name|tree
name|phi
decl_stmt|;
if|if
condition|(
name|var
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|SSA_NAME
condition|)
return|return
name|NULL_TREE
return|;
name|loop
operator|=
name|loop_containing_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|exit
operator|=
name|loop
operator|->
name|single_exit
expr_stmt|;
if|if
condition|(
operator|!
name|exit
condition|)
return|return
name|NULL_TREE
return|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|exit
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|exit
argument_list|)
operator|==
name|var
condition|)
return|return
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
return|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Analyze all the parameters of the chrec that were left under a symbolic form,    with respect to LOOP.  CHREC is the chrec to instantiate.  CACHE is the cache    of already instantiated values.  FLAGS modify the way chrecs are    instantiated.  SIZE_EXPR is used for computing the size of the expression to    be instantiated, and to stop if it exceeds some limit.  */
end_comment

begin_comment
comment|/* Values for FLAGS.  */
end_comment

begin_enum
enum|enum
block|{
name|INSERT_SUPERLOOP_CHRECS
init|=
literal|1
block|,
comment|/* Loop invariants are replaced with chrecs 				   in outer loops.  */
name|FOLD_CONVERSIONS
init|=
literal|2
comment|/* The conversions that may wrap in 				   signed/pointer type are folded, as long as the 				   value of the chrec is preserved.  */
block|}
enum|;
end_enum

begin_function
specifier|static
name|tree
name|instantiate_parameters_1
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|chrec
parameter_list|,
name|int
name|flags
parameter_list|,
name|htab_t
name|cache
parameter_list|,
name|int
name|size_expr
parameter_list|)
block|{
name|tree
name|res
decl_stmt|,
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|op2
decl_stmt|;
name|basic_block
name|def_bb
decl_stmt|;
name|struct
name|loop
modifier|*
name|def_loop
decl_stmt|;
name|tree
name|type
init|=
name|chrec_type
argument_list|(
name|chrec
argument_list|)
decl_stmt|;
comment|/* Give up if the expression is larger than the MAX that we allow.  */
if|if
condition|(
name|size_expr
operator|++
operator|>
name|PARAM_VALUE
argument_list|(
name|PARAM_SCEV_MAX_EXPR_SIZE
argument_list|)
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|automatically_generated_chrec_p
argument_list|(
name|chrec
argument_list|)
operator|||
name|is_gimple_min_invariant
argument_list|(
name|chrec
argument_list|)
condition|)
return|return
name|chrec
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
case|case
name|SSA_NAME
case|:
name|def_bb
operator|=
name|bb_for_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|chrec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A parameter (or loop invariant and we do not want to include 	 evolutions in outer loops), nothing to do.  */
if|if
condition|(
operator|!
name|def_bb
operator|||
operator|(
operator|!
operator|(
name|flags
operator|&
name|INSERT_SUPERLOOP_CHRECS
operator|)
operator|&&
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|def_bb
argument_list|)
operator|)
condition|)
return|return
name|chrec
return|;
comment|/* We cache the value of instantiated variable to avoid exponential 	 time complexity due to reevaluations.  We also store the convenient 	 value in the cache in order to prevent infinite recursion -- we do 	 not want to instantiate the SSA_NAME if it is in a mixer 	 structure.  This is used for avoiding the instantiation of 	 recursively defined functions, such as:   	 | a_2 -> {0, +, 1, +, a_2}_1  */
name|res
operator|=
name|get_instantiated_value
argument_list|(
name|cache
argument_list|,
name|chrec
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
comment|/* Store the convenient value for chrec in the structure.  If it 	 is defined outside of the loop, we may just leave it in symbolic 	 form, otherwise we need to admit that we do not know its behavior 	 inside the loop.  */
name|res
operator|=
operator|!
name|flow_bb_inside_loop_p
argument_list|(
name|loop
argument_list|,
name|def_bb
argument_list|)
condition|?
name|chrec
else|:
name|chrec_dont_know
expr_stmt|;
name|set_instantiated_value
argument_list|(
name|cache
argument_list|,
name|chrec
argument_list|,
name|res
argument_list|)
expr_stmt|;
comment|/* To make things even more complicated, instantiate_parameters_1 	 calls analyze_scalar_evolution that may call # of iterations 	 analysis that may in turn call instantiate_parameters_1 again. 	 To prevent the infinite recursion, keep also the bitmap of 	 ssa names that are being instantiated globally.  */
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|already_instantiated
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
return|return
name|res
return|;
name|def_loop
operator|=
name|find_common_loop
argument_list|(
name|loop
argument_list|,
name|def_bb
operator|->
name|loop_father
argument_list|)
expr_stmt|;
comment|/* If the analysis yields a parametric chrec, instantiate the 	 result again.  */
name|bitmap_set_bit
argument_list|(
name|already_instantiated
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|chrec
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|analyze_scalar_evolution
argument_list|(
name|def_loop
argument_list|,
name|chrec
argument_list|)
expr_stmt|;
comment|/* Don't instantiate loop-closed-ssa phi nodes.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|res
argument_list|)
operator|==
name|SSA_NAME
operator|&&
operator|(
name|loop_containing_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|res
argument_list|)
argument_list|)
operator|==
name|NULL
operator|||
operator|(
name|loop_containing_stmt
argument_list|(
name|SSA_NAME_DEF_STMT
argument_list|(
name|res
argument_list|)
argument_list|)
operator|->
name|depth
operator|>
name|def_loop
operator|->
name|depth
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|res
operator|==
name|chrec
condition|)
name|res
operator|=
name|loop_closed_phi_def
argument_list|(
name|chrec
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|chrec
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL_TREE
condition|)
name|res
operator|=
name|chrec_dont_know
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|!=
name|chrec_dont_know
condition|)
name|res
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|res
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|already_instantiated
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|chrec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the correct value to the cache.  */
name|set_instantiated_value
argument_list|(
name|cache
argument_list|,
name|chrec
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
case|case
name|POLYNOMIAL_CHREC
case|:
name|op0
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
name|op1
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|CHREC_LEFT
argument_list|(
name|chrec
argument_list|)
operator|!=
name|op0
operator|||
name|CHREC_RIGHT
argument_list|(
name|chrec
argument_list|)
operator|!=
name|op1
condition|)
block|{
name|op1
operator|=
name|chrec_convert
argument_list|(
name|chrec_type
argument_list|(
name|op0
argument_list|)
argument_list|,
name|op1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chrec
operator|=
name|build_polynomial_chrec
argument_list|(
name|CHREC_VARIABLE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
return|return
name|chrec
return|;
case|case
name|PLUS_EXPR
case|:
name|op0
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
name|op1
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
operator|!=
name|op0
operator|||
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
operator|!=
name|op1
condition|)
block|{
name|op0
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|op0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|op1
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|op1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chrec
operator|=
name|chrec_fold_plus
argument_list|(
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
return|return
name|chrec
return|;
case|case
name|MINUS_EXPR
case|:
name|op0
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
name|op1
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
operator|!=
name|op0
operator|||
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
operator|!=
name|op1
condition|)
block|{
name|op0
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|op0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|op1
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|op1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chrec
operator|=
name|chrec_fold_minus
argument_list|(
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
return|return
name|chrec
return|;
case|case
name|MULT_EXPR
case|:
name|op0
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
name|op1
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
operator|!=
name|op0
operator|||
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
operator|!=
name|op1
condition|)
block|{
name|op0
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|op0
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|op1
operator|=
name|chrec_convert
argument_list|(
name|type
argument_list|,
name|op1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|chrec
operator|=
name|chrec_fold_multiply
argument_list|(
name|type
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
return|return
name|chrec
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
name|op0
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|flags
operator|&
name|FOLD_CONVERSIONS
condition|)
block|{
name|tree
name|tmp
init|=
name|chrec_convert_aggressive
argument_list|(
name|TREE_TYPE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|op0
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
condition|)
return|return
name|tmp
return|;
block|}
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|chrec
return|;
comment|/* If we used chrec_convert_aggressive, we can no longer assume that 	 signed chrecs do not overflow, as chrec_convert does, so avoid          calling it in that case.  */
if|if
condition|(
name|flags
operator|&
name|FOLD_CONVERSIONS
condition|)
return|return
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|op0
argument_list|)
return|;
return|return
name|chrec_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|op0
argument_list|,
name|NULL_TREE
argument_list|)
return|;
case|case
name|SCEV_NOT_KNOWN
case|:
return|return
name|chrec_dont_know
return|;
case|case
name|SCEV_KNOWN
case|:
return|return
name|chrec_known
return|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|3
case|:
name|op0
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
name|op1
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
name|op2
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|2
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op2
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
operator|&&
name|op2
operator|==
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|chrec
return|;
return|return
name|fold_build3
argument_list|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|op2
argument_list|)
return|;
case|case
literal|2
case|:
name|op0
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
name|op1
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
operator|&&
name|op1
operator|==
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|chrec
return|;
return|return
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
return|;
case|case
literal|1
case|:
name|op0
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cache
argument_list|,
name|size_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
name|chrec_dont_know
condition|)
return|return
name|chrec_dont_know
return|;
if|if
condition|(
name|op0
operator|==
name|TREE_OPERAND
argument_list|(
name|chrec
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|chrec
return|;
return|return
name|fold_build1
argument_list|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|chrec
argument_list|)
argument_list|,
name|op0
argument_list|)
return|;
case|case
literal|0
case|:
return|return
name|chrec
return|;
default|default:
break|break;
block|}
comment|/* Too complicated to handle.  */
return|return
name|chrec_dont_know
return|;
block|}
end_function

begin_comment
comment|/* Analyze all the parameters of the chrec that were left under a    symbolic form.  LOOP is the loop in which symbolic names have to    be analyzed and instantiated.  */
end_comment

begin_function
name|tree
name|instantiate_parameters
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|chrec
parameter_list|)
block|{
name|tree
name|res
decl_stmt|;
name|htab_t
name|cache
init|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_scev_info
argument_list|,
name|eq_scev_info
argument_list|,
name|del_scev_info
argument_list|)
decl_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(instantiate_parameters \n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (loop_nb = %d)\n"
argument_list|,
name|loop
operator|->
name|num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (chrec = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|chrec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|chrec
argument_list|,
name|INSERT_SUPERLOOP_CHRECS
argument_list|,
name|cache
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  (res = "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"))\n"
argument_list|)
expr_stmt|;
block|}
name|htab_delete
argument_list|(
name|cache
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Similar to instantiate_parameters, but does not introduce the    evolutions in outer loops for LOOP invariants in CHREC, and does not    care about causing overflows, as long as they do not affect value    of an expression.  */
end_comment

begin_function
specifier|static
name|tree
name|resolve_mixers
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|chrec
parameter_list|)
block|{
name|htab_t
name|cache
init|=
name|htab_create
argument_list|(
literal|10
argument_list|,
name|hash_scev_info
argument_list|,
name|eq_scev_info
argument_list|,
name|del_scev_info
argument_list|)
decl_stmt|;
name|tree
name|ret
init|=
name|instantiate_parameters_1
argument_list|(
name|loop
argument_list|,
name|chrec
argument_list|,
name|FOLD_CONVERSIONS
argument_list|,
name|cache
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|htab_delete
argument_list|(
name|cache
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Entry point for the analysis of the number of iterations pass.      This function tries to safely approximate the number of iterations    the loop will run.  When this property is not decidable at compile    time, the result is chrec_dont_know.  Otherwise the result is    a scalar or a symbolic parameter.        Example of analysis: suppose that the loop has an exit condition:        "if (b> 49) goto end_loop;"        and that in a previous analysis we have determined that the    variable 'b' has an evolution function:        "EF = {23, +, 5}_2".          When we evaluate the function at the point 5, i.e. the value of the    variable 'b' after 5 iterations in the loop, we have EF (5) = 48,    and EF (6) = 53.  In this case the value of 'b' on exit is '53' and    the loop body has been executed 6 times.  */
end_comment

begin_function
name|tree
name|number_of_iterations_in_loop
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|)
block|{
name|tree
name|res
decl_stmt|,
name|type
decl_stmt|;
name|edge
name|exit
decl_stmt|;
name|struct
name|tree_niter_desc
name|niter_desc
decl_stmt|;
comment|/* Determine whether the number_of_iterations_in_loop has already      been computed.  */
name|res
operator|=
name|loop
operator|->
name|nb_iterations
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
name|res
operator|=
name|chrec_dont_know
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(number_of_iterations_in_loop\n"
argument_list|)
expr_stmt|;
name|exit
operator|=
name|loop
operator|->
name|single_exit
expr_stmt|;
if|if
condition|(
operator|!
name|exit
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
name|number_of_iterations_exit
argument_list|(
name|loop
argument_list|,
name|exit
argument_list|,
operator|&
name|niter_desc
argument_list|,
name|false
argument_list|)
condition|)
goto|goto
name|end
goto|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|niter_desc
operator|.
name|niter
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_nonzerop
argument_list|(
name|niter_desc
operator|.
name|may_be_zero
argument_list|)
condition|)
name|res
operator|=
name|build_int_cst
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|integer_zerop
argument_list|(
name|niter_desc
operator|.
name|may_be_zero
argument_list|)
condition|)
name|res
operator|=
name|niter_desc
operator|.
name|niter
expr_stmt|;
else|else
name|res
operator|=
name|chrec_dont_know
expr_stmt|;
name|end
label|:
return|return
name|set_nb_iterations_in_loop
argument_list|(
name|loop
argument_list|,
name|res
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* One of the drivers for testing the scalar evolutions analysis.    This function computes the number of iterations for all the loops    from the EXIT_CONDITIONS array.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|number_of_iterations_for_all_loops
argument_list|(
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|exit_conditions
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|nb_chrec_dont_know_loops
init|=
literal|0
decl_stmt|;
name|unsigned
name|nb_static_loops
init|=
literal|0
decl_stmt|;
name|tree
name|cond
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
operator|*
name|exit_conditions
argument_list|,
name|i
argument_list|,
name|cond
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|res
init|=
name|number_of_iterations_in_loop
argument_list|(
name|loop_containing_stmt
argument_list|(
name|cond
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|res
argument_list|)
condition|)
name|nb_chrec_dont_know_loops
operator|++
expr_stmt|;
else|else
name|nb_static_loops
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n(\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"-----------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d\tnb_chrec_dont_know_loops\n"
argument_list|,
name|nb_chrec_dont_know_loops
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d\tnb_static_loops\n"
argument_list|,
name|nb_static_loops
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"%d\tnb_total_loops\n"
argument_list|,
name|current_loops
operator|->
name|num
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"-----------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n\n"
argument_list|)
expr_stmt|;
name|print_loop_ir
argument_list|(
name|dump_file
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Counters for the stats.  */
end_comment

begin_struct
struct|struct
name|chrec_stats
block|{
name|unsigned
name|nb_chrecs
decl_stmt|;
name|unsigned
name|nb_affine
decl_stmt|;
name|unsigned
name|nb_affine_multivar
decl_stmt|;
name|unsigned
name|nb_higher_poly
decl_stmt|;
name|unsigned
name|nb_chrec_dont_know
decl_stmt|;
name|unsigned
name|nb_undetermined
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Reset the counters.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|reset_chrecs_counters
parameter_list|(
name|struct
name|chrec_stats
modifier|*
name|stats
parameter_list|)
block|{
name|stats
operator|->
name|nb_chrecs
operator|=
literal|0
expr_stmt|;
name|stats
operator|->
name|nb_affine
operator|=
literal|0
expr_stmt|;
name|stats
operator|->
name|nb_affine_multivar
operator|=
literal|0
expr_stmt|;
name|stats
operator|->
name|nb_higher_poly
operator|=
literal|0
expr_stmt|;
name|stats
operator|->
name|nb_chrec_dont_know
operator|=
literal|0
expr_stmt|;
name|stats
operator|->
name|nb_undetermined
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump the contents of a CHREC_STATS structure.  */
end_comment

begin_function
specifier|static
name|void
name|dump_chrecs_stats
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|chrec_stats
modifier|*
name|stats
parameter_list|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n(\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-----------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\taffine univariate chrecs\n"
argument_list|,
name|stats
operator|->
name|nb_affine
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\taffine multivariate chrecs\n"
argument_list|,
name|stats
operator|->
name|nb_affine_multivar
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\tdegree greater than 2 polynomials\n"
argument_list|,
name|stats
operator|->
name|nb_higher_poly
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\tchrec_dont_know chrecs\n"
argument_list|,
name|stats
operator|->
name|nb_chrec_dont_know
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-----------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\ttotal chrecs\n"
argument_list|,
name|stats
operator|->
name|nb_chrecs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\twith undetermined coefficients\n"
argument_list|,
name|stats
operator|->
name|nb_undetermined
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-----------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\tchrecs in the scev database\n"
argument_list|,
operator|(
name|int
operator|)
name|htab_elements
argument_list|(
name|scalar_evolution_info
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\tsets in the scev database\n"
argument_list|,
name|nb_set_scev
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%d\tgets in the scev database\n"
argument_list|,
name|nb_get_scev
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"-----------------------------------------\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|")\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gather statistics about CHREC.  */
end_comment

begin_function
specifier|static
name|void
name|gather_chrec_stats
parameter_list|(
name|tree
name|chrec
parameter_list|,
name|struct
name|chrec_stats
modifier|*
name|stats
parameter_list|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"(classify_chrec "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|chrec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|stats
operator|->
name|nb_chrecs
operator|++
expr_stmt|;
if|if
condition|(
name|chrec
operator|==
name|NULL_TREE
condition|)
block|{
name|stats
operator|->
name|nb_undetermined
operator|++
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
case|case
name|POLYNOMIAL_CHREC
case|:
if|if
condition|(
name|evolution_function_is_affine_p
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  affine_univariate\n"
argument_list|)
expr_stmt|;
name|stats
operator|->
name|nb_affine
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|evolution_function_is_affine_multivariate_p
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  affine_multivariate\n"
argument_list|)
expr_stmt|;
name|stats
operator|->
name|nb_affine_multivar
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  higher_degree_polynomial\n"
argument_list|)
expr_stmt|;
name|stats
operator|->
name|nb_higher_poly
operator|++
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|chrec
argument_list|)
condition|)
block|{
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"  undetermined\n"
argument_list|)
expr_stmt|;
name|stats
operator|->
name|nb_undetermined
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* One of the drivers for testing the scalar evolutions analysis.    This function analyzes the scalar evolution of all the scalars    defined as loop phi nodes in one of the loops from the    EXIT_CONDITIONS array.          TODO Optimization: A loop is in canonical form if it contains only    a single scalar loop phi node.  All the other scalars that have an    evolution in the loop are rewritten in function of this single    index.  This allows the parallelization of the loop.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|analyze_scalar_evolution_for_all_loop_phi_nodes
argument_list|(
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
operator|*
name|exit_conditions
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|chrec_stats
name|stats
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|reset_chrecs_counters
argument_list|(
operator|&
name|stats
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|tree
argument_list|,
operator|*
name|exit_conditions
argument_list|,
name|i
argument_list|,
name|cond
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
name|basic_block
name|bb
decl_stmt|;
name|tree
name|phi
decl_stmt|,
name|chrec
decl_stmt|;
name|loop
operator|=
name|loop_containing_stmt
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|bb
operator|=
name|loop
operator|->
name|header
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
if|if
condition|(
name|is_gimple_reg
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
condition|)
block|{
name|chrec
operator|=
name|instantiate_parameters
argument_list|(
name|loop
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|gather_chrec_stats
argument_list|(
name|chrec
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|dump_chrecs_stats
argument_list|(
name|dump_file
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* Callback for htab_traverse, gathers information on chrecs in the    hashtable.  */
end_comment

begin_function
specifier|static
name|int
name|gather_stats_on_scev_database_1
parameter_list|(
name|void
modifier|*
modifier|*
name|slot
parameter_list|,
name|void
modifier|*
name|stats
parameter_list|)
block|{
name|struct
name|scev_info_str
modifier|*
name|entry
init|=
operator|(
expr|struct
name|scev_info_str
operator|*
operator|)
operator|*
name|slot
decl_stmt|;
name|gather_chrec_stats
argument_list|(
name|entry
operator|->
name|chrec
argument_list|,
operator|(
expr|struct
name|chrec_stats
operator|*
operator|)
name|stats
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Classify the chrecs of the whole database.  */
end_comment

begin_function
name|void
name|gather_stats_on_scev_database
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|chrec_stats
name|stats
decl_stmt|;
if|if
condition|(
operator|!
name|dump_file
condition|)
return|return;
name|reset_chrecs_counters
argument_list|(
operator|&
name|stats
argument_list|)
expr_stmt|;
name|htab_traverse
argument_list|(
name|scalar_evolution_info
argument_list|,
name|gather_stats_on_scev_database_1
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
name|dump_chrecs_stats
argument_list|(
name|dump_file
argument_list|,
operator|&
name|stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initializer.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_scalar_evolutions_analyzer
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* The elements below are unique.  */
if|if
condition|(
name|chrec_dont_know
operator|==
name|NULL_TREE
condition|)
block|{
name|chrec_not_analyzed_yet
operator|=
name|NULL_TREE
expr_stmt|;
name|chrec_dont_know
operator|=
name|make_node
argument_list|(
name|SCEV_NOT_KNOWN
argument_list|)
expr_stmt|;
name|chrec_known
operator|=
name|make_node
argument_list|(
name|SCEV_KNOWN
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|chrec_dont_know
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|chrec_known
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the analysis of scalar evolutions for LOOPS.  */
end_comment

begin_function
name|void
name|scev_initialize
parameter_list|(
name|struct
name|loops
modifier|*
name|loops
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|current_loops
operator|=
name|loops
expr_stmt|;
name|scalar_evolution_info
operator|=
name|htab_create
argument_list|(
literal|100
argument_list|,
name|hash_scev_info
argument_list|,
name|eq_scev_info
argument_list|,
name|del_scev_info
argument_list|)
expr_stmt|;
name|already_instantiated
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|initialize_scalar_evolutions_analyzer
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|loops
operator|->
name|parray
index|[
name|i
index|]
condition|)
name|loops
operator|->
name|parray
index|[
name|i
index|]
operator|->
name|nb_iterations
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleans up the information cached by the scalar evolutions analysis.  */
end_comment

begin_function
name|void
name|scev_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|;
if|if
condition|(
operator|!
name|scalar_evolution_info
operator|||
operator|!
name|current_loops
condition|)
return|return;
name|htab_empty
argument_list|(
name|scalar_evolution_info
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|current_loops
operator|->
name|num
condition|;
name|i
operator|++
control|)
block|{
name|loop
operator|=
name|current_loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|loop
condition|)
name|loop
operator|->
name|nb_iterations
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Checks whether OP behaves as a simple affine iv of LOOP in STMT and returns    its base and step in IV if possible.  If ALLOW_NONCONSTANT_STEP is true, we    want step to be invariant in LOOP.  Otherwise we require it to be an    integer constant.  IV->no_overflow is set to true if we are sure the iv cannot    overflow (e.g.  because it is computed in signed arithmetics).  */
end_comment

begin_function
name|bool
name|simple_iv
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|tree
name|stmt
parameter_list|,
name|tree
name|op
parameter_list|,
name|affine_iv
modifier|*
name|iv
parameter_list|,
name|bool
name|allow_nonconstant_step
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|bb_for_stmt
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|ev
decl_stmt|;
name|bool
name|folded_casts
decl_stmt|;
name|iv
operator|->
name|base
operator|=
name|NULL_TREE
expr_stmt|;
name|iv
operator|->
name|step
operator|=
name|NULL_TREE
expr_stmt|;
name|iv
operator|->
name|no_overflow
operator|=
name|false
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
name|false
return|;
name|ev
operator|=
name|analyze_scalar_evolution_in_loop
argument_list|(
name|loop
argument_list|,
name|bb
operator|->
name|loop_father
argument_list|,
name|op
argument_list|,
operator|&
name|folded_casts
argument_list|)
expr_stmt|;
if|if
condition|(
name|chrec_contains_undetermined
argument_list|(
name|ev
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|tree_does_not_contain_chrecs
argument_list|(
name|ev
argument_list|)
operator|&&
operator|!
name|chrec_contains_symbols_defined_in_loop
argument_list|(
name|ev
argument_list|,
name|loop
operator|->
name|num
argument_list|)
condition|)
block|{
name|iv
operator|->
name|base
operator|=
name|ev
expr_stmt|;
name|iv
operator|->
name|no_overflow
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ev
argument_list|)
operator|!=
name|POLYNOMIAL_CHREC
operator|||
name|CHREC_VARIABLE
argument_list|(
name|ev
argument_list|)
operator|!=
operator|(
name|unsigned
operator|)
name|loop
operator|->
name|num
condition|)
return|return
name|false
return|;
name|iv
operator|->
name|step
operator|=
name|CHREC_RIGHT
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|allow_nonconstant_step
condition|)
block|{
if|if
condition|(
name|tree_contains_chrecs
argument_list|(
name|iv
operator|->
name|step
argument_list|,
name|NULL
argument_list|)
operator|||
name|chrec_contains_symbols_defined_in_loop
argument_list|(
name|iv
operator|->
name|step
argument_list|,
name|loop
operator|->
name|num
argument_list|)
condition|)
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|iv
operator|->
name|step
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return
name|false
return|;
name|iv
operator|->
name|base
operator|=
name|CHREC_LEFT
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_contains_chrecs
argument_list|(
name|iv
operator|->
name|base
argument_list|,
name|NULL
argument_list|)
operator|||
name|chrec_contains_symbols_defined_in_loop
argument_list|(
name|iv
operator|->
name|base
argument_list|,
name|loop
operator|->
name|num
argument_list|)
condition|)
return|return
name|false
return|;
name|iv
operator|->
name|no_overflow
operator|=
operator|!
name|folded_casts
operator|&&
name|TYPE_OVERFLOW_UNDEFINED
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Runs the analysis of scalar evolutions.  */
end_comment

begin_function
name|void
name|scev_analysis
parameter_list|(
name|void
parameter_list|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|exit_conditions
expr_stmt|;
name|exit_conditions
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|37
argument_list|)
expr_stmt|;
name|select_loops_exit_conditions
argument_list|(
name|current_loops
argument_list|,
operator|&
name|exit_conditions
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_STATS
operator|)
condition|)
name|analyze_scalar_evolution_for_all_loop_phi_nodes
argument_list|(
operator|&
name|exit_conditions
argument_list|)
expr_stmt|;
name|number_of_iterations_for_all_loops
argument_list|(
operator|&
name|exit_conditions
argument_list|)
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|exit_conditions
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finalize the scalar evolution analysis.  */
end_comment

begin_function
name|void
name|scev_finalize
parameter_list|(
name|void
parameter_list|)
block|{
name|htab_delete
argument_list|(
name|scalar_evolution_info
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|already_instantiated
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns true if EXPR looks expensive.  */
end_comment

begin_function
specifier|static
name|bool
name|expression_expensive_p
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
return|return
name|force_expr_to_var_cost
argument_list|(
name|expr
argument_list|)
operator|>=
name|target_spill_cost
return|;
block|}
end_function

begin_comment
comment|/* Replace ssa names for that scev can prove they are constant by the    appropriate constants.  Also perform final value replacement in loops,    in case the replacement expressions are cheap.        We only consider SSA names defined by phi nodes; rest is left to the    ordinary constant propagation pass.  */
end_comment

begin_function
name|unsigned
name|int
name|scev_const_prop
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|phi
decl_stmt|,
name|next_phi
decl_stmt|,
name|type
decl_stmt|,
name|ev
decl_stmt|;
name|struct
name|loop
modifier|*
name|loop
decl_stmt|,
modifier|*
name|ex_loop
decl_stmt|;
name|bitmap
name|ssa_names_to_remove
init|=
name|NULL
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|current_loops
condition|)
return|return
literal|0
return|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|loop
operator|=
name|bb
operator|->
name|loop_father
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
block|{
name|name
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|name
argument_list|)
condition|)
continue|continue;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
continue|continue;
name|ev
operator|=
name|resolve_mixers
argument_list|(
name|loop
argument_list|,
name|analyze_scalar_evolution
argument_list|(
name|loop
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|ev
argument_list|)
operator|||
operator|!
name|may_propagate_copy
argument_list|(
name|name
argument_list|,
name|ev
argument_list|)
condition|)
continue|continue;
comment|/* Replace the uses of the name.  */
if|if
condition|(
name|name
operator|!=
name|ev
condition|)
name|replace_uses_by
argument_list|(
name|name
argument_list|,
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ssa_names_to_remove
condition|)
name|ssa_names_to_remove
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|ssa_names_to_remove
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove the ssa names that were replaced by constants.  We do not remove them      directly in the previous cycle, since this invalidates scev cache.  */
if|if
condition|(
name|ssa_names_to_remove
condition|)
block|{
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|ssa_names_to_remove
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
block|{
name|name
operator|=
name|ssa_name
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|phi
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|phi
argument_list|)
operator|==
name|PHI_NODE
argument_list|)
expr_stmt|;
name|remove_phi_node
argument_list|(
name|phi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|BITMAP_FREE
argument_list|(
name|ssa_names_to_remove
argument_list|)
expr_stmt|;
name|scev_reset
argument_list|()
expr_stmt|;
block|}
comment|/* Now the regular final value replacement.  */
for|for
control|(
name|i
operator|=
name|current_loops
operator|->
name|num
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|edge
name|exit
decl_stmt|;
name|tree
name|def
decl_stmt|,
name|rslt
decl_stmt|,
name|ass
decl_stmt|,
name|niter
decl_stmt|;
name|block_stmt_iterator
name|bsi
decl_stmt|;
name|loop
operator|=
name|current_loops
operator|->
name|parray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|loop
condition|)
continue|continue;
comment|/* If we do not know exact number of iterations of the loop, we cannot 	 replace the final value.  */
name|exit
operator|=
name|loop
operator|->
name|single_exit
expr_stmt|;
if|if
condition|(
operator|!
name|exit
condition|)
continue|continue;
name|niter
operator|=
name|number_of_iterations_in_loop
argument_list|(
name|loop
argument_list|)
expr_stmt|;
if|if
condition|(
name|niter
operator|==
name|chrec_dont_know
comment|/* If computing the number of iterations is expensive, it may be 	     better not to introduce computations involving it.  */
operator|||
name|expression_expensive_p
argument_list|(
name|niter
argument_list|)
condition|)
continue|continue;
comment|/* Ensure that it is possible to insert new statements somewhere.  */
if|if
condition|(
operator|!
name|single_pred_p
argument_list|(
name|exit
operator|->
name|dest
argument_list|)
condition|)
name|split_loop_exit_edge
argument_list|(
name|exit
argument_list|)
expr_stmt|;
name|tree_block_label
argument_list|(
name|exit
operator|->
name|dest
argument_list|)
expr_stmt|;
name|bsi
operator|=
name|bsi_after_labels
argument_list|(
name|exit
operator|->
name|dest
argument_list|)
expr_stmt|;
name|ex_loop
operator|=
name|superloop_at_depth
argument_list|(
name|loop
argument_list|,
name|exit
operator|->
name|dest
operator|->
name|loop_father
operator|->
name|depth
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|exit
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|next_phi
control|)
block|{
name|next_phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|rslt
operator|=
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|def
operator|=
name|PHI_ARG_DEF_FROM_EDGE
argument_list|(
name|phi
argument_list|,
name|exit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_reg
argument_list|(
name|def
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|def
argument_list|)
argument_list|)
operator|&&
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|def
argument_list|)
argument_list|)
condition|)
continue|continue;
name|def
operator|=
name|analyze_scalar_evolution_in_loop
argument_list|(
name|ex_loop
argument_list|,
name|loop
argument_list|,
name|def
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|def
operator|=
name|compute_overall_effect_of_inner_loop
argument_list|(
name|ex_loop
argument_list|,
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tree_does_not_contain_chrecs
argument_list|(
name|def
argument_list|)
operator|||
name|chrec_contains_symbols_defined_in_loop
argument_list|(
name|def
argument_list|,
name|ex_loop
operator|->
name|num
argument_list|)
comment|/* Moving the computation from the loop may prolong life range 		 of some ssa names, which may cause problems if they appear 		 on abnormal edges.  */
operator|||
name|contains_abnormal_ssa_name_p
argument_list|(
name|def
argument_list|)
condition|)
continue|continue;
comment|/* Eliminate the phi node and replace it by a computation outside 	     the loop.  */
name|def
operator|=
name|unshare_expr
argument_list|(
name|def
argument_list|)
expr_stmt|;
name|SET_PHI_RESULT
argument_list|(
name|phi
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|remove_phi_node
argument_list|(
name|phi
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ass
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|rslt
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|SSA_NAME_DEF_STMT
argument_list|(
name|rslt
argument_list|)
operator|=
name|ass
expr_stmt|;
block|{
name|block_stmt_iterator
name|dest
init|=
name|bsi
decl_stmt|;
name|bsi_insert_before
argument_list|(
operator|&
name|dest
argument_list|,
name|ass
argument_list|,
name|BSI_NEW_STMT
argument_list|)
expr_stmt|;
name|def
operator|=
name|force_gimple_operand_bsi
argument_list|(
operator|&
name|dest
argument_list|,
name|def
argument_list|,
name|false
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
name|TREE_OPERAND
argument_list|(
name|ass
argument_list|,
literal|1
argument_list|)
operator|=
name|def
expr_stmt|;
name|update_stmt
argument_list|(
name|ass
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

