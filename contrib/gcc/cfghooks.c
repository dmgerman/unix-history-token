begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Hooks for cfg representation specific functions.    Copyright (C) 2003, 2004, 2005 Free Software Foundation, Inc.    Contributed by Sebastian Pop<s.pop@laposte.net>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* A pointer to one of the hooks containers.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cfg_hooks
modifier|*
name|cfg_hooks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialization of functions specific to the rtl IR.  */
end_comment

begin_function
name|void
name|rtl_register_cfg_hooks
parameter_list|(
name|void
parameter_list|)
block|{
name|cfg_hooks
operator|=
operator|&
name|rtl_cfg_hooks
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialization of functions specific to the rtl IR.  */
end_comment

begin_function
name|void
name|cfg_layout_rtl_register_cfg_hooks
parameter_list|(
name|void
parameter_list|)
block|{
name|cfg_hooks
operator|=
operator|&
name|cfg_layout_rtl_cfg_hooks
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialization of functions specific to the tree IR.  */
end_comment

begin_function
name|void
name|tree_register_cfg_hooks
parameter_list|(
name|void
parameter_list|)
block|{
name|cfg_hooks
operator|=
operator|&
name|tree_cfg_hooks
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns current ir type (rtl = 0, trees = 1).  */
end_comment

begin_function
name|int
name|ir_type
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|cfg_hooks
operator|==
operator|&
name|tree_cfg_hooks
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Verify the CFG consistency.     Currently it does following: checks edge and basic block list correctness    and calls into IL dependent checking then.  */
end_comment

begin_function
name|void
name|verify_flow_info
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
modifier|*
name|edge_checksum
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|basic_block
name|bb
decl_stmt|,
name|last_bb_seen
decl_stmt|;
name|basic_block
modifier|*
name|last_visited
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_CFG_VERIFY
argument_list|)
expr_stmt|;
name|last_visited
operator|=
name|XCNEWVEC
argument_list|(
name|basic_block
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
name|edge_checksum
operator|=
name|XCNEWVEC
argument_list|(
name|size_t
argument_list|,
name|last_basic_block
argument_list|)
expr_stmt|;
comment|/* Check bb chain& numbers.  */
name|last_bb_seen
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR->next_bb
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
block|{
if|if
condition|(
name|bb
operator|!=
name|EXIT_BLOCK_PTR
operator|&&
name|bb
operator|!=
name|BASIC_BLOCK
argument_list|(
name|bb
operator|->
name|index
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"bb %d on wrong place"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|prev_bb
operator|!=
name|last_bb_seen
condition|)
block|{
name|error
argument_list|(
literal|"prev_bb of %d should be %d, not %d"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|last_bb_seen
operator|->
name|index
argument_list|,
name|bb
operator|->
name|prev_bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|last_bb_seen
operator|=
name|bb
expr_stmt|;
block|}
comment|/* Now check the basic blocks (boundaries etc.) */
name|FOR_EACH_BB_REVERSE
argument_list|(
argument|bb
argument_list|)
block|{
name|int
name|n_fallthru
init|=
literal|0
decl_stmt|;
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
name|bb
operator|->
name|count
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Wrong count of block %i %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
operator|(
name|int
operator|)
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bb
operator|->
name|frequency
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Wrong frequency of block %i %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|frequency
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
if|if
condition|(
name|last_visited
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|==
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Duplicate edge %i->%i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|probability
operator|<
literal|0
operator|||
name|e
operator|->
name|probability
operator|>
name|REG_BR_PROB_BASE
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Wrong probability of edge %i->%i %i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
name|e
operator|->
name|probability
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|count
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Wrong count of edge %i->%i %i"
argument_list|,
name|e
operator|->
name|src
operator|->
name|index
argument_list|,
name|e
operator|->
name|dest
operator|->
name|index
argument_list|,
operator|(
name|int
operator|)
name|e
operator|->
name|count
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|last_visited
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|=
name|bb
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
condition|)
name|n_fallthru
operator|++
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|src
operator|!=
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"verify_flow_info: Basic block %d succ edge is corrupted"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Predecessor: "
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nSuccessor: "
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|edge_checksum
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|+=
operator|(
name|size_t
operator|)
name|e
expr_stmt|;
block|}
if|if
condition|(
name|n_fallthru
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"wrong amount of branch edges after unconditional jump %i"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|dest
operator|!=
name|bb
condition|)
block|{
name|error
argument_list|(
literal|"basic block %d pred edge is corrupted"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"Predecessor: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\nSuccessor: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ei
operator|.
name|index
operator|!=
name|e
operator|->
name|dest_idx
condition|)
block|{
name|error
argument_list|(
literal|"basic block %d pred edge is corrupted"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"its dest_idx should be %d, not %d"
argument_list|,
name|ei
operator|.
name|index
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"Predecessor: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\nSuccessor: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|dump_edge_info
argument_list|(
name|stderr
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|edge_checksum
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|-=
operator|(
name|size_t
operator|)
name|e
expr_stmt|;
block|}
block|}
comment|/* Complete edge checksumming for ENTRY and EXIT.  */
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|ENTRY_BLOCK_PTR->succs
argument_list|)
name|edge_checksum
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|+=
operator|(
name|size_t
operator|)
name|e
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|EXIT_BLOCK_PTR->preds
argument_list|)
name|edge_checksum
index|[
name|e
operator|->
name|dest
operator|->
name|index
index|]
operator|-=
operator|(
name|size_t
operator|)
name|e
expr_stmt|;
block|}
name|FOR_BB_BETWEEN
argument_list|(
argument|bb
argument_list|,
argument|ENTRY_BLOCK_PTR
argument_list|,
argument|NULL
argument_list|,
argument|next_bb
argument_list|)
if|if
condition|(
name|edge_checksum
index|[
name|bb
operator|->
name|index
index|]
condition|)
block|{
name|error
argument_list|(
literal|"basic block %i edge lists are corrupted"
argument_list|,
name|bb
operator|->
name|index
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
block|}
name|last_bb_seen
operator|=
name|ENTRY_BLOCK_PTR
expr_stmt|;
comment|/* Clean up.  */
name|free
argument_list|(
name|last_visited
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|edge_checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_hooks
operator|->
name|verify_flow_info
condition|)
name|err
operator||=
name|cfg_hooks
operator|->
name|verify_flow_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|internal_error
argument_list|(
literal|"verify_flow_info failed"
argument_list|)
expr_stmt|;
name|timevar_pop
argument_list|(
name|TV_CFG_VERIFY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out one basic block.  This function takes care of the purely    graph related information.  The cfg hook for the active representation    should dump representation-specific information.  */
end_comment

begin_function
name|void
name|dump_bb
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|FILE
modifier|*
name|outf
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|char
modifier|*
name|s_indent
decl_stmt|;
name|s_indent
operator|=
name|alloca
argument_list|(
operator|(
name|size_t
operator|)
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|s_indent
argument_list|,
literal|' '
argument_list|,
operator|(
name|size_t
operator|)
name|indent
argument_list|)
expr_stmt|;
name|s_indent
index|[
name|indent
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";;%s basic block %d, loop depth %d, count "
argument_list|,
name|s_indent
argument_list|,
name|bb
operator|->
name|index
argument_list|,
name|bb
operator|->
name|loop_depth
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
name|HOST_WIDEST_INT_PRINT_DEC
argument_list|,
operator|(
name|HOST_WIDEST_INT
operator|)
name|bb
operator|->
name|count
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";;%s prev block "
argument_list|,
name|s_indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|prev_bb
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%d, "
argument_list|,
name|bb
operator|->
name|prev_bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"(nil), "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"next block "
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|next_bb
condition|)
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"%d"
argument_list|,
name|bb
operator|->
name|next_bb
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|"(nil)"
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";;%s pred:      "
argument_list|,
name|s_indent
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->preds
argument_list|)
name|dump_edge_info
argument_list|(
name|outf
argument_list|,
name|e
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|outf
argument_list|,
literal|";;%s succ:      "
argument_list|,
name|s_indent
argument_list|)
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
name|dump_edge_info
argument_list|(
name|outf
argument_list|,
name|e
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|outf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_hooks
operator|->
name|dump_bb
condition|)
name|cfg_hooks
operator|->
name|dump_bb
argument_list|(
name|bb
argument_list|,
name|outf
argument_list|,
name|indent
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Redirect edge E to the given basic block DEST and update underlying program    representation.  Returns edge representing redirected branch (that may not    be equivalent to E in the case of duplicate edges being removed) or NULL    if edge is not easily redirectable for whatever reason.  */
end_comment

begin_function
name|edge
name|redirect_edge_and_branch
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
name|edge
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|redirect_edge_and_branch
condition|)
name|internal_error
argument_list|(
literal|"%s does not support redirect_edge_and_branch"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cfg_hooks
operator|->
name|redirect_edge_and_branch
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Redirect the edge E to basic block DEST even if it requires creating    of a new basic block; then it returns the newly created basic block.    Aborts when redirection is impossible.  */
end_comment

begin_function
name|basic_block
name|redirect_edge_and_branch_force
parameter_list|(
name|edge
name|e
parameter_list|,
name|basic_block
name|dest
parameter_list|)
block|{
name|basic_block
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|redirect_edge_and_branch_force
condition|)
name|internal_error
argument_list|(
literal|"%s does not support redirect_edge_and_branch_force"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cfg_hooks
operator|->
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Splits basic block BB after the specified instruction I (but at least after    the labels).  If I is NULL, splits just after labels.  The newly created edge    is returned.  The new basic block is created just after the old one.  */
end_comment

begin_function
name|edge
name|split_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|void
modifier|*
name|i
parameter_list|)
block|{
name|basic_block
name|new_bb
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|split_block
condition|)
name|internal_error
argument_list|(
literal|"%s does not support split_block"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
name|new_bb
operator|=
name|cfg_hooks
operator|->
name|split_block
argument_list|(
name|bb
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_bb
condition|)
return|return
name|NULL
return|;
name|new_bb
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
name|new_bb
operator|->
name|frequency
operator|=
name|bb
operator|->
name|frequency
expr_stmt|;
name|new_bb
operator|->
name|loop_depth
operator|=
name|bb
operator|->
name|loop_depth
expr_stmt|;
if|if
condition|(
name|dom_info_available_p
argument_list|(
name|CDI_DOMINATORS
argument_list|)
condition|)
block|{
name|redirect_immediate_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|new_bb
argument_list|,
name|bb
argument_list|)
expr_stmt|;
block|}
return|return
name|make_single_succ_edge
argument_list|(
name|bb
argument_list|,
name|new_bb
argument_list|,
name|EDGE_FALLTHRU
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Splits block BB just after labels.  The newly created edge is returned.  */
end_comment

begin_function
name|edge
name|split_block_after_labels
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
return|return
name|split_block
argument_list|(
name|bb
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Moves block BB immediately after block AFTER.  Returns false if the    movement was impossible.  */
end_comment

begin_function
name|bool
name|move_block_after
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|move_block_after
condition|)
name|internal_error
argument_list|(
literal|"%s does not support move_block_after"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cfg_hooks
operator|->
name|move_block_after
argument_list|(
name|bb
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Deletes the basic block BB.  */
end_comment

begin_function
name|void
name|delete_basic_block
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|delete_basic_block
condition|)
name|internal_error
argument_list|(
literal|"%s does not support delete_basic_block"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_hooks
operator|->
name|delete_basic_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
comment|/* Remove the edges into and out of this block.  Note that there may      indeed be edges in, if we are removing an unreachable loop.  */
while|while
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
operator|!=
literal|0
condition|)
name|remove_edge
argument_list|(
name|EDGE_PRED
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|succs
argument_list|)
operator|!=
literal|0
condition|)
name|remove_edge
argument_list|(
name|EDGE_SUCC
argument_list|(
name|bb
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|CDI_DOMINATORS
index|]
condition|)
name|delete_from_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|CDI_POST_DOMINATORS
index|]
condition|)
name|delete_from_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|bb
argument_list|)
expr_stmt|;
comment|/* Remove the basic block from the array.  */
name|expunge_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Splits edge E and returns the newly created basic block.  */
end_comment

begin_function
name|basic_block
name|split_edge
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|basic_block
name|ret
decl_stmt|;
name|gcov_type
name|count
init|=
name|e
operator|->
name|count
decl_stmt|;
name|int
name|freq
init|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|edge
name|f
decl_stmt|;
name|bool
name|irr
init|=
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_IRREDUCIBLE_LOOP
operator|)
operator|!=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|split_edge
condition|)
name|internal_error
argument_list|(
literal|"%s does not support split_edge"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cfg_hooks
operator|->
name|split_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|ret
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|ret
operator|->
name|frequency
operator|=
name|freq
expr_stmt|;
name|single_succ_edge
argument_list|(
name|ret
argument_list|)
operator|->
name|probability
operator|=
name|REG_BR_PROB_BASE
expr_stmt|;
name|single_succ_edge
argument_list|(
name|ret
argument_list|)
operator|->
name|count
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|irr
condition|)
block|{
name|ret
operator|->
name|flags
operator||=
name|BB_IRREDUCIBLE_LOOP
expr_stmt|;
name|single_pred_edge
argument_list|(
name|ret
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
name|single_succ_edge
argument_list|(
name|ret
argument_list|)
operator|->
name|flags
operator||=
name|EDGE_IRREDUCIBLE_LOOP
expr_stmt|;
block|}
if|if
condition|(
name|dom_computed
index|[
name|CDI_DOMINATORS
index|]
condition|)
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|ret
argument_list|,
name|single_pred
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|CDI_DOMINATORS
index|]
operator|>=
name|DOM_NO_FAST_QUERY
condition|)
block|{
comment|/* There are two cases:  	 If the immediate dominator of e->dest is not e->src, it 	 remains unchanged.  	 If immediate dominator of e->dest is e->src, it may become 	 ret, provided that all other predecessors of e->dest are 	 dominated by e->dest.  */
if|if
condition|(
name|get_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|single_succ
argument_list|(
name|ret
argument_list|)
argument_list|)
operator|==
name|single_pred
argument_list|(
name|ret
argument_list|)
condition|)
block|{
name|edge_iterator
name|ei
decl_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|f
argument_list|,
argument|ei
argument_list|,
argument|single_succ (ret)->preds
argument_list|)
block|{
if|if
condition|(
name|f
operator|==
name|single_succ_edge
argument_list|(
name|ret
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|dominated_by_p
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|f
operator|->
name|src
argument_list|,
name|single_succ
argument_list|(
name|ret
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|f
condition|)
name|set_immediate_dominator
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|single_succ
argument_list|(
name|ret
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Creates a new basic block just after the basic block AFTER.    HEAD and END are the first and the last statement belonging    to the block.  If both are NULL, an empty block is created.  */
end_comment

begin_function
name|basic_block
name|create_basic_block
parameter_list|(
name|void
modifier|*
name|head
parameter_list|,
name|void
modifier|*
name|end
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|basic_block
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|create_basic_block
condition|)
name|internal_error
argument_list|(
literal|"%s does not support create_basic_block"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cfg_hooks
operator|->
name|create_basic_block
argument_list|(
name|head
argument_list|,
name|end
argument_list|,
name|after
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|CDI_DOMINATORS
index|]
condition|)
name|add_to_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|CDI_POST_DOMINATORS
index|]
condition|)
name|add_to_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Creates an empty basic block just after basic block AFTER.  */
end_comment

begin_function
name|basic_block
name|create_empty_bb
parameter_list|(
name|basic_block
name|after
parameter_list|)
block|{
return|return
name|create_basic_block
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|after
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Checks whether we may merge blocks BB1 and BB2.  */
end_comment

begin_function
name|bool
name|can_merge_blocks_p
parameter_list|(
name|basic_block
name|bb1
parameter_list|,
name|basic_block
name|bb2
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|can_merge_blocks_p
condition|)
name|internal_error
argument_list|(
literal|"%s does not support can_merge_blocks_p"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cfg_hooks
operator|->
name|can_merge_blocks_p
argument_list|(
name|bb1
argument_list|,
name|bb2
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|predict_edge
parameter_list|(
name|edge
name|e
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|,
name|int
name|probability
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|predict_edge
condition|)
name|internal_error
argument_list|(
literal|"%s does not support predict_edge"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_hooks
operator|->
name|predict_edge
argument_list|(
name|e
argument_list|,
name|predictor
argument_list|,
name|probability
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|predicted_by_p
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|enum
name|br_predictor
name|predictor
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|predict_edge
condition|)
name|internal_error
argument_list|(
literal|"%s does not support predicted_by_p"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|cfg_hooks
operator|->
name|predicted_by_p
argument_list|(
name|bb
argument_list|,
name|predictor
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Merges basic block B into basic block A.  */
end_comment

begin_function
name|void
name|merge_blocks
parameter_list|(
name|basic_block
name|a
parameter_list|,
name|basic_block
name|b
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|merge_blocks
condition|)
name|internal_error
argument_list|(
literal|"%s does not support merge_blocks"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
name|cfg_hooks
operator|->
name|merge_blocks
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
comment|/* Normally there should only be one successor of A and that is B, but      partway though the merge of blocks for conditional_execution we'll      be merging a TEST block with THEN and ELSE successors.  Free the      whole lot of them and hope the caller knows what they're doing.  */
while|while
condition|(
name|EDGE_COUNT
argument_list|(
name|a
operator|->
name|succs
argument_list|)
operator|!=
literal|0
condition|)
name|remove_edge
argument_list|(
name|EDGE_SUCC
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust the edges out of B for the new owner.  */
name|FOR_EACH_EDGE
argument_list|(
argument|e
argument_list|,
argument|ei
argument_list|,
argument|b->succs
argument_list|)
name|e
operator|->
name|src
operator|=
name|a
expr_stmt|;
name|a
operator|->
name|succs
operator|=
name|b
operator|->
name|succs
expr_stmt|;
name|a
operator|->
name|flags
operator||=
name|b
operator|->
name|flags
expr_stmt|;
comment|/* B hasn't quite yet ceased to exist.  Attempt to prevent mishap.  */
name|b
operator|->
name|preds
operator|=
name|b
operator|->
name|succs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|CDI_DOMINATORS
index|]
condition|)
name|redirect_immediate_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|CDI_DOMINATORS
index|]
condition|)
name|delete_from_dominance_info
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|dom_computed
index|[
name|CDI_POST_DOMINATORS
index|]
condition|)
name|delete_from_dominance_info
argument_list|(
name|CDI_POST_DOMINATORS
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|expunge_block
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split BB into entry part and the rest (the rest is the newly created block).    Redirect those edges for that REDIRECT_EDGE_P returns true to the entry    part.  Returns the edge connecting the entry part to the rest.  */
end_comment

begin_function
name|edge
name|make_forwarder_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|bool
function_decl|(
modifier|*
name|redirect_edge_p
function_decl|)
parameter_list|(
name|edge
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|new_bb_cbk
function_decl|)
parameter_list|(
name|basic_block
parameter_list|)
parameter_list|)
block|{
name|edge
name|e
decl_stmt|,
name|fallthru
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
name|basic_block
name|dummy
decl_stmt|,
name|jump
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|make_forwarder_block
condition|)
name|internal_error
argument_list|(
literal|"%s does not support make_forwarder_block"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
name|fallthru
operator|=
name|split_block_after_labels
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|dummy
operator|=
name|fallthru
operator|->
name|src
expr_stmt|;
name|bb
operator|=
name|fallthru
operator|->
name|dest
expr_stmt|;
comment|/* Redirect back edges we want to keep.  */
for|for
control|(
name|ei
operator|=
name|ei_start
argument_list|(
name|dummy
operator|->
name|preds
argument_list|)
init|;
operator|(
name|e
operator|=
name|ei_safe_edge
argument_list|(
name|ei
argument_list|)
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|redirect_edge_p
argument_list|(
name|e
argument_list|)
condition|)
block|{
name|ei_next
argument_list|(
operator|&
name|ei
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dummy
operator|->
name|frequency
operator|-=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|dummy
operator|->
name|count
operator|-=
name|e
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|dummy
operator|->
name|frequency
operator|<
literal|0
condition|)
name|dummy
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dummy
operator|->
name|count
operator|<
literal|0
condition|)
name|dummy
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|fallthru
operator|->
name|count
operator|-=
name|e
operator|->
name|count
expr_stmt|;
if|if
condition|(
name|fallthru
operator|->
name|count
operator|<
literal|0
condition|)
name|fallthru
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|jump
operator|=
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|jump
condition|)
name|new_bb_cbk
argument_list|(
name|jump
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dom_info_available_p
argument_list|(
name|CDI_DOMINATORS
argument_list|)
condition|)
block|{
name|basic_block
name|doms_to_fix
index|[
literal|2
index|]
decl_stmt|;
name|doms_to_fix
index|[
literal|0
index|]
operator|=
name|dummy
expr_stmt|;
name|doms_to_fix
index|[
literal|1
index|]
operator|=
name|bb
expr_stmt|;
name|iterate_fix_dominators
argument_list|(
name|CDI_DOMINATORS
argument_list|,
name|doms_to_fix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|cfg_hooks
operator|->
name|make_forwarder_block
argument_list|(
name|fallthru
argument_list|)
expr_stmt|;
return|return
name|fallthru
return|;
block|}
end_function

begin_function
name|void
name|tidy_fallthru_edge
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
if|if
condition|(
name|cfg_hooks
operator|->
name|tidy_fallthru_edge
condition|)
name|cfg_hooks
operator|->
name|tidy_fallthru_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix up edges that now fall through, or rather should now fall through    but previously required a jump around now deleted blocks.  Simplify    the search by only examining blocks numerically adjacent, since this    is how find_basic_blocks created them.  */
end_comment

begin_function
name|void
name|tidy_fallthru_edges
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|b
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|tidy_fallthru_edge
condition|)
return|return;
if|if
condition|(
name|ENTRY_BLOCK_PTR
operator|->
name|next_bb
operator|==
name|EXIT_BLOCK_PTR
condition|)
return|return;
name|FOR_BB_BETWEEN
argument_list|(
argument|b
argument_list|,
argument|ENTRY_BLOCK_PTR->next_bb
argument_list|,
argument|EXIT_BLOCK_PTR->prev_bb
argument_list|,
argument|next_bb
argument_list|)
block|{
name|edge
name|s
decl_stmt|;
name|c
operator|=
name|b
operator|->
name|next_bb
expr_stmt|;
comment|/* We care about simple conditional or unconditional jumps with 	 a single successor.  	 If we had a conditional branch to the next instruction when 	 find_basic_blocks was called, then there will only be one 	 out edge for the block which ended with the conditional 	 branch (since we do not create duplicate edges).  	 Furthermore, the edge will be marked as a fallthru because we 	 merge the flags for the duplicate edges.  So we do not want to 	 check that the edge is not a FALLTHRU edge.  */
if|if
condition|(
name|single_succ_p
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|s
operator|=
name|single_succ_edge
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|flags
operator|&
name|EDGE_COMPLEX
operator|)
operator|&&
name|s
operator|->
name|dest
operator|==
name|c
operator|&&
operator|!
name|find_reg_note
argument_list|(
name|BB_END
argument_list|(
name|b
argument_list|)
argument_list|,
name|REG_CROSSING_JUMP
argument_list|,
name|NULL_RTX
argument_list|)
condition|)
name|tidy_fallthru_edge
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Returns true if we can duplicate basic block BB.  */
end_comment

begin_function
name|bool
name|can_duplicate_block_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|edge
name|e
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|can_duplicate_block_p
condition|)
name|internal_error
argument_list|(
literal|"%s does not support can_duplicate_block_p"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|==
name|EXIT_BLOCK_PTR
operator|||
name|bb
operator|==
name|ENTRY_BLOCK_PTR
condition|)
return|return
name|false
return|;
comment|/* Duplicating fallthru block to exit would require adding a jump      and splitting the real last BB.  */
name|e
operator|=
name|find_edge
argument_list|(
name|bb
argument_list|,
name|EXIT_BLOCK_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|&&
operator|(
name|e
operator|->
name|flags
operator|&
name|EDGE_FALLTHRU
operator|)
condition|)
return|return
name|false
return|;
return|return
name|cfg_hooks
operator|->
name|can_duplicate_block_p
argument_list|(
name|bb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Duplicates basic block BB and redirects edge E to it.  Returns the    new basic block.  The new basic block is placed after the basic block    AFTER.  */
end_comment

begin_function
name|basic_block
name|duplicate_block
parameter_list|(
name|basic_block
name|bb
parameter_list|,
name|edge
name|e
parameter_list|,
name|basic_block
name|after
parameter_list|)
block|{
name|edge
name|s
decl_stmt|,
name|n
decl_stmt|;
name|basic_block
name|new_bb
decl_stmt|;
name|gcov_type
name|new_count
init|=
name|e
condition|?
name|e
operator|->
name|count
else|:
literal|0
decl_stmt|;
name|edge_iterator
name|ei
decl_stmt|;
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|duplicate_block
condition|)
name|internal_error
argument_list|(
literal|"%s does not support duplicate_block"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|count
operator|<
name|new_count
condition|)
name|new_count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|gcc_assert
argument_list|(
name|can_duplicate_block_p
argument_list|(
name|bb
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|new_bb
operator|=
name|cfg_hooks
operator|->
name|duplicate_block
argument_list|(
name|bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
condition|)
name|move_block_after
argument_list|(
name|new_bb
argument_list|,
name|after
argument_list|)
expr_stmt|;
name|new_bb
operator|->
name|loop_depth
operator|=
name|bb
operator|->
name|loop_depth
expr_stmt|;
name|new_bb
operator|->
name|flags
operator|=
name|bb
operator|->
name|flags
expr_stmt|;
name|FOR_EACH_EDGE
argument_list|(
argument|s
argument_list|,
argument|ei
argument_list|,
argument|bb->succs
argument_list|)
block|{
comment|/* Since we are creating edges from a new block to successors 	 of another block (which therefore are known to be disjoint), there 	 is no need to actually check for duplicated edges.  */
name|n
operator|=
name|unchecked_make_edge
argument_list|(
name|new_bb
argument_list|,
name|s
operator|->
name|dest
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
name|n
operator|->
name|probability
operator|=
name|s
operator|->
name|probability
expr_stmt|;
if|if
condition|(
name|e
operator|&&
name|bb
operator|->
name|count
condition|)
block|{
comment|/* Take care for overflows!  */
name|n
operator|->
name|count
operator|=
name|s
operator|->
name|count
operator|*
operator|(
name|new_count
operator|*
literal|10000
operator|/
name|bb
operator|->
name|count
operator|)
operator|/
literal|10000
expr_stmt|;
name|s
operator|->
name|count
operator|-=
name|n
operator|->
name|count
expr_stmt|;
block|}
else|else
name|n
operator|->
name|count
operator|=
name|s
operator|->
name|count
expr_stmt|;
name|n
operator|->
name|aux
operator|=
name|s
operator|->
name|aux
expr_stmt|;
block|}
if|if
condition|(
name|e
condition|)
block|{
name|new_bb
operator|->
name|count
operator|=
name|new_count
expr_stmt|;
name|bb
operator|->
name|count
operator|-=
name|new_count
expr_stmt|;
name|new_bb
operator|->
name|frequency
operator|=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|bb
operator|->
name|frequency
operator|-=
name|EDGE_FREQUENCY
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|redirect_edge_and_branch_force
argument_list|(
name|e
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|count
operator|<
literal|0
condition|)
name|bb
operator|->
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|frequency
operator|<
literal|0
condition|)
name|bb
operator|->
name|frequency
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|new_bb
operator|->
name|count
operator|=
name|bb
operator|->
name|count
expr_stmt|;
name|new_bb
operator|->
name|frequency
operator|=
name|bb
operator|->
name|frequency
expr_stmt|;
block|}
name|set_bb_original
argument_list|(
name|new_bb
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|set_bb_copy
argument_list|(
name|bb
argument_list|,
name|new_bb
argument_list|)
expr_stmt|;
return|return
name|new_bb
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if BB ends with a call, possibly followed by some    instructions that must stay with the call, 0 otherwise.  */
end_comment

begin_function
name|bool
name|block_ends_with_call_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|block_ends_with_call_p
condition|)
name|internal_error
argument_list|(
literal|"%s does not support block_ends_with_call_p"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
call|(
name|cfg_hooks
operator|->
name|block_ends_with_call_p
call|)
argument_list|(
name|bb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if BB ends with a conditional branch, 0 otherwise.  */
end_comment

begin_function
name|bool
name|block_ends_with_condjump_p
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|block_ends_with_condjump_p
condition|)
name|internal_error
argument_list|(
literal|"%s does not support block_ends_with_condjump_p"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
call|(
name|cfg_hooks
operator|->
name|block_ends_with_condjump_p
call|)
argument_list|(
name|bb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add fake edges to the function exit for any non constant and non noreturn    calls, volatile inline assembly in the bitmap of blocks specified by    BLOCKS or to the whole CFG if BLOCKS is zero.  Return the number of blocks    that were split.     The goal is to expose cases in which entering a basic block does not imply    that all subsequent instructions must be executed.  */
end_comment

begin_function
name|int
name|flow_call_edges_add
parameter_list|(
name|sbitmap
name|blocks
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cfg_hooks
operator|->
name|flow_call_edges_add
condition|)
name|internal_error
argument_list|(
literal|"%s does not support flow_call_edges_add"
argument_list|,
name|cfg_hooks
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
call|(
name|cfg_hooks
operator|->
name|flow_call_edges_add
call|)
argument_list|(
name|blocks
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function is called immediately after edge E is added to the    edge vector E->dest->preds.  */
end_comment

begin_function
name|void
name|execute_on_growing_pred
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
if|if
condition|(
name|cfg_hooks
operator|->
name|execute_on_growing_pred
condition|)
name|cfg_hooks
operator|->
name|execute_on_growing_pred
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called immediately before edge E is removed from    the edge vector E->dest->preds.  */
end_comment

begin_function
name|void
name|execute_on_shrinking_pred
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
if|if
condition|(
name|cfg_hooks
operator|->
name|execute_on_shrinking_pred
condition|)
name|cfg_hooks
operator|->
name|execute_on_shrinking_pred
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is used inside loop versioning when we want to insert    stmts/insns on the edges, which have a different behavior    in tree's and in RTL, so we made a CFG hook.  */
end_comment

begin_function
name|void
name|lv_flush_pending_stmts
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
if|if
condition|(
name|cfg_hooks
operator|->
name|flush_pending_stmts
condition|)
name|cfg_hooks
operator|->
name|flush_pending_stmts
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Loop versioning uses the duplicate_loop_to_header_edge to create    a new version of the loop basic-blocks, the parameters here are    exactly the same as in duplicate_loop_to_header_edge or    tree_duplicate_loop_to_header_edge; while in tree-ssa there is    additional work to maintain ssa information that's why there is    a need to call the tree_duplicate_loop_to_header_edge rather    than duplicate_loop_to_header_edge when we are in tree mode.  */
end_comment

begin_function
name|bool
name|cfg_hook_duplicate_loop_to_header_edge
parameter_list|(
name|struct
name|loop
modifier|*
name|loop
parameter_list|,
name|edge
name|e
parameter_list|,
name|struct
name|loops
modifier|*
name|loops
parameter_list|,
name|unsigned
name|int
name|ndupl
parameter_list|,
name|sbitmap
name|wont_exit
parameter_list|,
name|edge
name|orig
parameter_list|,
name|edge
modifier|*
name|to_remove
parameter_list|,
name|unsigned
name|int
modifier|*
name|n_to_remove
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|cfg_hooks
operator|->
name|cfg_hook_duplicate_loop_to_header_edge
argument_list|)
expr_stmt|;
return|return
name|cfg_hooks
operator|->
name|cfg_hook_duplicate_loop_to_header_edge
argument_list|(
name|loop
argument_list|,
name|e
argument_list|,
name|loops
argument_list|,
name|ndupl
argument_list|,
name|wont_exit
argument_list|,
name|orig
argument_list|,
name|to_remove
argument_list|,
name|n_to_remove
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Conditional jumps are represented differently in trees and RTL,    this hook takes a basic block that is known to have a cond jump    at its end and extracts the taken and not taken eges out of it    and store it in E1 and E2 respectively.  */
end_comment

begin_function
name|void
name|extract_cond_bb_edges
parameter_list|(
name|basic_block
name|b
parameter_list|,
name|edge
modifier|*
name|e1
parameter_list|,
name|edge
modifier|*
name|e2
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|cfg_hooks
operator|->
name|extract_cond_bb_edges
argument_list|)
expr_stmt|;
name|cfg_hooks
operator|->
name|extract_cond_bb_edges
argument_list|(
name|b
argument_list|,
name|e1
argument_list|,
name|e2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Responsible for updating the ssa info (PHI nodes) on the    new condition basic block that guards the versioned loop.  */
end_comment

begin_function
name|void
name|lv_adjust_loop_header_phi
parameter_list|(
name|basic_block
name|first
parameter_list|,
name|basic_block
name|second
parameter_list|,
name|basic_block
name|new
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
if|if
condition|(
name|cfg_hooks
operator|->
name|lv_adjust_loop_header_phi
condition|)
name|cfg_hooks
operator|->
name|lv_adjust_loop_header_phi
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|new
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Conditions in trees and RTL are different so we need    a different handling when we add the condition to the    versioning code.  */
end_comment

begin_function
name|void
name|lv_add_condition_to_bb
parameter_list|(
name|basic_block
name|first
parameter_list|,
name|basic_block
name|second
parameter_list|,
name|basic_block
name|new
parameter_list|,
name|void
modifier|*
name|cond
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|cfg_hooks
operator|->
name|lv_add_condition_to_bb
argument_list|)
expr_stmt|;
name|cfg_hooks
operator|->
name|lv_add_condition_to_bb
argument_list|(
name|first
argument_list|,
name|second
argument_list|,
name|new
argument_list|,
name|cond
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

