begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tree lowering pass.  This pass converts the GENERIC functions-as-trees    tree representation into the GIMPLE form.    Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.    Major work done by Sebastian Pop<s.pop@laposte.net>,    Diego Novillo<dnovillo@redhat.com> and Jason Merrill<jason@redhat.com>.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"tree-gimple.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"langhooks-def.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_include
include|#
directive|include
file|"timevar.h"
end_include

begin_include
include|#
directive|include
file|"except.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"function.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"optabs.h"
end_include

begin_include
include|#
directive|include
file|"pointer-set.h"
end_include

begin_enum
enum|enum
name|gimplify_omp_var_data
block|{
name|GOVD_SEEN
init|=
literal|1
block|,
name|GOVD_EXPLICIT
init|=
literal|2
block|,
name|GOVD_SHARED
init|=
literal|4
block|,
name|GOVD_PRIVATE
init|=
literal|8
block|,
name|GOVD_FIRSTPRIVATE
init|=
literal|16
block|,
name|GOVD_LASTPRIVATE
init|=
literal|32
block|,
name|GOVD_REDUCTION
init|=
literal|64
block|,
name|GOVD_LOCAL
init|=
literal|128
block|,
name|GOVD_DEBUG_PRIVATE
init|=
literal|256
block|,
name|GOVD_DATA_SHARE_CLASS
init|=
operator|(
name|GOVD_SHARED
operator||
name|GOVD_PRIVATE
operator||
name|GOVD_FIRSTPRIVATE
operator||
name|GOVD_LASTPRIVATE
operator||
name|GOVD_REDUCTION
operator||
name|GOVD_LOCAL
operator|)
block|}
enum|;
end_enum

begin_struct
struct|struct
name|gimplify_omp_ctx
block|{
name|struct
name|gimplify_omp_ctx
modifier|*
name|outer_context
decl_stmt|;
name|splay_tree
name|variables
decl_stmt|;
name|struct
name|pointer_set_t
modifier|*
name|privatized_types
decl_stmt|;
name|location_t
name|location
decl_stmt|;
name|enum
name|omp_clause_default_kind
name|default_kind
decl_stmt|;
name|bool
name|is_parallel
decl_stmt|;
name|bool
name|is_combined_parallel
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gimplify_ctx
block|{
name|struct
name|gimplify_ctx
modifier|*
name|prev_context
decl_stmt|;
name|tree
name|current_bind_expr
decl_stmt|;
name|tree
name|temps
decl_stmt|;
name|tree
name|conditional_cleanups
decl_stmt|;
name|tree
name|exit_label
decl_stmt|;
name|tree
name|return_temp
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|case_labels
expr_stmt|;
comment|/* The formal temporary table.  Should this be persistent?  */
name|htab_t
name|temp_htab
decl_stmt|;
name|int
name|conditions
decl_stmt|;
name|bool
name|save_stack
decl_stmt|;
name|bool
name|into_ssa
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|gimplify_ctx
modifier|*
name|gimplify_ctxp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|gimplify_omp_ctx
modifier|*
name|gimplify_omp_ctxp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Formal (expression) temporary table handling: Multiple occurrences of    the same scalar expression are evaluated into the same temporary.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|gimple_temp_hash_elt
block|{
name|tree
name|val
decl_stmt|;
comment|/* Key */
name|tree
name|temp
decl_stmt|;
comment|/* Value */
block|}
name|elt_t
typedef|;
end_typedef

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
specifier|static
name|enum
name|gimplify_status
name|gimplify_compound_expr
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_function_decl
specifier|static
name|bool
name|cpt_same_type
parameter_list|(
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return a hash value for a formal temporary table entry.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|gimple_tree_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|tree
name|t
init|=
operator|(
operator|(
specifier|const
name|elt_t
operator|*
operator|)
name|p
operator|)
operator|->
name|val
decl_stmt|;
return|return
name|iterative_hash_expr
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare two formal temporary table entries.  */
end_comment

begin_function
specifier|static
name|int
name|gimple_tree_eq
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|tree
name|t1
init|=
operator|(
operator|(
specifier|const
name|elt_t
operator|*
operator|)
name|p1
operator|)
operator|->
name|val
decl_stmt|;
name|tree
name|t2
init|=
operator|(
operator|(
specifier|const
name|elt_t
operator|*
operator|)
name|p2
operator|)
operator|->
name|val
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|code
operator|||
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
operator|!=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|operand_equal_p
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Only allow them to compare equal if they also hash equal; otherwise      results are nondeterminate, and we fail bootstrap comparison.  */
name|gcc_assert
argument_list|(
name|gimple_tree_hash
argument_list|(
name|p1
argument_list|)
operator|==
name|gimple_tree_hash
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set up a context for the gimplifier.  */
end_comment

begin_function
name|void
name|push_gimplify_context
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|gimplify_ctx
modifier|*
name|c
decl_stmt|;
name|c
operator|=
operator|(
expr|struct
name|gimplify_ctx
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gimplify_ctx
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|prev_context
operator|=
name|gimplify_ctxp
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
name|c
operator|->
name|temp_htab
operator|=
name|htab_create
argument_list|(
literal|1000
argument_list|,
name|gimple_tree_hash
argument_list|,
name|gimple_tree_eq
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|gimplify_ctxp
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tear down a context for the gimplifier.  If BODY is non-null, then    put the temporaries into the outer BIND_EXPR.  Otherwise, put them    in the unexpanded_var_list.  */
end_comment

begin_function
name|void
name|pop_gimplify_context
parameter_list|(
name|tree
name|body
parameter_list|)
block|{
name|struct
name|gimplify_ctx
modifier|*
name|c
init|=
name|gimplify_ctxp
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|gcc_assert
argument_list|(
name|c
operator|&&
operator|!
name|c
operator|->
name|current_bind_expr
argument_list|)
expr_stmt|;
name|gimplify_ctxp
operator|=
name|c
operator|->
name|prev_context
expr_stmt|;
for|for
control|(
name|t
operator|=
name|c
operator|->
name|temps
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|DECL_GIMPLE_FORMAL_TEMP_P
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|body
condition|)
name|declare_vars
argument_list|(
name|c
operator|->
name|temps
argument_list|,
name|body
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|record_vars
argument_list|(
name|c
operator|->
name|temps
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimize
condition|)
name|htab_delete
argument_list|(
name|c
operator|->
name|temp_htab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gimple_push_bind_expr
parameter_list|(
name|tree
name|bind
parameter_list|)
block|{
name|TREE_CHAIN
argument_list|(
name|bind
argument_list|)
operator|=
name|gimplify_ctxp
operator|->
name|current_bind_expr
expr_stmt|;
name|gimplify_ctxp
operator|->
name|current_bind_expr
operator|=
name|bind
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gimple_pop_bind_expr
parameter_list|(
name|void
parameter_list|)
block|{
name|gimplify_ctxp
operator|->
name|current_bind_expr
operator|=
name|TREE_CHAIN
argument_list|(
name|gimplify_ctxp
operator|->
name|current_bind_expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|gimple_current_bind_expr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gimplify_ctxp
operator|->
name|current_bind_expr
return|;
block|}
end_function

begin_comment
comment|/* Returns true iff there is a COND_EXPR between us and the innermost    CLEANUP_POINT_EXPR.  This info is used by gimple_push_cleanup.  */
end_comment

begin_function
specifier|static
name|bool
name|gimple_conditional_context
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gimplify_ctxp
operator|->
name|conditions
operator|>
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Note that we've entered a COND_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|gimple_push_condition
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
name|gimplify_ctxp
operator|->
name|conditions
operator|==
literal|0
condition|)
name|gcc_assert
argument_list|(
operator|!
name|gimplify_ctxp
operator|->
name|conditional_cleanups
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
operator|(
name|gimplify_ctxp
operator|->
name|conditions
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note that we've left a COND_EXPR.  If we're back at unconditional scope    now, add any conditional cleanups we've seen to the prequeue.  */
end_comment

begin_function
specifier|static
name|void
name|gimple_pop_condition
parameter_list|(
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|int
name|conds
init|=
operator|--
operator|(
name|gimplify_ctxp
operator|->
name|conditions
operator|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|conds
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|conds
operator|==
literal|0
condition|)
block|{
name|append_to_statement_list
argument_list|(
name|gimplify_ctxp
operator|->
name|conditional_cleanups
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|gimplify_ctxp
operator|->
name|conditional_cleanups
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A stable comparison routine for use with splay trees and DECLs.  */
end_comment

begin_function
specifier|static
name|int
name|splay_tree_compare_decl_uid
parameter_list|(
name|splay_tree_key
name|xa
parameter_list|,
name|splay_tree_key
name|xb
parameter_list|)
block|{
name|tree
name|a
init|=
operator|(
name|tree
operator|)
name|xa
decl_stmt|;
name|tree
name|b
init|=
operator|(
name|tree
operator|)
name|xb
decl_stmt|;
return|return
name|DECL_UID
argument_list|(
name|a
argument_list|)
operator|-
name|DECL_UID
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new omp construct that deals with variable remapping.  */
end_comment

begin_function
specifier|static
name|struct
name|gimplify_omp_ctx
modifier|*
name|new_omp_context
parameter_list|(
name|bool
name|is_parallel
parameter_list|,
name|bool
name|is_combined_parallel
parameter_list|)
block|{
name|struct
name|gimplify_omp_ctx
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|XCNEW
argument_list|(
expr|struct
name|gimplify_omp_ctx
argument_list|)
expr_stmt|;
name|c
operator|->
name|outer_context
operator|=
name|gimplify_omp_ctxp
expr_stmt|;
name|c
operator|->
name|variables
operator|=
name|splay_tree_new
argument_list|(
name|splay_tree_compare_decl_uid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|privatized_types
operator|=
name|pointer_set_create
argument_list|()
expr_stmt|;
name|c
operator|->
name|location
operator|=
name|input_location
expr_stmt|;
name|c
operator|->
name|is_parallel
operator|=
name|is_parallel
expr_stmt|;
name|c
operator|->
name|is_combined_parallel
operator|=
name|is_combined_parallel
expr_stmt|;
name|c
operator|->
name|default_kind
operator|=
name|OMP_CLAUSE_DEFAULT_SHARED
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Destroy an omp construct that deals with variable remapping.  */
end_comment

begin_function
specifier|static
name|void
name|delete_omp_context
parameter_list|(
name|struct
name|gimplify_omp_ctx
modifier|*
name|c
parameter_list|)
block|{
name|splay_tree_delete
argument_list|(
name|c
operator|->
name|variables
argument_list|)
expr_stmt|;
name|pointer_set_destroy
argument_list|(
name|c
operator|->
name|privatized_types
argument_list|)
expr_stmt|;
name|XDELETE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|omp_add_variable
parameter_list|(
name|struct
name|gimplify_omp_ctx
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|omp_notice_variable
parameter_list|(
name|struct
name|gimplify_omp_ctx
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* A subroutine of append_to_statement_list{,_force}.  T is not NULL.  */
end_comment

begin_function
specifier|static
name|void
name|append_to_statement_list_1
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
name|tree
name|list
init|=
operator|*
name|list_p
decl_stmt|;
name|tree_stmt_iterator
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
block|{
if|if
condition|(
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
operator|*
name|list_p
operator|=
name|t
expr_stmt|;
return|return;
block|}
operator|*
name|list_p
operator|=
name|list
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
block|}
name|i
operator|=
name|tsi_last
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|tsi_link_after
argument_list|(
operator|&
name|i
argument_list|,
name|t
argument_list|,
name|TSI_CONTINUE_LINKING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add T to the end of the list container pointed to by LIST_P.    If T is an expression with no effects, it is ignored.  */
end_comment

begin_function
name|void
name|append_to_statement_list
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
if|if
condition|(
name|t
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|t
argument_list|)
condition|)
name|append_to_statement_list_1
argument_list|(
name|t
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similar, but the statement is always added, regardless of side effects.  */
end_comment

begin_function
name|void
name|append_to_statement_list_force
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
if|if
condition|(
name|t
operator|!=
name|NULL_TREE
condition|)
name|append_to_statement_list_1
argument_list|(
name|t
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Both gimplify the statement T and append it to LIST_P.  */
end_comment

begin_function
name|void
name|gimplify_and_add
parameter_list|(
name|tree
name|t
parameter_list|,
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
name|gimplify_stmt
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Strip off a legitimate source ending from the input string NAME of    length LEN.  Rather than having to know the names used by all of    our front ends, we strip off an ending of a period followed by    up to five characters.  (Java uses ".class".)  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|remove_suffix
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|8
operator|&&
name|len
operator|>
name|i
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|len
operator|-
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
name|name
index|[
name|len
operator|-
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create a nameless artificial label and put it in the current function    context.  Returns the newly created label.  */
end_comment

begin_function
name|tree
name|create_artificial_label
parameter_list|(
name|void
parameter_list|)
block|{
name|tree
name|lab
init|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|)
decl_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|lab
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|lab
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|lab
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
return|return
name|lab
return|;
block|}
end_function

begin_comment
comment|/* Subroutine for find_single_pointer_decl.  */
end_comment

begin_function
specifier|static
name|tree
name|find_single_pointer_decl_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
modifier|*
name|pdecl
init|=
operator|(
name|tree
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|tp
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|pdecl
condition|)
block|{
comment|/* We already found a pointer decl; return anything other 	     than NULL_TREE to unwind from walk_tree signalling that 	     we have a duplicate.  */
return|return
operator|*
name|tp
return|;
block|}
operator|*
name|pdecl
operator|=
operator|*
name|tp
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Find the single DECL of pointer type in the tree T and return it.    If there are zero or more than one such DECLs, return NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|find_single_pointer_decl
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|find_single_pointer_decl_1
argument_list|,
operator|&
name|decl
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
comment|/* find_single_pointer_decl_1 returns a nonzero value, causing 	 walk_tree to return a nonzero value, to indicate that it 	 found more than one pointer DECL.  */
return|return
name|NULL_TREE
return|;
block|}
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Create a new temporary name with PREFIX.  Returns an identifier.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|unsigned
name|int
name|tmp_var_id_num
expr_stmt|;
end_expr_stmt

begin_function
name|tree
name|create_tmp_var_name
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|char
modifier|*
name|tmp_name
decl_stmt|;
if|if
condition|(
name|prefix
condition|)
block|{
name|char
modifier|*
name|preftmp
init|=
name|ASTRDUP
argument_list|(
name|prefix
argument_list|)
decl_stmt|;
name|remove_suffix
argument_list|(
name|preftmp
argument_list|,
name|strlen
argument_list|(
name|preftmp
argument_list|)
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|preftmp
expr_stmt|;
block|}
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|tmp_name
argument_list|,
name|prefix
condition|?
name|prefix
else|:
literal|"T"
argument_list|,
name|tmp_var_id_num
operator|++
argument_list|)
expr_stmt|;
return|return
name|get_identifier
argument_list|(
name|tmp_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new temporary variable declaration of type TYPE.    Does NOT push it into the current binding.  */
end_comment

begin_function
name|tree
name|create_tmp_var_raw
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|tree
name|tmp_var
decl_stmt|;
name|tree
name|new_type
decl_stmt|;
comment|/* Make the type of the variable writable.  */
name|new_type
operator|=
name|build_type_variant
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_ATTRIBUTES
argument_list|(
name|new_type
argument_list|)
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|tmp_var
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|prefix
condition|?
name|create_tmp_var_name
argument_list|(
name|prefix
argument_list|)
else|:
name|NULL
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* The variable was declared by the compiler.  */
name|DECL_ARTIFICIAL
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* And we don't want debug info for it.  */
name|DECL_IGNORED_P
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Make the variable writable.  */
name|TREE_READONLY
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_USED
argument_list|(
name|tmp_var
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|tmp_var
return|;
block|}
end_function

begin_comment
comment|/* Create a new temporary variable declaration of type TYPE.  DOES push the    variable into the current binding.  Further, assume that this is called    only from gimplification or optimization, at which point the creation of    certain types are bugs.  */
end_comment

begin_function
name|tree
name|create_tmp_var
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|tree
name|tmp_var
decl_stmt|;
comment|/* We don't allow types that are addressable (meaning we can't make copies),      or incomplete.  We also used to reject every variable size objects here,      but now support those for which a constant upper bound can be obtained.      The processing for variable sizes is performed in gimple_add_tmp_var,      point at which it really matters and possibly reached via paths not going      through this function, e.g. after direct calls to create_tmp_var_raw.  */
name|gcc_assert
argument_list|(
operator|!
name|TREE_ADDRESSABLE
argument_list|(
name|type
argument_list|)
operator|&&
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_var
operator|=
name|create_tmp_var_raw
argument_list|(
name|type
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|gimple_add_tmp_var
argument_list|(
name|tmp_var
argument_list|)
expr_stmt|;
return|return
name|tmp_var
return|;
block|}
end_function

begin_comment
comment|/*  Given a tree, try to return a useful variable name that we can use     to prefix a temporary that is being assigned the value of the tree.     I.E. given<temp> =&A, return A.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_name
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|stripped_decl
decl_stmt|;
name|stripped_decl
operator|=
name|t
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|stripped_decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|stripped_decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|stripped_decl
argument_list|)
condition|)
return|return
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|stripped_decl
argument_list|)
argument_list|)
return|;
else|else
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stripped_decl
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
return|return
name|get_name
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stripped_decl
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Create a temporary with a name derived from VAL.  Subroutine of    lookup_tmp_var; nobody else should call this function.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|create_tmp_from_val
parameter_list|(
name|tree
name|val
parameter_list|)
block|{
return|return
name|create_tmp_var
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
name|get_name
argument_list|(
name|val
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a temporary to hold the value of VAL.  If IS_FORMAL, try to reuse    an existing expression temporary.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tmp_var
parameter_list|(
name|tree
name|val
parameter_list|,
name|bool
name|is_formal
parameter_list|)
block|{
name|tree
name|ret
decl_stmt|;
comment|/* If not optimizing, never really reuse a temporary.  local-alloc      won't allocate any variable that is used in more than one basic      block, which means it will go into memory, causing much extra      work in reload and final and poorer code generation, outweighing      the extra memory allocation here.  */
if|if
condition|(
operator|!
name|optimize
operator|||
operator|!
name|is_formal
operator|||
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
condition|)
name|ret
operator|=
name|create_tmp_from_val
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|elt_t
name|elt
decl_stmt|,
modifier|*
name|elt_p
decl_stmt|;
name|void
modifier|*
modifier|*
name|slot
decl_stmt|;
name|elt
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|gimplify_ctxp
operator|->
name|temp_htab
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|elt
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|==
name|NULL
condition|)
block|{
name|elt_p
operator|=
name|XNEW
argument_list|(
name|elt_t
argument_list|)
expr_stmt|;
name|elt_p
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|elt_p
operator|->
name|temp
operator|=
name|ret
operator|=
name|create_tmp_from_val
argument_list|(
name|val
argument_list|)
expr_stmt|;
operator|*
name|slot
operator|=
operator|(
name|void
operator|*
operator|)
name|elt_p
expr_stmt|;
block|}
else|else
block|{
name|elt_p
operator|=
operator|(
name|elt_t
operator|*
operator|)
operator|*
name|slot
expr_stmt|;
name|ret
operator|=
name|elt_p
operator|->
name|temp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_formal
condition|)
name|DECL_GIMPLE_FORMAL_TEMP_P
argument_list|(
name|ret
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Returns a formal temporary variable initialized with VAL.  PRE_P is as    in gimplify_expr.  Only use this function if:     1) The value of the unfactored expression represented by VAL will not       change between the initialization and use of the temporary, and    2) The temporary will not be otherwise modified.     For instance, #1 means that this is inappropriate for SAVE_EXPR temps,    and #2 means it is inappropriate for&& temps.     For other cases, use get_initialized_tmp_var instead.  */
end_comment

begin_function
specifier|static
name|tree
name|internal_get_tmp_var
parameter_list|(
name|tree
name|val
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|,
name|bool
name|is_formal
parameter_list|)
block|{
name|tree
name|t
decl_stmt|,
name|mod
decl_stmt|;
name|gimplify_expr
argument_list|(
operator|&
name|val
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_formal_tmp_rhs
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|t
operator|=
name|lookup_tmp_var
argument_list|(
name|val
argument_list|,
name|is_formal
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_formal
condition|)
block|{
name|tree
name|u
init|=
name|find_single_pointer_decl
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|u
operator|&&
name|TREE_CODE
argument_list|(
name|u
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_BASED_ON_RESTRICT_P
argument_list|(
name|u
argument_list|)
condition|)
name|u
operator|=
name|DECL_GET_RESTRICT_BASE
argument_list|(
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|&&
name|TYPE_RESTRICT
argument_list|(
name|TREE_TYPE
argument_list|(
name|u
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_BASED_ON_RESTRICT_P
argument_list|(
name|t
argument_list|)
condition|)
name|gcc_assert
argument_list|(
name|u
operator|==
name|DECL_GET_RESTRICT_BASE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|DECL_BASED_ON_RESTRICT_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SET_DECL_RESTRICT_BASE
argument_list|(
name|t
argument_list|,
name|u
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
name|mod
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|val
argument_list|)
condition|)
name|SET_EXPR_LOCUS
argument_list|(
name|mod
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SET_EXPR_LOCATION
argument_list|(
name|mod
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
comment|/* gimplify_modify_expr might want to reduce this further.  */
name|gimplify_and_add
argument_list|(
name|mod
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* If we're gimplifying into ssa, gimplify_modify_expr will have      given our temporary an ssa name.  Find and return it.  */
if|if
condition|(
name|gimplify_ctxp
operator|->
name|into_ssa
condition|)
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|mod
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Returns a formal temporary variable initialized with VAL.  PRE_P    points to a statement list where side-effects needed to compute VAL    should be stored.  */
end_comment

begin_function
name|tree
name|get_formal_tmp_var
parameter_list|(
name|tree
name|val
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
return|return
name|internal_get_tmp_var
argument_list|(
name|val
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|true
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns a temporary variable initialized with VAL.  PRE_P and POST_P    are as in gimplify_expr.  */
end_comment

begin_function
name|tree
name|get_initialized_tmp_var
parameter_list|(
name|tree
name|val
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
return|return
name|internal_get_tmp_var
argument_list|(
name|val
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Declares all the variables in VARS in SCOPE.  If DEBUG_INFO is    true, generate debug info for them; otherwise don't.  */
end_comment

begin_function
name|void
name|declare_vars
parameter_list|(
name|tree
name|vars
parameter_list|,
name|tree
name|scope
parameter_list|,
name|bool
name|debug_info
parameter_list|)
block|{
name|tree
name|last
init|=
name|vars
decl_stmt|;
if|if
condition|(
name|last
condition|)
block|{
name|tree
name|temps
decl_stmt|,
name|block
decl_stmt|;
comment|/* C99 mode puts the default 'return 0;' for main outside the outer 	 braces.  So drill down until we find an actual scope.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
name|scope
operator|=
name|TREE_OPERAND
argument_list|(
name|scope
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|scope
argument_list|)
operator|==
name|BIND_EXPR
argument_list|)
expr_stmt|;
name|temps
operator|=
name|nreverse
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|block
operator|=
name|BIND_EXPR_BLOCK
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|block
operator|||
operator|!
name|debug_info
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|BIND_EXPR_VARS
argument_list|(
name|scope
argument_list|)
expr_stmt|;
name|BIND_EXPR_VARS
argument_list|(
name|scope
argument_list|)
operator|=
name|temps
expr_stmt|;
block|}
else|else
block|{
comment|/* We need to attach the nodes both to the BIND_EXPR and to its 	     associated BLOCK for debugging purposes.  The key point here 	     is that the BLOCK_VARS of the BIND_EXPR_BLOCK of a BIND_EXPR 	     is a subchain of the BIND_EXPR_VARS of the BIND_EXPR.  */
if|if
condition|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
condition|)
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|chainon
argument_list|(
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
argument_list|,
name|temps
argument_list|)
expr_stmt|;
else|else
block|{
name|BIND_EXPR_VARS
argument_list|(
name|scope
argument_list|)
operator|=
name|chainon
argument_list|(
name|BIND_EXPR_VARS
argument_list|(
name|scope
argument_list|)
argument_list|,
name|temps
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|temps
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* For VAR a VAR_DECL of variable size, try to find a constant upper bound    for the size and adjust DECL_SIZE/DECL_SIZE_UNIT accordingly.  Abort if    no such upper bound can be obtained.  */
end_comment

begin_function
specifier|static
name|void
name|force_constant_size
parameter_list|(
name|tree
name|var
parameter_list|)
block|{
comment|/* The only attempt we make is by querying the maximum size of objects      of the variable's type.  */
name|HOST_WIDE_INT
name|max_size
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
name|max_size
operator|=
name|max_int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|max_size
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DECL_SIZE_UNIT
argument_list|(
name|var
argument_list|)
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|,
name|max_size
argument_list|)
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|var
argument_list|)
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|DECL_SIZE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|,
name|max_size
operator|*
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gimple_add_tmp_var
parameter_list|(
name|tree
name|tmp
parameter_list|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
operator|&&
operator|!
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Later processing assumes that the object size is constant, which might      not be true at this point.  Force the use of a constant upper bound in      this case.  */
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|DECL_SIZE_UNIT
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|force_constant_size
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|tmp
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|tmp
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|gimplify_ctxp
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|tmp
argument_list|)
operator|=
name|gimplify_ctxp
operator|->
name|temps
expr_stmt|;
name|gimplify_ctxp
operator|->
name|temps
operator|=
name|tmp
expr_stmt|;
comment|/* Mark temporaries local within the nearest enclosing parallel.  */
if|if
condition|(
name|gimplify_omp_ctxp
condition|)
block|{
name|struct
name|gimplify_omp_ctx
modifier|*
name|ctx
init|=
name|gimplify_omp_ctxp
decl_stmt|;
while|while
condition|(
name|ctx
operator|&&
operator|!
name|ctx
operator|->
name|is_parallel
condition|)
name|ctx
operator|=
name|ctx
operator|->
name|outer_context
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
name|omp_add_variable
argument_list|(
name|ctx
argument_list|,
name|tmp
argument_list|,
name|GOVD_LOCAL
operator||
name|GOVD_SEEN
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cfun
condition|)
name|record_vars
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
else|else
name|declare_vars
argument_list|(
name|tmp
argument_list|,
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determines whether to assign a locus to the statement STMT.  */
end_comment

begin_function
specifier|static
name|bool
name|should_carry_locus_p
parameter_list|(
name|tree
name|stmt
parameter_list|)
block|{
comment|/* Don't emit a line note for a label.  We particularly don't want to      emit one for the break label, since it doesn't actually correspond      to the beginning of the loop/switch.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
return|return
name|false
return|;
comment|/* Do not annotate empty statements, since it confuses gcov.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|stmt
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|annotate_one_with_locus
parameter_list|(
name|tree
name|t
parameter_list|,
name|location_t
name|locus
parameter_list|)
block|{
if|if
condition|(
name|EXPR_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
name|t
argument_list|)
operator|&&
name|should_carry_locus_p
argument_list|(
name|t
argument_list|)
condition|)
name|SET_EXPR_LOCATION
argument_list|(
name|t
argument_list|,
name|locus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|annotate_all_with_locus
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|,
name|location_t
name|locus
parameter_list|)
block|{
name|tree_stmt_iterator
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|stmt_p
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
operator|*
name|stmt_p
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|tree
name|t
init|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* Assuming we've already been gimplified, we shouldn't 	  see nested chaining constructs anymore.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|STATEMENT_LIST
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|COMPOUND_EXPR
argument_list|)
expr_stmt|;
name|annotate_one_with_locus
argument_list|(
name|t
argument_list|,
name|locus
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Similar to copy_tree_r() but do not copy SAVE_EXPR or TARGET_EXPR nodes.    These nodes model computations that should only be done once.  If we    were to unshare something like SAVE_EXPR(i++), the gimplification    process would create wrong code.  */
end_comment

begin_function
specifier|static
name|tree
name|mostly_copy_tree_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
decl_stmt|;
comment|/* Don't unshare types, decls, constants and SAVE_EXPR nodes.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_type
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_declaration
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_constant
operator|||
name|code
operator|==
name|SAVE_EXPR
operator|||
name|code
operator|==
name|TARGET_EXPR
comment|/* We can't do anything sensible with a BLOCK used as an expression, 	 but we also can't just die when we see it because of non-expression 	 uses.  So just avert our eyes and cross our fingers.  Silly Java.  */
operator|||
name|code
operator|==
name|BLOCK
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|gcc_assert
argument_list|(
name|code
operator|!=
name|BIND_EXPR
argument_list|)
expr_stmt|;
name|copy_tree_r
argument_list|(
name|tp
argument_list|,
name|walk_subtrees
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Callback for walk_tree to unshare most of the shared trees rooted at    *TP.  If *TP has been visited already (i.e., TREE_VISITED (*TP) == 1),    then *TP is deep copied by calling copy_tree_r.     This unshares the same trees as copy_tree_r with the exception of    SAVE_EXPR nodes.  These nodes model computations that should only be    done once.  If we were to unshare something like SAVE_EXPR(i++), the    gimplification process would create wrong code.  */
end_comment

begin_function
specifier|static
name|tree
name|copy_if_shared_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* Skip types, decls, and constants.  But we do want to look at their      types and the bounds of types.  Mark them as visited so we properly      unmark their subtrees on the unmark pass.  If we've already seen them,      don't look down further.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_type
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_declaration
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_constant
condition|)
block|{
if|if
condition|(
name|TREE_VISITED
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
else|else
name|TREE_VISITED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this node has been visited already, unshare it and don't look      any deeper.  */
elseif|else
if|if
condition|(
name|TREE_VISITED
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|walk_tree
argument_list|(
name|tp
argument_list|,
name|mostly_copy_tree_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Otherwise, mark the tree as visited and keep looking.  */
else|else
name|TREE_VISITED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|unmark_visited_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TREE_VISITED
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
name|TREE_VISITED
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Unshare all the trees in BODY_P, a pointer into the body of FNDECL, and the    bodies of any nested functions if we are unsharing the entire body of    FNDECL.  */
end_comment

begin_function
specifier|static
name|void
name|unshare_body
parameter_list|(
name|tree
modifier|*
name|body_p
parameter_list|,
name|tree
name|fndecl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|cgn
init|=
name|cgraph_node
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|walk_tree
argument_list|(
name|body_p
argument_list|,
name|copy_if_shared_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|body_p
operator|==
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
condition|)
for|for
control|(
name|cgn
operator|=
name|cgn
operator|->
name|nested
init|;
name|cgn
condition|;
name|cgn
operator|=
name|cgn
operator|->
name|next_nested
control|)
name|unshare_body
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|cgn
operator|->
name|decl
argument_list|)
argument_list|,
name|cgn
operator|->
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Likewise, but mark all trees as not visited.  */
end_comment

begin_function
specifier|static
name|void
name|unvisit_body
parameter_list|(
name|tree
modifier|*
name|body_p
parameter_list|,
name|tree
name|fndecl
parameter_list|)
block|{
name|struct
name|cgraph_node
modifier|*
name|cgn
init|=
name|cgraph_node
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|walk_tree
argument_list|(
name|body_p
argument_list|,
name|unmark_visited_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|body_p
operator|==
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
condition|)
for|for
control|(
name|cgn
operator|=
name|cgn
operator|->
name|nested
init|;
name|cgn
condition|;
name|cgn
operator|=
name|cgn
operator|->
name|next_nested
control|)
name|unvisit_body
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|cgn
operator|->
name|decl
argument_list|)
argument_list|,
name|cgn
operator|->
name|decl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unshare T and all the trees reached from T via TREE_CHAIN.  */
end_comment

begin_function
specifier|static
name|void
name|unshare_all_trees
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|copy_if_shared_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|t
argument_list|,
name|unmark_visited_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unconditionally make an unshared copy of EXPR.  This is used when using    stored expressions which span multiple functions, such as BINFO_VTABLE,    as the normal unsharing process can't tell that they're shared.  */
end_comment

begin_function
name|tree
name|unshare_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|walk_tree
argument_list|(
operator|&
name|expr
argument_list|,
name|mostly_copy_tree_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* A terser interface for building a representation of an exception    specification.  */
end_comment

begin_function
name|tree
name|gimple_build_eh_filter
parameter_list|(
name|tree
name|body
parameter_list|,
name|tree
name|allowed
parameter_list|,
name|tree
name|failure
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
comment|/* FIXME should the allowed types go in TREE_TYPE?  */
name|t
operator|=
name|build2
argument_list|(
name|EH_FILTER_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|allowed
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|failure
argument_list|,
operator|&
name|EH_FILTER_FAILURE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|TRY_CATCH_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|body
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* WRAPPER is a code such as BIND_EXPR or CLEANUP_POINT_EXPR which can both    contain statements and have a value.  Assign its value to a temporary    and give it void_type_node.  Returns the temporary, or NULL_TREE if    WRAPPER was already void.  */
end_comment

begin_function
name|tree
name|voidify_wrapper_expr
parameter_list|(
name|tree
name|wrapper
parameter_list|,
name|tree
name|temp
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|wrapper
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
modifier|*
name|p
decl_stmt|;
comment|/* Set p to point to the body of the wrapper.  Loop until we find 	 something that isn't a wrapper.  */
for|for
control|(
name|p
operator|=
operator|&
name|wrapper
init|;
name|p
operator|&&
operator|*
name|p
condition|;
control|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
case|case
name|BIND_EXPR
case|:
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|p
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|p
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
comment|/* For a BIND_EXPR, the body is operand 1.  */
name|p
operator|=
operator|&
name|BIND_EXPR_BODY
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLEANUP_POINT_EXPR
case|:
case|case
name|TRY_FINALLY_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|p
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|p
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|STATEMENT_LIST
case|:
block|{
name|tree_stmt_iterator
name|i
init|=
name|tsi_last
argument_list|(
operator|*
name|p
argument_list|)
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|p
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|p
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|p
operator|=
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|?
name|NULL
else|:
name|tsi_stmt_ptr
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COMPOUND_EXPR
case|:
comment|/* Advance to the last statement.  Set all container types to void.  */
for|for
control|(
init|;
name|TREE_CODE
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|;
name|p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|p
argument_list|,
literal|1
argument_list|)
control|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|p
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_TYPE
argument_list|(
operator|*
name|p
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
block|}
break|break;
default|default:
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|IS_EMPTY_STMT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|temp
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
condition|)
block|{
comment|/* The wrapper is on the RHS of an assignment that we're pushing 	     down.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|INIT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|temp
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|temp
argument_list|,
literal|1
argument_list|)
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
literal|"retval"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|type
argument_list|,
name|temp
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|temp
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Prepare calls to builtins to SAVE and RESTORE the stack as well as    a temporary through which they communicate.  */
end_comment

begin_function
specifier|static
name|void
name|build_stack_save_restore
parameter_list|(
name|tree
modifier|*
name|save
parameter_list|,
name|tree
modifier|*
name|restore
parameter_list|)
block|{
name|tree
name|save_call
decl_stmt|,
name|tmp_var
decl_stmt|;
name|save_call
operator|=
name|build_function_call_expr
argument_list|(
name|implicit_built_in_decls
index|[
name|BUILT_IN_STACK_SAVE
index|]
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|tmp_var
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type_node
argument_list|,
literal|"saved_stack"
argument_list|)
expr_stmt|;
operator|*
name|save
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|tmp_var
argument_list|,
name|save_call
argument_list|)
expr_stmt|;
operator|*
name|restore
operator|=
name|build_function_call_expr
argument_list|(
name|implicit_built_in_decls
index|[
name|BUILT_IN_STACK_RESTORE
index|]
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|tmp_var
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gimplify a BIND_EXPR.  Just voidify and recurse.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_bind_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|bind_expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|bool
name|old_save_stack
init|=
name|gimplify_ctxp
operator|->
name|save_stack
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|temp
init|=
name|voidify_wrapper_expr
argument_list|(
name|bind_expr
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
comment|/* Mark variables seen in this bind expr.  */
for|for
control|(
name|t
operator|=
name|BIND_EXPR_VARS
argument_list|(
name|bind_expr
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|struct
name|gimplify_omp_ctx
modifier|*
name|ctx
init|=
name|gimplify_omp_ctxp
decl_stmt|;
comment|/* Mark variable as local.  */
if|if
condition|(
name|ctx
operator|&&
operator|!
name|is_global_var
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
operator|!
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|t
argument_list|)
operator|||
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|variables
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|t
argument_list|)
operator|==
name|NULL
operator|)
condition|)
name|omp_add_variable
argument_list|(
name|gimplify_omp_ctxp
argument_list|,
name|t
argument_list|,
name|GOVD_LOCAL
operator||
name|GOVD_SEEN
argument_list|)
expr_stmt|;
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Preliminarily mark non-addressed complex variables as eligible 	 for promotion to gimple registers.  We'll transform their uses 	 as we find them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_HARD_REGISTER
argument_list|(
name|t
argument_list|)
operator|)
operator|&&
operator|!
name|needs_to_live_in_memory
argument_list|(
name|t
argument_list|)
condition|)
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|gimple_push_bind_expr
argument_list|(
name|bind_expr
argument_list|)
expr_stmt|;
name|gimplify_ctxp
operator|->
name|save_stack
operator|=
name|false
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind_expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimplify_ctxp
operator|->
name|save_stack
condition|)
block|{
name|tree
name|stack_save
decl_stmt|,
name|stack_restore
decl_stmt|;
comment|/* Save stack on entry and restore it on exit.  Add a try_finally 	 block to achieve this.  Note that mudflap depends on the 	 format of the emitted code: see mx_register_decls().  */
name|build_stack_save_restore
argument_list|(
operator|&
name|stack_save
argument_list|,
operator|&
name|stack_restore
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|TRY_FINALLY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|BIND_EXPR_BODY
argument_list|(
name|bind_expr
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|stack_restore
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|BIND_EXPR_BODY
argument_list|(
name|bind_expr
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|stack_save
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind_expr
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind_expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gimplify_ctxp
operator|->
name|save_stack
operator|=
name|old_save_stack
expr_stmt|;
name|gimple_pop_bind_expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
operator|*
name|expr_p
operator|=
name|temp
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|bind_expr
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
else|else
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* Gimplify a RETURN_EXPR.  If the expression to be returned is not a    GIMPLE value, it is assigned to a new temporary and the statement is    re-written to return the temporary.     PRE_P points to the list where side effects that must happen before    STMT should be stored.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_return_expr
parameter_list|(
name|tree
name|stmt
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|ret_expr
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|result_decl
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|ret_expr
operator|||
name|TREE_CODE
argument_list|(
name|ret_expr
argument_list|)
operator|==
name|RESULT_DECL
operator|||
name|ret_expr
operator|==
name|error_mark_node
condition|)
return|return
name|GS_ALL_DONE
return|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|result_decl
operator|=
name|NULL_TREE
expr_stmt|;
else|else
block|{
name|result_decl
operator|=
name|TREE_OPERAND
argument_list|(
name|ret_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|result_decl
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
comment|/* See through a return by reference.  */
name|result_decl
operator|=
name|TREE_OPERAND
argument_list|(
name|result_decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|ret_expr
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|ret_expr
argument_list|)
operator|==
name|INIT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|result_decl
argument_list|)
operator|==
name|RESULT_DECL
argument_list|)
expr_stmt|;
block|}
comment|/* If aggregate_value_p is true, then we can return the bare RESULT_DECL.      Recall that aggregate_value_p is FALSE for any aggregate type that is      returned in registers.  If we're returning values in registers, then      we don't want to extend the lifetime of the RESULT_DECL, particularly      across another call.  In addition, for those aggregates for which      hard_function_value generates a PARALLEL, we'll die during normal      expansion of structure assignments; there's special code in expand_return      to handle this case that does not exist in expand_expr.  */
if|if
condition|(
operator|!
name|result_decl
operator|||
name|aggregate_value_p
argument_list|(
name|result_decl
argument_list|,
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|result
operator|=
name|result_decl
expr_stmt|;
elseif|else
if|if
condition|(
name|gimplify_ctxp
operator|->
name|return_temp
condition|)
name|result
operator|=
name|gimplify_ctxp
operator|->
name|return_temp
expr_stmt|;
else|else
block|{
name|result
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_decl
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* ??? With complex control flow (usually involving abnormal edges), 	 we can wind up warning about an uninitialized value for this.  Due 	 to how this variable is constructed and initialized, this is never 	 true.  Give up and never warn.  */
name|TREE_NO_WARNING
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gimplify_ctxp
operator|->
name|return_temp
operator|=
name|result
expr_stmt|;
block|}
comment|/* Smash the lhs of the MODIFY_EXPR to the temporary we plan to use.      Then gimplify the whole thing.  */
if|if
condition|(
name|result
operator|!=
name|result_decl
condition|)
name|TREE_OPERAND
argument_list|(
name|ret_expr
argument_list|,
literal|0
argument_list|)
operator|=
name|result
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* If we didn't use a temporary, then the result is just the result_decl.      Otherwise we need a simple copy.  This should already be gimple.  */
if|if
condition|(
name|result
operator|==
name|result_decl
condition|)
name|ret_expr
operator|=
name|result
expr_stmt|;
else|else
name|ret_expr
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|,
name|result_decl
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
operator|=
name|ret_expr
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* Gimplifies a DECL_EXPR node *STMT_P by making any necessary allocation    and initialization explicit.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_decl_expr
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|stmt
init|=
operator|*
name|stmt_p
decl_stmt|;
name|tree
name|decl
init|=
name|DECL_EXPR_DECL
argument_list|(
name|stmt
argument_list|)
decl_stmt|;
operator|*
name|stmt_p
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|GS_ERROR
return|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
operator|!
name|TYPE_SIZES_GIMPLIFIED
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|gimplify_type_sizes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|init
init|=
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* This is a variable-sized decl.  Simplify its size and mark it 	     for deferred expansion.  Note that mudflap depends on the format 	     of the emitted code: see mx_register_decls().  */
name|tree
name|t
decl_stmt|,
name|args
decl_stmt|,
name|addr
decl_stmt|,
name|ptr_type
decl_stmt|;
name|gimplify_one_sizepos
argument_list|(
operator|&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
name|gimplify_one_sizepos
argument_list|(
operator|&
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
comment|/* All occurrences of this decl in final gimplified code will be 	     replaced by indirection.  Setting DECL_VALUE_EXPR does two 	     things: First, it lets the rest of the gimplifier know what 	     replacement to use.  Second, it lets the debug info know 	     where to find the value.  */
name|ptr_type
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|create_tmp_var
argument_list|(
name|ptr_type
argument_list|,
name|get_name
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|addr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|build_fold_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|SET_DECL_VALUE_EXPR
argument_list|(
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_ALLOCA
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|fold_convert
argument_list|(
name|ptr_type
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|addr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
comment|/* Indicate that we need to restore the stack level when the 	     enclosing BIND_EXPR is exited.  */
name|gimplify_ctxp
operator|->
name|save_stack
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|init
operator|&&
name|init
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|init
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|init
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We must still examine initializers for static variables 	       as they may contain a label address.  */
name|walk_tree
argument_list|(
operator|&
name|init
argument_list|,
name|force_labels_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Some front ends do not explicitly declare all anonymous 	 artificial variables.  We compensate here by declaring the 	 variables, though it would be better if the front ends would 	 explicitly declare them.  */
if|if
condition|(
operator|!
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|gimple_add_tmp_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* Gimplify a LOOP_EXPR.  Normally this just involves gimplifying the body    and replacing the LOOP_EXPR with goto, but if the loop contains an    EXIT_EXPR, we need to append a label for it to jump to.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_loop_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|saved_label
init|=
name|gimplify_ctxp
operator|->
name|exit_label
decl_stmt|;
name|tree
name|start_label
init|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|tree
name|jump_stmt
init|=
name|build_and_jump
argument_list|(
operator|&
name|LABEL_EXPR_LABEL
argument_list|(
name|start_label
argument_list|)
argument_list|)
decl_stmt|;
name|append_to_statement_list
argument_list|(
name|start_label
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|gimplify_ctxp
operator|->
name|exit_label
operator|=
name|NULL_TREE
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|LOOP_EXPR_BODY
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimplify_ctxp
operator|->
name|exit_label
condition|)
block|{
name|append_to_statement_list
argument_list|(
name|jump_stmt
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|gimplify_ctxp
operator|->
name|exit_label
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|expr_p
operator|=
name|jump_stmt
expr_stmt|;
name|gimplify_ctxp
operator|->
name|exit_label
operator|=
name|saved_label
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* Compare two case labels.  Because the front end should already have    made sure that case ranges do not overlap, it is enough to only compare    the CASE_LOW values of each case label.  */
end_comment

begin_function
specifier|static
name|int
name|compare_case_labels
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
name|tree
name|case1
init|=
operator|*
operator|(
name|tree
operator|*
operator|)
name|p1
decl_stmt|;
name|tree
name|case2
init|=
operator|*
operator|(
name|tree
operator|*
operator|)
name|p2
decl_stmt|;
return|return
name|tree_int_cst_compare
argument_list|(
name|CASE_LOW
argument_list|(
name|case1
argument_list|)
argument_list|,
name|CASE_LOW
argument_list|(
name|case2
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sort the case labels in LABEL_VEC in place in ascending order.  */
end_comment

begin_function
name|void
name|sort_case_labels
parameter_list|(
name|tree
name|label_vec
parameter_list|)
block|{
name|size_t
name|len
init|=
name|TREE_VEC_LENGTH
argument_list|(
name|label_vec
argument_list|)
decl_stmt|;
name|tree
name|default_case
init|=
name|TREE_VEC_ELT
argument_list|(
name|label_vec
argument_list|,
name|len
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|CASE_LOW
argument_list|(
name|default_case
argument_list|)
condition|)
block|{
name|size_t
name|i
decl_stmt|;
comment|/* The last label in the vector should be the default case          but it is not.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|tree
name|t
init|=
name|TREE_VEC_ELT
argument_list|(
name|label_vec
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|CASE_LOW
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|default_case
operator|=
name|t
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|label_vec
argument_list|,
name|i
argument_list|)
operator|=
name|TREE_VEC_ELT
argument_list|(
name|label_vec
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|label_vec
argument_list|,
name|len
operator|-
literal|1
argument_list|)
operator|=
name|default_case
expr_stmt|;
break|break;
block|}
block|}
block|}
name|qsort
argument_list|(
operator|&
name|TREE_VEC_ELT
argument_list|(
name|label_vec
argument_list|,
literal|0
argument_list|)
argument_list|,
name|len
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|compare_case_labels
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gimplify a SWITCH_EXPR, and collect a TREE_VEC of the labels it can    branch to.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_switch_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|switch_expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|enum
name|gimplify_status
name|ret
decl_stmt|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|SWITCH_COND
argument_list|(
name|switch_expr
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|SWITCH_BODY
argument_list|(
name|switch_expr
argument_list|)
condition|)
block|{
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|labels
operator|,
operator|*
name|saved_labels
expr_stmt|;
name|tree
name|label_vec
decl_stmt|,
name|default_case
init|=
name|NULL_TREE
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|;
comment|/* If someone can be bothered to fill in the labels, they can 	 be bothered to null out the body too.  */
name|gcc_assert
argument_list|(
operator|!
name|SWITCH_LABELS
argument_list|(
name|switch_expr
argument_list|)
argument_list|)
expr_stmt|;
name|saved_labels
operator|=
name|gimplify_ctxp
operator|->
name|case_labels
expr_stmt|;
name|gimplify_ctxp
operator|->
name|case_labels
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|SWITCH_BODY
argument_list|(
name|switch_expr
argument_list|)
argument_list|)
expr_stmt|;
name|labels
operator|=
name|gimplify_ctxp
operator|->
name|case_labels
expr_stmt|;
name|gimplify_ctxp
operator|->
name|case_labels
operator|=
name|saved_labels
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|labels
argument_list|)
condition|)
block|{
name|tree
name|elt
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|labels
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|tree
name|low
init|=
name|CASE_LOW
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|bool
name|remove_element
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|low
condition|)
block|{
comment|/* Discard empty ranges.  */
name|tree
name|high
init|=
name|CASE_HIGH
argument_list|(
name|elt
argument_list|)
decl_stmt|;
if|if
condition|(
name|high
operator|&&
name|INT_CST_LT
argument_list|(
name|high
argument_list|,
name|low
argument_list|)
condition|)
name|remove_element
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* The default case must be the last label in the list.  */
name|gcc_assert
argument_list|(
operator|!
name|default_case
argument_list|)
expr_stmt|;
name|default_case
operator|=
name|elt
expr_stmt|;
name|remove_element
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|remove_element
condition|)
name|VEC_ordered_remove
argument_list|(
name|tree
argument_list|,
name|labels
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|i
expr_stmt|;
name|label_vec
operator|=
name|make_tree_vec
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SWITCH_LABELS
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|=
name|label_vec
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|switch_expr
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|default_case
condition|)
block|{
comment|/* If the switch has no default label, add one, so that we jump 	     around the switch body.  */
name|default_case
operator|=
name|build3
argument_list|(
name|CASE_LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|create_artificial_label
argument_list|()
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|SWITCH_BODY
argument_list|(
name|switch_expr
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|CASE_LABEL
argument_list|(
name|default_case
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|expr_p
operator|=
name|SWITCH_BODY
argument_list|(
name|switch_expr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|TREE_VEC_ELT
argument_list|(
name|label_vec
argument_list|,
name|i
argument_list|)
operator|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|labels
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|TREE_VEC_ELT
argument_list|(
name|label_vec
argument_list|,
name|len
argument_list|)
operator|=
name|default_case
expr_stmt|;
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|labels
argument_list|)
expr_stmt|;
name|sort_case_labels
argument_list|(
name|label_vec
argument_list|)
expr_stmt|;
name|SWITCH_BODY
argument_list|(
name|switch_expr
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|gcc_assert
argument_list|(
name|SWITCH_LABELS
argument_list|(
name|switch_expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_case_label_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|struct
name|gimplify_ctx
modifier|*
name|ctxp
decl_stmt|;
comment|/* Invalid OpenMP programs can play Duff's Device type games with      #pragma omp parallel.  At least in the C front end, we don't      detect such invalid branches until after gimplification.  */
for|for
control|(
name|ctxp
operator|=
name|gimplify_ctxp
init|;
condition|;
name|ctxp
operator|=
name|ctxp
operator|->
name|prev_context
control|)
if|if
condition|(
name|ctxp
operator|->
name|case_labels
condition|)
break|break;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|ctxp
operator|->
name|case_labels
argument_list|,
name|expr
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|CASE_LABEL
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* Build a GOTO to the LABEL_DECL pointed to by LABEL_P, building it first    if necessary.  */
end_comment

begin_function
name|tree
name|build_and_jump
parameter_list|(
name|tree
modifier|*
name|label_p
parameter_list|)
block|{
if|if
condition|(
name|label_p
operator|==
name|NULL
condition|)
comment|/* If there's nowhere to jump, just fall through.  */
return|return
name|NULL_TREE
return|;
if|if
condition|(
operator|*
name|label_p
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|label
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
operator|*
name|label_p
operator|=
name|label
expr_stmt|;
block|}
return|return
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
operator|*
name|label_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Gimplify an EXIT_EXPR by converting to a GOTO_EXPR inside a COND_EXPR.    This also involves building a label to jump to and communicating it to    gimplify_loop_expr through gimplify_ctxp->exit_label.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_exit_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|tree
name|cond
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|expr
decl_stmt|;
name|expr
operator|=
name|build_and_jump
argument_list|(
operator|&
name|gimplify_ctxp
operator|->
name|exit_label
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cond
argument_list|,
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|expr
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
end_function

begin_comment
comment|/* A helper function to be called via walk_tree.  Mark all labels under *TP    as being forced.  To be called for DECL_INITIAL of static variables.  */
end_comment

begin_function
name|tree
name|force_labels_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|tp
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
operator|==
name|LABEL_DECL
condition|)
name|FORCED_LABEL
argument_list|(
operator|*
name|tp
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* *EXPR_P is a COMPONENT_REF being used as an rvalue.  If its type is    different from its canonical type, wrap the whole thing inside a    NOP_EXPR and force the type of the COMPONENT_REF to be the canonical    type.     The canonical type of a COMPONENT_REF is the type of the field being    referenced--unless the field is a bit-field which can be read directly    in a smaller mode, in which case the canonical type is the    sign-appropriate type corresponding to that mode.  */
end_comment

begin_function
specifier|static
name|void
name|canonicalize_component_ref
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|get_unwidened
argument_list|(
name|expr
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|type
condition|)
block|{
name|tree
name|old_type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
comment|/* Set the type of the COMPONENT_REF to the underlying type.  */
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* And wrap the whole thing inside a NOP_EXPR.  */
name|expr
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|old_type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|expr
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If a NOP conversion is changing a pointer to array of foo to a pointer    to foo, embed that change in the ADDR_EXPR by converting       T array[U];       (T *)&array    ==>&array[L]    where L is the lower bound.  For simplicity, only do this for constant    lower bound.  */
end_comment

begin_function
specifier|static
name|void
name|canonicalize_addr_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|tree
name|ctype
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|addr_expr
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|atype
init|=
name|TREE_TYPE
argument_list|(
name|addr_expr
argument_list|)
decl_stmt|;
name|tree
name|dctype
decl_stmt|,
name|datype
decl_stmt|,
name|ddatype
decl_stmt|,
name|otype
decl_stmt|,
name|obj_expr
decl_stmt|;
comment|/* Both cast and addr_expr types should be pointers.  */
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|ctype
argument_list|)
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|atype
argument_list|)
condition|)
return|return;
comment|/* The addr_expr type should be a pointer to an array.  */
name|datype
operator|=
name|TREE_TYPE
argument_list|(
name|atype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|datype
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
return|return;
comment|/* Both cast and addr_expr types should address the same object type.  */
name|dctype
operator|=
name|TREE_TYPE
argument_list|(
name|ctype
argument_list|)
expr_stmt|;
name|ddatype
operator|=
name|TREE_TYPE
argument_list|(
name|datype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|ddatype
argument_list|,
name|dctype
argument_list|)
condition|)
return|return;
comment|/* The addr_expr and the object type should match.  */
name|obj_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|addr_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|obj_expr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|otype
argument_list|,
name|datype
argument_list|)
condition|)
return|return;
comment|/* The lower bound and element sizes must be constant.  */
if|if
condition|(
operator|!
name|TYPE_SIZE_UNIT
argument_list|(
name|dctype
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|dctype
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
operator|!
name|TYPE_DOMAIN
argument_list|(
name|datype
argument_list|)
operator|||
operator|!
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|datype
argument_list|)
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|datype
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return;
comment|/* All checks succeeded.  Build a new node to merge the cast.  */
operator|*
name|expr_p
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|dctype
argument_list|,
name|obj_expr
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|datype
argument_list|)
argument_list|)
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|datype
argument_list|)
argument_list|)
argument_list|,
name|size_binop
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|dctype
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_ALIGN_UNIT
argument_list|(
name|dctype
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ctype
argument_list|,
operator|*
name|expr_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* *EXPR_P is a NOP_EXPR or CONVERT_EXPR.  Remove it and/or other conversions    underneath as appropriate.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_conversion
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|CONVERT_EXPR
argument_list|)
expr_stmt|;
comment|/* Then strip away all but the outermost conversion.  */
name|STRIP_SIGN_NOPS
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And remove the outermost conversion if it's useless.  */
if|if
condition|(
name|tree_ssa_useless_type_conversion
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
operator|*
name|expr_p
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we still have a conversion at the toplevel,      then canonicalize some constructs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|tree
name|sub
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If a NOP conversion is changing the type of a COMPONENT_REF 	 expression, then canonicalize its type now in order to expose more 	 redundant conversions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
name|canonicalize_component_ref
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a NOP conversion is changing a pointer to array of foo 	 to a pointer to foo, embed that change in the ADDR_EXPR.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|canonicalize_addr_expr
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
block|}
return|return
name|GS_OK
return|;
block|}
end_function

begin_comment
comment|/* Gimplify a VAR_DECL or PARM_DECL.  Returns GS_OK if we expanded a     DECL_VALUE_EXPR, and it's worth re-examining things.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_var_or_parm_decl
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|*
name|expr_p
decl_stmt|;
comment|/* ??? If this is a local variable, and it has not been seen in any      outer BIND_EXPR, then it's probably the result of a duplicate      declaration, for which we've already issued an error.  It would      be really nice if the front end wouldn't leak these at all.      Currently the only known culprit is C++ destructors, as seen      in g++.old-deja/g++.jason/binding.C.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
name|current_function_decl
condition|)
block|{
name|gcc_assert
argument_list|(
name|errorcount
operator|||
name|sorrycount
argument_list|)
expr_stmt|;
return|return
name|GS_ERROR
return|;
block|}
comment|/* When within an OpenMP context, notice uses of variables.  */
if|if
condition|(
name|gimplify_omp_ctxp
operator|&&
name|omp_notice_variable
argument_list|(
name|gimplify_omp_ctxp
argument_list|,
name|decl
argument_list|,
name|true
argument_list|)
condition|)
return|return
name|GS_ALL_DONE
return|;
comment|/* If the decl is an alias for another expression, substitute it now.  */
if|if
condition|(
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
operator|*
name|expr_p
operator|=
name|unshare_expr
argument_list|(
name|DECL_VALUE_EXPR
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* Gimplify the COMPONENT_REF, ARRAY_REF, REALPART_EXPR or IMAGPART_EXPR    node pointed to by EXPR_P.        compound_lval 	      : min_lval '[' val ']' 	      | min_lval '.' ID 	      | compound_lval '[' val ']' 	      | compound_lval '.' ID     This is not part of the original SIMPLE definition, which separates    array and member references, but it seems reasonable to handle them    together.  Also, this way we don't run into problems with union    aliasing; gcc requires that for accesses through a union to alias, the    union reference must be explicit, which was not always the case when we    were splitting up array and member refs.     PRE_P points to the list where side effects that must happen before      *EXPR_P should be stored.     POST_P points to the list where side effects that must happen after      *EXPR_P should be stored.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_compound_lval
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|,
name|fallback_t
name|fallback
parameter_list|)
block|{
name|tree
modifier|*
name|p
decl_stmt|;
name|VEC
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|)
operator|*
name|stack
expr_stmt|;
name|enum
name|gimplify_status
name|ret
init|=
name|GS_OK
decl_stmt|,
name|tret
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create a stack of the subexpressions so later we can walk them in      order from inner to outer.  */
name|stack
operator|=
name|VEC_alloc
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* We can handle anything that get_inner_reference can deal with.  */
for|for
control|(
name|p
operator|=
name|expr_p
init|;
condition|;
name|p
operator|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|p
argument_list|,
literal|0
argument_list|)
control|)
block|{
name|restart
label|:
comment|/* Fold INDIRECT_REFs now to turn them into ARRAY_REFs.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
operator|*
name|p
operator|=
name|fold_indirect_ref
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|handled_component_p
argument_list|(
operator|*
name|p
argument_list|)
condition|)
empty_stmt|;
comment|/* Expand DECL_VALUE_EXPR now.  In some cases that may expose 	 additional COMPONENT_REFs.  */
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|p
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
name|gimplify_var_or_parm_decl
argument_list|(
name|p
argument_list|)
operator|==
name|GS_OK
condition|)
goto|goto
name|restart
goto|;
else|else
break|break;
name|VEC_safe_push
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|stack
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|stack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now STACK is a stack of pointers to all the refs we've walked through      and P points to the innermost expression.       Java requires that we elaborated nodes in source order.  That      means we must gimplify the inner expression followed by each of      the indices, in order.  But we can't gimplify the inner      expression until we deal with any variable bounds, sizes, or      positions in order to deal with PLACEHOLDER_EXPRs.       So we do this in three steps.  First we deal with the annotations      for any variables in the components, then we gimplify the base,      then we gimplify any indices, from left to right.  */
for|for
control|(
name|i
operator|=
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|stack
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|tree
name|t
init|=
name|VEC_index
argument_list|(
name|tree
argument_list|,
name|stack
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
comment|/* Gimplify the low bound and element type size and put them into 	     the ARRAY_REF.  If these values are set, they have already been 	     gimplified.  */
if|if
condition|(
operator|!
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|tree
name|low
init|=
name|unshare_expr
argument_list|(
name|array_ref_low_bound
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|low
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|low
expr_stmt|;
name|tret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_formal_tmp_reg
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|ret
argument_list|,
name|tret
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|tree
name|elmt_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|elmt_size
init|=
name|unshare_expr
argument_list|(
name|array_ref_element_size
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|factor
init|=
name|size_int
argument_list|(
name|TYPE_ALIGN_UNIT
argument_list|(
name|elmt_type
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Divide the element size by the alignment of the element 		 type (above).  */
name|elmt_size
operator|=
name|size_binop
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|elmt_size
argument_list|,
name|factor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|elmt_size
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
operator|=
name|elmt_size
expr_stmt|;
name|tret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|3
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_formal_tmp_reg
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|ret
argument_list|,
name|tret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
comment|/* Set the field offset into T and gimplify it.  */
if|if
condition|(
operator|!
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|tree
name|offset
init|=
name|unshare_expr
argument_list|(
name|component_ref_field_offset
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|field
init|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|factor
init|=
name|size_int
argument_list|(
name|DECL_OFFSET_ALIGN
argument_list|(
name|field
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
decl_stmt|;
comment|/* Divide the offset by its alignment.  */
name|offset
operator|=
name|size_binop
argument_list|(
name|EXACT_DIV_EXPR
argument_list|,
name|offset
argument_list|,
name|factor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|offset
argument_list|)
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
operator|=
name|offset
expr_stmt|;
name|tret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_formal_tmp_reg
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|ret
argument_list|,
name|tret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Step 2 is to gimplify the base expression.  Make sure lvalue is set      so as to match the min_lval predicate.  Failure to do so may result      in the creation of large aggregate temporaries.  */
name|tret
operator|=
name|gimplify_expr
argument_list|(
name|p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_min_lval
argument_list|,
name|fallback
operator||
name|fb_lvalue
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|ret
argument_list|,
name|tret
argument_list|)
expr_stmt|;
comment|/* And finally, the indices and operands to BIT_FIELD_REF.  During this      loop we also remove any useless conversions.  */
for|for
control|(
init|;
name|VEC_length
argument_list|(
name|tree
argument_list|,
name|stack
argument_list|)
operator|>
literal|0
condition|;
control|)
block|{
name|tree
name|t
init|=
name|VEC_pop
argument_list|(
name|tree
argument_list|,
name|stack
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_REF
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|ARRAY_RANGE_REF
condition|)
block|{
comment|/* Gimplify the dimension. 	     Temporary fix for gcc.c-torture/execute/20040313-1.c. 	     Gimplify non-constant array indices into a temporary 	     variable. 	     FIXME - The real fix is to gimplify post-modify 	     expressions into a minimal gimple lvalue.  However, that 	     exposes bugs in alias analysis.  The alias analyzer does 	     not handle&PTR->FIELD very well.  Will fix after the 	     branch is merged into mainline (dnovillo 2004-05-03).  */
if|if
condition|(
operator|!
name|is_gimple_min_invariant
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|tret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_formal_tmp_reg
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|ret
argument_list|,
name|tret
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
block|{
name|tret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|ret
argument_list|,
name|tret
argument_list|)
expr_stmt|;
name|tret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|2
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|ret
argument_list|,
name|tret
argument_list|)
expr_stmt|;
block|}
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The innermost expression P may have originally had TREE_SIDE_EFFECTS 	 set which would have caused all the outer expressions in EXPR_P 	 leading to P to also have had TREE_SIDE_EFFECTS set.  */
name|recalculate_side_effects
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|tret
operator|=
name|gimplify_expr
argument_list|(
name|p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_min_lval
argument_list|,
name|fallback
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|ret
argument_list|,
name|tret
argument_list|)
expr_stmt|;
comment|/* If the outermost expression is a COMPONENT_REF, canonicalize its type.  */
if|if
condition|(
operator|(
name|fallback
operator|&
name|fb_rvalue
operator|)
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|canonicalize_component_ref
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|ret
argument_list|,
name|GS_OK
argument_list|)
expr_stmt|;
block|}
name|VEC_free
argument_list|(
name|tree
argument_list|,
name|heap
argument_list|,
name|stack
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  Gimplify the self modifying expression pointed to by EXPR_P     (++, --, +=, -=).      PRE_P points to the list where side effects that must happen before 	*EXPR_P should be stored.      POST_P points to the list where side effects that must happen after 	*EXPR_P should be stored.      WANT_VALUE is nonzero iff we want to use the value of this expression 	in another expression.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_self_mod_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|,
name|bool
name|want_value
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|lhs
decl_stmt|,
name|lvalue
decl_stmt|,
name|rhs
decl_stmt|,
name|t1
decl_stmt|,
name|post
init|=
name|NULL
decl_stmt|,
modifier|*
name|orig_post_p
init|=
name|post_p
decl_stmt|;
name|bool
name|postfix
decl_stmt|;
name|enum
name|tree_code
name|arith_code
decl_stmt|;
name|enum
name|gimplify_status
name|ret
decl_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTDECREMENT_EXPR
operator|||
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|PREDECREMENT_EXPR
argument_list|)
expr_stmt|;
comment|/* Prefix or postfix?  */
if|if
condition|(
name|code
operator|==
name|POSTINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTDECREMENT_EXPR
condition|)
comment|/* Faster to treat as prefix if result is not used.  */
name|postfix
operator|=
name|want_value
expr_stmt|;
else|else
name|postfix
operator|=
name|false
expr_stmt|;
comment|/* For postfix, make sure the inner expression's post side effects      are executed after side effects from this expression.  */
if|if
condition|(
name|postfix
condition|)
name|post_p
operator|=
operator|&
name|post
expr_stmt|;
comment|/* Add or subtract?  */
if|if
condition|(
name|code
operator|==
name|PREINCREMENT_EXPR
operator|||
name|code
operator|==
name|POSTINCREMENT_EXPR
condition|)
name|arith_code
operator|=
name|PLUS_EXPR
expr_stmt|;
else|else
name|arith_code
operator|=
name|MINUS_EXPR
expr_stmt|;
comment|/* Gimplify the LHS into a GIMPLE lvalue.  */
name|lvalue
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|lvalue
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_lvalue
argument_list|,
name|fb_lvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|GS_ERROR
condition|)
return|return
name|ret
return|;
comment|/* Extract the operands to the arithmetic operation.  */
name|lhs
operator|=
name|lvalue
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* For postfix operator, we evaluate the LHS to an rvalue and then use      that as the result value and in the postqueue operation.  */
if|if
condition|(
name|postfix
condition|)
block|{
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|lhs
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|GS_ERROR
condition|)
return|return
name|ret
return|;
block|}
name|t1
operator|=
name|build2
argument_list|(
name|arith_code
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|lhs
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|t1
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lvalue
argument_list|)
argument_list|,
name|lvalue
argument_list|,
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|postfix
condition|)
block|{
name|gimplify_and_add
argument_list|(
name|t1
argument_list|,
name|orig_post_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|post
argument_list|,
name|orig_post_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|lhs
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
else|else
block|{
operator|*
name|expr_p
operator|=
name|t1
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
block|}
end_function

begin_comment
comment|/* If *EXPR_P has a variable sized type, wrap it in a WITH_SIZE_EXPR.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_with_size_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|size
decl_stmt|;
comment|/* If we've already wrapped this or the type is error_mark_node, we can't do      anything.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|WITH_SIZE_EXPR
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* If the size isn't known or is a constant, we have nothing to do.  */
name|size
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|size
operator|||
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return;
comment|/* Otherwise, make a WITH_SIZE_EXPR.  */
name|size
operator|=
name|unshare_expr
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|size
argument_list|,
name|expr
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|build2
argument_list|(
name|WITH_SIZE_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of gimplify_call_expr:  Gimplify a single argument.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_arg
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|bool
function_decl|(
modifier|*
name|test
function_decl|)
parameter_list|(
name|tree
parameter_list|)
function_decl|;
name|fallback_t
name|fb
decl_stmt|;
comment|/* In general, we allow lvalues for function arguments to avoid      extra overhead of copying large aggregates out of even larger      aggregates into temporaries only to copy the temporaries to      the argument list.  Make optimizers happy by pulling out to      temporaries those types that fit in registers.  */
if|if
condition|(
name|is_gimple_reg_type
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
condition|)
name|test
operator|=
name|is_gimple_val
operator|,
name|fb
operator|=
name|fb_rvalue
expr_stmt|;
else|else
name|test
operator|=
name|is_gimple_lvalue
operator|,
name|fb
operator|=
name|fb_either
expr_stmt|;
comment|/* If this is a variable sized type, we must remember the size.  */
name|maybe_with_size_expr
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
comment|/* There is a sequence point before a function call.  Side effects in      the argument list must occur before the actual call. So, when      gimplifying arguments, force gimplify_expr to use an internal      post queue which is then appended to the end of PRE_P.  */
return|return
name|gimplify_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|test
argument_list|,
name|fb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Gimplify the CALL_EXPR node pointed to by EXPR_P.  PRE_P points to the    list where side effects that must happen before *EXPR_P should be stored.    WANT_VALUE is true if the result of the call is desired.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_call_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|bool
name|want_value
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|tree
name|arglist
decl_stmt|;
name|enum
name|gimplify_status
name|ret
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
comment|/* For reliable diagnostics during inlining, it is necessary that      every call_expr be annotated with file and line.  */
if|if
condition|(
operator|!
name|EXPR_HAS_LOCATION
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
name|SET_EXPR_LOCATION
argument_list|(
operator|*
name|expr_p
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
comment|/* This may be a call to a builtin function.       Builtin function calls may be transformed into different      (and more efficient) builtin function calls under certain      circumstances.  Unfortunately, gimplification can muck things      up enough that the builtin expanders are not aware that certain      transformations are still valid.       So we attempt transformation/gimplification of the call before      we gimplify the CALL_EXPR.  At this time we do not manage to      transform all calls in the same manner as the expanders do, but      we do transform most of them.  */
name|decl
operator|=
name|get_callee_fndecl
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|new
init|=
name|fold_builtin
argument_list|(
name|decl
argument_list|,
name|arglist
argument_list|,
operator|!
name|want_value
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|&&
name|new
operator|!=
operator|*
name|expr_p
condition|)
block|{
comment|/* There was a transformation of this call which computes the 	     same value, but in a more efficient way.  Return and try 	     again.  */
operator|*
name|expr_p
operator|=
name|new
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
operator|&&
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_VA_START
condition|)
block|{
if|if
condition|(
operator|!
name|arglist
operator|||
operator|!
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"too few arguments to function %<va_start%>"
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
if|if
condition|(
name|fold_builtin_next_arg
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|expr_p
operator|=
name|build_empty_stmt
argument_list|()
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
comment|/* Avoid gimplifying the second argument to va_start, which needs 	     to be the plain PARM_DECL.  */
return|return
name|gimplify_arg
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|pre_p
argument_list|)
return|;
block|}
block|}
comment|/* There is a sequence point before the call, so any side effects in      the calling expression must occur before the actual call.  Force      gimplify_expr to use an internal post queue.  */
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_call_addr
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|PUSH_ARGS_REVERSED
condition|)
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
init|;
name|arglist
condition|;
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
control|)
block|{
name|enum
name|gimplify_status
name|t
decl_stmt|;
name|t
operator|=
name|gimplify_arg
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|GS_ERROR
condition|)
name|ret
operator|=
name|GS_ERROR
expr_stmt|;
block|}
if|if
condition|(
name|PUSH_ARGS_REVERSED
condition|)
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
operator|=
name|nreverse
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try this again in case gimplification exposed something.  */
if|if
condition|(
name|ret
operator|!=
name|GS_ERROR
condition|)
block|{
name|decl
operator|=
name|get_callee_fndecl
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|new
init|=
name|fold_builtin
argument_list|(
name|decl
argument_list|,
name|arglist
argument_list|,
operator|!
name|want_value
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|&&
name|new
operator|!=
operator|*
name|expr_p
condition|)
block|{
comment|/* There was a transformation of this call which computes the 		 same value, but in a more efficient way.  Return and try 		 again.  */
operator|*
name|expr_p
operator|=
name|new
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
block|}
block|}
comment|/* If the function is "const" or "pure", then clear TREE_SIDE_EFFECTS on its      decl.  This allows us to eliminate redundant or useless      calls to "const" functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
operator|(
name|call_expr_flags
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|&
operator|(
name|ECF_CONST
operator||
name|ECF_PURE
operator|)
operator|)
condition|)
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Handle shortcut semantics in the predicate operand of a COND_EXPR by    rewriting it into multiple COND_EXPRs, and possibly GOTO_EXPRs.     TRUE_LABEL_P and FALSE_LABEL_P point to the labels to jump to if the    condition is true or false, respectively.  If null, we should generate    our own to skip over the evaluation of this specific expression.     This function is the tree equivalent of do_jump.     shortcut_cond_r should only be called by shortcut_cond_expr.  */
end_comment

begin_function
specifier|static
name|tree
name|shortcut_cond_r
parameter_list|(
name|tree
name|pred
parameter_list|,
name|tree
modifier|*
name|true_label_p
parameter_list|,
name|tree
modifier|*
name|false_label_p
parameter_list|)
block|{
name|tree
name|local_label
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|t
decl_stmt|,
name|expr
init|=
name|NULL
decl_stmt|;
comment|/* OK, it's not a simple case; we need to pull apart the COND_EXPR to      retain the shortcut semantics.  Just insert the gotos here;      shortcut_cond_expr will append the real blocks later.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pred
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
condition|)
block|{
comment|/* Turn if (a&& b) into  	 if (a); else goto no; 	 if (b) goto yes; else goto no; 	 (no:) */
if|if
condition|(
name|false_label_p
operator|==
name|NULL
condition|)
name|false_label_p
operator|=
operator|&
name|local_label
expr_stmt|;
name|t
operator|=
name|shortcut_cond_r
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pred
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|false_label_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|t
operator|=
name|shortcut_cond_r
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pred
argument_list|,
literal|1
argument_list|)
argument_list|,
name|true_label_p
argument_list|,
name|false_label_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pred
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
condition|)
block|{
comment|/* Turn if (a || b) into  	 if (a) goto yes; 	 if (b) goto yes; else goto no; 	 (yes:) */
if|if
condition|(
name|true_label_p
operator|==
name|NULL
condition|)
name|true_label_p
operator|=
operator|&
name|local_label
expr_stmt|;
name|t
operator|=
name|shortcut_cond_r
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pred
argument_list|,
literal|0
argument_list|)
argument_list|,
name|true_label_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|t
operator|=
name|shortcut_cond_r
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pred
argument_list|,
literal|1
argument_list|)
argument_list|,
name|true_label_p
argument_list|,
name|false_label_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pred
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* As long as we're messing with gotos, turn if (a ? b : c) into 	 if (a) 	   if (b) goto yes; else goto no; 	 else 	   if (c) goto yes; else goto no;  */
name|expr
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|pred
argument_list|,
literal|0
argument_list|)
argument_list|,
name|shortcut_cond_r
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pred
argument_list|,
literal|1
argument_list|)
argument_list|,
name|true_label_p
argument_list|,
name|false_label_p
argument_list|)
argument_list|,
name|shortcut_cond_r
argument_list|(
name|TREE_OPERAND
argument_list|(
name|pred
argument_list|,
literal|2
argument_list|)
argument_list|,
name|true_label_p
argument_list|,
name|false_label_p
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|expr
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|pred
argument_list|,
name|build_and_jump
argument_list|(
name|true_label_p
argument_list|)
argument_list|,
name|build_and_jump
argument_list|(
name|false_label_p
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_label
condition|)
block|{
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|local_label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_function
specifier|static
name|tree
name|shortcut_cond_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|pred
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|then_
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|else_
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|tree
name|true_label
decl_stmt|,
name|false_label
decl_stmt|,
name|end_label
decl_stmt|,
name|t
decl_stmt|;
name|tree
modifier|*
name|true_label_p
decl_stmt|;
name|tree
modifier|*
name|false_label_p
decl_stmt|;
name|bool
name|emit_end
decl_stmt|,
name|emit_false
decl_stmt|,
name|jump_over_else
decl_stmt|;
name|bool
name|then_se
init|=
name|then_
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|then_
argument_list|)
decl_stmt|;
name|bool
name|else_se
init|=
name|else_
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|else_
argument_list|)
decl_stmt|;
comment|/* First do simple transformations.  */
if|if
condition|(
operator|!
name|else_se
condition|)
block|{
comment|/* If there is no 'else', turn (a&& b) into if (a) if (b).  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|pred
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|pred
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|then_
operator|=
name|shortcut_cond_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|then_se
operator|=
name|then_
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|then_
argument_list|)
expr_stmt|;
name|pred
operator|=
name|TREE_OPERAND
argument_list|(
name|pred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|pred
argument_list|,
name|then_
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|then_se
condition|)
block|{
comment|/* If there is no 'then', turn 	   if (a || b); else d 	 into 	   if (a); else if (b); else d.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|pred
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|pred
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|else_
operator|=
name|shortcut_cond_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|else_se
operator|=
name|else_
operator|&&
name|TREE_SIDE_EFFECTS
argument_list|(
name|else_
argument_list|)
expr_stmt|;
name|pred
operator|=
name|TREE_OPERAND
argument_list|(
name|pred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|pred
argument_list|,
name|NULL_TREE
argument_list|,
name|else_
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we're done, great.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|pred
argument_list|)
operator|!=
name|TRUTH_ANDIF_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|pred
argument_list|)
operator|!=
name|TRUTH_ORIF_EXPR
condition|)
return|return
name|expr
return|;
comment|/* Otherwise we need to mess with gotos.  Change        if (a) c; else d;      to        if (a); else goto no;        c; goto end;        no: d; end:      and recursively gimplify the condition.  */
name|true_label
operator|=
name|false_label
operator|=
name|end_label
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* If our arms just jump somewhere, hijack those labels so we don't      generate jumps to jumps.  */
if|if
condition|(
name|then_
operator|&&
name|TREE_CODE
argument_list|(
name|then_
argument_list|)
operator|==
name|GOTO_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|then_
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
condition|)
block|{
name|true_label
operator|=
name|GOTO_DESTINATION
argument_list|(
name|then_
argument_list|)
expr_stmt|;
name|then_
operator|=
name|NULL
expr_stmt|;
name|then_se
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|else_
operator|&&
name|TREE_CODE
argument_list|(
name|else_
argument_list|)
operator|==
name|GOTO_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|GOTO_DESTINATION
argument_list|(
name|else_
argument_list|)
argument_list|)
operator|==
name|LABEL_DECL
condition|)
block|{
name|false_label
operator|=
name|GOTO_DESTINATION
argument_list|(
name|else_
argument_list|)
expr_stmt|;
name|else_
operator|=
name|NULL
expr_stmt|;
name|else_se
operator|=
name|false
expr_stmt|;
block|}
comment|/* If we aren't hijacking a label for the 'then' branch, it falls through.  */
if|if
condition|(
name|true_label
condition|)
name|true_label_p
operator|=
operator|&
name|true_label
expr_stmt|;
else|else
name|true_label_p
operator|=
name|NULL
expr_stmt|;
comment|/* The 'else' branch also needs a label if it contains interesting code.  */
if|if
condition|(
name|false_label
operator|||
name|else_se
condition|)
name|false_label_p
operator|=
operator|&
name|false_label
expr_stmt|;
else|else
name|false_label_p
operator|=
name|NULL
expr_stmt|;
comment|/* If there was nothing else in our arms, just forward the label(s).  */
if|if
condition|(
operator|!
name|then_se
operator|&&
operator|!
name|else_se
condition|)
return|return
name|shortcut_cond_r
argument_list|(
name|pred
argument_list|,
name|true_label_p
argument_list|,
name|false_label_p
argument_list|)
return|;
comment|/* If our last subexpression already has a terminal label, reuse it.  */
if|if
condition|(
name|else_se
condition|)
name|expr
operator|=
name|expr_last
argument_list|(
name|else_
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|then_se
condition|)
name|expr
operator|=
name|expr_last
argument_list|(
name|then_
argument_list|)
expr_stmt|;
else|else
name|expr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|expr
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|LABEL_EXPR
condition|)
name|end_label
operator|=
name|LABEL_EXPR_LABEL
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* If we don't care about jumping to the 'else' branch, jump to the end      if the condition is false.  */
if|if
condition|(
operator|!
name|false_label_p
condition|)
name|false_label_p
operator|=
operator|&
name|end_label
expr_stmt|;
comment|/* We only want to emit these labels if we aren't hijacking them.  */
name|emit_end
operator|=
operator|(
name|end_label
operator|==
name|NULL_TREE
operator|)
expr_stmt|;
name|emit_false
operator|=
operator|(
name|false_label
operator|==
name|NULL_TREE
operator|)
expr_stmt|;
comment|/* We only emit the jump over the else clause if we have to--if the      then clause may fall through.  Otherwise we can wind up with a      useless jump and a useless label at the end of gimplified code,      which will cause us to think that this conditional as a whole      falls through even if it doesn't.  If we then inline a function      which ends with such a condition, that can cause us to issue an      inappropriate warning about control reaching the end of a      non-void function.  */
name|jump_over_else
operator|=
name|block_may_fallthru
argument_list|(
name|then_
argument_list|)
expr_stmt|;
name|pred
operator|=
name|shortcut_cond_r
argument_list|(
name|pred
argument_list|,
name|true_label_p
argument_list|,
name|false_label_p
argument_list|)
expr_stmt|;
name|expr
operator|=
name|NULL
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|pred
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|then_
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|else_se
condition|)
block|{
if|if
condition|(
name|jump_over_else
condition|)
block|{
name|t
operator|=
name|build_and_jump
argument_list|(
operator|&
name|end_label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|emit_false
condition|)
block|{
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|false_label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
block|}
name|append_to_statement_list
argument_list|(
name|else_
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|emit_end
operator|&&
name|end_label
condition|)
block|{
name|t
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|end_label
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
operator|&
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* EXPR is used in a boolean context; make sure it has BOOLEAN_TYPE.  */
end_comment

begin_function
name|tree
name|gimple_boolify
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|BOOLEAN_TYPE
condition|)
return|return
name|expr
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
comment|/* Also boolify the arguments of truth exprs.  */
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|gimple_boolify
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|TRUTH_NOT_EXPR
case|:
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|gimple_boolify
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
comment|/* These expressions always produce boolean results.  */
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|boolean_type_node
expr_stmt|;
return|return
name|expr
return|;
default|default:
comment|/* Other expressions that get here must have boolean values, but 	 might need to be converted to the appropriate mode.  */
return|return
name|fold_convert
argument_list|(
name|boolean_type_node
argument_list|,
name|expr
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  Convert the conditional expression pointed to by EXPR_P '(p) ? a : b;'     into      if (p)			if (p)       t1 = a;			  a;     else		or	else       t1 = b;			  b;     t1;      The second form is used when *EXPR_P is of type void.      TARGET is the tree for T1 above.      PRE_P points to the list where side effects that must happen before       *EXPR_P should be stored.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_cond_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|fallback_t
name|fallback
parameter_list|)
block|{
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|tree
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|,
name|type
decl_stmt|;
name|enum
name|gimplify_status
name|ret
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* If this COND_EXPR has a value, copy the values into a temporary within      the arms.  */
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|fallback
operator|&
name|fb_lvalue
operator|)
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|tmp2
operator|=
name|tmp
operator|=
name|create_tmp_var
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|"iftmp"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
block|}
else|else
block|{
name|tree
name|type
init|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|build_fold_addr_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
operator|=
name|build_fold_addr_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|tmp
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
literal|"iftmp"
argument_list|)
expr_stmt|;
name|expr
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|build_fold_indirect_ref
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
block|}
comment|/* Build the then clause, 't1 = a;'.  But don't build an assignment 	 if this branch is void; in C++ it can be, if it's a throw.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tmp
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build the else clause, 't1 = b;'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|tmp2
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|recalculate_side_effects
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Move the COND_EXPR to the prequeue.  */
name|gimplify_and_add
argument_list|(
name|expr
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|result
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* Make sure the condition has BOOLEAN_TYPE.  */
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|gimple_boolify
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Break apart&& and || conditions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TRUTH_ORIF_EXPR
condition|)
block|{
name|expr
operator|=
name|shortcut_cond_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|expr
operator|!=
operator|*
name|expr_p
condition|)
block|{
operator|*
name|expr_p
operator|=
name|expr
expr_stmt|;
comment|/* We can't rely on gimplify_expr to re-gimplify the expanded 	     form properly, as cleanups might cause the target labels to be 	     wrapped in a TRY_FINALLY_EXPR.  To prevent that, we need to 	     set up a conditional context.  */
name|gimple_push_condition
argument_list|()
expr_stmt|;
name|gimplify_stmt
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|gimple_pop_condition
argument_list|(
name|pre_p
argument_list|)
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
block|}
comment|/* Now do the normal gimplification.  */
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_condexpr
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|gimple_push_condition
argument_list|()
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|recalculate_side_effects
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|gimple_pop_condition
argument_list|(
name|pre_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|GS_ERROR
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
condition|)
comment|/* Rewrite "if (a); else b" to "if (!a) b"  */
block|{
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|=
name|invert_truthvalue
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_condexpr
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
operator|=
name|tmp
expr_stmt|;
block|}
else|else
comment|/* Both arms are empty; replace the COND_EXPR with its predicate.  */
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|expr
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_modify_expr.  Replace a MODIFY_EXPR with    a call to __builtin_memcpy.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_modify_expr_to_memcpy
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
name|size
parameter_list|,
name|bool
name|want_value
parameter_list|)
block|{
name|tree
name|args
decl_stmt|,
name|t
decl_stmt|,
name|to
decl_stmt|,
name|to_ptr
decl_stmt|,
name|from
decl_stmt|;
name|to
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|from
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|to_ptr
operator|=
name|build_fold_addr_expr
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|to_ptr
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCPY
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_value
condition|)
block|{
name|t
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|to_ptr
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
operator|*
name|expr_p
operator|=
name|t
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_modify_expr.  Replace a MODIFY_EXPR with    a call to __builtin_memset.  In this case we know that the RHS is    a CONSTRUCTOR with an empty element list.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_modify_expr_to_memset
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
name|size
parameter_list|,
name|bool
name|want_value
parameter_list|)
block|{
name|tree
name|args
decl_stmt|,
name|t
decl_stmt|,
name|to
decl_stmt|,
name|to_ptr
decl_stmt|;
name|to
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|integer_zero_node
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|to_ptr
operator|=
name|build_fold_addr_expr
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|to_ptr
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMSET
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_value
condition|)
block|{
name|t
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|to_ptr
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|to
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
operator|*
name|expr_p
operator|=
name|t
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_init_ctor_preeval.  Called via walk_tree,    determine, cautiously, if a CONSTRUCTOR overlaps the lhs of an    assignment.  Returns non-null if we detect a potential overlap.  */
end_comment

begin_struct
struct|struct
name|gimplify_init_ctor_preeval_data
block|{
comment|/* The base decl of the lhs object.  May be NULL, in which case we      have to assume the lhs is indirect.  */
name|tree
name|lhs_base_decl
decl_stmt|;
comment|/* The alias set of the lhs object.  */
name|int
name|lhs_alias_set
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|tree
name|gimplify_init_ctor_preeval_1
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
parameter_list|,
name|void
modifier|*
name|xdata
parameter_list|)
block|{
name|struct
name|gimplify_init_ctor_preeval_data
modifier|*
name|data
init|=
operator|(
expr|struct
name|gimplify_init_ctor_preeval_data
operator|*
operator|)
name|xdata
decl_stmt|;
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
comment|/* If we find the base object, obviously we have overlap.  */
if|if
condition|(
name|data
operator|->
name|lhs_base_decl
operator|==
name|t
condition|)
return|return
name|t
return|;
comment|/* If the constructor component is indirect, determine if we have a      potential overlap with the lhs.  The only bits of information we      have to go on at this point are addressability and alias sets.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
operator|(
operator|!
name|data
operator|->
name|lhs_base_decl
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|data
operator|->
name|lhs_base_decl
argument_list|)
operator|)
operator|&&
name|alias_sets_conflict_p
argument_list|(
name|data
operator|->
name|lhs_alias_set
argument_list|,
name|get_alias_set
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
name|t
return|;
comment|/* If the constructor component is a call, determine if it can hide a      potential overlap with the lhs through an INDIRECT_REF like above.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|type
decl_stmt|,
name|fntype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|fntype
argument_list|)
init|;
name|type
condition|;
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
control|)
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
operator|(
operator|!
name|data
operator|->
name|lhs_base_decl
operator|||
name|TREE_ADDRESSABLE
argument_list|(
name|data
operator|->
name|lhs_base_decl
argument_list|)
operator|)
operator|&&
name|alias_sets_conflict_p
argument_list|(
name|data
operator|->
name|lhs_alias_set
argument_list|,
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|t
return|;
block|}
if|if
condition|(
name|IS_TYPE_OR_DECL_P
argument_list|(
name|t
argument_list|)
condition|)
operator|*
name|walk_subtrees
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_init_constructor.  Pre-evaluate *EXPR_P,    force values that overlap with the lhs (as described by *DATA)    into temporaries.  */
end_comment

begin_function
specifier|static
name|void
name|gimplify_init_ctor_preeval
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|,
name|struct
name|gimplify_init_ctor_preeval_data
modifier|*
name|data
parameter_list|)
block|{
name|enum
name|gimplify_status
name|one
decl_stmt|;
comment|/* If the value is invariant, then there's nothing to pre-evaluate.      But ensure it doesn't have any side-effects since a SAVE_EXPR is      invariant but has side effects and might contain a reference to      the object we're initializing.  */
if|if
condition|(
name|TREE_INVARIANT
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|&&
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
return|return;
comment|/* If the type has non-trivial constructors, we can't pre-evaluate.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
condition|)
return|return;
comment|/* Recurse for nested constructors.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|ix
decl_stmt|;
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
name|ix
argument_list|,
name|ce
argument_list|)
condition|;
name|ix
operator|++
control|)
name|gimplify_init_ctor_preeval
argument_list|(
operator|&
name|ce
operator|->
name|value
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is a variable sized type, we must remember the size.  */
name|maybe_with_size_expr
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
comment|/* Gimplify the constructor element to something appropriate for the rhs      of a MODIFY_EXPR.  Given that we know the lhs is an aggregate, we know      the gimplifier will consider this a store to memory.  Doing this      gimplification now means that we won't have to deal with complicated      language-specific trees, nor trees like SAVE_EXPR that can induce      exponential search behavior.  */
name|one
operator|=
name|gimplify_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_mem_rhs
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|one
operator|==
name|GS_ERROR
condition|)
block|{
operator|*
name|expr_p
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* If we gimplified to a bare decl, we can be sure that it doesn't overlap      with the lhs, since "a = { .x=a }" doesn't make sense.  This will      always be true for all scalars, since is_gimple_mem_rhs insists on a      temporary variable for them.  */
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
return|return;
comment|/* If this is of variable size, we have no choice but to assume it doesn't      overlap since we can't make a temporary for it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
return|return;
comment|/* Otherwise, we must search for overlap ...  */
if|if
condition|(
operator|!
name|walk_tree
argument_list|(
name|expr_p
argument_list|,
name|gimplify_init_ctor_preeval_1
argument_list|,
name|data
argument_list|,
name|NULL
argument_list|)
condition|)
return|return;
comment|/* ... and if found, force the value into a temporary.  */
operator|*
name|expr_p
operator|=
name|get_formal_tmp_var
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_init_ctor_eval.  Create a loop for    a RANGE_EXPR in a CONSTRUCTOR for an array.        var = lower;     loop_entry:       object[var] = value;       if (var == upper) 	goto loop_exit;       var = var + 1;       goto loop_entry;     loop_exit:     We increment var _after_ the loop exit check because we might otherwise    fail if upper == TYPE_MAX_VALUE (type for upper).     Note that we never have to deal with SAVE_EXPRs here, because this has    already been taken care of for us, in gimplify_init_ctor_preeval().  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|gimplify_init_ctor_eval
argument_list|(
name|tree
argument_list|,
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
argument_list|,
name|tree
operator|*
argument_list|,
name|bool
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gimplify_init_ctor_eval_range
parameter_list|(
name|tree
name|object
parameter_list|,
name|tree
name|lower
parameter_list|,
name|tree
name|upper
parameter_list|,
name|tree
name|value
parameter_list|,
name|tree
name|array_elt_type
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|bool
name|cleared
parameter_list|)
block|{
name|tree
name|loop_entry_label
decl_stmt|,
name|loop_exit_label
decl_stmt|;
name|tree
name|var
decl_stmt|,
name|var_type
decl_stmt|,
name|cref
decl_stmt|;
name|loop_entry_label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|loop_exit_label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
comment|/* Create and initialize the index variable.  */
name|var_type
operator|=
name|TREE_TYPE
argument_list|(
name|upper
argument_list|)
expr_stmt|;
name|var
operator|=
name|create_tmp_var
argument_list|(
name|var_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|var_type
argument_list|,
name|var
argument_list|,
name|lower
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* Add the loop entry label.  */
name|append_to_statement_list
argument_list|(
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|loop_entry_label
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* Build the reference.  */
name|cref
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|array_elt_type
argument_list|,
name|unshare_expr
argument_list|(
name|object
argument_list|)
argument_list|,
name|var
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
comment|/* If we are a constructor, just call gimplify_init_ctor_eval to do      the store.  Otherwise just assign value to the reference.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
comment|/* NB we might have to call ourself recursively through        gimplify_init_ctor_eval if the value is a constructor.  */
name|gimplify_init_ctor_eval
argument_list|(
name|cref
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|value
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|cleared
argument_list|)
expr_stmt|;
else|else
name|append_to_statement_list
argument_list|(
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|cref
argument_list|)
argument_list|,
name|cref
argument_list|,
name|value
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* We exit the loop when the index var is equal to the upper bound.  */
name|gimplify_and_add
argument_list|(
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build2
argument_list|(
name|EQ_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|var
argument_list|,
name|upper
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|loop_exit_label
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* Otherwise, increment the index var...  */
name|append_to_statement_list
argument_list|(
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|var_type
argument_list|,
name|var
argument_list|,
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|var_type
argument_list|,
name|var
argument_list|,
name|fold_convert
argument_list|(
name|var_type
argument_list|,
name|integer_one_node
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* ...and jump back to the loop entry.  */
name|append_to_statement_list
argument_list|(
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|loop_entry_label
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* Add the loop exit label.  */
name|append_to_statement_list
argument_list|(
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|loop_exit_label
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if FDECL is accessing a field that is zero sized.  */
end_comment

begin_function
specifier|static
name|bool
name|zero_sized_field_decl
parameter_list|(
name|tree
name|fdecl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|fdecl
argument_list|)
operator|==
name|FIELD_DECL
operator|&&
name|DECL_SIZE
argument_list|(
name|fdecl
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|DECL_SIZE
argument_list|(
name|fdecl
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Return true if TYPE is zero sized.  */
end_comment

begin_function
specifier|static
name|bool
name|zero_sized_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|&&
name|integer_zerop
argument_list|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_init_constructor.  Generate individual    MODIFY_EXPRs for a CONSTRUCTOR.  OBJECT is the LHS against which the    assignments should happen.  ELTS is the CONSTRUCTOR_ELTS of the    CONSTRUCTOR.  CLEARED is true if the entire LHS object has been    zeroed first.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|gimplify_init_ctor_eval
argument_list|(
name|tree
name|object
argument_list|,
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|elts
argument_list|,
name|tree
operator|*
name|pre_p
argument_list|,
name|bool
name|cleared
argument_list|)
block|{
name|tree
name|array_elt_type
init|=
name|NULL
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|ix
decl_stmt|;
name|tree
name|purpose
decl_stmt|,
name|value
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|array_elt_type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|FOR_EACH_CONSTRUCTOR_ELT
argument_list|(
argument|elts
argument_list|,
argument|ix
argument_list|,
argument|purpose
argument_list|,
argument|value
argument_list|)
block|{
name|tree
name|cref
decl_stmt|,
name|init
decl_stmt|;
comment|/* NULL values are created above for gimplification errors.  */
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|cleared
operator|&&
name|initializer_zerop
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
comment|/* ??? Here's to hoping the front end fills in all of the indices, 	 so we don't have to figure out what's missing ourselves.  */
name|gcc_assert
argument_list|(
name|purpose
argument_list|)
expr_stmt|;
comment|/* Skip zero-sized fields, unless value has side-effects.  This can 	 happen with calls to functions returning a zero-sized type, which 	 we shouldn't discard.  As a number of downstream passes don't 	 expect sets of zero-sized fields, we rely on the gimplification of 	 the MODIFY_EXPR we make below to drop the assignment statement.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
name|value
argument_list|)
operator|&&
name|zero_sized_field_decl
argument_list|(
name|purpose
argument_list|)
condition|)
continue|continue;
comment|/* If we have a RANGE_EXPR, we have to build a loop to assign the 	 whole range.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|purpose
argument_list|)
operator|==
name|RANGE_EXPR
condition|)
block|{
name|tree
name|lower
init|=
name|TREE_OPERAND
argument_list|(
name|purpose
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|upper
init|=
name|TREE_OPERAND
argument_list|(
name|purpose
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* If the lower bound is equal to upper, just treat it as if 	     upper was the index.  */
if|if
condition|(
name|simple_cst_equal
argument_list|(
name|lower
argument_list|,
name|upper
argument_list|)
condition|)
name|purpose
operator|=
name|upper
expr_stmt|;
else|else
block|{
name|gimplify_init_ctor_eval_range
argument_list|(
name|object
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|,
name|value
argument_list|,
name|array_elt_type
argument_list|,
name|pre_p
argument_list|,
name|cleared
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|array_elt_type
condition|)
block|{
name|cref
operator|=
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|array_elt_type
argument_list|,
name|unshare_expr
argument_list|(
name|object
argument_list|)
argument_list|,
name|purpose
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|purpose
argument_list|)
operator|==
name|FIELD_DECL
argument_list|)
expr_stmt|;
name|cref
operator|=
name|build3
argument_list|(
name|COMPONENT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|purpose
argument_list|)
argument_list|,
name|unshare_expr
argument_list|(
name|object
argument_list|)
argument_list|,
name|purpose
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONSTRUCTOR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|VECTOR_TYPE
condition|)
name|gimplify_init_ctor_eval
argument_list|(
name|cref
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
name|value
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|cleared
argument_list|)
expr_stmt|;
else|else
block|{
name|init
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|cref
argument_list|)
argument_list|,
name|cref
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|init
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* A subroutine of gimplify_modify_expr.  Break out elements of a    CONSTRUCTOR used as an initializer into separate MODIFY_EXPRs.     Note that we still need to clear any elements that don't have explicit    initializers, so if not all elements are initialized we keep the    original MODIFY_EXPR, we just remove all of the constructor elements.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_init_constructor
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|,
name|bool
name|want_value
parameter_list|)
block|{
name|tree
name|object
decl_stmt|;
name|tree
name|ctor
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|ctor
argument_list|)
decl_stmt|;
name|enum
name|gimplify_status
name|ret
decl_stmt|;
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|elts
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ctor
argument_list|)
operator|!=
name|CONSTRUCTOR
condition|)
return|return
name|GS_UNHANDLED
return|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_lvalue
argument_list|,
name|fb_lvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|GS_ERROR
condition|)
return|return
name|ret
return|;
name|object
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|elts
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|ctor
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
case|case
name|ARRAY_TYPE
case|:
block|{
name|struct
name|gimplify_init_ctor_preeval_data
name|preeval_data
decl_stmt|;
name|HOST_WIDE_INT
name|num_type_elements
decl_stmt|,
name|num_ctor_elements
decl_stmt|;
name|HOST_WIDE_INT
name|num_nonzero_elements
decl_stmt|;
name|bool
name|cleared
decl_stmt|,
name|valid_const_initializer
decl_stmt|;
comment|/* Aggregate types must lower constructors to initialization of 	   individual elements.  The exception is that a CONSTRUCTOR node 	   with no elements indicates zero-initialization of the whole.  */
if|if
condition|(
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|elts
argument_list|)
condition|)
break|break;
comment|/* Fetch information about the constructor to direct later processing. 	   We might want to make static versions of it in various cases, and 	   can only do so if it known to be a valid constant initializer.  */
name|valid_const_initializer
operator|=
name|categorize_ctor_elements
argument_list|(
name|ctor
argument_list|,
operator|&
name|num_nonzero_elements
argument_list|,
operator|&
name|num_ctor_elements
argument_list|,
operator|&
name|cleared
argument_list|)
expr_stmt|;
comment|/* If a const aggregate variable is being initialized, then it 	   should never be a lose to promote the variable to be static.  */
if|if
condition|(
name|valid_const_initializer
operator|&&
name|num_nonzero_elements
operator|>
literal|1
operator|&&
name|TREE_READONLY
argument_list|(
name|object
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|object
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|object
argument_list|)
operator|=
name|ctor
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|object
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_NAME
argument_list|(
name|object
argument_list|)
condition|)
name|DECL_NAME
argument_list|(
name|object
argument_list|)
operator|=
name|create_tmp_var_name
argument_list|(
literal|"C"
argument_list|)
expr_stmt|;
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|object
argument_list|)
argument_list|,
name|force_labels_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* ??? C++ doesn't automatically append a .<number> to the 	       assembler name, and even when it does, it looks a FE private 	       data structures to figure out what that number should be, 	       which are not set for this variable.  I suppose this is 	       important for local statics for inline functions, which aren't 	       "local" in the object file sense.  So in order to get a unique 	       TU-local symbol, we must invoke the lhd version now.  */
name|lhd_set_decl_assembler_name
argument_list|(
name|object
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|NULL_TREE
expr_stmt|;
break|break;
block|}
comment|/* If there are "lots" of initialized elements, even discounting 	   those that are not address constants (and thus *must* be 	   computed at runtime), then partition the constructor into 	   constant and non-constant parts.  Block copy the constant 	   parts in, then generate code for the non-constant parts.  */
comment|/* TODO.  There's code in cp/typeck.c to do this.  */
name|num_type_elements
operator|=
name|count_type_elements
argument_list|(
name|type
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* If count_type_elements could not determine number of type elements 	   for a constant-sized object, assume clearing is needed. 	   Don't do this for variable-sized objects, as store_constructor 	   will ignore the clearing of variable-sized objects.  */
if|if
condition|(
name|num_type_elements
operator|<
literal|0
operator|&&
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
operator|>=
literal|0
condition|)
name|cleared
operator|=
name|true
expr_stmt|;
comment|/* If there are "lots" of zeros, then block clear the object first.  */
elseif|else
if|if
condition|(
name|num_type_elements
operator|-
name|num_nonzero_elements
operator|>
name|CLEAR_RATIO
operator|&&
name|num_nonzero_elements
operator|<
name|num_type_elements
operator|/
literal|4
condition|)
name|cleared
operator|=
name|true
expr_stmt|;
comment|/* ??? This bit ought not be needed.  For any element not present 	   in the initializer, we should simply set them to zero.  Except 	   we'd need to *find* the elements that are not present, and that 	   requires trickery to avoid quadratic compile-time behavior in 	   large cases or excessive memory use in small cases.  */
elseif|else
if|if
condition|(
name|num_ctor_elements
operator|<
name|num_type_elements
condition|)
name|cleared
operator|=
name|true
expr_stmt|;
comment|/* If there are "lots" of initialized elements, and all of them 	   are valid address constants, then the entire initializer can 	   be dropped to memory, and then memcpy'd out.  Don't do this 	   for sparse arrays, though, as it's more efficient to follow 	   the standard CONSTRUCTOR behavior of memset followed by 	   individual element initialization.  */
if|if
condition|(
name|valid_const_initializer
operator|&&
operator|!
name|cleared
condition|)
block|{
name|HOST_WIDE_INT
name|size
init|=
name|int_size_in_bytes
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
comment|/* ??? We can still get unbounded array types, at least 	       from the C++ front end.  This seems wrong, but attempt 	       to work around it for now.  */
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
literal|0
condition|)
name|TREE_TYPE
argument_list|(
name|ctor
argument_list|)
operator|=
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
comment|/* Find the maximum alignment we can assume for the object.  */
comment|/* ??? Make use of DECL_OFFSET_ALIGN.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|object
argument_list|)
condition|)
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|object
argument_list|)
expr_stmt|;
else|else
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
operator|!
name|can_move_by_pieces
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
condition|)
block|{
name|tree
name|new
init|=
name|create_tmp_var_raw
argument_list|(
name|type
argument_list|,
literal|"C"
argument_list|)
decl_stmt|;
name|gimple_add_tmp_var
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|new
argument_list|)
operator|=
name|ctor
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|DECL_ALIGN
argument_list|(
name|new
argument_list|)
condition|)
block|{
name|DECL_ALIGN
argument_list|(
name|new
argument_list|)
operator|=
name|align
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|new
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|walk_tree
argument_list|(
operator|&
name|DECL_INITIAL
argument_list|(
name|new
argument_list|)
argument_list|,
name|force_labels_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
operator|=
name|new
expr_stmt|;
comment|/* This is no longer an assignment of a CONSTRUCTOR, but 		   we still may have processing to do on the LHS.  So 		   pretend we didn't do anything here to let that happen.  */
return|return
name|GS_UNHANDLED
return|;
block|}
block|}
comment|/* If there are nonzero elements, pre-evaluate to capture elements 	   overlapping with the lhs into temporaries.  We must do this before 	   clearing to fetch the values before they are zeroed-out.  */
if|if
condition|(
name|num_nonzero_elements
operator|>
literal|0
condition|)
block|{
name|preeval_data
operator|.
name|lhs_base_decl
operator|=
name|get_base_address
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_P
argument_list|(
name|preeval_data
operator|.
name|lhs_base_decl
argument_list|)
condition|)
name|preeval_data
operator|.
name|lhs_base_decl
operator|=
name|NULL
expr_stmt|;
name|preeval_data
operator|.
name|lhs_alias_set
operator|=
name|get_alias_set
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|gimplify_init_ctor_preeval
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
operator|&
name|preeval_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cleared
condition|)
block|{
comment|/* Zap the CONSTRUCTOR element list, which simplifies this case. 	       Note that we still have to gimplify, in order to handle the 	       case of variable sized types.  Avoid shared tree structures.  */
name|CONSTRUCTOR_ELTS
argument_list|(
name|ctor
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|object
operator|=
name|unshare_expr
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|gimplify_stmt
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
comment|/* If we have not block cleared the object, or if there are nonzero 	   elements in the constructor, add assignments to the individual 	   scalar fields of the object.  */
if|if
condition|(
operator|!
name|cleared
operator|||
name|num_nonzero_elements
operator|>
literal|0
condition|)
name|gimplify_init_ctor_eval
argument_list|(
name|object
argument_list|,
name|elts
argument_list|,
name|pre_p
argument_list|,
name|cleared
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|NULL_TREE
expr_stmt|;
block|}
break|break;
case|case
name|COMPLEX_TYPE
case|:
block|{
name|tree
name|r
decl_stmt|,
name|i
decl_stmt|;
comment|/* Extract the real and imaginary parts out of the ctor.  */
name|gcc_assert
argument_list|(
name|VEC_length
argument_list|(
name|constructor_elt
argument_list|,
name|elts
argument_list|)
operator|==
literal|2
argument_list|)
expr_stmt|;
name|r
operator|=
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|elts
argument_list|,
literal|0
argument_list|)
operator|->
name|value
expr_stmt|;
name|i
operator|=
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|elts
argument_list|,
literal|1
argument_list|)
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
operator|||
name|i
operator|==
name|NULL
condition|)
block|{
name|tree
name|zero
init|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|integer_zero_node
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|r
operator|=
name|zero
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
condition|)
name|i
operator|=
name|zero
expr_stmt|;
block|}
comment|/* Complex types have either COMPLEX_CST or COMPLEX_EXPR to 	   represent creation of a complex value.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|r
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|ctor
operator|=
name|build_complex
argument_list|(
name|type
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
operator|=
name|ctor
expr_stmt|;
block|}
else|else
block|{
name|ctor
operator|=
name|build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|type
argument_list|,
name|r
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
operator|=
name|ctor
expr_stmt|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|rhs_predicate_for
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|VECTOR_TYPE
case|:
block|{
name|unsigned
name|HOST_WIDE_INT
name|ix
decl_stmt|;
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
comment|/* Go ahead and simplify constant constructors to VECTOR_CST.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|ctor
argument_list|)
condition|)
block|{
name|bool
name|constant_p
init|=
name|true
decl_stmt|;
name|tree
name|value
decl_stmt|;
comment|/* Even when ctor is constant, it might contain non-*_CST 	      elements (e.g. { 1.0/0.0 - 1.0/0.0, 0.0 }) and those don't 	      belong into VECTOR_CST nodes.  */
name|FOR_EACH_CONSTRUCTOR_VALUE
argument_list|(
argument|elts
argument_list|,
argument|ix
argument_list|,
argument|value
argument_list|)
if|if
condition|(
operator|!
name|CONSTANT_CLASS_P
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|constant_p
operator|=
name|false
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|constant_p
condition|)
block|{
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
operator|=
name|build_vector_from_ctor
argument_list|(
name|type
argument_list|,
name|elts
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Don't reduce a TREE_CONSTANT vector ctor even if we can't 	       make a VECTOR_CST.  It won't do anything for us, and it'll 	       prevent us from representing it as a single constant.  */
break|break;
block|}
comment|/* Vector types use CONSTRUCTOR all the way through gimple 	  compilation as a general initializer.  */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|elts
argument_list|,
name|ix
argument_list|,
name|ce
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
name|enum
name|gimplify_status
name|tret
decl_stmt|;
name|tret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|ce
operator|->
name|value
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tret
operator|==
name|GS_ERROR
condition|)
name|ret
operator|=
name|GS_ERROR
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* So how did we get a CONSTRUCTOR for a scalar type?  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|GS_ERROR
condition|)
return|return
name|GS_ERROR
return|;
elseif|else
if|if
condition|(
name|want_value
condition|)
block|{
name|append_to_statement_list
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|object
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
else|else
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer value OP0, return a simplified version of an    indirection through OP0, or NULL_TREE if no simplification is    possible.  This may only be applied to a rhs of an expression.    Note that the resulting type may be different from the type pointed    to in the sense that it is still compatible from the langhooks    point of view. */
end_comment

begin_function
specifier|static
name|tree
name|fold_indirect_ref_rhs
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|sub
init|=
name|t
decl_stmt|;
name|tree
name|subtype
decl_stmt|;
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
name|sub
argument_list|)
expr_stmt|;
name|subtype
operator|=
name|TREE_TYPE
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|subtype
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|sub
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
block|{
name|tree
name|op
init|=
name|TREE_OPERAND
argument_list|(
name|sub
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|optype
init|=
name|TREE_TYPE
argument_list|(
name|op
argument_list|)
decl_stmt|;
comment|/* *&p => p */
if|if
condition|(
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|type
argument_list|,
name|optype
argument_list|)
condition|)
return|return
name|op
return|;
comment|/* *(foo *)&fooarray => fooarray[0] */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|optype
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|optype
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type_domain
init|=
name|TYPE_DOMAIN
argument_list|(
name|optype
argument_list|)
decl_stmt|;
name|tree
name|min_val
init|=
name|size_zero_node
decl_stmt|;
if|if
condition|(
name|type_domain
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|type_domain
argument_list|)
condition|)
name|min_val
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type_domain
argument_list|)
expr_stmt|;
return|return
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|op
argument_list|,
name|min_val
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
block|}
comment|/* *(foo *)fooarrptr => (*fooarrptr)[0] */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|subtype
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|type
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|subtype
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|type_domain
decl_stmt|;
name|tree
name|min_val
init|=
name|size_zero_node
decl_stmt|;
name|tree
name|osub
init|=
name|sub
decl_stmt|;
name|sub
operator|=
name|fold_indirect_ref_rhs
argument_list|(
name|sub
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sub
condition|)
name|sub
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|subtype
argument_list|)
argument_list|,
name|osub
argument_list|)
expr_stmt|;
name|type_domain
operator|=
name|TYPE_DOMAIN
argument_list|(
name|TREE_TYPE
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_domain
operator|&&
name|TYPE_MIN_VALUE
argument_list|(
name|type_domain
argument_list|)
condition|)
name|min_val
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type_domain
argument_list|)
expr_stmt|;
return|return
name|build4
argument_list|(
name|ARRAY_REF
argument_list|,
name|type
argument_list|,
name|sub
argument_list|,
name|min_val
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Subroutine of gimplify_modify_expr to do simplifications of MODIFY_EXPRs    based on the code of the RHS.  We loop for as long as something changes.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_modify_expr_rhs
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|from_p
parameter_list|,
name|tree
modifier|*
name|to_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|,
name|bool
name|want_value
parameter_list|)
block|{
name|enum
name|gimplify_status
name|ret
init|=
name|GS_OK
decl_stmt|;
while|while
condition|(
name|ret
operator|!=
name|GS_UNHANDLED
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|from_p
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
block|{
comment|/* If we have code like   	        *(const A*)(A*)&x  	     where the type of "x" is a (possibly cv-qualified variant 	     of "A"), treat the entire expression as identical to "x". 	     This kind of code arises in C++ when an object is bound 	     to a const reference, and if "x" is a TARGET_EXPR we want 	     to take advantage of the optimization below.  */
name|tree
name|t
init|=
name|fold_indirect_ref_rhs
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|from_p
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
block|{
operator|*
name|from_p
operator|=
name|t
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|GS_UNHANDLED
expr_stmt|;
break|break;
block|}
case|case
name|TARGET_EXPR
case|:
block|{
comment|/* If we are initializing something from a TARGET_EXPR, strip the 	     TARGET_EXPR and initialize it directly, if possible.  This can't 	     be done if the initializer is void, since that implies that the 	     temporary is set in some non-trivial way.  	     ??? What about code that pulls out the temp and uses it 	     elsewhere? I think that such code never uses the TARGET_EXPR as 	     an initializer.  If I'm wrong, we'll die because the temp won't 	     have any RTL.  In that case, I guess we'll need to replace 	     references somehow.  */
name|tree
name|init
init|=
name|TARGET_EXPR_INITIAL
argument_list|(
operator|*
name|from_p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|from_p
operator|=
name|init
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|GS_UNHANDLED
expr_stmt|;
block|}
break|break;
case|case
name|COMPOUND_EXPR
case|:
comment|/* Remove any COMPOUND_EXPR in the RHS so the following cases will be 	   caught.  */
name|gimplify_compound_expr
argument_list|(
name|from_p
argument_list|,
name|pre_p
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
comment|/* If we're initializing from a CONSTRUCTOR, break this into 	   individual MODIFY_EXPRs.  */
return|return
name|gimplify_init_constructor
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|want_value
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* If we're assigning to a non-register type, push the assignment 	   down into the branches.  This is mandatory for ADDRESSABLE types, 	   since we cannot generate temporaries for such, but it saves a 	   copy in other cases as well.  */
if|if
condition|(
operator|!
name|is_gimple_reg_type
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|from_p
argument_list|)
argument_list|)
condition|)
block|{
comment|/* This code should mirror the code in gimplify_cond_expr. */
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
decl_stmt|;
name|tree
name|cond
init|=
operator|*
name|from_p
decl_stmt|;
name|tree
name|result
init|=
operator|*
name|to_p
decl_stmt|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|result
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_min_lval
argument_list|,
name|fb_lvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GS_ERROR
condition|)
name|ret
operator|=
name|GS_OK
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
operator|=
name|build2
argument_list|(
name|code
argument_list|,
name|void_type_node
argument_list|,
name|result
argument_list|,
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|2
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|2
argument_list|)
operator|=
name|build2
argument_list|(
name|code
argument_list|,
name|void_type_node
argument_list|,
name|unshare_expr
argument_list|(
name|result
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|cond
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|recalculate_side_effects
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_value
condition|)
block|{
name|gimplify_and_add
argument_list|(
name|cond
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|unshare_expr
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|expr_p
operator|=
name|cond
expr_stmt|;
return|return
name|ret
return|;
block|}
else|else
name|ret
operator|=
name|GS_UNHANDLED
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
comment|/* For calls that return in memory, give *to_p as the CALL_EXPR's 	   return slot so that we don't generate a temporary.  */
if|if
condition|(
operator|!
name|CALL_EXPR_RETURN_SLOT_OPT
argument_list|(
operator|*
name|from_p
argument_list|)
operator|&&
name|aggregate_value_p
argument_list|(
operator|*
name|from_p
argument_list|,
operator|*
name|from_p
argument_list|)
condition|)
block|{
name|bool
name|use_target
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|rhs_predicate_for
argument_list|(
operator|*
name|to_p
argument_list|)
operator|)
operator|(
operator|*
name|from_p
operator|)
condition|)
comment|/* If we need a temporary, *to_p isn't accurate.  */
name|use_target
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|to_p
argument_list|)
operator|==
name|RESULT_DECL
operator|&&
name|DECL_NAME
argument_list|(
operator|*
name|to_p
argument_list|)
operator|==
name|NULL_TREE
operator|&&
name|needs_to_live_in_memory
argument_list|(
operator|*
name|to_p
argument_list|)
condition|)
comment|/* It's OK to use the return slot directly unless it's an NRV. */
name|use_target
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|is_gimple_reg_type
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|to_p
argument_list|)
argument_list|)
operator|||
operator|(
name|DECL_P
argument_list|(
operator|*
name|to_p
argument_list|)
operator|&&
name|DECL_REGISTER
argument_list|(
operator|*
name|to_p
argument_list|)
operator|)
condition|)
comment|/* Don't force regs into memory.  */
name|use_target
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|to_p
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_GIMPLE_FORMAL_TEMP_P
argument_list|(
operator|*
name|to_p
argument_list|)
condition|)
comment|/* Don't use the original target if it's a formal temp; we 		 don't want to take their addresses.  */
name|use_target
operator|=
name|false
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|INIT_EXPR
condition|)
comment|/* It's OK to use the target directly if it's being 		 initialized. */
name|use_target
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_gimple_non_addressable
argument_list|(
operator|*
name|to_p
argument_list|)
condition|)
comment|/* Don't use the original target if it's already addressable; 		 if its address escapes, and the called function uses the 		 NRV optimization, a conforming program could see *to_p 		 change before the called function returns; see c++/19317. 		 When optimizing, the return_slot pass marks more functions 		 as safe after we have escape info.  */
name|use_target
operator|=
name|false
expr_stmt|;
else|else
name|use_target
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|use_target
condition|)
block|{
name|CALL_EXPR_RETURN_SLOT_OPT
argument_list|(
operator|*
name|from_p
argument_list|)
operator|=
literal|1
expr_stmt|;
name|lang_hooks
operator|.
name|mark_addressable
argument_list|(
operator|*
name|to_p
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|GS_UNHANDLED
expr_stmt|;
break|break;
comment|/* If we're initializing from a container, push the initialization 	   inside it.  */
case|case
name|CLEANUP_POINT_EXPR
case|:
case|case
name|BIND_EXPR
case|:
case|case
name|STATEMENT_LIST
case|:
block|{
name|tree
name|wrap
init|=
operator|*
name|from_p
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
name|to_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_min_lval
argument_list|,
name|fb_lvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GS_ERROR
condition|)
name|ret
operator|=
name|GS_OK
expr_stmt|;
name|t
operator|=
name|voidify_wrapper_expr
argument_list|(
name|wrap
argument_list|,
operator|*
name|expr_p
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|t
operator|==
operator|*
name|expr_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_value
condition|)
block|{
name|gimplify_and_add
argument_list|(
name|wrap
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|unshare_expr
argument_list|(
operator|*
name|to_p
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|expr_p
operator|=
name|wrap
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
default|default:
name|ret
operator|=
name|GS_UNHANDLED
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Promote partial stores to COMPLEX variables to total stores.  *EXPR_P is    a MODIFY_EXPR with a lhs of a REAL/IMAGPART_EXPR of a variable with    DECL_COMPLEX_GIMPLE_REG_P set.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_modify_expr_complex_part
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|bool
name|want_value
parameter_list|)
block|{
name|enum
name|tree_code
name|code
decl_stmt|,
name|ocode
decl_stmt|;
name|tree
name|lhs
decl_stmt|,
name|rhs
decl_stmt|,
name|new_rhs
decl_stmt|,
name|other
decl_stmt|,
name|realpart
decl_stmt|,
name|imagpart
decl_stmt|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|lhs
argument_list|)
expr_stmt|;
name|lhs
operator|=
name|TREE_OPERAND
argument_list|(
name|lhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ocode
operator|=
name|code
operator|==
name|REALPART_EXPR
condition|?
name|IMAGPART_EXPR
else|:
name|REALPART_EXPR
expr_stmt|;
name|other
operator|=
name|build1
argument_list|(
name|ocode
argument_list|,
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|,
name|lhs
argument_list|)
expr_stmt|;
name|other
operator|=
name|get_formal_tmp_var
argument_list|(
name|other
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|realpart
operator|=
name|code
operator|==
name|REALPART_EXPR
condition|?
name|rhs
else|:
name|other
expr_stmt|;
name|imagpart
operator|=
name|code
operator|==
name|REALPART_EXPR
condition|?
name|other
else|:
name|rhs
expr_stmt|;
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|realpart
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|imagpart
argument_list|)
condition|)
name|new_rhs
operator|=
name|build_complex
argument_list|(
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|realpart
argument_list|,
name|imagpart
argument_list|)
expr_stmt|;
else|else
name|new_rhs
operator|=
name|build2
argument_list|(
name|COMPLEX_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|lhs
argument_list|)
argument_list|,
name|realpart
argument_list|,
name|imagpart
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
operator|=
name|lhs
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
operator|=
name|new_rhs
expr_stmt|;
if|if
condition|(
name|want_value
condition|)
block|{
name|append_to_statement_list
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|rhs
expr_stmt|;
block|}
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* Gimplify the MODIFY_EXPR node pointed to by EXPR_P.        modify_expr 	      : varname '=' rhs 	      | '*' ID '=' rhs      PRE_P points to the list where side effects that must happen before 	*EXPR_P should be stored.      POST_P points to the list where side effects that must happen after 	*EXPR_P should be stored.      WANT_VALUE is nonzero iff we want to use the value of this expression 	in another expression.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_modify_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|,
name|bool
name|want_value
parameter_list|)
block|{
name|tree
modifier|*
name|from_p
init|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
modifier|*
name|to_p
init|=
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|gimplify_status
name|ret
init|=
name|GS_UNHANDLED
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|MODIFY_EXPR
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|INIT_EXPR
argument_list|)
expr_stmt|;
comment|/* For zero sized types only gimplify the left hand side and right hand side      as statements and throw away the assignment.  */
if|if
condition|(
name|zero_sized_type
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|from_p
argument_list|)
argument_list|)
condition|)
block|{
name|gimplify_stmt
argument_list|(
name|from_p
argument_list|)
expr_stmt|;
name|gimplify_stmt
argument_list|(
name|to_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
operator|*
name|from_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
operator|*
name|to_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
comment|/* See if any simplifications can be done based on what the RHS is.  */
name|ret
operator|=
name|gimplify_modify_expr_rhs
argument_list|(
name|expr_p
argument_list|,
name|from_p
argument_list|,
name|to_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|want_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GS_UNHANDLED
condition|)
return|return
name|ret
return|;
comment|/* If the value being copied is of variable width, compute the length      of the copy into a WITH_SIZE_EXPR.   Note that we need to do this      before gimplifying any of the operands so that we can resolve any      PLACEHOLDER_EXPRs in the size.  Also note that the RTL expander uses      the size of the expression to be copied, not of the destination, so      that is what we must here.  */
name|maybe_with_size_expr
argument_list|(
name|from_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
name|to_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_lvalue
argument_list|,
name|fb_lvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|GS_ERROR
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
name|from_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|rhs_predicate_for
argument_list|(
operator|*
name|to_p
argument_list|)
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|GS_ERROR
condition|)
return|return
name|ret
return|;
comment|/* Now see if the above changed *from_p to something we handle specially.  */
name|ret
operator|=
name|gimplify_modify_expr_rhs
argument_list|(
name|expr_p
argument_list|,
name|from_p
argument_list|,
name|to_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|want_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GS_UNHANDLED
condition|)
return|return
name|ret
return|;
comment|/* If we've got a variable sized assignment between two lvalues (i.e. does      not involve a call), then we can make things a bit more straightforward      by converting the assignment to memcpy or memset.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|from_p
argument_list|)
operator|==
name|WITH_SIZE_EXPR
condition|)
block|{
name|tree
name|from
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|from_p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|size
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|from_p
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|from
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
return|return
name|gimplify_modify_expr_to_memset
argument_list|(
name|expr_p
argument_list|,
name|size
argument_list|,
name|want_value
argument_list|)
return|;
if|if
condition|(
name|is_gimple_addressable
argument_list|(
name|from
argument_list|)
condition|)
block|{
operator|*
name|from_p
operator|=
name|from
expr_stmt|;
return|return
name|gimplify_modify_expr_to_memcpy
argument_list|(
name|expr_p
argument_list|,
name|size
argument_list|,
name|want_value
argument_list|)
return|;
block|}
block|}
comment|/* Transform partial stores to non-addressable complex variables into      total stores.  This allows us to use real instead of virtual operands      for these variables, which improves optimization.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|to_p
argument_list|)
operator|==
name|REALPART_EXPR
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|to_p
argument_list|)
operator|==
name|IMAGPART_EXPR
operator|)
operator|&&
name|is_gimple_reg
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|to_p
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|gimplify_modify_expr_complex_part
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|want_value
argument_list|)
return|;
if|if
condition|(
name|gimplify_ctxp
operator|->
name|into_ssa
operator|&&
name|is_gimple_reg
argument_list|(
operator|*
name|to_p
argument_list|)
condition|)
block|{
comment|/* If we've somehow already got an SSA_NAME on the LHS, then 	 we're probably modified it twice.  Not good.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|to_p
argument_list|)
operator|!=
name|SSA_NAME
argument_list|)
expr_stmt|;
operator|*
name|to_p
operator|=
name|make_ssa_name
argument_list|(
operator|*
name|to_p
argument_list|,
operator|*
name|expr_p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|want_value
condition|)
block|{
name|append_to_statement_list
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
operator|*
name|to_p
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/*  Gimplify a comparison between two variable-sized objects.  Do this     with a call to BUILT_IN_MEMCMP.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_variable_sized_compare
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|args
decl_stmt|,
name|t
decl_stmt|,
name|dest
decl_stmt|;
name|t
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|unshare_expr
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|SUBSTITUTE_PLACEHOLDER_IN_EXPR
argument_list|(
name|t
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_fold_addr_expr
argument_list|(
name|op1
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|dest
operator|=
name|build_fold_addr_expr
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|dest
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|t
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_MEMCMP
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|t
argument_list|,
name|integer_zero_node
argument_list|)
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
end_function

begin_comment
comment|/*  Gimplify a comparison between two aggregate objects of integral scalar     mode as a comparison between the bitwise equivalent scalar values.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_scalar_mode_aggregate_compare
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|tree
name|scalar_type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|op0
operator|=
name|fold_build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|scalar_type
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|fold_build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|scalar_type
argument_list|,
name|op1
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|fold_build2
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
end_function

begin_comment
comment|/*  Gimplify TRUTH_ANDIF_EXPR and TRUTH_ORIF_EXPR expressions.  EXPR_P     points to the expression to gimplify.      Expressions of the form 'a&& b' are gimplified to:  	a&& b ? true : false      gimplify_cond_expr will do the rest.      PRE_P points to the list where side effects that must happen before 	*EXPR_P should be stored.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_boolean_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|)
block|{
comment|/* Preserve the original type of the expression.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
decl_stmt|;
operator|*
name|expr_p
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|type
argument_list|,
operator|*
name|expr_p
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|boolean_true_node
argument_list|)
argument_list|,
name|fold_convert
argument_list|(
name|type
argument_list|,
name|boolean_false_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
end_function

begin_comment
comment|/* Gimplifies an expression sequence.  This function gimplifies each    expression and re-writes the original expression with the last    expression of the sequence in GIMPLE form.     PRE_P points to the list where the side effects for all the        expressions in the sequence will be emitted.     WANT_VALUE is true when the result of the last COMPOUND_EXPR is used.  */
end_comment

begin_comment
comment|/* ??? Should rearrange to share the pre-queue with all the indirect    invocations of gimplify_expr.  Would probably save on creations    of statement_list nodes.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_compound_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|bool
name|want_value
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|expr_p
decl_stmt|;
do|do
block|{
name|tree
modifier|*
name|sub_p
init|=
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|sub_p
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
name|gimplify_compound_expr
argument_list|(
name|sub_p
argument_list|,
name|pre_p
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|gimplify_stmt
argument_list|(
name|sub_p
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
operator|*
name|sub_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPOUND_EXPR
condition|)
do|;
operator|*
name|expr_p
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|want_value
condition|)
return|return
name|GS_OK
return|;
else|else
block|{
name|gimplify_stmt
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Gimplifies a statement list.  These may be created either by an    enlightened front-end, or by shortcut_cond_expr.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_statement_list
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|temp
init|=
name|voidify_wrapper_expr
argument_list|(
operator|*
name|expr_p
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|tree_stmt_iterator
name|i
init|=
name|tsi_start
argument_list|(
operator|*
name|expr_p
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|gimplify_stmt
argument_list|(
name|tsi_stmt_ptr
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|tsi_stmt
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|tsi_delink
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|tsi_link_before
argument_list|(
operator|&
name|i
argument_list|,
name|t
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
name|tsi_delink
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|temp
condition|)
block|{
name|append_to_statement_list
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|temp
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/*  Gimplify a SAVE_EXPR node.  EXPR_P points to the expression to     gimplify.  After gimplification, EXPR_P will point to a new temporary     that holds the original value of the SAVE_EXPR node.      PRE_P points to the list where side effects that must happen before 	*EXPR_P should be stored.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_save_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|enum
name|gimplify_status
name|ret
init|=
name|GS_ALL_DONE
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|SAVE_EXPR
argument_list|)
expr_stmt|;
name|val
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the SAVE_EXPR has not been resolved, then evaluate it once.  */
if|if
condition|(
operator|!
name|SAVE_EXPR_RESOLVED_P
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
block|{
comment|/* The operand may be a void-valued expression such as SAVE_EXPRs 	 generated by the Java frontend for class initialization.  It is 	 being executed only for its side-effects.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_stmt
argument_list|,
name|fb_none
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|val
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|val
operator|=
name|get_initialized_tmp_var
argument_list|(
name|val
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
operator|=
name|val
expr_stmt|;
name|SAVE_EXPR_RESOLVED_P
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|expr_p
operator|=
name|val
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  Re-write the ADDR_EXPR node pointed to by EXPR_P        unary_expr 	      : ... 	      | '&' varname 	      ...      PRE_P points to the list where side effects that must happen before 	*EXPR_P should be stored.      POST_P points to the list where side effects that must happen after 	*EXPR_P should be stored.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_addr_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|enum
name|gimplify_status
name|ret
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
case|case
name|MISALIGNED_INDIRECT_REF
case|:
name|do_indirect_ref
label|:
comment|/* Check if we are dealing with an expression of the form '&*ptr'. 	 While the front end folds away '&*ptr' into 'ptr', these 	 expressions may be generated internally by the compiler (e.g., 	 builtins like __builtin_va_end).  */
comment|/* Caution: the silent array decomposition semantics we allow for 	 ADDR_EXPR means we can't always discard the pair.  */
comment|/* Gimplification of the ADDR_EXPR operand may drop 	 cv-qualification conversions, so make sure we add them if 	 needed.  */
block|{
name|tree
name|op00
init|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|t_expr
init|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
decl_stmt|;
name|tree
name|t_op00
init|=
name|TREE_TYPE
argument_list|(
name|op00
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|t_expr
argument_list|,
name|t_op00
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|tree
name|t_op0
init|=
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|POINTER_TYPE_P
argument_list|(
name|t_expr
argument_list|)
operator|&&
name|cpt_same_type
argument_list|(
name|TREE_CODE
argument_list|(
name|t_op0
argument_list|)
operator|==
name|ARRAY_TYPE
condition|?
name|TREE_TYPE
argument_list|(
name|t_op0
argument_list|)
else|:
name|t_op0
argument_list|,
name|TREE_TYPE
argument_list|(
name|t_expr
argument_list|)
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|t_op00
argument_list|)
operator|&&
name|cpt_same_type
argument_list|(
name|t_op0
argument_list|,
name|TREE_TYPE
argument_list|(
name|t_op00
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|op00
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|op00
argument_list|)
expr_stmt|;
block|}
operator|*
name|expr_p
operator|=
name|op00
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
block|}
break|break;
case|case
name|VIEW_CONVERT_EXPR
case|:
comment|/* Take the address of our operand and then convert it to the type of 	 this ADDR_EXPR.  	 ??? The interactions of VIEW_CONVERT_EXPR and aliasing is not at 	 all clear.  The impact of this transformation is even less clear.  */
comment|/* If the operand is a useless conversion, look through it.  Doing so 	 guarantees that the ADDR_EXPR and its operand will remain of the 	 same type.  */
if|if
condition|(
name|tree_ssa_useless_type_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|fold_convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|build_fold_addr_expr
argument_list|(
name|TREE_OPERAND
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
break|break;
default|default:
comment|/* We use fb_either here because the C frontend sometimes takes 	 the address of a call that returns a struct; see 	 gcc.dg/c99-array-lval-1.c.  The gimplifier will correctly make 	 the implied temporary explicit.  */
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_addressable
argument_list|,
name|fb_either
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|GS_ERROR
condition|)
block|{
name|op0
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For various reasons, the gimplification of the expression 	     may have made a new INDIRECT_REF.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
goto|goto
name|do_indirect_ref
goto|;
comment|/* Make sure TREE_INVARIANT, TREE_CONSTANT, and TREE_SIDE_EFFECTS 	     is set properly.  */
name|recompute_tree_invariant_for_addr_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* Mark the RHS addressable.  */
name|lang_hooks
operator|.
name|mark_addressable
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Gimplify the operands of an ASM_EXPR.  Input operands should be a gimple    value; output operands should be a gimple lvalue.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_asm_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|int
name|noutputs
init|=
name|list_length
argument_list|(
name|ASM_OUTPUTS
argument_list|(
name|expr
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|oconstraints
init|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|noutputs
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tree
name|link
decl_stmt|;
specifier|const
name|char
modifier|*
name|constraint
decl_stmt|;
name|bool
name|allows_mem
decl_stmt|,
name|allows_reg
decl_stmt|,
name|is_inout
decl_stmt|;
name|enum
name|gimplify_status
name|ret
decl_stmt|,
name|tret
decl_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|link
operator|=
name|ASM_OUTPUTS
argument_list|(
name|expr
argument_list|)
init|;
name|link
condition|;
operator|++
name|i
operator|,
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|size_t
name|constraint_len
decl_stmt|;
name|oconstraints
index|[
name|i
index|]
operator|=
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|constraint_len
operator|=
name|strlen
argument_list|(
name|constraint
argument_list|)
expr_stmt|;
if|if
condition|(
name|constraint_len
operator|==
literal|0
condition|)
continue|continue;
name|parse_output_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|,
operator|&
name|is_inout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|allows_mem
condition|)
name|lang_hooks
operator|.
name|mark_addressable
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
name|tret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_inout
condition|?
name|is_gimple_min_lval
else|:
name|is_gimple_lvalue
argument_list|,
name|fb_lvalue
operator||
name|fb_mayfail
argument_list|)
expr_stmt|;
if|if
condition|(
name|tret
operator|==
name|GS_ERROR
condition|)
block|{
name|error
argument_list|(
literal|"invalid lvalue in asm output %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tret
expr_stmt|;
block|}
if|if
condition|(
name|is_inout
condition|)
block|{
comment|/* An input/output operand.  To give the optimizers more 	     flexibility, split it into separate input and output  	     operands.  */
name|tree
name|input
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
comment|/* Turn the in/out constraint into an output constraint.  */
name|char
modifier|*
name|p
init|=
name|xstrdup
argument_list|(
name|constraint
argument_list|)
decl_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|'='
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|build_string
argument_list|(
name|constraint_len
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* And add a matching input constraint.  */
if|if
condition|(
name|allows_reg
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* If there are multiple alternatives in the constraint, 		 handle each of them individually.  Those that allow register 		 will be replaced with operand number, the others will stay 		 unchanged.  */
if|if
condition|(
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
init|=
literal|0
decl_stmt|,
name|buflen
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|char
modifier|*
name|beg
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
for|for
control|(
name|beg
operator|=
name|p
operator|+
literal|1
init|;
condition|;
control|)
block|{
name|end
operator|=
name|strchr
argument_list|(
name|beg
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
name|end
operator|=
name|strchr
argument_list|(
name|beg
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|end
operator|-
name|beg
argument_list|)
operator|<
name|buflen
condition|)
name|len
operator|+=
name|buflen
operator|+
literal|1
expr_stmt|;
else|else
name|len
operator|+=
name|end
operator|-
name|beg
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
name|beg
operator|=
name|end
operator|+
literal|1
expr_stmt|;
else|else
break|break;
block|}
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|beg
operator|=
name|p
operator|+
literal|1
operator|,
name|dst
operator|=
name|str
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|tem
decl_stmt|;
name|bool
name|mem_p
decl_stmt|,
name|reg_p
decl_stmt|,
name|inout_p
decl_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|beg
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|beg
index|[
operator|-
literal|1
index|]
operator|=
literal|'='
expr_stmt|;
name|tem
operator|=
name|beg
operator|-
literal|1
expr_stmt|;
name|parse_output_constraint
argument_list|(
operator|&
name|tem
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|mem_p
argument_list|,
operator|&
name|reg_p
argument_list|,
operator|&
name|inout_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|str
condition|)
operator|*
name|dst
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|reg_p
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|buflen
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end
condition|)
name|len
operator|=
name|end
operator|-
name|beg
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|beg
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|beg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|end
condition|)
name|beg
operator|=
name|end
operator|+
literal|1
expr_stmt|;
else|else
break|break;
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
name|input
operator|=
name|build_string
argument_list|(
name|dst
operator|-
name|str
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|input
operator|=
name|build_string
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|input
operator|=
name|build_string
argument_list|(
name|constraint_len
operator|-
literal|1
argument_list|,
name|constraint
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|input
operator|=
name|build_tree_list
argument_list|(
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|input
argument_list|)
argument_list|,
name|unshare_expr
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_INPUTS
argument_list|(
name|expr
argument_list|)
operator|=
name|chainon
argument_list|(
name|ASM_INPUTS
argument_list|(
name|expr
argument_list|)
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|link
operator|=
name|ASM_INPUTS
argument_list|(
name|expr
argument_list|)
init|;
name|link
condition|;
operator|++
name|i
operator|,
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
name|constraint
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|parse_input_constraint
argument_list|(
operator|&
name|constraint
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|noutputs
argument_list|,
literal|0
argument_list|,
name|oconstraints
argument_list|,
operator|&
name|allows_mem
argument_list|,
operator|&
name|allows_reg
argument_list|)
expr_stmt|;
comment|/* If the operand is a memory input, it should be an lvalue.  */
if|if
condition|(
operator|!
name|allows_reg
operator|&&
name|allows_mem
condition|)
block|{
name|tret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_lvalue
argument_list|,
name|fb_lvalue
operator||
name|fb_mayfail
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|mark_addressable
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tret
operator|==
name|GS_ERROR
condition|)
block|{
name|error
argument_list|(
literal|"memory input %d is not directly addressable"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tret
expr_stmt|;
block|}
block|}
else|else
block|{
name|tret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_asm_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tret
operator|==
name|GS_ERROR
condition|)
name|ret
operator|=
name|tret
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Gimplify a CLEANUP_POINT_EXPR.  Currently this works by adding    WITH_CLEANUP_EXPRs to the prequeue as we encounter cleanups while    gimplifying the body, and converting them to TRY_FINALLY_EXPRs when we    return to this function.     FIXME should we complexify the prequeue handling instead?  Or use flags    for all the cleanups and let the optimizer tighten them up?  The current    code seems pretty fragile; it will break on a cleanup within any    non-conditional nesting.  But any such nesting would be broken, anyway;    we can't write a TRY_FINALLY_EXPR that starts inside a nesting construct    and continues out of it.  We can do that at the RTL level, though, so    having an optimizer to tighten up try/finally regions would be a Good    Thing.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_cleanup_point_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree_stmt_iterator
name|iter
decl_stmt|;
name|tree
name|body
decl_stmt|;
name|tree
name|temp
init|=
name|voidify_wrapper_expr
argument_list|(
operator|*
name|expr_p
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
comment|/* We only care about the number of conditions between the innermost      CLEANUP_POINT_EXPR and the cleanup.  So save and reset the count and      any cleanups collected outside the CLEANUP_POINT_EXPR.  */
name|int
name|old_conds
init|=
name|gimplify_ctxp
operator|->
name|conditions
decl_stmt|;
name|tree
name|old_cleanups
init|=
name|gimplify_ctxp
operator|->
name|conditional_cleanups
decl_stmt|;
name|gimplify_ctxp
operator|->
name|conditions
operator|=
literal|0
expr_stmt|;
name|gimplify_ctxp
operator|->
name|conditional_cleanups
operator|=
name|NULL_TREE
expr_stmt|;
name|body
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|body
argument_list|)
expr_stmt|;
name|gimplify_ctxp
operator|->
name|conditions
operator|=
name|old_conds
expr_stmt|;
name|gimplify_ctxp
operator|->
name|conditional_cleanups
operator|=
name|old_cleanups
expr_stmt|;
for|for
control|(
name|iter
operator|=
name|tsi_start
argument_list|(
name|body
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|iter
argument_list|)
condition|;
control|)
block|{
name|tree
modifier|*
name|wce_p
init|=
name|tsi_stmt_ptr
argument_list|(
name|iter
argument_list|)
decl_stmt|;
name|tree
name|wce
init|=
operator|*
name|wce_p
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|wce
argument_list|)
operator|==
name|WITH_CLEANUP_EXPR
condition|)
block|{
if|if
condition|(
name|tsi_one_before_end_p
argument_list|(
name|iter
argument_list|)
condition|)
block|{
name|tsi_link_before
argument_list|(
operator|&
name|iter
argument_list|,
name|TREE_OPERAND
argument_list|(
name|wce
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TSI_SAME_STMT
argument_list|)
expr_stmt|;
name|tsi_delink
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|tree
name|sl
decl_stmt|,
name|tfe
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|CLEANUP_EH_ONLY
argument_list|(
name|wce
argument_list|)
condition|)
name|code
operator|=
name|TRY_CATCH_EXPR
expr_stmt|;
else|else
name|code
operator|=
name|TRY_FINALLY_EXPR
expr_stmt|;
name|sl
operator|=
name|tsi_split_statement_list_after
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
name|tfe
operator|=
name|build2
argument_list|(
name|code
argument_list|,
name|void_type_node
argument_list|,
name|sl
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|TREE_OPERAND
argument_list|(
name|wce
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|tfe
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|wce_p
operator|=
name|tfe
expr_stmt|;
name|iter
operator|=
name|tsi_start
argument_list|(
name|sl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|tsi_next
argument_list|(
operator|&
name|iter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|temp
condition|)
block|{
operator|*
name|expr_p
operator|=
name|temp
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|body
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
else|else
block|{
operator|*
name|expr_p
operator|=
name|body
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Insert a cleanup marker for gimplify_cleanup_point_expr.  CLEANUP    is the cleanup action required.  */
end_comment

begin_function
specifier|static
name|void
name|gimple_push_cleanup
parameter_list|(
name|tree
name|var
parameter_list|,
name|tree
name|cleanup
parameter_list|,
name|bool
name|eh_only
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|wce
decl_stmt|;
comment|/* Errors can result in improperly nested cleanups.  Which results in      confusion when trying to resolve the WITH_CLEANUP_EXPR.  */
if|if
condition|(
name|errorcount
operator|||
name|sorrycount
condition|)
return|return;
if|if
condition|(
name|gimple_conditional_context
argument_list|()
condition|)
block|{
comment|/* If we're in a conditional context, this is more complex.  We only 	 want to run the cleanup if we actually ran the initialization that 	 necessitates it, but we want to run it after the end of the 	 conditional context.  So we wrap the try/finally around the 	 condition and use a flag to determine whether or not to actually 	 run the destructor.  Thus  	   test ? f(A()) : 0  	 becomes (approximately)  	   flag = 0; 	   try { 	     if (test) { A::A(temp); flag = 1; val = f(temp); } 	     else { val = 0; } 	   } finally { 	     if (flag) A::~A(temp); 	   } 	   val       */
name|tree
name|flag
init|=
name|create_tmp_var
argument_list|(
name|boolean_type_node
argument_list|,
literal|"cleanup"
argument_list|)
decl_stmt|;
name|tree
name|ffalse
init|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|flag
argument_list|,
name|boolean_false_node
argument_list|)
decl_stmt|;
name|tree
name|ftrue
init|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|flag
argument_list|,
name|boolean_true_node
argument_list|)
decl_stmt|;
name|cleanup
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|flag
argument_list|,
name|cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wce
operator|=
name|build1
argument_list|(
name|WITH_CLEANUP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|ffalse
argument_list|,
operator|&
name|gimplify_ctxp
operator|->
name|conditional_cleanups
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|wce
argument_list|,
operator|&
name|gimplify_ctxp
operator|->
name|conditional_cleanups
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|ftrue
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* Because of this manipulation, and the EH edges that jump 	 threading cannot redirect, the temporary (VAR) will appear 	 to be used uninitialized.  Don't warn.  */
name|TREE_NO_WARNING
argument_list|(
name|var
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|wce
operator|=
name|build1
argument_list|(
name|WITH_CLEANUP_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
name|CLEANUP_EH_ONLY
argument_list|(
name|wce
argument_list|)
operator|=
name|eh_only
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|wce
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
name|gimplify_stmt
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|wce
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gimplify a TARGET_EXPR which doesn't appear on the rhs of an INIT_EXPR.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_target_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|)
block|{
name|tree
name|targ
init|=
operator|*
name|expr_p
decl_stmt|;
name|tree
name|temp
init|=
name|TARGET_EXPR_SLOT
argument_list|(
name|targ
argument_list|)
decl_stmt|;
name|tree
name|init
init|=
name|TARGET_EXPR_INITIAL
argument_list|(
name|targ
argument_list|)
decl_stmt|;
name|enum
name|gimplify_status
name|ret
decl_stmt|;
if|if
condition|(
name|init
condition|)
block|{
comment|/* TARGET_EXPR temps aren't part of the enclosing block, so add it 	 to the temps list.  */
name|gimple_add_tmp_var
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* If TARGET_EXPR_INITIAL is void, then the mere evaluation of the 	 expression is supposed to initialize the slot.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
argument_list|)
condition|)
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|init
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_stmt
argument_list|,
name|fb_none
argument_list|)
expr_stmt|;
else|else
block|{
name|init
operator|=
name|build2
argument_list|(
name|INIT_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|temp
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|init
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_stmt
argument_list|,
name|fb_none
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|GS_ERROR
condition|)
block|{
comment|/* PR c++/28266 Make sure this is expanded only once. */
name|TARGET_EXPR_INITIAL
argument_list|(
name|targ
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
return|return
name|GS_ERROR
return|;
block|}
name|append_to_statement_list
argument_list|(
name|init
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* If needed, push the cleanup for the temp.  */
if|if
condition|(
name|TARGET_EXPR_CLEANUP
argument_list|(
name|targ
argument_list|)
condition|)
block|{
name|gimplify_stmt
argument_list|(
operator|&
name|TARGET_EXPR_CLEANUP
argument_list|(
name|targ
argument_list|)
argument_list|)
expr_stmt|;
name|gimple_push_cleanup
argument_list|(
name|temp
argument_list|,
name|TARGET_EXPR_CLEANUP
argument_list|(
name|targ
argument_list|)
argument_list|,
name|CLEANUP_EH_ONLY
argument_list|(
name|targ
argument_list|)
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
comment|/* Only expand this once.  */
name|TREE_OPERAND
argument_list|(
name|targ
argument_list|,
literal|3
argument_list|)
operator|=
name|init
expr_stmt|;
name|TARGET_EXPR_INITIAL
argument_list|(
name|targ
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
block|}
else|else
comment|/* We should have expanded this before.  */
name|gcc_assert
argument_list|(
name|DECL_SEEN_IN_BIND_EXPR_P
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|temp
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
end_function

begin_comment
comment|/* Gimplification of expression trees.  */
end_comment

begin_comment
comment|/* Gimplify an expression which appears at statement context; usually, this    means replacing it with a suitably gimple STATEMENT_LIST.  */
end_comment

begin_function
name|void
name|gimplify_stmt
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|gimplify_expr
argument_list|(
name|stmt_p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|is_gimple_stmt
argument_list|,
name|fb_none
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, but force the result to be a STATEMENT_LIST.  */
end_comment

begin_function
name|void
name|gimplify_to_stmt_list
parameter_list|(
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|gimplify_stmt
argument_list|(
name|stmt_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|stmt_p
condition|)
operator|*
name|stmt_p
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|stmt_p
argument_list|)
operator|!=
name|STATEMENT_LIST
condition|)
block|{
name|tree
name|t
init|=
operator|*
name|stmt_p
decl_stmt|;
operator|*
name|stmt_p
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|t
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add FIRSTPRIVATE entries for DECL in the OpenMP the surrounding parallels    to CTX.  If entries already exist, force them to be some flavor of private.    If there is no enclosing parallel, do nothing.  */
end_comment

begin_function
name|void
name|omp_firstprivatize_variable
parameter_list|(
name|struct
name|gimplify_omp_ctx
modifier|*
name|ctx
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|NULL
operator|||
operator|!
name|DECL_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
do|do
block|{
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|variables
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|value
operator|&
name|GOVD_SHARED
condition|)
name|n
operator|->
name|value
operator|=
name|GOVD_FIRSTPRIVATE
operator||
operator|(
name|n
operator|->
name|value
operator|&
name|GOVD_SEEN
operator|)
expr_stmt|;
else|else
return|return;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|is_parallel
condition|)
name|omp_add_variable
argument_list|(
name|ctx
argument_list|,
name|decl
argument_list|,
name|GOVD_FIRSTPRIVATE
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|ctx
operator|->
name|outer_context
expr_stmt|;
block|}
do|while
condition|(
name|ctx
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Similarly for each of the type sizes of TYPE.  */
end_comment

begin_function
specifier|static
name|void
name|omp_firstprivatize_type_sizes
parameter_list|(
name|struct
name|gimplify_omp_ctx
modifier|*
name|ctx
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointer_set_insert
argument_list|(
name|ctx
operator|->
name|privatized_types
argument_list|,
name|type
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|REAL_TYPE
case|:
name|omp_firstprivatize_variable
argument_list|(
name|ctx
argument_list|,
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|omp_firstprivatize_variable
argument_list|(
name|ctx
argument_list|,
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
name|omp_firstprivatize_type_sizes
argument_list|(
name|ctx
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|omp_firstprivatize_type_sizes
argument_list|(
name|ctx
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
block|{
name|tree
name|field
decl_stmt|;
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|omp_firstprivatize_variable
argument_list|(
name|ctx
argument_list|,
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|omp_firstprivatize_type_sizes
argument_list|(
name|ctx
argument_list|,
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
name|omp_firstprivatize_type_sizes
argument_list|(
name|ctx
argument_list|,
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|omp_firstprivatize_variable
argument_list|(
name|ctx
argument_list|,
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|omp_firstprivatize_variable
argument_list|(
name|ctx
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|types
operator|.
name|omp_firstprivatize_type_sizes
argument_list|(
name|ctx
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add an entry for DECL in the OpenMP context CTX with FLAGS.  */
end_comment

begin_function
specifier|static
name|void
name|omp_add_variable
parameter_list|(
name|struct
name|gimplify_omp_ctx
modifier|*
name|ctx
parameter_list|,
name|tree
name|decl
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|unsigned
name|int
name|nflags
decl_stmt|;
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* Never elide decls whose type has TREE_ADDRESSABLE set.  This means      there are constructors involved somewhere.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|flags
operator||=
name|GOVD_SEEN
expr_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|variables
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
comment|/* We shouldn't be re-adding the decl with the same data 	 sharing class.  */
name|gcc_assert
argument_list|(
operator|(
name|n
operator|->
name|value
operator|&
name|GOVD_DATA_SHARE_CLASS
operator|&
name|flags
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* The only combination of data sharing classes we should see is 	 FIRSTPRIVATE and LASTPRIVATE.  */
name|nflags
operator|=
name|n
operator|->
name|value
operator||
name|flags
expr_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|nflags
operator|&
name|GOVD_DATA_SHARE_CLASS
operator|)
operator|==
operator|(
name|GOVD_FIRSTPRIVATE
operator||
name|GOVD_LASTPRIVATE
operator|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|value
operator|=
name|nflags
expr_stmt|;
return|return;
block|}
comment|/* When adding a variable-sized variable, we have to handle all sorts      of additional bits of data: the pointer replacement variable, and       the parameters of the type.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* Add the pointer replacement variable as PRIVATE if the variable 	 replacement is private, else FIRSTPRIVATE since we'll need the 	 address of the original variable either for SHARED, or for the 	 copy into or out of the context.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|GOVD_LOCAL
operator|)
condition|)
block|{
name|nflags
operator|=
name|flags
operator|&
name|GOVD_PRIVATE
condition|?
name|GOVD_PRIVATE
else|:
name|GOVD_FIRSTPRIVATE
expr_stmt|;
name|nflags
operator||=
name|flags
operator|&
name|GOVD_SEEN
expr_stmt|;
name|t
operator|=
name|DECL_VALUE_EXPR
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INDIRECT_REF
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|omp_add_variable
argument_list|(
name|ctx
argument_list|,
name|t
argument_list|,
name|nflags
argument_list|)
expr_stmt|;
block|}
comment|/* Add all of the variable and type parameters (which should have 	 been gimplified to a formal temporary) as FIRSTPRIVATE.  */
name|omp_firstprivatize_variable
argument_list|(
name|ctx
argument_list|,
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|omp_firstprivatize_variable
argument_list|(
name|ctx
argument_list|,
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|omp_firstprivatize_type_sizes
argument_list|(
name|ctx
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The variable-sized variable itself is never SHARED, only some form 	 of PRIVATE.  The sharing would take place via the pointer variable 	 which we remapped above.  */
if|if
condition|(
name|flags
operator|&
name|GOVD_SHARED
condition|)
name|flags
operator|=
name|GOVD_PRIVATE
operator||
name|GOVD_DEBUG_PRIVATE
operator||
operator|(
name|flags
operator|&
operator|(
name|GOVD_SEEN
operator||
name|GOVD_EXPLICIT
operator|)
operator|)
expr_stmt|;
comment|/* We're going to make use of the TYPE_SIZE_UNIT at least in the  	 alloca statement we generate for the variable, so make sure it 	 is available.  This isn't automatically needed for the SHARED 	 case, since we won't be allocating local storage then. 	 For local variables TYPE_SIZE_UNIT might not be gimplified yet, 	 in this case omp_notice_variable will be called later 	 on when it is gimplified.  */
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|GOVD_LOCAL
operator|)
condition|)
name|omp_notice_variable
argument_list|(
name|ctx
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_privatize_by_reference
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|(
name|flags
operator|&
name|GOVD_LOCAL
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|omp_firstprivatize_type_sizes
argument_list|(
name|ctx
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Similar to the direct variable sized case above, we'll need the 	 size of references being privatized.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|GOVD_SHARED
operator|)
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|omp_notice_variable
argument_list|(
name|ctx
argument_list|,
name|t
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
name|splay_tree_insert
argument_list|(
name|ctx
operator|->
name|variables
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the fact that DECL was used within the OpenMP context CTX.    IN_CODE is true when real code uses DECL, and false when we should    merely emit default(none) errors.  Return true if DECL is going to    be remapped and thus DECL shouldn't be gimplified into its    DECL_VALUE_EXPR (if any).  */
end_comment

begin_function
specifier|static
name|bool
name|omp_notice_variable
parameter_list|(
name|struct
name|gimplify_omp_ctx
modifier|*
name|ctx
parameter_list|,
name|tree
name|decl
parameter_list|,
name|bool
name|in_code
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|unsigned
name|flags
init|=
name|in_code
condition|?
name|GOVD_SEEN
else|:
literal|0
decl_stmt|;
name|bool
name|ret
init|=
name|false
decl_stmt|,
name|shared
decl_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
return|return
name|false
return|;
comment|/* Threadprivate variables are predetermined.  */
if|if
condition|(
name|is_global_var
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_THREAD_LOCAL_P
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
name|DECL_HAS_VALUE_EXPR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
name|get_base_address
argument_list|(
name|DECL_VALUE_EXPR
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|&&
name|DECL_P
argument_list|(
name|value
argument_list|)
operator|&&
name|DECL_THREAD_LOCAL_P
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|false
return|;
block|}
block|}
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|variables
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|enum
name|omp_clause_default_kind
name|default_kind
decl_stmt|,
name|kind
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|is_parallel
condition|)
goto|goto
name|do_outer
goto|;
comment|/* ??? Some compiler-generated variables (like SAVE_EXPRs) could be 	 remapped firstprivate instead of shared.  To some extent this is 	 addressed in omp_firstprivatize_type_sizes, but not effectively.  */
name|default_kind
operator|=
name|ctx
operator|->
name|default_kind
expr_stmt|;
name|kind
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_predetermined_sharing
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|OMP_CLAUSE_DEFAULT_UNSPECIFIED
condition|)
name|default_kind
operator|=
name|kind
expr_stmt|;
switch|switch
condition|(
name|default_kind
condition|)
block|{
case|case
name|OMP_CLAUSE_DEFAULT_NONE
case|:
name|error
argument_list|(
literal|"%qs not specified in enclosing parallel"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Henclosing parallel"
argument_list|,
operator|&
name|ctx
operator|->
name|location
argument_list|)
expr_stmt|;
comment|/* FALLTHRU */
case|case
name|OMP_CLAUSE_DEFAULT_SHARED
case|:
name|flags
operator||=
name|GOVD_SHARED
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_DEFAULT_PRIVATE
case|:
name|flags
operator||=
name|GOVD_PRIVATE
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|omp_add_variable
argument_list|(
name|ctx
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|shared
operator|=
operator|(
name|flags
operator|&
name|GOVD_SHARED
operator|)
operator|!=
literal|0
expr_stmt|;
name|ret
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_disregard_value_expr
argument_list|(
name|decl
argument_list|,
name|shared
argument_list|)
expr_stmt|;
goto|goto
name|do_outer
goto|;
block|}
name|shared
operator|=
operator|(
operator|(
name|flags
operator||
name|n
operator|->
name|value
operator|)
operator|&
name|GOVD_SHARED
operator|)
operator|!=
literal|0
expr_stmt|;
name|ret
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_disregard_value_expr
argument_list|(
name|decl
argument_list|,
name|shared
argument_list|)
expr_stmt|;
comment|/* If nothing changed, there's nothing left to do.  */
if|if
condition|(
operator|(
name|n
operator|->
name|value
operator|&
name|flags
operator|)
operator|==
name|flags
condition|)
return|return
name|ret
return|;
name|flags
operator||=
name|n
operator|->
name|value
expr_stmt|;
name|n
operator|->
name|value
operator|=
name|flags
expr_stmt|;
name|do_outer
label|:
comment|/* If the variable is private in the current context, then we don't      need to propagate anything to an outer context.  */
if|if
condition|(
name|flags
operator|&
name|GOVD_PRIVATE
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|ctx
operator|->
name|outer_context
operator|&&
name|omp_notice_variable
argument_list|(
name|ctx
operator|->
name|outer_context
argument_list|,
name|decl
argument_list|,
name|in_code
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Verify that DECL is private within CTX.  If there's specific information    to the contrary in the innermost scope, generate an error.  */
end_comment

begin_function
specifier|static
name|bool
name|omp_is_private
parameter_list|(
name|struct
name|gimplify_omp_ctx
modifier|*
name|ctx
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|variables
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|value
operator|&
name|GOVD_SHARED
condition|)
block|{
if|if
condition|(
name|ctx
operator|==
name|gimplify_omp_ctxp
condition|)
block|{
name|error
argument_list|(
literal|"iteration variable %qs should be private"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|value
operator|=
name|GOVD_PRIVATE
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
return|return
name|false
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|n
operator|->
name|value
operator|&
name|GOVD_EXPLICIT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ctx
operator|==
name|gimplify_omp_ctxp
operator|||
operator|(
name|ctx
operator|->
name|is_combined_parallel
operator|&&
name|gimplify_omp_ctxp
operator|->
name|outer_context
operator|==
name|ctx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|->
name|value
operator|&
name|GOVD_FIRSTPRIVATE
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"iteration variable %qs should not be firstprivate"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|n
operator|->
name|value
operator|&
name|GOVD_REDUCTION
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"iteration variable %qs should not be reduction"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|true
return|;
block|}
if|if
condition|(
name|ctx
operator|->
name|is_parallel
condition|)
return|return
name|false
return|;
elseif|else
if|if
condition|(
name|ctx
operator|->
name|outer_context
condition|)
return|return
name|omp_is_private
argument_list|(
name|ctx
operator|->
name|outer_context
argument_list|,
name|decl
argument_list|)
return|;
else|else
return|return
operator|!
name|is_global_var
argument_list|(
name|decl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return true if DECL is private within a parallel region    that binds to the current construct's context or in parallel    region's REDUCTION clause.  */
end_comment

begin_function
specifier|static
name|bool
name|omp_check_private
parameter_list|(
name|struct
name|gimplify_omp_ctx
modifier|*
name|ctx
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
do|do
block|{
name|ctx
operator|=
name|ctx
operator|->
name|outer_context
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|!
operator|(
name|is_global_var
argument_list|(
name|decl
argument_list|)
comment|/* References might be private, but might be shared too.  */
operator|||
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_privatize_by_reference
argument_list|(
name|decl
argument_list|)
operator|)
return|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|variables
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
return|return
operator|(
name|n
operator|->
name|value
operator|&
name|GOVD_SHARED
operator|)
operator|==
literal|0
return|;
block|}
do|while
condition|(
operator|!
name|ctx
operator|->
name|is_parallel
condition|)
do|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Scan the OpenMP clauses in *LIST_P, installing mappings into a new    and previous omp contexts.  */
end_comment

begin_function
specifier|static
name|void
name|gimplify_scan_omp_clauses
parameter_list|(
name|tree
modifier|*
name|list_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|bool
name|in_parallel
parameter_list|,
name|bool
name|in_combined_parallel
parameter_list|)
block|{
name|struct
name|gimplify_omp_ctx
modifier|*
name|ctx
decl_stmt|,
modifier|*
name|outer_ctx
decl_stmt|;
name|tree
name|c
decl_stmt|;
name|ctx
operator|=
name|new_omp_context
argument_list|(
name|in_parallel
argument_list|,
name|in_combined_parallel
argument_list|)
expr_stmt|;
name|outer_ctx
operator|=
name|ctx
operator|->
name|outer_context
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|list_p
operator|)
operator|!=
name|NULL
condition|)
block|{
name|enum
name|gimplify_status
name|gs
decl_stmt|;
name|bool
name|remove
init|=
name|false
decl_stmt|;
name|bool
name|notice_outer
init|=
name|true
decl_stmt|;
specifier|const
name|char
modifier|*
name|check_non_private
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
name|tree
name|decl
decl_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_PRIVATE
case|:
name|flags
operator|=
name|GOVD_PRIVATE
operator||
name|GOVD_EXPLICIT
expr_stmt|;
name|notice_outer
operator|=
name|false
expr_stmt|;
goto|goto
name|do_add
goto|;
case|case
name|OMP_CLAUSE_SHARED
case|:
name|flags
operator|=
name|GOVD_SHARED
operator||
name|GOVD_EXPLICIT
expr_stmt|;
goto|goto
name|do_add
goto|;
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
name|flags
operator|=
name|GOVD_FIRSTPRIVATE
operator||
name|GOVD_EXPLICIT
expr_stmt|;
name|check_non_private
operator|=
literal|"firstprivate"
expr_stmt|;
goto|goto
name|do_add
goto|;
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
name|flags
operator|=
name|GOVD_LASTPRIVATE
operator||
name|GOVD_SEEN
operator||
name|GOVD_EXPLICIT
expr_stmt|;
name|check_non_private
operator|=
literal|"lastprivate"
expr_stmt|;
goto|goto
name|do_add
goto|;
case|case
name|OMP_CLAUSE_REDUCTION
case|:
name|flags
operator|=
name|GOVD_REDUCTION
operator||
name|GOVD_SEEN
operator||
name|GOVD_EXPLICIT
expr_stmt|;
name|check_non_private
operator|=
literal|"reduction"
expr_stmt|;
goto|goto
name|do_add
goto|;
name|do_add
label|:
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|remove
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|omp_add_variable
argument_list|(
name|ctx
argument_list|,
name|decl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|OMP_CLAUSE_REDUCTION
operator|&&
name|OMP_CLAUSE_REDUCTION_PLACEHOLDER
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|omp_add_variable
argument_list|(
name|ctx
argument_list|,
name|OMP_CLAUSE_REDUCTION_PLACEHOLDER
argument_list|(
name|c
argument_list|)
argument_list|,
name|GOVD_LOCAL
operator||
name|GOVD_SEEN
argument_list|)
expr_stmt|;
name|gimplify_omp_ctxp
operator|=
name|ctx
expr_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|gimplify_stmt
argument_list|(
operator|&
name|OMP_CLAUSE_REDUCTION_INIT
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|OMP_CLAUSE_REDUCTION_INIT
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|gimplify_stmt
argument_list|(
operator|&
name|OMP_CLAUSE_REDUCTION_MERGE
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|OMP_CLAUSE_REDUCTION_MERGE
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_omp_ctxp
operator|=
name|outer_ctx
expr_stmt|;
block|}
if|if
condition|(
name|notice_outer
condition|)
goto|goto
name|do_notice
goto|;
break|break;
case|case
name|OMP_CLAUSE_COPYIN
case|:
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|decl
operator|==
name|error_mark_node
operator|||
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|remove
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|do_notice
label|:
if|if
condition|(
name|outer_ctx
condition|)
name|omp_notice_variable
argument_list|(
name|outer_ctx
argument_list|,
name|decl
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_non_private
operator|&&
operator|!
name|in_parallel
operator|&&
name|omp_check_private
argument_list|(
name|ctx
argument_list|,
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s variable %qs is private in outer context"
argument_list|,
name|check_non_private
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|remove
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|OMP_CLAUSE_IF
case|:
name|OMP_CLAUSE_OPERAND
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
operator|=
name|gimple_boolify
argument_list|(
name|OMP_CLAUSE_OPERAND
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
name|gs
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|OMP_CLAUSE_OPERAND
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|gs
operator|==
name|GS_ERROR
condition|)
name|remove
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_NOWAIT
case|:
case|case
name|OMP_CLAUSE_ORDERED
case|:
break|break;
case|case
name|OMP_CLAUSE_DEFAULT
case|:
name|ctx
operator|->
name|default_kind
operator|=
name|OMP_CLAUSE_DEFAULT_KIND
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|remove
condition|)
operator|*
name|list_p
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|list_p
operator|=
operator|&
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|gimplify_omp_ctxp
operator|=
name|ctx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For all variables that were not actually used within the context,    remove PRIVATE, SHARED, and FIRSTPRIVATE clauses.  */
end_comment

begin_function
specifier|static
name|int
name|gimplify_adjust_omp_clauses_1
parameter_list|(
name|splay_tree_node
name|n
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
modifier|*
name|list_p
init|=
operator|(
name|tree
operator|*
operator|)
name|data
decl_stmt|;
name|tree
name|decl
init|=
operator|(
name|tree
operator|)
name|n
operator|->
name|key
decl_stmt|;
name|unsigned
name|flags
init|=
name|n
operator|->
name|value
decl_stmt|;
name|enum
name|omp_clause_code
name|code
decl_stmt|;
name|tree
name|clause
decl_stmt|;
name|bool
name|private_debug
decl_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|GOVD_EXPLICIT
operator||
name|GOVD_LOCAL
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|GOVD_SEEN
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flags
operator|&
name|GOVD_DEBUG_PRIVATE
condition|)
block|{
name|gcc_assert
argument_list|(
operator|(
name|flags
operator|&
name|GOVD_DATA_SHARE_CLASS
operator|)
operator|==
name|GOVD_PRIVATE
argument_list|)
expr_stmt|;
name|private_debug
operator|=
name|true
expr_stmt|;
block|}
else|else
name|private_debug
operator|=
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_private_debug_clause
argument_list|(
name|decl
argument_list|,
operator|!
operator|!
operator|(
name|flags
operator|&
name|GOVD_SHARED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|private_debug
condition|)
name|code
operator|=
name|OMP_CLAUSE_PRIVATE
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|GOVD_SHARED
condition|)
block|{
if|if
condition|(
name|is_global_var
argument_list|(
name|decl
argument_list|)
condition|)
return|return
literal|0
return|;
name|code
operator|=
name|OMP_CLAUSE_SHARED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|GOVD_PRIVATE
condition|)
name|code
operator|=
name|OMP_CLAUSE_PRIVATE
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|GOVD_FIRSTPRIVATE
condition|)
name|code
operator|=
name|OMP_CLAUSE_FIRSTPRIVATE
expr_stmt|;
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|clause
operator|=
name|build_omp_clause
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_DECL
argument_list|(
name|clause
argument_list|)
operator|=
name|decl
expr_stmt|;
name|OMP_CLAUSE_CHAIN
argument_list|(
name|clause
argument_list|)
operator|=
operator|*
name|list_p
expr_stmt|;
if|if
condition|(
name|private_debug
condition|)
name|OMP_CLAUSE_PRIVATE_DEBUG
argument_list|(
name|clause
argument_list|)
operator|=
literal|1
expr_stmt|;
operator|*
name|list_p
operator|=
name|clause
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gimplify_adjust_omp_clauses
parameter_list|(
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
name|struct
name|gimplify_omp_ctx
modifier|*
name|ctx
init|=
name|gimplify_omp_ctxp
decl_stmt|;
name|tree
name|c
decl_stmt|,
name|decl
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|list_p
operator|)
operator|!=
name|NULL
condition|)
block|{
name|splay_tree_node
name|n
decl_stmt|;
name|bool
name|remove
init|=
name|false
decl_stmt|;
switch|switch
condition|(
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|OMP_CLAUSE_PRIVATE
case|:
case|case
name|OMP_CLAUSE_SHARED
case|:
case|case
name|OMP_CLAUSE_FIRSTPRIVATE
case|:
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|variables
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
name|remove
operator|=
operator|!
operator|(
name|n
operator|->
name|value
operator|&
name|GOVD_SEEN
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|remove
condition|)
block|{
name|bool
name|shared
init|=
name|OMP_CLAUSE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|OMP_CLAUSE_SHARED
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|->
name|value
operator|&
name|GOVD_DEBUG_PRIVATE
operator|)
operator|||
name|lang_hooks
operator|.
name|decls
operator|.
name|omp_private_debug_clause
argument_list|(
name|decl
argument_list|,
name|shared
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|(
name|n
operator|->
name|value
operator|&
name|GOVD_DEBUG_PRIVATE
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|n
operator|->
name|value
operator|&
name|GOVD_DATA_SHARE_CLASS
operator|)
operator|==
name|GOVD_PRIVATE
operator|)
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_SET_CODE
argument_list|(
name|c
argument_list|,
name|OMP_CLAUSE_PRIVATE
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_PRIVATE_DEBUG
argument_list|(
name|c
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
break|break;
case|case
name|OMP_CLAUSE_LASTPRIVATE
case|:
comment|/* Make sure OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE is set to 	     accurately reflect the presence of a FIRSTPRIVATE clause.  */
name|decl
operator|=
name|OMP_CLAUSE_DECL
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|ctx
operator|->
name|variables
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|decl
argument_list|)
expr_stmt|;
name|OMP_CLAUSE_LASTPRIVATE_FIRSTPRIVATE
argument_list|(
name|c
argument_list|)
operator|=
operator|(
name|n
operator|->
name|value
operator|&
name|GOVD_FIRSTPRIVATE
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|OMP_CLAUSE_REDUCTION
case|:
case|case
name|OMP_CLAUSE_COPYIN
case|:
case|case
name|OMP_CLAUSE_COPYPRIVATE
case|:
case|case
name|OMP_CLAUSE_IF
case|:
case|case
name|OMP_CLAUSE_NUM_THREADS
case|:
case|case
name|OMP_CLAUSE_SCHEDULE
case|:
case|case
name|OMP_CLAUSE_NOWAIT
case|:
case|case
name|OMP_CLAUSE_ORDERED
case|:
case|case
name|OMP_CLAUSE_DEFAULT
case|:
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|remove
condition|)
operator|*
name|list_p
operator|=
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|list_p
operator|=
operator|&
name|OMP_CLAUSE_CHAIN
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* Add in any implicit data sharing.  */
name|splay_tree_foreach
argument_list|(
name|ctx
operator|->
name|variables
argument_list|,
name|gimplify_adjust_omp_clauses_1
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
name|gimplify_omp_ctxp
operator|=
name|ctx
operator|->
name|outer_context
expr_stmt|;
name|delete_omp_context
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Gimplify the contents of an OMP_PARALLEL statement.  This involves    gimplification of the body, as well as scanning the body for used    variables.  We need to do this scan now, because variable-sized    decls will be decomposed during gimplification.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_omp_parallel
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|gimplify_scan_omp_clauses
argument_list|(
operator|&
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|expr
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|true
argument_list|,
name|OMP_PARALLEL_COMBINED
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|gimplify_stmt
argument_list|(
operator|&
name|OMP_PARALLEL_BODY
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|OMP_PARALLEL_BODY
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|pop_gimplify_context
argument_list|(
name|OMP_PARALLEL_BODY
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pop_gimplify_context
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
name|gimplify_adjust_omp_clauses
argument_list|(
operator|&
name|OMP_PARALLEL_CLAUSES
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* Gimplify the gross structure of an OMP_FOR statement.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_omp_for
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|for_stmt
decl_stmt|,
name|decl
decl_stmt|,
name|t
decl_stmt|;
name|enum
name|gimplify_status
name|ret
init|=
literal|0
decl_stmt|;
name|for_stmt
operator|=
operator|*
name|expr_p
expr_stmt|;
name|gimplify_scan_omp_clauses
argument_list|(
operator|&
name|OMP_FOR_CLAUSES
argument_list|(
name|for_stmt
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|t
operator|=
name|OMP_FOR_INIT
argument_list|(
name|for_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|DECL_P
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the iteration variable is private.  */
if|if
condition|(
name|omp_is_private
argument_list|(
name|gimplify_omp_ctxp
argument_list|,
name|decl
argument_list|)
condition|)
name|omp_notice_variable
argument_list|(
name|gimplify_omp_ctxp
argument_list|,
name|decl
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|omp_add_variable
argument_list|(
name|gimplify_omp_ctxp
argument_list|,
name|decl
argument_list|,
name|GOVD_PRIVATE
operator||
name|GOVD_SEEN
argument_list|)
expr_stmt|;
name|ret
operator||=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|OMP_FOR_PRE_BODY
argument_list|(
name|for_stmt
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|t
operator|=
name|OMP_FOR_COND
argument_list|(
name|for_stmt
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|COMPARISON_CLASS_P
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
name|decl
argument_list|)
expr_stmt|;
name|ret
operator||=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|OMP_FOR_PRE_BODY
argument_list|(
name|for_stmt
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|t
operator|=
name|OMP_FOR_INCR
argument_list|(
name|for_stmt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|t
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|build_modify
goto|;
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
name|t
operator|=
name|build_int_cst
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|build_modify
goto|;
name|build_modify
label|:
name|t
operator|=
name|build2
argument_list|(
name|PLUS_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|decl
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|OMP_FOR_INCR
argument_list|(
name|for_stmt
argument_list|)
operator|=
name|t
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
name|gcc_assert
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
name|decl
argument_list|)
expr_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|==
name|decl
condition|)
block|{
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|=
name|decl
expr_stmt|;
break|break;
block|}
case|case
name|MINUS_EXPR
case|:
name|gcc_assert
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
name|decl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|ret
operator||=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|OMP_FOR_PRE_BODY
argument_list|(
name|for_stmt
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|OMP_FOR_BODY
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_adjust_omp_clauses
argument_list|(
operator|&
name|OMP_FOR_CLAUSES
argument_list|(
name|for_stmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
operator|==
name|GS_ALL_DONE
condition|?
name|GS_ALL_DONE
else|:
name|GS_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Gimplify the gross structure of other OpenMP worksharing constructs.    In particular, OMP_SECTIONS and OMP_SINGLE.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_omp_workshare
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|stmt
init|=
operator|*
name|expr_p
decl_stmt|;
name|gimplify_scan_omp_clauses
argument_list|(
operator|&
name|OMP_CLAUSES
argument_list|(
name|stmt
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|OMP_BODY
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_adjust_omp_clauses
argument_list|(
operator|&
name|OMP_CLAUSES
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_omp_atomic.  The front end is supposed to have    stabilized the lhs of the atomic operation as *ADDR.  Return true if     EXPR is this stabilized form.  */
end_comment

begin_function
specifier|static
name|bool
name|goa_lhs_expr_p
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|addr
parameter_list|)
block|{
comment|/* Also include casts to other type variants.  The C front end is fond      of adding these for e.g. volatile variables.  This is like       STRIP_TYPE_NOPS but includes the main variant lookup.  */
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
operator|)
operator|&&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|expr
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INDIRECT_REF
operator|&&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
operator|==
name|addr
condition|)
return|return
name|true
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|expr
operator|==
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_omp_atomic.  Attempt to implement the atomic    operation as a __sync_fetch_and_op builtin.  INDEX is log2 of the    size of the data type, and thus usable to find the index of the builtin    decl.  Returns GS_UNHANDLED if the expression is not of the proper form.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_omp_atomic_fetch_op
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
name|addr
parameter_list|,
name|tree
name|rhs
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|enum
name|built_in_function
name|base
decl_stmt|;
name|tree
name|decl
decl_stmt|,
name|args
decl_stmt|,
name|itype
decl_stmt|;
name|enum
name|insn_code
modifier|*
name|optab
decl_stmt|;
comment|/* Check for one of the supported fetch-op operations.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|base
operator|=
name|BUILT_IN_FETCH_AND_ADD_N
expr_stmt|;
name|optab
operator|=
name|sync_add_optab
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|base
operator|=
name|BUILT_IN_FETCH_AND_SUB_N
expr_stmt|;
name|optab
operator|=
name|sync_add_optab
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|base
operator|=
name|BUILT_IN_FETCH_AND_AND_N
expr_stmt|;
name|optab
operator|=
name|sync_and_optab
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|base
operator|=
name|BUILT_IN_FETCH_AND_OR_N
expr_stmt|;
name|optab
operator|=
name|sync_ior_optab
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|base
operator|=
name|BUILT_IN_FETCH_AND_XOR_N
expr_stmt|;
name|optab
operator|=
name|sync_xor_optab
expr_stmt|;
break|break;
default|default:
return|return
name|GS_UNHANDLED
return|;
block|}
comment|/* Make sure the expression is of the proper form.  */
if|if
condition|(
name|goa_lhs_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
argument_list|,
name|addr
argument_list|)
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|commutative_tree_code
argument_list|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
argument_list|)
operator|&&
name|goa_lhs_expr_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
argument_list|,
name|addr
argument_list|)
condition|)
name|rhs
operator|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
name|GS_UNHANDLED
return|;
name|decl
operator|=
name|built_in_decls
index|[
name|base
operator|+
name|index
operator|+
literal|1
index|]
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|optab
index|[
name|TYPE_MODE
argument_list|(
name|itype
argument_list|)
index|]
operator|==
name|CODE_FOR_nothing
condition|)
return|return
name|GS_UNHANDLED
return|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|rhs
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|addr
argument_list|,
name|args
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|build_function_call_expr
argument_list|(
name|decl
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|GS_OK
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_omp_atomic_pipeline.  Walk *EXPR_P and replace    appearances of *LHS_ADDR with LHS_VAR.  If an expression does not involve    the lhs, evaluate it into a temporary.  Return 1 if the lhs appeared as    a subexpression, 0 if it did not, or -1 if an error was encountered.  */
end_comment

begin_function
specifier|static
name|int
name|goa_stabilize_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
name|lhs_addr
parameter_list|,
name|tree
name|lhs_var
parameter_list|)
block|{
name|tree
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
name|int
name|saw_lhs
decl_stmt|;
if|if
condition|(
name|goa_lhs_expr_p
argument_list|(
name|expr
argument_list|,
name|lhs_addr
argument_list|)
condition|)
block|{
operator|*
name|expr_p
operator|=
name|lhs_var
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|is_gimple_val
argument_list|(
name|expr
argument_list|)
condition|)
return|return
literal|0
return|;
name|saw_lhs
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_binary
case|:
name|saw_lhs
operator||=
name|goa_stabilize_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|lhs_addr
argument_list|,
name|lhs_var
argument_list|)
expr_stmt|;
case|case
name|tcc_unary
case|:
name|saw_lhs
operator||=
name|goa_stabilize_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|lhs_addr
argument_list|,
name|lhs_var
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|saw_lhs
operator|==
literal|0
condition|)
block|{
name|enum
name|gimplify_status
name|gs
decl_stmt|;
name|gs
operator|=
name|gimplify_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|gs
operator|!=
name|GS_ALL_DONE
condition|)
name|saw_lhs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|saw_lhs
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_omp_atomic.  Implement the atomic operation as:  	oldval = *addr;       repeat: 	newval = rhs;	// with oldval replacing *addr in rhs 	oldval = __sync_val_compare_and_swap (addr, oldval, newval); 	if (oldval != newval) 	  goto repeat;     INDEX is log2 of the size of the data type, and thus usable to find the    index of the builtin decl.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_omp_atomic_pipeline
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
name|addr
parameter_list|,
name|tree
name|rhs
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|tree
name|oldval
decl_stmt|,
name|oldival
decl_stmt|,
name|oldival2
decl_stmt|,
name|newval
decl_stmt|,
name|newival
decl_stmt|,
name|label
decl_stmt|;
name|tree
name|type
decl_stmt|,
name|itype
decl_stmt|,
name|cmpxchg
decl_stmt|,
name|args
decl_stmt|,
name|x
decl_stmt|,
name|iaddr
decl_stmt|;
name|cmpxchg
operator|=
name|built_in_decls
index|[
name|BUILT_IN_VAL_COMPARE_AND_SWAP_N
operator|+
name|index
operator|+
literal|1
index|]
expr_stmt|;
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|itype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cmpxchg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync_compare_and_swap
index|[
name|TYPE_MODE
argument_list|(
name|itype
argument_list|)
index|]
operator|==
name|CODE_FOR_nothing
condition|)
return|return
name|GS_UNHANDLED
return|;
name|oldval
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|newval
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Precompute as much of RHS as possible.  In the same walk, replace      occurrences of the lhs value with our temporary.  */
if|if
condition|(
name|goa_stabilize_expr
argument_list|(
operator|&
name|rhs
argument_list|,
name|pre_p
argument_list|,
name|addr
argument_list|,
name|oldval
argument_list|)
operator|<
literal|0
condition|)
return|return
name|GS_ERROR
return|;
name|x
operator|=
name|build_fold_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|oldval
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* For floating-point values, we'll need to view-convert them to integers      so that we can perform the atomic compare and swap.  Simplify the       following code by always setting up the "i"ntegral variables.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|oldival
operator|=
name|oldval
expr_stmt|;
name|newival
operator|=
name|newval
expr_stmt|;
name|iaddr
operator|=
name|addr
expr_stmt|;
block|}
else|else
block|{
name|oldival
operator|=
name|create_tmp_var
argument_list|(
name|itype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|newival
operator|=
name|create_tmp_var
argument_list|(
name|itype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|itype
argument_list|,
name|oldval
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|oldival
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|iaddr
operator|=
name|fold_convert
argument_list|(
name|build_pointer_type
argument_list|(
name|itype
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|oldival2
operator|=
name|create_tmp_var
argument_list|(
name|itype
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
name|x
operator|=
name|build1
argument_list|(
name|LABEL_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|newval
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|newval
operator|!=
name|newival
condition|)
block|{
name|x
operator|=
name|build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|itype
argument_list|,
name|newval
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|newival
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|oldival2
argument_list|,
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|oldival
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|newival
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|fold_convert
argument_list|(
name|itype
argument_list|,
name|oldival
argument_list|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL
argument_list|,
name|iaddr
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|cmpxchg
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldval
operator|==
name|oldival
condition|)
name|x
operator|=
name|fold_convert
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|oldival
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
comment|/* For floating point, be prepared for the loop backedge.  */
if|if
condition|(
name|oldval
operator|!=
name|oldival
condition|)
block|{
name|x
operator|=
name|build1
argument_list|(
name|VIEW_CONVERT_EXPR
argument_list|,
name|type
argument_list|,
name|oldival
argument_list|)
expr_stmt|;
name|x
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|oldval
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
comment|/* Note that we always perform the comparison as an integer, even for      floating point.  This allows the atomic operation to properly       succeed even with NaNs and -0.0.  */
name|x
operator|=
name|build3
argument_list|(
name|COND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|build2
argument_list|(
name|NE_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|oldival
argument_list|,
name|oldival2
argument_list|)
argument_list|,
name|build1
argument_list|(
name|GOTO_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|label
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|x
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|NULL
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_omp_atomic.  Implement the atomic operation as:  	GOMP_atomic_start (); 	*addr = rhs; 	GOMP_atomic_end ();     The result is not globally atomic, but works so long as all parallel    references are within #pragma omp atomic directives.  According to    responses received from omp@openmp.org, appears to be within spec.    Which makes sense, since that's how several other compilers handle    this situation as well.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_omp_atomic_mutex
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
name|addr
parameter_list|,
name|tree
name|rhs
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_ATOMIC_START
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_fold_indirect_ref
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|t
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|t
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
name|t
operator|=
name|built_in_decls
index|[
name|BUILT_IN_GOMP_ATOMIC_END
index|]
expr_stmt|;
name|t
operator|=
name|build_function_call_expr
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|t
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|NULL
expr_stmt|;
return|return
name|GS_ALL_DONE
return|;
block|}
end_function

begin_comment
comment|/* Gimplify an OMP_ATOMIC statement.  */
end_comment

begin_function
specifier|static
name|enum
name|gimplify_status
name|gimplify_omp_atomic
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|)
block|{
name|tree
name|addr
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|addr
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|index
decl_stmt|;
comment|/* Make sure the type is one of the supported sizes.  */
name|index
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|index
operator|=
name|exact_log2
argument_list|(
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<=
literal|4
condition|)
block|{
name|enum
name|gimplify_status
name|gs
decl_stmt|;
name|unsigned
name|int
name|align
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|align
operator|=
name|DECL_ALIGN_UNIT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|align
operator|=
name|DECL_ALIGN_UNIT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|align
operator|=
name|TYPE_ALIGN_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* __sync builtins require strict data alignment.  */
if|if
condition|(
name|exact_log2
argument_list|(
name|align
argument_list|)
operator|>=
name|index
condition|)
block|{
comment|/* When possible, use specialized atomic update functions.  */
if|if
condition|(
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|gs
operator|=
name|gimplify_omp_atomic_fetch_op
argument_list|(
name|expr_p
argument_list|,
name|addr
argument_list|,
name|rhs
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|gs
operator|!=
name|GS_UNHANDLED
condition|)
return|return
name|gs
return|;
block|}
comment|/* If we don't have specialized __sync builtins, try and implement 	     as a compare and swap loop.  */
name|gs
operator|=
name|gimplify_omp_atomic_pipeline
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|addr
argument_list|,
name|rhs
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|gs
operator|!=
name|GS_UNHANDLED
condition|)
return|return
name|gs
return|;
block|}
block|}
comment|/* The ultimate fallback is wrapping the operation in a mutex.  */
return|return
name|gimplify_omp_atomic_mutex
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|addr
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  Gimplifies the expression tree pointed to by EXPR_P.  Return 0 if     gimplification failed.      PRE_P points to the list where side effects that must happen before 	EXPR should be stored.      POST_P points to the list where side effects that must happen after 	EXPR should be stored, or NULL if there is no suitable list.  In 	that case, we copy the result to a temporary, emit the 	post-effects, and then return the temporary.      GIMPLE_TEST_F points to a function that takes a tree T and 	returns nonzero if T is in the GIMPLE form requested by the 	caller.  The GIMPLE predicates are in tree-gimple.c.  	This test is used twice.  Before gimplification, the test is 	invoked to determine whether *EXPR_P is already gimple enough.  If 	that fails, *EXPR_P is gimplified according to its code and 	GIMPLE_TEST_F is called again.  If the test still fails, then a new 	temporary variable is created and assigned the value of the 	gimplified expression.      FALLBACK tells the function what sort of a temporary we want.  If the 1 	bit is set, an rvalue is OK.  If the 2 bit is set, an lvalue is OK. 	If both are set, either is OK, but an lvalue is preferable.      The return value is either GS_ERROR or GS_ALL_DONE, since this function     iterates until solution.  */
end_comment

begin_function
name|enum
name|gimplify_status
name|gimplify_expr
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|pre_p
parameter_list|,
name|tree
modifier|*
name|post_p
parameter_list|,
name|bool
function_decl|(
modifier|*
name|gimple_test_f
function_decl|)
parameter_list|(
name|tree
parameter_list|)
parameter_list|,
name|fallback_t
name|fallback
parameter_list|)
block|{
name|tree
name|tmp
decl_stmt|;
name|tree
name|internal_pre
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|internal_post
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|save_expr
decl_stmt|;
name|int
name|is_statement
init|=
operator|(
name|pre_p
operator|==
name|NULL
operator|)
decl_stmt|;
name|location_t
name|saved_location
decl_stmt|;
name|enum
name|gimplify_status
name|ret
decl_stmt|;
name|save_expr
operator|=
operator|*
name|expr_p
expr_stmt|;
if|if
condition|(
name|save_expr
operator|==
name|NULL_TREE
condition|)
return|return
name|GS_ALL_DONE
return|;
comment|/* We used to check the predicate here and return immediately if it      succeeds.  This is wrong; the design is for gimplification to be      idempotent, and for the predicates to only test for valid forms, not      whether they are fully simplified.  */
comment|/* Set up our internal queues if needed.  */
if|if
condition|(
name|pre_p
operator|==
name|NULL
condition|)
name|pre_p
operator|=
operator|&
name|internal_pre
expr_stmt|;
if|if
condition|(
name|post_p
operator|==
name|NULL
condition|)
name|post_p
operator|=
operator|&
name|internal_post
expr_stmt|;
name|saved_location
operator|=
name|input_location
expr_stmt|;
if|if
condition|(
name|save_expr
operator|!=
name|error_mark_node
operator|&&
name|EXPR_HAS_LOCATION
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
name|input_location
operator|=
name|EXPR_LOCATION
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
comment|/* Loop over the specific gimplifiers until the toplevel node      remains the same.  */
do|do
block|{
comment|/* Strip away as many useless type conversions as possible 	 at the toplevel.  */
name|STRIP_USELESS_TYPE_CONVERSION
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
comment|/* Remember the expr.  */
name|save_expr
operator|=
operator|*
name|expr_p
expr_stmt|;
comment|/* Die, die, die, my darling.  */
if|if
condition|(
name|save_expr
operator|==
name|error_mark_node
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|save_expr
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|save_expr
argument_list|)
operator|==
name|error_mark_node
operator|)
condition|)
block|{
name|ret
operator|=
name|GS_ERROR
expr_stmt|;
break|break;
block|}
comment|/* Do any language-specific gimplification.  */
name|ret
operator|=
name|lang_hooks
operator|.
name|gimplify_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|GS_OK
condition|)
block|{
if|if
condition|(
operator|*
name|expr_p
operator|==
name|NULL_TREE
condition|)
break|break;
if|if
condition|(
operator|*
name|expr_p
operator|!=
name|save_expr
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
name|GS_UNHANDLED
condition|)
break|break;
name|ret
operator|=
name|GS_OK
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
block|{
comment|/* First deal with the special cases.  */
case|case
name|POSTINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|PREDECREMENT_EXPR
case|:
name|ret
operator|=
name|gimplify_self_mod_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|fallback
operator|!=
name|fb_none
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|COMPONENT_REF
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
name|ret
operator|=
name|gimplify_compound_lval
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|fallback
condition|?
name|fallback
else|:
name|fb_rvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|ret
operator|=
name|gimplify_cond_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|fallback
argument_list|)
expr_stmt|;
comment|/* C99 code may assign to an array in a structure value of a 	     conditional expression, and this has undefined behavior 	     only on execution, so create a temporary if an lvalue is 	     required.  */
if|if
condition|(
name|fallback
operator|==
name|fb_lvalue
condition|)
block|{
operator|*
name|expr_p
operator|=
name|get_initialized_tmp_var
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|mark_addressable
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
name|ret
operator|=
name|gimplify_call_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|fallback
operator|!=
name|fb_none
argument_list|)
expr_stmt|;
comment|/* C99 code may assign to an array in a structure returned 	     from a function, and this has undefined behavior only on 	     execution, so create a temporary if an lvalue is 	     required.  */
if|if
condition|(
name|fallback
operator|==
name|fb_lvalue
condition|)
block|{
operator|*
name|expr_p
operator|=
name|get_initialized_tmp_var
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|mark_addressable
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TREE_LIST
case|:
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|COMPOUND_EXPR
case|:
name|ret
operator|=
name|gimplify_compound_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|fallback
operator|!=
name|fb_none
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODIFY_EXPR
case|:
case|case
name|INIT_EXPR
case|:
name|ret
operator|=
name|gimplify_modify_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|fallback
operator|!=
name|fb_none
argument_list|)
expr_stmt|;
comment|/* The distinction between MODIFY_EXPR and INIT_EXPR is no longer 	     useful.  */
if|if
condition|(
operator|*
name|expr_p
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|INIT_EXPR
condition|)
name|TREE_SET_CODE
argument_list|(
operator|*
name|expr_p
argument_list|,
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
name|ret
operator|=
name|gimplify_boolean_expr
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUTH_NOT_EXPR
case|:
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
operator|=
name|gimple_boolify
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|recalculate_side_effects
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
name|ret
operator|=
name|gimplify_addr_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|VA_ARG_EXPR
case|:
name|ret
operator|=
name|gimplify_va_arg_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
if|if
condition|(
name|IS_EMPTY_STMT
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
block|{
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|||
name|fallback
operator|==
name|fb_none
condition|)
block|{
comment|/* Just strip a conversion to void (or in void context) and 		 try again.  */
operator|*
name|expr_p
operator|=
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|ret
operator|=
name|gimplify_conversion
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|GS_ERROR
condition|)
break|break;
if|if
condition|(
operator|*
name|expr_p
operator|!=
name|save_expr
condition|)
break|break;
comment|/* FALLTHRU */
case|case
name|FIX_TRUNC_EXPR
case|:
case|case
name|FIX_CEIL_EXPR
case|:
case|case
name|FIX_FLOOR_EXPR
case|:
case|case
name|FIX_ROUND_EXPR
case|:
comment|/* unary_expr: ... | '(' cast ')' val | ...  */
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|recalculate_side_effects
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|INDIRECT_REF
case|:
operator|*
name|expr_p
operator|=
name|fold_indirect_ref
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|expr_p
operator|!=
name|save_expr
condition|)
break|break;
comment|/* else fall through.  */
case|case
name|ALIGN_INDIRECT_REF
case|:
case|case
name|MISALIGNED_INDIRECT_REF
case|:
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_reg
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|recalculate_side_effects
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
break|break;
comment|/* Constants need not be gimplified.  */
case|case
name|INTEGER_CST
case|:
case|case
name|REAL_CST
case|:
case|case
name|STRING_CST
case|:
case|case
name|COMPLEX_CST
case|:
case|case
name|VECTOR_CST
case|:
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|CONST_DECL
case|:
comment|/* If we require an lvalue, such as for ADDR_EXPR, retain the 	     CONST_DECL node.  Otherwise the decl is replaceable by its 	     value.  */
comment|/* ??? Should be == fb_lvalue, but ADDR_EXPR passes fb_either.  */
if|if
condition|(
name|fallback
operator|&
name|fb_lvalue
condition|)
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
else|else
operator|*
name|expr_p
operator|=
name|DECL_INITIAL
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECL_EXPR
case|:
name|ret
operator|=
name|gimplify_decl_expr
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXC_PTR_EXPR
case|:
comment|/* FIXME make this a decl.  */
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|BIND_EXPR
case|:
name|ret
operator|=
name|gimplify_bind_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOOP_EXPR
case|:
name|ret
operator|=
name|gimplify_loop_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|SWITCH_EXPR
case|:
name|ret
operator|=
name|gimplify_switch_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXIT_EXPR
case|:
name|ret
operator|=
name|gimplify_exit_expr
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|GOTO_EXPR
case|:
comment|/* If the target is not LABEL, then it is a computed jump 	     and the target needs to be gimplified.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|GOTO_DESTINATION
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|!=
name|LABEL_DECL
condition|)
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|GOTO_DESTINATION
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|LABEL_EXPR
case|:
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
name|gcc_assert
argument_list|(
name|decl_function_context
argument_list|(
name|LABEL_EXPR_LABEL
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|==
name|current_function_decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|CASE_LABEL_EXPR
case|:
name|ret
operator|=
name|gimplify_case_label_expr
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_EXPR
case|:
name|ret
operator|=
name|gimplify_return_expr
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
comment|/* Don't reduce this in place; let gimplify_init_constructor work its 	     magic.  Buf if we're just elaborating this for side effects, just 	     gimplify any element that has side-effects.  */
if|if
condition|(
name|fallback
operator|==
name|fb_none
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|ix
decl_stmt|;
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
name|tree
name|temp
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|CONSTRUCTOR_ELTS
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|ix
argument_list|,
name|ce
argument_list|)
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|ce
operator|->
name|value
argument_list|)
condition|)
name|append_to_statement_list
argument_list|(
name|ce
operator|->
name|value
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|temp
expr_stmt|;
name|ret
operator|=
name|GS_OK
expr_stmt|;
block|}
comment|/* C99 code may assign to an array in a constructed 	     structure or union, and this has undefined behavior only 	     on execution, so create a temporary if an lvalue is 	     required.  */
elseif|else
if|if
condition|(
name|fallback
operator|==
name|fb_lvalue
condition|)
block|{
operator|*
name|expr_p
operator|=
name|get_initialized_tmp_var
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|mark_addressable
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
comment|/* The following are special cases that are not handled by the 	     original GIMPLE grammar.  */
comment|/* SAVE_EXPR nodes are converted into a GIMPLE identifier and 	     eliminated.  */
case|case
name|SAVE_EXPR
case|:
name|ret
operator|=
name|gimplify_save_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIT_FIELD_REF
case|:
block|{
name|enum
name|gimplify_status
name|r0
decl_stmt|,
name|r1
decl_stmt|,
name|r2
decl_stmt|;
name|r0
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_lvalue
argument_list|,
name|fb_either
argument_list|)
expr_stmt|;
name|r1
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|r2
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|2
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|recalculate_side_effects
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|r0
argument_list|,
name|MIN
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NON_LVALUE_EXPR
case|:
comment|/* This should have been stripped above.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
case|case
name|ASM_EXPR
case|:
name|ret
operator|=
name|gimplify_asm_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_FINALLY_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|CLEANUP_POINT_EXPR
case|:
name|ret
operator|=
name|gimplify_cleanup_point_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_EXPR
case|:
name|ret
operator|=
name|gimplify_target_expr
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CATCH_EXPR
case|:
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|CATCH_BODY
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|EH_FILTER_EXPR
case|:
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|EH_FILTER_FAILURE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|OBJ_TYPE_REF
case|:
block|{
name|enum
name|gimplify_status
name|r0
decl_stmt|,
name|r1
decl_stmt|;
name|r0
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|OBJ_TYPE_REF_OBJECT
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|r1
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|OBJ_TYPE_REF_EXPR
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|r0
argument_list|,
name|r1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LABEL_DECL
case|:
comment|/* We get here when taking the address of a label.  We mark 	     the label as "forced"; meaning it can never be removed and 	     it is a potential target for any computed goto.  */
name|FORCED_LABEL
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|STATEMENT_LIST
case|:
name|ret
operator|=
name|gimplify_statement_list
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|WITH_SIZE_EXPR
case|:
block|{
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
operator|==
operator|&
name|internal_post
condition|?
name|NULL
else|:
name|post_p
argument_list|,
name|gimple_test_f
argument_list|,
name|fallback
argument_list|)
expr_stmt|;
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_DECL
case|:
case|case
name|PARM_DECL
case|:
name|ret
operator|=
name|gimplify_var_or_parm_decl
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|RESULT_DECL
case|:
comment|/* When within an OpenMP context, notice uses of variables.  */
if|if
condition|(
name|gimplify_omp_ctxp
condition|)
name|omp_notice_variable
argument_list|(
name|gimplify_omp_ctxp
argument_list|,
operator|*
name|expr_p
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|SSA_NAME
case|:
comment|/* Allow callbacks into the gimplifier during optimization.  */
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
case|case
name|OMP_PARALLEL
case|:
name|ret
operator|=
name|gimplify_omp_parallel
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_FOR
case|:
name|ret
operator|=
name|gimplify_omp_for
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_SECTIONS
case|:
case|case
name|OMP_SINGLE
case|:
name|ret
operator|=
name|gimplify_omp_workshare
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_SECTION
case|:
case|case
name|OMP_MASTER
case|:
case|case
name|OMP_ORDERED
case|:
case|case
name|OMP_CRITICAL
case|:
name|gimplify_to_stmt_list
argument_list|(
operator|&
name|OMP_BODY
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_ATOMIC
case|:
name|ret
operator|=
name|gimplify_omp_atomic
argument_list|(
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OMP_RETURN
case|:
case|case
name|OMP_CONTINUE
case|:
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
break|break;
default|default:
switch|switch
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|tcc_comparison
case|:
comment|/* Handle comparison of objects of non scalar mode aggregates 	     	 with a call to memcmp.  It would be nice to only have to do 	     	 this for variable-sized objects, but then we'd have to allow 	     	 the same nest of reference nodes we allow for MODIFY_EXPR and 	     	 that's too complex.  		 Compare scalar mode aggregates as scalar mode values.  Using 		 memcmp for them would be very inefficient at best, and is 		 plain wrong if bitfields are involved.  */
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|AGGREGATE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
goto|goto
name|expr_2
goto|;
elseif|else
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|BLKmode
condition|)
name|ret
operator|=
name|gimplify_scalar_mode_aggregate_compare
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|gimplify_variable_sized_compare
argument_list|(
name|expr_p
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If *EXPR_P does not need to be special-cased, handle it 	       according to its class.  */
case|case
name|tcc_unary
case|:
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|tcc_binary
case|:
name|expr_2
label|:
block|{
name|enum
name|gimplify_status
name|r0
decl_stmt|,
name|r1
decl_stmt|;
name|r0
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|r1
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|ret
operator|=
name|MIN
argument_list|(
name|r0
argument_list|,
name|r1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|tcc_declaration
case|:
case|case
name|tcc_constant
case|:
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
goto|goto
name|dont_recalculate
goto|;
default|default:
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|TRUTH_AND_EXPR
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|TRUTH_OR_EXPR
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|TRUTH_XOR_EXPR
argument_list|)
expr_stmt|;
goto|goto
name|expr_2
goto|;
block|}
name|recalculate_side_effects
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
name|dont_recalculate
label|:
break|break;
block|}
comment|/* If we replaced *expr_p, gimplify again.  */
if|if
condition|(
name|ret
operator|==
name|GS_OK
operator|&&
operator|(
operator|*
name|expr_p
operator|==
name|NULL
operator|||
operator|*
name|expr_p
operator|==
name|save_expr
operator|)
condition|)
name|ret
operator|=
name|GS_ALL_DONE
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|GS_OK
condition|)
do|;
comment|/* If we encountered an error_mark somewhere nested inside, either      stub out the statement or propagate the error back out.  */
if|if
condition|(
name|ret
operator|==
name|GS_ERROR
condition|)
block|{
if|if
condition|(
name|is_statement
condition|)
operator|*
name|expr_p
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* This was only valid as a return value from the langhook, which      we handled.  Make sure it doesn't escape from any other context.  */
name|gcc_assert
argument_list|(
name|ret
operator|!=
name|GS_UNHANDLED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fallback
operator|==
name|fb_none
operator|&&
operator|*
name|expr_p
operator|&&
operator|!
name|is_gimple_stmt
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
block|{
comment|/* We aren't looking for a value, and we don't have a valid 	 statement.  If it doesn't have side-effects, throw it away.  */
if|if
condition|(
operator|!
name|TREE_SIDE_EFFECTS
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
operator|*
name|expr_p
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
block|{
comment|/* This is probably a _REF that contains something nested that 	     has side effects.  Recurse through the operands to find it.  */
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
case|case
name|REALPART_EXPR
case|:
case|case
name|IMAGPART_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|gimple_test_f
argument_list|,
name|fallback
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
case|case
name|ARRAY_RANGE_REF
case|:
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|gimple_test_f
argument_list|,
name|fallback
argument_list|)
expr_stmt|;
name|gimplify_expr
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
operator|*
name|expr_p
argument_list|,
literal|1
argument_list|)
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|gimple_test_f
argument_list|,
name|fallback
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Anything else with side-effects must be converted to 		  a valid statement before we get here.  */
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
operator|*
name|expr_p
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
operator|!=
name|BLKmode
condition|)
block|{
comment|/* Historically, the compiler has treated a bare reference 	     to a non-BLKmode volatile lvalue as forcing a load.  */
name|tree
name|type
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Normally, we do not want to create a temporary for a 	     TREE_ADDRESSABLE type because such a type should not be 	     copied by bitwise-assignment.  However, we make an 	     exception here, as all we are doing here is ensuring that 	     we read the bytes that make up the type.  We use 	     create_tmp_var_raw because create_tmp_var will abort when 	     given a TREE_ADDRESSABLE type.  */
name|tree
name|tmp
init|=
name|create_tmp_var_raw
argument_list|(
name|type
argument_list|,
literal|"vol"
argument_list|)
decl_stmt|;
name|gimple_add_tmp_var
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|type
argument_list|,
name|tmp
argument_list|,
operator|*
name|expr_p
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We can't do anything useful with a volatile reference to 	   an incomplete type, so just throw it away.  Likewise for 	   a BLKmode type, since any implicit inner load should 	   already have been turned into an explicit one by the 	   gimplification process.  */
operator|*
name|expr_p
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If we are gimplifying at the statement level, we're done.  Tack      everything together and replace the original statement with the      gimplified form.  */
if|if
condition|(
name|fallback
operator|==
name|fb_none
operator|||
name|is_statement
condition|)
block|{
if|if
condition|(
name|internal_pre
operator|||
name|internal_post
condition|)
block|{
name|append_to_statement_list
argument_list|(
operator|*
name|expr_p
argument_list|,
operator|&
name|internal_pre
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|internal_post
argument_list|,
operator|&
name|internal_pre
argument_list|)
expr_stmt|;
name|annotate_all_with_locus
argument_list|(
operator|&
name|internal_pre
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|internal_pre
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|*
name|expr_p
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
name|annotate_all_with_locus
argument_list|(
name|expr_p
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
else|else
name|annotate_one_with_locus
argument_list|(
operator|*
name|expr_p
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Otherwise we're gimplifying a subexpression, so the resulting value is      interesting.  */
comment|/* If it's sufficiently simple already, we're done.  Unless we are      handling some post-effects internally; if that's the case, we need to      copy into a temp before adding the post-effects to the tree.  */
if|if
condition|(
operator|!
name|internal_post
operator|&&
call|(
modifier|*
name|gimple_test_f
call|)
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* Otherwise, we need to create a new temporary for the gimplified      expression.  */
comment|/* We can't return an lvalue if we have an internal postqueue.  The      object the lvalue refers to would (probably) be modified by the      postqueue; we need to copy the value out first, which means an      rvalue.  */
if|if
condition|(
operator|(
name|fallback
operator|&
name|fb_lvalue
operator|)
operator|&&
operator|!
name|internal_post
operator|&&
name|is_gimple_addressable
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
block|{
comment|/* An lvalue will do.  Take the address of the expression, store it 	 in a temporary, and replace the expression with an INDIRECT_REF of 	 that temporary.  */
name|tmp
operator|=
name|build_fold_addr_expr
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
name|gimplify_expr
argument_list|(
operator|&
name|tmp
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|,
name|is_gimple_reg
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tmp
argument_list|)
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fallback
operator|&
name|fb_rvalue
operator|)
operator|&&
name|is_gimple_formal_tmp_rhs
argument_list|(
operator|*
name|expr_p
argument_list|)
condition|)
block|{
name|gcc_assert
argument_list|(
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* An rvalue will do.  Assign the gimplified expression into a new 	 temporary TMP and replace the original expression with TMP.  */
if|if
condition|(
name|internal_post
operator|||
operator|(
name|fallback
operator|&
name|fb_lvalue
operator|)
condition|)
comment|/* The postqueue might change the value of the expression between 	   the initialization and use of the temporary, so we can't use a 	   formal temp.  FIXME do we care?  */
operator|*
name|expr_p
operator|=
name|get_initialized_tmp_var
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|,
name|post_p
argument_list|)
expr_stmt|;
else|else
operator|*
name|expr_p
operator|=
name|get_formal_tmp_var
argument_list|(
operator|*
name|expr_p
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|!=
name|SSA_NAME
condition|)
name|DECL_GIMPLE_FORMAL_TEMP_P
argument_list|(
operator|*
name|expr_p
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
if|if
condition|(
operator|!
operator|(
name|fallback
operator|&
name|fb_mayfail
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gimplification failed:\n"
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|stderr
argument_list|,
operator|*
name|expr_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug_tree
argument_list|(
operator|*
name|expr_p
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
literal|"gimplification failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|gcc_assert
argument_list|(
name|fallback
operator|&
name|fb_mayfail
argument_list|)
expr_stmt|;
comment|/* If this is an asm statement, and the user asked for the 	 impossible, don't die.  Fail and let gimplify_asm_expr 	 issue an error.  */
name|ret
operator|=
name|GS_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Make sure the temporary matches our predicate.  */
name|gcc_assert
argument_list|(
call|(
modifier|*
name|gimple_test_f
call|)
argument_list|(
operator|*
name|expr_p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|internal_post
condition|)
block|{
name|annotate_all_with_locus
argument_list|(
operator|&
name|internal_post
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|internal_post
argument_list|,
name|pre_p
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|input_location
operator|=
name|saved_location
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Look through TYPE for variable-sized objects and gimplify each such    size that we find.  Add to LIST_P any statements generated.  */
end_comment

begin_function
name|void
name|gimplify_type_sizes
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
modifier|*
name|list_p
parameter_list|)
block|{
name|tree
name|field
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
name|type
operator|==
name|error_mark_node
condition|)
return|return;
comment|/* We first do the main variant, then copy into any other variants.  */
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Avoid infinite recursion.  */
if|if
condition|(
name|TYPE_SIZES_GIMPLIFIED
argument_list|(
name|type
argument_list|)
condition|)
return|return;
name|TYPE_SIZES_GIMPLIFIED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|BOOLEAN_TYPE
case|:
case|case
name|REAL_TYPE
case|:
name|gimplify_one_sizepos
argument_list|(
operator|&
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
name|gimplify_one_sizepos
argument_list|(
operator|&
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
block|{
name|TYPE_MIN_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY_TYPE
case|:
comment|/* These types may not have declarations, so handle them here.  */
name|gimplify_type_sizes
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
name|gimplify_type_sizes
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
case|case
name|QUAL_UNION_TYPE
case|:
for|for
control|(
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
init|;
name|field
condition|;
name|field
operator|=
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|field
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
name|gimplify_one_sizepos
argument_list|(
operator|&
name|DECL_FIELD_OFFSET
argument_list|(
name|field
argument_list|)
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
name|gimplify_type_sizes
argument_list|(
name|TREE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
comment|/* We used to recurse on the pointed-to type here, which turned out to 	   be incorrect because its definition might refer to variables not 	   yet initialized at this point if a forward declaration is involved.  	   It was actually useful for anonymous pointed-to types to ensure 	   that the sizes evaluation dominates every possible later use of the 	   values.  Restricting to such types here would be safe since there 	   is no possible forward declaration around, but would introduce an 	   undesirable middle-end semantic to anonymity.  We then defer to 	   front-ends the responsibility of ensuring that the sizes are 	   evaluated both early and late enough, e.g. by attaching artificial 	   type declarations to the tree.  */
break|break;
default|default:
break|break;
block|}
name|gimplify_one_sizepos
argument_list|(
operator|&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
name|gimplify_one_sizepos
argument_list|(
operator|&
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|list_p
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
block|{
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_SIZE_UNIT
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_SIZES_GIMPLIFIED
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* A subroutine of gimplify_type_sizes to make sure that *EXPR_P,    a size or position, has had all of its SAVE_EXPRs evaluated.    We add any required statements to STMT_P.  */
end_comment

begin_function
name|void
name|gimplify_one_sizepos
parameter_list|(
name|tree
modifier|*
name|expr_p
parameter_list|,
name|tree
modifier|*
name|stmt_p
parameter_list|)
block|{
name|tree
name|type
decl_stmt|,
name|expr
init|=
operator|*
name|expr_p
decl_stmt|;
comment|/* We don't do anything if the value isn't there, is constant, or contains      A PLACEHOLDER_EXPR.  We also don't want to do anything if it's already      a VAR_DECL.  If it's a VAR_DECL from another function, the gimplifier      will want to replace it with a new variable, but that will cause problems      if this type is from outside the function.  It's OK to have that here.  */
if|if
condition|(
name|expr
operator|==
name|NULL_TREE
operator|||
name|TREE_CONSTANT
argument_list|(
name|expr
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|CONTAINS_PLACEHOLDER_P
argument_list|(
name|expr
argument_list|)
condition|)
return|return;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
operator|*
name|expr_p
operator|=
name|unshare_expr
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|gimplify_expr
argument_list|(
name|expr_p
argument_list|,
name|stmt_p
argument_list|,
name|NULL
argument_list|,
name|is_gimple_val
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|expr
operator|=
operator|*
name|expr_p
expr_stmt|;
comment|/* Verify that we've an exact type match with the original expression.      In particular, we do not wish to drop a "sizetype" in favour of a      type of similar dimensions.  We don't want to pollute the generic      type-stripping code with this knowledge because it doesn't matter      for the bulk of GENERIC/GIMPLE.  It only matters that TYPE_SIZE_UNIT      and friends retain their "sizetype-ness".  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_IS_SIZETYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
name|tmp
decl_stmt|;
operator|*
name|expr_p
operator|=
name|create_tmp_var
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|type
argument_list|,
operator|*
name|expr_p
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|EXPR_HAS_LOCATION
argument_list|(
name|expr
argument_list|)
condition|)
name|SET_EXPR_LOCUS
argument_list|(
name|tmp
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SET_EXPR_LOCATION
argument_list|(
name|tmp
argument_list|,
name|input_location
argument_list|)
expr_stmt|;
name|gimplify_and_add
argument_list|(
name|tmp
argument_list|,
name|stmt_p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
end_ifdef

begin_comment
comment|/* Compare types A and B for a "close enough" match.  */
end_comment

begin_function
specifier|static
name|bool
name|cpt_same_type
parameter_list|(
name|tree
name|a
parameter_list|,
name|tree
name|b
parameter_list|)
block|{
if|if
condition|(
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* ??? The C++ FE decomposes METHOD_TYPES to FUNCTION_TYPES and doesn't      link them together.  This routine is intended to catch type errors      that will affect the optimizers, and the optimizers don't add new      dereferences of function pointers, so ignore it.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|METHOD_TYPE
operator|)
condition|)
return|return
name|true
return|;
comment|/* ??? The C FE pushes type qualifiers after the fact into the type of      the element from the type of the array.  See build_unary_op's handling      of ADDR_EXPR.  This seems wrong -- if we were going to do this, we      should have done it when creating the variable in the first place.      Alternately, why aren't the two array types made variants?  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|a
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|b
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|cpt_same_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
comment|/* And because of those, we have to recurse down through pointers.  */
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|a
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|b
argument_list|)
condition|)
return|return
name|cpt_same_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|a
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|b
argument_list|)
argument_list|)
return|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Check for some cases of the front end missing cast expressions.    The type of a dereference should correspond to the pointer type;    similarly the type of an address should match its object.  */
end_comment

begin_function
specifier|static
name|tree
name|check_pointer_types_r
parameter_list|(
name|tree
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|walk_subtrees
name|ATTRIBUTE_UNUSED
parameter_list|,
name|void
modifier|*
name|data
name|ATTRIBUTE_UNUSED
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|tp
decl_stmt|;
name|tree
name|ptype
decl_stmt|,
name|otype
decl_stmt|,
name|dtype
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INDIRECT_REF
case|:
case|case
name|ARRAY_REF
case|:
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|TREE_TYPE
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|cpt_same_type
argument_list|(
name|otype
argument_list|,
name|dtype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_EXPR
case|:
name|ptype
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|otype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|dtype
operator|=
name|TREE_TYPE
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpt_same_type
argument_list|(
name|otype
argument_list|,
name|dtype
argument_list|)
condition|)
block|{
comment|/*&array is allowed to produce a pointer to the element, rather than 	     a pointer to the array type.  We must allow this in order to 	     properly represent assigning the address of an array in C into 	     pointer to the element type.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|otype
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|ptype
argument_list|)
operator|&&
name|cpt_same_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|,
name|dtype
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
return|return
name|NULL_TREE
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Gimplify the body of statements pointed to by BODY_P.  FNDECL is the    function decl containing BODY.  */
end_comment

begin_function
name|void
name|gimplify_body
parameter_list|(
name|tree
modifier|*
name|body_p
parameter_list|,
name|tree
name|fndecl
parameter_list|,
name|bool
name|do_parms
parameter_list|)
block|{
name|location_t
name|saved_location
init|=
name|input_location
decl_stmt|;
name|tree
name|body
decl_stmt|,
name|parm_stmts
decl_stmt|;
name|timevar_push
argument_list|(
name|TV_TREE_GIMPLIFY
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|gimplify_ctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
comment|/* Unshare most shared trees in the body and in that of any nested functions.      It would seem we don't have to do this for nested functions because      they are supposed to be output and then the outer function gimplified      first, but the g++ front end doesn't always do it that way.  */
name|unshare_body
argument_list|(
name|body_p
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
name|unvisit_body
argument_list|(
name|body_p
argument_list|,
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Make sure input_location isn't set to something wierd.  */
name|input_location
operator|=
name|DECL_SOURCE_LOCATION
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
comment|/* Resolve callee-copies.  This has to be done before processing      the body so that DECL_VALUE_EXPR gets processed correctly.  */
name|parm_stmts
operator|=
name|do_parms
condition|?
name|gimplify_parameters
argument_list|()
else|:
name|NULL
expr_stmt|;
comment|/* Gimplify the function's body.  */
name|gimplify_stmt
argument_list|(
name|body_p
argument_list|)
expr_stmt|;
name|body
operator|=
operator|*
name|body_p
expr_stmt|;
if|if
condition|(
operator|!
name|body
condition|)
name|body
operator|=
name|alloc_stmt_list
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|body
argument_list|)
operator|==
name|STATEMENT_LIST
condition|)
block|{
name|tree
name|t
init|=
name|expr_only
argument_list|(
operator|*
name|body_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
condition|)
name|body
operator|=
name|t
expr_stmt|;
block|}
comment|/* If there isn't an outer BIND_EXPR, add one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|body
argument_list|)
operator|!=
name|BIND_EXPR
condition|)
block|{
name|tree
name|b
init|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
decl_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|b
argument_list|)
operator|=
literal|1
expr_stmt|;
name|append_to_statement_list_force
argument_list|(
name|body
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|b
expr_stmt|;
block|}
comment|/* If we had callee-copies statements, insert them at the beginning      of the function.  */
if|if
condition|(
name|parm_stmts
condition|)
block|{
name|append_to_statement_list_force
argument_list|(
name|BIND_EXPR_BODY
argument_list|(
name|body
argument_list|)
argument_list|,
operator|&
name|parm_stmts
argument_list|)
expr_stmt|;
name|BIND_EXPR_BODY
argument_list|(
name|body
argument_list|)
operator|=
name|parm_stmts
expr_stmt|;
block|}
comment|/* Unshare again, in case gimplification was sloppy.  */
name|unshare_all_trees
argument_list|(
name|body
argument_list|)
expr_stmt|;
operator|*
name|body_p
operator|=
name|body
expr_stmt|;
name|pop_gimplify_context
argument_list|(
name|body
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|gimplify_ctxp
operator|==
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_CHECKING
name|walk_tree
argument_list|(
name|body_p
argument_list|,
name|check_pointer_types_r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|timevar_pop
argument_list|(
name|TV_TREE_GIMPLIFY
argument_list|)
expr_stmt|;
name|input_location
operator|=
name|saved_location
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Entry point to the gimplification pass.  FNDECL is the FUNCTION_DECL    node for the function we want to gimplify.  */
end_comment

begin_function
name|void
name|gimplify_function_tree
parameter_list|(
name|tree
name|fndecl
parameter_list|)
block|{
name|tree
name|oldfn
decl_stmt|,
name|parm
decl_stmt|,
name|ret
decl_stmt|;
name|oldfn
operator|=
name|current_function_decl
expr_stmt|;
name|current_function_decl
operator|=
name|fndecl
expr_stmt|;
name|cfun
operator|=
name|DECL_STRUCT_FUNCTION
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfun
operator|==
name|NULL
condition|)
name|allocate_struct_function
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
comment|/* Preliminarily mark non-addressed complex variables as eligible          for promotion to gimple registers.  We'll transform their uses          as we find them.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|parm
argument_list|)
operator|&&
operator|!
name|needs_to_live_in_memory
argument_list|(
name|parm
argument_list|)
condition|)
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|parm
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|ret
operator|=
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|ret
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
operator|&&
operator|!
name|needs_to_live_in_memory
argument_list|(
name|ret
argument_list|)
condition|)
name|DECL_COMPLEX_GIMPLE_REG_P
argument_list|(
name|ret
argument_list|)
operator|=
literal|1
expr_stmt|;
name|gimplify_body
argument_list|(
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
argument_list|,
name|fndecl
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* If we're instrumenting function entry/exit, then prepend the call to      the entry hook and wrap the whole function in a TRY_FINALLY_EXPR to      catch the exit hook.  */
comment|/* ??? Add some way to ignore exceptions for this TFE.  */
if|if
condition|(
name|flag_instrument_function_entry_exit
operator|&&
operator|!
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
name|tree
name|tf
decl_stmt|,
name|x
decl_stmt|,
name|bind
decl_stmt|;
name|tf
operator|=
name|build2
argument_list|(
name|TRY_FINALLY_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|tf
argument_list|)
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|tf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_PROFILE_FUNC_EXIT
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|TREE_OPERAND
argument_list|(
name|tf
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bind
operator|=
name|build3
argument_list|(
name|BIND_EXPR
argument_list|,
name|void_type_node
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|bind
argument_list|)
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|implicit_built_in_decls
index|[
name|BUILT_IN_PROFILE_FUNC_ENTER
index|]
expr_stmt|;
name|x
operator|=
name|build_function_call_expr
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|x
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|append_to_statement_list
argument_list|(
name|tf
argument_list|,
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|bind
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_SAVED_TREE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|bind
expr_stmt|;
block|}
name|current_function_decl
operator|=
name|oldfn
expr_stmt|;
name|cfun
operator|=
name|oldfn
condition|?
name|DECL_STRUCT_FUNCTION
argument_list|(
name|oldfn
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expands EXPR to list of gimple statements STMTS.  If SIMPLE is true,    force the result to be either ssa_name or an invariant, otherwise    just force it to be a rhs expression.  If VAR is not NULL, make the    base variable of the final destination be VAR if suitable.  */
end_comment

begin_function
name|tree
name|force_gimple_operand
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
modifier|*
name|stmts
parameter_list|,
name|bool
name|simple
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
name|enum
name|gimplify_status
name|ret
decl_stmt|;
name|gimple_predicate
name|gimple_test_f
decl_stmt|;
operator|*
name|stmts
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|is_gimple_val
argument_list|(
name|expr
argument_list|)
condition|)
return|return
name|expr
return|;
name|gimple_test_f
operator|=
name|simple
condition|?
name|is_gimple_val
else|:
name|is_gimple_reg_rhs
expr_stmt|;
name|push_gimplify_context
argument_list|()
expr_stmt|;
name|gimplify_ctxp
operator|->
name|into_ssa
operator|=
name|in_ssa_p
expr_stmt|;
if|if
condition|(
name|var
condition|)
name|expr
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|,
name|var
argument_list|,
name|expr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|gimplify_expr
argument_list|(
operator|&
name|expr
argument_list|,
name|stmts
argument_list|,
name|NULL
argument_list|,
name|gimple_test_f
argument_list|,
name|fb_rvalue
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|ret
operator|!=
name|GS_ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|referenced_vars
condition|)
block|{
for|for
control|(
name|t
operator|=
name|gimplify_ctxp
operator|->
name|temps
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
name|add_referenced_var
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|pop_gimplify_context
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_comment
comment|/* Invokes force_gimple_operand for EXPR with parameters SIMPLE_P and VAR.  If    some statements are produced, emits them before BSI.  */
end_comment

begin_function
name|tree
name|force_gimple_operand_bsi
parameter_list|(
name|block_stmt_iterator
modifier|*
name|bsi
parameter_list|,
name|tree
name|expr
parameter_list|,
name|bool
name|simple_p
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|tree
name|stmts
decl_stmt|;
name|expr
operator|=
name|force_gimple_operand
argument_list|(
name|expr
argument_list|,
operator|&
name|stmts
argument_list|,
name|simple_p
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts
condition|)
name|bsi_insert_before
argument_list|(
name|bsi
argument_list|,
name|stmts
argument_list|,
name|BSI_SAME_STMT
argument_list|)
expr_stmt|;
return|return
name|expr
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-gimplify.h"
end_include

end_unit

