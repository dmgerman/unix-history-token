begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic routines for manipulating PHIs    Copyright (C) 2003, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"basic-block.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_comment
comment|/* Rewriting a function into SSA form can create a huge number of PHIs    many of which may be thrown away shortly after their creation if jumps    were threaded through PHI nodes.     While our garbage collection mechanisms will handle this situation, it    is extremely wasteful to create nodes and throw them away, especially    when the nodes can be reused.     For PR 8361, we can significantly reduce the number of nodes allocated    and thus the total amount of memory allocated by managing PHIs a    little.  This additionally helps reduce the amount of work done by the    garbage collector.  Similar results have been seen on a wider variety    of tests (such as the compiler itself).     Right now we maintain our free list on a per-function basis.  It may    or may not make sense to maintain the free list for the duration of    a compilation unit.     We could also use a zone allocator for these objects since they have    a very well defined lifetime.  If someone wants to experiment with that    this is the place to try it.     PHI nodes have different sizes, so we can't have a single list of all    the PHI nodes as it would be too expensive to walk down that list to    find a PHI of a suitable size.     Instead we have an array of lists of free PHI nodes.  The array is    indexed by the number of PHI alternatives that PHI node can hold.    Except for the last array member, which holds all remaining PHI    nodes.     So to find a free PHI node, we compute its index into the free PHI    node array and see if there are any elements with an exact match.    If so, then we are done.  Otherwise, we test the next larger size    up and continue until we are in the last array element.     We do not actually walk members of the last array element.  While it    might allow us to pick up a few reusable PHI nodes, it could potentially    be very expensive if the program has released a bunch of large PHI nodes,    but keeps asking for even larger PHI nodes.  Experiments have shown that    walking the elements of the last array entry would result in finding less    than .1% additional reusable PHI nodes.     Note that we can never have less than two PHI argument slots.  Thus,    the -2 on all the calculations below.  */
end_comment

begin_define
define|#
directive|define
name|NUM_BUCKETS
value|10
end_define

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(deletable (
literal|""
argument|))
argument_list|)
name|tree
name|free_phinodes
index|[
name|NUM_BUCKETS
operator|-
literal|2
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|free_phinode_count
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ideal_phi_node_len
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resize_phi_node
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_decl_stmt
name|unsigned
name|int
name|phi_nodes_reused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|phi_nodes_created
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialize management of PHIs.  */
end_comment

begin_function
name|void
name|init_phinodes
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_BUCKETS
operator|-
literal|2
condition|;
name|i
operator|++
control|)
name|free_phinodes
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|free_phinode_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finalize management of PHIs.  */
end_comment

begin_function
name|void
name|fini_phinodes
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_BUCKETS
operator|-
literal|2
condition|;
name|i
operator|++
control|)
name|free_phinodes
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|free_phinode_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump some simple statistics regarding the re-use of PHI nodes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
end_ifdef

begin_function
name|void
name|phinodes_print_statistics
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PHI nodes allocated: %u\n"
argument_list|,
name|phi_nodes_created
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PHI nodes reused: %u\n"
argument_list|,
name|phi_nodes_reused
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Allocate a PHI node with at least LEN arguments.  If the free list    happens to contain a PHI node with LEN arguments or more, return    that one.  */
end_comment

begin_function
specifier|static
specifier|inline
name|tree
name|allocate_phi_node
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|int
name|bucket
init|=
name|NUM_BUCKETS
operator|-
literal|2
decl_stmt|;
name|int
name|size
init|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_phi_node
argument_list|)
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|phi_arg_d
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|free_phinode_count
condition|)
for|for
control|(
name|bucket
operator|=
name|len
operator|-
literal|2
init|;
name|bucket
operator|<
name|NUM_BUCKETS
operator|-
literal|2
condition|;
name|bucket
operator|++
control|)
if|if
condition|(
name|free_phinodes
index|[
name|bucket
index|]
condition|)
break|break;
comment|/* If our free list has an element, then use it.  */
if|if
condition|(
name|bucket
operator|<
name|NUM_BUCKETS
operator|-
literal|2
operator|&&
name|PHI_ARG_CAPACITY
argument_list|(
name|free_phinodes
index|[
name|bucket
index|]
argument_list|)
operator|>=
name|len
condition|)
block|{
name|free_phinode_count
operator|--
expr_stmt|;
name|phi
operator|=
name|free_phinodes
index|[
name|bucket
index|]
expr_stmt|;
name|free_phinodes
index|[
name|bucket
index|]
operator|=
name|PHI_CHAIN
argument_list|(
name|free_phinodes
index|[
name|bucket
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|phi_nodes_reused
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|phi
operator|=
name|ggc_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATHER_STATISTICS
name|phi_nodes_created
operator|++
expr_stmt|;
name|tree_node_counts
index|[
operator|(
name|int
operator|)
name|phi_kind
index|]
operator|++
expr_stmt|;
name|tree_node_sizes
index|[
operator|(
name|int
operator|)
name|phi_kind
index|]
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|phi
return|;
block|}
end_function

begin_comment
comment|/* Given LEN, the original number of requested PHI arguments, return    a new, "ideal" length for the PHI node.  The "ideal" length rounds    the total size of the PHI node up to the next power of two bytes.     Rounding up will not result in wasting any memory since the size request    will be rounded up by the GC system anyway.  [ Note this is not entirely    true since the original length might have fit on one of the special    GC pages. ]  By rounding up, we may avoid the need to reallocate the    PHI node later if we increase the number of arguments for the PHI.  */
end_comment

begin_function
specifier|static
name|int
name|ideal_phi_node_len
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|,
name|new_size
decl_stmt|;
name|int
name|log2
decl_stmt|,
name|new_len
decl_stmt|;
comment|/* We do not support allocations of less than two PHI argument slots.  */
if|if
condition|(
name|len
operator|<
literal|2
condition|)
name|len
operator|=
literal|2
expr_stmt|;
comment|/* Compute the number of bytes of the original request.  */
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tree_phi_node
argument_list|)
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|phi_arg_d
argument_list|)
expr_stmt|;
comment|/* Round it up to the next power of two.  */
name|log2
operator|=
name|ceil_log2
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|new_size
operator|=
literal|1
operator|<<
name|log2
expr_stmt|;
comment|/* Now compute and return the number of PHI argument slots given an      ideal size allocation.  */
name|new_len
operator|=
name|len
operator|+
operator|(
name|new_size
operator|-
name|size
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|phi_arg_d
argument_list|)
expr_stmt|;
return|return
name|new_len
return|;
block|}
end_function

begin_comment
comment|/* Return a PHI node with LEN argument slots for variable VAR.  */
end_comment

begin_function
specifier|static
name|tree
name|make_phi_node
parameter_list|(
name|tree
name|var
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|int
name|capacity
decl_stmt|,
name|i
decl_stmt|;
name|capacity
operator|=
name|ideal_phi_node_len
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|phi
operator|=
name|allocate_phi_node
argument_list|(
name|capacity
argument_list|)
expr_stmt|;
comment|/* We need to clear the entire PHI node, including the argument      portion, because we represent a "missing PHI argument" by placing      NULL_TREE in PHI_ARG_DEF.  */
name|memset
argument_list|(
name|phi
argument_list|,
literal|0
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_phi_node
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|phi_arg_d
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|phi_arg_d
argument_list|)
operator|*
name|len
operator|)
argument_list|)
expr_stmt|;
name|TREE_SET_CODE
argument_list|(
name|phi
argument_list|,
name|PHI_NODE
argument_list|)
expr_stmt|;
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
operator|=
name|len
expr_stmt|;
name|PHI_ARG_CAPACITY
argument_list|(
name|phi
argument_list|)
operator|=
name|capacity
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|phi
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|SET_PHI_RESULT
argument_list|(
name|phi
argument_list|,
name|var
argument_list|)
expr_stmt|;
else|else
name|SET_PHI_RESULT
argument_list|(
name|phi
argument_list|,
name|make_ssa_name
argument_list|(
name|var
argument_list|,
name|phi
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|capacity
condition|;
name|i
operator|++
control|)
block|{
name|use_operand_p
name|imm
decl_stmt|;
name|imm
operator|=
operator|&
operator|(
name|PHI_ARG_IMM_USE_NODE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
name|imm
operator|->
name|use
operator|=
operator|&
operator|(
name|PHI_ARG_DEF_TREE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
name|imm
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|imm
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|imm
operator|->
name|stmt
operator|=
name|phi
expr_stmt|;
block|}
return|return
name|phi
return|;
block|}
end_function

begin_comment
comment|/* We no longer need PHI, release it so that it may be reused.  */
end_comment

begin_function
name|void
name|release_phi_node
parameter_list|(
name|tree
name|phi
parameter_list|)
block|{
name|int
name|bucket
decl_stmt|;
name|int
name|len
init|=
name|PHI_ARG_CAPACITY
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
condition|;
name|x
operator|++
control|)
block|{
name|use_operand_p
name|imm
decl_stmt|;
name|imm
operator|=
operator|&
operator|(
name|PHI_ARG_IMM_USE_NODE
argument_list|(
name|phi
argument_list|,
name|x
argument_list|)
operator|)
expr_stmt|;
name|delink_imm_use
argument_list|(
name|imm
argument_list|)
expr_stmt|;
block|}
name|bucket
operator|=
name|len
operator|>
name|NUM_BUCKETS
operator|-
literal|1
condition|?
name|NUM_BUCKETS
operator|-
literal|1
else|:
name|len
expr_stmt|;
name|bucket
operator|-=
literal|2
expr_stmt|;
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
operator|=
name|free_phinodes
index|[
name|bucket
index|]
expr_stmt|;
name|free_phinodes
index|[
name|bucket
index|]
operator|=
name|phi
expr_stmt|;
name|free_phinode_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resize an existing PHI node.  The only way is up.  Return the    possibly relocated phi.  */
end_comment

begin_function
specifier|static
name|void
name|resize_phi_node
parameter_list|(
name|tree
modifier|*
name|phi
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|old_size
decl_stmt|,
name|i
decl_stmt|;
name|tree
name|new_phi
decl_stmt|;
name|gcc_assert
argument_list|(
name|len
operator|>
name|PHI_ARG_CAPACITY
argument_list|(
operator|*
name|phi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The garbage collector will not look at the PHI node beyond the      first PHI_NUM_ARGS elements.  Therefore, all we have to copy is a      portion of the PHI node currently in use.  */
name|old_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|tree_phi_node
argument_list|)
operator|+
operator|(
name|PHI_NUM_ARGS
argument_list|(
operator|*
name|phi
argument_list|)
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|phi_arg_d
argument_list|)
operator|)
expr_stmt|;
name|new_phi
operator|=
name|allocate_phi_node
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_phi
argument_list|,
operator|*
name|phi
argument_list|,
name|old_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|new_phi
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|use_operand_p
name|imm
decl_stmt|,
name|old_imm
decl_stmt|;
name|imm
operator|=
operator|&
operator|(
name|PHI_ARG_IMM_USE_NODE
argument_list|(
name|new_phi
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
name|old_imm
operator|=
operator|&
operator|(
name|PHI_ARG_IMM_USE_NODE
argument_list|(
operator|*
name|phi
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
name|imm
operator|->
name|use
operator|=
operator|&
operator|(
name|PHI_ARG_DEF_TREE
argument_list|(
name|new_phi
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
name|relink_imm_use_stmt
argument_list|(
name|imm
argument_list|,
name|old_imm
argument_list|,
name|new_phi
argument_list|)
expr_stmt|;
block|}
name|PHI_ARG_CAPACITY
argument_list|(
name|new_phi
argument_list|)
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
name|PHI_NUM_ARGS
argument_list|(
name|new_phi
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|use_operand_p
name|imm
decl_stmt|;
name|imm
operator|=
operator|&
operator|(
name|PHI_ARG_IMM_USE_NODE
argument_list|(
name|new_phi
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
name|imm
operator|->
name|use
operator|=
operator|&
operator|(
name|PHI_ARG_DEF_TREE
argument_list|(
name|new_phi
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
name|imm
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|imm
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|imm
operator|->
name|stmt
operator|=
name|new_phi
expr_stmt|;
block|}
operator|*
name|phi
operator|=
name|new_phi
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reserve PHI arguments for a new edge to basic block BB.  */
end_comment

begin_function
name|void
name|reserve_phi_args_for_new_edge
parameter_list|(
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
modifier|*
name|loc
decl_stmt|;
name|int
name|len
init|=
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
decl_stmt|;
name|int
name|cap
init|=
name|ideal_phi_node_len
argument_list|(
name|len
operator|+
literal|4
argument_list|)
decl_stmt|;
for|for
control|(
name|loc
operator|=
operator|&
operator|(
name|bb
operator|->
name|phi_nodes
operator|)
init|;
operator|*
name|loc
condition|;
name|loc
operator|=
operator|&
name|PHI_CHAIN
argument_list|(
operator|*
name|loc
argument_list|)
control|)
block|{
if|if
condition|(
name|len
operator|>
name|PHI_ARG_CAPACITY
argument_list|(
operator|*
name|loc
argument_list|)
condition|)
block|{
name|tree
name|old_phi
init|=
operator|*
name|loc
decl_stmt|;
name|resize_phi_node
argument_list|(
name|loc
argument_list|,
name|cap
argument_list|)
expr_stmt|;
comment|/* The result of the phi is defined by this phi node.  */
name|SSA_NAME_DEF_STMT
argument_list|(
name|PHI_RESULT
argument_list|(
operator|*
name|loc
argument_list|)
argument_list|)
operator|=
operator|*
name|loc
expr_stmt|;
name|release_phi_node
argument_list|(
name|old_phi
argument_list|)
expr_stmt|;
block|}
comment|/* We represent a "missing PHI argument" by placing NULL_TREE in 	 the corresponding slot.  If PHI arguments were added 	 immediately after an edge is created, this zeroing would not 	 be necessary, but unfortunately this is not the case.  For 	 example, the loop optimizer duplicates several basic blocks, 	 redirects edges, and then fixes up PHI arguments later in 	 batch.  */
name|SET_PHI_ARG_DEF
argument_list|(
operator|*
name|loc
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|PHI_NUM_ARGS
argument_list|(
operator|*
name|loc
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a new PHI node for variable VAR at basic block BB.  */
end_comment

begin_function
name|tree
name|create_phi_node
parameter_list|(
name|tree
name|var
parameter_list|,
name|basic_block
name|bb
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
name|phi
operator|=
name|make_phi_node
argument_list|(
name|var
argument_list|,
name|EDGE_COUNT
argument_list|(
name|bb
operator|->
name|preds
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the new PHI node to the list of PHI nodes for block BB.  */
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
operator|=
name|phi_nodes
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|->
name|phi_nodes
operator|=
name|phi
expr_stmt|;
comment|/* Associate BB to the PHI node.  */
name|set_bb_for_stmt
argument_list|(
name|phi
argument_list|,
name|bb
argument_list|)
expr_stmt|;
return|return
name|phi
return|;
block|}
end_function

begin_comment
comment|/* Add a new argument to PHI node PHI.  DEF is the incoming reaching    definition and E is the edge through which DEF reaches PHI.  The new    argument is added at the end of the argument list.    If PHI has reached its maximum capacity, add a few slots.  In this case,    PHI points to the reallocated phi node when we return.  */
end_comment

begin_function
name|void
name|add_phi_arg
parameter_list|(
name|tree
name|phi
parameter_list|,
name|tree
name|def
parameter_list|,
name|edge
name|e
parameter_list|)
block|{
name|basic_block
name|bb
init|=
name|e
operator|->
name|dest
decl_stmt|;
name|gcc_assert
argument_list|(
name|bb
operator|==
name|bb_for_stmt
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We resize PHI nodes upon edge creation.  We should always have      enough room at this point.  */
name|gcc_assert
argument_list|(
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
operator|<=
name|PHI_ARG_CAPACITY
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We resize PHI nodes upon edge creation.  We should always have      enough room at this point.  */
name|gcc_assert
argument_list|(
name|e
operator|->
name|dest_idx
operator|<
operator|(
name|unsigned
name|int
operator|)
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy propagation needs to know what object occur in abnormal      PHI nodes.  This is a convenient place to record such information.  */
if|if
condition|(
name|e
operator|->
name|flags
operator|&
name|EDGE_ABNORMAL
condition|)
block|{
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|def
argument_list|)
operator|=
literal|1
expr_stmt|;
name|SSA_NAME_OCCURS_IN_ABNORMAL_PHI
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|SET_PHI_ARG_DEF
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|,
name|def
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove the Ith argument from PHI's argument list.  This routine    implements removal by swapping the last alternative with the    alternative we want to delete and then shrinking the vector, which    is consistent with how we remove an edge from the edge vector.  */
end_comment

begin_function
specifier|static
name|void
name|remove_phi_arg_num
parameter_list|(
name|tree
name|phi
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|int
name|num_elem
init|=
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|i
operator|<
name|num_elem
argument_list|)
expr_stmt|;
comment|/* Delink the item which is being removed.  */
name|delink_imm_use
argument_list|(
operator|&
operator|(
name|PHI_ARG_IMM_USE_NODE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If it is not the last element, move the last element      to the element we want to delete, resetting all the links. */
if|if
condition|(
name|i
operator|!=
name|num_elem
operator|-
literal|1
condition|)
block|{
name|use_operand_p
name|old_p
decl_stmt|,
name|new_p
decl_stmt|;
name|old_p
operator|=
operator|&
name|PHI_ARG_IMM_USE_NODE
argument_list|(
name|phi
argument_list|,
name|num_elem
operator|-
literal|1
argument_list|)
expr_stmt|;
name|new_p
operator|=
operator|&
name|PHI_ARG_IMM_USE_NODE
argument_list|(
name|phi
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Set use on new node, and link into last element's place.  */
operator|*
operator|(
name|new_p
operator|->
name|use
operator|)
operator|=
operator|*
operator|(
name|old_p
operator|->
name|use
operator|)
expr_stmt|;
name|relink_imm_use
argument_list|(
name|new_p
argument_list|,
name|old_p
argument_list|)
expr_stmt|;
block|}
comment|/* Shrink the vector and return.  Note that we do not have to clear      PHI_ARG_DEF because the garbage collector will not look at those      elements beyond the first PHI_NUM_ARGS elements of the array.  */
name|PHI_NUM_ARGS
argument_list|(
name|phi
argument_list|)
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove all PHI arguments associated with edge E.  */
end_comment

begin_function
name|void
name|remove_phi_args
parameter_list|(
name|edge
name|e
parameter_list|)
block|{
name|tree
name|phi
decl_stmt|;
for|for
control|(
name|phi
operator|=
name|phi_nodes
argument_list|(
name|e
operator|->
name|dest
argument_list|)
init|;
name|phi
condition|;
name|phi
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
control|)
name|remove_phi_arg_num
argument_list|(
name|phi
argument_list|,
name|e
operator|->
name|dest_idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove PHI node PHI from basic block BB.  If PREV is non-NULL, it is    used as the node immediately before PHI in the linked list.  */
end_comment

begin_function
name|void
name|remove_phi_node
parameter_list|(
name|tree
name|phi
parameter_list|,
name|tree
name|prev
parameter_list|)
block|{
name|tree
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
name|prev
condition|)
block|{
name|loc
operator|=
operator|&
name|PHI_CHAIN
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|loc
operator|=
operator|&
operator|(
name|bb_for_stmt
argument_list|(
name|phi
argument_list|)
operator|->
name|phi_nodes
operator|)
init|;
operator|*
name|loc
operator|!=
name|phi
condition|;
name|loc
operator|=
operator|&
name|PHI_CHAIN
argument_list|(
operator|*
name|loc
argument_list|)
control|)
empty_stmt|;
block|}
comment|/* Remove PHI from the chain.  */
operator|*
name|loc
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
expr_stmt|;
comment|/* If we are deleting the PHI node, then we should release the      SSA_NAME node so that it can be reused.  */
name|release_phi_node
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|release_ssa_name
argument_list|(
name|PHI_RESULT
argument_list|(
name|phi
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reverse the order of PHI nodes in the chain PHI.    Return the new head of the chain (old last PHI node).  */
end_comment

begin_function
name|tree
name|phi_reverse
parameter_list|(
name|tree
name|phi
parameter_list|)
block|{
name|tree
name|prev
init|=
name|NULL_TREE
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
init|;
name|phi
condition|;
name|phi
operator|=
name|next
control|)
block|{
name|next
operator|=
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
expr_stmt|;
name|PHI_CHAIN
argument_list|(
name|phi
argument_list|)
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|phi
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-tree-phinodes.h"
end_include

end_unit

