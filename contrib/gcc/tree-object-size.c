begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* __builtin_object_size (ptr, object_size_type) computation    Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.    Contributed by Jakub Jelinek<jakub@redhat.com>  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tree-flow.h"
end_include

begin_include
include|#
directive|include
file|"tree-pass.h"
end_include

begin_include
include|#
directive|include
file|"tree-ssa-propagate.h"
end_include

begin_struct
struct|struct
name|object_size_info
block|{
name|int
name|object_size_type
decl_stmt|;
name|bitmap
name|visited
decl_stmt|,
name|reexamine
decl_stmt|;
name|int
name|pass
decl_stmt|;
name|bool
name|changed
decl_stmt|;
name|unsigned
name|int
modifier|*
name|depths
decl_stmt|;
name|unsigned
name|int
modifier|*
name|stack
decl_stmt|,
modifier|*
name|tos
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|unknown
index|[
literal|4
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|tree
name|compute_object_offset
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|addr_object_size
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|alloc_object_size
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|pass_through_call
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|collect_object_sizes_for
parameter_list|(
name|struct
name|object_size_info
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expr_object_size
parameter_list|(
name|struct
name|object_size_info
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|merge_object_sizes
parameter_list|(
name|struct
name|object_size_info
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|plus_expr_object_size
parameter_list|(
name|struct
name|object_size_info
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|compute_object_sizes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_offset_limit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_for_plus_in_loops
parameter_list|(
name|struct
name|object_size_info
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_for_plus_in_loops_1
parameter_list|(
name|struct
name|object_size_info
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* object_sizes[0] is upper bound for number of bytes till the end of    the object.    object_sizes[1] is upper bound for number of bytes till the end of    the subobject (innermost array or field with address taken).    object_sizes[2] is lower bound for number of bytes till the end of    the object and object_sizes[3] lower bound for subobject.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|object_sizes
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmaps what object sizes have been computed already.  */
end_comment

begin_decl_stmt
specifier|static
name|bitmap
name|computed
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum value of offset we consider to be addition.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|offset_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize OFFSET_LIMIT variable.  */
end_comment

begin_function
specifier|static
name|void
name|init_offset_limit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|host_integerp
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
name|offset_limit
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|sizetype
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|offset_limit
operator|=
operator|-
literal|1
expr_stmt|;
name|offset_limit
operator|/=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute offset of EXPR within VAR.  Return error_mark_node    if unknown.  */
end_comment

begin_function
specifier|static
name|tree
name|compute_object_offset
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|PLUS_EXPR
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|off
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|var
condition|)
return|return
name|size_zero_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|COMPONENT_REF
case|:
name|base
operator|=
name|compute_object_offset
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
return|return
name|base
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|off
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_FIELD_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REALPART_EXPR
case|:
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
case|case
name|VIEW_CONVERT_EXPR
case|:
case|case
name|NON_LVALUE_EXPR
case|:
return|return
name|compute_object_offset
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|var
argument_list|)
return|;
case|case
name|IMAGPART_EXPR
case|:
name|base
operator|=
name|compute_object_offset
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
return|return
name|base
return|;
name|off
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|base
operator|=
name|compute_object_offset
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
return|return
name|base
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|t
argument_list|)
operator|<
literal|0
condition|)
block|{
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
name|t
operator|=
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|off
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|error_mark_node
return|;
block|}
return|return
name|size_binop
argument_list|(
name|code
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compute __builtin_object_size for PTR, which is a ADDR_EXPR.    OBJECT_SIZE_TYPE is the second argument from __builtin_object_size.    If unknown, return unknown[object_size_type].  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|addr_object_size
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|int
name|object_size_type
parameter_list|)
block|{
name|tree
name|pt_var
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|ADDR_EXPR
argument_list|)
expr_stmt|;
name|pt_var
operator|=
name|TREE_OPERAND
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|REFERENCE_CLASS_P
argument_list|(
name|pt_var
argument_list|)
condition|)
name|pt_var
operator|=
name|get_base_address
argument_list|(
name|pt_var
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt_var
operator|&&
operator|(
name|SSA_VAR_P
argument_list|(
name|pt_var
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|pt_var
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|&&
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|pt_var
argument_list|)
argument_list|)
operator|&&
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|pt_var
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|pt_var
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|<
name|offset_limit
condition|)
block|{
name|tree
name|bytes
decl_stmt|;
if|if
condition|(
name|pt_var
operator|!=
name|TREE_OPERAND
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|tree
name|var
decl_stmt|;
if|if
condition|(
name|object_size_type
operator|&
literal|1
condition|)
block|{
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|var
operator|!=
name|pt_var
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|BIT_FIELD_REF
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|ARRAY_REF
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|ARRAY_RANGE_REF
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|REALPART_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|!=
name|IMAGPART_EXPR
condition|)
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|var
operator|!=
name|pt_var
operator|&&
name|TREE_CODE
argument_list|(
name|var
argument_list|)
operator|==
name|ARRAY_REF
condition|)
name|var
operator|=
name|TREE_OPERAND
argument_list|(
name|var
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|||
name|tree_int_cst_lt
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|pt_var
argument_list|)
argument_list|)
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|)
condition|)
name|var
operator|=
name|pt_var
expr_stmt|;
block|}
else|else
name|var
operator|=
name|pt_var
expr_stmt|;
name|bytes
operator|=
name|compute_object_offset
argument_list|(
name|TREE_OPERAND
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
name|error_mark_node
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|bytes
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_lt
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|,
name|bytes
argument_list|)
condition|)
name|bytes
operator|=
name|size_zero_node
expr_stmt|;
else|else
name|bytes
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|bytes
operator|=
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|pt_var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|bytes
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|tree_low_cst
argument_list|(
name|bytes
argument_list|,
literal|1
argument_list|)
return|;
block|}
return|return
name|unknown
index|[
name|object_size_type
index|]
return|;
block|}
end_function

begin_comment
comment|/* Compute __builtin_object_size for CALL, which is a CALL_EXPR.    Handles various allocation calls.  OBJECT_SIZE_TYPE is the second    argument from __builtin_object_size.  If unknown, return    unknown[object_size_type].  */
end_comment

begin_function
specifier|static
name|unsigned
name|HOST_WIDE_INT
name|alloc_object_size
parameter_list|(
name|tree
name|call
parameter_list|,
name|int
name|object_size_type
parameter_list|)
block|{
name|tree
name|callee
decl_stmt|,
name|arglist
decl_stmt|,
name|a
decl_stmt|,
name|bytes
init|=
name|NULL_TREE
decl_stmt|;
name|unsigned
name|int
name|arg_mask
init|=
literal|0
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|==
name|CALL_EXPR
argument_list|)
expr_stmt|;
name|callee
operator|=
name|get_callee_fndecl
argument_list|(
name|call
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|TREE_OPERAND
argument_list|(
name|call
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|callee
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|callee
argument_list|)
operator|==
name|BUILT_IN_NORMAL
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|callee
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_MALLOC
case|:
case|case
name|BUILT_IN_ALLOCA
case|:
name|arg_mask
operator|=
literal|1
expr_stmt|;
break|break;
comment|/*       case BUILT_IN_REALLOC: 	arg_mask = 2; 	break; 	*/
case|case
name|BUILT_IN_CALLOC
case|:
name|arg_mask
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|a
operator|=
name|arglist
init|;
name|arg_mask
operator|&&
name|a
condition|;
name|arg_mask
operator|>>=
literal|1
operator|,
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
if|if
condition|(
name|arg_mask
operator|&
literal|1
condition|)
block|{
name|tree
name|arg
init|=
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
break|break;
if|if
condition|(
operator|!
name|bytes
condition|)
name|bytes
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|bytes
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|bytes
argument_list|,
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|arg_mask
operator|&&
name|bytes
operator|&&
name|host_integerp
argument_list|(
name|bytes
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|tree_low_cst
argument_list|(
name|bytes
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|unknown
index|[
name|object_size_type
index|]
return|;
block|}
end_function

begin_comment
comment|/* If object size is propagated from one of function's arguments directly    to its return value, return that argument for CALL_EXPR CALL.    Otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|tree
name|pass_through_call
parameter_list|(
name|tree
name|call
parameter_list|)
block|{
name|tree
name|callee
init|=
name|get_callee_fndecl
argument_list|(
name|call
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|call
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|callee
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|callee
argument_list|)
operator|==
name|BUILT_IN_NORMAL
condition|)
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|callee
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_MEMCPY
case|:
case|case
name|BUILT_IN_MEMMOVE
case|:
case|case
name|BUILT_IN_MEMSET
case|:
case|case
name|BUILT_IN_STRCPY
case|:
case|case
name|BUILT_IN_STRNCPY
case|:
case|case
name|BUILT_IN_STRCAT
case|:
case|case
name|BUILT_IN_STRNCAT
case|:
case|case
name|BUILT_IN_MEMCPY_CHK
case|:
case|case
name|BUILT_IN_MEMMOVE_CHK
case|:
case|case
name|BUILT_IN_MEMSET_CHK
case|:
case|case
name|BUILT_IN_STRCPY_CHK
case|:
case|case
name|BUILT_IN_STRNCPY_CHK
case|:
case|case
name|BUILT_IN_STRCAT_CHK
case|:
case|case
name|BUILT_IN_STRNCAT_CHK
case|:
if|if
condition|(
name|arglist
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Compute __builtin_object_size value for PTR.  OBJECT_SIZE_TYPE is the    second argument from __builtin_object_size.  */
end_comment

begin_function
name|unsigned
name|HOST_WIDE_INT
name|compute_builtin_object_size
parameter_list|(
name|tree
name|ptr
parameter_list|,
name|int
name|object_size_type
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|object_size_type
operator|>=
literal|0
operator|&&
name|object_size_type
operator|<=
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|offset_limit
condition|)
name|init_offset_limit
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
return|return
name|addr_object_size
argument_list|(
name|ptr
argument_list|,
name|object_size_type
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|arg
init|=
name|pass_through_call
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
condition|)
return|return
name|compute_builtin_object_size
argument_list|(
name|arg
argument_list|,
name|object_size_type
argument_list|)
return|;
else|else
return|return
name|alloc_object_size
argument_list|(
name|ptr
argument_list|,
name|object_size_type
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ptr
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptr
argument_list|)
argument_list|)
operator|&&
name|object_sizes
index|[
name|object_size_type
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|computed
index|[
name|object_size_type
index|]
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|ptr
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|object_size_info
name|osi
decl_stmt|;
name|bitmap_iterator
name|bi
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dump_file
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Computing %s %sobject size for "
argument_list|,
operator|(
name|object_size_type
operator|&
literal|2
operator|)
condition|?
literal|"minimum"
else|:
literal|"maximum"
argument_list|,
operator|(
name|object_size_type
operator|&
literal|1
operator|)
condition|?
literal|"sub"
else|:
literal|""
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|ptr
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
block|}
name|osi
operator|.
name|visited
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|osi
operator|.
name|reexamine
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|osi
operator|.
name|object_size_type
operator|=
name|object_size_type
expr_stmt|;
name|osi
operator|.
name|depths
operator|=
name|NULL
expr_stmt|;
name|osi
operator|.
name|stack
operator|=
name|NULL
expr_stmt|;
name|osi
operator|.
name|tos
operator|=
name|NULL
expr_stmt|;
comment|/* First pass: walk UD chains, compute object sizes that 	     can be computed.  osi.reexamine bitmap at the end will 	     contain what variables were found in dependency cycles 	     and therefore need to be reexamined.  */
name|osi
operator|.
name|pass
operator|=
literal|0
expr_stmt|;
name|osi
operator|.
name|changed
operator|=
name|false
expr_stmt|;
name|collect_object_sizes_for
argument_list|(
operator|&
name|osi
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* Second pass: keep recomputing object sizes of variables 	     that need reexamination, until no object sizes are 	     increased or all object sizes are computed.  */
if|if
condition|(
operator|!
name|bitmap_empty_p
argument_list|(
name|osi
operator|.
name|reexamine
argument_list|)
condition|)
block|{
name|bitmap
name|reexamine
init|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
comment|/* If looking for minimum instead of maximum object size, 		 detect cases where a pointer is increased in a loop. 		 Although even without this detection pass 2 would eventually 		 terminate, it could take a long time.  If a pointer is 		 increasing this way, we need to assume 0 object size. 		 E.g. p =&buf[0]; while (cond) p = p + 4;  */
if|if
condition|(
name|object_size_type
operator|&
literal|2
condition|)
block|{
name|osi
operator|.
name|depths
operator|=
name|XCNEWVEC
argument_list|(
argument|unsigned int
argument_list|,
argument|num_ssa_names
argument_list|)
expr_stmt|;
name|osi
operator|.
name|stack
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned int
argument_list|,
argument|num_ssa_names
argument_list|)
expr_stmt|;
name|osi
operator|.
name|tos
operator|=
name|osi
operator|.
name|stack
expr_stmt|;
name|osi
operator|.
name|pass
operator|=
literal|1
expr_stmt|;
comment|/* collect_object_sizes_for is changing 		     osi.reexamine bitmap, so iterate over a copy.  */
name|bitmap_copy
argument_list|(
name|reexamine
argument_list|,
name|osi
operator|.
name|reexamine
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|reexamine
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|osi
operator|.
name|reexamine
argument_list|,
name|i
argument_list|)
condition|)
name|check_for_plus_in_loops
argument_list|(
operator|&
name|osi
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|osi
operator|.
name|depths
argument_list|)
expr_stmt|;
name|osi
operator|.
name|depths
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|osi
operator|.
name|stack
argument_list|)
expr_stmt|;
name|osi
operator|.
name|stack
operator|=
name|NULL
expr_stmt|;
name|osi
operator|.
name|tos
operator|=
name|NULL
expr_stmt|;
block|}
do|do
block|{
name|osi
operator|.
name|pass
operator|=
literal|2
expr_stmt|;
name|osi
operator|.
name|changed
operator|=
name|false
expr_stmt|;
comment|/* collect_object_sizes_for is changing 		     osi.reexamine bitmap, so iterate over a copy.  */
name|bitmap_copy
argument_list|(
name|reexamine
argument_list|,
name|osi
operator|.
name|reexamine
argument_list|)
expr_stmt|;
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|reexamine
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|osi
operator|.
name|reexamine
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|collect_object_sizes_for
argument_list|(
operator|&
name|osi
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Reexamining "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|osi
operator|.
name|changed
condition|)
do|;
name|BITMAP_FREE
argument_list|(
name|reexamine
argument_list|)
expr_stmt|;
block|}
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|osi.reexamine
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
name|bitmap_set_bit
argument_list|(
name|computed
index|[
name|object_size_type
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Debugging dumps.  */
if|if
condition|(
name|dump_file
condition|)
block|{
name|EXECUTE_IF_SET_IN_BITMAP
argument_list|(
argument|osi.visited
argument_list|,
literal|0
argument_list|,
argument|i
argument_list|,
argument|bi
argument_list|)
if|if
condition|(
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|i
index|]
operator|!=
name|unknown
index|[
name|object_size_type
index|]
condition|)
block|{
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|ssa_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|": %s %sobject size "
name|HOST_WIDE_INT_PRINT_UNSIGNED
literal|"\n"
argument_list|,
operator|(
name|object_size_type
operator|&
literal|2
operator|)
condition|?
literal|"minimum"
else|:
literal|"maximum"
argument_list|,
operator|(
name|object_size_type
operator|&
literal|1
operator|)
condition|?
literal|"sub"
else|:
literal|""
argument_list|,
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|BITMAP_FREE
argument_list|(
name|osi
operator|.
name|reexamine
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|osi
operator|.
name|visited
argument_list|)
expr_stmt|;
block|}
return|return
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|SSA_NAME_VERSION
argument_list|(
name|ptr
argument_list|)
index|]
return|;
block|}
return|return
name|unknown
index|[
name|object_size_type
index|]
return|;
block|}
end_function

begin_comment
comment|/* Compute object_sizes for PTR, defined to VALUE, which is not    a SSA_NAME.  */
end_comment

begin_function
specifier|static
name|void
name|expr_object_size
parameter_list|(
name|struct
name|object_size_info
modifier|*
name|osi
parameter_list|,
name|tree
name|ptr
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|int
name|object_size_type
init|=
name|osi
operator|->
name|object_size_type
decl_stmt|;
name|unsigned
name|int
name|varno
init|=
name|SSA_NAME_VERSION
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bytes
decl_stmt|;
name|gcc_assert
argument_list|(
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|!=
name|unknown
index|[
name|object_size_type
index|]
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|osi
operator|->
name|pass
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|WITH_SIZE_EXPR
condition|)
name|value
operator|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pointer variables should have been handled by merge_object_sizes.  */
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|SSA_NAME
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|bytes
operator|=
name|addr_object_size
argument_list|(
name|value
argument_list|,
name|object_size_type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CALL_EXPR
condition|)
name|bytes
operator|=
name|alloc_object_size
argument_list|(
name|value
argument_list|,
name|object_size_type
argument_list|)
expr_stmt|;
else|else
name|bytes
operator|=
name|unknown
index|[
name|object_size_type
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|object_size_type
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|<
name|bytes
condition|)
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|=
name|bytes
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|>
name|bytes
condition|)
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|=
name|bytes
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Merge object sizes of ORIG + OFFSET into DEST.  Return true if    the object size might need reexamination later.  */
end_comment

begin_function
specifier|static
name|bool
name|merge_object_sizes
parameter_list|(
name|struct
name|object_size_info
modifier|*
name|osi
parameter_list|,
name|tree
name|dest
parameter_list|,
name|tree
name|orig
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|offset
parameter_list|)
block|{
name|int
name|object_size_type
init|=
name|osi
operator|->
name|object_size_type
decl_stmt|;
name|unsigned
name|int
name|varno
init|=
name|SSA_NAME_VERSION
argument_list|(
name|dest
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|orig_bytes
decl_stmt|;
if|if
condition|(
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|==
name|unknown
index|[
name|object_size_type
index|]
condition|)
return|return
name|false
return|;
if|if
condition|(
name|offset
operator|>=
name|offset_limit
condition|)
block|{
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|=
name|unknown
index|[
name|object_size_type
index|]
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|osi
operator|->
name|pass
operator|==
literal|0
condition|)
name|collect_object_sizes_for
argument_list|(
name|osi
argument_list|,
name|orig
argument_list|)
expr_stmt|;
name|orig_bytes
operator|=
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|SSA_NAME_VERSION
argument_list|(
name|orig
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|orig_bytes
operator|!=
name|unknown
index|[
name|object_size_type
index|]
condition|)
name|orig_bytes
operator|=
operator|(
name|offset
operator|>
name|orig_bytes
operator|)
condition|?
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|0
else|:
name|orig_bytes
operator|-
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|object_size_type
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|<
name|orig_bytes
condition|)
block|{
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|=
name|orig_bytes
expr_stmt|;
name|osi
operator|->
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|>
name|orig_bytes
condition|)
block|{
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|=
name|orig_bytes
expr_stmt|;
name|osi
operator|->
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
return|return
name|bitmap_bit_p
argument_list|(
name|osi
operator|->
name|reexamine
argument_list|,
name|SSA_NAME_VERSION
argument_list|(
name|orig
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compute object_sizes for PTR, defined to VALUE, which is    a PLUS_EXPR.  Return true if the object size might need reexamination    later.  */
end_comment

begin_function
specifier|static
name|bool
name|plus_expr_object_size
parameter_list|(
name|struct
name|object_size_info
modifier|*
name|osi
parameter_list|,
name|tree
name|var
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|bool
name|ptr1_p
init|=
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|INTEGER_CST
decl_stmt|;
name|bool
name|ptr2_p
init|=
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|INTEGER_CST
decl_stmt|;
name|int
name|object_size_type
init|=
name|osi
operator|->
name|object_size_type
decl_stmt|;
name|unsigned
name|int
name|varno
init|=
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|bytes
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|PLUS_EXPR
argument_list|)
expr_stmt|;
if|if
condition|(
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|==
name|unknown
index|[
name|object_size_type
index|]
condition|)
return|return
name|false
return|;
comment|/* Swap operands if needed.  */
if|if
condition|(
name|ptr2_p
operator|&&
operator|!
name|ptr1_p
condition|)
block|{
name|tree
name|tem
init|=
name|op0
decl_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|ptr1_p
operator|=
name|true
expr_stmt|;
name|ptr2_p
operator|=
name|false
expr_stmt|;
block|}
comment|/* Handle PTR + OFFSET here.  */
if|if
condition|(
name|ptr1_p
operator|&&
operator|!
name|ptr2_p
operator|&&
name|TREE_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
operator|||
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|ADDR_EXPR
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
condition|)
name|bytes
operator|=
name|unknown
index|[
name|object_size_type
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
return|return
name|merge_object_sizes
argument_list|(
name|osi
argument_list|,
name|var
argument_list|,
name|op0
argument_list|,
name|tree_low_cst
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
else|else
block|{
name|unsigned
name|HOST_WIDE_INT
name|off
init|=
name|tree_low_cst
argument_list|(
name|op1
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|bytes
operator|=
name|compute_builtin_object_size
argument_list|(
name|op0
argument_list|,
name|object_size_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>
name|offset_limit
condition|)
name|bytes
operator|=
name|unknown
index|[
name|object_size_type
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|off
operator|>
name|bytes
condition|)
name|bytes
operator|=
literal|0
expr_stmt|;
else|else
name|bytes
operator|-=
name|off
expr_stmt|;
block|}
block|}
else|else
name|bytes
operator|=
name|unknown
index|[
name|object_size_type
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|object_size_type
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|<
name|bytes
condition|)
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|=
name|bytes
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|>
name|bytes
condition|)
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|=
name|bytes
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Compute object sizes for VAR.    For ADDR_EXPR an object size is the number of remaining bytes    to the end of the object (where what is considered an object depends on    OSI->object_size_type).    For allocation CALL_EXPR like malloc or calloc object size is the size    of the allocation.    For pointer PLUS_EXPR where second operand is a constant integer,    object size is object size of the first operand minus the constant.    If the constant is bigger than the number of remaining bytes until the    end of the object, object size is 0, but if it is instead a pointer    subtraction, object size is unknown[object_size_type].    To differentiate addition from subtraction, ADDR_EXPR returns    unknown[object_size_type] for all objects bigger than half of the address    space, and constants less than half of the address space are considered    addition, while bigger constants subtraction.    For a memcpy like CALL_EXPR that always returns one of its arguments, the    object size is object size of that argument.    Otherwise, object size is the maximum of object sizes of variables    that it might be set to.  */
end_comment

begin_function
specifier|static
name|void
name|collect_object_sizes_for
parameter_list|(
name|struct
name|object_size_info
modifier|*
name|osi
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|int
name|object_size_type
init|=
name|osi
operator|->
name|object_size_type
decl_stmt|;
name|unsigned
name|int
name|varno
init|=
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|tree
name|stmt
decl_stmt|;
name|bool
name|reexamine
decl_stmt|;
if|if
condition|(
name|bitmap_bit_p
argument_list|(
name|computed
index|[
name|object_size_type
index|]
argument_list|,
name|varno
argument_list|)
condition|)
return|return;
if|if
condition|(
name|osi
operator|->
name|pass
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|osi
operator|->
name|visited
argument_list|,
name|varno
argument_list|)
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|osi
operator|->
name|visited
argument_list|,
name|varno
argument_list|)
expr_stmt|;
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|=
operator|(
name|object_size_type
operator|&
literal|2
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Found a dependency loop.  Mark the variable for later 	     re-examination.  */
name|bitmap_set_bit
argument_list|(
name|osi
operator|->
name|reexamine
argument_list|,
name|varno
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Found a dependency loop at "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Visiting use-def links for "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|stmt
operator|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|reexamine
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|RETURN_EXPR
case|:
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU  */
case|case
name|MODIFY_EXPR
case|:
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|,
name|arg
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|arg
operator|=
name|pass_through_call
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|rhs
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|rhs
argument_list|)
argument_list|)
condition|)
name|reexamine
operator|=
name|merge_object_sizes
argument_list|(
name|osi
argument_list|,
name|var
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
name|reexamine
operator|=
name|plus_expr_object_size
argument_list|(
name|osi
argument_list|,
name|var
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
else|else
name|expr_object_size
argument_list|(
name|osi
argument_list|,
name|var
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ASM_EXPR
case|:
comment|/* Pointers defined by __asm__ statements can point anywhere.  */
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|=
name|unknown
index|[
name|object_size_type
index|]
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
block|{
name|tree
name|decl
init|=
name|SSA_NAME_VAR
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|IS_EMPTY_STMT
argument_list|(
name|stmt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|expr_object_size
argument_list|(
name|osi
argument_list|,
name|var
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|expr_object_size
argument_list|(
name|osi
argument_list|,
name|var
argument_list|,
name|decl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PHI_NODE
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|stmt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|rhs
init|=
name|PHI_ARG_DEF
argument_list|(
name|stmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|==
name|unknown
index|[
name|object_size_type
index|]
condition|)
break|break;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|reexamine
operator||=
name|merge_object_sizes
argument_list|(
name|osi
argument_list|,
name|var
argument_list|,
name|rhs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|osi
operator|->
name|pass
operator|==
literal|0
condition|)
name|expr_object_size
argument_list|(
name|osi
argument_list|,
name|var
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reexamine
operator|||
name|object_sizes
index|[
name|object_size_type
index|]
index|[
name|varno
index|]
operator|==
name|unknown
index|[
name|object_size_type
index|]
condition|)
block|{
name|bitmap_set_bit
argument_list|(
name|computed
index|[
name|object_size_type
index|]
argument_list|,
name|varno
argument_list|)
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|osi
operator|->
name|reexamine
argument_list|,
name|varno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bitmap_set_bit
argument_list|(
name|osi
operator|->
name|reexamine
argument_list|,
name|varno
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Need to reexamine "
argument_list|)
expr_stmt|;
name|print_generic_expr
argument_list|(
name|dump_file
argument_list|,
name|var
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper function for check_for_plus_in_loops.  Called recursively    to detect loops.  */
end_comment

begin_function
specifier|static
name|void
name|check_for_plus_in_loops_1
parameter_list|(
name|struct
name|object_size_info
modifier|*
name|osi
parameter_list|,
name|tree
name|var
parameter_list|,
name|unsigned
name|int
name|depth
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|varno
init|=
name|SSA_NAME_VERSION
argument_list|(
name|var
argument_list|)
decl_stmt|;
if|if
condition|(
name|osi
operator|->
name|depths
index|[
name|varno
index|]
condition|)
block|{
if|if
condition|(
name|osi
operator|->
name|depths
index|[
name|varno
index|]
operator|!=
name|depth
condition|)
block|{
name|unsigned
name|int
modifier|*
name|sp
decl_stmt|;
comment|/* Found a loop involving pointer addition.  */
for|for
control|(
name|sp
operator|=
name|osi
operator|->
name|tos
init|;
name|sp
operator|>
name|osi
operator|->
name|stack
condition|;
control|)
block|{
operator|--
name|sp
expr_stmt|;
name|bitmap_clear_bit
argument_list|(
name|osi
operator|->
name|reexamine
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
name|bitmap_set_bit
argument_list|(
name|computed
index|[
name|osi
operator|->
name|object_size_type
index|]
argument_list|,
operator|*
name|sp
argument_list|)
expr_stmt|;
name|object_sizes
index|[
name|osi
operator|->
name|object_size_type
index|]
index|[
operator|*
name|sp
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
name|varno
condition|)
break|break;
block|}
block|}
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|bitmap_bit_p
argument_list|(
name|osi
operator|->
name|reexamine
argument_list|,
name|varno
argument_list|)
condition|)
return|return;
name|osi
operator|->
name|depths
index|[
name|varno
index|]
operator|=
name|depth
expr_stmt|;
operator|*
name|osi
operator|->
name|tos
operator|++
operator|=
name|varno
expr_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|RETURN_EXPR
case|:
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU  */
case|case
name|MODIFY_EXPR
case|:
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|,
name|arg
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|arg
operator|=
name|pass_through_call
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|rhs
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|check_for_plus_in_loops_1
argument_list|(
name|osi
argument_list|,
name|rhs
argument_list|,
name|depth
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|cst
decl_stmt|,
name|basevar
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|basevar
operator|=
name|op0
expr_stmt|;
name|cst
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
name|basevar
operator|=
name|op1
expr_stmt|;
name|cst
operator|=
name|op0
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|basevar
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|cst
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|check_for_plus_in_loops_1
argument_list|(
name|osi
argument_list|,
name|basevar
argument_list|,
name|depth
operator|+
operator|!
name|integer_zerop
argument_list|(
name|cst
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|gcc_unreachable
argument_list|()
expr_stmt|;
break|break;
block|}
case|case
name|PHI_NODE
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHI_NUM_ARGS
argument_list|(
name|stmt
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|tree
name|rhs
init|=
name|PHI_ARG_DEF
argument_list|(
name|stmt
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|SSA_NAME
condition|)
name|check_for_plus_in_loops_1
argument_list|(
name|osi
argument_list|,
name|rhs
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|osi
operator|->
name|depths
index|[
name|varno
index|]
operator|=
literal|0
expr_stmt|;
name|osi
operator|->
name|tos
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if some pointer we are computing object size of is being increased    within a loop.  If yes, assume all the SSA variables participating in    that loop have minimum object sizes 0.  */
end_comment

begin_function
specifier|static
name|void
name|check_for_plus_in_loops
parameter_list|(
name|struct
name|object_size_info
modifier|*
name|osi
parameter_list|,
name|tree
name|var
parameter_list|)
block|{
name|tree
name|stmt
init|=
name|SSA_NAME_DEF_STMT
argument_list|(
name|var
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|stmt
argument_list|)
condition|)
block|{
case|case
name|RETURN_EXPR
case|:
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MODIFY_EXPR
argument_list|)
expr_stmt|;
name|stmt
operator|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FALLTHRU  */
case|case
name|MODIFY_EXPR
case|:
block|{
name|tree
name|rhs
init|=
name|TREE_OPERAND
argument_list|(
name|stmt
argument_list|,
literal|1
argument_list|)
decl_stmt|,
name|arg
decl_stmt|;
name|STRIP_NOPS
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|arg
operator|=
name|pass_through_call
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|rhs
operator|=
name|arg
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|rhs
argument_list|)
operator|==
name|PLUS_EXPR
condition|)
block|{
name|tree
name|op0
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|op1
init|=
name|TREE_OPERAND
argument_list|(
name|rhs
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|cst
decl_stmt|,
name|basevar
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SSA_NAME
condition|)
block|{
name|basevar
operator|=
name|op0
expr_stmt|;
name|cst
operator|=
name|op1
expr_stmt|;
block|}
else|else
block|{
name|basevar
operator|=
name|op1
expr_stmt|;
name|cst
operator|=
name|op0
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|basevar
argument_list|)
operator|==
name|SSA_NAME
argument_list|)
expr_stmt|;
block|}
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|cst
argument_list|)
operator|==
name|INTEGER_CST
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer_zerop
argument_list|(
name|cst
argument_list|)
condition|)
break|break;
name|osi
operator|->
name|depths
index|[
name|SSA_NAME_VERSION
argument_list|(
name|basevar
argument_list|)
index|]
operator|=
literal|1
expr_stmt|;
operator|*
name|osi
operator|->
name|tos
operator|++
operator|=
name|SSA_NAME_VERSION
argument_list|(
name|basevar
argument_list|)
expr_stmt|;
name|check_for_plus_in_loops_1
argument_list|(
name|osi
argument_list|,
name|var
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|osi
operator|->
name|depths
index|[
name|SSA_NAME_VERSION
argument_list|(
name|basevar
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
name|osi
operator|->
name|tos
operator|--
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Initialize data structures for the object size computation.  */
end_comment

begin_function
name|void
name|init_object_sizes
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|object_size_type
decl_stmt|;
if|if
condition|(
name|object_sizes
index|[
literal|0
index|]
condition|)
return|return;
for|for
control|(
name|object_size_type
operator|=
literal|0
init|;
name|object_size_type
operator|<=
literal|3
condition|;
name|object_size_type
operator|++
control|)
block|{
name|object_sizes
index|[
name|object_size_type
index|]
operator|=
name|XNEWVEC
argument_list|(
argument|unsigned HOST_WIDE_INT
argument_list|,
argument|num_ssa_names
argument_list|)
expr_stmt|;
name|computed
index|[
name|object_size_type
index|]
operator|=
name|BITMAP_ALLOC
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|init_offset_limit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Destroy data structures after the object size computation.  */
end_comment

begin_function
name|void
name|fini_object_sizes
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|object_size_type
decl_stmt|;
for|for
control|(
name|object_size_type
operator|=
literal|0
init|;
name|object_size_type
operator|<=
literal|3
condition|;
name|object_size_type
operator|++
control|)
block|{
name|free
argument_list|(
name|object_sizes
index|[
name|object_size_type
index|]
argument_list|)
expr_stmt|;
name|BITMAP_FREE
argument_list|(
name|computed
index|[
name|object_size_type
index|]
argument_list|)
expr_stmt|;
name|object_sizes
index|[
name|object_size_type
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Simple pass to optimize all __builtin_object_size () builtins.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|compute_object_sizes
parameter_list|(
name|void
parameter_list|)
block|{
name|basic_block
name|bb
decl_stmt|;
name|FOR_EACH_BB
argument_list|(
argument|bb
argument_list|)
block|{
name|block_stmt_iterator
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|bsi_start
argument_list|(
name|bb
argument_list|)
init|;
operator|!
name|bsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|bsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
block|{
name|tree
modifier|*
name|stmtp
init|=
name|bsi_stmt_ptr
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|tree
name|call
init|=
name|get_rhs
argument_list|(
operator|*
name|stmtp
argument_list|)
decl_stmt|;
name|tree
name|callee
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|call
operator|||
name|TREE_CODE
argument_list|(
name|call
argument_list|)
operator|!=
name|CALL_EXPR
condition|)
continue|continue;
name|callee
operator|=
name|get_callee_fndecl
argument_list|(
name|call
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callee
operator|||
name|DECL_BUILT_IN_CLASS
argument_list|(
name|callee
argument_list|)
operator|!=
name|BUILT_IN_NORMAL
operator|||
name|DECL_FUNCTION_CODE
argument_list|(
name|callee
argument_list|)
operator|!=
name|BUILT_IN_OBJECT_SIZE
condition|)
continue|continue;
name|init_object_sizes
argument_list|()
expr_stmt|;
name|result
operator|=
name|fold_builtin
argument_list|(
name|callee
argument_list|,
name|TREE_OPERAND
argument_list|(
name|call
argument_list|,
literal|1
argument_list|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|call
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|arglist
operator|!=
name|NULL
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|!=
name|NULL
operator|&&
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|tree
name|ost
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|host_integerp
argument_list|(
name|ost
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|object_size_type
init|=
name|tree_low_cst
argument_list|(
name|ost
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|object_size_type
operator|<
literal|2
condition|)
name|result
operator|=
name|fold_convert
argument_list|(
name|size_type_node
argument_list|,
name|integer_minus_one_node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|object_size_type
operator|<
literal|4
condition|)
name|result
operator|=
name|size_zero_node
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|result
condition|)
continue|continue;
block|}
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"Simplified\n  "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
operator|*
name|stmtp
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|set_rhs
argument_list|(
name|stmtp
argument_list|,
name|result
argument_list|)
condition|)
name|gcc_unreachable
argument_list|()
expr_stmt|;
name|update_stmt
argument_list|(
operator|*
name|stmtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dump_file
operator|&&
operator|(
name|dump_flags
operator|&
name|TDF_DETAILS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"to\n  "
argument_list|)
expr_stmt|;
name|print_generic_stmt
argument_list|(
name|dump_file
argument_list|,
operator|*
name|stmtp
argument_list|,
name|dump_flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dump_file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fini_object_sizes
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|tree_opt_pass
name|pass_object_sizes
init|=
block|{
literal|"objsz"
block|,
comment|/* name */
name|NULL
block|,
comment|/* gate */
name|compute_object_sizes
block|,
comment|/* execute */
name|NULL
block|,
comment|/* sub */
name|NULL
block|,
comment|/* next */
literal|0
block|,
comment|/* static_pass_number */
literal|0
block|,
comment|/* tv_id */
name|PROP_cfg
operator||
name|PROP_ssa
operator||
name|PROP_alias
block|,
comment|/* properties_required */
literal|0
block|,
comment|/* properties_provided */
literal|0
block|,
comment|/* properties_destroyed */
literal|0
block|,
comment|/* todo_flags_start */
name|TODO_dump_func
operator||
name|TODO_verify_ssa
block|,
comment|/* todo_flags_finish */
literal|0
comment|/* letter */
block|}
decl_stmt|;
end_decl_stmt

end_unit

