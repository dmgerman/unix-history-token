begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines shared by all languages that are variants of C.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"coretypes.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"intl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"varray.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"langhooks.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"tree-iterator.h"
end_include

begin_include
include|#
directive|include
file|"hashtab.h"
end_include

begin_include
include|#
directive|include
file|"tree-mudflap.h"
end_include

begin_include
include|#
directive|include
file|"opts.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"cgraph.h"
end_include

begin_decl_stmt
name|cpp_reader
modifier|*
name|parse_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declared in c-pragma.h.  */
end_comment

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PID_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PID_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCHAR_TYPE gets overridden by -fshort-wchar.  */
end_comment

begin_define
define|#
directive|define
name|MODIFIED_WCHAR_TYPE
define|\
value|(flag_short_wchar ? "short unsigned int" : WCHAR_TYPE)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRDIFF_TYPE
value|"long int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WINT_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WINT_TYPE
value|"unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INTMAX_TYPE
end_ifndef

begin_define
define|#
directive|define
name|INTMAX_TYPE
value|((INT_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 		     ? "int"					\ 		     : ((LONG_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 			? "long int"				\ 			: "long long int"))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UINTMAX_TYPE
end_ifndef

begin_define
define|#
directive|define
name|UINTMAX_TYPE
value|((INT_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 		     ? "unsigned int"				\ 		     : ((LONG_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 			? "long unsigned int"			\ 			: "long long unsigned int"))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following symbols are subsumed in the c_global_trees array, and    listed here individually for documentation purposes.     INTEGER_TYPE and REAL_TYPE nodes for the standard data types.  	tree short_integer_type_node; 	tree long_integer_type_node; 	tree long_long_integer_type_node;  	tree short_unsigned_type_node; 	tree long_unsigned_type_node; 	tree long_long_unsigned_type_node;  	tree truthvalue_type_node; 	tree truthvalue_false_node; 	tree truthvalue_true_node;  	tree ptrdiff_type_node;  	tree unsigned_char_type_node; 	tree signed_char_type_node; 	tree wchar_type_node; 	tree signed_wchar_type_node; 	tree unsigned_wchar_type_node;  	tree float_type_node; 	tree double_type_node; 	tree long_double_type_node;  	tree complex_integer_type_node; 	tree complex_float_type_node; 	tree complex_double_type_node; 	tree complex_long_double_type_node;  	tree dfloat32_type_node; 	tree dfloat64_type_node; 	tree_dfloat128_type_node;  	tree intQI_type_node; 	tree intHI_type_node; 	tree intSI_type_node; 	tree intDI_type_node; 	tree intTI_type_node;  	tree unsigned_intQI_type_node; 	tree unsigned_intHI_type_node; 	tree unsigned_intSI_type_node; 	tree unsigned_intDI_type_node; 	tree unsigned_intTI_type_node;  	tree widest_integer_literal_type_node; 	tree widest_unsigned_literal_type_node;     Nodes for types `void *' and `const void *'.  	tree ptr_type_node, const_ptr_type_node;     Nodes for types `char *' and `const char *'.  	tree string_type_node, const_string_type_node;     Type `char[SOMENUMBER]'.    Used when an array of char is needed and the size is irrelevant.  	tree char_array_type_node;     Type `int[SOMENUMBER]' or something like it.    Used when an array of int needed and the size is irrelevant.  	tree int_array_type_node;     Type `wchar_t[SOMENUMBER]' or something like it.    Used when a wide string literal is created.  	tree wchar_array_type_node;     Type `int ()' -- used for implicit declaration of functions.  	tree default_function_type;     A VOID_TYPE node, packaged in a TREE_LIST.  	tree void_list_node;    The lazily created VAR_DECLs for __FUNCTION__, __PRETTY_FUNCTION__,   and __func__. (C doesn't generate __FUNCTION__ and__PRETTY_FUNCTION__   VAR_DECLS, but C++ does.)  	tree function_name_decl_node; 	tree pretty_function_name_decl_node; 	tree c99_function_name_decl_node;    Stack of nested function name VAR_DECLs.  	tree saved_function_name_decls;  */
end_comment

begin_decl_stmt
name|tree
name|c_global_trees
index|[
name|CTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Switches common to the C front ends.  */
end_comment

begin_comment
comment|/* Nonzero if prepreprocessing only.  */
end_comment

begin_decl_stmt
name|int
name|flag_preprocess_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't output line number information.  */
end_comment

begin_decl_stmt
name|char
name|flag_no_line_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero causes -E output not to be done, but directives such as    #define that have side effects are still obeyed.  */
end_comment

begin_decl_stmt
name|char
name|flag_no_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means dump macros in some fashion.  */
end_comment

begin_decl_stmt
name|char
name|flag_dump_macros
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means pass #include lines through to the output.  */
end_comment

begin_decl_stmt
name|char
name|flag_dump_includes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means process PCH files while preprocessing.  */
end_comment

begin_decl_stmt
name|bool
name|flag_pch_preprocess
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The file name to which we should write a precompiled header, or    NULL if no header will be written in this compile.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|pch_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if an ISO standard was selected.  It rejects macros in the    user's namespace.  */
end_comment

begin_decl_stmt
name|int
name|flag_iso
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if -undef was given.  It suppresses target built-in macros    and assertions.  */
end_comment

begin_decl_stmt
name|int
name|flag_undef
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.    -ansi sets this.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_nonansi_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `double' the same size as `float'.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_double
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `wchar_t' the same size as `short'.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_wchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means allow implicit conversions between vectors with    differing numbers of subparts and/or differing element types.  */
end_comment

begin_decl_stmt
name|int
name|flag_lax_vector_conversions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means allow Microsoft extensions without warnings or errors.  */
end_comment

begin_decl_stmt
name|int
name|flag_ms_extensions
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the keyword `asm'.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_asm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to treat bitfields as signed unless they say `unsigned'.  */
end_comment

begin_decl_stmt
name|int
name|flag_signed_bitfields
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about #pragma directives that are not recognized.  */
end_comment

begin_decl_stmt
name|int
name|warn_unknown_pragmas
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tri state variable.  */
end_comment

begin_comment
comment|/* Warn about format/argument anomalies in calls to formatted I/O functions    (*printf, *scanf, strftime, strfmon, etc.).  */
end_comment

begin_decl_stmt
name|int
name|warn_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about using __null (as NULL in C++) as sentinel.  For code compiled    with GCC this doesn't matter as __null is guaranteed to have the right    size.  */
end_comment

begin_decl_stmt
name|int
name|warn_strict_null_sentinel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero means that faster, ...NonNil variants of objc_msgSend...    calls will be used in ObjC; passing nil receivers to such calls    will most likely result in crashes.  */
end_comment

begin_decl_stmt
name|int
name|flag_nil_receivers
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that code generation will be altered to support    "zero-link" execution.  This currently affects ObjC only, but may    affect other languages in the future.  */
end_comment

begin_decl_stmt
name|int
name|flag_zero_link
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means emit an '__OBJC, __image_info' for the current translation    unit.  It will inform the ObjC runtime that class definition(s) herein    contained are to replace one(s) previously loaded.  */
end_comment

begin_decl_stmt
name|int
name|flag_replace_objc_classes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C/ObjC language option variables.  */
end_comment

begin_comment
comment|/* Nonzero means allow type mismatches in conditional expressions;    just make their values `void'.  */
end_comment

begin_decl_stmt
name|int
name|flag_cond_mismatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means enable C89 Amendment 1 features.  */
end_comment

begin_decl_stmt
name|int
name|flag_isoc94
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use the ISO C99 dialect of C.  */
end_comment

begin_decl_stmt
name|int
name|flag_isoc99
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that we have builtin functions, and main is an int.  */
end_comment

begin_decl_stmt
name|int
name|flag_hosted
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if main is suspicious.  */
end_comment

begin_decl_stmt
name|int
name|warn_main
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ObjC language option variables.  */
end_comment

begin_comment
comment|/* Open and close the file for outputting class declarations, if    requested (ObjC).  */
end_comment

begin_decl_stmt
name|int
name|flag_gen_declaration
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tells the compiler that this is a special run.  Do not perform any    compiling, instead we are to test some platform dependent features    and output a C header file with appropriate definitions.  */
end_comment

begin_decl_stmt
name|int
name|print_struct_values
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tells the compiler what is the constant string class for Objc.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|constant_string_class_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++ language option variables.  */
end_comment

begin_comment
comment|/* Nonzero means don't recognize any extension keywords.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_gnu_keywords
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do emit exported implementations of functions even if    they can be inlined.  */
end_comment

begin_decl_stmt
name|int
name|flag_implement_inlines
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that implicit instantiations will be emitted if needed.  */
end_comment

begin_decl_stmt
name|int
name|flag_implicit_templates
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that implicit instantiations of inline templates will be    emitted if needed, even if instantiations of non-inline templates    aren't.  */
end_comment

begin_decl_stmt
name|int
name|flag_implicit_inline_templates
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means generate separate instantiation control files and    juggle them at link time.  */
end_comment

begin_decl_stmt
name|int
name|flag_use_repository
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to issue diagnostics that the standard says are not    required.  */
end_comment

begin_decl_stmt
name|int
name|flag_optional_diags
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we should attempt to elide constructors when possible.  */
end_comment

begin_decl_stmt
name|int
name|flag_elide_constructors
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that member functions defined in class scope are    inline by default.  */
end_comment

begin_decl_stmt
name|int
name|flag_default_inline
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls whether compiler generates 'type descriptor' that give    run-time type information.  */
end_comment

begin_decl_stmt
name|int
name|flag_rtti
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to conserve space in the .o files.  We do this    by putting uninitialized data and runtime initialized data into    .common instead of .data at the expense of not flagging multiple    definitions.  */
end_comment

begin_decl_stmt
name|int
name|flag_conserve_space
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to obey access control semantics.  */
end_comment

begin_decl_stmt
name|int
name|flag_access_control
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to check the return value of new and avoid calling    constructors if it is a null pointer.  */
end_comment

begin_decl_stmt
name|int
name|flag_check_new
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want the new ISO rules for pushing a new scope for `for'    initialization variables.    0: Old rules, set by -fno-for-scope.    2: New ISO rules, set by -ffor-scope.    1: Try to implement new ISO rules, but with backup compatibility    (and warnings).  This is the default, for now.  */
end_comment

begin_decl_stmt
name|int
name|flag_new_for_scope
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we want to emit defined symbols with common-like linkage as    weak symbols where possible, in order to conform to C++ semantics.    Otherwise, emit them as local symbols.  */
end_comment

begin_decl_stmt
name|int
name|flag_weak
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 means we want the preprocessor to not emit line directives for    the current working directory.  1 means we want it to do it.  -1    means we should decide depending on whether debugging information    is being emitted or not.  */
end_comment

begin_decl_stmt
name|int
name|flag_working_directory
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to use __cxa_atexit, rather than atexit, to register    destructors for local statics and global objects.  '2' means it has been    set nonzero as a default, not by a command-line flag.  */
end_comment

begin_decl_stmt
name|int
name|flag_use_cxa_atexit
init|=
name|DEFAULT_USE_CXA_ATEXIT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero to use __cxa_get_exception_ptr in C++ exception-handling    code.  '2' means it has not been set explicitly on the command line.  */
end_comment

begin_decl_stmt
name|int
name|flag_use_cxa_get_exception_ptr
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means make the default pedwarns warnings instead of errors.    The value of this flag is ignored if -pedantic is specified.  */
end_comment

begin_decl_stmt
name|int
name|flag_permissive
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to implement standard semantics for exception    specifications, calling unexpected if an exception is thrown that    doesn't match the specification.  Zero means to treat them as    assertions and optimize accordingly, but not check them.  */
end_comment

begin_decl_stmt
name|int
name|flag_enforce_eh_specs
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to generate thread-safe code for initializing local    statics.  */
end_comment

begin_decl_stmt
name|int
name|flag_threadsafe_statics
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about implicit declarations.  */
end_comment

begin_decl_stmt
name|int
name|warn_implicit
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum template instantiation depth.  This limit is rather    arbitrary, but it exists to limit the time it takes to notice    infinite template instantiations.  */
end_comment

begin_decl_stmt
name|int
name|max_tinst_depth
init|=
literal|500
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The elements of `ridpointers' are identifier nodes for the reserved    type names and storage classes.  It is indexed by a RID_... value.  */
end_comment

begin_decl_stmt
name|tree
modifier|*
name|ridpointers
decl_stmt|;
end_decl_stmt

begin_function_decl
name|tree
function_decl|(
modifier|*
name|make_fname_decl
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Nonzero means the expression being parsed will never be evaluated.    This is a count, since unevaluated expressions can nest.  */
end_comment

begin_decl_stmt
name|int
name|skip_evaluation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Information about how a function name is generated.  */
end_comment

begin_struct
struct|struct
name|fname_var_t
block|{
name|tree
modifier|*
specifier|const
name|decl
decl_stmt|;
comment|/* pointer to the VAR_DECL.  */
specifier|const
name|unsigned
name|rid
decl_stmt|;
comment|/* RID number for the identifier.  */
specifier|const
name|int
name|pretty
decl_stmt|;
comment|/* How pretty is it? */
block|}
struct|;
end_struct

begin_comment
comment|/* The three ways of getting then name of the current function.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|fname_var_t
name|fname_vars
index|[]
init|=
block|{
comment|/* C99 compliant __func__, must be first.  */
block|{
operator|&
name|c99_function_name_decl_node
block|,
name|RID_C99_FUNCTION_NAME
block|,
literal|0
block|}
block|,
comment|/* GCC __FUNCTION__ compliant.  */
block|{
operator|&
name|function_name_decl_node
block|,
name|RID_FUNCTION_NAME
block|,
literal|0
block|}
block|,
comment|/* GCC __PRETTY_FUNCTION__ compliant.  */
block|{
operator|&
name|pretty_function_name_decl_node
block|,
name|RID_PRETTY_FUNCTION_NAME
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|constant_fits_type_p
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|check_case_value
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|check_case_bounds
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|tree
modifier|*
parameter_list|,
name|tree
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_packed_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_nocommon_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_common_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_noreturn_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_noinline_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_always_inline_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_gnu_inline_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_flatten_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_used_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_unused_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_externally_visible_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_const_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_transparent_union_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_constructor_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_destructor_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_mode_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_section_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_aligned_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_weak_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_alias_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_weakref_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_visibility_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_tls_model_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_no_instrument_function_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_malloc_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_returns_twice_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_no_limit_stack_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_pure_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_novops_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_deprecated_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_vector_size_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_nonnull_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_nothrow_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_cleanup_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_warn_unused_result_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|handle_sentinel_attribute
parameter_list|(
name|tree
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|,
name|bool
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_function_nonnull
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_nonnull_arg
parameter_list|(
name|void
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|nonnull_check_p
parameter_list|(
name|tree
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|get_nonnull_operand
parameter_list|(
name|tree
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|resort_field_decl_cmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Table of machine-independent attributes common to all C-like languages.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|c_common_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"packed"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_packed_attribute
block|}
block|,
block|{
literal|"nocommon"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_nocommon_attribute
block|}
block|,
block|{
literal|"common"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_common_attribute
block|}
block|,
comment|/* FIXME: logically, noreturn attributes should be listed as      "false, true, true" and apply to function types.  But implementing this      would require all the places in the compiler that use TREE_THIS_VOLATILE      on a decl to identify non-returning functions to be located and fixed      to check the function type instead.  */
block|{
literal|"noreturn"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_noreturn_attribute
block|}
block|,
block|{
literal|"volatile"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_noreturn_attribute
block|}
block|,
block|{
literal|"noinline"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_noinline_attribute
block|}
block|,
block|{
literal|"always_inline"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_always_inline_attribute
block|}
block|,
block|{
literal|"gnu_inline"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_gnu_inline_attribute
block|}
block|,
block|{
literal|"flatten"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_flatten_attribute
block|}
block|,
block|{
literal|"used"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_used_attribute
block|}
block|,
block|{
literal|"unused"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_unused_attribute
block|}
block|,
block|{
literal|"externally_visible"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_externally_visible_attribute
block|}
block|,
comment|/* The same comments as for noreturn attributes apply to const ones.  */
block|{
literal|"const"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_const_attribute
block|}
block|,
block|{
literal|"transparent_union"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_transparent_union_attribute
block|}
block|,
block|{
literal|"constructor"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_constructor_attribute
block|}
block|,
block|{
literal|"destructor"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_destructor_attribute
block|}
block|,
block|{
literal|"mode"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|handle_mode_attribute
block|}
block|,
block|{
literal|"section"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_section_attribute
block|}
block|,
block|{
literal|"aligned"
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_aligned_attribute
block|}
block|,
block|{
literal|"weak"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_weak_attribute
block|}
block|,
block|{
literal|"alias"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_alias_attribute
block|}
block|,
block|{
literal|"weakref"
block|,
literal|0
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_weakref_attribute
block|}
block|,
block|{
literal|"no_instrument_function"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_no_instrument_function_attribute
block|}
block|,
block|{
literal|"malloc"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_malloc_attribute
block|}
block|,
block|{
literal|"returns_twice"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_returns_twice_attribute
block|}
block|,
block|{
literal|"no_stack_limit"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_no_limit_stack_attribute
block|}
block|,
block|{
literal|"pure"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_pure_attribute
block|}
block|,
comment|/* For internal use (marking of builtins) only.  The name contains space      to prevent its usage in source code.  */
block|{
literal|"no vops"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_novops_attribute
block|}
block|,
block|{
literal|"deprecated"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_deprecated_attribute
block|}
block|,
block|{
literal|"vector_size"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|handle_vector_size_attribute
block|}
block|,
block|{
literal|"visibility"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|handle_visibility_attribute
block|}
block|,
block|{
literal|"tls_model"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_tls_model_attribute
block|}
block|,
block|{
literal|"nonnull"
block|,
literal|0
block|,
operator|-
literal|1
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|handle_nonnull_attribute
block|}
block|,
block|{
literal|"nothrow"
block|,
literal|0
block|,
literal|0
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_nothrow_attribute
block|}
block|,
block|{
literal|"may_alias"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|false
block|,
name|NULL
block|}
block|,
block|{
literal|"cleanup"
block|,
literal|1
block|,
literal|1
block|,
name|true
block|,
name|false
block|,
name|false
block|,
name|handle_cleanup_attribute
block|}
block|,
block|{
literal|"warn_unused_result"
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|handle_warn_unused_result_attribute
block|}
block|,
block|{
literal|"sentinel"
block|,
literal|0
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|handle_sentinel_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Give the specifications for the format attributes, used by C and all    descendants.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|attribute_spec
name|c_common_format_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"format"
block|,
literal|3
block|,
literal|3
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|handle_format_attribute
block|}
block|,
block|{
literal|"format_arg"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|handle_format_arg_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push current bindings for the function name VAR_DECLS.  */
end_comment

begin_function
name|void
name|start_fname_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|saved
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|decl
init|=
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
decl_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|saved
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|ix
argument_list|)
argument_list|,
name|saved
argument_list|)
expr_stmt|;
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|saved
operator|||
name|saved_function_name_decls
condition|)
comment|/* Normally they'll have been NULL, so only push if we've got a        stack, or they are non-NULL.  */
name|saved_function_name_decls
operator|=
name|tree_cons
argument_list|(
name|saved
argument_list|,
name|NULL_TREE
argument_list|,
name|saved_function_name_decls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish up the current bindings, adding them into the current function's    statement tree.  This must be done _before_ finish_stmt_tree is called.    If there is no current function, we must be at file scope and no statements    are involved. Pop the previous bindings.  */
end_comment

begin_function
name|void
name|finish_fname_decls
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|stmts
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|stack
init|=
name|saved_function_name_decls
decl_stmt|;
for|for
control|(
init|;
name|stack
operator|&&
name|TREE_VALUE
argument_list|(
name|stack
argument_list|)
condition|;
name|stack
operator|=
name|TREE_CHAIN
argument_list|(
name|stack
argument_list|)
control|)
name|append_to_statement_list
argument_list|(
name|TREE_VALUE
argument_list|(
name|stack
argument_list|)
argument_list|,
operator|&
name|stmts
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmts
condition|)
block|{
name|tree
modifier|*
name|bodyp
init|=
operator|&
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|bodyp
argument_list|)
operator|==
name|BIND_EXPR
condition|)
name|bodyp
operator|=
operator|&
name|BIND_EXPR_BODY
argument_list|(
operator|*
name|bodyp
argument_list|)
expr_stmt|;
name|append_to_statement_list_force
argument_list|(
operator|*
name|bodyp
argument_list|,
operator|&
name|stmts
argument_list|)
expr_stmt|;
operator|*
name|bodyp
operator|=
name|stmts
expr_stmt|;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
condition|;
name|ix
operator|++
control|)
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|stack
condition|)
block|{
comment|/* We had saved values, restore them.  */
name|tree
name|saved
decl_stmt|;
for|for
control|(
name|saved
operator|=
name|TREE_PURPOSE
argument_list|(
name|stack
argument_list|)
init|;
name|saved
condition|;
name|saved
operator|=
name|TREE_CHAIN
argument_list|(
name|saved
argument_list|)
control|)
block|{
name|tree
name|decl
init|=
name|TREE_PURPOSE
argument_list|(
name|saved
argument_list|)
decl_stmt|;
name|unsigned
name|ix
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|saved
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|decl
expr_stmt|;
block|}
name|stack
operator|=
name|TREE_CHAIN
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
name|saved_function_name_decls
operator|=
name|stack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the text name of the current function, suitably prettified    by PRETTY_P.  Return string must be freed by caller.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|fname_as_string
parameter_list|(
name|int
name|pretty_p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
literal|"top level"
decl_stmt|;
name|char
modifier|*
name|namep
decl_stmt|;
name|int
name|vrb
init|=
literal|2
decl_stmt|;
if|if
condition|(
operator|!
name|pretty_p
condition|)
block|{
name|name
operator|=
literal|""
expr_stmt|;
name|vrb
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|current_function_decl
condition|)
name|name
operator|=
name|lang_hooks
operator|.
name|decl_printable_name
argument_list|(
name|current_function_decl
argument_list|,
name|vrb
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_lex_string_translate
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|3
decl_stmt|;
comment|/* Two for '"'s.  One for NULL.  */
name|cpp_string
name|cstr
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|,
name|strname
decl_stmt|;
name|namep
operator|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|namep
argument_list|,
name|len
argument_list|,
literal|"\"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strname
operator|.
name|text
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|namep
expr_stmt|;
name|strname
operator|.
name|len
operator|=
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cpp_interpret_string
argument_list|(
name|parse_in
argument_list|,
operator|&
name|strname
argument_list|,
literal|1
argument_list|,
operator|&
name|cstr
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|XDELETEVEC
argument_list|(
name|namep
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|cstr
operator|.
name|text
return|;
block|}
block|}
else|else
name|namep
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|namep
return|;
block|}
end_function

begin_comment
comment|/* Expand DECL if it declares an entity not handled by the    common code.  */
end_comment

begin_function
name|int
name|c_expand_decl
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* Let the back-end know about this variable.  */
if|if
condition|(
operator|!
name|anon_aggr_type_p
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|emit_local_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|else
name|expand_anon_union_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|DECL_ANON_UNION_ELEMS
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the VAR_DECL for a const char array naming the current    function. If the VAR_DECL has not yet been created, create it    now. RID indicates how it should be formatted and IDENTIFIER_NODE    ID is its name (unfortunately C and C++ hold the RID values of    keywords in different places, so we can't derive RID from ID in    this language independent code.  */
end_comment

begin_function
name|tree
name|fname_decl
parameter_list|(
name|unsigned
name|int
name|rid
parameter_list|,
name|tree
name|id
parameter_list|)
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|fname_vars
index|[
name|ix
index|]
operator|.
name|rid
operator|==
name|rid
condition|)
break|break;
name|decl
operator|=
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
block|{
comment|/* If a tree is built here, it would normally have the lineno of 	 the current statement.  Later this tree will be moved to the 	 beginning of the function and this line number will be wrong. 	 To avoid this problem set the lineno to 0 here; that prevents 	 it from appearing in the RTL.  */
name|tree
name|stmts
decl_stmt|;
name|location_t
name|saved_location
init|=
name|input_location
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_MAPPED_LOCATION
name|input_location
operator|=
name|UNKNOWN_LOCATION
expr_stmt|;
else|#
directive|else
name|input_line
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|stmts
operator|=
name|push_stmt_list
argument_list|()
expr_stmt|;
name|decl
operator|=
call|(
modifier|*
name|make_fname_decl
call|)
argument_list|(
name|id
argument_list|,
name|fname_vars
index|[
name|ix
index|]
operator|.
name|pretty
argument_list|)
expr_stmt|;
name|stmts
operator|=
name|pop_stmt_list
argument_list|(
name|stmts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_EMPTY_STMT
argument_list|(
name|stmts
argument_list|)
condition|)
name|saved_function_name_decls
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|stmts
argument_list|,
name|saved_function_name_decls
argument_list|)
expr_stmt|;
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|decl
expr_stmt|;
name|input_location
operator|=
name|saved_location
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ix
operator|&&
operator|!
name|current_function_decl
condition|)
name|pedwarn
argument_list|(
literal|"%qD is not defined outside of function scope"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Given a STRING_CST, give it a suitable array-of-chars data type.  */
end_comment

begin_function
name|tree
name|fix_string_type
parameter_list|(
name|tree
name|value
parameter_list|)
block|{
specifier|const
name|int
name|wchar_bytes
init|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
specifier|const
name|int
name|wide_flag
init|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|wchar_array_type_node
decl_stmt|;
name|int
name|length
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|int
name|nchars
decl_stmt|;
name|tree
name|e_type
decl_stmt|,
name|i_type
decl_stmt|,
name|a_type
decl_stmt|;
comment|/* Compute the number of elements, for the array type.  */
name|nchars
operator|=
name|wide_flag
condition|?
name|length
operator|/
name|wchar_bytes
else|:
name|length
expr_stmt|;
comment|/* C89 2.2.4.1, C99 5.2.4.1 (Translation limits).  The analogous      limit in C++98 Annex B is very large (65536) and is not normative,      so we do not diagnose it (warn_overlength_strings is forced off      in c_common_post_options).  */
if|if
condition|(
name|warn_overlength_strings
condition|)
block|{
specifier|const
name|int
name|nchars_max
init|=
name|flag_isoc99
condition|?
literal|4095
else|:
literal|509
decl_stmt|;
specifier|const
name|int
name|relevant_std
init|=
name|flag_isoc99
condition|?
literal|99
else|:
literal|90
decl_stmt|;
if|if
condition|(
name|nchars
operator|-
literal|1
operator|>
name|nchars_max
condition|)
comment|/* Translators: The %d after 'ISO C' will be 90 or 99.  Do not 	   separate the %d from the 'C'.  'ISO' should not be 	   translated, but it may be moved after 'C%d' in languages 	   where modifiers follow nouns.  */
name|pedwarn
argument_list|(
literal|"string length %qd is greater than the length %qd "
literal|"ISO C%d compilers are required to support"
argument_list|,
name|nchars
operator|-
literal|1
argument_list|,
name|nchars_max
argument_list|,
name|relevant_std
argument_list|)
expr_stmt|;
block|}
comment|/* Create the array type for the string constant.  The ISO C++      standard says that a string literal has type `const char[N]' or      `const wchar_t[N]'.  We use the same logic when invoked as a C      front-end with -Wwrite-strings.      ??? We should change the type of an expression depending on the      state of a warning flag.  We should just be warning -- see how      this is handled in the C++ front-end for the deprecated implicit      conversion from string literals to `char*' or `wchar_t*'.       The C++ front end relies on TYPE_MAIN_VARIANT of a cv-qualified      array type being the unqualified version of that type.      Therefore, if we are constructing an array of const char, we must      construct the matching unqualified array type first.  The C front      end does not require this, but it does no harm, so we do it      unconditionally.  */
name|e_type
operator|=
name|wide_flag
condition|?
name|wchar_type_node
else|:
name|char_type_node
expr_stmt|;
name|i_type
operator|=
name|build_index_type
argument_list|(
name|build_int_cst
argument_list|(
name|NULL_TREE
argument_list|,
name|nchars
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|a_type
operator|=
name|build_array_type
argument_list|(
name|e_type
argument_list|,
name|i_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_cxx
argument_list|()
operator|||
name|warn_write_strings
condition|)
name|a_type
operator|=
name|c_build_qualified_type
argument_list|(
name|a_type
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|a_type
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_INVARIANT
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a warning if a constant expression had overflow in folding.    Invoke this function on every expression that the language    requires to be a constant expression.    Note the ANSI C standard says it is erroneous for a    constant expression to overflow.  */
end_comment

begin_function
name|void
name|constant_expression_warning
parameter_list|(
name|tree
name|value
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|VECTOR_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|)
operator|&&
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|&&
name|warn_overflow
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"overflow in constant expression"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a warning if an expression had overflow in folding and its    operands hadn't.     Invoke this function on every expression that    (1) appears in the source code, and    (2) is a constant expression that overflowed, and    (3) is not already checked by convert_and_check;    however, do not invoke this function on operands of explicit casts    or when the expression is the result of an operator and any operand    already overflowed.  */
end_comment

begin_function
name|void
name|overflow_warning
parameter_list|(
name|tree
name|value
parameter_list|)
block|{
if|if
condition|(
name|skip_evaluation
condition|)
return|return;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
condition|)
block|{
case|case
name|INTEGER_CST
case|:
name|warning
argument_list|(
name|OPT_Woverflow
argument_list|,
literal|"integer overflow in expression"
argument_list|)
expr_stmt|;
break|break;
case|case
name|REAL_CST
case|:
name|warning
argument_list|(
name|OPT_Woverflow
argument_list|,
literal|"floating point overflow in expression"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VECTOR_CST
case|:
name|warning
argument_list|(
name|OPT_Woverflow
argument_list|,
literal|"vector overflow in expression"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPLEX_CST
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|warning
argument_list|(
name|OPT_Woverflow
argument_list|,
literal|"complex integer overflow in expression"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REAL_CST
condition|)
name|warning
argument_list|(
name|OPT_Woverflow
argument_list|,
literal|"complex floating point overflow in expression"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print a warning if a large constant is truncated to unsigned,    or if -Wconversion is used and a constant< 0 is converted to unsigned.    Invoke this function on every expression that might be implicitly    converted to an unsigned type.  */
end_comment

begin_function
specifier|static
name|void
name|unsigned_conversion_warning
parameter_list|(
name|tree
name|result
parameter_list|,
name|tree
name|operand
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|skip_evaluation
operator|==
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|operand
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|operand
argument_list|,
name|c_common_signed_type
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
comment|/* This detects cases like converting -129 or 256 to unsigned char.  */
name|warning
argument_list|(
name|OPT_Woverflow
argument_list|,
literal|"large integer implicitly truncated to unsigned type"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wconversion
argument_list|,
literal|"negative integer implicitly converted to unsigned type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a warning about casts that might indicate violation    of strict aliasing rules if -Wstrict-aliasing is used and    strict aliasing mode is in effect. OTYPE is the original    TREE_TYPE of EXPR, and TYPE the type we're casting to. */
end_comment

begin_function
name|bool
name|strict_aliasing_warning
parameter_list|(
name|tree
name|otype
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|flag_strict_aliasing
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|otype
argument_list|)
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|(
name|warn_strict_aliasing
operator|>
literal|1
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|||
name|handled_component_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Casting the address of an object to non void pointer. Warn          if the cast breaks type based aliasing.  */
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|&&
name|warn_strict_aliasing
operator|==
literal|2
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wstrict_aliasing
argument_list|,
literal|"type-punning to incomplete type "
literal|"might break strict-aliasing rules"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
comment|/* warn_strict_aliasing>= 3.   This includes the default (3).                Only warn if the cast is dereferenced immediately.  */
name|HOST_WIDE_INT
name|set1
init|=
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|set2
init|=
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|alias_sets_conflict_p
argument_list|(
name|set1
argument_list|,
name|set2
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wstrict_aliasing
argument_list|,
literal|"dereferencing type-punned "
literal|"pointer will break strict-aliasing rules"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|warn_strict_aliasing
operator|==
literal|2
operator|&&
operator|!
name|alias_sets_might_conflict_p
argument_list|(
name|set1
argument_list|,
name|set2
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wstrict_aliasing
argument_list|,
literal|"dereferencing type-punned "
literal|"pointer might break strict-aliasing rules"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|warn_strict_aliasing
operator|==
literal|1
operator|)
operator|&&
operator|!
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
condition|)
block|{
comment|/* At this level, warn for any conversions, even if an address is            not taken in the same statement.  This will likely produce many            false positives, but could be useful to pinpoint problems that            are not revealed at higher levels.  */
name|HOST_WIDE_INT
name|set1
init|=
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|otype
argument_list|)
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|set2
init|=
name|get_alias_set
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|alias_sets_might_conflict_p
argument_list|(
name|set1
argument_list|,
name|set2
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wstrict_aliasing
argument_list|,
literal|"dereferencing type-punned "
literal|"pointer might break strict-aliasing rules"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Print a warning about if (); or if () .. else; constructs    via the special empty statement node that we create.  INNER_THEN    and INNER_ELSE are the statement lists of the if and the else    block.  */
end_comment

begin_function
name|void
name|empty_body_warning
parameter_list|(
name|tree
name|inner_then
parameter_list|,
name|tree
name|inner_else
parameter_list|)
block|{
if|if
condition|(
name|extra_warnings
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|inner_then
argument_list|)
operator|==
name|STATEMENT_LIST
operator|&&
name|STATEMENT_LIST_TAIL
argument_list|(
name|inner_then
argument_list|)
condition|)
name|inner_then
operator|=
name|STATEMENT_LIST_TAIL
argument_list|(
name|inner_then
argument_list|)
operator|->
name|stmt
expr_stmt|;
if|if
condition|(
name|inner_else
operator|&&
name|TREE_CODE
argument_list|(
name|inner_else
argument_list|)
operator|==
name|STATEMENT_LIST
operator|&&
name|STATEMENT_LIST_TAIL
argument_list|(
name|inner_else
argument_list|)
condition|)
name|inner_else
operator|=
name|STATEMENT_LIST_TAIL
argument_list|(
name|inner_else
argument_list|)
operator|->
name|stmt
expr_stmt|;
if|if
condition|(
name|IS_EMPTY_STMT
argument_list|(
name|inner_then
argument_list|)
operator|&&
operator|!
name|inner_else
condition|)
name|warning
argument_list|(
name|OPT_Wextra
argument_list|,
literal|"%Hempty body in an if-statement"
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|inner_then
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_else
operator|&&
name|IS_EMPTY_STMT
argument_list|(
name|inner_else
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wextra
argument_list|,
literal|"%Hempty body in an else-statement"
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|inner_else
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if constant C has a value that is permissible    for type TYPE (an INTEGER_TYPE).  */
end_comment

begin_function
specifier|static
name|int
name|constant_fits_type_p
parameter_list|(
name|tree
name|c
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|int_fits_type_p
argument_list|(
name|c
argument_list|,
name|type
argument_list|)
return|;
name|c
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|!
name|TREE_OVERFLOW
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* True if vector types T1 and T2 can be converted to each other    without an explicit cast.  If EMIT_LAX_NOTE is true, and T1 and T2    can only be converted with -flax-vector-conversions yet that is not    in effect, emit a note telling the user about that option if such    a note has not previously been emitted.  */
end_comment

begin_function
name|bool
name|vector_types_convertible_p
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|,
name|bool
name|emit_lax_note
parameter_list|)
block|{
specifier|static
name|bool
name|emitted_lax_note
init|=
name|false
decl_stmt|;
name|bool
name|convertible_lax
decl_stmt|;
if|if
condition|(
operator|(
name|targetm
operator|.
name|vector_opaque_p
argument_list|(
name|t1
argument_list|)
operator|||
name|targetm
operator|.
name|vector_opaque_p
argument_list|(
name|t2
argument_list|)
operator|)
operator|&&
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
name|convertible_lax
operator|=
operator|(
name|tree_int_cst_equal
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TYPE_SIZE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|!=
name|REAL_TYPE
operator|||
name|TYPE_PRECISION
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|t2
argument_list|)
operator|)
operator|&&
operator|(
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|)
operator|==
name|INTEGRAL_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|convertible_lax
operator|||
name|flag_lax_vector_conversions
condition|)
return|return
name|convertible_lax
return|;
if|if
condition|(
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_VECTOR_SUBPARTS
argument_list|(
name|t2
argument_list|)
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|emit_lax_note
operator|&&
operator|!
name|emitted_lax_note
condition|)
block|{
name|emitted_lax_note
operator|=
name|true
expr_stmt|;
name|inform
argument_list|(
literal|"use -flax-vector-conversions to permit "
literal|"conversions between vectors with differing "
literal|"element types or numbers of subparts"
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Convert EXPR to TYPE, warning about conversion problems with constants.    Invoke this function on every expression that is converted implicitly,    i.e. because of language rules and not because of an explicit cast.  */
end_comment

begin_function
name|tree
name|convert_and_check
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|t
init|=
name|convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Do not diagnose overflow in a constant expression merely 	     because a conversion overflowed.  */
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|CONSTANT_CLASS_P
argument_list|(
name|expr
argument_list|)
operator|&&
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* No warning for converting 0x80000000 to int.  */
if|if
condition|(
operator|!
operator|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* If EXPR fits in the unsigned version of TYPE, 	       don't warn unless pedantic.  */
if|if
condition|(
operator|(
name|pedantic
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|constant_fits_type_p
argument_list|(
name|expr
argument_list|,
name|c_common_unsigned_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
name|OPT_Woverflow
argument_list|,
literal|"overflow in implicit constant conversion"
argument_list|)
expr_stmt|;
block|}
else|else
name|unsigned_conversion_warning
argument_list|(
name|t
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A node in a list that describes references to variables (EXPR), which are    either read accesses if WRITER is zero, or write accesses, in which case    WRITER is the parent of EXPR.  */
end_comment

begin_struct
struct|struct
name|tlist
block|{
name|struct
name|tlist
modifier|*
name|next
decl_stmt|;
name|tree
name|expr
decl_stmt|,
name|writer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used to implement a cache the results of a call to verify_tree.  We only    use this for SAVE_EXPRs.  */
end_comment

begin_struct
struct|struct
name|tlist_cache
block|{
name|struct
name|tlist_cache
modifier|*
name|next
decl_stmt|;
name|struct
name|tlist
modifier|*
name|cache_before_sp
decl_stmt|;
name|struct
name|tlist
modifier|*
name|cache_after_sp
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Obstack to use when allocating tlist structures, and corresponding    firstobj.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|tlist_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tlist_firstobj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of the identifiers we've warned about, so we can avoid duplicate    warnings.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tlist
modifier|*
name|warned_ids
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SAVE_EXPRs need special treatment.  We process them only once and then    cache the results.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tlist_cache
modifier|*
name|save_expr_cache
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|add_tlist
parameter_list|(
name|struct
name|tlist
modifier|*
modifier|*
parameter_list|,
name|struct
name|tlist
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|merge_tlist
parameter_list|(
name|struct
name|tlist
modifier|*
modifier|*
parameter_list|,
name|struct
name|tlist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verify_tree
parameter_list|(
name|tree
parameter_list|,
name|struct
name|tlist
modifier|*
modifier|*
parameter_list|,
name|struct
name|tlist
modifier|*
modifier|*
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|warning_candidate_p
parameter_list|(
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warn_for_collisions
parameter_list|(
name|struct
name|tlist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warn_for_collisions_1
parameter_list|(
name|tree
parameter_list|,
name|tree
parameter_list|,
name|struct
name|tlist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|tlist
modifier|*
name|new_tlist
parameter_list|(
name|struct
name|tlist
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|tree
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Create a new struct tlist and fill in its fields.  */
end_comment

begin_function
specifier|static
name|struct
name|tlist
modifier|*
name|new_tlist
parameter_list|(
name|struct
name|tlist
modifier|*
name|next
parameter_list|,
name|tree
name|t
parameter_list|,
name|tree
name|writer
parameter_list|)
block|{
name|struct
name|tlist
modifier|*
name|l
decl_stmt|;
name|l
operator|=
name|XOBNEW
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
expr|struct
name|tlist
argument_list|)
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|l
operator|->
name|expr
operator|=
name|t
expr_stmt|;
name|l
operator|->
name|writer
operator|=
name|writer
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Add duplicates of the nodes found in ADD to the list *TO.  If EXCLUDE_WRITER    is nonnull, we ignore any node we find which has a writer equal to it.  */
end_comment

begin_function
specifier|static
name|void
name|add_tlist
parameter_list|(
name|struct
name|tlist
modifier|*
modifier|*
name|to
parameter_list|,
name|struct
name|tlist
modifier|*
name|add
parameter_list|,
name|tree
name|exclude_writer
parameter_list|,
name|int
name|copy
parameter_list|)
block|{
while|while
condition|(
name|add
condition|)
block|{
name|struct
name|tlist
modifier|*
name|next
init|=
name|add
operator|->
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|copy
condition|)
name|add
operator|->
name|next
operator|=
operator|*
name|to
expr_stmt|;
if|if
condition|(
operator|!
name|exclude_writer
operator|||
name|add
operator|->
name|writer
operator|!=
name|exclude_writer
condition|)
operator|*
name|to
operator|=
name|copy
condition|?
name|new_tlist
argument_list|(
operator|*
name|to
argument_list|,
name|add
operator|->
name|expr
argument_list|,
name|add
operator|->
name|writer
argument_list|)
else|:
name|add
expr_stmt|;
name|add
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Merge the nodes of ADD into TO.  This merging process is done so that for    each variable that already exists in TO, no new node is added; however if    there is a write access recorded in ADD, and an occurrence on TO is only    a read access, then the occurrence in TO will be modified to record the    write.  */
end_comment

begin_function
specifier|static
name|void
name|merge_tlist
parameter_list|(
name|struct
name|tlist
modifier|*
modifier|*
name|to
parameter_list|,
name|struct
name|tlist
modifier|*
name|add
parameter_list|,
name|int
name|copy
parameter_list|)
block|{
name|struct
name|tlist
modifier|*
modifier|*
name|end
init|=
name|to
decl_stmt|;
while|while
condition|(
operator|*
name|end
condition|)
name|end
operator|=
operator|&
operator|(
operator|*
name|end
operator|)
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|add
condition|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|tlist
modifier|*
name|tmp2
decl_stmt|;
name|struct
name|tlist
modifier|*
name|next
init|=
name|add
operator|->
name|next
decl_stmt|;
for|for
control|(
name|tmp2
operator|=
operator|*
name|to
init|;
name|tmp2
condition|;
name|tmp2
operator|=
name|tmp2
operator|->
name|next
control|)
if|if
condition|(
name|tmp2
operator|->
name|expr
operator|==
name|add
operator|->
name|expr
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|tmp2
operator|->
name|writer
condition|)
name|tmp2
operator|->
name|writer
operator|=
name|add
operator|->
name|writer
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|*
name|end
operator|=
name|copy
condition|?
name|add
else|:
name|new_tlist
argument_list|(
name|NULL
argument_list|,
name|add
operator|->
name|expr
argument_list|,
name|add
operator|->
name|writer
argument_list|)
expr_stmt|;
name|end
operator|=
operator|&
operator|(
operator|*
name|end
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
block|}
name|add
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* WRITTEN is a variable, WRITER is its parent.  Warn if any of the variable    references in list LIST conflict with it, excluding reads if ONLY writers    is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|warn_for_collisions_1
parameter_list|(
name|tree
name|written
parameter_list|,
name|tree
name|writer
parameter_list|,
name|struct
name|tlist
modifier|*
name|list
parameter_list|,
name|int
name|only_writes
parameter_list|)
block|{
name|struct
name|tlist
modifier|*
name|tmp
decl_stmt|;
comment|/* Avoid duplicate warnings.  */
for|for
control|(
name|tmp
operator|=
name|warned_ids
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
name|tmp
operator|->
name|expr
operator|==
name|written
condition|)
return|return;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|expr
operator|==
name|written
operator|&&
name|list
operator|->
name|writer
operator|!=
name|writer
operator|&&
operator|(
operator|!
name|only_writes
operator|||
name|list
operator|->
name|writer
operator|)
operator|&&
name|DECL_NAME
argument_list|(
name|list
operator|->
name|expr
argument_list|)
condition|)
block|{
name|warned_ids
operator|=
name|new_tlist
argument_list|(
name|warned_ids
argument_list|,
name|written
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"operation on %qE may be undefined"
argument_list|,
name|list
operator|->
name|expr
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a list LIST of references to variables, find whether any of these    can cause conflicts due to missing sequence points.  */
end_comment

begin_function
specifier|static
name|void
name|warn_for_collisions
parameter_list|(
name|struct
name|tlist
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|tlist
modifier|*
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|list
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tmp
operator|->
name|writer
condition|)
name|warn_for_collisions_1
argument_list|(
name|tmp
operator|->
name|expr
argument_list|,
name|tmp
operator|->
name|writer
argument_list|,
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if X is a tree that can be verified by the sequence point    warnings.  */
end_comment

begin_function
specifier|static
name|int
name|warning_candidate_p
parameter_list|(
name|tree
name|x
parameter_list|)
block|{
return|return
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARM_DECL
return|;
block|}
end_function

begin_comment
comment|/* Walk the tree X, and record accesses to variables.  If X is written by the    parent tree, WRITER is the parent.    We store accesses in one of the two lists: PBEFORE_SP, and PNO_SP.  If this    expression or its only operand forces a sequence point, then everything up    to the sequence point is stored in PBEFORE_SP.  Everything else gets stored    in PNO_SP.    Once we return, we will have emitted warnings if any subexpression before    such a sequence point could be undefined.  On a higher level, however, the    sequence point may not be relevant, and we'll merge the two lists.     Example: (b++, a) + b;    The call that processes the COMPOUND_EXPR will store the increment of B    in PBEFORE_SP, and the use of A in PNO_SP.  The higher-level call that    processes the PLUS_EXPR will need to merge the two lists so that    eventually, all accesses end up on the same list (and we'll warn about the    unordered subexpressions b++ and b.     A note on merging.  If we modify the former example so that our expression    becomes      (b++, b) + a    care must be taken not simply to add all three expressions into the final    PNO_SP list.  The function merge_tlist takes care of that by merging the    before-SP list of the COMPOUND_EXPR into its after-SP list in a special    way, so that no more than one access to B is recorded.  */
end_comment

begin_function
specifier|static
name|void
name|verify_tree
parameter_list|(
name|tree
name|x
parameter_list|,
name|struct
name|tlist
modifier|*
modifier|*
name|pbefore_sp
parameter_list|,
name|struct
name|tlist
modifier|*
modifier|*
name|pno_sp
parameter_list|,
name|tree
name|writer
parameter_list|)
block|{
name|struct
name|tlist
modifier|*
name|tmp_before
decl_stmt|,
modifier|*
name|tmp_nosp
decl_stmt|,
modifier|*
name|tmp_list2
decl_stmt|,
modifier|*
name|tmp_list3
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|enum
name|tree_code_class
name|cl
decl_stmt|;
comment|/* X may be NULL if it is the operand of an empty statement expression      ({ }).  */
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
return|return;
name|restart
label|:
name|code
operator|=
name|TREE_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|cl
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|warning_candidate_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|pno_sp
operator|=
name|new_tlist
argument_list|(
operator|*
name|pno_sp
argument_list|,
name|x
argument_list|,
name|writer
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
return|return;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
name|tmp_before
operator|=
name|tmp_nosp
operator|=
name|tmp_list3
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_nosp
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_nosp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
name|pno_sp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|COND_EXPR
case|:
name|tmp_before
operator|=
name|tmp_list2
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_list2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_list2
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp_list3
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_nosp
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp_list3
operator|=
name|tmp_list2
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
operator|&
name|tmp_list2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_list2
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Rather than add both tmp_nosp and tmp_list2, we have to merge the 	 two first, to avoid warning for (a ? b++ : b++).  */
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|tmp_list2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pno_sp
argument_list|,
name|pno_sp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
case|case
name|MODIFY_EXPR
case|:
name|tmp_before
operator|=
name|tmp_nosp
operator|=
name|tmp_list3
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
operator|&
name|tmp_list3
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Expressions inside the LHS are not ordered wrt. the sequence points 	 in the RHS.  Example: 	   *a = (a++, 2) 	 Despite the fact that the modification of "a" is in the before_sp 	 list (tmp_before), it conflicts with the use of "a" in the LHS. 	 We can handle this by adding the contents of tmp_list3 	 to those of tmp_before, and redoing the collision warnings for that 	 list.  */
name|add_tlist
argument_list|(
operator|&
name|tmp_before
argument_list|,
name|tmp_list3
argument_list|,
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_before
argument_list|)
expr_stmt|;
comment|/* Exclude the LHS itself here; we first have to merge it into the 	 tmp_nosp list.  This is done to avoid warning for "a = a"; if we 	 didn't exclude the LHS, we'd get it twice, once as a read and once 	 as a write.  */
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_list3
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warn_for_collisions_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
name|tmp_nosp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warning_candidate_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|new_tlist
argument_list|(
name|NULL
argument_list|,
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL_EXPR
case|:
comment|/* We need to warn about conflicts among arguments and conflicts between 	 args and the function address.  Side effects of the function address, 	 however, are not ordered by the sequence point of the call.  */
name|tmp_before
operator|=
name|tmp_nosp
operator|=
name|tmp_list2
operator|=
name|tmp_list3
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_list2
argument_list|,
operator|&
name|tmp_list3
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_list3
argument_list|,
name|tmp_list2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
operator|&
name|tmp_before
argument_list|,
name|tmp_list3
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
operator|&
name|tmp_before
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_before
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|TREE_LIST
case|:
comment|/* Scan all the list, e.g. indices of multi dimensional array.  */
while|while
condition|(
name|x
condition|)
block|{
name|tmp_before
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|SAVE_EXPR
case|:
block|{
name|struct
name|tlist_cache
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|save_expr_cache
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|t
operator|->
name|expr
operator|==
name|x
condition|)
break|break;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|t
operator|=
name|XOBNEW
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
expr|struct
name|tlist_cache
argument_list|)
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|save_expr_cache
expr_stmt|;
name|t
operator|->
name|expr
operator|=
name|x
expr_stmt|;
name|save_expr_cache
operator|=
name|t
expr_stmt|;
name|tmp_before
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_nosp
argument_list|)
expr_stmt|;
name|tmp_list3
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tmp_nosp
condition|)
block|{
name|struct
name|tlist
modifier|*
name|t
init|=
name|tmp_nosp
decl_stmt|;
name|tmp_nosp
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_list3
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|cache_before_sp
operator|=
name|tmp_before
expr_stmt|;
name|t
operator|->
name|cache_after_sp
operator|=
name|tmp_list3
expr_stmt|;
block|}
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|t
operator|->
name|cache_before_sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|t
operator|->
name|cache_after_sp
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
comment|/* For other expressions, simply recurse on their operands. 	 Manual tail recursion for unary expressions. 	 Other non-expressions need not be processed.  */
if|if
condition|(
name|cl
operator|==
name|tcc_unary
condition|)
block|{
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writer
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
elseif|else
if|if
condition|(
name|IS_EXPR_CODE_CLASS
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|int
name|lp
decl_stmt|;
name|int
name|max
init|=
name|TREE_CODE_LENGTH
argument_list|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|lp
operator|=
literal|0
init|;
name|lp
operator|<
name|max
condition|;
name|lp
operator|++
control|)
block|{
name|tmp_before
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
name|lp
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Try to warn for undefined behavior in EXPR due to missing sequence    points.  */
end_comment

begin_function
name|void
name|verify_sequence_points
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|struct
name|tlist
modifier|*
name|before_sp
init|=
literal|0
decl_stmt|,
modifier|*
name|after_sp
init|=
literal|0
decl_stmt|;
name|warned_ids
operator|=
literal|0
expr_stmt|;
name|save_expr_cache
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tlist_firstobj
operator|==
literal|0
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|tlist_obstack
argument_list|)
expr_stmt|;
name|tlist_firstobj
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|verify_tree
argument_list|(
name|expr
argument_list|,
operator|&
name|before_sp
argument_list|,
operator|&
name|after_sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|after_sp
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
name|tlist_firstobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Validate the expression after `case' and apply default promotions.  */
end_comment

begin_function
specifier|static
name|tree
name|check_case_value
parameter_list|(
name|tree
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|==
name|NULL_TREE
condition|)
return|return
name|value
return|;
comment|/* ??? Can we ever get nops here for a valid case value?  We      shouldn't for C.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* In C++, the following is allowed:         const int i = 3;        switch (...) { case i: ... }       So, we try to reduce the VALUE to a constant that way.  */
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
block|{
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|fold
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
comment|/* Promote char or short to int.  */
name|value
operator|=
name|perform_integral_promotions
argument_list|(
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"case label does not reduce to an integer constant"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if the case values LOW and HIGH are in the range of the original    type (i.e. before the default conversion to int) of the switch testing    expression.    TYPE is the promoted type of the testing expression, and ORIG_TYPE is    the type before promoting it.  CASE_LOW_P is a pointer to the lower    bound of the case label, and CASE_HIGH_P is the upper bound or NULL    if the case is not a case range.    The caller has to make sure that we are not called with NULL for    CASE_LOW_P (i.e. the default case).    Returns true if the case label is in range of ORIG_TYPE (saturated or    untouched) or false if the label is out of range.  */
end_comment

begin_function
specifier|static
name|bool
name|check_case_bounds
parameter_list|(
name|tree
name|type
parameter_list|,
name|tree
name|orig_type
parameter_list|,
name|tree
modifier|*
name|case_low_p
parameter_list|,
name|tree
modifier|*
name|case_high_p
parameter_list|)
block|{
name|tree
name|min_value
decl_stmt|,
name|max_value
decl_stmt|;
name|tree
name|case_low
init|=
operator|*
name|case_low_p
decl_stmt|;
name|tree
name|case_high
init|=
name|case_high_p
condition|?
operator|*
name|case_high_p
else|:
name|case_low
decl_stmt|;
comment|/* If there was a problem with the original type, do nothing.  */
if|if
condition|(
name|orig_type
operator|==
name|error_mark_node
condition|)
return|return
name|true
return|;
name|min_value
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|orig_type
argument_list|)
expr_stmt|;
name|max_value
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|orig_type
argument_list|)
expr_stmt|;
comment|/* Case label is less than minimum for type.  */
if|if
condition|(
name|tree_int_cst_compare
argument_list|(
name|case_low
argument_list|,
name|min_value
argument_list|)
operator|<
literal|0
operator|&&
name|tree_int_cst_compare
argument_list|(
name|case_high
argument_list|,
name|min_value
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"case label value is less than minimum value for type"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Case value is greater than maximum for type.  */
if|if
condition|(
name|tree_int_cst_compare
argument_list|(
name|case_low
argument_list|,
name|max_value
argument_list|)
operator|>
literal|0
operator|&&
name|tree_int_cst_compare
argument_list|(
name|case_high
argument_list|,
name|max_value
argument_list|)
operator|>
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"case label value exceeds maximum value for type"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* Saturate lower case label value to minimum.  */
if|if
condition|(
name|tree_int_cst_compare
argument_list|(
name|case_high
argument_list|,
name|min_value
argument_list|)
operator|>=
literal|0
operator|&&
name|tree_int_cst_compare
argument_list|(
name|case_low
argument_list|,
name|min_value
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"lower value in case label range"
literal|" less than minimum value for type"
argument_list|)
expr_stmt|;
name|case_low
operator|=
name|min_value
expr_stmt|;
block|}
comment|/* Saturate upper case label value to maximum.  */
if|if
condition|(
name|tree_int_cst_compare
argument_list|(
name|case_low
argument_list|,
name|max_value
argument_list|)
operator|<=
literal|0
operator|&&
name|tree_int_cst_compare
argument_list|(
name|case_high
argument_list|,
name|max_value
argument_list|)
operator|>
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"upper value in case label range"
literal|" exceeds maximum value for type"
argument_list|)
expr_stmt|;
name|case_high
operator|=
name|max_value
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|case_low_p
operator|!=
name|case_low
condition|)
operator|*
name|case_low_p
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|case_low
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_high_p
operator|&&
operator|*
name|case_high_p
operator|!=
name|case_high
condition|)
operator|*
name|case_high_p
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|case_high
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an integer type with BITS bits of precision,    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */
end_comment

begin_function
name|tree
name|c_common_type_for_size
parameter_list|(
name|unsigned
name|int
name|bits
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|widest_integer_literal_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
operator|)
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Used for communication between c_common_type_for_mode and    c_register_builtin_type.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|registered_builtin_types
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return a data type that has machine mode MODE.    If the mode is an integer,    then UNSIGNEDP selects between signed and unsigned types.  */
end_comment

begin_function
name|tree
name|c_common_type_for_mode
parameter_list|(
name|enum
name|machine_mode
name|mode
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|widest_integer_literal_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|QImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|HImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intTI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intTI_type_node
else|:
name|intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
condition|)
return|return
name|float_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_double_type_node
argument_list|)
condition|)
return|return
name|long_double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|void_type_node
argument_list|)
condition|)
return|return
name|void_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|make_unsigned_type
argument_list|(
name|GET_MODE_PRECISION
argument_list|(
name|mode
argument_list|)
argument_list|)
else|:
name|make_signed_type
argument_list|(
name|GET_MODE_PRECISION
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|make_unsigned_type
argument_list|(
name|GET_MODE_PRECISION
argument_list|(
name|mode
argument_list|)
argument_list|)
else|:
name|make_signed_type
argument_list|(
name|GET_MODE_PRECISION
argument_list|(
name|mode
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|COMPLEX_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
decl_stmt|;
name|tree
name|inner_type
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|complex_float_type_node
argument_list|)
condition|)
return|return
name|complex_float_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|complex_double_type_node
argument_list|)
condition|)
return|return
name|complex_double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|complex_long_double_type_node
argument_list|)
condition|)
return|return
name|complex_long_double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|complex_integer_type_node
argument_list|)
operator|&&
operator|!
name|unsignedp
condition|)
return|return
name|complex_integer_type_node
return|;
name|inner_mode
operator|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|inner_type
operator|=
name|c_common_type_for_mode
argument_list|(
name|inner_mode
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inner_type
operator|!=
name|NULL_TREE
condition|)
return|return
name|build_complex_type
argument_list|(
name|inner_type
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|enum
name|machine_mode
name|inner_mode
init|=
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
decl_stmt|;
name|tree
name|inner_type
init|=
name|c_common_type_for_mode
argument_list|(
name|inner_mode
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
if|if
condition|(
name|inner_type
operator|!=
name|NULL_TREE
condition|)
return|return
name|build_vector_type_for_mode
argument_list|(
name|inner_type
argument_list|,
name|mode
argument_list|)
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|dfloat32_type_node
argument_list|)
condition|)
return|return
name|dfloat32_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|dfloat64_type_node
argument_list|)
condition|)
return|return
name|dfloat64_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|dfloat128_type_node
argument_list|)
condition|)
return|return
name|dfloat128_type_node
return|;
for|for
control|(
name|t
operator|=
name|registered_builtin_types
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|mode
condition|)
return|return
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return an unsigned type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|c_common_unsigned_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|signed_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|unsigned_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|integer_type_node
condition|)
return|return
name|unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_integer_type_node
condition|)
return|return
name|short_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_integer_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_integer_type_node
condition|)
return|return
name|long_long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|widest_integer_literal_type_node
condition|)
return|return
name|widest_unsigned_literal_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|type1
operator|==
name|intTI_type_node
condition|)
return|return
name|unsigned_intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|type1
operator|==
name|intDI_type_node
condition|)
return|return
name|unsigned_intDI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intSI_type_node
condition|)
return|return
name|unsigned_intSI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intHI_type_node
condition|)
return|return
name|unsigned_intHI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intQI_type_node
condition|)
return|return
name|unsigned_intQI_type_node
return|;
return|return
name|c_common_signed_or_unsigned_type
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a signed type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|c_common_signed_type
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|unsigned_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|signed_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_type_node
condition|)
return|return
name|integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_unsigned_type_node
condition|)
return|return
name|short_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_unsigned_type_node
condition|)
return|return
name|long_long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|widest_unsigned_literal_type_node
condition|)
return|return
name|widest_integer_literal_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|type1
operator|==
name|unsigned_intTI_type_node
condition|)
return|return
name|intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|type1
operator|==
name|unsigned_intDI_type_node
condition|)
return|return
name|intDI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intSI_type_node
condition|)
return|return
name|intSI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intHI_type_node
condition|)
return|return
name|intHI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intQI_type_node
condition|)
return|return
name|intQI_type_node
return|;
return|return
name|c_common_signed_or_unsigned_type
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a type the same as TYPE except unsigned or    signed according to UNSIGNEDP.  */
end_comment

begin_function
name|tree
name|c_common_signed_or_unsigned_type
parameter_list|(
name|int
name|unsignedp
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|==
name|unsignedp
condition|)
return|return
name|type
return|;
comment|/* For ENUMERAL_TYPEs in C++, must check the mode of the types, not      the precision; they have precision set to match their range, but      may use a wider mode to match an ABI.  If we change modes, we may      wind up with bad conversions.  For INTEGER_TYPEs in C, must check      the precision as well, so as to yield correct results for      bit-field types.  C++ does not have these separate bit-field      types, and producing a signed or unsigned variant of an      ENUMERAL_TYPE may cause other problems as well.  */
define|#
directive|define
name|TYPE_OK
parameter_list|(
name|node
parameter_list|)
define|\
value|(TYPE_MODE (type) == TYPE_MODE (node)					    \&& (c_dialect_cxx () || TYPE_PRECISION (type) == TYPE_PRECISION (node)))
if|if
condition|(
name|TYPE_OK
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|TYPE_OK
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|TYPE_OK
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|TYPE_OK
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|TYPE_OK
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
if|if
condition|(
name|TYPE_OK
argument_list|(
name|widest_integer_literal_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
operator|)
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|TYPE_OK
argument_list|(
name|intTI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intTI_type_node
else|:
name|intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|TYPE_OK
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
if|if
condition|(
name|TYPE_OK
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|TYPE_OK
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|TYPE_OK
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
undef|#
directive|undef
name|TYPE_OK
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
return|return
name|type
return|;
else|else
return|return
name|build_nonstandard_integer_type
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Build a bit-field integer type for the given WIDTH and UNSIGNEDP.  */
end_comment

begin_function
name|tree
name|c_build_bitfield_integer_type
parameter_list|(
name|unsigned
name|HOST_WIDE_INT
name|width
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
comment|/* Extended integer types of the same width as a standard type have      lesser rank, so those of the same width as int promote to int or      unsigned int and are valid for printf formats expecting int or      unsigned int.  To avoid such special cases, avoid creating      extended integer types for bit-fields if a standard integer type      is available.  */
if|if
condition|(
name|width
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|width
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|width
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|width
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|width
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
return|return
name|build_nonstandard_integer_type
argument_list|(
name|width
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The C version of the register_builtin_type langhook.  */
end_comment

begin_function
name|void
name|c_register_builtin_type
parameter_list|(
name|tree
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|registered_builtin_types
operator|=
name|tree_cons
argument_list|(
literal|0
argument_list|,
name|type
argument_list|,
name|registered_builtin_types
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the minimum number of bits needed to represent VALUE in a    signed or unsigned type, UNSIGNEDP says which.  */
end_comment

begin_function
name|unsigned
name|int
name|min_precision
parameter_list|(
name|tree
name|value
parameter_list|,
name|int
name|unsignedp
parameter_list|)
block|{
name|int
name|log
decl_stmt|;
comment|/* If the value is negative, compute its negative minus 1.  The latter      adjustment is because the absolute value of the largest negative value      is one larger than the largest positive value.  This is equivalent to      a bit-wise negation, so use that operation instead.  */
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|value
argument_list|)
operator|<
literal|0
condition|)
name|value
operator|=
name|fold_build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Return the number of bits needed, taking into account the fact      that we need one more bit for a signed than unsigned type.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|value
argument_list|)
condition|)
name|log
operator|=
literal|0
expr_stmt|;
else|else
name|log
operator|=
name|tree_floor_log2
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|log
operator|+
literal|1
operator|+
operator|!
name|unsignedp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an error message for invalid operands to arith operation    CODE with TYPE0 for operand 0, and TYPE1 for operand 1.  */
end_comment

begin_function
name|void
name|binary_op_error
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|type0
parameter_list|,
name|tree
name|type1
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PLUS_EXPR
case|:
name|opname
operator|=
literal|"+"
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|opname
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|opname
operator|=
literal|"*"
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|opname
operator|=
literal|"max"
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|opname
operator|=
literal|"min"
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
name|opname
operator|=
literal|"=="
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|opname
operator|=
literal|"!="
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|opname
operator|=
literal|"<="
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|opname
operator|=
literal|">="
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|opname
operator|=
literal|"<"
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|opname
operator|=
literal|">"
expr_stmt|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
name|opname
operator|=
literal|"<<"
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|opname
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
name|opname
operator|=
literal|"%"
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
name|opname
operator|=
literal|"/"
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|opname
operator|=
literal|"&"
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|opname
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|opname
operator|=
literal|"&&"
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|opname
operator|=
literal|"||"
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|opname
operator|=
literal|"^"
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|error
argument_list|(
literal|"invalid operands to binary %s (have %qT and %qT)"
argument_list|,
name|opname
argument_list|,
name|type0
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of build_binary_op, used for comparison operations.    See if the operands have both been converted from subword integer types    and, if so, perhaps change them both back to their original type.    This function is also responsible for converting the two operands    to the proper common type for comparison.     The arguments of this function are all pointers to local variables    of build_binary_op: OP0_PTR is&OP0, OP1_PTR is&OP1,    RESTYPE_PTR is&RESULT_TYPE and RESCODE_PTR is&RESULTCODE.     If this function returns nonzero, it means that the comparison has    a constant value.  What this function returns is an expression for    that value.  */
end_comment

begin_function
name|tree
name|shorten_compare
parameter_list|(
name|tree
modifier|*
name|op0_ptr
parameter_list|,
name|tree
modifier|*
name|op1_ptr
parameter_list|,
name|tree
modifier|*
name|restype_ptr
parameter_list|,
name|enum
name|tree_code
modifier|*
name|rescode_ptr
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|op0
init|=
operator|*
name|op0_ptr
decl_stmt|;
name|tree
name|op1
init|=
operator|*
name|op1_ptr
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|int
name|real1
decl_stmt|,
name|real2
decl_stmt|;
name|tree
name|primop0
decl_stmt|,
name|primop1
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
operator|*
name|rescode_ptr
decl_stmt|;
comment|/* Throw away any conversions to wider types      already present in the operands.  */
name|primop0
operator|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion      but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|primop0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp0
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|primop1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp1
operator|=
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If one of the operands must be floated, we cannot optimize.  */
name|real1
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
name|real2
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
comment|/* If first arg is constant, swap the args (changing operation      so value is preserved), for canonicalization.  Don't do this if      the second arg is 0.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|primop0
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|primop1
argument_list|)
operator|&&
operator|!
name|real_zerop
argument_list|(
name|primop1
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|primop0
decl_stmt|;
name|int
name|temi
init|=
name|unsignedp0
decl_stmt|;
name|primop0
operator|=
name|primop1
expr_stmt|;
name|primop1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
operator|*
name|op0_ptr
operator|=
name|op0
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|op1
expr_stmt|;
name|unsignedp0
operator|=
name|unsignedp1
expr_stmt|;
name|unsignedp1
operator|=
name|temi
expr_stmt|;
name|temi
operator|=
name|real1
expr_stmt|;
name|real1
operator|=
name|real2
expr_stmt|;
name|real2
operator|=
name|temi
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|rescode_ptr
operator|=
name|code
expr_stmt|;
block|}
comment|/* If comparing an integer against a constant more bits wide,      maybe we can deduce a value of 1 or 0 independent of the data.      Or else truncate the constant now      rather than extend the variable at run time.       This is only interesting if the constant is the wider arg.      Also, it is not safe if the constant is unsigned and the      variable arg is signed, since in this case the variable      would be sign-extended and then regarded as unsigned.      Our technique fails in this case because the lowest/highest      possible unsigned results don't follow naturally from the      lowest/highest possible values of the variable operand.      For just EQ_EXPR and NE_EXPR there is another technique that      could be used: see if the constant can be faithfully represented      in the other operand's type, by truncating it and reextending it      and see if that preserves the constant's value.  */
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|int
name|min_gt
decl_stmt|,
name|max_gt
decl_stmt|,
name|min_lt
decl_stmt|,
name|max_lt
decl_stmt|;
name|tree
name|maxval
decl_stmt|,
name|minval
decl_stmt|;
comment|/* 1 if comparison is nominally unsigned.  */
name|int
name|unsignedp
init|=
name|TYPE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|minval
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
operator|*
name|restype_ptr
operator|=
name|c_common_signed_type
argument_list|(
operator|*
name|restype_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
block|{
comment|/* Convert primop1 to target type, but do not introduce 	     additional overflow.  We know primop1 is an int_cst.  */
name|tree
name|tmp
init|=
name|build_int_cst_wide
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|primop1
argument_list|)
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|primop1
argument_list|)
argument_list|)
decl_stmt|;
name|primop1
operator|=
name|force_fit_type
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|,
name|TREE_OVERFLOW
argument_list|(
name|primop1
argument_list|)
argument_list|,
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|primop1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
operator|*
name|restype_ptr
condition|)
block|{
name|minval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsignedp
operator|&&
name|unsignedp0
condition|)
block|{
name|min_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
comment|/* This used to be a switch, but Genix compiler can't handle that.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|truthvalue_true_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|truthvalue_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LT_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|truthvalue_true_node
expr_stmt|;
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|truthvalue_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GT_EXPR
condition|)
block|{
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|truthvalue_true_node
expr_stmt|;
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|truthvalue_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|truthvalue_true_node
expr_stmt|;
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|truthvalue_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|truthvalue_true_node
expr_stmt|;
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|truthvalue_false_node
expr_stmt|;
block|}
comment|/* If primop0 was sign-extended and unsigned comparison specd, 	 we did a signed comparison above using the signed type bounds. 	 But the comparison we output must be unsigned.  	 Also, for inequalities, VAL is no good; but if the signed 	 comparison had *any* fixed result, it follows that the 	 unsigned comparison just tests the sign in reverse 	 (positive values are LE, negative ones GE). 	 So we can generate an unsigned comparison 	 against an extreme value of the signed type.  */
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
block|{
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|primop1
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|primop1
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|type
operator|=
name|c_common_unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|val
operator|==
name|truthvalue_false_node
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison is always false due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|truthvalue_true_node
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison is always true due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|val
argument_list|)
return|;
return|return
name|val
return|;
block|}
comment|/* Value is not predetermined, but do the comparison 	 in the type of the operand that is not constant. 	 TYPE is already properly set.  */
block|}
comment|/* If either arg is decimal float and the other is float, find the      proper common type to use for comparison.  */
elseif|else
if|if
condition|(
name|real1
operator|&&
name|real2
operator|&&
operator|(
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
argument_list|)
operator|||
name|DECIMAL_FLOAT_MODE_P
argument_list|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
name|type
operator|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|real1
operator|&&
name|real2
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
expr_stmt|;
comment|/* If args' natural types are both narrower than nominal type      and both extend in the same manner, compare them      in the type of the wider arg.      Otherwise must actually extend both to the nominal      common type lest different ways of extending      alter the result.      (eg, (short)-1 == (unsigned short)-1  should be 0.)  */
elseif|else
if|if
condition|(
name|unsignedp0
operator|==
name|unsignedp1
operator|&&
name|real1
operator|==
name|real2
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|type
operator|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsignedp0
operator|||
name|TYPE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primop0
operator|=
name|convert
argument_list|(
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|convert
argument_list|(
name|c_common_signed_or_unsigned_type
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we must do the comparison on the nominal type 	 using the args exactly as we received them.  */
name|type
operator|=
operator|*
name|restype_ptr
expr_stmt|;
name|primop0
operator|=
name|op0
expr_stmt|;
name|primop1
operator|=
name|op1
expr_stmt|;
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|integer_zerop
argument_list|(
name|primop1
argument_list|)
operator|&&
name|TYPE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE_EXPR
case|:
comment|/* All unsigned values are>= 0, so we warn if extra warnings 		 are requested.  However, if OP0 is a constant that is>= 0, the signedness of the comparison isn't an issue, 		 so suppress the warning.  */
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|convert
argument_list|(
name|c_common_signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|primop0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison of unsigned expression>= 0 is always true"
argument_list|)
expr_stmt|;
name|value
operator|=
name|truthvalue_true_node
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|convert
argument_list|(
name|c_common_signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|primop0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"comparison of unsigned expression< 0 is always false"
argument_list|)
expr_stmt|;
name|value
operator|=
name|truthvalue_false_node
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|value
argument_list|)
return|;
return|return
name|value
return|;
block|}
block|}
block|}
operator|*
name|op0_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
operator|*
name|restype_ptr
operator|=
name|truthvalue_type_node
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree for the sum or difference (RESULTCODE says which)    of pointer PTROP and integer INTOP.  */
end_comment

begin_function
name|tree
name|pointer_int_sum
parameter_list|(
name|enum
name|tree_code
name|resultcode
parameter_list|,
name|tree
name|ptrop
parameter_list|,
name|tree
name|intop
parameter_list|)
block|{
name|tree
name|size_exp
decl_stmt|,
name|ret
decl_stmt|;
comment|/* The result is a pointer of the same type that is being added.  */
name|tree
name|result_type
init|=
name|TREE_TYPE
argument_list|(
name|ptrop
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"pointer of type %<void *%> used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"pointer to a function used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
operator|==
name|METHOD_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|||
name|warn_pointer_arith
condition|)
name|pedwarn
argument_list|(
literal|"pointer to member function used in arithmetic"
argument_list|)
expr_stmt|;
name|size_exp
operator|=
name|integer_one_node
expr_stmt|;
block|}
else|else
name|size_exp
operator|=
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are manipulating pointer values, so we don't need to warn      about relying on undefined signed overflow.  We disable the      warning here because we use integer types so fold won't know that      they are really pointers.  */
name|fold_defer_overflow_warnings
argument_list|()
expr_stmt|;
comment|/* If what we are about to multiply by the size of the elements      contains a constant term, apply distributive law      and multiply that constant term separately.      This helps produce common subexpressions.  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|PLUS_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
operator|)
operator|&&
operator|!
name|TREE_CONSTANT
argument_list|(
name|intop
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_CONSTANT
argument_list|(
name|size_exp
argument_list|)
comment|/* If the constant comes from pointer subtraction, 	 skip this optimization--it would cause an error.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
comment|/* If the constant is unsigned, and smaller than the pointer size, 	 then we must skip this optimization.  This is because it could cause 	 an overflow error if the constant is negative but INTOP is not.  */
operator|&&
operator|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|ptrop
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
name|enum
name|tree_code
name|subcode
init|=
name|resultcode
decl_stmt|;
name|tree
name|int_type
init|=
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|intop
argument_list|)
operator|==
name|MINUS_EXPR
condition|)
name|subcode
operator|=
operator|(
name|subcode
operator|==
name|PLUS_EXPR
condition|?
name|MINUS_EXPR
else|:
name|PLUS_EXPR
operator|)
expr_stmt|;
comment|/* Convert both subexpression types to the type of intop, 	 because weird cases involving pointer arithmetic 	 can result in a sum or difference with different type args.  */
name|ptrop
operator|=
name|build_binary_op
argument_list|(
name|subcode
argument_list|,
name|ptrop
argument_list|,
name|convert
argument_list|(
name|int_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|intop
operator|=
name|convert
argument_list|(
name|int_type
argument_list|,
name|TREE_OPERAND
argument_list|(
name|intop
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the integer argument to a type the same size as sizetype      so the multiply won't overflow spuriously.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
operator|||
name|TYPE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|)
operator|!=
name|TYPE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
condition|)
name|intop
operator|=
name|convert
argument_list|(
name|c_common_type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|sizetype
argument_list|)
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
argument_list|)
argument_list|,
name|intop
argument_list|)
expr_stmt|;
comment|/* Replace the integer argument with a suitable product by the object size.      Do this multiplication as signed, then convert to the appropriate      pointer type (actually unsigned integral).  */
name|intop
operator|=
name|convert
argument_list|(
name|result_type
argument_list|,
name|build_binary_op
argument_list|(
name|MULT_EXPR
argument_list|,
name|intop
argument_list|,
name|convert
argument_list|(
name|TREE_TYPE
argument_list|(
name|intop
argument_list|)
argument_list|,
name|size_exp
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the sum or difference.  */
name|ret
operator|=
name|fold_build2
argument_list|(
name|resultcode
argument_list|,
name|result_type
argument_list|,
name|ptrop
argument_list|,
name|intop
argument_list|)
expr_stmt|;
name|fold_undefer_and_ignore_overflow_warnings
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,    or for an `if' or `while' statement or ?..: exp.  It should already    have been validated to be of suitable type; otherwise, a bad    diagnostic may result.     This preparation consists of taking the ordinary    representation of an expression expr and producing a valid tree    boolean expression describing whether expr is nonzero.  We could    simply always do build_binary_op (NE_EXPR, expr, truthvalue_false_node, 1),    but we optimize comparisons,&&, ||, and !.     The resulting type should always be `truthvalue_type_node'.  */
end_comment

begin_function
name|tree
name|c_common_truthvalue_conversion
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|UNEQ_EXPR
case|:
case|case
name|LTGT_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|UNLE_EXPR
case|:
case|case
name|UNGE_EXPR
case|:
case|case
name|UNLT_EXPR
case|:
case|case
name|UNGT_EXPR
case|:
case|case
name|ORDERED_EXPR
case|:
case|case
name|UNORDERED_EXPR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|truthvalue_type_node
condition|)
return|return
name|expr
return|;
return|return
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|truthvalue_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|truthvalue_type_node
condition|)
return|return
name|expr
return|;
return|return
name|build2
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|truthvalue_type_node
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|TRUTH_NOT_EXPR
case|:
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|==
name|truthvalue_type_node
condition|)
return|return
name|expr
return|;
return|return
name|build1
argument_list|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
argument_list|,
name|truthvalue_type_node
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|expr
return|;
case|case
name|INTEGER_CST
case|:
comment|/* Avoid integer_zerop to ignore TREE_CONSTANT_OVERFLOW.  */
return|return
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|expr
argument_list|)
operator|!=
literal|0
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|expr
argument_list|)
operator|!=
literal|0
operator|)
condition|?
name|truthvalue_true_node
else|:
name|truthvalue_false_node
return|;
case|case
name|REAL_CST
case|:
return|return
name|real_compare
argument_list|(
name|NE_EXPR
argument_list|,
operator|&
name|TREE_REAL_CST
argument_list|(
name|expr
argument_list|)
argument_list|,
operator|&
name|dconst0
argument_list|)
condition|?
name|truthvalue_true_node
else|:
name|truthvalue_false_node
return|;
case|case
name|FUNCTION_DECL
case|:
name|expr
operator|=
name|build_unary_op
argument_list|(
name|ADDR_EXPR
argument_list|,
name|expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Fall through.  */
case|case
name|ADDR_EXPR
case|:
block|{
name|tree
name|inner
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
name|inner
argument_list|)
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|inner
argument_list|)
operator|==
name|LABEL_DECL
operator|||
operator|!
name|DECL_WEAK
argument_list|(
name|inner
argument_list|)
operator|)
condition|)
block|{
comment|/* Common Ada/Pascal programmer's mistake.  We always warn 	       about this since it is so bad.  */
name|warning
argument_list|(
name|OPT_Waddress
argument_list|,
literal|"the address of %qD will always evaluate as %<true%>"
argument_list|,
name|inner
argument_list|)
expr_stmt|;
return|return
name|truthvalue_true_node
return|;
block|}
comment|/* If we are taking the address of an external decl, it might be 	   zero if it is weak, so we cannot optimize.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|inner
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|inner
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|inner
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|truthvalue_type_node
argument_list|,
name|inner
argument_list|,
name|truthvalue_true_node
argument_list|)
return|;
else|else
return|return
name|truthvalue_true_node
return|;
block|}
case|case
name|COMPLEX_EXPR
case|:
return|return
name|build_binary_op
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
comment|/* These don't change whether an object is nonzero or zero.  */
return|return
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
comment|/* These don't change whether an object is zero or nonzero, but 	 we can't ignore them if their second arg has side-effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|truthvalue_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* Distribute the conversion into the arms of a COND_EXPR.  */
return|return
name|fold_build3
argument_list|(
name|COND_EXPR
argument_list|,
name|truthvalue_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
case|case
name|NOP_EXPR
case|:
comment|/* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE, 	 since that affects how `default_conversion' will behave.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
break|break;
comment|/* If this is widening the argument, we can ignore it.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|c_common_truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
operator|!
name|TREE_NO_WARNING
argument_list|(
name|expr
argument_list|)
operator|&&
name|warn_parentheses
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around assignment used as truth value"
argument_list|)
expr_stmt|;
name|TREE_NO_WARNING
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|t
init|=
name|save_expr
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
operator|(
name|build_binary_op
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|c_common_truthvalue_conversion
argument_list|(
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|def_builtin_1
parameter_list|(
name|enum
name|built_in_function
name|fncode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|built_in_class
name|fnclass
parameter_list|,
name|tree
name|fntype
parameter_list|,
name|tree
name|libtype
parameter_list|,
name|bool
name|both_p
parameter_list|,
name|bool
name|fallback_p
parameter_list|,
name|bool
name|nonansi_p
parameter_list|,
name|tree
name|fnattrs
parameter_list|,
name|bool
name|implicit_p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Make a variant type in the proper way for C/C++, propagating qualifiers    down to the element type of an array.  */
end_comment

begin_function
name|tree
name|c_build_qualified_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|int
name|type_quals
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|t
decl_stmt|;
name|tree
name|element_type
init|=
name|c_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type_quals
argument_list|)
decl_stmt|;
comment|/* See if we already have an identically qualified type.  */
for|for
control|(
name|t
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
init|;
name|t
condition|;
name|t
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TYPE_QUALS
argument_list|(
name|strip_array_types
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|type_quals
operator|&&
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_CONTEXT
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CONTEXT
argument_list|(
name|type
argument_list|)
operator|&&
name|attribute_list_equal
argument_list|(
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|t
operator|=
name|build_variant_type_copy
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|element_type
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
comment|/* A restrict-qualified pointer type must be a pointer to object or      incomplete type.  Note that the use of POINTER_TYPE_P also allows      REFERENCE_TYPEs, which is appropriate for C++.  */
if|if
condition|(
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
operator|&&
operator|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|C_TYPE_OBJECT_OR_INCOMPLETE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of %<restrict%>"
argument_list|)
expr_stmt|;
name|type_quals
operator|&=
operator|~
name|TYPE_QUAL_RESTRICT
expr_stmt|;
block|}
return|return
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Apply the TYPE_QUALS to the new DECL.  */
end_comment

begin_function
name|void
name|c_apply_type_quals_to_decl
parameter_list|(
name|int
name|type_quals
parameter_list|,
name|tree
name|decl
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return;
if|if
condition|(
operator|(
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
operator|||
operator|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
operator|)
comment|/* An object declared 'const' is only readonly after it is 	 initialized.  We don't have any way of expressing this currently, 	 so we need to be conservative and unset TREE_READONLY for types 	 with constructors.  Otherwise aliasing code will ignore stores in 	 an inline constructor.  */
operator|&&
operator|!
operator|(
name|type
operator|&&
name|TYPE_NEEDS_CONSTRUCTING
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_RESTRICT
condition|)
block|{
while|while
condition|(
name|type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
comment|/* Allow 'restrict' on arrays of pointers. 	   FIXME currently we just ignore it.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|C_TYPE_OBJECT_OR_INCOMPLETE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of %<restrict%>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_strict_aliasing
operator|&&
name|type
operator|==
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Indicate we need to make a unique alias set for this pointer. 	   We can't do it here because it might be pointing to an 	   incomplete type.  */
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|decl
argument_list|)
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hash function for the problem of multiple type definitions in    different files.  This must hash all types that will compare    equal via comptypes to the same value.  In practice it hashes    on some of the simple stuff and leaves the details to comptypes.  */
end_comment

begin_function
specifier|static
name|hashval_t
name|c_type_hash
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|shift
decl_stmt|,
name|size
decl_stmt|;
name|tree
name|t
init|=
operator|(
name|tree
operator|)
name|p
decl_stmt|;
name|tree
name|t2
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
comment|/* For pointers, hash on pointee type plus some swizzling.  */
case|case
name|POINTER_TYPE
case|:
return|return
name|c_type_hash
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|^
literal|0x3003003
return|;
comment|/* Hash on number of elements and total size.  */
case|case
name|ENUMERAL_TYPE
case|:
name|shift
operator|=
literal|3
expr_stmt|;
name|t2
operator|=
name|TYPE_VALUES
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
name|shift
operator|=
literal|0
expr_stmt|;
name|t2
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|QUAL_UNION_TYPE
case|:
name|shift
operator|=
literal|1
expr_stmt|;
name|t2
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNION_TYPE
case|:
name|shift
operator|=
literal|2
expr_stmt|;
name|t2
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
for|for
control|(
init|;
name|t2
condition|;
name|t2
operator|=
name|TREE_CHAIN
argument_list|(
name|t2
argument_list|)
control|)
name|i
operator|++
expr_stmt|;
name|size
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|size
operator|<<
literal|24
operator|)
operator||
operator|(
name|i
operator|<<
name|shift
operator|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|(param_is (union tree_node))
argument_list|)
name|htab_t
name|type_hash_table
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return the typed-based alias set for T, which may be an expression    or a type.  Return -1 if we don't do anything special.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|c_common_get_alias_set
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
name|tree
name|u
decl_stmt|;
name|PTR
modifier|*
name|slot
decl_stmt|;
comment|/* Permit type-punning when accessing a union, provided the access      is directly through the union.  For example, this code does not      permit taking the address of a union member and then storing      through it.  Even the type-punning allowed here is a GCC      extension, albeit a common and useful one; the C standard says      that such accesses have implementation-defined behavior.  */
for|for
control|(
name|u
operator|=
name|t
init|;
name|TREE_CODE
argument_list|(
name|u
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|u
argument_list|)
operator|==
name|ARRAY_REF
condition|;
name|u
operator|=
name|TREE_OPERAND
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|u
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
literal|0
return|;
comment|/* That's all the expressions we handle specially.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* The C standard guarantees that any object may be accessed via an      lvalue that has character type.  */
if|if
condition|(
name|t
operator|==
name|char_type_node
operator|||
name|t
operator|==
name|signed_char_type_node
operator|||
name|t
operator|==
name|unsigned_char_type_node
condition|)
return|return
literal|0
return|;
comment|/* If it has the may_alias attribute, it can alias anything.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"may_alias"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|t
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The C standard specifically allows aliasing between signed and      unsigned variants of the same type.  We treat the signed      variant as canonical.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_UNSIGNED
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|t1
init|=
name|c_common_signed_type
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* t1 == t can happen for boolean nodes which are always unsigned.  */
if|if
condition|(
name|t1
operator|!=
name|t
condition|)
return|return
name|get_alias_set
argument_list|(
name|t1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|t1
decl_stmt|;
comment|/* Unfortunately, there is no canonical form of a pointer type. 	 In particular, if we have `typedef int I', then `int *', and 	 `I *' are different types.  So, we have to pick a canonical 	 representative.  We do this below.  	 Technically, this approach is actually more conservative that 	 it needs to be.  In particular, `const int *' and `int *' 	 should be in different alias sets, according to the C and C++ 	 standard, since their types are not the same, and so, 	 technically, an `int **' and `const int **' cannot point at 	 the same thing.  	 But, the standard is wrong.  In particular, this code is 	 legal C++:  	    int *ip; 	    int **ipp =&ip; 	    const int* const* cipp = ipp;  	 And, it doesn't make sense for that to be legal unless you 	 can dereference IPP and CIPP.  So, we ignore cv-qualifiers on 	 the pointed-to types.  This issue has been reported to the 	 C++ committee.  */
name|t1
operator|=
name|build_type_no_quals
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t
condition|)
return|return
name|get_alias_set
argument_list|(
name|t1
argument_list|)
return|;
block|}
comment|/* Handle the case of multiple type nodes referring to "the same" type,      which occurs with IMA.  These share an alias set.  FIXME:  Currently only      C90 is handled.  (In C99 type compatibility is not transitive, which      complicates things mightily. The alias set splay trees can theoretically      represent this, but insertion is tricky when you consider all the      different orders things might arrive in.) */
if|if
condition|(
name|c_language
operator|!=
name|clk_c
operator|||
name|flag_isoc99
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Save time if there's only one input file.  */
if|if
condition|(
name|num_in_fnames
operator|==
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Pointers need special handling if they point to any type that      needs special handling (below).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|tree
name|t2
decl_stmt|;
comment|/* Find bottom type under any nested POINTERs.  */
for|for
control|(
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
init|;
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|POINTER_TYPE
condition|;
name|t2
operator|=
name|TREE_TYPE
argument_list|(
name|t2
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|QUAL_UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* These are the only cases that need special handling.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|QUAL_UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|UNION_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Undefined? */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Look up t in hash table.  Only one of the compatible types within each      alias set is recorded in the table.  */
if|if
condition|(
operator|!
name|type_hash_table
condition|)
name|type_hash_table
operator|=
name|htab_create_ggc
argument_list|(
literal|1021
argument_list|,
name|c_type_hash
argument_list|,
operator|(
name|htab_eq
operator|)
name|lang_hooks
operator|.
name|types_compatible_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|slot
operator|=
name|htab_find_slot
argument_list|(
name|type_hash_table
argument_list|,
name|t
argument_list|,
name|INSERT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|slot
operator|!=
name|NULL
condition|)
block|{
name|TYPE_ALIAS_SET
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_ALIAS_SET
argument_list|(
operator|(
name|tree
operator|)
operator|*
name|slot
argument_list|)
expr_stmt|;
return|return
name|TYPE_ALIAS_SET
argument_list|(
operator|(
name|tree
operator|)
operator|*
name|slot
argument_list|)
return|;
block|}
else|else
comment|/* Our caller will assign and record (in t) a new alias set; all we need        to do is remember t in the hash table.  */
operator|*
name|slot
operator|=
name|t
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the value of 'sizeof (TYPE)' or '__alignof__ (TYPE)', where the    second parameter indicates which OPERATOR is being applied.  The COMPLAIN    flag controls whether we should diagnose possibly ill-formed    constructs or not.  */
end_comment

begin_function
name|tree
name|c_sizeof_or_alignof_type
parameter_list|(
name|tree
name|type
parameter_list|,
name|bool
name|is_sizeof
parameter_list|,
name|int
name|complain
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|op_name
decl_stmt|;
name|tree
name|value
init|=
name|NULL
decl_stmt|;
name|enum
name|tree_code
name|type_code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|op_name
operator|=
name|is_sizeof
condition|?
literal|"sizeof"
else|:
literal|"__alignof__"
expr_stmt|;
if|if
condition|(
name|type_code
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|is_sizeof
condition|)
block|{
if|if
condition|(
name|complain
operator|&&
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid application of %<sizeof%> to a function type"
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_one_node
expr_stmt|;
block|}
else|else
name|value
operator|=
name|size_int
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_code
operator|==
name|VOID_TYPE
operator|||
name|type_code
operator|==
name|ERROR_MARK
condition|)
block|{
if|if
condition|(
name|type_code
operator|==
name|VOID_TYPE
operator|&&
name|complain
operator|&&
operator|(
name|pedantic
operator|||
name|warn_pointer_arith
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid application of %qs to a void type"
argument_list|,
name|op_name
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"invalid application of %qs to incomplete type %qT "
argument_list|,
name|op_name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|value
operator|=
name|size_zero_node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_sizeof
condition|)
comment|/* Convert in case a char is more than one unit.  */
name|value
operator|=
name|size_binop
argument_list|(
name|CEIL_DIV_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|size_int
argument_list|(
name|TYPE_ALIGN_UNIT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* VALUE will have an integer type with TYPE_IS_SIZETYPE set.      TYPE_IS_SIZETYPE means that certain things (like overflow) will      never happen.  However, this node should really have type      `size_t', which is just a typedef for an ordinary integer type.  */
name|value
operator|=
name|fold_convert
argument_list|(
name|size_type_node
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
operator|!
name|TYPE_IS_SIZETYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of EXPR, measured in bytes.  For VAR_DECLs,    FUNCTION_DECLs and FIELD_DECLs return DECL_ALIGN (which can be set    from an "aligned" __attribute__ specification).  */
end_comment

begin_function
name|tree
name|c_alignof_expr
parameter_list|(
name|tree
name|expr
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|VAR_OR_FUNCTION_DECL_P
argument_list|(
name|expr
argument_list|)
condition|)
name|t
operator|=
name|size_int
argument_list|(
name|DECL_ALIGN_UNIT
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%<__alignof%> applied to a bit-field"
argument_list|)
expr_stmt|;
name|t
operator|=
name|size_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|t
operator|=
name|size_int
argument_list|(
name|DECL_ALIGN_UNIT
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|best
init|=
name|t
decl_stmt|;
name|int
name|bestalign
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|int
name|thisalign
decl_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thisalign
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisalign
operator|>
name|bestalign
condition|)
name|best
operator|=
name|t
operator|,
name|bestalign
operator|=
name|thisalign
expr_stmt|;
block|}
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|best
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
return|return
name|fold_convert
argument_list|(
name|size_type_node
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle C and C++ default attributes.  */
end_comment

begin_enum
enum|enum
name|built_in_attribute
block|{
define|#
directive|define
name|DEF_ATTR_NULL_TREE
parameter_list|(
name|ENUM
parameter_list|)
value|ENUM,
define|#
directive|define
name|DEF_ATTR_INT
parameter_list|(
name|ENUM
parameter_list|,
name|VALUE
parameter_list|)
value|ENUM,
define|#
directive|define
name|DEF_ATTR_IDENT
parameter_list|(
name|ENUM
parameter_list|,
name|STRING
parameter_list|)
value|ENUM,
define|#
directive|define
name|DEF_ATTR_TREE_LIST
parameter_list|(
name|ENUM
parameter_list|,
name|PURPOSE
parameter_list|,
name|VALUE
parameter_list|,
name|CHAIN
parameter_list|)
value|ENUM,
include|#
directive|include
file|"builtin-attrs.def"
undef|#
directive|undef
name|DEF_ATTR_NULL_TREE
undef|#
directive|undef
name|DEF_ATTR_INT
undef|#
directive|undef
name|DEF_ATTR_IDENT
undef|#
directive|undef
name|DEF_ATTR_TREE_LIST
name|ATTR_LAST
block|}
enum|;
end_enum

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|tree
name|built_in_attributes
index|[
operator|(
name|int
operator|)
name|ATTR_LAST
index|]
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|c_init_attributes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_enum
enum|enum
name|c_builtin_type
block|{
define|#
directive|define
name|DEF_PRIMITIVE_TYPE
parameter_list|(
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_0
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_1
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_2
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_3
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_4
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_5
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|,
name|ARG5
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_6
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|,
name|ARG5
parameter_list|,
name|ARG6
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_7
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|,
name|ARG5
parameter_list|,
name|ARG6
parameter_list|,
name|ARG7
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_0
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_1
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_2
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_3
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_4
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_5
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|,
name|ARG6
parameter_list|)
define|\
value|NAME,
define|#
directive|define
name|DEF_POINTER_TYPE
parameter_list|(
name|NAME
parameter_list|,
name|TYPE
parameter_list|)
value|NAME,
include|#
directive|include
file|"builtin-types.def"
undef|#
directive|undef
name|DEF_PRIMITIVE_TYPE
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_0
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_1
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_2
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_3
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_4
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_5
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_6
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_7
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_0
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_1
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_2
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_3
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_4
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_5
undef|#
directive|undef
name|DEF_POINTER_TYPE
name|BT_LAST
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|enum
name|c_builtin_type
name|builtin_type
typedef|;
end_typedef

begin_comment
comment|/* A temporary array for c_common_nodes_and_builtins.  Used in    communication with def_fn_type.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|builtin_types
index|[
operator|(
name|int
operator|)
name|BT_LAST
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A helper function for c_common_nodes_and_builtins.  Build function type    for DEF with return type RET and N arguments.  If VAR is true, then the    function should be variadic after those N arguments.     Takes special care not to ICE if any of the types involved are    error_mark_node, which indicates that said type is not in fact available    (see builtin_type_for_size).  In which case the function type as a whole    should be error_mark_node.  */
end_comment

begin_function
specifier|static
name|void
name|def_fn_type
parameter_list|(
name|builtin_type
name|def
parameter_list|,
name|builtin_type
name|ret
parameter_list|,
name|bool
name|var
parameter_list|,
name|int
name|n
parameter_list|,
modifier|...
parameter_list|)
block|{
name|tree
name|args
init|=
name|NULL
decl_stmt|,
name|t
decl_stmt|;
name|va_list
name|list
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|list
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
block|{
name|builtin_type
name|a
init|=
name|va_arg
argument_list|(
name|list
argument_list|,
name|builtin_type
argument_list|)
decl_stmt|;
name|t
operator|=
name|builtin_types
index|[
name|a
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
goto|goto
name|egress
goto|;
name|args
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|args
operator|=
name|nreverse
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|var
condition|)
name|args
operator|=
name|chainon
argument_list|(
name|args
argument_list|,
name|void_list_node
argument_list|)
expr_stmt|;
name|t
operator|=
name|builtin_types
index|[
name|ret
index|]
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
goto|goto
name|egress
goto|;
name|t
operator|=
name|build_function_type
argument_list|(
name|t
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|egress
label|:
name|builtin_types
index|[
name|def
index|]
operator|=
name|t
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build builtin functions common to both C and C++ language    frontends.  */
end_comment

begin_function
specifier|static
name|void
name|c_define_builtins
parameter_list|(
name|tree
name|va_list_ref_type_node
parameter_list|,
name|tree
name|va_list_arg_type_node
parameter_list|)
block|{
define|#
directive|define
name|DEF_PRIMITIVE_TYPE
parameter_list|(
name|ENUM
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|builtin_types[ENUM] = VALUE;
define|#
directive|define
name|DEF_FUNCTION_TYPE_0
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 0, 0);
define|#
directive|define
name|DEF_FUNCTION_TYPE_1
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 0, 1, ARG1);
define|#
directive|define
name|DEF_FUNCTION_TYPE_2
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 0, 2, ARG1, ARG2);
define|#
directive|define
name|DEF_FUNCTION_TYPE_3
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 0, 3, ARG1, ARG2, ARG3);
define|#
directive|define
name|DEF_FUNCTION_TYPE_4
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 0, 4, ARG1, ARG2, ARG3, ARG4);
define|#
directive|define
name|DEF_FUNCTION_TYPE_5
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|,
name|ARG5
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 0, 5, ARG1, ARG2, ARG3, ARG4, ARG5);
define|#
directive|define
name|DEF_FUNCTION_TYPE_6
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|,
name|ARG5
parameter_list|, \
name|ARG6
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 0, 6, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6);
define|#
directive|define
name|DEF_FUNCTION_TYPE_7
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|,
name|ARG5
parameter_list|, \
name|ARG6
parameter_list|,
name|ARG7
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 0, 7, ARG1, ARG2, ARG3, ARG4, ARG5, ARG6, ARG7);
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_0
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 1, 0);
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_1
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 1, 1, ARG1);
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_2
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 1, 2, ARG1, ARG2);
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_3
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 1, 3, ARG1, ARG2, ARG3);
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_4
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 1, 4, ARG1, ARG2, ARG3, ARG4);
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_5
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|,
name|ARG5
parameter_list|)
define|\
value|def_fn_type (ENUM, RETURN, 1, 5, ARG1, ARG2, ARG3, ARG4, ARG5);
define|#
directive|define
name|DEF_POINTER_TYPE
parameter_list|(
name|ENUM
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|builtin_types[(int) ENUM] = build_pointer_type (builtin_types[(int) TYPE]);
include|#
directive|include
file|"builtin-types.def"
undef|#
directive|undef
name|DEF_PRIMITIVE_TYPE
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_1
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_2
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_3
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_4
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_5
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_6
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_0
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_1
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_2
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_3
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_4
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_5
undef|#
directive|undef
name|DEF_POINTER_TYPE
name|builtin_types
index|[
operator|(
name|int
operator|)
name|BT_LAST
index|]
operator|=
name|NULL_TREE
expr_stmt|;
name|c_init_attributes
argument_list|()
expr_stmt|;
define|#
directive|define
name|DEF_BUILTIN
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,
name|TYPE
parameter_list|,
name|LIBTYPE
parameter_list|,
name|BOTH_P
parameter_list|,
name|FALLBACK_P
parameter_list|, \
name|NONANSI_P
parameter_list|,
name|ATTRS
parameter_list|,
name|IMPLICIT
parameter_list|,
name|COND
parameter_list|)
define|\
value|if (NAME&& COND)							\     def_builtin_1 (ENUM, NAME, CLASS,                                   \ 		   builtin_types[(int) TYPE],                           \ 		   builtin_types[(int) LIBTYPE],                        \ 		   BOTH_P, FALLBACK_P, NONANSI_P,                       \ 		   built_in_attributes[(int) ATTRS], IMPLICIT);
include|#
directive|include
file|"builtins.def"
undef|#
directive|undef
name|DEF_BUILTIN
name|build_common_builtin_nodes
argument_list|()
expr_stmt|;
name|targetm
operator|.
name|init_builtins
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_mudflap
condition|)
name|mudflap_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build tree nodes and builtin functions common to both C and C++ language    frontends.  */
end_comment

begin_function
name|void
name|c_common_nodes_and_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|wchar_type_size
decl_stmt|;
name|tree
name|array_domain_type
decl_stmt|;
name|tree
name|va_list_ref_type_node
decl_stmt|;
name|tree
name|va_list_arg_type_node
decl_stmt|;
comment|/* Define `int' and `char' first so that dbx will output them first.  */
name|record_builtin_type
argument_list|(
name|RID_INT
argument_list|,
name|NULL
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_CHAR
argument_list|,
literal|"char"
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
comment|/* `signed' is the same as `int'.  FIXME: the declarations of "signed",      "unsigned long", "long long unsigned" and "unsigned short" were in C++      but not C.  Are the conditionals here needed?  */
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
name|record_builtin_type
argument_list|(
name|RID_SIGNED
argument_list|,
name|NULL
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_LONG
argument_list|,
literal|"long int"
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long unsigned int"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned long"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long int"
argument_list|,
name|long_long_integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned int"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_SHORT
argument_list|,
literal|"short int"
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"short unsigned int"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned short"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"signed char"
argument_list|,
name|signed_char_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned char"
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* These are types that c_common_type_for_size and      c_common_type_for_mode use.  */
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|targetm
operator|.
name|scalar_mode_supported_p
argument_list|(
name|TImode
argument_list|)
condition|)
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__int128_t"
argument_list|)
argument_list|,
name|intTI_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|targetm
operator|.
name|scalar_mode_supported_p
argument_list|(
name|TImode
argument_list|)
condition|)
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__uint128_t"
argument_list|)
argument_list|,
name|unsigned_intTI_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create the widest literal types.  */
name|widest_integer_literal_type_node
operator|=
name|make_signed_type
argument_list|(
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|widest_integer_literal_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|widest_unsigned_literal_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|widest_unsigned_literal_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* `unsigned long' is the standard type for sizeof.      Note that stddef.h uses `unsigned long',      and this must agree, even if long and int are the same size.  */
name|size_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|SIZE_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|signed_size_type_node
operator|=
name|c_common_signed_type
argument_list|(
name|size_type_node
argument_list|)
expr_stmt|;
name|set_sizetype
argument_list|(
name|size_type_node
argument_list|)
expr_stmt|;
name|pid_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|PID_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|build_common_tree_nodes_2
argument_list|(
name|flag_short_double
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_FLOAT
argument_list|,
name|NULL
argument_list|,
name|float_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_DOUBLE
argument_list|,
name|NULL
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long double"
argument_list|,
name|long_double_type_node
argument_list|)
expr_stmt|;
comment|/* Only supported decimal floating point extension if the target      actually supports underlying modes. */
if|if
condition|(
name|targetm
operator|.
name|scalar_mode_supported_p
argument_list|(
name|SDmode
argument_list|)
operator|&&
name|targetm
operator|.
name|scalar_mode_supported_p
argument_list|(
name|DDmode
argument_list|)
operator|&&
name|targetm
operator|.
name|scalar_mode_supported_p
argument_list|(
name|TDmode
argument_list|)
condition|)
block|{
name|record_builtin_type
argument_list|(
name|RID_DFLOAT32
argument_list|,
name|NULL
argument_list|,
name|dfloat32_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_DFLOAT64
argument_list|,
name|NULL
argument_list|,
name|dfloat64_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_DFLOAT128
argument_list|,
name|NULL
argument_list|,
name|dfloat128_type_node
argument_list|)
expr_stmt|;
block|}
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex int"
argument_list|)
argument_list|,
name|complex_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex float"
argument_list|)
argument_list|,
name|complex_float_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex double"
argument_list|)
argument_list|,
name|complex_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex long double"
argument_list|)
argument_list|,
name|complex_long_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
comment|/* For C++, make fileptr_type_node a distinct void * type until        FILE type is defined.  */
name|fileptr_type_node
operator|=
name|build_variant_type_copy
argument_list|(
name|ptr_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_VOID
argument_list|,
name|NULL
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* This node must not be shared.  */
name|void_zero_node
operator|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|void_zero_node
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|void_list_node
operator|=
name|build_void_list_node
argument_list|()
expr_stmt|;
comment|/* Make a type to be the domain of a few array types      whose domains don't really matter.      200 is small enough that it always fits in size_t      and large enough that it can hold most function names for the      initializations of __FUNCTION__ and __PRETTY_FUNCTION__.  */
name|array_domain_type
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
literal|200
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a type for arrays of characters.      With luck nothing will ever really depend on the length of this      array type.  */
name|char_array_type_node
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
comment|/* Likewise for arrays of ints.  */
name|int_array_type_node
operator|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
name|string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|const_string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is special for C++ so functions can be overloaded.  */
name|wchar_type_node
operator|=
name|get_identifier
argument_list|(
name|MODIFIED_WCHAR_TYPE
argument_list|)
expr_stmt|;
name|wchar_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|wchar_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|wchar_type_size
operator|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_dialect_cxx
argument_list|()
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|wchar_type_node
argument_list|)
condition|)
name|wchar_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
else|else
name|wchar_type_node
operator|=
name|make_signed_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_WCHAR
argument_list|,
literal|"wchar_t"
argument_list|,
name|wchar_type_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signed_wchar_type_node
operator|=
name|c_common_signed_type
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
name|unsigned_wchar_type_node
operator|=
name|c_common_unsigned_type
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
block|}
comment|/* This is for wide string constants.  */
name|wchar_array_type_node
operator|=
name|build_array_type
argument_list|(
name|wchar_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
name|wint_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|WINT_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intmax_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|INTMAX_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|uintmax_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|UINTMAX_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|default_function_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ptrdiff_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|PTRDIFF_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_ptrdiff_type_node
operator|=
name|c_common_unsigned_type
argument_list|(
name|ptrdiff_type_node
argument_list|)
expr_stmt|;
name|lang_hooks
operator|.
name|decls
operator|.
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__builtin_va_list"
argument_list|)
argument_list|,
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|va_list_type_node
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|va_list_arg_type_node
operator|=
name|va_list_ref_type_node
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|va_list_arg_type_node
operator|=
name|va_list_type_node
expr_stmt|;
name|va_list_ref_type_node
operator|=
name|build_reference_type
argument_list|(
name|va_list_type_node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_preprocess_only
condition|)
name|c_define_builtins
argument_list|(
name|va_list_ref_type_node
argument_list|,
name|va_list_arg_type_node
argument_list|)
expr_stmt|;
name|main_identifier_node
operator|=
name|get_identifier
argument_list|(
literal|"main"
argument_list|)
expr_stmt|;
comment|/* Create the built-in __null node.  It is important that this is      not shared.  */
name|null_node
operator|=
name|make_node
argument_list|(
name|INTEGER_CST
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|null_node
argument_list|)
operator|=
name|c_common_type_for_size
argument_list|(
name|POINTER_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Since builtin_types isn't gc'ed, don't export these nodes.  */
name|memset
argument_list|(
name|builtin_types
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|builtin_types
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up the function in built_in_decls that corresponds to DECL    and set ASMSPEC as its user assembler name.  DECL must be a    function decl that declares a builtin.  */
end_comment

begin_function
name|void
name|set_builtin_user_assembler_name
parameter_list|(
name|tree
name|decl
parameter_list|,
specifier|const
name|char
modifier|*
name|asmspec
parameter_list|)
block|{
name|tree
name|builtin
decl_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN_CLASS
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_NORMAL
operator|&&
name|asmspec
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|builtin
operator|=
name|built_in_decls
index|[
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
index|]
expr_stmt|;
name|set_user_assembler_name
argument_list|(
name|builtin
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_MEMCPY
condition|)
name|init_block_move_fn
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|BUILT_IN_MEMSET
condition|)
name|init_block_clear_fn
argument_list|(
name|asmspec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The number of named compound-literals generated thus far.  */
end_comment

begin_expr_stmt
specifier|static
name|GTY
argument_list|(
argument|()
argument_list|)
name|int
name|compound_literal_number
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set DECL_NAME for DECL, a VAR_DECL for a compound-literal.  */
end_comment

begin_function
name|void
name|set_compound_literal_name
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|name
argument_list|,
literal|"__compound_literal"
argument_list|,
name|compound_literal_number
argument_list|)
expr_stmt|;
name|compound_literal_number
operator|++
expr_stmt|;
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|build_va_arg
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|type
parameter_list|)
block|{
return|return
name|build1
argument_list|(
name|VA_ARG_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Linked list of disabled built-in functions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|disabled_builtin
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|disabled_builtin
modifier|*
name|next
decl_stmt|;
block|}
name|disabled_builtin
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|disabled_builtin
modifier|*
name|disabled_builtins
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|bool
name|builtin_function_disabled_p
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Disable a built-in function specified by -fno-builtin-NAME.  If NAME    begins with "__builtin_", give an error.  */
end_comment

begin_function
name|void
name|disable_builtin_function
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_"
argument_list|,
name|strlen
argument_list|(
literal|"__builtin_"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"cannot disable built-in function %qs"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|disabled_builtin
modifier|*
name|new_disabled_builtin
init|=
name|XNEW
argument_list|(
name|disabled_builtin
argument_list|)
decl_stmt|;
name|new_disabled_builtin
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new_disabled_builtin
operator|->
name|next
operator|=
name|disabled_builtins
expr_stmt|;
name|disabled_builtins
operator|=
name|new_disabled_builtin
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the built-in function NAME has been disabled, false    otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|builtin_function_disabled_p
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|disabled_builtin
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|disabled_builtins
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Worker for DEF_BUILTIN.    Possibly define a builtin function with one or two names.    Does not declare a non-__builtin_ function if flag_no_builtin, or if    nonansi_p and flag_no_nonansi_builtin.  */
end_comment

begin_function
specifier|static
name|void
name|def_builtin_1
parameter_list|(
name|enum
name|built_in_function
name|fncode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|built_in_class
name|fnclass
parameter_list|,
name|tree
name|fntype
parameter_list|,
name|tree
name|libtype
parameter_list|,
name|bool
name|both_p
parameter_list|,
name|bool
name|fallback_p
parameter_list|,
name|bool
name|nonansi_p
parameter_list|,
name|tree
name|fnattrs
parameter_list|,
name|bool
name|implicit_p
parameter_list|)
block|{
name|tree
name|decl
decl_stmt|;
specifier|const
name|char
modifier|*
name|libname
decl_stmt|;
if|if
condition|(
name|fntype
operator|==
name|error_mark_node
condition|)
return|return;
name|gcc_assert
argument_list|(
operator|(
operator|!
name|both_p
operator|&&
operator|!
name|fallback_p
operator|)
operator|||
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_"
argument_list|,
name|strlen
argument_list|(
literal|"__builtin_"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|libname
operator|=
name|name
operator|+
name|strlen
argument_list|(
literal|"__builtin_"
argument_list|)
expr_stmt|;
name|decl
operator|=
name|lang_hooks
operator|.
name|builtin_function
argument_list|(
name|name
argument_list|,
name|fntype
argument_list|,
name|fncode
argument_list|,
name|fnclass
argument_list|,
operator|(
name|fallback_p
condition|?
name|libname
else|:
name|NULL
operator|)
argument_list|,
name|fnattrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|both_p
operator|&&
operator|!
name|flag_no_builtin
operator|&&
operator|!
name|builtin_function_disabled_p
argument_list|(
name|libname
argument_list|)
operator|&&
operator|!
operator|(
name|nonansi_p
operator|&&
name|flag_no_nonansi_builtin
operator|)
condition|)
name|lang_hooks
operator|.
name|builtin_function
argument_list|(
name|libname
argument_list|,
name|libtype
argument_list|,
name|fncode
argument_list|,
name|fnclass
argument_list|,
name|NULL
argument_list|,
name|fnattrs
argument_list|)
expr_stmt|;
name|built_in_decls
index|[
operator|(
name|int
operator|)
name|fncode
index|]
operator|=
name|decl
expr_stmt|;
if|if
condition|(
name|implicit_p
condition|)
name|implicit_built_in_decls
index|[
operator|(
name|int
operator|)
name|fncode
index|]
operator|=
name|decl
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if the type T promotes to int.  This is (nearly) the    integral promotions defined in ISO C99 6.3.1.1/2.  */
end_comment

begin_function
name|bool
name|c_promoting_integer_type_p
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
return|return
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|char_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|signed_char_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|unsigned_char_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|short_integer_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|short_unsigned_type_node
operator|||
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
return|;
case|case
name|ENUMERAL_TYPE
case|:
comment|/* ??? Technically all enumerations not larger than an int 	 promote to an int.  But this is used along code paths 	 that only want to notice a size change.  */
return|return
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
return|;
case|case
name|BOOLEAN_TYPE
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if PARMS specifies a fixed number of parameters    and none of their types is affected by default promotions.  */
end_comment

begin_function
name|int
name|self_promoting_args_p
parameter_list|(
name|tree
name|parms
parameter_list|)
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|parms
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Recursively examines the array elements of TYPE, until a non-array    element type is found.  */
end_comment

begin_function
name|tree
name|strip_array_types
parameter_list|(
name|tree
name|type
parameter_list|)
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Recursively remove any '*' or '&' operator from TYPE.  */
end_comment

begin_function
name|tree
name|strip_pointer_operator
parameter_list|(
name|tree
name|t
parameter_list|)
block|{
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
name|t
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Used to compare case labels.  K1 and K2 are actually tree nodes    representing case labels, or NULL_TREE for a `default' label.    Returns -1 if K1 is ordered before K2, -1 if K1 is ordered after    K2, and 0 if K1 and K2 are equal.  */
end_comment

begin_function
name|int
name|case_compare
parameter_list|(
name|splay_tree_key
name|k1
parameter_list|,
name|splay_tree_key
name|k2
parameter_list|)
block|{
comment|/* Consider a NULL key (such as arises with a `default' label) to be      smaller than anything else.  */
if|if
condition|(
operator|!
name|k1
condition|)
return|return
name|k2
condition|?
operator|-
literal|1
else|:
literal|0
return|;
elseif|else
if|if
condition|(
operator|!
name|k2
condition|)
return|return
name|k1
condition|?
literal|1
else|:
literal|0
return|;
return|return
name|tree_int_cst_compare
argument_list|(
operator|(
name|tree
operator|)
name|k1
argument_list|,
operator|(
name|tree
operator|)
name|k2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process a case label for the range LOW_VALUE ... HIGH_VALUE.  If    LOW_VALUE and HIGH_VALUE are both NULL_TREE then this case label is    actually a `default' label.  If only HIGH_VALUE is NULL_TREE, then    case label was declared using the usual C/C++ syntax, rather than    the GNU case range extension.  CASES is a tree containing all the    case ranges processed so far; COND is the condition for the    switch-statement itself.  Returns the CASE_LABEL_EXPR created, or    ERROR_MARK_NODE if no CASE_LABEL_EXPR is created.  */
end_comment

begin_function
name|tree
name|c_add_case_label
parameter_list|(
name|splay_tree
name|cases
parameter_list|,
name|tree
name|cond
parameter_list|,
name|tree
name|orig_type
parameter_list|,
name|tree
name|low_value
parameter_list|,
name|tree
name|high_value
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|label
decl_stmt|;
name|tree
name|case_label
decl_stmt|;
name|splay_tree_node
name|node
decl_stmt|;
comment|/* Create the LABEL_DECL itself.  */
name|label
operator|=
name|create_artificial_label
argument_list|()
expr_stmt|;
comment|/* If there was an error processing the switch condition, bail now      before we get more confused.  */
if|if
condition|(
operator|!
name|cond
operator|||
name|cond
operator|==
name|error_mark_node
condition|)
goto|goto
name|error_out
goto|;
if|if
condition|(
operator|(
name|low_value
operator|&&
name|TREE_TYPE
argument_list|(
name|low_value
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|low_value
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|high_value
operator|&&
name|TREE_TYPE
argument_list|(
name|high_value
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|high_value
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"pointers are not permitted as case values"
argument_list|)
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
comment|/* Case ranges are a GNU extension.  */
if|if
condition|(
name|high_value
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"range expressions in switch statements are non-standard"
argument_list|)
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|low_value
condition|)
block|{
name|low_value
operator|=
name|check_case_value
argument_list|(
name|low_value
argument_list|)
expr_stmt|;
name|low_value
operator|=
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|low_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|low_value
operator|==
name|error_mark_node
condition|)
goto|goto
name|error_out
goto|;
block|}
if|if
condition|(
name|high_value
condition|)
block|{
name|high_value
operator|=
name|check_case_value
argument_list|(
name|high_value
argument_list|)
expr_stmt|;
name|high_value
operator|=
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|high_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|high_value
operator|==
name|error_mark_node
condition|)
goto|goto
name|error_out
goto|;
block|}
if|if
condition|(
name|low_value
operator|&&
name|high_value
condition|)
block|{
comment|/* If the LOW_VALUE and HIGH_VALUE are the same, then this isn't 	 really a case range, even though it was written that way. 	 Remove the HIGH_VALUE to simplify later processing.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|)
condition|)
name|high_value
operator|=
name|NULL_TREE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|tree_int_cst_lt
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|)
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"empty range specified"
argument_list|)
expr_stmt|;
block|}
comment|/* See if the case is in range of the type of the original testing      expression.  If both low_value and high_value are out of range,      don't insert the case label and return NULL_TREE.  */
if|if
condition|(
name|low_value
operator|&&
operator|!
name|check_case_bounds
argument_list|(
name|type
argument_list|,
name|orig_type
argument_list|,
operator|&
name|low_value
argument_list|,
name|high_value
condition|?
operator|&
name|high_value
else|:
name|NULL
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Look up the LOW_VALUE in the table of case labels we already      have.  */
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|)
expr_stmt|;
comment|/* If there was not an exact match, check for overlapping ranges.      There's no need to do this if there's no LOW_VALUE or HIGH_VALUE;      that's a `default' label and the only overlap is an exact match.  */
if|if
condition|(
operator|!
name|node
operator|&&
operator|(
name|low_value
operator|||
name|high_value
operator|)
condition|)
block|{
name|splay_tree_node
name|low_bound
decl_stmt|;
name|splay_tree_node
name|high_bound
decl_stmt|;
comment|/* Even though there wasn't an exact match, there might be an 	 overlap between this case range and another case range. 	 Since we've (inductively) not allowed any overlapping case 	 ranges, we simply need to find the greatest low case label 	 that is smaller that LOW_VALUE, and the smallest low case 	 label that is greater than LOW_VALUE.  If there is an overlap 	 it will occur in one of these two ranges.  */
name|low_bound
operator|=
name|splay_tree_predecessor
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|)
expr_stmt|;
name|high_bound
operator|=
name|splay_tree_successor
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|)
expr_stmt|;
comment|/* Check to see if the LOW_BOUND overlaps.  It is smaller than 	 the LOW_VALUE, so there is no need to check unless the 	 LOW_BOUND is in fact itself a case range.  */
if|if
condition|(
name|low_bound
operator|&&
name|CASE_HIGH
argument_list|(
operator|(
name|tree
operator|)
name|low_bound
operator|->
name|value
argument_list|)
operator|&&
name|tree_int_cst_compare
argument_list|(
name|CASE_HIGH
argument_list|(
operator|(
name|tree
operator|)
name|low_bound
operator|->
name|value
argument_list|)
argument_list|,
name|low_value
argument_list|)
operator|>=
literal|0
condition|)
name|node
operator|=
name|low_bound
expr_stmt|;
comment|/* Check to see if the HIGH_BOUND overlaps.  The low end of that 	 range is bigger than the low end of the current range, so we 	 are only interested if the current range is a real range, and 	 not an ordinary case label.  */
elseif|else
if|if
condition|(
name|high_bound
operator|&&
name|high_value
operator|&&
operator|(
name|tree_int_cst_compare
argument_list|(
operator|(
name|tree
operator|)
name|high_bound
operator|->
name|key
argument_list|,
name|high_value
argument_list|)
operator|<=
literal|0
operator|)
condition|)
name|node
operator|=
name|high_bound
expr_stmt|;
block|}
comment|/* If there was an overlap, issue an error.  */
if|if
condition|(
name|node
condition|)
block|{
name|tree
name|duplicate
init|=
name|CASE_LABEL
argument_list|(
operator|(
name|tree
operator|)
name|node
operator|->
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|high_value
condition|)
block|{
name|error
argument_list|(
literal|"duplicate (or overlapping) case value"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Jthis is the first entry overlapping that value"
argument_list|,
name|duplicate
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|low_value
condition|)
block|{
name|error
argument_list|(
literal|"duplicate case value"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Jpreviously used here"
argument_list|,
name|duplicate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"multiple default labels in one switch"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"%Jthis is the first default label"
argument_list|,
name|duplicate
argument_list|)
expr_stmt|;
block|}
goto|goto
name|error_out
goto|;
block|}
comment|/* Add a CASE_LABEL to the statement-tree.  */
name|case_label
operator|=
name|add_stmt
argument_list|(
name|build_case_label
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Register this case label in the splay tree.  */
name|splay_tree_insert
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|case_label
argument_list|)
expr_stmt|;
return|return
name|case_label
return|;
name|error_out
label|:
comment|/* Add a label so that the back-end doesn't think that the beginning of      the switch is unreachable.  Note that we do not add a case label, as      that just leads to duplicates and thence to failure later on.  */
if|if
condition|(
operator|!
name|cases
operator|->
name|root
condition|)
block|{
name|tree
name|t
init|=
name|create_artificial_label
argument_list|()
decl_stmt|;
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|LABEL_EXPR
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* Subroutines of c_do_switch_warnings, called via splay_tree_foreach.    Used to verify that case values match up with enumerator values.  */
end_comment

begin_function
specifier|static
name|void
name|match_case_to_enum_1
parameter_list|(
name|tree
name|key
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|label
parameter_list|)
block|{
name|char
name|buf
index|[
literal|2
operator|+
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|/
literal|4
operator|+
literal|1
index|]
decl_stmt|;
comment|/* ??? Not working too hard to print the double-word value.      Should perhaps be done with %lwd in the diagnostic routines?  */
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|key
argument_list|)
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|key
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|key
argument_list|)
operator|!=
literal|0
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"-"
name|HOST_WIDE_INT_PRINT_UNSIGNED
argument_list|,
operator|-
name|TREE_INT_CST_LOW
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|HOST_WIDE_INT_PRINT_DOUBLE_HEX
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|key
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Jcase value %qs not in enumerated type"
argument_list|,
name|CASE_LABEL
argument_list|(
name|label
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Jcase value %qs not in enumerated type %qT"
argument_list|,
name|CASE_LABEL
argument_list|(
name|label
argument_list|)
argument_list|,
name|buf
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of c_do_switch_warnings, called via splay_tree_foreach.    Used to verify that case values match up with enumerator values.  */
end_comment

begin_function
specifier|static
name|int
name|match_case_to_enum
parameter_list|(
name|splay_tree_node
name|node
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|tree
name|label
init|=
operator|(
name|tree
operator|)
name|node
operator|->
name|value
decl_stmt|;
name|tree
name|type
init|=
operator|(
name|tree
operator|)
name|data
decl_stmt|;
comment|/* Skip default case.  */
if|if
condition|(
operator|!
name|CASE_LOW
argument_list|(
name|label
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If CASE_LOW_SEEN is not set, that means CASE_LOW did not appear      when we did our enum->case scan.  Reset our scratch bit after.  */
if|if
condition|(
operator|!
name|CASE_LOW_SEEN
argument_list|(
name|label
argument_list|)
condition|)
name|match_case_to_enum_1
argument_list|(
name|CASE_LOW
argument_list|(
name|label
argument_list|)
argument_list|,
name|type
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|else
name|CASE_LOW_SEEN
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If CASE_HIGH is non-null, we have a range.  If CASE_HIGH_SEEN is      not set, that means that CASE_HIGH did not appear when we did our      enum->case scan.  Reset our scratch bit after.  */
if|if
condition|(
name|CASE_HIGH
argument_list|(
name|label
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|CASE_HIGH_SEEN
argument_list|(
name|label
argument_list|)
condition|)
name|match_case_to_enum_1
argument_list|(
name|CASE_HIGH
argument_list|(
name|label
argument_list|)
argument_list|,
name|type
argument_list|,
name|label
argument_list|)
expr_stmt|;
else|else
name|CASE_HIGH_SEEN
argument_list|(
name|label
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Handle -Wswitch*.  Called from the front end after parsing the    switch construct.  */
end_comment

begin_comment
comment|/* ??? Should probably be somewhere generic, since other languages    besides C and C++ would want this.  At the moment, however, C/C++    are the only tree-ssa languages that support enumerations at all,    so the point is moot.  */
end_comment

begin_function
name|void
name|c_do_switch_warnings
parameter_list|(
name|splay_tree
name|cases
parameter_list|,
name|location_t
name|switch_location
parameter_list|,
name|tree
name|type
parameter_list|,
name|tree
name|cond
parameter_list|)
block|{
name|splay_tree_node
name|default_node
decl_stmt|;
name|splay_tree_node
name|node
decl_stmt|;
name|tree
name|chain
decl_stmt|;
if|if
condition|(
operator|!
name|warn_switch
operator|&&
operator|!
name|warn_switch_enum
operator|&&
operator|!
name|warn_switch_default
condition|)
return|return;
name|default_node
operator|=
name|splay_tree_lookup
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|default_node
condition|)
name|warning
argument_list|(
name|OPT_Wswitch_default
argument_list|,
literal|"%Hswitch missing default case"
argument_list|,
operator|&
name|switch_location
argument_list|)
expr_stmt|;
comment|/* From here on, we only care about about enumerated types.  */
if|if
condition|(
operator|!
name|type
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
return|return;
comment|/* If the switch expression was an enumerated type, check that      exactly all enumeration literals are covered by the cases.      The check is made when -Wswitch was specified and there is no      default case, or when -Wswitch-enum was specified.  */
if|if
condition|(
operator|!
name|warn_switch_enum
operator|&&
operator|!
operator|(
name|warn_switch
operator|&&
operator|!
name|default_node
operator|)
condition|)
return|return;
comment|/* Clearing COND if it is not an integer constant simplifies      the tests inside the loop below.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cond
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|cond
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* The time complexity here is O(N*lg(N)) worst case, but for the       common case of monotonically increasing enumerators, it is       O(N), since the nature of the splay tree will keep the next       element adjacent to the root at all times.  */
for|for
control|(
name|chain
operator|=
name|TYPE_VALUES
argument_list|(
name|type
argument_list|)
init|;
name|chain
condition|;
name|chain
operator|=
name|TREE_CHAIN
argument_list|(
name|chain
argument_list|)
control|)
block|{
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|chain
argument_list|)
decl_stmt|;
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
comment|/* Mark the CASE_LOW part of the case entry as seen.  */
name|tree
name|label
init|=
operator|(
name|tree
operator|)
name|node
operator|->
name|value
decl_stmt|;
name|CASE_LOW_SEEN
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* Even though there wasn't an exact match, there might be a 	 case range which includes the enumator's value.  */
name|node
operator|=
name|splay_tree_predecessor
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|&&
name|CASE_HIGH
argument_list|(
operator|(
name|tree
operator|)
name|node
operator|->
name|value
argument_list|)
condition|)
block|{
name|tree
name|label
init|=
operator|(
name|tree
operator|)
name|node
operator|->
name|value
decl_stmt|;
name|int
name|cmp
init|=
name|tree_int_cst_compare
argument_list|(
name|CASE_HIGH
argument_list|(
name|label
argument_list|)
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmp
operator|>=
literal|0
condition|)
block|{
comment|/* If we match the upper bound exactly, mark the CASE_HIGH 		 part of the case entry as seen.  */
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
name|CASE_HIGH_SEEN
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* We've now determined that this enumerated literal isn't 	 handled by the case labels of the switch statement.  */
comment|/* If the switch expression is a constant, we only really care 	 about whether that constant is handled by the switch.  */
if|if
condition|(
name|cond
operator|&&
name|tree_int_cst_compare
argument_list|(
name|cond
argument_list|,
name|value
argument_list|)
condition|)
continue|continue;
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Henumeration value %qE not handled in switch"
argument_list|,
operator|&
name|switch_location
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Warn if there are case expressions that don't correspond to      enumerators.  This can occur since C and C++ don't enforce      type-checking of assignments to enumeration variables.       The time complexity here is now always O(N) worst case, since      we should have marked both the lower bound and upper bound of      every disjoint case label, with CASE_LOW_SEEN and CASE_HIGH_SEEN      above.  This scan also resets those fields.  */
name|splay_tree_foreach
argument_list|(
name|cases
argument_list|,
name|match_case_to_enum
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish an expression taking the address of LABEL (an    IDENTIFIER_NODE).  Returns an expression for the address.  */
end_comment

begin_function
name|tree
name|finish_label_address_expr
parameter_list|(
name|tree
name|label
parameter_list|)
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"taking the address of a label is non-standard"
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|error_mark_node
condition|)
return|return
name|error_mark_node
return|;
name|label
operator|=
name|lookup_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL_TREE
condition|)
name|result
operator|=
name|null_pointer_node
expr_stmt|;
else|else
block|{
name|TREE_USED
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|label
argument_list|)
expr_stmt|;
comment|/* The current function in not necessarily uninlinable. 	 Computed gotos are incompatible with inlining, but the value 	 here could be used only in a diagnostic, for example.  */
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Hook used by expand_expr to expand language-specific tree codes.  */
end_comment

begin_comment
comment|/* The only things that should go here are bits needed to expand    constant initializers.  Everything else should be handled by the    gimplification routines.  */
end_comment

begin_function
name|rtx
name|c_expand_expr
parameter_list|(
name|tree
name|exp
parameter_list|,
name|rtx
name|target
parameter_list|,
name|enum
name|machine_mode
name|tmode
parameter_list|,
name|int
name|modifier
comment|/* Actually enum_modifier.  */
parameter_list|,
name|rtx
modifier|*
name|alt_rtl
parameter_list|)
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|COMPOUND_LITERAL_EXPR
case|:
block|{
comment|/* Initialize the anonymous variable declared in the compound 	   literal, then return the variable.  */
name|tree
name|decl
init|=
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|emit_local_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|expand_expr_real
argument_list|(
name|decl
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|alt_rtl
argument_list|)
return|;
block|}
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hook used by staticp to handle language-specific tree codes.  */
end_comment

begin_function
name|tree
name|c_staticp
parameter_list|(
name|tree
name|exp
parameter_list|)
block|{
return|return
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
operator|&&
name|TREE_STATIC
argument_list|(
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|?
name|exp
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a boolean expression ARG, return a tree representing an increment    or decrement (as indicated by CODE) of ARG.  The front end must check for    invalid cases (e.g., decrement in C++).  */
end_comment

begin_function
name|tree
name|boolean_increment
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|tree
name|arg
parameter_list|)
block|{
name|tree
name|val
decl_stmt|;
name|tree
name|true_res
init|=
name|boolean_true_node
decl_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
name|val
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|true_res
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTINCREMENT_EXPR
case|:
name|val
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|true_res
argument_list|)
expr_stmt|;
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|val
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREDECREMENT_EXPR
case|:
name|val
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTDECREMENT_EXPR
case|:
name|val
operator|=
name|build2
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|val
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build2
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Built-in macros for stddef.h, that require macros defined in this    file.  */
end_comment

begin_function
name|void
name|c_stddef_cpp_builtins
parameter_list|(
name|void
parameter_list|)
block|{
name|builtin_define_with_value
argument_list|(
literal|"__SIZE_TYPE__"
argument_list|,
name|SIZE_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
literal|"__PTRDIFF_TYPE__"
argument_list|,
name|PTRDIFF_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
literal|"__WCHAR_TYPE__"
argument_list|,
name|MODIFIED_WCHAR_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
literal|"__WINT_TYPE__"
argument_list|,
name|WINT_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
literal|"__INTMAX_TYPE__"
argument_list|,
name|INTMAX_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|builtin_define_with_value
argument_list|(
literal|"__UINTMAX_TYPE__"
argument_list|,
name|UINTMAX_TYPE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|c_init_attributes
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Fill in the built_in_attributes array.  */
define|#
directive|define
name|DEF_ATTR_NULL_TREE
parameter_list|(
name|ENUM
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM] = NULL_TREE;
define|#
directive|define
name|DEF_ATTR_INT
parameter_list|(
name|ENUM
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM] = build_int_cst (NULL_TREE, VALUE);
define|#
directive|define
name|DEF_ATTR_IDENT
parameter_list|(
name|ENUM
parameter_list|,
name|STRING
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM] = get_identifier (STRING);
define|#
directive|define
name|DEF_ATTR_TREE_LIST
parameter_list|(
name|ENUM
parameter_list|,
name|PURPOSE
parameter_list|,
name|VALUE
parameter_list|,
name|CHAIN
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM]			\     = tree_cons (built_in_attributes[(int) PURPOSE],	\ 		 built_in_attributes[(int) VALUE],	\ 		 built_in_attributes[(int) CHAIN]);
include|#
directive|include
file|"builtin-attrs.def"
undef|#
directive|undef
name|DEF_ATTR_NULL_TREE
undef|#
directive|undef
name|DEF_ATTR_INT
undef|#
directive|undef
name|DEF_ATTR_IDENT
undef|#
directive|undef
name|DEF_ATTR_TREE_LIST
block|}
end_function

begin_comment
comment|/* Attribute handlers common to C front ends.  */
end_comment

begin_comment
comment|/* Handle a "packed" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_packed_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|node
operator|=
name|build_variant_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TYPE_PACKED
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FIELD_DECL
condition|)
block|{
if|if
condition|(
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
operator|<=
name|BITS_PER_UNIT
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored for field of type %qT"
argument_list|,
name|name
argument_list|,
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|DECL_PACKED
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* We can't set DECL_PACKED for a VAR_DECL, because the bit is      used for DECL_REGISTER.  It wouldn't mean anything anyway.      We can't set DECL_PACKED on the type of a TYPE_DECL, because      that changes what the typedef is typing.  */
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "nocommon" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_nocommon_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_COMMON
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "common" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_common_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_COMMON
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "noreturn" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_noreturn_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
decl_stmt|;
comment|/* See FIXME comment in c_common_attribute_table.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "noinline" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_noinline_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_UNINLINABLE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "always_inline" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_always_inline_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Do nothing else, just set the attribute.  We'll get at 	 it later with lookup_attribute.  */
block|}
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "gnu_inline" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_gnu_inline_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_DECLARED_INLINE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
comment|/* Do nothing else, just set the attribute.  We'll get at 	 it later with lookup_attribute.  */
block|}
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "flatten" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_flatten_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
name|ATTRIBUTE_UNUSED
parameter_list|,
name|int
name|flags
name|ATTRIBUTE_UNUSED
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
comment|/* Do nothing else, just set the attribute.  We'll get at        it later with lookup_attribute.  */
empty_stmt|;
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "used" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_used_attribute
parameter_list|(
name|tree
modifier|*
name|pnode
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|node
init|=
operator|*
name|pnode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_STATIC
argument_list|(
name|node
argument_list|)
operator|)
condition|)
block|{
name|TREE_USED
argument_list|(
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_PRESERVE_P
argument_list|(
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "unused" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_unused_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|LABEL_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|node
operator|=
name|build_variant_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TREE_USED
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "externally_visible" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_externally_visible_attribute
parameter_list|(
name|tree
modifier|*
name|pnode
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|node
init|=
operator|*
name|pnode
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|TREE_STATIC
argument_list|(
name|node
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|node
argument_list|)
operator|)
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute have effect only on public objects"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "const" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_const_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
decl_stmt|;
comment|/* See FIXME comment on noreturn in c_common_attribute_table.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_READONLY
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "transparent_union" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_transparent_union_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|type
init|=
name|NULL
decl_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
goto|goto
name|ignored
goto|;
name|node
operator|=
operator|&
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|type
operator|=
operator|*
name|node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
name|type
operator|=
operator|*
name|node
expr_stmt|;
else|else
goto|goto
name|ignored
goto|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
comment|/* When IN_PLACE is set, leave the check for FIELDS and MODE to 	 the code in finish_struct.  */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|==
name|NULL_TREE
operator|||
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
goto|goto
name|ignored
goto|;
comment|/* A type variant isn't good enough, since we don't a cast 	     to such a type removed as a no-op.  */
operator|*
name|node
operator|=
name|type
operator|=
name|build_duplicate_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|ignored
label|:
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "constructor" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_constructor_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "destructor" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_destructor_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "mode" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_mode_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|tree
name|typefm
decl_stmt|;
name|bool
name|valid_mode
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|newp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|-
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|newp
argument_list|,
operator|&
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|newp
index|[
name|len
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|newp
expr_stmt|;
block|}
comment|/* Change this type to have a type with the specified mode. 	 First check for the special modes.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"byte"
argument_list|)
condition|)
name|mode
operator|=
name|byte_mode
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"word"
argument_list|)
condition|)
name|mode
operator|=
name|word_mode
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"pointer"
argument_list|)
condition|)
name|mode
operator|=
name|ptr_mode
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_MACHINE_MODES
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
block|{
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
name|j
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
name|error
argument_list|(
literal|"unknown machine mode %qs"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|valid_mode
operator|=
name|false
expr_stmt|;
switch|switch
condition|(
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
condition|)
block|{
case|case
name|MODE_INT
case|:
case|case
name|MODE_PARTIAL_INT
case|:
case|case
name|MODE_FLOAT
case|:
case|case
name|MODE_DECIMAL_FLOAT
case|:
name|valid_mode
operator|=
name|targetm
operator|.
name|scalar_mode_supported_p
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_COMPLEX_INT
case|:
case|case
name|MODE_COMPLEX_FLOAT
case|:
name|valid_mode
operator|=
name|targetm
operator|.
name|scalar_mode_supported_p
argument_list|(
name|GET_MODE_INNER
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_VECTOR_INT
case|:
case|case
name|MODE_VECTOR_FLOAT
case|:
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"specifying vector types with "
literal|"__attribute__ ((mode)) is deprecated"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"use __attribute__ ((vector_size)) instead"
argument_list|)
expr_stmt|;
name|valid_mode
operator|=
name|vector_mode_valid_p
argument_list|(
name|mode
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|valid_mode
condition|)
block|{
name|error
argument_list|(
literal|"unable to emulate %qs"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|tree
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|tree
parameter_list|,
name|enum
name|machine_mode
parameter_list|,
name|bool
parameter_list|)
function_decl|;
if|if
condition|(
operator|!
name|targetm
operator|.
name|valid_pointer_mode
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid pointer mode %qs"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|fn
operator|=
name|build_pointer_type_for_mode
expr_stmt|;
else|else
name|fn
operator|=
name|build_reference_type_for_mode
expr_stmt|;
name|typefm
operator|=
name|fn
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|mode
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
name|typefm
operator|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_mode
argument_list|(
name|mode
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typefm
operator|==
name|NULL_TREE
condition|)
block|{
name|error
argument_list|(
literal|"no data type for mode %qs"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
comment|/* For enumeral types, copy the precision from the integer 	     type returned above.  If not an INTEGER_TYPE, we can't use 	     this mode for this type.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typefm
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"cannot use mode %qs for enumeral types"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|ATTR_FLAG_TYPE_IN_PLACE
condition|)
block|{
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|typefm
argument_list|)
expr_stmt|;
name|typefm
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
comment|/* We cannot build a type variant, as there's code that assumes 		 that TYPE_MAIN_VARIANT has the same mode.  This includes the 		 debug generators.  Instead, create a subrange type.  This 		 results in all of the enumeral values being emitted only once 		 in the original, and the subtype gets them by reference.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|typefm
operator|=
name|make_unsigned_type
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|typefm
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|typefm
operator|=
name|make_signed_type
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|typefm
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|typefm
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|VECTOR_MODE_P
argument_list|(
name|mode
argument_list|)
condition|?
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|typefm
argument_list|)
argument_list|)
else|:
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|typefm
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"mode %qs applied to inappropriate type"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
operator|*
name|node
operator|=
name|typefm
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "section" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_section_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|name
parameter_list|)
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|targetm
operator|.
name|have_named_sections
condition|)
block|{
name|user_defined_section_attribute
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|current_function_decl
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jsection attribute cannot be specified for "
literal|"local variables"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
comment|/* The decl may have already been given a section attribute 	     from a previous declaration.  Ensure they match.  */
elseif|else
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"section of %q+D conflicts with previous declaration"
argument_list|,
operator|*
name|node
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"section attribute not allowed for %q+D"
argument_list|,
operator|*
name|node
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"%Jsection attributes are not supported for this target"
argument_list|,
operator|*
name|node
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "aligned" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_aligned_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|name
parameter_list|)
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|int
name|is_type
init|=
literal|0
decl_stmt|;
name|tree
name|align_expr
init|=
operator|(
name|args
condition|?
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
else|:
name|size_int
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|decl
operator|=
operator|*
name|node
expr_stmt|;
name|type
operator|=
operator|&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|TYPE_DECL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
name|type
operator|=
name|node
operator|,
name|is_type
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"requested alignment is not a constant"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|=
name|tree_log2
argument_list|(
name|align_expr
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"requested alignment is not a power of 2"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|HOST_BITS_PER_INT
operator|-
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"requested alignment is too large"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_type
condition|)
block|{
comment|/* If we have a TYPE_DECL, then copy the type, so that we 	 don't accidentally modify a builtin type.  See pushdecl.  */
if|if
condition|(
name|decl
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|NULL_TREE
condition|)
block|{
name|tree
name|tt
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
operator|*
name|type
operator|=
name|build_variant_type_copy
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
name|DECL_ORIGINAL_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|tt
expr_stmt|;
name|TYPE_NAME
argument_list|(
operator|*
name|type
argument_list|)
operator|=
name|decl
expr_stmt|;
name|TREE_USED
argument_list|(
operator|*
name|type
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
operator|*
name|type
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|type
operator|=
name|build_variant_type_copy
argument_list|(
operator|*
name|type
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
operator|*
name|type
argument_list|)
operator|=
operator|(
literal|1
operator|<<
name|i
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|TYPE_USER_ALIGN
argument_list|(
operator|*
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|VAR_OR_FUNCTION_DECL_P
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
block|{
name|error
argument_list|(
literal|"alignment may not be specified for %q+D"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|>
operator|(
literal|1
operator|<<
name|i
operator|)
operator|*
name|BITS_PER_UNIT
condition|)
block|{
if|if
condition|(
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
condition|)
name|error
argument_list|(
literal|"alignment for %q+D was previously specified as %d "
literal|"and may not be decreased"
argument_list|,
name|decl
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"alignment for %q+D must be at least %d"
argument_list|,
name|decl
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
literal|1
operator|<<
name|i
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|DECL_USER_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "weak" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_weak_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|ARG_UNUSED
parameter_list|(
name|no_add_attrs
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|declare_weak
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle an "alias" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_alias_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
comment|/* A static variable declaration is always a tentative definition, 	 but the alias is a non-tentative definition which overrides.  */
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"%q+D defined both normally and as an alias"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
comment|/* Note that the very first time we process a nested declaration,      decl_function_context will not be set.  Indeed, *would* never      be set except for the DECL_INITIAL/DECL_EXTERNAL frobbery that      we do below.  After such frobbery, pushdecl would set the context.      In any case, this is never what we want.  */
elseif|else
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|current_function_decl
operator|==
name|NULL
condition|)
block|{
name|tree
name|id
decl_stmt|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"alias argument not a string"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|id
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This counts as a use of the object pointed to.  */
name|TREE_USED
argument_list|(
name|id
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
else|else
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"weakref"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "weakref" attribute; arguments as in struct    attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_weakref_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|name
parameter_list|)
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|attr
init|=
name|NULL_TREE
decl_stmt|;
comment|/* We must ignore the attribute when it is associated with      local-scoped decls, since attribute alias is ignored and many      such symbols do not even have a DECL_WEAK field.  */
if|if
condition|(
name|decl_function_context
argument_list|(
operator|*
name|node
argument_list|)
operator|||
name|current_function_decl
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* The idea here is that `weakref("name")' mutates into `weakref,      alias("name")', and weakref without arguments, in turn,      implicitly adds weak. */
if|if
condition|(
name|args
condition|)
block|{
name|attr
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"alias"
argument_list|)
argument_list|,
name|args
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|attr
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"weakref"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|attr
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
name|decl_attributes
argument_list|(
name|node
argument_list|,
name|attr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"alias"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%Jweakref attribute must appear before alias attribute"
argument_list|,
operator|*
name|node
argument_list|)
expr_stmt|;
comment|/* Can't call declare_weak because it wants this to be TREE_PUBLIC, 	 and that isn't supported; and because it wants to add it to 	 the list of weak decls, which isn't helpful.  */
name|DECL_WEAK
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle an "visibility" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_visibility_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|ARG_UNUSED
parameter_list|(
name|no_add_attrs
parameter_list|)
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|id
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|enum
name|symbol_visibility
name|vis
decl_stmt|;
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
comment|/* OK */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|RECORD_TYPE
operator|&&
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|!=
name|UNION_TYPE
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored on non-class types"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%qE attribute ignored because %qT is already defined"
argument_list|,
name|name
argument_list|,
operator|*
name|node
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"visibility argument not a string"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/*  If this is a type, set the visibility on the type decl.  */
if|if
condition|(
name|TYPE_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|decl
operator|=
name|TYPE_NAME
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
return|return
name|NULL_TREE
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored on types"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
name|vis
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"internal"
argument_list|)
operator|==
literal|0
condition|)
name|vis
operator|=
name|VISIBILITY_INTERNAL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"hidden"
argument_list|)
operator|==
literal|0
condition|)
name|vis
operator|=
name|VISIBILITY_HIDDEN
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"protected"
argument_list|)
operator|==
literal|0
condition|)
name|vis
operator|=
name|VISIBILITY_PROTECTED
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"visibility argument must be one of \"default\", \"hidden\", \"protected\" or \"internal\""
argument_list|)
expr_stmt|;
name|vis
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
block|}
if|if
condition|(
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|&&
name|vis
operator|!=
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|&&
name|lookup_attribute
argument_list|(
literal|"visibility"
argument_list|,
operator|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|?
name|TYPE_ATTRIBUTES
argument_list|(
operator|*
name|node
argument_list|)
else|:
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
operator|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"%qD redeclared with different visibility"
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|vis
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Go ahead and attach the attribute to the node as well.  This is needed      so we can determine whether we have VISIBILITY_DEFAULT because the      visibility was not specified, or because it was explicitly overridden      from the containing scope.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Determine the ELF symbol visibility for DECL, which is either a    variable or a function.  It is an error to use this function if a    definition of DECL is not available in this translation unit.    Returns true if the final visibility has been determined by this    function; false if the caller is free to make additional    modifications.  */
end_comment

begin_function
name|bool
name|c_determine_visibility
parameter_list|(
name|tree
name|decl
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
comment|/* If the user explicitly specified the visibility with an      attribute, honor that.  DECL_VISIBILITY will have been set during      the processing of the attribute.  We check for an explicit      attribute, rather than just checking DECL_VISIBILITY_SPECIFIED,      to distinguish the use of an attribute from the use of a "#pragma      GCC visibility push(...)"; in the latter case we still want other      considerations to be able to overrule the #pragma.  */
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"visibility"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Anything that is exported must have default visibility.  */
if|if
condition|(
name|TARGET_DLLIMPORT_DECL_ATTRIBUTES
operator|&&
name|lookup_attribute
argument_list|(
literal|"dllexport"
argument_list|,
name|DECL_ATTRIBUTES
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|VISIBILITY_DEFAULT
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|true
return|;
block|}
comment|/* Set default visibility to whatever the user supplied with      visibility_specified depending on #pragma GCC visibility.  */
if|if
condition|(
operator|!
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_VISIBILITY
argument_list|(
name|decl
argument_list|)
operator|=
name|default_visibility
expr_stmt|;
name|DECL_VISIBILITY_SPECIFIED
argument_list|(
name|decl
argument_list|)
operator|=
name|visibility_options
operator|.
name|inpragma
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Handle an "tls_model" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_tls_model_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|id
decl_stmt|;
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|enum
name|tls_model
name|kind
decl_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|!
name|DECL_THREAD_LOCAL_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|kind
operator|=
name|DECL_TLS_MODEL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"tls_model argument not a string"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"local-exec"
argument_list|)
condition|)
name|kind
operator|=
name|TLS_MODEL_LOCAL_EXEC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"initial-exec"
argument_list|)
condition|)
name|kind
operator|=
name|TLS_MODEL_INITIAL_EXEC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"local-dynamic"
argument_list|)
condition|)
name|kind
operator|=
name|optimize
condition|?
name|TLS_MODEL_LOCAL_DYNAMIC
else|:
name|TLS_MODEL_GLOBAL_DYNAMIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|,
literal|"global-dynamic"
argument_list|)
condition|)
name|kind
operator|=
name|TLS_MODEL_GLOBAL_DYNAMIC
expr_stmt|;
else|else
name|error
argument_list|(
literal|"tls_model argument must be one of \"local-exec\", \"initial-exec\", \"local-dynamic\" or \"global-dynamic\""
argument_list|)
expr_stmt|;
name|DECL_TLS_MODEL
argument_list|(
name|decl
argument_list|)
operator|=
name|kind
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "no_instrument_function" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_no_instrument_function_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%J%qE attribute applies only to functions"
argument_list|,
name|decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jcan%'t set %qE attribute after definition"
argument_list|,
name|decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "malloc" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_malloc_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
argument_list|)
condition|)
name|DECL_IS_MALLOC
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "returns_twice" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_returns_twice_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_IS_RETURNS_TWICE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "no_limit_stack" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_no_limit_stack_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error
argument_list|(
literal|"%J%qE attribute applies only to functions"
argument_list|,
name|decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%Jcan%'t set %qE attribute after definition"
argument_list|,
name|decl
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
name|DECL_NO_LIMIT_STACK
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "pure" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_pure_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_IS_PURE
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ??? TODO: Support types.  */
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "no vops" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_novops_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|name
parameter_list|)
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|ARG_UNUSED
parameter_list|(
name|no_add_attrs
parameter_list|)
parameter_list|)
block|{
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
argument_list|)
expr_stmt|;
name|DECL_IS_NOVOPS
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "deprecated" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_deprecated_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|warn
init|=
literal|0
decl_stmt|;
name|tree
name|what
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|DECL_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|TREE_DEPRECATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|warn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_P
argument_list|(
operator|*
name|node
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|int
operator|)
name|ATTR_FLAG_TYPE_IN_PLACE
operator|)
condition|)
operator|*
name|node
operator|=
name|build_variant_type_copy
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|TREE_DEPRECATED
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
name|type
operator|=
operator|*
name|node
expr_stmt|;
block|}
else|else
name|warn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|type
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
name|what
operator|=
name|TYPE_NAME
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|what
operator|=
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|what
condition|)
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored for %qE"
argument_list|,
name|name
argument_list|,
name|what
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "vector_size" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_vector_size_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|vecsize
decl_stmt|,
name|nunits
decl_stmt|;
name|enum
name|machine_mode
name|orig_mode
decl_stmt|;
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|,
name|new_type
decl_stmt|,
name|size
decl_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
name|size
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host_integerp
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Get the vector size (in bytes).  */
name|vecsize
operator|=
name|tree_low_cst
argument_list|(
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We need to provide for vector pointers, vector arrays, and      functions returning vectors.  For example:         __attribute__((vector_size(16))) short *foo;       In this case, the mode is SI, but the type being modified is      HI, so we need to look further.  */
while|while
condition|(
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|METHOD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Get the mode of the type being modified.  */
name|orig_mode
operator|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VECTOR_TYPE
operator|||
operator|(
operator|!
name|SCALAR_FLOAT_MODE_P
argument_list|(
name|orig_mode
argument_list|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|orig_mode
argument_list|)
operator|!=
name|MODE_INT
operator|)
operator|||
operator|!
name|host_integerp
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid vector type for attribute %qE"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|vecsize
operator|%
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"vector size not an integral multiple of component size"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|vecsize
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"zero vector size"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Calculate how many units fit in the vector.  */
name|nunits
operator|=
name|vecsize
operator|/
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nunits
operator|&
operator|(
name|nunits
operator|-
literal|1
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"number of components of the vector not a power of two"
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|new_type
operator|=
name|build_vector_type
argument_list|(
name|type
argument_list|,
name|nunits
argument_list|)
expr_stmt|;
comment|/* Build back pointers if needed.  */
operator|*
name|node
operator|=
name|reconstruct_complex_type
argument_list|(
operator|*
name|node
argument_list|,
name|new_type
argument_list|)
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle the "nonnull" attribute.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_nonnull_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|name
parameter_list|)
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|type
init|=
operator|*
name|node
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|attr_arg_num
decl_stmt|;
comment|/* If no arguments are specified, all pointer arguments should be      non-null.  Verify a full prototype is given so that the arguments      will have the correct types when we actually check them later.  */
if|if
condition|(
operator|!
name|args
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"nonnull attribute without arguments on a non-prototype"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
comment|/* Argument list specified.  Verify that each argument number references      a pointer argument.  */
for|for
control|(
name|attr_arg_num
operator|=
literal|1
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|tree
name|argument
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|arg_num
init|=
literal|0
decl_stmt|,
name|ck_num
decl_stmt|;
if|if
condition|(
operator|!
name|get_nonnull_operand
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
operator|&
name|arg_num
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"nonnull argument has invalid operand number (argument %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|attr_arg_num
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|argument
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument
condition|)
block|{
for|for
control|(
name|ck_num
operator|=
literal|1
init|;
condition|;
name|ck_num
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|argument
operator|||
name|ck_num
operator|==
name|arg_num
condition|)
break|break;
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|argument
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|==
name|VOID_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"nonnull argument with out-of-range operand number (argument %lu, operand %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|attr_arg_num
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|arg_num
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"nonnull argument references non-pointer operand (argument %lu, operand %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|attr_arg_num
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|arg_num
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Check the argument list of a function call for null in argument slots    that are marked as requiring a non-null pointer argument.  */
end_comment

begin_function
specifier|static
name|void
name|check_function_nonnull
parameter_list|(
name|tree
name|attrs
parameter_list|,
name|tree
name|params
parameter_list|)
block|{
name|tree
name|a
decl_stmt|,
name|args
decl_stmt|,
name|param
decl_stmt|;
name|int
name|param_num
decl_stmt|;
for|for
control|(
name|a
operator|=
name|attrs
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"nonnull"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
block|{
name|args
operator|=
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* Walk the argument list.  If we encounter an argument number we 	     should check for non-null, do it.  If the attribute has no args, 	     then every pointer argument is checked (in which case the check 	     for pointer type is done in check_nonnull_arg).  */
for|for
control|(
name|param
operator|=
name|params
operator|,
name|param_num
operator|=
literal|1
init|;
condition|;
name|param_num
operator|++
operator|,
name|param
operator|=
name|TREE_CHAIN
argument_list|(
name|param
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|param
condition|)
break|break;
if|if
condition|(
operator|!
name|args
operator|||
name|nonnull_check_p
argument_list|(
name|args
argument_list|,
name|param_num
argument_list|)
condition|)
name|check_function_arguments_recurse
argument_list|(
name|check_nonnull_arg
argument_list|,
name|NULL
argument_list|,
name|TREE_VALUE
argument_list|(
name|param
argument_list|)
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check that the Nth argument of a function call (counting backwards    from the end) is a (pointer)0.  */
end_comment

begin_function
specifier|static
name|void
name|check_function_sentinel
parameter_list|(
name|tree
name|attrs
parameter_list|,
name|tree
name|params
parameter_list|,
name|tree
name|typelist
parameter_list|)
block|{
name|tree
name|attr
init|=
name|lookup_attribute
argument_list|(
literal|"sentinel"
argument_list|,
name|attrs
argument_list|)
decl_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
comment|/* Skip over the named arguments.  */
while|while
condition|(
name|typelist
operator|&&
name|params
condition|)
block|{
name|typelist
operator|=
name|TREE_CHAIN
argument_list|(
name|typelist
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typelist
operator|||
operator|!
name|params
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"not enough variable arguments to fit a sentinel"
argument_list|)
expr_stmt|;
else|else
block|{
name|tree
name|sentinel
decl_stmt|,
name|end
decl_stmt|;
name|unsigned
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
condition|)
block|{
name|tree
name|p
init|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attr
argument_list|)
argument_list|)
decl_stmt|;
name|pos
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|sentinel
operator|=
name|end
operator|=
name|params
expr_stmt|;
comment|/* Advance `end' ahead of `sentinel' by `pos' positions.  */
while|while
condition|(
name|pos
operator|>
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|pos
operator|--
expr_stmt|;
name|end
operator|=
name|TREE_CHAIN
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pos
operator|>
literal|0
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"not enough variable arguments to fit a sentinel"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now advance both until we find the last parameter.  */
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|end
operator|=
name|TREE_CHAIN
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|sentinel
operator|=
name|TREE_CHAIN
argument_list|(
name|sentinel
argument_list|)
expr_stmt|;
block|}
comment|/* Validate the sentinel.  */
if|if
condition|(
operator|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|sentinel
argument_list|)
argument_list|)
argument_list|)
operator|||
operator|!
name|integer_zerop
argument_list|(
name|TREE_VALUE
argument_list|(
name|sentinel
argument_list|)
argument_list|)
operator|)
comment|/* Although __null (in C++) is only an integer we allow it 		 nevertheless, as we are guaranteed that it's exactly 		 as wide as a pointer, and we don't want to force 		 users to cast the NULL they have written there. 		 We warn with -Wstrict-null-sentinel, though.  */
operator|&&
operator|(
name|warn_strict_null_sentinel
operator|||
name|null_node
operator|!=
name|TREE_VALUE
argument_list|(
name|sentinel
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wformat
argument_list|,
literal|"missing sentinel in function call"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper for check_function_nonnull; given a list of operands which    must be non-null in ARGS, determine if operand PARAM_NUM should be    checked.  */
end_comment

begin_function
specifier|static
name|bool
name|nonnull_check_p
parameter_list|(
name|tree
name|args
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|param_num
parameter_list|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|arg_num
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|args
condition|;
name|args
operator|=
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
control|)
block|{
name|bool
name|found
init|=
name|get_nonnull_operand
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|,
operator|&
name|arg_num
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
name|found
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_num
operator|==
name|param_num
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Check that the function argument PARAM (which is operand number    PARAM_NUM) is non-null.  This is called by check_function_nonnull    via check_function_arguments_recurse.  */
end_comment

begin_function
specifier|static
name|void
name|check_nonnull_arg
parameter_list|(
name|void
modifier|*
name|ARG_UNUSED
parameter_list|(
name|ctx
parameter_list|)
parameter_list|,
name|tree
name|param
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|param_num
parameter_list|)
block|{
comment|/* Just skip checking the argument if it's not a pointer.  This can      happen if the "nonnull" attribute was given without an operand      list (which means to check every pointer argument).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|param
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
return|return;
if|if
condition|(
name|integer_zerop
argument_list|(
name|param
argument_list|)
condition|)
name|warning
argument_list|(
name|OPT_Wnonnull
argument_list|,
literal|"null argument where non-null required "
literal|"(argument %lu)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|param_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for nonnull attribute handling; fetch the operand number    from the attribute argument list.  */
end_comment

begin_function
specifier|static
name|bool
name|get_nonnull_operand
parameter_list|(
name|tree
name|arg_num_expr
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
modifier|*
name|valp
parameter_list|)
block|{
comment|/* Verify the arg number is a constant.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|arg_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_INT_CST_HIGH
argument_list|(
name|arg_num_expr
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
operator|*
name|valp
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|arg_num_expr
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* Handle a "nothrow" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_nothrow_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
operator|*
name|node
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_NOTHROW
argument_list|(
operator|*
name|node
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* ??? TODO: Support types.  */
else|else
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "cleanup" attribute; arguments as in    struct attribute_spec.handler.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_cleanup_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|decl
init|=
operator|*
name|node
decl_stmt|;
name|tree
name|cleanup_id
decl_stmt|,
name|cleanup_decl
decl_stmt|;
comment|/* ??? Could perhaps support cleanups on TREE_STATIC, much like we do      for global destructors in C++.  This requires infrastructure that      we don't have generically at the moment.  It's also not a feature      we'd be missing too much, since we do have attribute constructor.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* Verify that the argument is a function in scope.  */
comment|/* ??? We could support pointers to functions here as well, if      that was considered desirable.  */
name|cleanup_id
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cleanup_id
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|error
argument_list|(
literal|"cleanup argument not an identifier"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
name|cleanup_decl
operator|=
name|lookup_name
argument_list|(
name|cleanup_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cleanup_decl
operator|||
name|TREE_CODE
argument_list|(
name|cleanup_decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error
argument_list|(
literal|"cleanup argument not a function"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
return|return
name|NULL_TREE
return|;
block|}
comment|/* That the function has proper type is checked with the      eventual call to build_function_call.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "warn_unused_result" attribute.  No special handling.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_warn_unused_result_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|ARG_UNUSED
parameter_list|(
name|args
parameter_list|)
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
comment|/* Ignore the attribute for functions not returning any value.  */
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Handle a "sentinel" attribute.  */
end_comment

begin_function
specifier|static
name|tree
name|handle_sentinel_attribute
parameter_list|(
name|tree
modifier|*
name|node
parameter_list|,
name|tree
name|name
parameter_list|,
name|tree
name|args
parameter_list|,
name|int
name|ARG_UNUSED
parameter_list|(
name|flags
parameter_list|)
parameter_list|,
name|bool
modifier|*
name|no_add_attrs
parameter_list|)
block|{
name|tree
name|params
init|=
name|TYPE_ARG_TYPES
argument_list|(
operator|*
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|params
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute requires prototypes with named arguments"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
condition|)
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOID_TYPE_P
argument_list|(
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|OPT_Wattributes
argument_list|,
literal|"%qE attribute only applies to variadic functions"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|args
condition|)
block|{
name|tree
name|position
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|position
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"requested position is not an integer constant"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|position
argument_list|,
name|integer_zero_node
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|0
argument_list|,
literal|"requested position is less than zero"
argument_list|)
expr_stmt|;
operator|*
name|no_add_attrs
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check for valid arguments being passed to a function.  */
end_comment

begin_function
name|void
name|check_function_arguments
parameter_list|(
name|tree
name|attrs
parameter_list|,
name|tree
name|params
parameter_list|,
name|tree
name|typelist
parameter_list|)
block|{
comment|/* Check for null being passed in a pointer argument that must be      non-null.  We also need to do this if format checking is enabled.  */
if|if
condition|(
name|warn_nonnull
condition|)
name|check_function_nonnull
argument_list|(
name|attrs
argument_list|,
name|params
argument_list|)
expr_stmt|;
comment|/* Check for errors in format strings.  */
if|if
condition|(
name|warn_format
operator|||
name|warn_missing_format_attribute
condition|)
name|check_function_format
argument_list|(
name|attrs
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_format
condition|)
name|check_function_sentinel
argument_list|(
name|attrs
argument_list|,
name|params
argument_list|,
name|typelist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generic argument checking recursion routine.  PARAM is the argument to    be checked.  PARAM_NUM is the number of the argument.  CALLBACK is invoked    once the argument is resolved.  CTX is context for the callback.  */
end_comment

begin_function
name|void
name|check_function_arguments_recurse
parameter_list|(
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|tree
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|,
name|tree
name|param
parameter_list|,
name|unsigned
name|HOST_WIDE_INT
name|param_num
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|param
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|param
argument_list|)
operator|==
name|CONVERT_EXPR
operator|)
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|param
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|param
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Strip coercion.  */
name|check_function_arguments_recurse
argument_list|(
name|callback
argument_list|,
name|ctx
argument_list|,
name|TREE_OPERAND
argument_list|(
name|param
argument_list|,
literal|0
argument_list|)
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|param
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|param
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
name|bool
name|found_format_arg
init|=
name|false
decl_stmt|;
comment|/* See if this is a call to a known internationalization function 	 that modifies a format arg.  Such a function may have multiple 	 format_arg attributes (for example, ngettext).  */
for|for
control|(
name|attrs
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|type
argument_list|)
init|;
name|attrs
condition|;
name|attrs
operator|=
name|TREE_CHAIN
argument_list|(
name|attrs
argument_list|)
control|)
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"format_arg"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|attrs
argument_list|)
argument_list|)
condition|)
block|{
name|tree
name|inner_args
decl_stmt|;
name|tree
name|format_num_expr
decl_stmt|;
name|int
name|format_num
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Extract the argument number, which was previously checked 	       to be valid.  */
name|format_num_expr
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_VALUE
argument_list|(
name|attrs
argument_list|)
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_INT_CST_HIGH
argument_list|(
name|format_num_expr
argument_list|)
argument_list|)
expr_stmt|;
name|format_num
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|format_num_expr
argument_list|)
expr_stmt|;
for|for
control|(
name|inner_args
operator|=
name|TREE_OPERAND
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
operator|,
name|i
operator|=
literal|1
init|;
name|inner_args
operator|!=
literal|0
condition|;
name|inner_args
operator|=
name|TREE_CHAIN
argument_list|(
name|inner_args
argument_list|)
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|format_num
condition|)
block|{
name|check_function_arguments_recurse
argument_list|(
name|callback
argument_list|,
name|ctx
argument_list|,
name|TREE_VALUE
argument_list|(
name|inner_args
argument_list|)
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
name|found_format_arg
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we found a format_arg attribute and did a recursive check, 	 we are done with checking this argument.  Otherwise, we continue 	 and this will be considered a non-literal.  */
if|if
condition|(
name|found_format_arg
condition|)
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|param
argument_list|)
operator|==
name|COND_EXPR
condition|)
block|{
comment|/* Check both halves of the conditional expression.  */
name|check_function_arguments_recurse
argument_list|(
name|callback
argument_list|,
name|ctx
argument_list|,
name|TREE_OPERAND
argument_list|(
name|param
argument_list|,
literal|1
argument_list|)
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
name|check_function_arguments_recurse
argument_list|(
name|callback
argument_list|,
name|ctx
argument_list|,
name|TREE_OPERAND
argument_list|(
name|param
argument_list|,
literal|2
argument_list|)
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
modifier|*
name|callback
call|)
argument_list|(
name|ctx
argument_list|,
name|param
argument_list|,
name|param_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function to help qsort sort FIELD_DECLs by name order.  */
end_comment

begin_function
name|int
name|field_decl_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|x_p
parameter_list|,
specifier|const
name|void
modifier|*
name|y_p
parameter_list|)
block|{
specifier|const
name|tree
modifier|*
specifier|const
name|x
init|=
operator|(
specifier|const
name|tree
operator|*
specifier|const
operator|)
name|x_p
decl_stmt|;
specifier|const
name|tree
modifier|*
specifier|const
name|y
init|=
operator|(
specifier|const
name|tree
operator|*
specifier|const
operator|)
name|y_p
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
operator|*
name|y
argument_list|)
condition|)
comment|/* A nontype is "greater" than a type.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|y
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|-
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|)
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|y
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|x
argument_list|)
operator|<
name|DECL_NAME
argument_list|(
operator|*
name|y
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|gt_pointer_operator
name|new_value
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
block|}
name|resort_data
struct|;
end_struct

begin_comment
comment|/* This routine compares two fields like field_decl_cmp but using the pointer operator in resort_data.  */
end_comment

begin_function
specifier|static
name|int
name|resort_field_decl_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|x_p
parameter_list|,
specifier|const
name|void
modifier|*
name|y_p
parameter_list|)
block|{
specifier|const
name|tree
modifier|*
specifier|const
name|x
init|=
operator|(
specifier|const
name|tree
operator|*
specifier|const
operator|)
name|x_p
decl_stmt|;
specifier|const
name|tree
modifier|*
specifier|const
name|y
init|=
operator|(
specifier|const
name|tree
operator|*
specifier|const
operator|)
name|y_p
decl_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
operator|*
name|y
argument_list|)
condition|)
comment|/* A nontype is "greater" than a type.  */
return|return
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|y
argument_list|)
operator|==
name|TYPE_DECL
operator|)
operator|-
operator|(
name|TREE_CODE
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|TYPE_DECL
operator|)
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|x
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|DECL_NAME
argument_list|(
operator|*
name|y
argument_list|)
operator|==
name|NULL_TREE
condition|)
return|return
literal|1
return|;
block|{
name|tree
name|d1
init|=
name|DECL_NAME
argument_list|(
operator|*
name|x
argument_list|)
decl_stmt|;
name|tree
name|d2
init|=
name|DECL_NAME
argument_list|(
operator|*
name|y
argument_list|)
decl_stmt|;
name|resort_data
operator|.
name|new_value
argument_list|(
operator|&
name|d1
argument_list|,
name|resort_data
operator|.
name|cookie
argument_list|)
expr_stmt|;
name|resort_data
operator|.
name|new_value
argument_list|(
operator|&
name|d2
argument_list|,
name|resort_data
operator|.
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|d1
operator|<
name|d2
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Resort DECL_SORTED_FIELDS because pointers have been reordered.  */
end_comment

begin_function
name|void
name|resort_sorted_fields
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|ARG_UNUSED
parameter_list|(
name|orig_obj
parameter_list|)
parameter_list|,
name|gt_pointer_operator
name|new_value
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|sorted_fields_type
modifier|*
name|sf
init|=
operator|(
expr|struct
name|sorted_fields_type
operator|*
operator|)
name|obj
decl_stmt|;
name|resort_data
operator|.
name|new_value
operator|=
name|new_value
expr_stmt|;
name|resort_data
operator|.
name|cookie
operator|=
name|cookie
expr_stmt|;
name|qsort
argument_list|(
operator|&
name|sf
operator|->
name|elts
index|[
literal|0
index|]
argument_list|,
name|sf
operator|->
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|resort_field_decl_cmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subroutine of c_parse_error.    Return the result of concatenating LHS and RHS. RHS is really    a string literal, its first character is indicated by RHS_START and    RHS_SIZE is its length (including the terminating NUL character).     The caller is responsible for deleting the returned pointer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|catenate_strings
parameter_list|(
specifier|const
name|char
modifier|*
name|lhs
parameter_list|,
specifier|const
name|char
modifier|*
name|rhs_start
parameter_list|,
name|int
name|rhs_size
parameter_list|)
block|{
specifier|const
name|int
name|lhs_size
init|=
name|strlen
argument_list|(
name|lhs
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|XNEWVEC
argument_list|(
name|char
argument_list|,
name|lhs_size
operator|+
name|rhs_size
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|lhs
argument_list|,
name|lhs_size
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
operator|+
name|lhs_size
argument_list|,
name|rhs_start
argument_list|,
name|rhs_size
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Issue the error given by GMSGID, indicating that it occurred before    TOKEN, which had the associated VALUE.  */
end_comment

begin_function
name|void
name|c_parse_error
parameter_list|(
specifier|const
name|char
modifier|*
name|gmsgid
parameter_list|,
name|enum
name|cpp_ttype
name|token
parameter_list|,
name|tree
name|value
parameter_list|)
block|{
define|#
directive|define
name|catenate_messages
parameter_list|(
name|M1
parameter_list|,
name|M2
parameter_list|)
value|catenate_strings ((M1), (M2), sizeof (M2))
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|token
operator|==
name|CPP_EOF
condition|)
name|message
operator|=
name|catenate_messages
argument_list|(
name|gmsgid
argument_list|,
literal|" at end of input"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_CHAR
operator|||
name|token
operator|==
name|CPP_WCHAR
condition|)
block|{
name|unsigned
name|int
name|val
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|ell
init|=
operator|(
name|token
operator|==
name|CPP_CHAR
operator|)
condition|?
literal|""
else|:
literal|"L"
decl_stmt|;
if|if
condition|(
name|val
operator|<=
name|UCHAR_MAX
operator|&&
name|ISGRAPH
argument_list|(
name|val
argument_list|)
condition|)
name|message
operator|=
name|catenate_messages
argument_list|(
name|gmsgid
argument_list|,
literal|" before %s'%c'"
argument_list|)
expr_stmt|;
else|else
name|message
operator|=
name|catenate_messages
argument_list|(
name|gmsgid
argument_list|,
literal|" before %s'\\x%x'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|,
name|ell
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|message
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_STRING
operator|||
name|token
operator|==
name|CPP_WSTRING
condition|)
name|message
operator|=
name|catenate_messages
argument_list|(
name|gmsgid
argument_list|,
literal|" before string constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NUMBER
condition|)
name|message
operator|=
name|catenate_messages
argument_list|(
name|gmsgid
argument_list|,
literal|" before numeric constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_NAME
condition|)
block|{
name|message
operator|=
name|catenate_messages
argument_list|(
name|gmsgid
argument_list|,
literal|" before %qE"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|message
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_PRAGMA
condition|)
name|message
operator|=
name|catenate_messages
argument_list|(
name|gmsgid
argument_list|,
literal|" before %<#pragma%>"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|==
name|CPP_PRAGMA_EOL
condition|)
name|message
operator|=
name|catenate_messages
argument_list|(
name|gmsgid
argument_list|,
literal|" before end of line"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|<
name|N_TTYPES
condition|)
block|{
name|message
operator|=
name|catenate_messages
argument_list|(
name|gmsgid
argument_list|,
literal|" before %qs token"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|message
argument_list|,
name|cpp_type2name
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|message
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|error
argument_list|(
name|gmsgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
block|{
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|catenate_messages
block|}
end_function

begin_comment
comment|/* Walk a gimplified function and warn for functions whose return value is    ignored and attribute((warn_unused_result)) is set.  This is done before    inlining, so we don't have to worry about that.  */
end_comment

begin_function
name|void
name|c_warn_unused_result
parameter_list|(
name|tree
modifier|*
name|top_p
parameter_list|)
block|{
name|tree
name|t
init|=
operator|*
name|top_p
decl_stmt|;
name|tree_stmt_iterator
name|i
decl_stmt|;
name|tree
name|fdecl
decl_stmt|,
name|ftype
decl_stmt|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|STATEMENT_LIST
case|:
for|for
control|(
name|i
operator|=
name|tsi_start
argument_list|(
operator|*
name|top_p
argument_list|)
init|;
operator|!
name|tsi_end_p
argument_list|(
name|i
argument_list|)
condition|;
name|tsi_next
argument_list|(
operator|&
name|i
argument_list|)
control|)
name|c_warn_unused_result
argument_list|(
name|tsi_stmt_ptr
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COND_EXPR
case|:
name|c_warn_unused_result
argument_list|(
operator|&
name|COND_EXPR_THEN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|c_warn_unused_result
argument_list|(
operator|&
name|COND_EXPR_ELSE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIND_EXPR
case|:
name|c_warn_unused_result
argument_list|(
operator|&
name|BIND_EXPR_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_FINALLY_EXPR
case|:
case|case
name|TRY_CATCH_EXPR
case|:
name|c_warn_unused_result
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|c_warn_unused_result
argument_list|(
operator|&
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CATCH_EXPR
case|:
name|c_warn_unused_result
argument_list|(
operator|&
name|CATCH_BODY
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|EH_FILTER_EXPR
case|:
name|c_warn_unused_result
argument_list|(
operator|&
name|EH_FILTER_FAILURE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALL_EXPR
case|:
if|if
condition|(
name|TREE_USED
argument_list|(
name|t
argument_list|)
condition|)
break|break;
comment|/* This is a naked call, as opposed to a CALL_EXPR nested inside 	 a MODIFY_EXPR.  All calls whose value is ignored should be 	 represented like this.  Look for the attribute.  */
name|fdecl
operator|=
name|get_callee_fndecl
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdecl
condition|)
name|ftype
operator|=
name|TREE_TYPE
argument_list|(
name|fdecl
argument_list|)
expr_stmt|;
else|else
block|{
name|ftype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look past pointer-to-function to the function type itself.  */
name|ftype
operator|=
name|TREE_TYPE
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lookup_attribute
argument_list|(
literal|"warn_unused_result"
argument_list|,
name|TYPE_ATTRIBUTES
argument_list|(
name|ftype
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|fdecl
condition|)
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hignoring return value of %qD, "
literal|"declared with attribute warn_unused_result"
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|t
argument_list|)
argument_list|,
name|fdecl
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|0
argument_list|,
literal|"%Hignoring return value of function "
literal|"declared with attribute warn_unused_result"
argument_list|,
name|EXPR_LOCUS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Not a container, not a call, or a call whose value is used.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Convert a character from the host to the target execution character    set.  cpplib handles this, mostly.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|c_common_to_target_charset
parameter_list|(
name|HOST_WIDE_INT
name|c
parameter_list|)
block|{
comment|/* Character constants in GCC proper are sign-extended under -fsigned-char,      zero-extended under -fno-signed-char.  cpplib insists that characters      and character constants are always unsigned.  Hence we must convert      back and forth.  */
name|cppchar_t
name|uc
init|=
operator|(
operator|(
name|cppchar_t
operator|)
name|c
operator|)
operator|&
operator|(
operator|(
operator|(
operator|(
name|cppchar_t
operator|)
literal|1
operator|)
operator|<<
name|CHAR_BIT
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|uc
operator|=
name|cpp_host_to_exec_charset
argument_list|(
name|parse_in
argument_list|,
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_signed_char
condition|)
return|return
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|uc
operator|)
operator|<<
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|CHAR_TYPE_SIZE
operator|)
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|CHAR_TYPE_SIZE
operator|)
return|;
else|else
return|return
name|uc
return|;
block|}
end_function

begin_comment
comment|/* Build the result of __builtin_offsetof.  EXPR is a nested sequence of    component references, with STOP_REF, or alternatively an INDIRECT_REF of    NULL, at the bottom; much like the traditional rendering of offsetof as a    macro.  Returns the folded and properly cast result.  */
end_comment

begin_function
specifier|static
name|tree
name|fold_offsetof_1
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|stop_ref
parameter_list|)
block|{
name|enum
name|tree_code
name|code
init|=
name|PLUS_EXPR
decl_stmt|;
name|tree
name|base
decl_stmt|,
name|off
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
name|expr
operator|==
name|stop_ref
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
return|return
name|size_zero_node
return|;
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|ERROR_MARK
case|:
return|return
name|expr
return|;
case|case
name|VAR_DECL
case|:
name|error
argument_list|(
literal|"cannot apply %<offsetof%> to static data member %qD"
argument_list|,
name|expr
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|CALL_EXPR
case|:
name|error
argument_list|(
literal|"cannot apply %<offsetof%> when %<operator[]%> is overloaded"
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
case|case
name|INTEGER_CST
case|:
name|gcc_assert
argument_list|(
name|integer_zerop
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|size_zero_node
return|;
case|case
name|NOP_EXPR
case|:
case|case
name|INDIRECT_REF
case|:
name|base
operator|=
name|fold_offsetof_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|stop_ref
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|base
operator|==
name|error_mark_node
operator|||
name|base
operator|==
name|size_zero_node
argument_list|)
expr_stmt|;
return|return
name|base
return|;
case|case
name|COMPONENT_REF
case|:
name|base
operator|=
name|fold_offsetof_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|stop_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
return|return
name|base
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_C_BIT_FIELD
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"attempt to take address of bit-field structure "
literal|"member %qD"
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|off
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|DECL_FIELD_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|,
name|size_int
argument_list|(
name|tree_low_cst
argument_list|(
name|DECL_FIELD_BIT_OFFSET
argument_list|(
name|t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY_REF
case|:
name|base
operator|=
name|fold_offsetof_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|stop_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|error_mark_node
condition|)
return|return
name|base
return|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|t
argument_list|)
operator|<
literal|0
condition|)
block|{
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
name|t
operator|=
name|fold_build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|convert
argument_list|(
name|sizetype
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|off
operator|=
name|size_binop
argument_list|(
name|MULT_EXPR
argument_list|,
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMPOUND_EXPR
case|:
comment|/* Handle static members of volatile structs.  */
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gcc_assert
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VAR_DECL
argument_list|)
expr_stmt|;
return|return
name|fold_offsetof_1
argument_list|(
name|t
argument_list|,
name|stop_ref
argument_list|)
return|;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
return|return
name|size_binop
argument_list|(
name|code
argument_list|,
name|base
argument_list|,
name|off
argument_list|)
return|;
block|}
end_function

begin_function
name|tree
name|fold_offsetof
parameter_list|(
name|tree
name|expr
parameter_list|,
name|tree
name|stop_ref
parameter_list|)
block|{
comment|/* Convert back from the internal sizetype to size_t.  */
return|return
name|convert
argument_list|(
name|size_type_node
argument_list|,
name|fold_offsetof_1
argument_list|(
name|expr
argument_list|,
name|stop_ref
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print an error message for an invalid lvalue.  USE says    how the lvalue is being used and so selects the error message.  */
end_comment

begin_function
name|void
name|lvalue_error
parameter_list|(
name|enum
name|lvalue_use
name|use
parameter_list|)
block|{
switch|switch
condition|(
name|use
condition|)
block|{
case|case
name|lv_assign
case|:
name|error
argument_list|(
literal|"lvalue required as left operand of assignment"
argument_list|)
expr_stmt|;
break|break;
case|case
name|lv_increment
case|:
name|error
argument_list|(
literal|"lvalue required as increment operand"
argument_list|)
expr_stmt|;
break|break;
case|case
name|lv_decrement
case|:
name|error
argument_list|(
literal|"lvalue required as decrement operand"
argument_list|)
expr_stmt|;
break|break;
case|case
name|lv_addressof
case|:
name|error
argument_list|(
literal|"lvalue required as unary %<&%> operand"
argument_list|)
expr_stmt|;
break|break;
case|case
name|lv_asm
case|:
name|error
argument_list|(
literal|"lvalue required in asm statement"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|gcc_unreachable
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* *PTYPE is an incomplete array.  Complete it with a domain based on    INITIAL_VALUE.  If INITIAL_VALUE is not present, use 1 if DO_DEFAULT    is true.  Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,    2 if INITIAL_VALUE was NULL, and 3 if INITIAL_VALUE was empty.  */
end_comment

begin_function
name|int
name|complete_array_type
parameter_list|(
name|tree
modifier|*
name|ptype
parameter_list|,
name|tree
name|initial_value
parameter_list|,
name|bool
name|do_default
parameter_list|)
block|{
name|tree
name|maxindex
decl_stmt|,
name|type
decl_stmt|,
name|main_type
decl_stmt|,
name|elt
decl_stmt|,
name|unqual_elt
decl_stmt|;
name|int
name|failure
init|=
literal|0
decl_stmt|,
name|quals
decl_stmt|;
name|maxindex
operator|=
name|size_zero_node
expr_stmt|;
if|if
condition|(
name|initial_value
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|int
name|eltsize
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|initial_value
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|size_int
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|initial_value
argument_list|)
operator|/
name|eltsize
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|VEC
argument_list|(
name|constructor_elt
argument_list|,
name|gc
argument_list|)
operator|*
name|v
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|VEC_empty
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|failure
operator|=
literal|3
expr_stmt|;
name|maxindex
operator|=
name|integer_minus_one_node
expr_stmt|;
block|}
else|else
block|{
name|tree
name|curindex
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|cnt
decl_stmt|;
name|constructor_elt
modifier|*
name|ce
decl_stmt|;
if|if
condition|(
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
operator|->
name|index
condition|)
name|maxindex
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|VEC_index
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
literal|0
argument_list|)
operator|->
name|index
argument_list|)
expr_stmt|;
name|curindex
operator|=
name|maxindex
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|1
init|;
name|VEC_iterate
argument_list|(
name|constructor_elt
argument_list|,
name|v
argument_list|,
name|cnt
argument_list|,
name|ce
argument_list|)
condition|;
name|cnt
operator|++
control|)
block|{
if|if
condition|(
name|ce
operator|->
name|index
condition|)
name|curindex
operator|=
name|fold_convert
argument_list|(
name|sizetype
argument_list|,
name|ce
operator|->
name|index
argument_list|)
expr_stmt|;
else|else
name|curindex
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|curindex
argument_list|,
name|size_one_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|maxindex
argument_list|,
name|curindex
argument_list|)
condition|)
name|maxindex
operator|=
name|curindex
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Make an error message unless that happened already.  */
if|if
condition|(
name|initial_value
operator|!=
name|error_mark_node
condition|)
name|failure
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|failure
operator|=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|do_default
condition|)
return|return
name|failure
return|;
block|}
name|type
operator|=
operator|*
name|ptype
expr_stmt|;
name|elt
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|quals
operator|=
name|TYPE_QUALS
argument_list|(
name|strip_array_types
argument_list|(
name|elt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
operator|==
literal|0
condition|)
name|unqual_elt
operator|=
name|elt
expr_stmt|;
else|else
name|unqual_elt
operator|=
name|c_build_qualified_type
argument_list|(
name|elt
argument_list|,
name|TYPE_UNQUALIFIED
argument_list|)
expr_stmt|;
comment|/* Using build_distinct_type_copy and modifying things afterward instead      of using build_array_type to create a new type preserves all of the      TYPE_LANG_FLAG_? bits that the front end may have set.  */
name|main_type
operator|=
name|build_distinct_type_copy
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|main_type
argument_list|)
operator|=
name|unqual_elt
expr_stmt|;
name|TYPE_DOMAIN
argument_list|(
name|main_type
argument_list|)
operator|=
name|build_index_type
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|main_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|quals
operator|==
literal|0
condition|)
name|type
operator|=
name|main_type
expr_stmt|;
else|else
name|type
operator|=
name|c_build_qualified_type
argument_list|(
name|main_type
argument_list|,
name|quals
argument_list|)
expr_stmt|;
operator|*
name|ptype
operator|=
name|type
expr_stmt|;
return|return
name|failure
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Used to help initialize the builtin-types.def table.  When a type of    the correct size doesn't exist, use error_mark_node instead of NULL.    The later results in segfaults even when a decl using the type doesn't    get invoked.  */
end_comment

begin_function
name|tree
name|builtin_type_for_size
parameter_list|(
name|int
name|size
parameter_list|,
name|bool
name|unsignedp
parameter_list|)
block|{
name|tree
name|type
init|=
name|lang_hooks
operator|.
name|types
operator|.
name|type_for_size
argument_list|(
name|size
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
return|return
name|type
condition|?
name|type
else|:
name|error_mark_node
return|;
block|}
end_function

begin_comment
comment|/* A helper function for resolve_overloaded_builtin in resolving the    overloaded __sync_ builtins.  Returns a positive power of 2 if the    first operand of PARAMS is a pointer to a supported data type.    Returns 0 if an error is encountered.  */
end_comment

begin_function
specifier|static
name|int
name|sync_resolve_size
parameter_list|(
name|tree
name|function
parameter_list|,
name|tree
name|params
parameter_list|)
block|{
name|tree
name|type
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"too few arguments to function %qE"
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|POINTER_TYPE
condition|)
goto|goto
name|incompatible
goto|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
goto|goto
name|incompatible
goto|;
name|size
operator|=
name|tree_low_cst
argument_list|(
name|TYPE_SIZE_UNIT
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
operator|||
name|size
operator|==
literal|2
operator|||
name|size
operator|==
literal|4
operator|||
name|size
operator|==
literal|8
operator|||
name|size
operator|==
literal|16
condition|)
return|return
name|size
return|;
name|incompatible
label|:
name|error
argument_list|(
literal|"incompatible type for argument %d of %qE"
argument_list|,
literal|1
argument_list|,
name|function
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A helper function for resolve_overloaded_builtin.  Adds casts to    PARAMS to make arguments match up with those of FUNCTION.  Drops    the variadic arguments at the end.  Returns false if some error    was encountered; true on success.  */
end_comment

begin_function
specifier|static
name|bool
name|sync_resolve_params
parameter_list|(
name|tree
name|orig_function
parameter_list|,
name|tree
name|function
parameter_list|,
name|tree
name|params
parameter_list|)
block|{
name|tree
name|arg_types
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|ptype
decl_stmt|;
name|int
name|number
decl_stmt|;
comment|/* We've declared the implementation functions to use "volatile void *"      as the pointer parameter, so we shouldn't get any complaints from the      call to check_function_arguments what ever type the user used.  */
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
name|ptype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|number
operator|=
literal|2
expr_stmt|;
comment|/* For the rest of the values, we need to cast these to FTYPE, so that we      don't get warnings for passing pointer types, etc.  */
while|while
condition|(
name|arg_types
operator|!=
name|void_list_node
condition|)
block|{
name|tree
name|val
decl_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"too few arguments to function %qE"
argument_list|,
name|orig_function
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
comment|/* ??? Ideally for the first conversion we'd use convert_for_assignment 	 so that we get warnings for anything that doesn't match the pointer 	 type.  This isn't portable across the C and C++ front ends atm.  */
name|val
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|val
operator|=
name|convert
argument_list|(
name|ptype
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|convert
argument_list|(
name|TREE_VALUE
argument_list|(
name|arg_types
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
operator|=
name|val
expr_stmt|;
name|arg_types
operator|=
name|TREE_CHAIN
argument_list|(
name|arg_types
argument_list|)
expr_stmt|;
name|number
operator|++
expr_stmt|;
block|}
comment|/* The definition of these primitives is variadic, with the remaining      being "an optional list of variables protected by the memory barrier".      No clue what that's supposed to mean, precisely, but we consider all      call-clobbered variables to be protected so we're safe.  */
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/* A helper function for resolve_overloaded_builtin.  Adds a cast to    RESULT to make it match the type of the first pointer argument in    PARAMS.  */
end_comment

begin_function
specifier|static
name|tree
name|sync_resolve_return
parameter_list|(
name|tree
name|params
parameter_list|,
name|tree
name|result
parameter_list|)
block|{
name|tree
name|ptype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|ptype
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|ptype
argument_list|)
expr_stmt|;
return|return
name|convert
argument_list|(
name|ptype
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Some builtin functions are placeholders for other expressions.  This    function should be called immediately after parsing the call expression    before surrounding code has committed to the type of the expression.     FUNCTION is the DECL that has been invoked; it is known to be a builtin.    PARAMS is the argument list for the call.  The return value is non-null    when expansion is complete, and null if normal processing should    continue.  */
end_comment

begin_function
name|tree
name|resolve_overloaded_builtin
parameter_list|(
name|tree
name|function
parameter_list|,
name|tree
name|params
parameter_list|)
block|{
name|enum
name|built_in_function
name|orig_code
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|function
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|function
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_NORMAL
case|:
break|break;
case|case
name|BUILT_IN_MD
case|:
if|if
condition|(
name|targetm
operator|.
name|resolve_overloaded_builtin
condition|)
return|return
name|targetm
operator|.
name|resolve_overloaded_builtin
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
return|;
else|else
return|return
name|NULL_TREE
return|;
default|default:
return|return
name|NULL_TREE
return|;
block|}
comment|/* Handle BUILT_IN_NORMAL here.  */
switch|switch
condition|(
name|orig_code
condition|)
block|{
case|case
name|BUILT_IN_FETCH_AND_ADD_N
case|:
case|case
name|BUILT_IN_FETCH_AND_SUB_N
case|:
case|case
name|BUILT_IN_FETCH_AND_OR_N
case|:
case|case
name|BUILT_IN_FETCH_AND_AND_N
case|:
case|case
name|BUILT_IN_FETCH_AND_XOR_N
case|:
case|case
name|BUILT_IN_FETCH_AND_NAND_N
case|:
case|case
name|BUILT_IN_ADD_AND_FETCH_N
case|:
case|case
name|BUILT_IN_SUB_AND_FETCH_N
case|:
case|case
name|BUILT_IN_OR_AND_FETCH_N
case|:
case|case
name|BUILT_IN_AND_AND_FETCH_N
case|:
case|case
name|BUILT_IN_XOR_AND_FETCH_N
case|:
case|case
name|BUILT_IN_NAND_AND_FETCH_N
case|:
case|case
name|BUILT_IN_BOOL_COMPARE_AND_SWAP_N
case|:
case|case
name|BUILT_IN_VAL_COMPARE_AND_SWAP_N
case|:
case|case
name|BUILT_IN_LOCK_TEST_AND_SET_N
case|:
case|case
name|BUILT_IN_LOCK_RELEASE_N
case|:
block|{
name|int
name|n
init|=
name|sync_resolve_size
argument_list|(
name|function
argument_list|,
name|params
argument_list|)
decl_stmt|;
name|tree
name|new_function
decl_stmt|,
name|result
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|error_mark_node
return|;
name|new_function
operator|=
name|built_in_decls
index|[
name|orig_code
operator|+
name|exact_log2
argument_list|(
name|n
argument_list|)
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|sync_resolve_params
argument_list|(
name|function
argument_list|,
name|new_function
argument_list|,
name|params
argument_list|)
condition|)
return|return
name|error_mark_node
return|;
name|result
operator|=
name|build_function_call
argument_list|(
name|new_function
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_code
operator|!=
name|BUILT_IN_BOOL_COMPARE_AND_SWAP_N
operator|&&
name|orig_code
operator|!=
name|BUILT_IN_LOCK_RELEASE_N
condition|)
name|result
operator|=
name|sync_resolve_return
argument_list|(
name|params
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
default|default:
return|return
name|NULL_TREE
return|;
block|}
block|}
end_function

begin_comment
comment|/* Ignoring their sign, return true if two scalar types are the same.  */
end_comment

begin_function
name|bool
name|same_scalar_type_ignoring_signedness
parameter_list|(
name|tree
name|t1
parameter_list|,
name|tree
name|t2
parameter_list|)
block|{
name|enum
name|tree_code
name|c1
init|=
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
decl_stmt|,
name|c2
init|=
name|TREE_CODE
argument_list|(
name|t2
argument_list|)
decl_stmt|;
name|gcc_assert
argument_list|(
operator|(
name|c1
operator|==
name|INTEGER_TYPE
operator|||
name|c1
operator|==
name|REAL_TYPE
operator|)
operator|&&
operator|(
name|c2
operator|==
name|INTEGER_TYPE
operator|||
name|c2
operator|==
name|REAL_TYPE
operator|)
argument_list|)
expr_stmt|;
comment|/* Equality works here because c_common_signed_type uses      TYPE_MAIN_VARIANT.  */
return|return
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|t1
argument_list|)
operator|==
name|lang_hooks
operator|.
name|types
operator|.
name|signed_type
argument_list|(
name|t2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check for missing format attributes on function pointers.  LTYPE is    the new type or left-hand side type.  RTYPE is the old type or    right-hand side type.  Returns TRUE if LTYPE is missing the desired    attribute.  */
end_comment

begin_function
name|bool
name|check_missing_format_attribute
parameter_list|(
name|tree
name|ltype
parameter_list|,
name|tree
name|rtype
parameter_list|)
block|{
name|tree
specifier|const
name|ttr
init|=
name|TREE_TYPE
argument_list|(
name|rtype
argument_list|)
decl_stmt|,
name|ttl
init|=
name|TREE_TYPE
argument_list|(
name|ltype
argument_list|)
decl_stmt|;
name|tree
name|ra
decl_stmt|;
for|for
control|(
name|ra
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|ttr
argument_list|)
init|;
name|ra
condition|;
name|ra
operator|=
name|TREE_CHAIN
argument_list|(
name|ra
argument_list|)
control|)
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"format"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|ra
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ra
condition|)
block|{
name|tree
name|la
decl_stmt|;
for|for
control|(
name|la
operator|=
name|TYPE_ATTRIBUTES
argument_list|(
name|ttl
argument_list|)
init|;
name|la
condition|;
name|la
operator|=
name|TREE_CHAIN
argument_list|(
name|la
argument_list|)
control|)
if|if
condition|(
name|is_attribute_p
argument_list|(
literal|"format"
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|la
argument_list|)
argument_list|)
condition|)
break|break;
return|return
operator|!
name|la
return|;
block|}
else|else
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Subscripting with type char is likely to lose on a machine where    chars are signed.  So warn on any machine, but optionally.  Don't    warn for unsigned char since that type is safe.  Don't warn for    signed char because anyone who uses that must have done so    deliberately. Furthermore, we reduce the false positive load by    warning only for non-constant value of type char.  */
end_comment

begin_function
name|void
name|warn_array_subscript_with_type_char
parameter_list|(
name|tree
name|index
parameter_list|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|index
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|&&
name|TREE_CODE
argument_list|(
name|index
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|warning
argument_list|(
name|OPT_Wchar_subscripts
argument_list|,
literal|"array subscript has type %<char%>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement -Wparentheses for the unexpected C precedence rules, to    cover cases like x + y<< z which readers are likely to    misinterpret.  We have seen an expression in which CODE is a binary    operator used to combine expressions headed by CODE_LEFT and    CODE_RIGHT.  CODE_LEFT and CODE_RIGHT may be ERROR_MARK, which    means that that side of the expression was not formed using a    binary operator, or it was enclosed in parentheses.  */
end_comment

begin_function
name|void
name|warn_about_parentheses
parameter_list|(
name|enum
name|tree_code
name|code
parameter_list|,
name|enum
name|tree_code
name|code_left
parameter_list|,
name|enum
name|tree_code
name|code_right
parameter_list|)
block|{
if|if
condition|(
operator|!
name|warn_parentheses
condition|)
return|return;
if|if
condition|(
name|code
operator|==
name|LSHIFT_EXPR
operator|||
name|code
operator|==
name|RSHIFT_EXPR
condition|)
block|{
if|if
condition|(
name|code_left
operator|==
name|PLUS_EXPR
operator|||
name|code_left
operator|==
name|MINUS_EXPR
operator|||
name|code_right
operator|==
name|PLUS_EXPR
operator|||
name|code_right
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around + or - inside shift"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|TRUTH_ORIF_EXPR
condition|)
block|{
if|if
condition|(
name|code_left
operator|==
name|TRUTH_ANDIF_EXPR
operator|||
name|code_right
operator|==
name|TRUTH_ANDIF_EXPR
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around&& within ||"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_IOR_EXPR
condition|)
block|{
if|if
condition|(
name|code_left
operator|==
name|BIT_AND_EXPR
operator|||
name|code_left
operator|==
name|BIT_XOR_EXPR
operator|||
name|code_left
operator|==
name|PLUS_EXPR
operator|||
name|code_left
operator|==
name|MINUS_EXPR
operator|||
name|code_right
operator|==
name|BIT_AND_EXPR
operator|||
name|code_right
operator|==
name|BIT_XOR_EXPR
operator|||
name|code_right
operator|==
name|PLUS_EXPR
operator|||
name|code_right
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around arithmetic in operand of |"
argument_list|)
expr_stmt|;
comment|/* Check cases like x|y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code_left
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code_right
argument_list|)
operator|==
name|tcc_comparison
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around comparison in operand of |"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_XOR_EXPR
condition|)
block|{
if|if
condition|(
name|code_left
operator|==
name|BIT_AND_EXPR
operator|||
name|code_left
operator|==
name|PLUS_EXPR
operator|||
name|code_left
operator|==
name|MINUS_EXPR
operator|||
name|code_right
operator|==
name|BIT_AND_EXPR
operator|||
name|code_right
operator|==
name|PLUS_EXPR
operator|||
name|code_right
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around arithmetic in operand of ^"
argument_list|)
expr_stmt|;
comment|/* Check cases like x^y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code_left
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code_right
argument_list|)
operator|==
name|tcc_comparison
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around comparison in operand of ^"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|BIT_AND_EXPR
condition|)
block|{
if|if
condition|(
name|code_left
operator|==
name|PLUS_EXPR
operator|||
name|code_left
operator|==
name|MINUS_EXPR
operator|||
name|code_right
operator|==
name|PLUS_EXPR
operator|||
name|code_right
operator|==
name|MINUS_EXPR
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around + or - in operand of&"
argument_list|)
expr_stmt|;
comment|/* Check cases like x&y==z */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code_left
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code_right
argument_list|)
operator|==
name|tcc_comparison
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"suggest parentheses around comparison in operand of&"
argument_list|)
expr_stmt|;
block|}
comment|/* Similarly, check for cases like 1<=i<=10 that are probably errors.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
operator|==
name|tcc_comparison
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|code_left
argument_list|)
operator|==
name|tcc_comparison
operator|||
name|TREE_CODE_CLASS
argument_list|(
name|code_right
argument_list|)
operator|==
name|tcc_comparison
operator|)
condition|)
name|warning
argument_list|(
name|OPT_Wparentheses
argument_list|,
literal|"comparisons like X<=Y<=Z do not "
literal|"have their mathematical meaning"
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"gt-c-common.h"
end_include

end_unit

