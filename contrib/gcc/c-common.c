begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines shared by all languages that are variants of C.    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002 Free Software Foundation, Inc.  This file is part of GCC.  GCC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GCC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GCC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"c-pragma.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"ggc.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"c-common.h"
end_include

begin_include
include|#
directive|include
file|"tree-inline.h"
end_include

begin_include
include|#
directive|include
file|"diagnostic.h"
end_include

begin_include
include|#
directive|include
file|"tm_p.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_decl_stmt
name|cpp_reader
modifier|*
name|parse_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declared in c-lex.h.  */
end_comment

begin_undef
undef|#
directive|undef
name|WCHAR_TYPE_SIZE
end_undef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|TYPE_PRECISION (wchar_type_node)
end_define

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRDIFF_TYPE
value|"long int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WINT_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WINT_TYPE
value|"unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INTMAX_TYPE
end_ifndef

begin_define
define|#
directive|define
name|INTMAX_TYPE
value|((INT_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 		     ? "int"					\ 		     : ((LONG_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 			? "long int"				\ 			: "long long int"))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UINTMAX_TYPE
end_ifndef

begin_define
define|#
directive|define
name|UINTMAX_TYPE
value|((INT_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 		     ? "unsigned int"				\ 		     : ((LONG_TYPE_SIZE == LONG_LONG_TYPE_SIZE)	\ 			? "long unsigned int"			\ 			: "long long unsigned int"))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The variant of the C language being processed.  */
end_comment

begin_decl_stmt
name|enum
name|c_language_kind
name|c_language
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The following symbols are subsumed in the c_global_trees array, and    listed here individually for documentation purposes.     INTEGER_TYPE and REAL_TYPE nodes for the standard data types.  	tree short_integer_type_node; 	tree long_integer_type_node; 	tree long_long_integer_type_node;  	tree short_unsigned_type_node; 	tree long_unsigned_type_node; 	tree long_long_unsigned_type_node;  	tree boolean_type_node; 	tree boolean_false_node; 	tree boolean_true_node;  	tree ptrdiff_type_node;  	tree unsigned_char_type_node; 	tree signed_char_type_node; 	tree wchar_type_node; 	tree signed_wchar_type_node; 	tree unsigned_wchar_type_node;  	tree float_type_node; 	tree double_type_node; 	tree long_double_type_node;  	tree complex_integer_type_node; 	tree complex_float_type_node; 	tree complex_double_type_node; 	tree complex_long_double_type_node;  	tree intQI_type_node; 	tree intHI_type_node; 	tree intSI_type_node; 	tree intDI_type_node; 	tree intTI_type_node;  	tree unsigned_intQI_type_node; 	tree unsigned_intHI_type_node; 	tree unsigned_intSI_type_node; 	tree unsigned_intDI_type_node; 	tree unsigned_intTI_type_node;  	tree widest_integer_literal_type_node; 	tree widest_unsigned_literal_type_node;     Nodes for types `void *' and `const void *'.  	tree ptr_type_node, const_ptr_type_node;     Nodes for types `char *' and `const char *'.  	tree string_type_node, const_string_type_node;     Type `char[SOMENUMBER]'.    Used when an array of char is needed and the size is irrelevant.  	tree char_array_type_node;     Type `int[SOMENUMBER]' or something like it.    Used when an array of int needed and the size is irrelevant.  	tree int_array_type_node;     Type `wchar_t[SOMENUMBER]' or something like it.    Used when a wide string literal is created.  	tree wchar_array_type_node;     Type `int ()' -- used for implicit declaration of functions.  	tree default_function_type;     A VOID_TYPE node, packaged in a TREE_LIST.  	tree void_list_node;    The lazily created VAR_DECLs for __FUNCTION__, __PRETTY_FUNCTION__,   and __func__. (C doesn't generate __FUNCTION__ and__PRETTY_FUNCTION__   VAR_DECLS, but C++ does.)  	tree function_name_decl_node; 	tree pretty_function_name_decl_node; 	tree c99_function_name_decl_node;    Stack of nested function name VAR_DECLs.    	tree saved_function_name_decls;  */
end_comment

begin_decl_stmt
name|tree
name|c_global_trees
index|[
name|CTI_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.    -ansi sets this.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_nonansi_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `double' the same size as `float'.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_double
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `wchar_t' the same size as `short'.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_wchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about possible violations of sequence point rules.  */
end_comment

begin_decl_stmt
name|int
name|warn_sequence_point
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to warn about compile-time division by zero.  */
end_comment

begin_decl_stmt
name|int
name|warn_div_by_zero
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The elements of `ridpointers' are identifier nodes for the reserved    type names and storage classes.  It is indexed by a RID_... value.  */
end_comment

begin_decl_stmt
name|tree
modifier|*
name|ridpointers
decl_stmt|;
end_decl_stmt

begin_macro
name|tree
argument_list|(
argument|*make_fname_decl
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If non-NULL, the address of a language-specific function that    returns 1 for language-specific statement codes.  */
end_comment

begin_macro
name|int
argument_list|(
argument|*lang_statement_code_p
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
expr|enum
name|tree_code
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* If non-NULL, the address of a language-specific function that takes    any action required right before expand_function_end is called.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*lang_expand_function_end
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Nonzero means the expression being parsed will never be evaluated.    This is a count, since unevaluated expressions can nest.  */
end_comment

begin_decl_stmt
name|int
name|skip_evaluation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Information about how a function name is generated.  */
end_comment

begin_struct
struct|struct
name|fname_var_t
block|{
name|tree
modifier|*
specifier|const
name|decl
decl_stmt|;
comment|/* pointer to the VAR_DECL.  */
specifier|const
name|unsigned
name|rid
decl_stmt|;
comment|/* RID number for the identifier.  */
specifier|const
name|int
name|pretty
decl_stmt|;
comment|/* How pretty is it? */
block|}
struct|;
end_struct

begin_comment
comment|/* The three ways of getting then name of the current function.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|fname_var_t
name|fname_vars
index|[]
init|=
block|{
comment|/* C99 compliant __func__, must be first.  */
block|{
operator|&
name|c99_function_name_decl_node
block|,
name|RID_C99_FUNCTION_NAME
block|,
literal|0
block|}
block|,
comment|/* GCC __FUNCTION__ compliant.  */
block|{
operator|&
name|function_name_decl_node
block|,
name|RID_FUNCTION_NAME
block|,
literal|0
block|}
block|,
comment|/* GCC __PRETTY_FUNCTION__ compliant.  */
block|{
operator|&
name|pretty_function_name_decl_node
block|,
name|RID_PRETTY_FUNCTION_NAME
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|constant_fits_type_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep a stack of if statements.  We record the number of compound    statements seen up to the if keyword, as well as the line number    and file of the if.  If a potentially ambiguous else is seen, that    fact is recorded; the warning is issued when we can be sure that    the enclosing if statement does not have an else branch.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|compstmt_count
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|needs_warning
decl_stmt|;
name|tree
name|if_stmt
decl_stmt|;
block|}
name|if_elt
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|if_elt
modifier|*
name|if_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of space in the if statement stack.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|if_stack_space
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|if_stack_pointer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the start of an if-then, and record the start of it    for ambiguous else detection.     COND is the condition for the if-then statement.     IF_STMT is the statement node that has already been created for    this if-then statement.  It is created before parsing the    condition to keep line number information accurate.  */
end_comment

begin_function
name|void
name|c_expand_start_cond
parameter_list|(
name|cond
parameter_list|,
name|compstmt_count
parameter_list|,
name|if_stmt
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|int
name|compstmt_count
decl_stmt|;
name|tree
name|if_stmt
decl_stmt|;
block|{
comment|/* Make sure there is enough space on the stack.  */
if|if
condition|(
name|if_stack_space
operator|==
literal|0
condition|)
block|{
name|if_stack_space
operator|=
literal|10
expr_stmt|;
name|if_stack
operator|=
operator|(
name|if_elt
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|if_elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|if_stack_space
operator|==
name|if_stack_pointer
condition|)
block|{
name|if_stack_space
operator|+=
literal|10
expr_stmt|;
name|if_stack
operator|=
operator|(
name|if_elt
operator|*
operator|)
name|xrealloc
argument_list|(
name|if_stack
argument_list|,
name|if_stack_space
operator|*
sizeof|sizeof
argument_list|(
name|if_elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IF_COND
argument_list|(
name|if_stmt
argument_list|)
operator|=
name|cond
expr_stmt|;
name|add_stmt
argument_list|(
name|if_stmt
argument_list|)
expr_stmt|;
comment|/* Record this if statement.  */
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|compstmt_count
operator|=
name|compstmt_count
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|file
operator|=
name|input_filename
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|line
operator|=
name|lineno
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|needs_warning
operator|=
literal|0
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|if_stmt
operator|=
name|if_stmt
expr_stmt|;
name|if_stack_pointer
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after the then-clause for an if-statement is processed.  */
end_comment

begin_function
name|void
name|c_finish_then
parameter_list|()
block|{
name|tree
name|if_stmt
init|=
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|if_stmt
decl_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|if_stmt
argument_list|,
name|THEN_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the end of an if-then.  Optionally warn if a nested    if statement had an ambiguous else clause.  */
end_comment

begin_function
name|void
name|c_expand_end_cond
parameter_list|()
block|{
name|if_stack_pointer
operator|--
expr_stmt|;
if|if
condition|(
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|needs_warning
condition|)
name|warning_with_file_and_line
argument_list|(
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|file
argument_list|,
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|line
argument_list|,
literal|"suggest explicit braces to avoid ambiguous `else'"
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called between the then-clause and the else-clause    of an if-then-else.  */
end_comment

begin_function
name|void
name|c_expand_start_else
parameter_list|()
block|{
comment|/* An ambiguous else warning must be generated for the enclosing if      statement, unless we see an else branch for that one, too.  */
if|if
condition|(
name|warn_parentheses
operator|&&
name|if_stack_pointer
operator|>
literal|1
operator|&&
operator|(
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|compstmt_count
operator|==
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|2
index|]
operator|.
name|compstmt_count
operator|)
condition|)
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|2
index|]
operator|.
name|needs_warning
operator|=
literal|1
expr_stmt|;
comment|/* Even if a nested if statement had an else branch, it can't be      ambiguous if this one also has an else.  So don't warn in that      case.  Also don't warn for any if statements nested in this else.  */
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|needs_warning
operator|=
literal|0
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|compstmt_count
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called after the else-clause for an if-statement is processed.  */
end_comment

begin_function
name|void
name|c_finish_else
parameter_list|()
block|{
name|tree
name|if_stmt
init|=
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|if_stmt
decl_stmt|;
name|RECHAIN_STMTS
argument_list|(
name|if_stmt
argument_list|,
name|ELSE_CLAUSE
argument_list|(
name|if_stmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin an if-statement.  Returns a newly created IF_STMT if    appropriate.     Unlike the C++ front-end, we do not call add_stmt here; it is    probably safe to do so, but I am not very familiar with this    code so I am being extra careful not to change its behavior    beyond what is strictly necessary for correctness.  */
end_comment

begin_function
name|tree
name|c_begin_if_stmt
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|IF_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Begin a while statement.  Returns a newly created WHILE_STMT if    appropriate.     Unlike the C++ front-end, we do not call add_stmt here; it is    probably safe to do so, but I am not very familiar with this    code so I am being extra careful not to change its behavior    beyond what is strictly necessary for correctness.  */
end_comment

begin_function
name|tree
name|c_begin_while_stmt
parameter_list|()
block|{
name|tree
name|r
decl_stmt|;
name|r
operator|=
name|build_stmt
argument_list|(
name|WHILE_STMT
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|c_finish_while_stmt_cond
parameter_list|(
name|cond
parameter_list|,
name|while_stmt
parameter_list|)
name|tree
name|while_stmt
decl_stmt|;
name|tree
name|cond
decl_stmt|;
block|{
name|WHILE_COND
argument_list|(
name|while_stmt
argument_list|)
operator|=
name|cond
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push current bindings for the function name VAR_DECLS.  */
end_comment

begin_function
name|void
name|start_fname_decls
parameter_list|()
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|saved
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
condition|;
name|ix
operator|++
control|)
block|{
name|tree
name|decl
init|=
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
decl_stmt|;
if|if
condition|(
name|decl
condition|)
block|{
name|saved
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|build_int_2
argument_list|(
name|ix
argument_list|,
literal|0
argument_list|)
argument_list|,
name|saved
argument_list|)
expr_stmt|;
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|saved
operator|||
name|saved_function_name_decls
condition|)
comment|/* Normally they'll have been NULL, so only push if we've got a        stack, or they are non-NULL.  */
name|saved_function_name_decls
operator|=
name|tree_cons
argument_list|(
name|saved
argument_list|,
name|NULL_TREE
argument_list|,
name|saved_function_name_decls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish up the current bindings, adding them into the    current function's statement tree. This is done by wrapping the    function's body in a COMPOUND_STMT containing these decls too. This    must be done _before_ finish_stmt_tree is called. If there is no    current function, we must be at file scope and no statements are    involved. Pop the previous bindings.  */
end_comment

begin_function
name|void
name|finish_fname_decls
parameter_list|()
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|body
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|stack
init|=
name|saved_function_name_decls
decl_stmt|;
for|for
control|(
init|;
name|stack
operator|&&
name|TREE_VALUE
argument_list|(
name|stack
argument_list|)
condition|;
name|stack
operator|=
name|TREE_CHAIN
argument_list|(
name|stack
argument_list|)
control|)
name|body
operator|=
name|chainon
argument_list|(
name|TREE_VALUE
argument_list|(
name|stack
argument_list|)
argument_list|,
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|body
condition|)
block|{
comment|/* They were called into existence, so add to statement tree.  */
name|body
operator|=
name|chainon
argument_list|(
name|body
argument_list|,
name|TREE_CHAIN
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|body
operator|=
name|build_stmt
argument_list|(
name|COMPOUND_STMT
argument_list|,
name|body
argument_list|)
expr_stmt|;
name|COMPOUND_STMT_NO_SCOPE
argument_list|(
name|body
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|DECL_SAVED_TREE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
operator|=
name|body
expr_stmt|;
block|}
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
condition|;
name|ix
operator|++
control|)
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|stack
condition|)
block|{
comment|/* We had saved values, restore them.  */
name|tree
name|saved
decl_stmt|;
for|for
control|(
name|saved
operator|=
name|TREE_PURPOSE
argument_list|(
name|stack
argument_list|)
init|;
name|saved
condition|;
name|saved
operator|=
name|TREE_CHAIN
argument_list|(
name|saved
argument_list|)
control|)
block|{
name|tree
name|decl
init|=
name|TREE_PURPOSE
argument_list|(
name|saved
argument_list|)
decl_stmt|;
name|unsigned
name|ix
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_VALUE
argument_list|(
name|saved
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|decl
expr_stmt|;
block|}
name|stack
operator|=
name|TREE_CHAIN
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
name|saved_function_name_decls
operator|=
name|stack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the text name of the current function, suitable prettified    by PRETTY_P.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|fname_as_string
parameter_list|(
name|pretty_p
parameter_list|)
name|int
name|pretty_p
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pretty_p
condition|)
name|name
operator|=
operator|(
name|current_function_decl
condition|?
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
else|:
literal|"top level"
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_function_decl
operator|&&
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
literal|""
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/* Return the text name of the current function, formatted as    required by the supplied RID value.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|fname_string
parameter_list|(
name|rid
parameter_list|)
name|unsigned
name|rid
decl_stmt|;
block|{
name|unsigned
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|fname_vars
index|[
name|ix
index|]
operator|.
name|rid
operator|==
name|rid
condition|)
break|break;
return|return
name|fname_as_string
argument_list|(
name|fname_vars
index|[
name|ix
index|]
operator|.
name|pretty
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the VAR_DECL for a const char array naming the current    function. If the VAR_DECL has not yet been created, create it    now. RID indicates how it should be formatted and IDENTIFIER_NODE    ID is its name (unfortunately C and C++ hold the RID values of    keywords in different places, so we can't derive RID from ID in    this language independent code.  */
end_comment

begin_function
name|tree
name|fname_decl
parameter_list|(
name|rid
parameter_list|,
name|id
parameter_list|)
name|unsigned
name|rid
decl_stmt|;
name|tree
name|id
decl_stmt|;
block|{
name|unsigned
name|ix
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
condition|;
name|ix
operator|++
control|)
if|if
condition|(
name|fname_vars
index|[
name|ix
index|]
operator|.
name|rid
operator|==
name|rid
condition|)
break|break;
name|decl
operator|=
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
expr_stmt|;
if|if
condition|(
operator|!
name|decl
condition|)
block|{
name|tree
name|saved_last_tree
init|=
name|last_tree
decl_stmt|;
name|decl
operator|=
call|(
modifier|*
name|make_fname_decl
call|)
argument_list|(
name|id
argument_list|,
name|fname_vars
index|[
name|ix
index|]
operator|.
name|pretty
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_tree
operator|!=
name|saved_last_tree
condition|)
block|{
comment|/* We created some statement tree for the decl. This belongs 	     at the start of the function, so remove it now and reinsert 	     it after the function is complete.  */
name|tree
name|stmts
init|=
name|TREE_CHAIN
argument_list|(
name|saved_last_tree
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|saved_last_tree
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
name|last_tree
operator|=
name|saved_last_tree
expr_stmt|;
name|saved_function_name_decls
operator|=
name|tree_cons
argument_list|(
name|decl
argument_list|,
name|stmts
argument_list|,
name|saved_function_name_decls
argument_list|)
expr_stmt|;
block|}
operator|*
name|fname_vars
index|[
name|ix
index|]
operator|.
name|decl
operator|=
name|decl
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ix
operator|&&
operator|!
name|current_function_decl
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' is not defined outside of function scope"
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Given a chain of STRING_CST nodes,    concatenate them into one STRING_CST    and give it a suitable array-of-chars data type.  */
end_comment

begin_function
name|tree
name|combine_strings
parameter_list|(
name|strings
parameter_list|)
name|tree
name|strings
decl_stmt|;
block|{
name|tree
name|value
decl_stmt|,
name|t
decl_stmt|;
name|int
name|length
init|=
literal|1
decl_stmt|;
name|int
name|wide_length
init|=
literal|0
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|int
name|wchar_bytes
init|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|nchars
decl_stmt|;
specifier|const
name|int
name|nchars_max
init|=
name|flag_isoc99
condition|?
literal|4095
else|:
literal|509
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|strings
argument_list|)
condition|)
block|{
comment|/* More than one in the chain, so concatenate.  */
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Don't include the \0 at the end of each substring, 	 except for the last one. 	 Count wide strings and ordinary strings separately.  */
for|for
control|(
name|t
operator|=
name|strings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
condition|)
block|{
name|wide_length
operator|+=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
name|wchar_bytes
operator|)
expr_stmt|;
name|wide_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|length
operator|+=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|C_ARTIFICIAL_STRING_P
argument_list|(
name|t
argument_list|)
operator|&&
operator|!
name|in_system_header
condition|)
name|warning
argument_list|(
literal|"concatenation of string literals with __FUNCTION__ is deprecated.  This feature will be removed in future"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If anything is wide, the non-wides will be converted, 	 which makes them take more space.  */
if|if
condition|(
name|wide_flag
condition|)
name|length
operator|=
name|length
operator|*
name|wchar_bytes
operator|+
name|wide_length
expr_stmt|;
name|p
operator|=
name|alloca
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|/* Copy the individual strings into the new combined string. 	 If the combined string is wide, convert the chars to ints 	 for any individual strings that are not wide.  */
name|q
operator|=
name|p
expr_stmt|;
for|for
control|(
name|t
operator|=
name|strings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|int
name|len
init|=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
operator|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
operator|)
condition|?
name|wchar_bytes
else|:
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
operator|)
operator|==
name|wide_flag
condition|)
block|{
name|memcpy
argument_list|(
name|q
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|q
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BYTES_BIG_ENDIAN
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|WCHAR_TYPE_SIZE
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|q
operator|++
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|++
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|WCHAR_TYPE_SIZE
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|wide_flag
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wchar_bytes
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|build_string
argument_list|(
name|length
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|strings
expr_stmt|;
name|length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|wchar_array_type_node
condition|)
name|wide_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Compute the number of elements, for the array type.  */
name|nchars
operator|=
name|wide_flag
condition|?
name|length
operator|/
name|wchar_bytes
else|:
name|length
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|nchars
operator|-
literal|1
operator|>
name|nchars_max
operator|&&
name|c_language
operator|==
name|clk_c
condition|)
name|pedwarn
argument_list|(
literal|"string length `%d' is greater than the length `%d' ISO C%d compilers are required to support"
argument_list|,
name|nchars
operator|-
literal|1
argument_list|,
name|nchars_max
argument_list|,
name|flag_isoc99
condition|?
literal|99
else|:
literal|89
argument_list|)
expr_stmt|;
comment|/* Create the array type for the string constant.      -Wwrite-strings says make the string constant an array of const char      so that copying it to a non-const pointer will get a warning.      For C++, this is the standard behavior.  */
if|if
condition|(
name|flag_const_strings
operator|&&
operator|(
operator|!
name|flag_traditional
operator|&&
operator|!
name|flag_writable_strings
operator|)
condition|)
block|{
name|tree
name|elements
init|=
name|build_type_variant
argument_list|(
name|wide_flag
condition|?
name|wchar_type_node
else|:
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|elements
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nchars
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|wide_flag
condition|?
name|wchar_type_node
else|:
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nchars
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|value
argument_list|)
operator|=
operator|!
name|flag_writable_strings
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|is_valid_printf_arglist
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|c_expand_builtin
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|expand_modifier
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|c_expand_builtin_printf
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|expand_modifier
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rtx
name|c_expand_builtin_fprintf
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|rtx
operator|,
expr|enum
name|machine_mode
operator|,
expr|enum
name|expand_modifier
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print a warning if a constant expression had overflow in folding.    Invoke this function on every expression that the language    requires to be a constant expression.    Note the ANSI C standard says it is erroneous for a    constant expression to overflow.  */
end_comment

begin_function
name|void
name|constant_expression_warning
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|)
operator|&&
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"overflow in constant expression"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a warning if an expression had overflow in folding.    Invoke this function on every expression that    (1) appears in the source code, and    (2) might be a constant expression that overflowed, and    (3) is not already checked by convert_and_check;    however, do not invoke this function on operands of explicit casts.  */
end_comment

begin_function
name|void
name|overflow_warning
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
operator|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"integer overflow in expression"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|)
operator|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"floating point overflow in expression"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a warning if a large constant is truncated to unsigned,    or if -Wconversion is used and a constant< 0 is converted to unsigned.    Invoke this function on every expression that might be implicitly    converted to an unsigned type.  */
end_comment

begin_function
name|void
name|unsigned_conversion_warning
parameter_list|(
name|result
parameter_list|,
name|operand
parameter_list|)
name|tree
name|result
decl_stmt|,
name|operand
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|&&
name|skip_evaluation
operator|==
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|operand
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|operand
argument_list|,
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* This detects cases like converting -129 or 256 to unsigned char.  */
name|warning
argument_list|(
literal|"large integer implicitly truncated to unsigned type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_conversion
condition|)
name|warning
argument_list|(
literal|"negative integer implicitly converted to unsigned type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Nonzero if constant C has a value that is permissible    for type TYPE (an INTEGER_TYPE).  */
end_comment

begin_function
specifier|static
name|int
name|constant_fits_type_p
parameter_list|(
name|c
parameter_list|,
name|type
parameter_list|)
name|tree
name|c
decl_stmt|,
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|c
argument_list|)
operator|==
name|INTEGER_CST
condition|)
return|return
name|int_fits_type_p
argument_list|(
name|c
argument_list|,
name|type
argument_list|)
return|;
name|c
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|!
name|TREE_OVERFLOW
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert EXPR to TYPE, warning about conversion problems with constants.    Invoke this function on every expression that is converted implicitly,    i.e. because of language rules and not because of an explicit cast.  */
end_comment

begin_function
name|tree
name|convert_and_check
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|t
init|=
name|convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Do not diagnose overflow in a constant expression merely 	     because a conversion overflowed.  */
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* No warning for converting 0x80000000 to int.  */
if|if
condition|(
operator|!
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|<
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* If EXPR fits in the unsigned version of TYPE, 	       don't warn unless pedantic.  */
if|if
condition|(
operator|(
name|pedantic
operator|||
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|constant_fits_type_p
argument_list|(
name|expr
argument_list|,
name|unsigned_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"overflow in implicit constant conversion"
argument_list|)
expr_stmt|;
block|}
else|else
name|unsigned_conversion_warning
argument_list|(
name|t
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A node in a list that describes references to variables (EXPR), which are    either read accesses if WRITER is zero, or write accesses, in which case    WRITER is the parent of EXPR.  */
end_comment

begin_struct
struct|struct
name|tlist
block|{
name|struct
name|tlist
modifier|*
name|next
decl_stmt|;
name|tree
name|expr
decl_stmt|,
name|writer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Used to implement a cache the results of a call to verify_tree.  We only    use this for SAVE_EXPRs.  */
end_comment

begin_struct
struct|struct
name|tlist_cache
block|{
name|struct
name|tlist_cache
modifier|*
name|next
decl_stmt|;
name|struct
name|tlist
modifier|*
name|cache_before_sp
decl_stmt|;
name|struct
name|tlist
modifier|*
name|cache_after_sp
decl_stmt|;
name|tree
name|expr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Obstack to use when allocating tlist structures, and corresponding    firstobj.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|tlist_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tlist_firstobj
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep track of the identifiers we've warned about, so we can avoid duplicate    warnings.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tlist
modifier|*
name|warned_ids
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SAVE_EXPRs need special treatment.  We process them only once and then    cache the results.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tlist_cache
modifier|*
name|save_expr_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_tlist
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tlist
operator|*
operator|*
operator|,
expr|struct
name|tlist
operator|*
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|merge_tlist
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tlist
operator|*
operator|*
operator|,
expr|struct
name|tlist
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|verify_tree
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
expr|struct
name|tlist
operator|*
operator|*
operator|,
expr|struct
name|tlist
operator|*
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|warning_candidate_p
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_for_collisions
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|warn_for_collisions_1
name|PARAMS
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|struct
name|tlist
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tlist
modifier|*
name|new_tlist
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tlist
operator|*
operator|,
name|tree
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|verify_sequence_points
name|PARAMS
argument_list|(
operator|(
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a new struct tlist and fill in its fields.  */
end_comment

begin_function
specifier|static
name|struct
name|tlist
modifier|*
name|new_tlist
parameter_list|(
name|next
parameter_list|,
name|t
parameter_list|,
name|writer
parameter_list|)
name|struct
name|tlist
modifier|*
name|next
decl_stmt|;
name|tree
name|t
decl_stmt|;
name|tree
name|writer
decl_stmt|;
block|{
name|struct
name|tlist
modifier|*
name|l
decl_stmt|;
name|l
operator|=
operator|(
expr|struct
name|tlist
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
sizeof|sizeof
expr|*
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|l
operator|->
name|expr
operator|=
name|t
expr_stmt|;
name|l
operator|->
name|writer
operator|=
name|writer
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/* Add duplicates of the nodes found in ADD to the list *TO.  If EXCLUDE_WRITER    is nonnull, we ignore any node we find which has a writer equal to it.  */
end_comment

begin_function
specifier|static
name|void
name|add_tlist
parameter_list|(
name|to
parameter_list|,
name|add
parameter_list|,
name|exclude_writer
parameter_list|,
name|copy
parameter_list|)
name|struct
name|tlist
modifier|*
modifier|*
name|to
decl_stmt|;
name|struct
name|tlist
modifier|*
name|add
decl_stmt|;
name|tree
name|exclude_writer
decl_stmt|;
name|int
name|copy
decl_stmt|;
block|{
while|while
condition|(
name|add
condition|)
block|{
name|struct
name|tlist
modifier|*
name|next
init|=
name|add
operator|->
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|copy
condition|)
name|add
operator|->
name|next
operator|=
operator|*
name|to
expr_stmt|;
if|if
condition|(
operator|!
name|exclude_writer
operator|||
name|add
operator|->
name|writer
operator|!=
name|exclude_writer
condition|)
operator|*
name|to
operator|=
name|copy
condition|?
name|new_tlist
argument_list|(
operator|*
name|to
argument_list|,
name|add
operator|->
name|expr
argument_list|,
name|add
operator|->
name|writer
argument_list|)
else|:
name|add
expr_stmt|;
name|add
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Merge the nodes of ADD into TO.  This merging process is done so that for    each variable that already exists in TO, no new node is added; however if    there is a write access recorded in ADD, and an occurrence on TO is only    a read access, then the occurrence in TO will be modified to record the    write.  */
end_comment

begin_function
specifier|static
name|void
name|merge_tlist
parameter_list|(
name|to
parameter_list|,
name|add
parameter_list|,
name|copy
parameter_list|)
name|struct
name|tlist
modifier|*
modifier|*
name|to
decl_stmt|;
name|struct
name|tlist
modifier|*
name|add
decl_stmt|;
name|int
name|copy
decl_stmt|;
block|{
name|struct
name|tlist
modifier|*
modifier|*
name|end
init|=
name|to
decl_stmt|;
while|while
condition|(
operator|*
name|end
condition|)
name|end
operator|=
operator|&
operator|(
operator|*
name|end
operator|)
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|add
condition|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|tlist
modifier|*
name|tmp2
decl_stmt|;
name|struct
name|tlist
modifier|*
name|next
init|=
name|add
operator|->
name|next
decl_stmt|;
for|for
control|(
name|tmp2
operator|=
operator|*
name|to
init|;
name|tmp2
condition|;
name|tmp2
operator|=
name|tmp2
operator|->
name|next
control|)
if|if
condition|(
name|tmp2
operator|->
name|expr
operator|==
name|add
operator|->
name|expr
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|tmp2
operator|->
name|writer
condition|)
name|tmp2
operator|->
name|writer
operator|=
name|add
operator|->
name|writer
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|*
name|end
operator|=
name|copy
condition|?
name|add
else|:
name|new_tlist
argument_list|(
name|NULL
argument_list|,
name|add
operator|->
name|expr
argument_list|,
name|add
operator|->
name|writer
argument_list|)
expr_stmt|;
name|end
operator|=
operator|&
operator|(
operator|*
name|end
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|end
operator|=
literal|0
expr_stmt|;
block|}
name|add
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* WRITTEN is a variable, WRITER is its parent.  Warn if any of the variable    references in list LIST conflict with it, excluding reads if ONLY writers    is nonzero.  */
end_comment

begin_function
specifier|static
name|void
name|warn_for_collisions_1
parameter_list|(
name|written
parameter_list|,
name|writer
parameter_list|,
name|list
parameter_list|,
name|only_writes
parameter_list|)
name|tree
name|written
decl_stmt|,
name|writer
decl_stmt|;
name|struct
name|tlist
modifier|*
name|list
decl_stmt|;
name|int
name|only_writes
decl_stmt|;
block|{
name|struct
name|tlist
modifier|*
name|tmp
decl_stmt|;
comment|/* Avoid duplicate warnings.  */
for|for
control|(
name|tmp
operator|=
name|warned_ids
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
if|if
condition|(
name|tmp
operator|->
name|expr
operator|==
name|written
condition|)
return|return;
while|while
condition|(
name|list
condition|)
block|{
if|if
condition|(
name|list
operator|->
name|expr
operator|==
name|written
operator|&&
name|list
operator|->
name|writer
operator|!=
name|writer
operator|&&
operator|(
operator|!
name|only_writes
operator|||
name|list
operator|->
name|writer
operator|)
condition|)
block|{
name|warned_ids
operator|=
name|new_tlist
argument_list|(
name|warned_ids
argument_list|,
name|written
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"operation on `%s' may be undefined"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|list
operator|->
name|expr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given a list LIST of references to variables, find whether any of these    can cause conflicts due to missing sequence points.  */
end_comment

begin_function
specifier|static
name|void
name|warn_for_collisions
parameter_list|(
name|list
parameter_list|)
name|struct
name|tlist
modifier|*
name|list
decl_stmt|;
block|{
name|struct
name|tlist
modifier|*
name|tmp
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|list
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tmp
operator|->
name|writer
condition|)
name|warn_for_collisions_1
argument_list|(
name|tmp
operator|->
name|expr
argument_list|,
name|tmp
operator|->
name|writer
argument_list|,
name|list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero if X is a tree that can be verified by the sequence point    warnings.  */
end_comment

begin_function
specifier|static
name|int
name|warning_candidate_p
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
return|return
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARM_DECL
return|;
block|}
end_function

begin_comment
comment|/* Walk the tree X, and record accesses to variables.  If X is written by the    parent tree, WRITER is the parent.    We store accesses in one of the two lists: PBEFORE_SP, and PNO_SP.  If this    expression or its only operand forces a sequence point, then everything up    to the sequence point is stored in PBEFORE_SP.  Everything else gets stored    in PNO_SP.    Once we return, we will have emitted warnings if any subexpression before    such a sequence point could be undefined.  On a higher level, however, the    sequence point may not be relevant, and we'll merge the two lists.     Example: (b++, a) + b;    The call that processes the COMPOUND_EXPR will store the increment of B    in PBEFORE_SP, and the use of A in PNO_SP.  The higher-level call that    processes the PLUS_EXPR will need to merge the two lists so that    eventually, all accesses end up on the same list (and we'll warn about the    unordered subexpressions b++ and b.     A note on merging.  If we modify the former example so that our expression    becomes      (b++, b) + a    care must be taken not simply to add all three expressions into the final    PNO_SP list.  The function merge_tlist takes care of that by merging the    before-SP list of the COMPOUND_EXPR into its after-SP list in a special    way, so that no more than one access to B is recorded.  */
end_comment

begin_function
specifier|static
name|void
name|verify_tree
parameter_list|(
name|x
parameter_list|,
name|pbefore_sp
parameter_list|,
name|pno_sp
parameter_list|,
name|writer
parameter_list|)
name|tree
name|x
decl_stmt|;
name|struct
name|tlist
modifier|*
modifier|*
name|pbefore_sp
decl_stmt|,
decl|*
modifier|*
name|pno_sp
decl_stmt|;
end_function

begin_decl_stmt
name|tree
name|writer
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|tlist
modifier|*
name|tmp_before
decl_stmt|,
modifier|*
name|tmp_nosp
decl_stmt|,
modifier|*
name|tmp_list2
decl_stmt|,
modifier|*
name|tmp_list3
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|char
name|class
decl_stmt|;
comment|/* X may be NULL if it is the operand of an empty statement expression      ({ }).  */
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
return|return;
name|restart
label|:
name|code
operator|=
name|TREE_CODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|class
operator|=
name|TREE_CODE_CLASS
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|warning_candidate_p
argument_list|(
name|x
argument_list|)
condition|)
block|{
operator|*
name|pno_sp
operator|=
name|new_tlist
argument_list|(
operator|*
name|pno_sp
argument_list|,
name|x
argument_list|,
name|writer
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONSTRUCTOR
case|:
return|return;
case|case
name|COMPOUND_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
name|tmp_before
operator|=
name|tmp_nosp
operator|=
name|tmp_list3
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_nosp
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_nosp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
name|pno_sp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|COND_EXPR
case|:
name|tmp_before
operator|=
name|tmp_list2
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_list2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_list2
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tmp_list3
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_nosp
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp_list3
operator|=
name|tmp_list2
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
operator|&
name|tmp_list2
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_list2
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_list3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Rather than add both tmp_nosp and tmp_list2, we have to merge the 	 two first, to avoid warning for (a ? b++ : b++).  */
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|tmp_list2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|PREDECREMENT_EXPR
case|:
case|case
name|PREINCREMENT_EXPR
case|:
case|case
name|POSTDECREMENT_EXPR
case|:
case|case
name|POSTINCREMENT_EXPR
case|:
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|pno_sp
argument_list|,
name|pno_sp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return;
case|case
name|MODIFY_EXPR
case|:
name|tmp_before
operator|=
name|tmp_nosp
operator|=
name|tmp_list3
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_list3
argument_list|,
operator|&
name|tmp_list3
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Expressions inside the LHS are not ordered wrt. the sequence points 	 in the RHS.  Example: 	   *a = (a++, 2) 	 Despite the fact that the modification of "a" is in the before_sp 	 list (tmp_before), it conflicts with the use of "a" in the LHS. 	 We can handle this by adding the contents of tmp_list3 	 to those of tmp_before, and redoing the collision warnings for that 	 list.  */
name|add_tlist
argument_list|(
operator|&
name|tmp_before
argument_list|,
name|tmp_list3
argument_list|,
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_before
argument_list|)
expr_stmt|;
comment|/* Exclude the LHS itself here; we first have to merge it into the 	 tmp_nosp list.  This is done to avoid warning for "a = a"; if we 	 didn't exclude the LHS, we'd get it twice, once as a read and once 	 as a write.  */
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_list3
argument_list|,
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warn_for_collisions_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|,
name|tmp_nosp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warning_candidate_p
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|new_tlist
argument_list|(
name|NULL
argument_list|,
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
case|case
name|CALL_EXPR
case|:
comment|/* We need to warn about conflicts among arguments and conflicts between 	 args and the function address.  Side effects of the function address, 	 however, are not ordered by the sequence point of the call.  */
name|tmp_before
operator|=
name|tmp_nosp
operator|=
name|tmp_list2
operator|=
name|tmp_list3
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp_list2
argument_list|,
operator|&
name|tmp_list3
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_list3
argument_list|,
name|tmp_list2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
operator|&
name|tmp_before
argument_list|,
name|tmp_list3
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
operator|&
name|tmp_before
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_before
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|tmp_before
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|TREE_LIST
case|:
comment|/* Scan all the list, e.g. indices of multi dimensional array.  */
while|while
condition|(
name|x
condition|)
block|{
name|tmp_before
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_VALUE
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|SAVE_EXPR
case|:
block|{
name|struct
name|tlist_cache
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|save_expr_cache
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
if|if
condition|(
name|t
operator|->
name|expr
operator|==
name|x
condition|)
break|break;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|t
operator|=
operator|(
expr|struct
name|tlist_cache
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
sizeof|sizeof
expr|*
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|save_expr_cache
expr_stmt|;
name|t
operator|->
name|expr
operator|=
name|x
expr_stmt|;
name|save_expr_cache
operator|=
name|t
expr_stmt|;
name|tmp_before
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|tmp_nosp
argument_list|)
expr_stmt|;
name|tmp_list3
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tmp_nosp
condition|)
block|{
name|struct
name|tlist
modifier|*
name|t
init|=
name|tmp_nosp
decl_stmt|;
name|tmp_nosp
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_list3
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|cache_before_sp
operator|=
name|tmp_before
expr_stmt|;
name|t
operator|->
name|cache_after_sp
operator|=
name|tmp_list3
expr_stmt|;
block|}
name|merge_tlist
argument_list|(
name|pbefore_sp
argument_list|,
name|t
operator|->
name|cache_before_sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|t
operator|->
name|cache_after_sp
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
default|default:
break|break;
block|}
if|if
condition|(
name|class
operator|==
literal|'1'
condition|)
block|{
if|if
condition|(
name|first_rtl_op
argument_list|(
name|code
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|x
operator|=
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|writer
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'<'
case|:
case|case
literal|'2'
case|:
case|case
literal|'b'
case|:
case|case
literal|'e'
case|:
case|case
literal|'s'
case|:
case|case
literal|'x'
case|:
block|{
name|int
name|lp
decl_stmt|;
name|int
name|max
init|=
name|first_rtl_op
argument_list|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|lp
operator|=
literal|0
init|;
name|lp
operator|<
name|max
condition|;
name|lp
operator|++
control|)
block|{
name|tmp_before
operator|=
name|tmp_nosp
operator|=
literal|0
expr_stmt|;
name|verify_tree
argument_list|(
name|TREE_OPERAND
argument_list|(
name|x
argument_list|,
name|lp
argument_list|)
argument_list|,
operator|&
name|tmp_before
argument_list|,
operator|&
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|merge_tlist
argument_list|(
operator|&
name|tmp_nosp
argument_list|,
name|tmp_before
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_tlist
argument_list|(
name|pno_sp
argument_list|,
name|tmp_nosp
argument_list|,
name|NULL_TREE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Try to warn for undefined behaviour in EXPR due to missing sequence    points.  */
end_comment

begin_function
specifier|static
name|void
name|verify_sequence_points
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|struct
name|tlist
modifier|*
name|before_sp
init|=
literal|0
decl_stmt|,
modifier|*
name|after_sp
init|=
literal|0
decl_stmt|;
name|warned_ids
operator|=
literal|0
expr_stmt|;
name|save_expr_cache
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tlist_firstobj
operator|==
literal|0
condition|)
block|{
name|gcc_obstack_init
argument_list|(
operator|&
name|tlist_obstack
argument_list|)
expr_stmt|;
name|tlist_firstobj
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|verify_tree
argument_list|(
name|expr
argument_list|,
operator|&
name|before_sp
argument_list|,
operator|&
name|after_sp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|warn_for_collisions
argument_list|(
name|after_sp
argument_list|)
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|tlist_obstack
argument_list|,
name|tlist_firstobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|c_expand_expr_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
comment|/* Do default conversion if safe and possibly important,      in case within ({...}).  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|flag_isoc99
operator|||
name|lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|expr
operator|=
name|default_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_sequence_point
condition|)
name|verify_sequence_points
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|error_mark_node
operator|&&
operator|!
name|COMPLETE_OR_VOID_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|error
argument_list|(
literal|"expression statement has incomplete type"
argument_list|)
expr_stmt|;
name|last_expr_type
operator|=
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
expr_stmt|;
return|return
name|add_stmt
argument_list|(
name|build_stmt
argument_list|(
name|EXPR_STMT
argument_list|,
name|expr
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Validate the expression after `case' and apply default promotions.  */
end_comment

begin_function
name|tree
name|check_case_value
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|==
name|NULL_TREE
condition|)
return|return
name|value
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* In C++, the following is allowed:         const int i = 3;        switch (...) { case i: ... }       So, we try to reduce the VALUE to a constant that way.  */
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
block|{
name|value
operator|=
name|decl_constant_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|fold
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"case label does not reduce to an integer constant"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
comment|/* Promote char or short to int.  */
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an integer type with BITS bits of precision,    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */
end_comment

begin_function
name|tree
name|type_for_size
parameter_list|(
name|bits
parameter_list|,
name|unsignedp
parameter_list|)
name|unsigned
name|bits
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|widest_integer_literal_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
operator|)
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a data type that has machine mode MODE.    If the mode is an integer,    then UNSIGNEDP selects between signed and unsigned types.  */
end_comment

begin_function
name|tree
name|type_for_mode
parameter_list|(
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|widest_integer_literal_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|QImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|HImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|SImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|DImode
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intTI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intTI_type_node
else|:
name|intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
condition|)
return|return
name|float_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_double_type_node
argument_list|)
condition|)
return|return
name|long_double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
return|;
ifdef|#
directive|ifdef
name|VECTOR_MODE_SUPPORTED_P
if|if
condition|(
name|VECTOR_MODE_SUPPORTED_P
argument_list|(
name|mode
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V16QImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V16QI_type_node
else|:
name|V16QI_type_node
return|;
case|case
name|V8HImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V8HI_type_node
else|:
name|V8HI_type_node
return|;
case|case
name|V4SImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V4SI_type_node
else|:
name|V4SI_type_node
return|;
case|case
name|V2SImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V2SI_type_node
else|:
name|V2SI_type_node
return|;
case|case
name|V4HImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V4HI_type_node
else|:
name|V4HI_type_node
return|;
case|case
name|V8QImode
case|:
return|return
name|unsignedp
condition|?
name|unsigned_V8QI_type_node
else|:
name|V8QI_type_node
return|;
case|case
name|V4SFmode
case|:
return|return
name|V4SF_type_node
return|;
case|case
name|V2SFmode
case|:
return|return
name|V2SF_type_node
return|;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return an unsigned type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|unsigned_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|signed_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|unsigned_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|integer_type_node
condition|)
return|return
name|unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_integer_type_node
condition|)
return|return
name|short_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_integer_type_node
condition|)
return|return
name|long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_integer_type_node
condition|)
return|return
name|long_long_unsigned_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|widest_integer_literal_type_node
condition|)
return|return
name|widest_unsigned_literal_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|type1
operator|==
name|intTI_type_node
condition|)
return|return
name|unsigned_intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|type1
operator|==
name|intDI_type_node
condition|)
return|return
name|unsigned_intDI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intSI_type_node
condition|)
return|return
name|unsigned_intSI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intHI_type_node
condition|)
return|return
name|unsigned_intHI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|intQI_type_node
condition|)
return|return
name|unsigned_intQI_type_node
return|;
return|return
name|signed_or_unsigned_type
argument_list|(
literal|1
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a signed type the same as TYPE in other respects.  */
end_comment

begin_function
name|tree
name|signed_type
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|tree
name|type1
init|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|==
name|unsigned_char_type_node
operator|||
name|type1
operator|==
name|char_type_node
condition|)
return|return
name|signed_char_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_type_node
condition|)
return|return
name|integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|short_unsigned_type_node
condition|)
return|return
name|short_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_unsigned_type_node
condition|)
return|return
name|long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|long_long_unsigned_type_node
condition|)
return|return
name|long_long_integer_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|widest_unsigned_literal_type_node
condition|)
return|return
name|widest_integer_literal_type_node
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|type1
operator|==
name|unsigned_intTI_type_node
condition|)
return|return
name|intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|type1
operator|==
name|unsigned_intDI_type_node
condition|)
return|return
name|intDI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intSI_type_node
condition|)
return|return
name|intSI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intHI_type_node
condition|)
return|return
name|intHI_type_node
return|;
if|if
condition|(
name|type1
operator|==
name|unsigned_intQI_type_node
condition|)
return|return
name|intQI_type_node
return|;
return|return
name|signed_or_unsigned_type
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a type the same as TYPE except unsigned or    signed according to UNSIGNEDP.  */
end_comment

begin_function
name|tree
name|signed_or_unsigned_type
parameter_list|(
name|unsignedp
parameter_list|,
name|type
parameter_list|)
name|int
name|unsignedp
decl_stmt|;
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|INTEGRAL_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|==
name|unsignedp
condition|)
return|return
name|type
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|widest_integer_literal_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|widest_unsigned_literal_type_node
else|:
name|widest_integer_literal_type_node
operator|)
return|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|intTI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intTI_type_node
else|:
name|intTI_type_node
return|;
endif|#
directive|endif
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the minimum number of bits needed to represent VALUE in a    signed or unsigned type, UNSIGNEDP says which.  */
end_comment

begin_function
name|unsigned
name|int
name|min_precision
parameter_list|(
name|value
parameter_list|,
name|unsignedp
parameter_list|)
name|tree
name|value
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|int
name|log
decl_stmt|;
comment|/* If the value is negative, compute its negative minus 1.  The latter      adjustment is because the absolute value of the largest negative value      is one larger than the largest positive value.  This is equivalent to      a bit-wise negation, so use that operation instead.  */
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|value
argument_list|)
operator|<
literal|0
condition|)
name|value
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the number of bits needed, taking into account the fact      that we need one more bit for a signed than unsigned type.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|value
argument_list|)
condition|)
name|log
operator|=
literal|0
expr_stmt|;
else|else
name|log
operator|=
name|tree_floor_log2
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|log
operator|+
literal|1
operator|+
operator|!
name|unsignedp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an error message for invalid operands to arith operation CODE.    NOP_EXPR is used as a special case (see truthvalue_conversion).  */
end_comment

begin_function
name|void
name|binary_op_error
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|opname
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOP_EXPR
case|:
name|error
argument_list|(
literal|"invalid truth-value expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS_EXPR
case|:
name|opname
operator|=
literal|"+"
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|opname
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|opname
operator|=
literal|"*"
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|opname
operator|=
literal|"max"
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|opname
operator|=
literal|"min"
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
name|opname
operator|=
literal|"=="
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|opname
operator|=
literal|"!="
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|opname
operator|=
literal|"<="
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|opname
operator|=
literal|">="
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|opname
operator|=
literal|"<"
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|opname
operator|=
literal|">"
expr_stmt|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
name|opname
operator|=
literal|"<<"
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|opname
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
name|opname
operator|=
literal|"%"
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
name|opname
operator|=
literal|"/"
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|opname
operator|=
literal|"&"
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|opname
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|opname
operator|=
literal|"&&"
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|opname
operator|=
literal|"||"
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|opname
operator|=
literal|"^"
expr_stmt|;
break|break;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
name|opname
operator|=
literal|"rotate"
expr_stmt|;
break|break;
default|default:
name|opname
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"invalid operands to binary %s"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of build_binary_op, used for comparison operations.    See if the operands have both been converted from subword integer types    and, if so, perhaps change them both back to their original type.    This function is also responsible for converting the two operands    to the proper common type for comparison.     The arguments of this function are all pointers to local variables    of build_binary_op: OP0_PTR is&OP0, OP1_PTR is&OP1,    RESTYPE_PTR is&RESULT_TYPE and RESCODE_PTR is&RESULTCODE.     If this function returns nonzero, it means that the comparison has    a constant value.  What this function returns is an expression for    that value.  */
end_comment

begin_function
name|tree
name|shorten_compare
parameter_list|(
name|op0_ptr
parameter_list|,
name|op1_ptr
parameter_list|,
name|restype_ptr
parameter_list|,
name|rescode_ptr
parameter_list|)
name|tree
modifier|*
name|op0_ptr
decl_stmt|,
decl|*
name|op1_ptr
decl_stmt|;
end_function

begin_decl_stmt
name|tree
modifier|*
name|restype_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|tree_code
modifier|*
name|rescode_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|op0
init|=
operator|*
name|op0_ptr
decl_stmt|;
name|tree
name|op1
init|=
operator|*
name|op1_ptr
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|int
name|real1
decl_stmt|,
name|real2
decl_stmt|;
name|tree
name|primop0
decl_stmt|,
name|primop1
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
operator|*
name|rescode_ptr
decl_stmt|;
comment|/* Throw away any conversions to wider types      already present in the operands.  */
name|primop0
operator|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion      but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|primop0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|primop1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If one of the operands must be floated, we cannot optimize.  */
name|real1
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
name|real2
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
comment|/* If first arg is constant, swap the args (changing operation      so value is preserved), for canonicalization.  Don't do this if      the second arg is 0.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|primop0
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|primop1
argument_list|)
operator|&&
operator|!
name|real_zerop
argument_list|(
name|primop1
argument_list|)
condition|)
block|{
name|tree
name|tem
init|=
name|primop0
decl_stmt|;
name|int
name|temi
init|=
name|unsignedp0
decl_stmt|;
name|primop0
operator|=
name|primop1
expr_stmt|;
name|primop1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
operator|*
name|op0_ptr
operator|=
name|op0
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|op1
expr_stmt|;
name|unsignedp0
operator|=
name|unsignedp1
expr_stmt|;
name|unsignedp1
operator|=
name|temi
expr_stmt|;
name|temi
operator|=
name|real1
expr_stmt|;
name|real1
operator|=
name|real2
expr_stmt|;
name|real2
operator|=
name|temi
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|rescode_ptr
operator|=
name|code
expr_stmt|;
block|}
comment|/* If comparing an integer against a constant more bits wide,      maybe we can deduce a value of 1 or 0 independent of the data.      Or else truncate the constant now      rather than extend the variable at run time.       This is only interesting if the constant is the wider arg.      Also, it is not safe if the constant is unsigned and the      variable arg is signed, since in this case the variable      would be sign-extended and then regarded as unsigned.      Our technique fails in this case because the lowest/highest      possible unsigned results don't follow naturally from the      lowest/highest possible values of the variable operand.      For just EQ_EXPR and NE_EXPR there is another technique that      could be used: see if the constant can be faithfully represented      in the other operand's type, by truncating it and reextending it      and see if that preserves the constant's value.  */
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|int
name|min_gt
decl_stmt|,
name|max_gt
decl_stmt|,
name|min_lt
decl_stmt|,
name|max_lt
decl_stmt|;
name|tree
name|maxval
decl_stmt|,
name|minval
decl_stmt|;
comment|/* 1 if comparison is nominally unsigned.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If TYPE is an enumeration, then we need to get its min/max 	 values from it's underlying integral type, not the enumerated 	 type itself.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|type
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|unsignedp0
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|minval
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
operator|*
name|restype_ptr
operator|=
name|signed_type
argument_list|(
operator|*
name|restype_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|primop1
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
operator|*
name|restype_ptr
condition|)
block|{
name|minval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsignedp
operator|&&
name|unsignedp0
condition|)
block|{
name|min_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
comment|/* This used to be a switch, but Genix compiler can't handle that.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LT_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GT_EXPR
condition|)
block|{
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
comment|/* If primop0 was sign-extended and unsigned comparison specd, 	 we did a signed comparison above using the signed type bounds. 	 But the comparison we output must be unsigned.  	 Also, for inequalities, VAL is no good; but if the signed 	 comparison had *any* fixed result, it follows that the 	 unsigned comparison just tests the sign in reverse 	 (positive values are LE, negative ones GE). 	 So we can generate an unsigned comparison 	 against an extreme value of the signed type.  */
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
block|{
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|primop1
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|primop1
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|type
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|max_gt
operator|&&
operator|!
name|unsignedp0
operator|&&
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* This is the case of (char)x>?< 0x80, which people used to use 	     expecting old C compilers to change the 0x80 into -0x80.  */
if|if
condition|(
name|val
operator|==
name|boolean_false_node
condition|)
name|warning
argument_list|(
literal|"comparison is always false due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|boolean_true_node
condition|)
name|warning
argument_list|(
literal|"comparison is always true due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|min_lt
operator|&&
name|unsignedp0
operator|&&
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* This is the case of (unsigned char)x>?< -1 or< 0.  */
if|if
condition|(
name|val
operator|==
name|boolean_false_node
condition|)
name|warning
argument_list|(
literal|"comparison is always false due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|boolean_true_node
condition|)
name|warning
argument_list|(
literal|"comparison is always true due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|val
argument_list|)
return|;
return|return
name|val
return|;
block|}
comment|/* Value is not predetermined, but do the comparison 	 in the type of the operand that is not constant. 	 TYPE is already properly set.  */
block|}
elseif|else
if|if
condition|(
name|real1
operator|&&
name|real2
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
expr_stmt|;
comment|/* If args' natural types are both narrower than nominal type      and both extend in the same manner, compare them      in the type of the wider arg.      Otherwise must actually extend both to the nominal      common type lest different ways of extending      alter the result.      (eg, (short)-1 == (unsigned short)-1  should be 0.)  */
elseif|else
if|if
condition|(
name|unsignedp0
operator|==
name|unsignedp1
operator|&&
name|real1
operator|==
name|real2
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|type
operator|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
operator|||
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primop0
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we must do the comparison on the nominal type 	 using the args exactly as we received them.  */
name|type
operator|=
operator|*
name|restype_ptr
expr_stmt|;
name|primop0
operator|=
name|op0
expr_stmt|;
name|primop1
operator|=
name|op1
expr_stmt|;
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|integer_zerop
argument_list|(
name|primop1
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE_EXPR
case|:
comment|/* All unsigned values are>= 0, so we warn if extra warnings 		 are requested.  However, if OP0 is a constant that is>= 0, the signedness of the comparison isn't an issue, 		 so suppress the warning.  */
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|convert
argument_list|(
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|primop0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"comparison of unsigned expression>= 0 is always true"
argument_list|)
expr_stmt|;
name|value
operator|=
name|boolean_true_node
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
name|in_system_header
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|convert
argument_list|(
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|primop0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"comparison of unsigned expression< 0 is always false"
argument_list|)
expr_stmt|;
name|value
operator|=
name|boolean_false_node
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|value
argument_list|)
return|;
return|return
name|value
return|;
block|}
block|}
block|}
operator|*
name|op0_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
operator|*
name|restype_ptr
operator|=
name|boolean_type_node
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,    or validate its data type for an `if' or `while' statement or ?..: exp.     This preparation consists of taking the ordinary    representation of an expression expr and producing a valid tree    boolean expression describing whether expr is nonzero.  We could    simply always do build_binary_op (NE_EXPR, expr, boolean_false_node, 1),    but we optimize comparisons,&&, ||, and !.     The resulting type should always be `boolean_type_node'.  */
end_comment

begin_function
name|tree
name|truthvalue_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|expr
return|;
if|#
directive|if
literal|0
comment|/* This appears to be wrong for C++.  */
comment|/* These really should return error_mark_node after 2.4 is stable.      But not all callers handle ERROR_MARK properly.  */
block|switch (TREE_CODE (TREE_TYPE (expr)))     {     case RECORD_TYPE:       error ("struct type value used where scalar is required");       return boolean_false_node;      case UNION_TYPE:       error ("union type value used where scalar is required");       return boolean_false_node;      case ARRAY_TYPE:       error ("array type value used where scalar is required");       return boolean_false_node;      default:       break;     }
endif|#
directive|endif
comment|/* 0 */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
case|case
name|EQ_EXPR
case|:
case|case
name|NE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|boolean_type_node
expr_stmt|;
return|return
name|expr
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|expr
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
return|;
case|case
name|REAL_CST
case|:
return|return
name|real_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
return|;
case|case
name|ADDR_EXPR
case|:
comment|/* If we are taking the address of an external decl, it might be zero 	 if it is weak, so we cannot optimize.  */
if|if
condition|(
name|DECL_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|boolean_true_node
argument_list|)
return|;
else|else
return|return
name|boolean_true_node
return|;
case|case
name|COMPLEX_EXPR
case|:
return|return
name|build_binary_op
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FFS_EXPR
case|:
comment|/* These don't change whether an object is non-zero or zero.  */
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
comment|/* These don't change whether an object is zero or non-zero, but 	 we can't ignore them if their second arg has side-effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* Distribute the conversion into the arms of a COND_EXPR.  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
comment|/* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE, 	 since that affects how `default_conversion' will behave.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
break|break;
comment|/* fall through...  */
case|case
name|NOP_EXPR
case|:
comment|/* If this is widening the argument, we can ignore it.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* With IEEE arithmetic, x - x may not equal 0, so we can't optimize 	 this case.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
break|break;
comment|/* fall through...  */
case|case
name|BIT_XOR_EXPR
case|:
comment|/* This and MINUS_EXPR can be changed into a comparison of the 	 two objects.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|boolean_type_node
condition|)
comment|/* Using convert here would cause infinite recursion.  */
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|expr
argument_list|)
return|;
break|break;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|warn_parentheses
operator|&&
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around assignment used as truth value"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|tem
init|=
name|save_expr
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
operator|(
name|build_binary_op
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|tree
name|builtin_function_2
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|tree
operator|,
name|tree
operator|,
name|int
operator|,
expr|enum
name|built_in_class
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a variant type in the proper way for C/C++, propagating qualifiers    down to the element type of an array.  */
end_comment

begin_function
name|tree
name|c_build_qualified_type
parameter_list|(
name|type
parameter_list|,
name|type_quals
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|type_quals
decl_stmt|;
block|{
comment|/* A restrict-qualified pointer type must be a pointer to object or      incomplete type.  Note that the use of POINTER_TYPE_P also allows      REFERENCE_TYPEs, which is appropriate for C++.  Unfortunately,      the C++ front-end also use POINTER_TYPE for pointer-to-member      values, so even though it should be illegal to use `restrict'      with such an entity we don't flag that here.  Thus, special case      code for that case is required in the C++ front-end.  */
if|if
condition|(
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_RESTRICT
operator|)
operator|&&
operator|(
operator|!
name|POINTER_TYPE_P
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|C_TYPE_OBJECT_OR_INCOMPLETE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid use of `restrict'"
argument_list|)
expr_stmt|;
name|type_quals
operator|&=
operator|~
name|TYPE_QUAL_RESTRICT
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|build_array_type
argument_list|(
name|c_build_qualified_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|type_quals
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
return|return
name|build_qualified_type
argument_list|(
name|type
argument_list|,
name|type_quals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Apply the TYPE_QUALS to the new DECL.  */
end_comment

begin_function
name|void
name|c_apply_type_quals_to_decl
parameter_list|(
name|type_quals
parameter_list|,
name|decl
parameter_list|)
name|int
name|type_quals
decl_stmt|;
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|type_quals
operator|&
name|TYPE_QUAL_CONST
operator|)
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|)
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_VOLATILE
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|type_quals
operator|&
name|TYPE_QUAL_RESTRICT
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|||
operator|!
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|||
operator|!
name|C_TYPE_OBJECT_OR_INCOMPLETE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"invalid use of `restrict'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_strict_aliasing
condition|)
comment|/* Indicate we need to make a unique alias set for this pointer. 	   We can't do it here because it might be pointing to an 	   incomplete type.  */
name|DECL_POINTER_ALIAS_SET
argument_list|(
name|decl
argument_list|)
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the typed-based alias set for T, which may be an expression    or a type.  Return -1 if we don't do anything special.  */
end_comment

begin_function
name|HOST_WIDE_INT
name|c_common_get_alias_set
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
name|tree
name|u
decl_stmt|;
comment|/* We know nothing about vector types */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|VECTOR_TYPE
condition|)
return|return
literal|0
return|;
comment|/* Permit type-punning when accessing a union, provided the access      is directly through the union.  For example, this code does not      permit taking the address of a union member and then storing      through it.  Even the type-punning allowed here is a GCC      extension, albeit a common and useful one; the C standard says      that such accesses have implementation-defined behavior.  */
for|for
control|(
name|u
operator|=
name|t
init|;
name|TREE_CODE
argument_list|(
name|u
argument_list|)
operator|==
name|COMPONENT_REF
operator|||
name|TREE_CODE
argument_list|(
name|u
argument_list|)
operator|==
name|ARRAY_REF
condition|;
name|u
operator|=
name|TREE_OPERAND
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|u
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|u
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
return|return
literal|0
return|;
comment|/* If this is a char *, the ANSI C standard says it can alias      anything.  Note that all references need do this.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'r'
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* That's all the expressions we handle specially.  */
if|if
condition|(
operator|!
name|TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* The C standard specifically allows aliasing between signed and      unsigned variants of the same type.  We treat the signed      variant as canonical.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|t1
init|=
name|signed_type
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* t1 == t can happen for boolean nodes which are always unsigned.  */
if|if
condition|(
name|t1
operator|!=
name|t
condition|)
return|return
name|get_alias_set
argument_list|(
name|t1
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|POINTER_TYPE_P
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|tree
name|t1
decl_stmt|;
comment|/* Unfortunately, there is no canonical form of a pointer type. 	 In particular, if we have `typedef int I', then `int *', and 	 `I *' are different types.  So, we have to pick a canonical 	 representative.  We do this below.  	 Technically, this approach is actually more conservative that 	 it needs to be.  In particular, `const int *' and `int *' 	 should be in different alias sets, according to the C and C++ 	 standard, since their types are not the same, and so, 	 technically, an `int **' and `const int **' cannot point at 	 the same thing.           But, the standard is wrong.  In particular, this code is 	 legal C++:              int *ip;             int **ipp =&ip;             const int* const* cipp =&ipp;           And, it doesn't make sense for that to be legal unless you 	 can dereference IPP and CIPP.  So, we ignore cv-qualifiers on 	 the pointed-to types.  This issue has been reported to the 	 C++ committee.  */
name|t1
operator|=
name|build_type_no_quals
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t
condition|)
return|return
name|get_alias_set
argument_list|(
name|t1
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of TYPE, measured in bytes.  */
end_comment

begin_function
name|tree
name|c_alignof
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|tree
name|t
decl_stmt|;
comment|/* In C++, sizeof applies to the referent.  Handle alignof the same way.  */
if|if
condition|(
name|code
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|code
operator|=
name|TREE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|FUNCTION_TYPE
condition|)
name|t
operator|=
name|size_int
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|VOID_TYPE
operator|||
name|code
operator|==
name|ERROR_MARK
condition|)
name|t
operator|=
name|size_one_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|COMPLETE_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"__alignof__ applied to an incomplete type"
argument_list|)
expr_stmt|;
name|t
operator|=
name|size_zero_node
expr_stmt|;
block|}
else|else
name|t
operator|=
name|size_int
argument_list|(
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|c_size_type_node
argument_list|,
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement the __alignof keyword: Return the minimum required    alignment of EXPR, measured in bytes.  For VAR_DECL's and    FIELD_DECL's return DECL_ALIGN (which can be set from an    "aligned" __attribute__ specification).  */
end_comment

begin_function
name|tree
name|c_alignof_expr
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|t
operator|=
name|size_int
argument_list|(
name|DECL_ALIGN
argument_list|(
name|expr
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|DECL_C_BIT_FIELD
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"`__alignof' applied to a bit-field"
argument_list|)
expr_stmt|;
name|t
operator|=
name|size_one_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|t
operator|=
name|size_int
argument_list|(
name|DECL_ALIGN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
name|tree
name|t
init|=
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|best
init|=
name|t
decl_stmt|;
name|int
name|bestalign
init|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|int
name|thisalign
decl_stmt|;
name|t
operator|=
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|thisalign
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisalign
operator|>
name|bestalign
condition|)
name|best
operator|=
name|t
operator|,
name|bestalign
operator|=
name|thisalign
expr_stmt|;
block|}
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|best
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|c_alignof
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
return|;
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|c_size_type_node
argument_list|,
name|t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Give the specifications for the format attributes, used by C and all    descendents.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|attribute_spec
name|c_format_attribute_table
index|[]
init|=
block|{
comment|/* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */
block|{
literal|"format"
block|,
literal|3
block|,
literal|3
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|handle_format_attribute
block|}
block|,
block|{
literal|"format_arg"
block|,
literal|1
block|,
literal|1
block|,
name|false
block|,
name|true
block|,
name|true
block|,
name|handle_format_arg_attribute
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|false
block|,
name|false
block|,
name|false
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Build tree nodes and builtin functions common to both C and C++ language    frontends.  */
end_comment

begin_function
name|void
name|c_common_nodes_and_builtins
parameter_list|()
block|{
enum|enum
name|builtin_type
block|{
define|#
directive|define
name|DEF_PRIMITIVE_TYPE
parameter_list|(
name|NAME
parameter_list|,
name|VALUE
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_0
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_1
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_2
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_3
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_4
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_0
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_1
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_2
parameter_list|(
name|NAME
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
value|NAME,
define|#
directive|define
name|DEF_POINTER_TYPE
parameter_list|(
name|NAME
parameter_list|,
name|TYPE
parameter_list|)
value|NAME,
include|#
directive|include
file|"builtin-types.def"
undef|#
directive|undef
name|DEF_PRIMITIVE_TYPE
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_0
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_1
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_2
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_3
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_4
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_0
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_1
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_2
undef|#
directive|undef
name|DEF_POINTER_TYPE
name|BT_LAST
block|}
enum|;
typedef|typedef
name|enum
name|builtin_type
name|builtin_type
typedef|;
name|tree
name|builtin_types
index|[
operator|(
name|int
operator|)
name|BT_LAST
index|]
decl_stmt|;
name|int
name|wchar_type_size
decl_stmt|;
name|tree
name|array_domain_type
decl_stmt|;
comment|/* Either char* or void*.  */
name|tree
name|traditional_ptr_type_node
decl_stmt|;
comment|/* Either const char* or const void*.  */
name|tree
name|traditional_cptr_type_node
decl_stmt|;
name|tree
name|traditional_len_type_node
decl_stmt|;
name|tree
name|va_list_ref_type_node
decl_stmt|;
name|tree
name|va_list_arg_type_node
decl_stmt|;
comment|/* We must initialize this before any builtin functions (which might have      attributes) are declared.  (c_common_init is too late.)  */
name|format_attribute_table
operator|=
name|c_format_attribute_table
expr_stmt|;
comment|/* Define `int' and `char' first so that dbx will output them first.  */
name|record_builtin_type
argument_list|(
name|RID_INT
argument_list|,
name|NULL
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_CHAR
argument_list|,
literal|"char"
argument_list|,
name|char_type_node
argument_list|)
expr_stmt|;
comment|/* `signed' is the same as `int'.  FIXME: the declarations of "signed",      "unsigned long", "long long unsigned" and "unsigned short" were in C++      but not C.  Are the conditionals here needed?  */
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|record_builtin_type
argument_list|(
name|RID_SIGNED
argument_list|,
name|NULL
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_LONG
argument_list|,
literal|"long int"
argument_list|,
name|long_integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long unsigned int"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned long"
argument_list|,
name|long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long int"
argument_list|,
name|long_long_integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned int"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long long unsigned"
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_SHORT
argument_list|,
literal|"short int"
argument_list|,
name|short_integer_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"short unsigned int"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned short"
argument_list|,
name|short_unsigned_type_node
argument_list|)
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"signed char"
argument_list|,
name|signed_char_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"unsigned char"
argument_list|,
name|unsigned_char_type_node
argument_list|)
expr_stmt|;
comment|/* These are types that type_for_size and type_for_mode use.  */
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__int128_t"
argument_list|)
argument_list|,
name|intTI_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|>=
literal|64
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__uint128_t"
argument_list|)
argument_list|,
name|unsigned_intTI_type_node
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Create the widest literal types.  */
name|widest_integer_literal_type_node
operator|=
name|make_signed_type
argument_list|(
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|widest_integer_literal_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|widest_unsigned_literal_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|HOST_BITS_PER_WIDE_INT
operator|*
literal|2
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|widest_unsigned_literal_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* `unsigned long' is the standard type for sizeof.      Note that stddef.h uses `unsigned long',      and this must agree, even if long and int are the same size.  */
name|c_size_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|SIZE_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|signed_size_type_node
operator|=
name|signed_type
argument_list|(
name|c_size_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
name|c_size_type_node
operator|=
name|signed_size_type_node
expr_stmt|;
name|set_sizetype
argument_list|(
name|c_size_type_node
argument_list|)
expr_stmt|;
name|build_common_tree_nodes_2
argument_list|(
name|flag_short_double
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_FLOAT
argument_list|,
name|NULL
argument_list|,
name|float_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_DOUBLE
argument_list|,
name|NULL
argument_list|,
name|double_type_node
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_MAX
argument_list|,
literal|"long double"
argument_list|,
name|long_double_type_node
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex int"
argument_list|)
argument_list|,
name|complex_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex float"
argument_list|)
argument_list|,
name|complex_float_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex double"
argument_list|)
argument_list|,
name|complex_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex long double"
argument_list|)
argument_list|,
name|complex_long_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_VOID
argument_list|,
name|NULL
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
name|void_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|void_zero_node
argument_list|)
operator|=
name|void_type_node
expr_stmt|;
name|void_list_node
operator|=
name|build_void_list_node
argument_list|()
expr_stmt|;
comment|/* Make a type to be the domain of a few array types      whose domains don't really matter.      200 is small enough that it always fits in size_t      and large enough that it can hold most function names for the      initializations of __FUNCTION__ and __PRETTY_FUNCTION__.  */
name|array_domain_type
operator|=
name|build_index_type
argument_list|(
name|size_int
argument_list|(
literal|200
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a type for arrays of characters.      With luck nothing will ever really depend on the length of this      array type.  */
name|char_array_type_node
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
comment|/* Likewise for arrays of ints.  */
name|int_array_type_node
operator|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
name|string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|const_string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_qualified_type
argument_list|(
name|char_type_node
argument_list|,
name|TYPE_QUAL_CONST
argument_list|)
argument_list|)
expr_stmt|;
name|traditional_ptr_type_node
operator|=
operator|(
operator|(
name|flag_traditional
operator|&&
name|c_language
operator|!=
name|clk_cplusplus
operator|)
condition|?
name|string_type_node
else|:
name|ptr_type_node
operator|)
expr_stmt|;
name|traditional_cptr_type_node
operator|=
operator|(
operator|(
name|flag_traditional
operator|&&
name|c_language
operator|!=
name|clk_cplusplus
operator|)
condition|?
name|const_string_type_node
else|:
name|const_ptr_type_node
operator|)
expr_stmt|;
call|(
modifier|*
name|targetm
operator|.
name|init_builtins
call|)
argument_list|()
expr_stmt|;
comment|/* This is special for C++ so functions can be overloaded.  */
name|wchar_type_node
operator|=
name|get_identifier
argument_list|(
name|flag_short_wchar
condition|?
literal|"short unsigned int"
else|:
name|WCHAR_TYPE
argument_list|)
expr_stmt|;
name|wchar_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|wchar_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|wchar_type_size
operator|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
block|{
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|wchar_type_node
argument_list|)
condition|)
name|wchar_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
else|else
name|wchar_type_node
operator|=
name|make_signed_type
argument_list|(
name|wchar_type_size
argument_list|)
expr_stmt|;
name|record_builtin_type
argument_list|(
name|RID_WCHAR
argument_list|,
literal|"wchar_t"
argument_list|,
name|wchar_type_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signed_wchar_type_node
operator|=
name|signed_type
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
name|unsigned_wchar_type_node
operator|=
name|unsigned_type
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
block|}
comment|/* This is for wide string constants.  */
name|wchar_array_type_node
operator|=
name|build_array_type
argument_list|(
name|wchar_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
name|wint_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|WINT_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|intmax_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|INTMAX_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|uintmax_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|UINTMAX_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|default_function_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ptrdiff_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|identifier_global_value
argument_list|(
name|get_identifier
argument_list|(
name|PTRDIFF_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_ptrdiff_type_node
operator|=
name|unsigned_type
argument_list|(
name|ptrdiff_type_node
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__builtin_va_list"
argument_list|)
argument_list|,
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__builtin_ptrdiff_t"
argument_list|)
argument_list|,
name|ptrdiff_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"__builtin_size_t"
argument_list|)
argument_list|,
name|sizetype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|va_list_type_node
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|va_list_arg_type_node
operator|=
name|va_list_ref_type_node
operator|=
name|build_pointer_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|va_list_type_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|va_list_arg_type_node
operator|=
name|va_list_type_node
expr_stmt|;
name|va_list_ref_type_node
operator|=
name|build_reference_type
argument_list|(
name|va_list_type_node
argument_list|)
expr_stmt|;
block|}
name|traditional_len_type_node
operator|=
operator|(
operator|(
name|flag_traditional
operator|&&
name|c_language
operator|!=
name|clk_cplusplus
operator|)
condition|?
name|integer_type_node
else|:
name|sizetype
operator|)
expr_stmt|;
define|#
directive|define
name|DEF_PRIMITIVE_TYPE
parameter_list|(
name|ENUM
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|builtin_types[(int) ENUM] = VALUE;
define|#
directive|define
name|DEF_FUNCTION_TYPE_0
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|)
define|\
value|builtin_types[(int) ENUM]				\     = build_function_type (builtin_types[(int) RETURN],	\ 			   void_list_node);
define|#
directive|define
name|DEF_FUNCTION_TYPE_1
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
define|\
value|builtin_types[(int) ENUM]						\     = build_function_type (builtin_types[(int) RETURN],			\ 			   tree_cons (NULL_TREE,			\ 				      builtin_types[(int) ARG1],	\ 				      void_list_node));
define|#
directive|define
name|DEF_FUNCTION_TYPE_2
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
define|\
value|builtin_types[(int) ENUM]				\     = build_function_type 				\       (builtin_types[(int) RETURN],			\        tree_cons (NULL_TREE,				\ 		  builtin_types[(int) ARG1],		\ 		  tree_cons (NULL_TREE,			\ 			     builtin_types[(int) ARG2],	\ 			     void_list_node)));
define|#
directive|define
name|DEF_FUNCTION_TYPE_3
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|)
define|\
value|builtin_types[(int) ENUM]						 \     = build_function_type						 \       (builtin_types[(int) RETURN],					 \        tree_cons (NULL_TREE,						 \ 		  builtin_types[(int) ARG1],				 \ 		  tree_cons (NULL_TREE,					 \ 			     builtin_types[(int) ARG2],			 \ 			     tree_cons (NULL_TREE,			 \ 					builtin_types[(int) ARG3],	 \ 					void_list_node))));
define|#
directive|define
name|DEF_FUNCTION_TYPE_4
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|,
name|ARG3
parameter_list|,
name|ARG4
parameter_list|)
define|\
value|builtin_types[(int) ENUM]						\     = build_function_type						\       (builtin_types[(int) RETURN],					\        tree_cons (NULL_TREE,						\ 		  builtin_types[(int) ARG1],				\ 		  tree_cons (NULL_TREE,					\ 			     builtin_types[(int) ARG2],			\ 			     tree_cons 					\ 			     (NULL_TREE,				\ 			      builtin_types[(int) ARG3],	 	\ 			      tree_cons (NULL_TREE,			\ 					 builtin_types[(int) ARG4],	\ 					 void_list_node)))));
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_0
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|)
define|\
value|builtin_types[(int) ENUM]						\     = build_function_type (builtin_types[(int) RETURN], NULL_TREE);
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_1
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|)
define|\
value|builtin_types[(int) ENUM]						 \     = build_function_type (builtin_types[(int) RETURN], 		 \ 			   tree_cons (NULL_TREE,			 \ 				      builtin_types[(int) ARG1],	 \ 				      NULL_TREE));
define|#
directive|define
name|DEF_FUNCTION_TYPE_VAR_2
parameter_list|(
name|ENUM
parameter_list|,
name|RETURN
parameter_list|,
name|ARG1
parameter_list|,
name|ARG2
parameter_list|)
define|\
value|builtin_types[(int) ENUM]					\     = build_function_type 					\       (builtin_types[(int) RETURN],				\        tree_cons (NULL_TREE,					\ 		  builtin_types[(int) ARG1],			\ 		  tree_cons (NULL_TREE,				\ 			     builtin_types[(int) ARG2],		\ 			     NULL_TREE)));
define|#
directive|define
name|DEF_POINTER_TYPE
parameter_list|(
name|ENUM
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|builtin_types[(int) ENUM]				\     = build_pointer_type (builtin_types[(int) TYPE]);
include|#
directive|include
file|"builtin-types.def"
undef|#
directive|undef
name|DEF_PRIMITIVE_TYPE
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_1
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_2
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_3
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_4
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_0
undef|#
directive|undef
name|DEF_FUNCTION_TYPE_VAR_1
undef|#
directive|undef
name|DEF_POINTER_TYPE
define|#
directive|define
name|DEF_BUILTIN
parameter_list|(
name|ENUM
parameter_list|,
name|NAME
parameter_list|,
name|CLASS
parameter_list|,					\
name|TYPE
parameter_list|,
name|LIBTYPE
parameter_list|,
name|BOTH_P
parameter_list|,
name|FALLBACK_P
parameter_list|,
name|NONANSI_P
parameter_list|)
define|\
value|if (NAME)								\     {									\       tree decl;							\ 									\       if (strncmp (NAME, "__builtin_", strlen ("__builtin_")) != 0)	\ 	abort ();							\ 									\       if (!BOTH_P)							\ 	decl = builtin_function (NAME, builtin_types[TYPE], ENUM,	\ 				 CLASS,					\ 				 (FALLBACK_P				\ 				  ? (NAME + strlen ("__builtin_"))	\ 				  : NULL));				\       else								\ 	decl = builtin_function_2 (NAME,				\ 				   NAME + strlen ("__builtin_"),	\ 				   builtin_types[TYPE],			\ 				   builtin_types[LIBTYPE],		\ 				   ENUM,				\ 				   CLASS,				\ 				   FALLBACK_P,				\ 				   NONANSI_P,				\
comment|/*noreturn_p=*/
value|0);			\ 									\       built_in_decls[(int) ENUM] = decl;				\     }
include|#
directive|include
file|"builtins.def"
undef|#
directive|undef
name|DEF_BUILTIN
comment|/* Declare _exit and _Exit just to mark them as non-returning.  */
name|builtin_function_2
argument_list|(
name|NULL
argument_list|,
literal|"_exit"
argument_list|,
name|NULL_TREE
argument_list|,
name|builtin_types
index|[
name|BT_FN_VOID_INT
index|]
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|builtin_function_2
argument_list|(
name|NULL
argument_list|,
literal|"_Exit"
argument_list|,
name|NULL_TREE
argument_list|,
name|builtin_types
index|[
name|BT_FN_VOID_INT
index|]
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
operator|!
name|flag_isoc99
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Declare these functions non-returning      to avoid spurious "control drops through" warnings.  */
name|builtin_function_2
argument_list|(
name|NULL
argument_list|,
literal|"abort"
argument_list|,
name|NULL_TREE
argument_list|,
operator|(
operator|(
name|c_language
operator|==
name|clk_cplusplus
operator|)
condition|?
name|builtin_types
index|[
name|BT_FN_VOID
index|]
else|:
name|builtin_types
index|[
name|BT_FN_VOID_VAR
index|]
operator|)
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|builtin_function_2
argument_list|(
name|NULL
argument_list|,
literal|"exit"
argument_list|,
name|NULL_TREE
argument_list|,
operator|(
operator|(
name|c_language
operator|==
name|clk_cplusplus
operator|)
condition|?
name|builtin_types
index|[
name|BT_FN_VOID_INT
index|]
else|:
name|builtin_types
index|[
name|BT_FN_VOID_VAR
index|]
operator|)
argument_list|,
literal|0
argument_list|,
name|NOT_BUILT_IN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|main_identifier_node
operator|=
name|get_identifier
argument_list|(
literal|"main"
argument_list|)
expr_stmt|;
comment|/* ??? Perhaps there's a better place to do this.  But it is related      to __builtin_va_arg, so it isn't that off-the-wall.  */
name|lang_type_promotes_to
operator|=
name|simple_type_promotes_to
expr_stmt|;
block|}
end_function

begin_function
name|tree
name|build_va_arg
parameter_list|(
name|expr
parameter_list|,
name|type
parameter_list|)
name|tree
name|expr
decl_stmt|,
name|type
decl_stmt|;
block|{
return|return
name|build1
argument_list|(
name|VA_ARG_EXPR
argument_list|,
name|type
argument_list|,
name|expr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Linked list of disabled built-in functions.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|disabled_builtin
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|disabled_builtin
modifier|*
name|next
decl_stmt|;
block|}
name|disabled_builtin
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|disabled_builtin
modifier|*
name|disabled_builtins
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|builtin_function_disabled_p
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disable a built-in function specified by -fno-builtin-NAME.  If NAME    begins with "__builtin_", give an error.  */
end_comment

begin_function
name|void
name|disable_builtin_function
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"__builtin_"
argument_list|,
name|strlen
argument_list|(
literal|"__builtin_"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"cannot disable built-in function `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|disabled_builtin
modifier|*
name|new
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|disabled_builtin
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|disabled_builtins
expr_stmt|;
name|disabled_builtins
operator|=
name|new
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return true if the built-in function NAME has been disabled, false    otherwise.  */
end_comment

begin_function
specifier|static
name|bool
name|builtin_function_disabled_p
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|disabled_builtin
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|disabled_builtins
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|p
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/* Possibly define a builtin function with one or two names.  BUILTIN_NAME    is an __builtin_-prefixed name; NAME is the ordinary name; one or both    of these may be NULL (though both being NULL is useless).    BUILTIN_TYPE is the type of the __builtin_-prefixed function;    TYPE is the type of the function with the ordinary name.  These    may differ if the ordinary name is declared with a looser type to avoid    conflicts with headers.  FUNCTION_CODE and CLASS are as for    builtin_function.  If LIBRARY_NAME_P is nonzero, NAME is passed as    the LIBRARY_NAME parameter to builtin_function when declaring BUILTIN_NAME.    If NONANSI_P is nonzero, the name NAME is treated as a non-ANSI name; if    NORETURN_P is nonzero, the function is marked as non-returning.    Returns the declaration of BUILTIN_NAME, if any, otherwise    the declaration of NAME.  Does not declare NAME if flag_no_builtin,    or if NONANSI_P and flag_no_nonansi_builtin.  */
end_comment

begin_function
specifier|static
name|tree
name|builtin_function_2
parameter_list|(
name|builtin_name
parameter_list|,
name|name
parameter_list|,
name|builtin_type
parameter_list|,
name|type
parameter_list|,
name|function_code
parameter_list|,
name|class
parameter_list|,
name|library_name_p
parameter_list|,
name|nonansi_p
parameter_list|,
name|noreturn_p
parameter_list|)
specifier|const
name|char
modifier|*
name|builtin_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|builtin_type
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|int
name|function_code
decl_stmt|;
name|enum
name|built_in_class
name|class
decl_stmt|;
name|int
name|library_name_p
decl_stmt|;
name|int
name|nonansi_p
decl_stmt|;
name|int
name|noreturn_p
decl_stmt|;
block|{
name|tree
name|bdecl
init|=
name|NULL_TREE
decl_stmt|;
name|tree
name|decl
init|=
name|NULL_TREE
decl_stmt|;
if|if
condition|(
name|builtin_name
operator|!=
literal|0
condition|)
block|{
name|bdecl
operator|=
name|builtin_function
argument_list|(
name|builtin_name
argument_list|,
name|builtin_type
argument_list|,
name|function_code
argument_list|,
name|class
argument_list|,
name|library_name_p
condition|?
name|name
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|noreturn_p
condition|)
block|{
name|TREE_THIS_VOLATILE
argument_list|(
name|bdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|bdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
operator|!=
literal|0
operator|&&
operator|!
name|flag_no_builtin
operator|&&
operator|!
name|builtin_function_disabled_p
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
operator|(
name|nonansi_p
operator|&&
name|flag_no_nonansi_builtin
operator|)
condition|)
block|{
name|decl
operator|=
name|builtin_function
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|function_code
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonansi_p
condition|)
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|noreturn_p
condition|)
block|{
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|bdecl
operator|!=
literal|0
condition|?
name|bdecl
else|:
name|decl
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Nonzero if the type T promotes to int.  This is (nearly) the    integral promotions defined in ISO C99 6.3.1.1/2.  */
end_comment

begin_function
name|bool
name|c_promoting_integer_type_p
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
return|return
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|char_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|signed_char_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|unsigned_char_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|short_integer_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
operator|==
name|short_unsigned_type_node
operator|||
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
return|;
case|case
name|ENUMERAL_TYPE
case|:
comment|/* ??? Technically all enumerations not larger than an int 	 promote to an int.  But this is used along code paths 	 that only want to notice a size change.  */
return|return
name|TYPE_PRECISION
argument_list|(
name|t
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
return|;
case|case
name|BOOLEAN_TYPE
case|:
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Given a type, apply default promotions wrt unnamed function arguments    and return the new type.  Return NULL_TREE if no change.  */
end_comment

begin_comment
comment|/* ??? There is a function of the same name in the C++ front end that    does something similar, but is more thorough and does not return NULL    if no change.  We could perhaps share code, but it would make the    self_promoting_type property harder to identify.  */
end_comment

begin_function
name|tree
name|simple_type_promotes_to
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Traditionally, unsignedness is preserved in default promotions.          Also preserve unsignedness if not really getting any wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|flag_traditional
operator|||
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
return|return
name|unsigned_type_node
return|;
return|return
name|integer_type_node
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Return 1 if PARMS specifies a fixed number of parameters    and none of their types is affected by default promotions.  */
end_comment

begin_function
name|int
name|self_promoting_args_p
parameter_list|(
name|parms
parameter_list|)
name|tree
name|parms
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|parms
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|!=
name|void_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c_promoting_integer_type_p
argument_list|(
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Recursively examines the array elements of TYPE, until a non-array    element type is found.  */
end_comment

begin_function
name|tree
name|strip_array_types
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
while|while
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Recognize certain built-in functions so we can make tree-codes    other than CALL_EXPR.  We do this when it enables fold-const.c    to do something useful.  */
end_comment

begin_comment
comment|/* ??? By rights this should go in builtins.c, but only C and C++    implement build_{binary,unary}_op.  Not exactly sure what bits    of functionality are actually needed from those functions, or    where the similar functionality exists in the other front ends.  */
end_comment

begin_function
name|tree
name|expand_tree_builtin
parameter_list|(
name|function
parameter_list|,
name|params
parameter_list|,
name|coerced_params
parameter_list|)
name|tree
name|function
decl_stmt|,
name|params
decl_stmt|,
name|coerced_params
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
if|if
condition|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|function
argument_list|)
operator|!=
name|BUILT_IN_NORMAL
condition|)
return|return
name|NULL_TREE
return|;
switch|switch
condition|(
name|DECL_FUNCTION_CODE
argument_list|(
name|function
argument_list|)
condition|)
block|{
case|case
name|BUILT_IN_ABS
case|:
case|case
name|BUILT_IN_LABS
case|:
case|case
name|BUILT_IN_LLABS
case|:
case|case
name|BUILT_IN_IMAXABS
case|:
case|case
name|BUILT_IN_FABS
case|:
case|case
name|BUILT_IN_FABSL
case|:
case|case
name|BUILT_IN_FABSF
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|ABS_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_CONJ
case|:
case|case
name|BUILT_IN_CONJF
case|:
case|case
name|BUILT_IN_CONJL
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|CONJ_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_CREAL
case|:
case|case
name|BUILT_IN_CREALF
case|:
case|case
name|BUILT_IN_CREALL
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_CIMAG
case|:
case|case
name|BUILT_IN_CIMAGF
case|:
case|case
name|BUILT_IN_CIMAGL
case|:
if|if
condition|(
name|coerced_params
operator|==
literal|0
condition|)
return|return
name|integer_zero_node
return|;
return|return
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|TREE_VALUE
argument_list|(
name|coerced_params
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|BUILT_IN_ISGREATER
case|:
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
condition|)
name|code
operator|=
name|UNLE_EXPR
expr_stmt|;
else|else
name|code
operator|=
name|LE_EXPR
expr_stmt|;
goto|goto
name|unordered_cmp
goto|;
case|case
name|BUILT_IN_ISGREATEREQUAL
case|:
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
condition|)
name|code
operator|=
name|UNLT_EXPR
expr_stmt|;
else|else
name|code
operator|=
name|LT_EXPR
expr_stmt|;
goto|goto
name|unordered_cmp
goto|;
case|case
name|BUILT_IN_ISLESS
case|:
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
condition|)
name|code
operator|=
name|UNGE_EXPR
expr_stmt|;
else|else
name|code
operator|=
name|GE_EXPR
expr_stmt|;
goto|goto
name|unordered_cmp
goto|;
case|case
name|BUILT_IN_ISLESSEQUAL
case|:
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
condition|)
name|code
operator|=
name|UNGT_EXPR
expr_stmt|;
else|else
name|code
operator|=
name|GT_EXPR
expr_stmt|;
goto|goto
name|unordered_cmp
goto|;
case|case
name|BUILT_IN_ISLESSGREATER
case|:
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
condition|)
name|code
operator|=
name|UNEQ_EXPR
expr_stmt|;
else|else
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
goto|goto
name|unordered_cmp
goto|;
case|case
name|BUILT_IN_ISUNORDERED
case|:
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
condition|)
return|return
name|integer_zero_node
return|;
name|code
operator|=
name|UNORDERED_EXPR
expr_stmt|;
goto|goto
name|unordered_cmp
goto|;
name|unordered_cmp
label|:
block|{
name|tree
name|arg0
decl_stmt|,
name|arg1
decl_stmt|;
if|if
condition|(
name|params
operator|==
literal|0
operator|||
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"too few arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"too many arguments to function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|function
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
name|arg0
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|arg0
operator|=
name|build_binary_op
argument_list|(
name|code
argument_list|,
name|arg0
argument_list|,
name|arg1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|UNORDERED_EXPR
condition|)
name|arg0
operator|=
name|build_unary_op
argument_list|(
name|TRUTH_NOT_EXPR
argument_list|,
name|arg0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|arg0
return|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if CODE is the code for a statement.  */
end_comment

begin_function
name|int
name|statement_code_p
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|EXPR_STMT
case|:
case|case
name|COMPOUND_STMT
case|:
case|case
name|DECL_STMT
case|:
case|case
name|IF_STMT
case|:
case|case
name|FOR_STMT
case|:
case|case
name|WHILE_STMT
case|:
case|case
name|DO_STMT
case|:
case|case
name|RETURN_STMT
case|:
case|case
name|BREAK_STMT
case|:
case|case
name|CONTINUE_STMT
case|:
case|case
name|SCOPE_STMT
case|:
case|case
name|SWITCH_STMT
case|:
case|case
name|GOTO_STMT
case|:
case|case
name|LABEL_STMT
case|:
case|case
name|ASM_STMT
case|:
case|case
name|FILE_STMT
case|:
case|case
name|CASE_LABEL
case|:
return|return
literal|1
return|;
default|default:
if|if
condition|(
name|lang_statement_code_p
condition|)
return|return
call|(
modifier|*
name|lang_statement_code_p
call|)
argument_list|(
name|code
argument_list|)
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Walk the statement tree, rooted at *tp.  Apply FUNC to all the    sub-trees of *TP in a pre-order traversal.  FUNC is called with the    DATA and the address of each sub-tree.  If FUNC returns a non-NULL    value, the traversal is aborted, and the value returned by FUNC is    returned.  If FUNC sets WALK_SUBTREES to zero, then the subtrees of    the node being visited are not walked.     We don't need a without_duplicates variant of this one because the    statement tree is a tree, not a graph.  */
end_comment

begin_function
name|tree
name|walk_stmt_tree
parameter_list|(
name|tp
parameter_list|,
name|func
parameter_list|,
name|data
parameter_list|)
name|tree
modifier|*
name|tp
decl_stmt|;
name|walk_tree_fn
name|func
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|enum
name|tree_code
name|code
decl_stmt|;
name|int
name|walk_subtrees
decl_stmt|;
name|tree
name|result
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
define|#
directive|define
name|WALK_SUBTREE
parameter_list|(
name|NODE
parameter_list|)
define|\
value|do							\     {							\       result = walk_stmt_tree (&(NODE), func, data);	\       if (result)					\ 	return result;					\     }							\   while (0)
comment|/* Skip empty subtrees.  */
if|if
condition|(
operator|!
operator|*
name|tp
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Skip subtrees below non-statement nodes.  */
if|if
condition|(
operator|!
name|statement_code_p
argument_list|(
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Call the function.  */
name|walk_subtrees
operator|=
literal|1
expr_stmt|;
name|result
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|tp
argument_list|,
operator|&
name|walk_subtrees
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* If we found something, return it.  */
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
comment|/* FUNC may have modified the tree, recheck that we're looking at a      statement node.  */
name|code
operator|=
name|TREE_CODE
argument_list|(
operator|*
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|statement_code_p
argument_list|(
name|code
argument_list|)
condition|)
return|return
name|NULL_TREE
return|;
comment|/* Visit the subtrees unless FUNC decided that there was nothing      interesting below this point in the tree.  */
if|if
condition|(
name|walk_subtrees
condition|)
block|{
comment|/* Walk over all the sub-trees of this operand.  Statement nodes 	 never contain RTL, and we needn't worry about TARGET_EXPRs.  */
name|len
operator|=
name|TREE_CODE_LENGTH
argument_list|(
name|code
argument_list|)
expr_stmt|;
comment|/* Go through the subtrees.  We need to do this in forward order so 	 that the scope of a FOR_EXPR is handled properly.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|WALK_SUBTREE
argument_list|(
name|TREE_OPERAND
argument_list|(
operator|*
name|tp
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Finally visit the chain.  This can be tail-recursion optimized if      we write it this way.  */
return|return
name|walk_stmt_tree
argument_list|(
operator|&
name|TREE_CHAIN
argument_list|(
operator|*
name|tp
argument_list|)
argument_list|,
name|func
argument_list|,
name|data
argument_list|)
return|;
undef|#
directive|undef
name|WALK_SUBTREE
block|}
end_function

begin_comment
comment|/* Used to compare case labels.  K1 and K2 are actually tree nodes    representing case labels, or NULL_TREE for a `default' label.    Returns -1 if K1 is ordered before K2, -1 if K1 is ordered after    K2, and 0 if K1 and K2 are equal.  */
end_comment

begin_function
name|int
name|case_compare
parameter_list|(
name|k1
parameter_list|,
name|k2
parameter_list|)
name|splay_tree_key
name|k1
decl_stmt|;
name|splay_tree_key
name|k2
decl_stmt|;
block|{
comment|/* Consider a NULL key (such as arises with a `default' label) to be      smaller than anything else.  */
if|if
condition|(
operator|!
name|k1
condition|)
return|return
name|k2
condition|?
operator|-
literal|1
else|:
literal|0
return|;
elseif|else
if|if
condition|(
operator|!
name|k2
condition|)
return|return
name|k1
condition|?
literal|1
else|:
literal|0
return|;
return|return
name|tree_int_cst_compare
argument_list|(
operator|(
name|tree
operator|)
name|k1
argument_list|,
operator|(
name|tree
operator|)
name|k2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Process a case label for the range LOW_VALUE ... HIGH_VALUE.  If    LOW_VALUE and HIGH_VALUE are both NULL_TREE then this case label is    actually a `default' label.  If only HIGH_VALUE is NULL_TREE, then    case label was declared using the usual C/C++ syntax, rather than    the GNU case range extension.  CASES is a tree containing all the    case ranges processed so far; COND is the condition for the    switch-statement itself.  Returns the CASE_LABEL created, or    ERROR_MARK_NODE if no CASE_LABEL is created.  */
end_comment

begin_function
name|tree
name|c_add_case_label
parameter_list|(
name|cases
parameter_list|,
name|cond
parameter_list|,
name|low_value
parameter_list|,
name|high_value
parameter_list|)
name|splay_tree
name|cases
decl_stmt|;
name|tree
name|cond
decl_stmt|;
name|tree
name|low_value
decl_stmt|;
name|tree
name|high_value
decl_stmt|;
block|{
name|tree
name|type
decl_stmt|;
name|tree
name|label
decl_stmt|;
name|tree
name|case_label
decl_stmt|;
name|splay_tree_node
name|node
decl_stmt|;
comment|/* Create the LABEL_DECL itself.  */
name|label
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_CONTEXT
argument_list|(
name|label
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* If there was an error processing the switch condition, bail now      before we get more confused.  */
if|if
condition|(
operator|!
name|cond
operator|||
name|cond
operator|==
name|error_mark_node
condition|)
block|{
comment|/* Add a label anyhow so that the back-end doesn't think that 	 the beginning of the switch is unreachable.  */
if|if
condition|(
operator|!
name|cases
operator|->
name|root
condition|)
name|add_stmt
argument_list|(
name|build_case_label
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
if|if
condition|(
operator|(
name|low_value
operator|&&
name|TREE_TYPE
argument_list|(
name|low_value
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|low_value
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
name|high_value
operator|&&
name|TREE_TYPE
argument_list|(
name|high_value
argument_list|)
operator|&&
name|POINTER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|high_value
argument_list|)
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"pointers are not permitted as case values"
argument_list|)
expr_stmt|;
comment|/* Case ranges are a GNU extension.  */
if|if
condition|(
name|high_value
operator|&&
name|pedantic
condition|)
block|{
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids range expressions in switch statements"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C forbids range expressions in switch statements"
argument_list|)
expr_stmt|;
block|}
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|low_value
condition|)
block|{
name|low_value
operator|=
name|check_case_value
argument_list|(
name|low_value
argument_list|)
expr_stmt|;
name|low_value
operator|=
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|low_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|high_value
condition|)
block|{
name|high_value
operator|=
name|check_case_value
argument_list|(
name|high_value
argument_list|)
expr_stmt|;
name|high_value
operator|=
name|convert_and_check
argument_list|(
name|type
argument_list|,
name|high_value
argument_list|)
expr_stmt|;
block|}
comment|/* If an error has occurred, bail out now.  */
if|if
condition|(
name|low_value
operator|==
name|error_mark_node
operator|||
name|high_value
operator|==
name|error_mark_node
condition|)
block|{
if|if
condition|(
operator|!
name|cases
operator|->
name|root
condition|)
name|add_stmt
argument_list|(
name|build_case_label
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error_mark_node
return|;
block|}
comment|/* If the LOW_VALUE and HIGH_VALUE are the same, then this isn't      really a case range, even though it was written that way.  Remove      the HIGH_VALUE to simplify later processing.  */
if|if
condition|(
name|tree_int_cst_equal
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|)
condition|)
name|high_value
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|low_value
operator|&&
name|high_value
operator|&&
operator|!
name|tree_int_cst_lt
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|)
condition|)
name|warning
argument_list|(
literal|"empty range specified"
argument_list|)
expr_stmt|;
comment|/* Look up the LOW_VALUE in the table of case labels we already      have.  */
name|node
operator|=
name|splay_tree_lookup
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|)
expr_stmt|;
comment|/* If there was not an exact match, check for overlapping ranges.      There's no need to do this if there's no LOW_VALUE or HIGH_VALUE;      that's a `default' label and the only overlap is an exact match.  */
if|if
condition|(
operator|!
name|node
operator|&&
operator|(
name|low_value
operator|||
name|high_value
operator|)
condition|)
block|{
name|splay_tree_node
name|low_bound
decl_stmt|;
name|splay_tree_node
name|high_bound
decl_stmt|;
comment|/* Even though there wasn't an exact match, there might be an 	 overlap between this case range and another case range. 	 Since we've (inductively) not allowed any overlapping case 	 ranges, we simply need to find the greatest low case label 	 that is smaller that LOW_VALUE, and the smallest low case 	 label that is greater than LOW_VALUE.  If there is an overlap 	 it will occur in one of these two ranges.  */
name|low_bound
operator|=
name|splay_tree_predecessor
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|)
expr_stmt|;
name|high_bound
operator|=
name|splay_tree_successor
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|)
expr_stmt|;
comment|/* Check to see if the LOW_BOUND overlaps.  It is smaller than 	 the LOW_VALUE, so there is no need to check unless the 	 LOW_BOUND is in fact itself a case range.  */
if|if
condition|(
name|low_bound
operator|&&
name|CASE_HIGH
argument_list|(
operator|(
name|tree
operator|)
name|low_bound
operator|->
name|value
argument_list|)
operator|&&
name|tree_int_cst_compare
argument_list|(
name|CASE_HIGH
argument_list|(
operator|(
name|tree
operator|)
name|low_bound
operator|->
name|value
argument_list|)
argument_list|,
name|low_value
argument_list|)
operator|>=
literal|0
condition|)
name|node
operator|=
name|low_bound
expr_stmt|;
comment|/* Check to see if the HIGH_BOUND overlaps.  The low end of that 	 range is bigger than the low end of the current range, so we 	 are only interested if the current range is a real range, and 	 not an ordinary case label.  */
elseif|else
if|if
condition|(
name|high_bound
operator|&&
name|high_value
operator|&&
operator|(
name|tree_int_cst_compare
argument_list|(
operator|(
name|tree
operator|)
name|high_bound
operator|->
name|key
argument_list|,
name|high_value
argument_list|)
operator|<=
literal|0
operator|)
condition|)
name|node
operator|=
name|high_bound
expr_stmt|;
block|}
comment|/* If there was an overlap, issue an error.  */
if|if
condition|(
name|node
condition|)
block|{
name|tree
name|duplicate
init|=
name|CASE_LABEL_DECL
argument_list|(
operator|(
name|tree
operator|)
name|node
operator|->
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|high_value
condition|)
block|{
name|error
argument_list|(
literal|"duplicate (or overlapping) case value"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|duplicate
argument_list|,
literal|"this is the first entry overlapping that value"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|low_value
condition|)
block|{
name|error
argument_list|(
literal|"duplicate case value"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|duplicate
argument_list|,
literal|"previously used here"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"multiple default labels in one switch"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|duplicate
argument_list|,
literal|"this is the first default label"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cases
operator|->
name|root
condition|)
name|add_stmt
argument_list|(
name|build_case_label
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add a CASE_LABEL to the statement-tree.  */
name|case_label
operator|=
name|add_stmt
argument_list|(
name|build_case_label
argument_list|(
name|low_value
argument_list|,
name|high_value
argument_list|,
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Register this case label in the splay tree.  */
name|splay_tree_insert
argument_list|(
name|cases
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|low_value
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|case_label
argument_list|)
expr_stmt|;
return|return
name|case_label
return|;
block|}
end_function

begin_comment
comment|/* Finish an expression taking the address of LABEL.  Returns an    expression for the address.  */
end_comment

begin_function
name|tree
name|finish_label_address_expr
parameter_list|(
name|label
parameter_list|)
name|tree
name|label
decl_stmt|;
block|{
name|tree
name|result
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|c_language
operator|==
name|clk_cplusplus
condition|)
name|pedwarn
argument_list|(
literal|"ISO C++ forbids taking the address of a label"
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ISO C forbids taking the address of a label"
argument_list|)
expr_stmt|;
block|}
name|label
operator|=
name|lookup_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|==
name|NULL_TREE
condition|)
name|result
operator|=
name|null_pointer_node
expr_stmt|;
else|else
block|{
name|TREE_USED
argument_list|(
name|label
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|ptr_type_node
argument_list|,
name|label
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|result
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The current function in not necessarily uninlinable. 	 Computed gotos are incompatible with inlining, but the value 	 here could be used only in a diagnostic, for example.  */
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Mark P (a stmt_tree) for GC.  The use of a `void *' for the    parameter allows this function to be used as a GC-marking    function.  */
end_comment

begin_function
name|void
name|mark_stmt_tree
parameter_list|(
name|p
parameter_list|)
name|void
modifier|*
name|p
decl_stmt|;
block|{
name|stmt_tree
name|st
init|=
operator|(
name|stmt_tree
operator|)
name|p
decl_stmt|;
name|ggc_mark_tree
argument_list|(
name|st
operator|->
name|x_last_stmt
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|st
operator|->
name|x_last_expr_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark LD for GC.  */
end_comment

begin_function
name|void
name|c_mark_lang_decl
parameter_list|(
name|c
parameter_list|)
name|struct
name|c_lang_decl
modifier|*
name|c
name|ATTRIBUTE_UNUSED
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Mark F for GC.  */
end_comment

begin_function
name|void
name|mark_c_language_function
parameter_list|(
name|f
parameter_list|)
name|struct
name|language_function
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|f
condition|)
return|return;
name|mark_stmt_tree
argument_list|(
operator|&
name|f
operator|->
name|x_stmt_tree
argument_list|)
expr_stmt|;
name|ggc_mark_tree
argument_list|(
name|f
operator|->
name|x_scope_stmt_stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Hook used by expand_expr to expand language-specific tree codes.  */
end_comment

begin_function
name|rtx
name|c_expand_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|STMT_EXPR
case|:
block|{
name|tree
name|rtl_expr
decl_stmt|;
name|rtx
name|result
decl_stmt|;
comment|/* Since expand_expr_stmt calls free_temp_slots after every 	   expression statement, we must call push_temp_slots here. 	   Otherwise, any temporaries in use now would be considered 	   out-of-scope after the first EXPR_STMT from within the 	   STMT_EXPR.  */
name|push_temp_slots
argument_list|()
expr_stmt|;
name|rtl_expr
operator|=
name|expand_start_stmt_expr
argument_list|()
expr_stmt|;
comment|/* If we want the result of this expression, find the last            EXPR_STMT in the COMPOUND_STMT and mark it as addressable.  */
if|if
condition|(
name|target
operator|!=
name|const0_rtx
operator|&&
name|TREE_CODE
argument_list|(
name|STMT_EXPR_STMT
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|COMPOUND_STMT
operator|&&
name|TREE_CODE
argument_list|(
name|COMPOUND_BODY
argument_list|(
name|STMT_EXPR_STMT
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
operator|==
name|SCOPE_STMT
condition|)
block|{
name|tree
name|expr
init|=
name|COMPOUND_BODY
argument_list|(
name|STMT_EXPR_STMT
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|last
init|=
name|TREE_CHAIN
argument_list|(
name|expr
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
condition|)
block|{
name|expr
operator|=
name|last
expr_stmt|;
name|last
operator|=
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|last
argument_list|)
operator|==
name|SCOPE_STMT
operator|&&
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|EXPR_STMT
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|expr
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|expand_stmt
argument_list|(
name|STMT_EXPR_STMT
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|expand_end_stmt_expr
argument_list|(
name|rtl_expr
argument_list|)
expr_stmt|;
name|result
operator|=
name|expand_expr
argument_list|(
name|rtl_expr
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
name|pop_temp_slots
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
break|break;
case|case
name|CALL_EXPR
case|:
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|&&
operator|(
name|DECL_BUILT_IN_CLASS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|BUILT_IN_FRONTEND
operator|)
condition|)
return|return
name|c_expand_builtin
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|COMPOUND_LITERAL_EXPR
case|:
block|{
comment|/* Initialize the anonymous variable declared in the compound 	   literal, then return the variable.  */
name|tree
name|decl
init|=
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|emit_local_var
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|expand_expr
argument_list|(
name|decl
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Hook used by safe_from_p to handle language-specific tree codes.  */
end_comment

begin_function
name|int
name|c_safe_from_p
parameter_list|(
name|target
parameter_list|,
name|exp
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|tree
name|exp
decl_stmt|;
block|{
comment|/* We can see statements here when processing the body of a      statement-expression.  For a declaration statement declaring a      variable, look at the variable's initializer.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|DECL_STMT
condition|)
block|{
name|tree
name|decl
init|=
name|DECL_STMT_DECL
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
comment|/*top_p=*/
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* For any statement, we must follow the statement-chain.  */
if|if
condition|(
name|statement_code_p
argument_list|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|&&
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|safe_from_p
argument_list|(
name|target
argument_list|,
name|TREE_CHAIN
argument_list|(
name|exp
argument_list|)
argument_list|,
comment|/*top_p=*/
literal|0
argument_list|)
return|;
comment|/* Assume everything else is safe.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Hook used by unsafe_for_reeval to handle language-specific tree codes.  */
end_comment

begin_function
name|int
name|c_unsafe_for_reeval
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
comment|/* Statement expressions may not be reevaluated.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STMT_EXPR
condition|)
return|return
literal|2
return|;
comment|/* Walk all other expressions.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Hook used by staticp to handle language-specific tree codes.  */
end_comment

begin_function
name|int
name|c_staticp
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|COMPOUND_LITERAL_EXPR
operator|&&
name|TREE_STATIC
argument_list|(
name|COMPOUND_LITERAL_EXPR_DECL
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Tree code classes.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|TYPE,
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|c_tree_code_type
index|[]
init|=
block|{
literal|'x'
block|,
include|#
directive|include
file|"c-common.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Table indexed by tree code giving number of expression    operands beyond the fixed part of the node structure.    Not used for types or decls.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LENGTH
parameter_list|)
value|LENGTH,
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|c_tree_code_length
index|[]
init|=
block|{
literal|0
block|,
include|#
directive|include
file|"c-common.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Names of tree components.    Used for printing out the tree and error messages.  */
end_comment

begin_define
define|#
directive|define
name|DEFTREECODE
parameter_list|(
name|SYM
parameter_list|,
name|NAME
parameter_list|,
name|TYPE
parameter_list|,
name|LEN
parameter_list|)
value|NAME,
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|c_tree_code_name
index|[]
init|=
block|{
literal|"@@dummy"
block|,
include|#
directive|include
file|"c-common.def"
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|DEFTREECODE
end_undef

begin_comment
comment|/* Adds the tree codes specific to the C front end to the list of all    tree codes.  */
end_comment

begin_function
name|void
name|add_c_tree_codes
parameter_list|()
block|{
name|memcpy
argument_list|(
name|tree_code_type
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
argument_list|,
name|c_tree_code_type
argument_list|,
operator|(
name|int
operator|)
name|LAST_C_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tree_code_length
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
argument_list|,
name|c_tree_code_length
argument_list|,
operator|(
name|LAST_C_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tree_code_name
operator|+
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
argument_list|,
name|c_tree_code_name
argument_list|,
operator|(
name|LAST_C_TREE_CODE
operator|-
operator|(
name|int
operator|)
name|LAST_AND_UNUSED_TREE_CODE
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|lang_unsafe_for_reeval
operator|=
name|c_unsafe_for_reeval
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CALLED_AS_BUILT_IN
parameter_list|(
name|NODE
parameter_list|)
define|\
value|(!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), "__builtin_", 10))
end_define

begin_function
specifier|static
name|rtx
name|c_expand_builtin
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|tree
name|fndecl
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|arglist
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|built_in_function
name|fcode
init|=
name|DECL_FUNCTION_CODE
argument_list|(
name|fndecl
argument_list|)
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|const
name|int
name|ignore
init|=
operator|(
name|target
operator|==
name|const0_rtx
operator|||
operator|(
operator|(
name|code
operator|==
name|NON_LVALUE_EXPR
operator|||
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
operator|||
name|code
operator|==
name|REFERENCE_EXPR
operator|||
name|code
operator|==
name|COND_EXPR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|VOID_TYPE
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|optimize
operator|&&
operator|!
name|CALLED_AS_BUILT_IN
argument_list|(
name|fndecl
argument_list|)
condition|)
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
switch|switch
condition|(
name|fcode
condition|)
block|{
case|case
name|BUILT_IN_PRINTF
case|:
name|target
operator|=
name|c_expand_builtin_printf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|ignore
argument_list|,
comment|/*unlocked=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_PRINTF_UNLOCKED
case|:
name|target
operator|=
name|c_expand_builtin_printf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|ignore
argument_list|,
comment|/*unlocked=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPRINTF
case|:
name|target
operator|=
name|c_expand_builtin_fprintf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|ignore
argument_list|,
comment|/*unlocked=*/
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
case|case
name|BUILT_IN_FPRINTF_UNLOCKED
case|:
name|target
operator|=
name|c_expand_builtin_fprintf
argument_list|(
name|arglist
argument_list|,
name|target
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|,
name|ignore
argument_list|,
comment|/*unlocked=*/
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
return|return
name|target
return|;
break|break;
default|default:
comment|/* just do library call, if unknown builtin */
name|error
argument_list|(
literal|"built-in function `%s' not currently supported"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The switch statement above can drop through to cause the function      to be called normally.  */
return|return
name|expand_call
argument_list|(
name|exp
argument_list|,
name|target
argument_list|,
name|ignore
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check an arglist to *printf for problems.  The arglist should start    at the format specifier, with the remaining arguments immediately    following it.  */
end_comment

begin_function
specifier|static
name|int
name|is_valid_printf_arglist
parameter_list|(
name|arglist
parameter_list|)
name|tree
name|arglist
decl_stmt|;
block|{
comment|/* Save this value so we can restore it later.  */
specifier|const
name|int
name|SAVE_pedantic
init|=
name|pedantic
decl_stmt|;
name|int
name|diagnostic_occurred
init|=
literal|0
decl_stmt|;
name|tree
name|attrs
decl_stmt|;
comment|/* Set this to a known value so the user setting won't affect code      generation.  */
name|pedantic
operator|=
literal|1
expr_stmt|;
comment|/* Check to make sure there are no format specifier errors.  */
name|attrs
operator|=
name|tree_cons
argument_list|(
name|get_identifier
argument_list|(
literal|"format"
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|get_identifier
argument_list|(
literal|"printf"
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_one_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_int_2
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|check_function_format
argument_list|(
operator|&
name|diagnostic_occurred
argument_list|,
name|attrs
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
comment|/* Restore the value of `pedantic'.  */
name|pedantic
operator|=
name|SAVE_pedantic
expr_stmt|;
comment|/* If calling `check_function_format_ptr' produces a warning, we      return false, otherwise we return true.  */
return|return
operator|!
name|diagnostic_occurred
return|;
block|}
end_function

begin_comment
comment|/* If the arguments passed to printf are suitable for optimizations,    we attempt to transform the call.  */
end_comment

begin_function
specifier|static
name|rtx
name|c_expand_builtin_printf
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|,
name|ignore
parameter_list|,
name|unlocked
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|int
name|unlocked
decl_stmt|;
block|{
name|tree
name|fn_putchar
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_PUTCHAR_UNLOCKED
index|]
else|:
name|built_in_decls
index|[
name|BUILT_IN_PUTCHAR
index|]
decl_stmt|;
name|tree
name|fn_puts
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_PUTS_UNLOCKED
index|]
else|:
name|built_in_decls
index|[
name|BUILT_IN_PUTS
index|]
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|format_arg
decl_stmt|,
name|stripped_string
decl_stmt|;
comment|/* If the return value is used, or the replacement _DECL isn't      initialized, don't do the transformation.  */
if|if
condition|(
operator|!
name|ignore
operator|||
operator|!
name|fn_putchar
operator|||
operator|!
name|fn_puts
condition|)
return|return
literal|0
return|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
name|arglist
operator|==
literal|0
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Check the specifier vs. the parameters.  */
if|if
condition|(
operator|!
name|is_valid_printf_arglist
argument_list|(
name|arglist
argument_list|)
condition|)
return|return
literal|0
return|;
name|format_arg
operator|=
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|stripped_string
operator|=
name|format_arg
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|stripped_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|stripped_string
operator|&&
name|TREE_CODE
argument_list|(
name|stripped_string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|stripped_string
operator|=
name|TREE_OPERAND
argument_list|(
name|stripped_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the format specifier isn't a STRING_CST, punt.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stripped_string
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return
literal|0
return|;
comment|/* OK!  We can attempt optimization.  */
comment|/* If the format specifier was "%s\n", call __builtin_puts(arg2).  */
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|"%s\n"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_puts
expr_stmt|;
block|}
comment|/* If the format specifier was "%c", call __builtin_putchar (arg2).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|"%c"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arglist
operator|=
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_putchar
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't handle anything else with % args or %% ... yet.  */
if|if
condition|(
name|strchr
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|'%'
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* If the resulting constant string has a length of 1, call          putchar.  Note, TREE_STRING_LENGTH includes the terminating          NULL in its count.  */
if|if
condition|(
name|TREE_STRING_LENGTH
argument_list|(
name|stripped_string
argument_list|)
operator|==
literal|2
condition|)
block|{
comment|/* Given printf("c"), (where c is any one character,)              convert "c"[0] to an int and pass that to the replacement              function.  */
name|arglist
operator|=
name|build_int_2
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_putchar
expr_stmt|;
block|}
comment|/* If the resulting constant was "string\n", call          __builtin_puts("string").  Ensure "string" has at least one          character besides the trailing \n.  Note, TREE_STRING_LENGTH          includes the terminating NULL in its count.  */
elseif|else
if|if
condition|(
name|TREE_STRING_LENGTH
argument_list|(
name|stripped_string
argument_list|)
operator|>
literal|2
operator|&&
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
index|[
name|TREE_STRING_LENGTH
argument_list|(
name|stripped_string
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* Create a NULL-terminated string that's one char shorter 	     than the original, stripping off the trailing '\n'.  */
specifier|const
name|int
name|newlen
init|=
name|TREE_STRING_LENGTH
argument_list|(
name|stripped_string
argument_list|)
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|newstr
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|newlen
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|newstr
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
name|newlen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|newstr
index|[
name|newlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|arglist
operator|=
name|combine_strings
argument_list|(
name|build_string
argument_list|(
name|newlen
argument_list|,
name|newstr
argument_list|)
argument_list|)
expr_stmt|;
name|arglist
operator|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_puts
expr_stmt|;
block|}
else|else
comment|/* We'd like to arrange to call fputs(string) here, but we            need stdout and don't have a way to get it ... yet.  */
return|return
literal|0
return|;
block|}
return|return
name|expand_expr
argument_list|(
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
operator|(
name|ignore
condition|?
name|const0_rtx
else|:
name|target
operator|)
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the arguments passed to fprintf are suitable for optimizations,    we attempt to transform the call.  */
end_comment

begin_function
specifier|static
name|rtx
name|c_expand_builtin_fprintf
parameter_list|(
name|arglist
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|,
name|ignore
parameter_list|,
name|unlocked
parameter_list|)
name|tree
name|arglist
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
name|int
name|ignore
decl_stmt|;
name|int
name|unlocked
decl_stmt|;
block|{
name|tree
name|fn_fputc
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_FPUTC_UNLOCKED
index|]
else|:
name|built_in_decls
index|[
name|BUILT_IN_FPUTC
index|]
decl_stmt|;
name|tree
name|fn_fputs
init|=
name|unlocked
condition|?
name|built_in_decls
index|[
name|BUILT_IN_FPUTS_UNLOCKED
index|]
else|:
name|built_in_decls
index|[
name|BUILT_IN_FPUTS
index|]
decl_stmt|;
name|tree
name|fn
decl_stmt|,
name|format_arg
decl_stmt|,
name|stripped_string
decl_stmt|;
comment|/* If the return value is used, or the replacement _DECL isn't      initialized, don't do the transformation.  */
if|if
condition|(
operator|!
name|ignore
operator|||
operator|!
name|fn_fputc
operator|||
operator|!
name|fn_fputs
condition|)
return|return
literal|0
return|;
comment|/* Verify the required arguments in the original call.  */
if|if
condition|(
name|arglist
operator|==
literal|0
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
operator|||
operator|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Check the specifier vs. the parameters.  */
if|if
condition|(
operator|!
name|is_valid_printf_arglist
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|format_arg
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|stripped_string
operator|=
name|format_arg
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|stripped_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|stripped_string
operator|&&
name|TREE_CODE
argument_list|(
name|stripped_string
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|stripped_string
operator|=
name|TREE_OPERAND
argument_list|(
name|stripped_string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the format specifier isn't a STRING_CST, punt.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|stripped_string
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return
literal|0
return|;
comment|/* OK!  We can attempt optimization.  */
comment|/* If the format specifier was "%s", call __builtin_fputs(arg3, arg1).  */
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|"%s"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|newarglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputs
expr_stmt|;
block|}
comment|/* If the format specifier was "%c", call __builtin_fputc (arg3, arg1).  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|"%c"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|newarglist
init|=
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
decl_stmt|;
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|newarglist
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputc
expr_stmt|;
block|}
else|else
block|{
comment|/* We can't handle anything else with % args or %% ... yet.  */
if|if
condition|(
name|strchr
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|stripped_string
argument_list|)
argument_list|,
literal|'%'
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* When "string" doesn't contain %, replace all cases of          fprintf(stream,string) with fputs(string,stream).  The fputs          builtin will take take of special cases like length==1.  */
name|arglist
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|,
name|build_tree_list
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|arglist
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fn
operator|=
name|fn_fputs
expr_stmt|;
block|}
return|return
name|expand_expr
argument_list|(
name|build_function_call
argument_list|(
name|fn
argument_list|,
name|arglist
argument_list|)
argument_list|,
operator|(
name|ignore
condition|?
name|const0_rtx
else|:
name|target
operator|)
argument_list|,
name|tmode
argument_list|,
name|modifier
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a boolean expression ARG, return a tree representing an increment    or decrement (as indicated by CODE) of ARG.  The front end must check for    invalid cases (e.g., decrement in C++).  */
end_comment

begin_function
name|tree
name|boolean_increment
parameter_list|(
name|code
parameter_list|,
name|arg
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|arg
decl_stmt|;
block|{
name|tree
name|val
decl_stmt|;
name|tree
name|true_res
init|=
operator|(
name|c_language
operator|==
name|clk_cplusplus
condition|?
name|boolean_true_node
else|:
name|c_bool_true_node
operator|)
decl_stmt|;
name|arg
operator|=
name|stabilize_reference
argument_list|(
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PREINCREMENT_EXPR
case|:
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|true_res
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTINCREMENT_EXPR
case|:
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|true_res
argument_list|)
expr_stmt|;
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|val
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|PREDECREMENT_EXPR
case|:
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|POSTDECREMENT_EXPR
case|:
name|val
operator|=
name|build
argument_list|(
name|MODIFY_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|invert_truthvalue
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|arg
operator|=
name|save_expr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|val
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|val
operator|=
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|arg
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|TREE_SIDE_EFFECTS
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle C and C++ default attributes.  */
end_comment

begin_enum
enum|enum
name|built_in_attribute
block|{
define|#
directive|define
name|DEF_ATTR_NULL_TREE
parameter_list|(
name|ENUM
parameter_list|)
value|ENUM,
define|#
directive|define
name|DEF_ATTR_INT
parameter_list|(
name|ENUM
parameter_list|,
name|VALUE
parameter_list|)
value|ENUM,
define|#
directive|define
name|DEF_ATTR_IDENT
parameter_list|(
name|ENUM
parameter_list|,
name|STRING
parameter_list|)
value|ENUM,
define|#
directive|define
name|DEF_ATTR_TREE_LIST
parameter_list|(
name|ENUM
parameter_list|,
name|PURPOSE
parameter_list|,
name|VALUE
parameter_list|,
name|CHAIN
parameter_list|)
value|ENUM,
define|#
directive|define
name|DEF_FN_ATTR
parameter_list|(
name|NAME
parameter_list|,
name|ATTRS
parameter_list|,
name|PREDICATE
parameter_list|)
comment|/* No entry needed in enum.  */
include|#
directive|include
file|"builtin-attrs.def"
undef|#
directive|undef
name|DEF_ATTR_NULL_TREE
undef|#
directive|undef
name|DEF_ATTR_INT
undef|#
directive|undef
name|DEF_ATTR_IDENT
undef|#
directive|undef
name|DEF_ATTR_TREE_LIST
undef|#
directive|undef
name|DEF_FN_ATTR
name|ATTR_LAST
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|tree
name|built_in_attributes
index|[
operator|(
name|int
operator|)
name|ATTR_LAST
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|c_attrs_initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|c_init_attributes
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Common initialization before parsing options.  */
end_comment

begin_function
name|void
name|c_common_init_options
parameter_list|(
name|lang
parameter_list|)
name|enum
name|c_language_kind
name|lang
decl_stmt|;
block|{
name|c_language
operator|=
name|lang
expr_stmt|;
name|parse_in
operator|=
name|cpp_create_reader
argument_list|(
name|lang
operator|==
name|clk_c
condition|?
name|CLK_GNUC89
else|:
name|lang
operator|==
name|clk_cplusplus
condition|?
name|CLK_GNUCXX
else|:
name|CLK_OBJC
argument_list|)
expr_stmt|;
comment|/* Mark as "unspecified" (see c_common_post_options).  */
name|flag_bounds_check
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Post-switch processing.  */
end_comment

begin_function
name|void
name|c_common_post_options
parameter_list|()
block|{
name|cpp_post_options
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
comment|/* Use tree inlining if possible.  Function instrumentation is only      done in the RTL level, so we disable tree inlining.  */
if|if
condition|(
operator|!
name|flag_instrument_function_entry_exit
condition|)
block|{
if|if
condition|(
operator|!
name|flag_no_inline
condition|)
block|{
name|flag_inline_trees
operator|=
literal|1
expr_stmt|;
name|flag_no_inline
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flag_inline_functions
condition|)
block|{
name|flag_inline_trees
operator|=
literal|2
expr_stmt|;
name|flag_inline_functions
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If still "unspecified", make it match -fbounded-pointers.  */
if|if
condition|(
name|flag_bounds_check
operator|==
operator|-
literal|1
condition|)
name|flag_bounds_check
operator|=
name|flag_bounded_pointers
expr_stmt|;
comment|/* Special format checking options don't work without -Wformat; warn if      they are used.  */
if|if
condition|(
name|warn_format_y2k
operator|&&
operator|!
name|warn_format
condition|)
name|warning
argument_list|(
literal|"-Wformat-y2k ignored without -Wformat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_format_extra_args
operator|&&
operator|!
name|warn_format
condition|)
name|warning
argument_list|(
literal|"-Wformat-extra-args ignored without -Wformat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_format_nonliteral
operator|&&
operator|!
name|warn_format
condition|)
name|warning
argument_list|(
literal|"-Wformat-nonliteral ignored without -Wformat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_format_security
operator|&&
operator|!
name|warn_format
condition|)
name|warning
argument_list|(
literal|"-Wformat-security ignored without -Wformat"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_missing_format_attribute
operator|&&
operator|!
name|warn_format
condition|)
name|warning
argument_list|(
literal|"-Wmissing-format-attribute ignored without -Wformat"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Front end initialization common to C, ObjC and C++.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|c_common_init
parameter_list|(
name|filename
parameter_list|)
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
comment|/* Do this before initializing pragmas, as then cpplib's hash table      has been set up.  */
name|filename
operator|=
name|init_c_lex
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|init_pragma
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|c_attrs_initialized
condition|)
name|c_init_attributes
argument_list|()
expr_stmt|;
return|return
name|filename
return|;
block|}
end_function

begin_comment
comment|/* Common finish hook for the C, ObjC and C++ front ends.  */
end_comment

begin_function
name|void
name|c_common_finish
parameter_list|()
block|{
name|cpp_finish
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
comment|/* For performance, avoid tearing down cpplib's internal structures.      Call cpp_errors () instead of cpp_destroy ().  */
name|errorcount
operator|+=
name|cpp_errors
argument_list|(
name|parse_in
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|c_init_attributes
parameter_list|()
block|{
comment|/* Fill in the built_in_attributes array.  */
define|#
directive|define
name|DEF_ATTR_NULL_TREE
parameter_list|(
name|ENUM
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM] = NULL_TREE;
define|#
directive|define
name|DEF_ATTR_INT
parameter_list|(
name|ENUM
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM] = build_int_2 (VALUE, VALUE< 0 ? -1 : 0);
define|#
directive|define
name|DEF_ATTR_IDENT
parameter_list|(
name|ENUM
parameter_list|,
name|STRING
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM] = get_identifier (STRING);
define|#
directive|define
name|DEF_ATTR_TREE_LIST
parameter_list|(
name|ENUM
parameter_list|,
name|PURPOSE
parameter_list|,
name|VALUE
parameter_list|,
name|CHAIN
parameter_list|)
define|\
value|built_in_attributes[(int) ENUM]			\     = tree_cons (built_in_attributes[(int) PURPOSE],	\ 		 built_in_attributes[(int) VALUE],	\ 		 built_in_attributes[(int) CHAIN]);
define|#
directive|define
name|DEF_FN_ATTR
parameter_list|(
name|NAME
parameter_list|,
name|ATTRS
parameter_list|,
name|PREDICATE
parameter_list|)
comment|/* No initialization needed.  */
include|#
directive|include
file|"builtin-attrs.def"
undef|#
directive|undef
name|DEF_ATTR_NULL_TREE
undef|#
directive|undef
name|DEF_ATTR_INT
undef|#
directive|undef
name|DEF_ATTR_IDENT
undef|#
directive|undef
name|DEF_ATTR_TREE_LIST
undef|#
directive|undef
name|DEF_FN_ATTR
name|ggc_add_tree_root
argument_list|(
name|built_in_attributes
argument_list|,
operator|(
name|int
operator|)
name|ATTR_LAST
argument_list|)
expr_stmt|;
name|c_attrs_initialized
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Depending on the name of DECL, apply default attributes to it.  */
end_comment

begin_function
name|void
name|c_common_insert_default_attributes
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c_attrs_initialized
condition|)
name|c_init_attributes
argument_list|()
expr_stmt|;
define|#
directive|define
name|DEF_ATTR_NULL_TREE
parameter_list|(
name|ENUM
parameter_list|)
comment|/* Nothing needed after initialization.  */
define|#
directive|define
name|DEF_ATTR_INT
parameter_list|(
name|ENUM
parameter_list|,
name|VALUE
parameter_list|)
define|#
directive|define
name|DEF_ATTR_IDENT
parameter_list|(
name|ENUM
parameter_list|,
name|STRING
parameter_list|)
define|#
directive|define
name|DEF_ATTR_TREE_LIST
parameter_list|(
name|ENUM
parameter_list|,
name|PURPOSE
parameter_list|,
name|VALUE
parameter_list|,
name|CHAIN
parameter_list|)
define|#
directive|define
name|DEF_FN_ATTR
parameter_list|(
name|NAME
parameter_list|,
name|ATTRS
parameter_list|,
name|PREDICATE
parameter_list|)
define|\
value|if ((PREDICATE)&& name == built_in_attributes[(int) NAME])	\     decl_attributes (&decl, built_in_attributes[(int) ATTRS],	\ 		     ATTR_FLAG_BUILT_IN);
include|#
directive|include
file|"builtin-attrs.def"
undef|#
directive|undef
name|DEF_ATTR_NULL_TREE
undef|#
directive|undef
name|DEF_ATTR_INT
undef|#
directive|undef
name|DEF_ATTR_IDENT
undef|#
directive|undef
name|DEF_ATTR_TREE_LIST
undef|#
directive|undef
name|DEF_FN_ATTR
block|}
end_function

begin_comment
comment|/* Output a -Wshadow warning MSGID about NAME, an IDENTIFIER_NODE, and    additionally give the location of the previous declaration DECL.  */
end_comment

begin_function
name|void
name|shadow_warning
parameter_list|(
name|msgid
parameter_list|,
name|name
parameter_list|,
name|decl
parameter_list|)
specifier|const
name|char
modifier|*
name|msgid
decl_stmt|;
name|tree
name|name
decl_stmt|,
name|decl
decl_stmt|;
block|{
name|warning
argument_list|(
literal|"declaration of `%s' shadows %s"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|,
name|msgid
argument_list|)
expr_stmt|;
name|warning_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"shadowed declaration is here"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

