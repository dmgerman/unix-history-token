begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines shared by all languages that are variants of C.    Copyright (C) 1992, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"toplev.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_if
if|#
directive|if
name|USE_CPPLIB
end_if

begin_include
include|#
directive|include
file|"cpplib.h"
end_include

begin_decl_stmt
name|cpp_reader
name|parse_in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpp_options
name|parse_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|cpp_token
name|cpp_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE_SIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|INT_TYPE_SIZE
end_ifdef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|INT_TYPE_SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means the expression being parsed will never be evaluated.    This is a count, since unevaluated expressions can nest.  */
end_comment

begin_decl_stmt
name|int
name|skip_evaluation
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|attrs
block|{
name|A_PACKED
block|,
name|A_NOCOMMON
block|,
name|A_COMMON
block|,
name|A_NORETURN
block|,
name|A_CONST
block|,
name|A_T_UNION
block|,
name|A_CONSTRUCTOR
block|,
name|A_DESTRUCTOR
block|,
name|A_MODE
block|,
name|A_SECTION
block|,
name|A_ALIGNED
block|,
name|A_UNUSED
block|,
name|A_FORMAT
block|,
name|A_FORMAT_ARG
block|,
name|A_WEAK
block|,
name|A_ALIAS
block|}
enum|;
end_enum

begin_enum
enum|enum
name|format_type
block|{
name|printf_format_type
block|,
name|scanf_format_type
block|,
name|strftime_format_type
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|declare_hidden_char_array
name|PROTO
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_attribute
name|PROTO
argument_list|(
operator|(
expr|enum
name|attrs
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_attributes
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_function_format
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
expr|enum
name|format_type
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_international_format
name|PROTO
argument_list|(
operator|(
name|tree
operator|,
name|tree
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keep a stack of if statements.  We record the number of compound    statements seen up to the if keyword, as well as the line number    and file of the if.  If a potentially ambiguous else is seen, that    fact is recorded; the warning is issued when we can be sure that    the enclosing if statement does not have an else branch.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|compstmt_count
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|needs_warning
decl_stmt|;
block|}
name|if_elt
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|if_elt
modifier|*
name|if_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of space in the if statement stack.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|if_stack_space
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack pointer.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|if_stack_pointer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Generate RTL for the start of an if-then, and record the start of it    for ambiguous else detection.  */
end_comment

begin_function
name|void
name|c_expand_start_cond
parameter_list|(
name|cond
parameter_list|,
name|exitflag
parameter_list|,
name|compstmt_count
parameter_list|)
name|tree
name|cond
decl_stmt|;
name|int
name|exitflag
decl_stmt|;
name|int
name|compstmt_count
decl_stmt|;
block|{
comment|/* Make sure there is enough space on the stack.  */
if|if
condition|(
name|if_stack_space
operator|==
literal|0
condition|)
block|{
name|if_stack_space
operator|=
literal|10
expr_stmt|;
name|if_stack
operator|=
operator|(
name|if_elt
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|if_elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|if_stack_space
operator|==
name|if_stack_pointer
condition|)
block|{
name|if_stack_space
operator|+=
literal|10
expr_stmt|;
name|if_stack
operator|=
operator|(
name|if_elt
operator|*
operator|)
name|xrealloc
argument_list|(
name|if_stack
argument_list|,
name|if_stack_space
operator|*
sizeof|sizeof
argument_list|(
name|if_elt
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Record this if statement.  */
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|compstmt_count
operator|=
name|compstmt_count
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|file
operator|=
name|input_filename
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|line
operator|=
name|lineno
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|needs_warning
operator|=
literal|0
expr_stmt|;
name|if_stack_pointer
operator|++
expr_stmt|;
name|expand_start_cond
argument_list|(
name|cond
argument_list|,
name|exitflag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL for the end of an if-then.  Optionally warn if a nested    if statement had an ambiguous else clause.  */
end_comment

begin_function
name|void
name|c_expand_end_cond
parameter_list|()
block|{
name|if_stack_pointer
operator|--
expr_stmt|;
if|if
condition|(
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|needs_warning
condition|)
name|warning_with_file_and_line
argument_list|(
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|file
argument_list|,
name|if_stack
index|[
name|if_stack_pointer
index|]
operator|.
name|line
argument_list|,
literal|"suggest explicit braces to avoid ambiguous `else'"
argument_list|)
expr_stmt|;
name|expand_end_cond
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate RTL between the then-clause and the else-clause    of an if-then-else.  */
end_comment

begin_function
name|void
name|c_expand_start_else
parameter_list|()
block|{
comment|/* An ambiguous else warning must be generated for the enclosing if      statement, unless we see an else branch for that one, too.  */
if|if
condition|(
name|warn_parentheses
operator|&&
name|if_stack_pointer
operator|>
literal|1
operator|&&
operator|(
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|compstmt_count
operator|==
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|2
index|]
operator|.
name|compstmt_count
operator|)
condition|)
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|2
index|]
operator|.
name|needs_warning
operator|=
literal|1
expr_stmt|;
comment|/* Even if a nested if statement had an else branch, it can't be      ambiguous if this one also has an else.  So don't warn in that      case.  Also don't warn for any if statements nested in this else.  */
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|needs_warning
operator|=
literal|0
expr_stmt|;
name|if_stack
index|[
name|if_stack_pointer
operator|-
literal|1
index|]
operator|.
name|compstmt_count
operator|--
expr_stmt|;
name|expand_start_else
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */
end_comment

begin_function
name|void
name|declare_function_name
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|printable_name
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
literal|""
expr_stmt|;
name|printable_name
operator|=
literal|"top level"
expr_stmt|;
block|}
else|else
block|{
comment|/* Allow functions to be nameless (such as artificial ones).  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
condition|)
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
literal|""
expr_stmt|;
name|printable_name
operator|=
call|(
modifier|*
name|decl_printable_name
call|)
argument_list|(
name|current_function_decl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|declare_hidden_char_array
argument_list|(
literal|"__FUNCTION__"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|declare_hidden_char_array
argument_list|(
literal|"__PRETTY_FUNCTION__"
argument_list|,
name|printable_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|declare_hidden_char_array
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|value
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|,
name|init
decl_stmt|;
name|int
name|vlen
decl_stmt|;
comment|/* If the default size of char arrays isn't big enough for the name,      or if we want to give warnings for large objects, make a bigger one.  */
name|vlen
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
expr_stmt|;
name|type
operator|=
name|char_array_type_node
expr_stmt|;
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|<
name|vlen
operator|||
name|warn_larger_than
condition|)
name|type
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|vlen
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_ARTIFICIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_IGNORED_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|init
operator|=
name|build_string
argument_list|(
name|vlen
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
operator|=
name|type
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
expr_stmt|;
name|finish_decl
argument_list|(
name|pushdecl
argument_list|(
name|decl
argument_list|)
argument_list|,
name|init
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Given a chain of STRING_CST nodes,    concatenate them into one STRING_CST    and give it a suitable array-of-chars data type.  */
end_comment

begin_function
name|tree
name|combine_strings
parameter_list|(
name|strings
parameter_list|)
name|tree
name|strings
decl_stmt|;
block|{
specifier|register
name|tree
name|value
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|int
name|length
init|=
literal|1
decl_stmt|;
name|int
name|wide_length
init|=
literal|0
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|int
name|wchar_bytes
init|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|nchars
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|strings
argument_list|)
condition|)
block|{
comment|/* More than one in the chain, so concatenate.  */
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Don't include the \0 at the end of each substring, 	 except for the last one. 	 Count wide strings and ordinary strings separately.  */
for|for
control|(
name|t
operator|=
name|strings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
condition|)
block|{
name|wide_length
operator|+=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
name|wchar_bytes
operator|)
expr_stmt|;
name|wide_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|length
operator|+=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
comment|/* If anything is wide, the non-wides will be converted, 	 which makes them take more space.  */
if|if
condition|(
name|wide_flag
condition|)
name|length
operator|=
name|length
operator|*
name|wchar_bytes
operator|+
name|wide_length
expr_stmt|;
name|p
operator|=
name|savealloc
argument_list|(
name|length
argument_list|)
expr_stmt|;
comment|/* Copy the individual strings into the new combined string. 	 If the combined string is wide, convert the chars to ints 	 for any individual strings that are not wide.  */
name|q
operator|=
name|p
expr_stmt|;
for|for
control|(
name|t
operator|=
name|strings
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
name|int
name|len
init|=
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|t
argument_list|)
operator|-
operator|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
operator|)
condition|?
name|wchar_bytes
else|:
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|wchar_array_type_node
operator|)
operator|==
name|wide_flag
condition|)
block|{
name|bcopy
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
argument_list|,
name|q
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|q
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|WCHAR_TYPE_SIZE
operator|==
name|HOST_BITS_PER_SHORT
condition|)
operator|(
operator|(
name|short
operator|*
operator|)
name|q
operator|)
index|[
name|i
index|]
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
else|else
operator|(
operator|(
name|int
operator|*
operator|)
name|q
operator|)
index|[
name|i
index|]
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|t
argument_list|)
index|[
name|i
index|]
expr_stmt|;
block|}
name|q
operator|+=
name|len
operator|*
name|wchar_bytes
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wide_flag
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wchar_bytes
condition|;
name|i
operator|++
control|)
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|make_node
argument_list|(
name|STRING_CST
argument_list|)
expr_stmt|;
name|TREE_STRING_POINTER
argument_list|(
name|value
argument_list|)
operator|=
name|p
expr_stmt|;
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
operator|=
name|length
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|strings
expr_stmt|;
name|length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|==
name|wchar_array_type_node
condition|)
name|wide_flag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Compute the number of elements, for the array type.  */
name|nchars
operator|=
name|wide_flag
condition|?
name|length
operator|/
name|wchar_bytes
else|:
name|length
expr_stmt|;
comment|/* Create the array type for the string constant.      -Wwrite-strings says make the string constant an array of const char      so that copying it to a non-const pointer will get a warning.  */
if|if
condition|(
name|warn_write_strings
operator|&&
operator|(
operator|!
name|flag_traditional
operator|&&
operator|!
name|flag_writable_strings
operator|)
condition|)
block|{
name|tree
name|elements
init|=
name|build_type_variant
argument_list|(
name|wide_flag
condition|?
name|wchar_type_node
else|:
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|elements
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nchars
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|build_array_type
argument_list|(
name|wide_flag
condition|?
name|wchar_type_node
else|:
name|char_type_node
argument_list|,
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
name|nchars
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CONSTANT
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|value
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* To speed up processing of attributes, we maintain an array of    IDENTIFIER_NODES and the corresponding attribute types.  */
end_comment

begin_comment
comment|/* Array to hold attribute information.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|enum
name|attrs
name|id
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|min
decl_stmt|,
name|max
decl_stmt|,
name|decl_req
decl_stmt|;
block|}
name|attrtab
index|[
literal|50
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|attrtab_idx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add an entry to the attribute table above.  */
end_comment

begin_function
specifier|static
name|void
name|add_attribute
parameter_list|(
name|id
parameter_list|,
name|string
parameter_list|,
name|min_len
parameter_list|,
name|max_len
parameter_list|,
name|decl_req
parameter_list|)
name|enum
name|attrs
name|id
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|min_len
decl_stmt|,
name|max_len
decl_stmt|;
name|int
name|decl_req
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|attrtab
index|[
name|attrtab_idx
index|]
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|attrtab
index|[
name|attrtab_idx
index|]
operator|.
name|name
operator|=
name|get_identifier
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|attrtab
index|[
name|attrtab_idx
index|]
operator|.
name|min
operator|=
name|min_len
expr_stmt|;
name|attrtab
index|[
name|attrtab_idx
index|]
operator|.
name|max
operator|=
name|max_len
expr_stmt|;
name|attrtab
index|[
name|attrtab_idx
operator|++
index|]
operator|.
name|decl_req
operator|=
name|decl_req
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"__%s__"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|attrtab
index|[
name|attrtab_idx
index|]
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|attrtab
index|[
name|attrtab_idx
index|]
operator|.
name|name
operator|=
name|get_identifier
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|attrtab
index|[
name|attrtab_idx
index|]
operator|.
name|min
operator|=
name|min_len
expr_stmt|;
name|attrtab
index|[
name|attrtab_idx
index|]
operator|.
name|max
operator|=
name|max_len
expr_stmt|;
name|attrtab
index|[
name|attrtab_idx
operator|++
index|]
operator|.
name|decl_req
operator|=
name|decl_req
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize attribute table.  */
end_comment

begin_function
specifier|static
name|void
name|init_attributes
parameter_list|()
block|{
name|add_attribute
argument_list|(
name|A_PACKED
argument_list|,
literal|"packed"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_NOCOMMON
argument_list|,
literal|"nocommon"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_COMMON
argument_list|,
literal|"common"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_NORETURN
argument_list|,
literal|"noreturn"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_NORETURN
argument_list|,
literal|"volatile"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_UNUSED
argument_list|,
literal|"unused"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_CONST
argument_list|,
literal|"const"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_T_UNION
argument_list|,
literal|"transparent_union"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_CONSTRUCTOR
argument_list|,
literal|"constructor"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_DESTRUCTOR
argument_list|,
literal|"destructor"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_MODE
argument_list|,
literal|"mode"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_SECTION
argument_list|,
literal|"section"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_ALIGNED
argument_list|,
literal|"aligned"
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_FORMAT
argument_list|,
literal|"format"
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_FORMAT_ARG
argument_list|,
literal|"format_arg"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_WEAK
argument_list|,
literal|"weak"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_attribute
argument_list|(
name|A_ALIAS
argument_list|,
literal|"alias"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the attributes listed in ATTRIBUTES and PREFIX_ATTRIBUTES    and install them in NODE, which is either a DECL (including a TYPE_DECL)    or a TYPE.  PREFIX_ATTRIBUTES can appear after the declaration specifiers    and declaration modifiers but before the declaration proper.  */
end_comment

begin_function
name|void
name|decl_attributes
parameter_list|(
name|node
parameter_list|,
name|attributes
parameter_list|,
name|prefix_attributes
parameter_list|)
name|tree
name|node
decl_stmt|,
name|attributes
decl_stmt|,
name|prefix_attributes
decl_stmt|;
block|{
name|tree
name|decl
init|=
literal|0
decl_stmt|,
name|type
init|=
literal|0
decl_stmt|;
name|int
name|is_type
init|=
literal|0
decl_stmt|;
name|tree
name|a
decl_stmt|;
if|if
condition|(
name|attrtab_idx
operator|==
literal|0
condition|)
name|init_attributes
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
literal|'d'
condition|)
block|{
name|decl
operator|=
name|node
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|is_type
operator|=
name|TREE_CODE
argument_list|(
name|node
argument_list|)
operator|==
name|TYPE_DECL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
literal|'t'
condition|)
name|type
operator|=
name|node
operator|,
name|is_type
operator|=
literal|1
expr_stmt|;
name|attributes
operator|=
name|chainon
argument_list|(
name|prefix_attributes
argument_list|,
name|attributes
argument_list|)
expr_stmt|;
for|for
control|(
name|a
operator|=
name|attributes
init|;
name|a
condition|;
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
control|)
block|{
name|tree
name|name
init|=
name|TREE_PURPOSE
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_VALUE
argument_list|(
name|a
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|attrs
name|id
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|attrtab_idx
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|attrtab
index|[
name|i
index|]
operator|.
name|name
operator|==
name|name
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|attrtab_idx
condition|)
block|{
if|if
condition|(
operator|!
name|valid_machine_attribute
argument_list|(
name|name
argument_list|,
name|args
argument_list|,
name|decl
argument_list|,
name|type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`%s' attribute directive ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|!=
literal|0
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|attrtab
index|[
name|i
index|]
operator|.
name|decl_req
operator|&&
name|decl
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute does not apply to types"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|list_length
argument_list|(
name|args
argument_list|)
operator|<
name|attrtab
index|[
name|i
index|]
operator|.
name|min
operator|||
name|list_length
argument_list|(
name|args
argument_list|)
operator|>
name|attrtab
index|[
name|i
index|]
operator|.
name|max
condition|)
block|{
name|error
argument_list|(
literal|"wrong number of arguments specified for `%s' attribute"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|id
operator|=
name|attrtab
index|[
name|i
index|]
operator|.
name|id
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|A_PACKED
case|:
if|if
condition|(
name|is_type
condition|)
name|TYPE_PACKED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FIELD_DECL
condition|)
name|DECL_PACKED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* We can't set DECL_PACKED for a VAR_DECL, because the bit is 	     used for DECL_REGISTER.  It wouldn't mean anything anyway.  */
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_NOCOMMON
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_COMMON
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|DECL_COMMON
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_NORETURN
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TREE_READONLY
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_UNUSED
case|:
if|if
condition|(
name|is_type
condition|)
name|TREE_USED
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_CONST
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|1
argument_list|,
name|TREE_THIS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_T_UNION
case|:
if|if
condition|(
name|is_type
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
operator|(
name|decl
operator|==
literal|0
operator|||
operator|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
name|TYPE_TRANSPARENT_UNION
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|decl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
operator|==
name|DECL_MODE
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
name|DECL_TRANSPARENT_UNION
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_CONSTRUCTOR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_STATIC_CONSTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_DESTRUCTOR
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DECL_STATIC_DESTRUCTOR
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_USED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_MODE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|tree
name|typefm
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|newp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|-
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|newp
argument_list|,
operator|&
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|newp
index|[
name|len
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|newp
expr_stmt|;
block|}
comment|/* Give this decl a type with the specified mode. 		 First check for the special modes.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"byte"
argument_list|)
condition|)
name|mode
operator|=
name|byte_mode
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"word"
argument_list|)
condition|)
name|mode
operator|=
name|word_mode
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"pointer"
argument_list|)
condition|)
name|mode
operator|=
name|ptr_mode
expr_stmt|;
else|else
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_MACHINE_MODES
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|GET_MODE_NAME
argument_list|(
name|j
argument_list|)
argument_list|)
condition|)
name|mode
operator|=
operator|(
expr|enum
name|machine_mode
operator|)
name|j
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|error
argument_list|(
literal|"unknown machine mode `%s'"
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
operator|(
name|typefm
operator|=
name|type_for_mode
argument_list|(
name|mode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"no data type for mode `%s'"
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
operator|=
name|typefm
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|A_SECTION
case|:
ifdef|#
directive|ifdef
name|ASM_OUTPUT_SECTION_NAME
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|current_function_decl
operator|!=
name|NULL_TREE
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"section attribute cannot be specified for local variables"
argument_list|)
expr_stmt|;
comment|/* The decl may have already been given a section attribute from 		 a previous declaration.  Ensure they match.  */
elseif|else
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|!=
name|NULL_TREE
operator|&&
name|strcmp
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error_with_decl
argument_list|(
name|node
argument_list|,
literal|"section of `%s' conflicts with previous declaration"
argument_list|)
expr_stmt|;
else|else
name|DECL_SECTION_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
else|else
name|error_with_decl
argument_list|(
name|node
argument_list|,
literal|"section attribute not allowed for `%s'"
argument_list|)
expr_stmt|;
else|#
directive|else
name|error_with_decl
argument_list|(
name|node
argument_list|,
literal|"section attributes are not supported for this target"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|A_ALIGNED
case|:
block|{
name|tree
name|align_expr
init|=
operator|(
name|args
condition|?
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
else|:
name|size_int
argument_list|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
argument_list|)
operator|)
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* Strip any NOPs of any kind.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|align_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|align_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|align_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"requested alignment is not a constant"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|align
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|align_expr
argument_list|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
if|if
condition|(
name|exact_log2
argument_list|(
name|align
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"requested alignment is not a power of 2"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|is_type
condition|)
name|TYPE_ALIGN
argument_list|(
name|type
argument_list|)
operator|=
name|align
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|VAR_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FIELD_DECL
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"alignment may not be specified for `%s'"
argument_list|)
expr_stmt|;
else|else
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
operator|=
name|align
expr_stmt|;
block|}
break|break;
case|case
name|A_FORMAT
case|:
block|{
name|tree
name|format_type_id
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|tree
name|format_num_expr
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|first_arg_num_expr
init|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|args
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|format_num
decl_stmt|;
name|int
name|first_arg_num
decl_stmt|;
name|int
name|null_format_ok
decl_stmt|;
name|enum
name|format_type
name|format_type
decl_stmt|;
name|tree
name|argument
decl_stmt|;
name|int
name|arg_num
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"argument format specified for non-function `%s'"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_type_id
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"unrecognized format specifier"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|format_type_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"printf"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"__printf__"
argument_list|)
condition|)
block|{
name|format_type
operator|=
name|printf_format_type
expr_stmt|;
name|null_format_ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"printf0"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"__printf0__"
argument_list|)
condition|)
block|{
name|format_type
operator|=
name|printf_format_type
expr_stmt|;
name|null_format_ok
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"scanf"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"__scanf__"
argument_list|)
condition|)
block|{
name|format_type
operator|=
name|scanf_format_type
expr_stmt|;
name|null_format_ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"strftime"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"__strftime__"
argument_list|)
condition|)
block|{
name|format_type
operator|=
name|strftime_format_type
expr_stmt|;
name|null_format_ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"`%s' is an unrecognized format function type"
argument_list|,
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Strip any conversions from the string index and first arg number 	       and verify they are constants.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|format_num_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|format_num_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|first_arg_num_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|first_arg_num_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|first_arg_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"format string has non-constant operand number"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|format_num
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|format_num_expr
argument_list|)
expr_stmt|;
name|first_arg_num
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|first_arg_num_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_arg_num
operator|!=
literal|0
operator|&&
name|first_arg_num
operator|<=
name|format_num
condition|)
block|{
name|error
argument_list|(
literal|"format string arg follows the args to be formatted"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If a parameter list is specified, verify that the format_num 	       argument is actually a string, in case the format attribute 	       is in error.  */
name|argument
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument
condition|)
block|{
for|for
control|(
name|arg_num
operator|=
literal|1
init|;
condition|;
operator|++
name|arg_num
control|)
block|{
if|if
condition|(
name|argument
operator|==
literal|0
operator|||
name|arg_num
operator|==
name|format_num
condition|)
break|break;
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|argument
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"format string arg not a string type"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
comment|/* Verify that first_arg_num points to the last arg, 		       the ...  */
while|while
condition|(
name|argument
condition|)
name|arg_num
operator|++
operator|,
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_num
operator|!=
name|first_arg_num
condition|)
block|{
name|error
argument_list|(
literal|"args to be formatted is not ..."
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|record_function_format
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|format_type
argument_list|,
name|null_format_ok
argument_list|,
name|format_num
argument_list|,
name|first_arg_num
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|A_FORMAT_ARG
case|:
block|{
name|tree
name|format_num_expr
init|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
decl_stmt|;
name|int
name|format_num
decl_stmt|,
name|arg_num
decl_stmt|;
name|tree
name|argument
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"argument format specified for non-function `%s'"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Strip any conversions from the first arg number and verify it 	       is a constant.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|CONVERT_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|==
name|NON_LVALUE_EXPR
condition|)
name|format_num_expr
operator|=
name|TREE_OPERAND
argument_list|(
name|format_num_expr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_num_expr
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
name|error
argument_list|(
literal|"format string has non-constant operand number"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|format_num
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|format_num_expr
argument_list|)
expr_stmt|;
comment|/* If a parameter list is specified, verify that the format_num 	       argument is actually a string, in case the format attribute 	       is in error.  */
name|argument
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|argument
condition|)
block|{
for|for
control|(
name|arg_num
operator|=
literal|1
init|;
condition|;
operator|++
name|arg_num
control|)
block|{
if|if
condition|(
name|argument
operator|==
literal|0
operator|||
name|arg_num
operator|==
name|format_num
condition|)
break|break;
name|argument
operator|=
name|TREE_CHAIN
argument_list|(
name|argument
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|argument
operator|||
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_VALUE
argument_list|(
name|argument
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"format string arg not a string type"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|char_type_node
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"function does not return string type"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|record_international_format
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|,
name|format_num
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|A_WEAK
case|:
name|declare_weak
argument_list|(
name|decl
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_ALIAS
case|:
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|)
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"`%s' defined both normally and as an alias"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|decl_function_context
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|id
decl_stmt|;
name|id
operator|=
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"alias arg not a string"
argument_list|)
expr_stmt|;
break|break;
block|}
name|id
operator|=
name|get_identifier
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
else|else
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|assemble_alias
argument_list|(
name|decl
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Split SPECS_ATTRS, a list of declspecs and prefix attributes, into two    lists.  SPECS_ATTRS may also be just a typespec (eg: RECORD_TYPE).     The head of the declspec list is stored in DECLSPECS.    The head of the attribute list is stored in PREFIX_ATTRIBUTES.     Note that attributes in SPECS_ATTRS are stored in the TREE_PURPOSE of    the list elements.  We drop the containing TREE_LIST nodes and link the    resulting attributes together the way decl_attributes expects them.  */
end_comment

begin_function
name|void
name|split_specs_attrs
parameter_list|(
name|specs_attrs
parameter_list|,
name|declspecs
parameter_list|,
name|prefix_attributes
parameter_list|)
name|tree
name|specs_attrs
decl_stmt|;
name|tree
modifier|*
name|declspecs
decl_stmt|,
decl|*
name|prefix_attributes
decl_stmt|;
end_function

begin_block
block|{
name|tree
name|t
decl_stmt|,
name|s
decl_stmt|,
name|a
decl_stmt|,
name|next
decl_stmt|,
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
comment|/* This can happen in c++ (eg: decl: typespec initdecls ';').  */
if|if
condition|(
name|specs_attrs
operator|!=
name|NULL_TREE
operator|&&
name|TREE_CODE
argument_list|(
name|specs_attrs
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
operator|*
name|declspecs
operator|=
name|specs_attrs
expr_stmt|;
operator|*
name|prefix_attributes
operator|=
name|NULL_TREE
expr_stmt|;
return|return;
block|}
comment|/* Remember to keep the lists in the same order, element-wise.  */
name|specs
operator|=
name|s
operator|=
name|NULL_TREE
expr_stmt|;
name|attrs
operator|=
name|a
operator|=
name|NULL_TREE
expr_stmt|;
for|for
control|(
name|t
operator|=
name|specs_attrs
init|;
name|t
condition|;
name|t
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Declspecs have a non-NULL TREE_VALUE.  */
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
operator|!=
name|NULL_TREE
condition|)
block|{
if|if
condition|(
name|specs
operator|==
name|NULL_TREE
condition|)
name|specs
operator|=
name|s
operator|=
name|t
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
operator|=
name|t
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|attrs
operator|==
name|NULL_TREE
condition|)
name|attrs
operator|=
name|a
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
else|else
block|{
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|a
operator|=
name|TREE_PURPOSE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* More attrs can be linked here, move A to the end.  */
while|while
condition|(
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|!=
name|NULL_TREE
condition|)
name|a
operator|=
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Terminate the lists.  */
if|if
condition|(
name|s
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|s
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL_TREE
condition|)
name|TREE_CHAIN
argument_list|(
name|a
argument_list|)
operator|=
name|NULL_TREE
expr_stmt|;
comment|/* All done.  */
operator|*
name|declspecs
operator|=
name|specs
expr_stmt|;
operator|*
name|prefix_attributes
operator|=
name|attrs
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Strip attributes from SPECS_ATTRS, a list of declspecs and attributes.    This function is used by the parser when a rule will accept attributes    in a particular position, but we don't want to support that just yet.     A warning is issued for every ignored attribute.  */
end_comment

begin_function
name|tree
name|strip_attrs
parameter_list|(
name|specs_attrs
parameter_list|)
name|tree
name|specs_attrs
decl_stmt|;
block|{
name|tree
name|specs
decl_stmt|,
name|attrs
decl_stmt|;
name|split_specs_attrs
argument_list|(
name|specs_attrs
argument_list|,
operator|&
name|specs
argument_list|,
operator|&
name|attrs
argument_list|)
expr_stmt|;
while|while
condition|(
name|attrs
condition|)
block|{
name|warning
argument_list|(
literal|"`%s' attribute ignored"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|attrs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|attrs
operator|=
name|TREE_CHAIN
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
block|}
return|return
name|specs
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check a printf/fprintf/sprintf/scanf/fscanf/sscanf format against    a parameter list.  */
end_comment

begin_define
define|#
directive|define
name|T_I
value|&integer_type_node
end_define

begin_define
define|#
directive|define
name|T_L
value|&long_integer_type_node
end_define

begin_define
define|#
directive|define
name|T_LL
value|&long_long_integer_type_node
end_define

begin_define
define|#
directive|define
name|T_S
value|&short_integer_type_node
end_define

begin_define
define|#
directive|define
name|T_UI
value|&unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T_UL
value|&long_unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T_ULL
value|&long_long_unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T_US
value|&short_unsigned_type_node
end_define

begin_define
define|#
directive|define
name|T_F
value|&float_type_node
end_define

begin_define
define|#
directive|define
name|T_D
value|&double_type_node
end_define

begin_define
define|#
directive|define
name|T_LD
value|&long_double_type_node
end_define

begin_define
define|#
directive|define
name|T_C
value|&char_type_node
end_define

begin_define
define|#
directive|define
name|T_UC
value|&unsigned_char_type_node
end_define

begin_define
define|#
directive|define
name|T_V
value|&void_type_node
end_define

begin_define
define|#
directive|define
name|T_W
value|&wchar_type_node
end_define

begin_define
define|#
directive|define
name|T_ST
value|&sizetype
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|format_chars
decl_stmt|;
name|int
name|pointer_count
decl_stmt|;
comment|/* Type of argument if no length modifier is used.  */
name|tree
modifier|*
name|nolen
decl_stmt|;
comment|/* Type of argument if length modifier for shortening to byte is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|hhlen
decl_stmt|;
comment|/* Type of argument if length modifier for shortening is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|hlen
decl_stmt|;
comment|/* Type of argument if length modifier `l' is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|llen
decl_stmt|;
comment|/* Type of argument if length modifier `q' or `ll' is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|qlen
decl_stmt|;
comment|/* Type of argument if length modifier `L' is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|bigllen
decl_stmt|;
comment|/* Type of argument if length modifier `Z' is used.      If NULL, then this modifier is not allowed.  */
name|tree
modifier|*
name|zlen
decl_stmt|;
comment|/* List of other modifier characters allowed with these options.  */
name|char
modifier|*
name|flag_chars
decl_stmt|;
block|}
name|format_char_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|format_char_info
name|print_char_table
index|[]
init|=
block|{
comment|/* FreeBSD kernel extensions.  */
block|{
literal|"D"
block|,
literal|1
block|,
name|T_C
block|,
name|T_C
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-wp"
block|}
block|,
block|{
literal|"b"
block|,
literal|1
block|,
name|T_C
block|,
name|T_C
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-wp"
block|}
block|,
block|{
literal|"rz"
block|,
literal|0
block|,
name|NULL
block|,
name|T_I
block|,
name|T_I
block|,
name|T_L
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-wp0 +#"
block|}
block|,
define|#
directive|define
name|unextended_print_char_table
value|(print_char_table + 3)
block|{
literal|"di"
block|,
literal|0
block|,
name|T_I
block|,
name|T_I
block|,
name|T_I
block|,
name|T_L
block|,
name|T_LL
block|,
name|T_LL
block|,
name|T_ST
block|,
literal|"-wp0 +"
block|}
block|,
block|{
literal|"oxX"
block|,
literal|0
block|,
name|T_UI
block|,
name|T_UI
block|,
name|T_UI
block|,
name|T_UL
block|,
name|T_ULL
block|,
name|T_ULL
block|,
name|T_ST
block|,
literal|"-wp0#"
block|}
block|,
block|{
literal|"u"
block|,
literal|0
block|,
name|T_UI
block|,
name|T_UI
block|,
name|T_UI
block|,
name|T_UL
block|,
name|T_ULL
block|,
name|T_ULL
block|,
name|T_ST
block|,
literal|"-wp0"
block|}
block|,
comment|/* A GNU extension.  */
block|{
literal|"m"
block|,
literal|0
block|,
name|T_V
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-wp"
block|}
block|,
block|{
literal|"feEgGaA"
block|,
literal|0
block|,
name|T_D
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|T_LD
block|,
name|NULL
block|,
literal|"-wp0 +#"
block|}
block|,
block|{
literal|"c"
block|,
literal|0
block|,
name|T_I
block|,
name|NULL
block|,
name|NULL
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-w"
block|}
block|,
block|{
literal|"C"
block|,
literal|0
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-w"
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|T_C
block|,
name|NULL
block|,
name|NULL
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-wp"
block|}
block|,
block|{
literal|"S"
block|,
literal|1
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-wp"
block|}
block|,
block|{
literal|"p"
block|,
literal|1
block|,
name|T_V
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-w"
block|}
block|,
block|{
literal|"n"
block|,
literal|1
block|,
name|T_I
block|,
name|NULL
block|,
name|T_S
block|,
name|T_L
block|,
name|T_LL
block|,
name|NULL
block|,
name|NULL
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|format_char_info
name|scan_char_table
index|[]
init|=
block|{
block|{
literal|"di"
block|,
literal|1
block|,
name|T_I
block|,
name|T_C
block|,
name|T_S
block|,
name|T_L
block|,
name|T_LL
block|,
name|T_LL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"ouxX"
block|,
literal|1
block|,
name|T_UI
block|,
name|T_UC
block|,
name|T_US
block|,
name|T_UL
block|,
name|T_ULL
block|,
name|T_ULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"efgEGaA"
block|,
literal|1
block|,
name|T_F
block|,
name|NULL
block|,
name|NULL
block|,
name|T_D
block|,
name|NULL
block|,
name|T_LD
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"c"
block|,
literal|1
block|,
name|T_C
block|,
name|NULL
block|,
name|NULL
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"s"
block|,
literal|1
block|,
name|T_C
block|,
name|NULL
block|,
name|NULL
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*a"
block|}
block|,
block|{
literal|"["
block|,
literal|1
block|,
name|T_C
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*a"
block|}
block|,
block|{
literal|"C"
block|,
literal|1
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"S"
block|,
literal|1
block|,
name|T_W
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*a"
block|}
block|,
block|{
literal|"p"
block|,
literal|2
block|,
name|T_V
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"*"
block|}
block|,
block|{
literal|"n"
block|,
literal|1
block|,
name|T_I
block|,
name|T_C
block|,
name|T_S
block|,
name|T_L
block|,
name|T_LL
block|,
name|NULL
block|,
name|NULL
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle format characters recognized by glibc's strftime.c.    '2' - MUST do years as only two digits    '3' - MAY do years as only two digits (depending on locale)    'E' - E modifier is acceptable    'O' - O modifier is acceptable to Standard C    'o' - O modifier is acceptable as a GNU extension    'G' - other GNU extensions  */
end_comment

begin_decl_stmt
specifier|static
name|format_char_info
name|time_char_table
index|[]
init|=
block|{
block|{
literal|"y"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"2EO-_0w"
block|}
block|,
block|{
literal|"D"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"2"
block|}
block|,
block|{
literal|"g"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"2O-_0w"
block|}
block|,
block|{
literal|"cx"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"3E"
block|}
block|,
block|{
literal|"%RTXnrt"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|""
block|}
block|,
block|{
literal|"P"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"G"
block|}
block|,
block|{
literal|"HIMSUWdemw"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-_0Ow"
block|}
block|,
block|{
literal|"Vju"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-_0Oow"
block|}
block|,
block|{
literal|"Gklsz"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-_0OGw"
block|}
block|,
block|{
literal|"ABZa"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"^#"
block|}
block|,
block|{
literal|"p"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"#"
block|}
block|,
block|{
literal|"bh"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"^"
block|}
block|,
block|{
literal|"CY"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"-_0EOw"
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|function_format_info
block|{
name|struct
name|function_format_info
modifier|*
name|next
decl_stmt|;
comment|/* next structure on the list */
name|tree
name|name
decl_stmt|;
comment|/* identifier such as "printf" */
name|tree
name|assembler_name
decl_stmt|;
comment|/* optional mangled identifier (for C++) */
name|enum
name|format_type
name|format_type
decl_stmt|;
comment|/* type of format (printf, scanf, etc.) */
name|int
name|null_format_ok
decl_stmt|;
comment|/* TRUE if the format string may be NULL */
name|int
name|format_num
decl_stmt|;
comment|/* number of format argument */
name|int
name|first_arg_num
decl_stmt|;
comment|/* number of first arg (zero for varargs) */
block|}
name|function_format_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|function_format_info
modifier|*
name|function_format_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|international_format_info
block|{
name|struct
name|international_format_info
modifier|*
name|next
decl_stmt|;
comment|/* next structure on the list */
name|tree
name|name
decl_stmt|;
comment|/* identifier such as "gettext" */
name|tree
name|assembler_name
decl_stmt|;
comment|/* optional mangled identifier (for C++) */
name|int
name|format_num
decl_stmt|;
comment|/* number of format argument */
block|}
name|international_format_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|international_format_info
modifier|*
name|international_format_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_format_info
name|PROTO
argument_list|(
operator|(
name|function_format_info
operator|*
operator|,
name|tree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the table of functions to perform format checking on.    The ANSI functions are always checked (whether<stdio.h> is    included or not), since it is common to call printf without    including<stdio.h>.  There shouldn't be a problem with this,    since ANSI reserves these function names whether you include the    header file or not.  In any case, the checking is harmless.     Also initialize the name of function that modify the format string for    internationalization purposes.  */
end_comment

begin_function
name|void
name|init_function_format_info
parameter_list|()
block|{
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"printf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|printf_format_type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"fprintf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|printf_format_type
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"sprintf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|printf_format_type
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"scanf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|scanf_format_type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"fscanf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|scanf_format_type
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"sscanf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|scanf_format_type
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"vprintf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|printf_format_type
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"vfprintf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|printf_format_type
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"vsprintf"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|printf_format_type
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_function_format
argument_list|(
name|get_identifier
argument_list|(
literal|"strftime"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
name|strftime_format_type
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|record_international_format
argument_list|(
name|get_identifier
argument_list|(
literal|"gettext"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|record_international_format
argument_list|(
name|get_identifier
argument_list|(
literal|"dgettext"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|record_international_format
argument_list|(
name|get_identifier
argument_list|(
literal|"dcgettext"
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record information for argument format checking.  FUNCTION_IDENT is    the identifier node for the name of the function to check (its decl    need not exist yet).    FORMAT_TYPE specifies the type of format checking.  FORMAT_NUM is the number    of the argument which is the format control string (starting from 1).    FIRST_ARG_NUM is the number of the first actual argument to check    against the format string, or zero if no checking is not be done    (e.g. for varargs such as vfprintf).  */
end_comment

begin_function
specifier|static
name|void
name|record_function_format
parameter_list|(
name|name
parameter_list|,
name|assembler_name
parameter_list|,
name|format_type
parameter_list|,
name|null_format_ok
parameter_list|,
name|format_num
parameter_list|,
name|first_arg_num
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|assembler_name
decl_stmt|;
name|enum
name|format_type
name|format_type
decl_stmt|;
name|int
name|null_format_ok
decl_stmt|;
name|int
name|format_num
decl_stmt|;
name|int
name|first_arg_num
decl_stmt|;
block|{
name|function_format_info
modifier|*
name|info
decl_stmt|;
comment|/* Re-use existing structure if it's there.  */
for|for
control|(
name|info
operator|=
name|function_format_list
init|;
name|info
condition|;
name|info
operator|=
name|info
operator|->
name|next
control|)
block|{
if|if
condition|(
name|info
operator|->
name|name
operator|==
name|name
operator|&&
name|info
operator|->
name|assembler_name
operator|==
name|assembler_name
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|info
condition|)
block|{
name|info
operator|=
operator|(
name|function_format_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|function_format_info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|next
operator|=
name|function_format_list
expr_stmt|;
name|function_format_list
operator|=
name|info
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|info
operator|->
name|assembler_name
operator|=
name|assembler_name
expr_stmt|;
block|}
name|info
operator|->
name|format_type
operator|=
name|format_type
expr_stmt|;
name|info
operator|->
name|null_format_ok
operator|=
name|null_format_ok
expr_stmt|;
name|info
operator|->
name|format_num
operator|=
name|format_num
expr_stmt|;
name|info
operator|->
name|first_arg_num
operator|=
name|first_arg_num
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record information for the names of function that modify the format    argument to format functions.  FUNCTION_IDENT is the identifier node for    the name of the function (its decl need not exist yet) and FORMAT_NUM is    the number of the argument which is the format control string (starting    from 1).  */
end_comment

begin_function
specifier|static
name|void
name|record_international_format
parameter_list|(
name|name
parameter_list|,
name|assembler_name
parameter_list|,
name|format_num
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|assembler_name
decl_stmt|;
name|int
name|format_num
decl_stmt|;
block|{
name|international_format_info
modifier|*
name|info
decl_stmt|;
comment|/* Re-use existing structure if it's there.  */
for|for
control|(
name|info
operator|=
name|international_format_list
init|;
name|info
condition|;
name|info
operator|=
name|info
operator|->
name|next
control|)
block|{
if|if
condition|(
name|info
operator|->
name|name
operator|==
name|name
operator|&&
name|info
operator|->
name|assembler_name
operator|==
name|assembler_name
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|info
condition|)
block|{
name|info
operator|=
operator|(
name|international_format_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|international_format_info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|next
operator|=
name|international_format_list
expr_stmt|;
name|international_format_list
operator|=
name|info
expr_stmt|;
name|info
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|info
operator|->
name|assembler_name
operator|=
name|assembler_name
expr_stmt|;
block|}
name|info
operator|->
name|format_num
operator|=
name|format_num
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|tfaff
index|[]
init|=
literal|"too few arguments for format"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Check the argument list of a call to printf, scanf, etc.    NAME is the function identifier.    ASSEMBLER_NAME is the function's assembler identifier.    (Either NAME or ASSEMBLER_NAME, but not both, may be NULL_TREE.)    PARAMS is the list of argument values.  */
end_comment

begin_function
name|void
name|check_function_format
parameter_list|(
name|name
parameter_list|,
name|assembler_name
parameter_list|,
name|params
parameter_list|)
name|tree
name|name
decl_stmt|;
name|tree
name|assembler_name
decl_stmt|;
name|tree
name|params
decl_stmt|;
block|{
name|function_format_info
modifier|*
name|info
decl_stmt|;
comment|/* See if this function is a format function.  */
for|for
control|(
name|info
operator|=
name|function_format_list
init|;
name|info
condition|;
name|info
operator|=
name|info
operator|->
name|next
control|)
block|{
if|if
condition|(
name|info
operator|->
name|assembler_name
condition|?
operator|(
name|info
operator|->
name|assembler_name
operator|==
name|assembler_name
operator|)
else|:
operator|(
name|info
operator|->
name|name
operator|==
name|name
operator|)
condition|)
block|{
comment|/* Yup; check it.  */
name|check_format_info
argument_list|(
name|info
argument_list|,
name|params
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check the argument list of a call to printf, scanf, etc.    INFO points to the function_format_info structure.    PARAMS is the list of argument values.  */
end_comment

begin_function
specifier|static
name|void
name|check_format_info
parameter_list|(
name|info
parameter_list|,
name|params
parameter_list|)
name|function_format_info
modifier|*
name|info
decl_stmt|;
name|tree
name|params
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|arg_num
decl_stmt|;
name|int
name|suppressed
decl_stmt|,
name|wide
decl_stmt|,
name|precise
decl_stmt|;
name|int
name|length_char
init|=
literal|0
decl_stmt|;
name|int
name|format_char
decl_stmt|;
name|int
name|format_length
decl_stmt|;
name|tree
name|format_tree
decl_stmt|;
name|tree
name|cur_param
decl_stmt|;
name|tree
name|cur_type
decl_stmt|;
name|tree
name|wanted_type
decl_stmt|;
name|tree
name|first_fillin_param
decl_stmt|;
name|char
modifier|*
name|format_chars
decl_stmt|;
name|format_char_info
modifier|*
name|fci
init|=
name|NULL
decl_stmt|;
name|char
name|flag_chars
index|[
literal|8
index|]
decl_stmt|;
name|int
name|has_operand_number
init|=
literal|0
decl_stmt|;
comment|/* Skip to format argument.  If the argument isn't available, there's      no work for us to do; prototype checking will catch the problem.  */
for|for
control|(
name|arg_num
operator|=
literal|1
init|;
condition|;
operator|++
name|arg_num
control|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|arg_num
operator|==
name|info
operator|->
name|format_num
condition|)
break|break;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
block|}
name|format_tree
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_tree
operator|==
literal|0
condition|)
return|return;
comment|/* We can only check the format if it's a string constant.  */
while|while
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|format_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* strip coercion */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|CALL_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
condition|)
block|{
name|tree
name|function
init|=
name|TREE_OPERAND
argument_list|(
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* See if this is a call to a known internationalization function 	 that modifies the format arg.  */
name|international_format_info
modifier|*
name|info
decl_stmt|;
for|for
control|(
name|info
operator|=
name|international_format_list
init|;
name|info
condition|;
name|info
operator|=
name|info
operator|->
name|next
control|)
if|if
condition|(
name|info
operator|->
name|assembler_name
condition|?
operator|(
name|info
operator|->
name|assembler_name
operator|==
name|DECL_ASSEMBLER_NAME
argument_list|(
name|function
argument_list|)
operator|)
else|:
operator|(
name|info
operator|->
name|name
operator|==
name|DECL_NAME
argument_list|(
name|function
argument_list|)
operator|)
condition|)
block|{
name|tree
name|inner_args
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|inner_args
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|1
argument_list|)
operator|,
name|i
operator|=
literal|1
init|;
name|inner_args
operator|!=
literal|0
condition|;
name|inner_args
operator|=
name|TREE_CHAIN
argument_list|(
name|inner_args
argument_list|)
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|info
operator|->
name|format_num
condition|)
block|{
name|format_tree
operator|=
name|TREE_VALUE
argument_list|(
name|inner_args
argument_list|)
expr_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|==
name|NOP_EXPR
condition|)
name|format_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|integer_zerop
argument_list|(
name|format_tree
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|null_format_ok
condition|)
name|warning
argument_list|(
literal|"null format string"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|ADDR_EXPR
condition|)
return|return;
name|format_tree
operator|=
name|TREE_OPERAND
argument_list|(
name|format_tree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|STRING_CST
condition|)
return|return;
name|format_chars
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
name|format_length
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|format_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_length
operator|<=
literal|1
condition|)
name|warning
argument_list|(
literal|"zero-length format string"
argument_list|)
expr_stmt|;
if|if
condition|(
name|format_chars
index|[
operator|--
name|format_length
index|]
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"unterminated format string"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Skip to first argument to check.  */
while|while
condition|(
name|arg_num
operator|+
literal|1
operator|<
name|info
operator|->
name|first_arg_num
condition|)
block|{
if|if
condition|(
name|params
operator|==
literal|0
condition|)
return|return;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
block|}
name|first_fillin_param
operator|=
name|params
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|aflag
decl_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|format_chars
operator|-
name|TREE_STRING_POINTER
argument_list|(
name|format_tree
argument_list|)
operator|!=
name|format_length
condition|)
name|warning
argument_list|(
literal|"embedded `\\0' in format"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
operator|&&
name|params
operator|!=
literal|0
operator|&&
operator|!
name|has_operand_number
condition|)
name|warning
argument_list|(
literal|"too many arguments for format"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|format_chars
operator|++
operator|!=
literal|'%'
condition|)
continue|continue;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"spurious trailing `%%' in format"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'%'
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
continue|continue;
block|}
name|flag_chars
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|suppressed
operator|=
name|wide
operator|=
name|precise
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|format_type
operator|==
name|scanf_format_type
condition|)
block|{
name|suppressed
operator|=
operator|*
name|format_chars
operator|==
literal|'*'
expr_stmt|;
if|if
condition|(
name|suppressed
condition|)
operator|++
name|format_chars
expr_stmt|;
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
operator|++
name|format_chars
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|format_type
operator|==
name|strftime_format_type
condition|)
block|{
while|while
condition|(
operator|*
name|format_chars
operator|!=
literal|0
operator|&&
name|index
argument_list|(
literal|"_-0^#"
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C does not support the strftime `%c' flag"
argument_list|,
operator|*
name|format_chars
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|flag_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"repeated `%c' flag in format"
argument_list|,
operator|*
name|format_chars
argument_list|)
expr_stmt|;
operator|++
name|format_chars
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|format_chars
operator|++
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|format_chars
argument_list|)
condition|)
block|{
name|wide
operator|=
name|TRUE
expr_stmt|;
operator|++
name|format_chars
expr_stmt|;
block|}
if|if
condition|(
name|wide
operator|&&
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C does not support strftime format width"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'E'
operator|||
operator|*
name|format_chars
operator|==
literal|'O'
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|format_chars
operator|++
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'E'
operator|||
operator|*
name|format_chars
operator|==
literal|'O'
condition|)
block|{
name|warning
argument_list|(
literal|"multiple E/O modifiers in format"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|format_chars
operator|==
literal|'E'
operator|||
operator|*
name|format_chars
operator|==
literal|'O'
condition|)
operator|++
name|format_chars
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|format_type
operator|==
name|printf_format_type
condition|)
block|{
comment|/* See if we have a number followed by a dollar sign.  If we do, 	     it is an operand number, so set PARAMS to that operand.  */
if|if
condition|(
operator|*
name|format_chars
operator|>=
literal|'0'
operator|&&
operator|*
name|format_chars
operator|<=
literal|'9'
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|format_chars
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|++
operator|<=
literal|'9'
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
block|{
name|int
name|opnum
init|=
name|atoi
argument_list|(
name|format_chars
argument_list|)
decl_stmt|;
name|params
operator|=
name|first_fillin_param
expr_stmt|;
name|format_chars
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|has_operand_number
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|opnum
operator|&&
name|params
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|opnum
operator|==
literal|0
operator|||
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"operand number out of range in format"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
while|while
condition|(
operator|*
name|format_chars
operator|!=
literal|0
operator|&&
name|index
argument_list|(
literal|" +#0-"
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|flag_chars
argument_list|,
operator|*
name|format_chars
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"repeated `%c' flag in format"
argument_list|,
operator|*
name|format_chars
operator|++
argument_list|)
expr_stmt|;
else|else
block|{
name|i
operator|=
name|strlen
argument_list|(
name|flag_chars
argument_list|)
expr_stmt|;
name|flag_chars
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|format_chars
operator|++
expr_stmt|;
name|flag_chars
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* "If the space and + flags both appear, 	     the space flag will be ignored."  */
if|if
condition|(
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|' '
argument_list|)
operator|!=
literal|0
operator|&&
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'+'
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"use of both ` ' and `+' flags in format"
argument_list|)
expr_stmt|;
comment|/* "If the 0 and - flags both appear, 	     the 0 flag will be ignored."  */
if|if
condition|(
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'0'
argument_list|)
operator|!=
literal|0
operator|&&
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'-'
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"use of both `0' and `-' flags in format"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'*'
condition|)
block|{
name|wide
operator|=
name|TRUE
expr_stmt|;
comment|/* "...a field width...may be indicated by an asterisk. 		 In this case, an int argument supplies the field width..."  */
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|tfaff
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
comment|/* size_t is generally not valid here. 		     It will work on most machines, because size_t and int 		     have the same mode.  But might as well warn anyway, 		     since it will fail on other machines.  */
comment|/* XXX should we allow unsigned ints here?  */
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
operator|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|!=
name|unsigned_type_node
operator|)
condition|)
name|warning
argument_list|(
literal|"precision is not type int (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
block|{
name|wide
operator|=
name|TRUE
expr_stmt|;
operator|++
name|format_chars
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'.'
condition|)
block|{
name|precise
operator|=
name|TRUE
expr_stmt|;
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|!=
literal|'*'
operator|&&
operator|!
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`.' not followed by `*' or digit in format"
argument_list|)
expr_stmt|;
comment|/* "...a...precision...may be indicated by an asterisk. 		 In this case, an int argument supplies the...precision."  */
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|tfaff
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|warning
argument_list|(
literal|"field width is not type int (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|format_chars
argument_list|)
condition|)
operator|++
name|format_chars
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'b'
condition|)
block|{
comment|/* There should be an int arg to control the string arg.  */
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|tfaff
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
operator|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|!=
name|unsigned_type_node
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"bitmap is not type int (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'D'
condition|)
block|{
comment|/* There should be an unsigned char * arg before the string arg.  */
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|tfaff
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|!=
literal|0
condition|)
block|{
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
name|cur_type
operator|=
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|!=
name|POINTER_TYPE
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|!=
name|unsigned_char_type_node
condition|)
block|{
name|warning
argument_list|(
literal|"ethernet address is not type unsigned char *"
literal|" (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|aflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|format_type
operator|!=
name|strftime_format_type
condition|)
block|{
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'h'
operator|||
operator|*
name|format_chars
operator|==
literal|'l'
condition|)
name|length_char
operator|=
operator|*
name|format_chars
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'q'
operator|||
operator|*
name|format_chars
operator|==
literal|'L'
condition|)
block|{
name|length_char
operator|=
operator|*
name|format_chars
operator|++
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C does not support the `%c' length modifier"
argument_list|,
name|length_char
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'Z'
condition|)
block|{
name|length_char
operator|=
operator|*
name|format_chars
operator|++
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C does not support the `Z' length modifier"
argument_list|)
expr_stmt|;
block|}
else|else
name|length_char
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|length_char
operator|==
literal|'l'
operator|&&
operator|*
name|format_chars
operator|==
literal|'l'
condition|)
block|{
name|length_char
operator|=
literal|'q'
operator|,
name|format_chars
operator|++
expr_stmt|;
comment|/* FIXME: Is allowed in ISO C 9x.  */
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C does not support the `ll' length modifier"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length_char
operator|==
literal|'h'
operator|&&
operator|*
name|format_chars
operator|==
literal|'h'
condition|)
block|{
name|length_char
operator|=
literal|'H'
operator|,
name|format_chars
operator|++
expr_stmt|;
comment|/* FIXME: Is allowed in ISO C 9x.  */
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C does not support the `hh' length modifier"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'a'
operator|&&
name|info
operator|->
name|format_type
operator|==
name|scanf_format_type
condition|)
block|{
if|if
condition|(
name|format_chars
index|[
literal|1
index|]
operator|==
literal|'s'
operator|||
name|format_chars
index|[
literal|1
index|]
operator|==
literal|'S'
operator|||
name|format_chars
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
block|{
comment|/* `a' is used as a flag.  */
name|aflag
operator|=
literal|1
expr_stmt|;
name|format_chars
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|suppressed
operator|&&
name|length_char
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"use of `*' and `%c' together in format"
argument_list|,
name|length_char
argument_list|)
expr_stmt|;
block|}
name|format_char
operator|=
operator|*
name|format_chars
expr_stmt|;
if|if
condition|(
name|format_char
operator|==
literal|0
operator|||
operator|(
name|info
operator|->
name|format_type
operator|!=
name|strftime_format_type
operator|&&
name|format_char
operator|==
literal|'%'
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"conversion lacks type at end of format"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* The m, C, and S formats are GNU extensions.  */
if|if
condition|(
name|pedantic
operator|&&
name|info
operator|->
name|format_type
operator|!=
name|strftime_format_type
operator|&&
operator|(
name|format_char
operator|==
literal|'m'
operator|||
name|format_char
operator|==
literal|'C'
operator|||
name|format_char
operator|==
literal|'S'
operator|)
condition|)
name|warning
argument_list|(
literal|"ANSI C does not support the `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
comment|/* ??? The a and A formats are C9X extensions, and should be allowed 	 when a C9X option is added.  */
if|if
condition|(
name|pedantic
operator|&&
name|info
operator|->
name|format_type
operator|!=
name|strftime_format_type
operator|&&
operator|(
name|format_char
operator|==
literal|'a'
operator|||
name|format_char
operator|==
literal|'A'
operator|)
condition|)
name|warning
argument_list|(
literal|"ANSI C does not support the `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
name|format_chars
operator|++
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|format_type
condition|)
block|{
case|case
name|printf_format_type
case|:
name|fci
operator|=
name|flag_format_extensions
condition|?
name|print_char_table
else|:
name|unextended_print_char_table
expr_stmt|;
break|break;
case|case
name|scanf_format_type
case|:
name|fci
operator|=
name|scan_char_table
expr_stmt|;
break|break;
case|case
name|strftime_format_type
case|:
name|fci
operator|=
name|time_char_table
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|fci
operator|->
name|format_chars
operator|!=
literal|0
operator|&&
name|index
argument_list|(
name|fci
operator|->
name|format_chars
argument_list|,
name|format_char
argument_list|)
operator|==
literal|0
condition|)
operator|++
name|fci
expr_stmt|;
if|if
condition|(
name|fci
operator|->
name|format_chars
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|format_char
operator|>=
literal|040
operator|&&
name|format_char
operator|<
literal|0177
condition|)
name|warning
argument_list|(
literal|"unknown conversion type character `%c' in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"unknown conversion type character 0x%x in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'G'
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"ANSI C does not support `%%%c'"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'o'
argument_list|)
operator|!=
literal|0
operator|&&
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'O'
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"ANSI C does not support `%%O%c'"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wide
operator|&&
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'w'
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"width used with `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'2'
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"`%%%c' yields only last 2 digits of year"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'3'
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"`%%%c' yields only last 2 digits of year in some locales"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|precise
operator|&&
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'p'
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"precision used with `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|aflag
operator|&&
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'a'
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"`a' flag used with `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
comment|/* To simplify the following code.  */
name|aflag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* The a flag is a GNU extension.  */
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|aflag
condition|)
name|warning
argument_list|(
literal|"ANSI C does not support the `a' flag"
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|format_type
operator|==
name|scanf_format_type
operator|&&
name|format_char
operator|==
literal|'['
condition|)
block|{
comment|/* Skip over scan set, in case it happens to have '%' in it.  */
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|'^'
condition|)
operator|++
name|format_chars
expr_stmt|;
comment|/* Find closing bracket; if one is hit immediately, then 	     it's part of the scan set rather than a terminator.  */
if|if
condition|(
operator|*
name|format_chars
operator|==
literal|']'
condition|)
operator|++
name|format_chars
expr_stmt|;
while|while
condition|(
operator|*
name|format_chars
operator|&&
operator|*
name|format_chars
operator|!=
literal|']'
condition|)
operator|++
name|format_chars
expr_stmt|;
if|if
condition|(
operator|*
name|format_chars
operator|!=
literal|']'
condition|)
comment|/* The end of the format string was reached.  */
name|warning
argument_list|(
literal|"no closing `]' for `%%[' format"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|suppressed
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
literal|'*'
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"suppression of `%c' conversion in format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|flag_chars
index|[
name|i
index|]
operator|!=
literal|0
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|index
argument_list|(
name|fci
operator|->
name|flag_chars
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"flag `%c' used with type `%c'"
argument_list|,
name|flag_chars
index|[
name|i
index|]
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|format_type
operator|==
name|strftime_format_type
condition|)
continue|continue;
if|if
condition|(
name|precise
operator|&&
name|index
argument_list|(
name|flag_chars
argument_list|,
literal|'0'
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|format_char
operator|==
literal|'d'
operator|||
name|format_char
operator|==
literal|'i'
operator|||
name|format_char
operator|==
literal|'o'
operator|||
name|format_char
operator|==
literal|'u'
operator|||
name|format_char
operator|==
literal|'x'
operator|||
name|format_char
operator|==
literal|'x'
operator|)
condition|)
name|warning
argument_list|(
literal|"`0' flag ignored with precision specifier and `%c' format"
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|length_char
condition|)
block|{
default|default:
name|wanted_type
operator|=
name|fci
operator|->
name|nolen
condition|?
operator|*
operator|(
name|fci
operator|->
name|nolen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|hhlen
condition|?
operator|*
operator|(
name|fci
operator|->
name|hhlen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|hlen
condition|?
operator|*
operator|(
name|fci
operator|->
name|hlen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|llen
condition|?
operator|*
operator|(
name|fci
operator|->
name|llen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|qlen
condition|?
operator|*
operator|(
name|fci
operator|->
name|qlen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|bigllen
condition|?
operator|*
operator|(
name|fci
operator|->
name|bigllen
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|wanted_type
operator|=
name|fci
operator|->
name|zlen
condition|?
operator|*
name|fci
operator|->
name|zlen
else|:
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wanted_type
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"use of `%c' length character with `%c' type character"
argument_list|,
name|length_char
argument_list|,
name|format_char
argument_list|)
expr_stmt|;
comment|/* Finally. . .check type of argument against desired type!  */
if|if
condition|(
name|info
operator|->
name|first_arg_num
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|fci
operator|->
name|pointer_count
operator|==
literal|0
operator|&&
name|wanted_type
operator|==
name|void_type_node
condition|)
comment|/* This specifier takes no argument.  */
continue|continue;
if|if
condition|(
name|params
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
name|tfaff
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_param
operator|=
name|TREE_VALUE
argument_list|(
name|params
argument_list|)
expr_stmt|;
name|params
operator|=
name|TREE_CHAIN
argument_list|(
name|params
argument_list|)
expr_stmt|;
operator|++
name|arg_num
expr_stmt|;
name|cur_type
operator|=
name|TREE_TYPE
argument_list|(
name|cur_param
argument_list|)
expr_stmt|;
name|STRIP_NOPS
argument_list|(
name|cur_param
argument_list|)
expr_stmt|;
comment|/* Check the types of any additional pointer arguments 	 that precede the "real" argument.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fci
operator|->
name|pointer_count
operator|+
name|aflag
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
block|{
name|cur_type
operator|=
name|TREE_TYPE
argument_list|(
name|cur_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_param
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|cur_param
argument_list|)
operator|==
name|ADDR_EXPR
condition|)
name|cur_param
operator|=
name|TREE_OPERAND
argument_list|(
name|cur_param
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|cur_param
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|warning
argument_list|(
literal|"format argument is not a %s (arg %d)"
argument_list|,
operator|(
operator|(
name|fci
operator|->
name|pointer_count
operator|+
name|aflag
operator|==
literal|1
operator|)
condition|?
literal|"pointer"
else|:
literal|"pointer to a pointer"
operator|)
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* See if this is an attempt to write into a const type with 	 scanf or with printf "%n".  */
if|if
condition|(
operator|(
name|info
operator|->
name|format_type
operator|==
name|scanf_format_type
operator|||
operator|(
name|info
operator|->
name|format_type
operator|==
name|printf_format_type
operator|&&
name|format_char
operator|==
literal|'n'
operator|)
operator|)
operator|&&
name|i
operator|==
name|fci
operator|->
name|pointer_count
operator|+
name|aflag
operator|&&
name|wanted_type
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|cur_type
argument_list|)
operator|||
operator|(
name|cur_param
operator|!=
literal|0
operator|&&
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|==
literal|'c'
operator|||
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|cur_param
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
name|TREE_READONLY
argument_list|(
name|cur_param
argument_list|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|"writing into constant object (arg %d)"
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
comment|/* Check the type of the "real" argument, if there's a type we want.  */
if|if
condition|(
name|i
operator|==
name|fci
operator|->
name|pointer_count
operator|+
name|aflag
operator|&&
name|wanted_type
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|wanted_type
operator|!=
name|TYPE_MAIN_VARIANT
argument_list|(
name|cur_type
argument_list|)
comment|/* If we want `void *', allow any pointer type. 	     (Anything else would already have got a warning.)  */
operator|&&
operator|!
operator|(
name|wanted_type
operator|==
name|void_type_node
operator|&&
name|fci
operator|->
name|pointer_count
operator|>
literal|0
operator|)
comment|/* Don't warn about differences merely in signedness.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|wanted_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
operator|(
name|TREE_UNSIGNED
argument_list|(
name|wanted_type
argument_list|)
condition|?
name|wanted_type
operator|==
operator|(
name|cur_type
operator|=
name|unsigned_type
argument_list|(
name|cur_type
argument_list|)
operator|)
else|:
name|wanted_type
operator|==
operator|(
name|cur_type
operator|=
name|signed_type
argument_list|(
name|cur_type
argument_list|)
operator|)
operator|)
operator|)
comment|/* Likewise, "signed char", "unsigned char" and "char" are 	     equivalent but the above test won't consider them equivalent.  */
operator|&&
operator|!
operator|(
name|wanted_type
operator|==
name|char_type_node
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|cur_type
argument_list|)
operator|==
name|signed_char_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|cur_type
argument_list|)
operator|==
name|unsigned_char_type_node
operator|)
operator|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|this
decl_stmt|;
specifier|register
name|char
modifier|*
name|that
decl_stmt|;
name|this
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|wanted_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|that
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
operator|&&
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|that
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|that
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* A nameless type can't possibly match what the format wants. 	     So there will be a warning for it. 	     Make up a string to describe vaguely what it is.  */
if|if
condition|(
name|that
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|POINTER_TYPE
condition|)
name|that
operator|=
literal|"pointer"
expr_stmt|;
else|else
name|that
operator|=
literal|"different type"
expr_stmt|;
block|}
comment|/* Make the warning better in case of mismatch of int vs long.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|cur_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|wanted_type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|cur_type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|wanted_type
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|that
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|TYPE_NAME
argument_list|(
name|cur_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|this
argument_list|,
name|that
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"%s format, %s arg (arg %d)"
argument_list|,
name|this
argument_list|,
name|that
argument_list|,
name|arg_num
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a warning if a constant expression had overflow in folding.    Invoke this function on every expression that the language    requires to be a constant expression.    Note the ANSI C standard says it is erroneous for a    constant expression to overflow.  */
end_comment

begin_function
name|void
name|constant_expression_warning
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
operator|||
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|)
operator|&&
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"overflow in constant expression"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a warning if an expression had overflow in folding.    Invoke this function on every expression that    (1) appears in the source code, and    (2) might be a constant expression that overflowed, and    (3) is not already checked by convert_and_check;    however, do not invoke this function on operands of explicit casts.  */
end_comment

begin_function
name|void
name|overflow_warning
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
operator|)
operator|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"integer overflow in expression"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REAL_CST
operator|||
operator|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|COMPLEX_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_REALPART
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|REAL_CST
operator|)
operator|)
operator|&&
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|value
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"floating point overflow in expression"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a warning if a large constant is truncated to unsigned,    or if -Wconversion is used and a constant< 0 is converted to unsigned.    Invoke this function on every expression that might be implicitly    converted to an unsigned type.  */
end_comment

begin_function
name|void
name|unsigned_conversion_warning
parameter_list|(
name|result
parameter_list|,
name|operand
parameter_list|)
name|tree
name|result
decl_stmt|,
name|operand
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|operand
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
operator|&&
name|skip_evaluation
operator|==
literal|0
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|operand
argument_list|,
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|int_fits_type_p
argument_list|(
name|operand
argument_list|,
name|signed_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|result
argument_list|)
argument_list|)
argument_list|)
condition|)
comment|/* This detects cases like converting -129 or 256 to unsigned char.  */
name|warning
argument_list|(
literal|"large integer implicitly truncated to unsigned type"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_conversion
condition|)
name|warning
argument_list|(
literal|"negative integer implicitly converted to unsigned type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert EXPR to TYPE, warning about conversion problems with constants.    Invoke this function on every expression that is converted implicitly,    i.e. because of language rules and not because of an explicit cast.  */
end_comment

begin_function
name|tree
name|convert_and_check
parameter_list|(
name|type
parameter_list|,
name|expr
parameter_list|)
name|tree
name|type
decl_stmt|,
name|expr
decl_stmt|;
block|{
name|tree
name|t
init|=
name|convert
argument_list|(
name|type
argument_list|,
name|expr
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
condition|)
block|{
name|TREE_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Do not diagnose overflow in a constant expression merely 	     because a conversion overflowed.  */
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|expr
argument_list|)
expr_stmt|;
comment|/* No warning for converting 0x80000000 to int.  */
if|if
condition|(
operator|!
operator|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|<
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|)
condition|)
comment|/* If EXPR fits in the unsigned version of TYPE, 	       don't warn unless pedantic.  */
if|if
condition|(
operator|(
name|pedantic
operator|||
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|||
operator|!
name|int_fits_type_p
argument_list|(
name|expr
argument_list|,
name|unsigned_type
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
operator|&&
name|skip_evaluation
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"overflow in implicit constant conversion"
argument_list|)
expr_stmt|;
block|}
else|else
name|unsigned_conversion_warning
argument_list|(
name|t
argument_list|,
name|expr
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|c_expand_expr_stmt
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
comment|/* Do default conversion if safe and possibly important,      in case within ({...}).  */
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|lvalue_p
argument_list|(
name|expr
argument_list|)
operator|)
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
name|expr
operator|=
name|default_conversion
argument_list|(
name|expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|error_mark_node
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
name|error
argument_list|(
literal|"expression statement has incomplete type"
argument_list|)
expr_stmt|;
name|expand_expr_stmt
argument_list|(
name|expr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Validate the expression after `case' and apply default promotions.  */
end_comment

begin_function
name|tree
name|check_case_value
parameter_list|(
name|value
parameter_list|)
name|tree
name|value
decl_stmt|;
block|{
if|if
condition|(
name|value
operator|==
name|NULL_TREE
condition|)
return|return
name|value
return|;
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|INTEGER_CST
operator|&&
name|value
operator|!=
name|error_mark_node
condition|)
block|{
name|error
argument_list|(
literal|"case label does not reduce to an integer constant"
argument_list|)
expr_stmt|;
name|value
operator|=
name|error_mark_node
expr_stmt|;
block|}
else|else
comment|/* Promote char or short to int.  */
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return an integer type with BITS bits of precision,    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */
end_comment

begin_function
name|tree
name|type_for_size
parameter_list|(
name|bits
parameter_list|,
name|unsignedp
parameter_list|)
name|unsigned
name|bits
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|bits
operator|==
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
operator|(
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|bits
operator|<=
name|TYPE_PRECISION
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a data type that has machine mode MODE.    If the mode is an integer,    then UNSIGNEDP selects between signed and unsigned types.  */
end_comment

begin_function
name|tree
name|type_for_mode
parameter_list|(
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|signed_char_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_char_type_node
else|:
name|signed_char_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|short_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|short_unsigned_type_node
else|:
name|short_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_long_integer_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intQI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intQI_type_node
else|:
name|intQI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intHI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intHI_type_node
else|:
name|intHI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intSI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intSI_type_node
else|:
name|intSI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intDI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intDI_type_node
else|:
name|intDI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|intTI_type_node
argument_list|)
condition|)
return|return
name|unsignedp
condition|?
name|unsigned_intTI_type_node
else|:
name|intTI_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|float_type_node
argument_list|)
condition|)
return|return
name|float_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|double_type_node
argument_list|)
condition|)
return|return
name|double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|long_double_type_node
argument_list|)
condition|)
return|return
name|long_double_type_node
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|TYPE_MODE
argument_list|(
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
condition|)
return|return
name|build_pointer_type
argument_list|(
name|integer_type_node
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the minimum number of bits needed to represent VALUE in a    signed or unsigned type, UNSIGNEDP says which.  */
end_comment

begin_function
name|int
name|min_precision
parameter_list|(
name|value
parameter_list|,
name|unsignedp
parameter_list|)
name|tree
name|value
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|int
name|log
decl_stmt|;
comment|/* If the value is negative, compute its negative minus 1.  The latter      adjustment is because the absolute value of the largest negative value      is one larger than the largest positive value.  This is equivalent to      a bit-wise negation, so use that operation instead.  */
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|value
argument_list|)
operator|<
literal|0
condition|)
name|value
operator|=
name|fold
argument_list|(
name|build1
argument_list|(
name|BIT_NOT_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the number of bits needed, taking into account the fact      that we need one more bit for a signed than unsigned type.  */
if|if
condition|(
name|integer_zerop
argument_list|(
name|value
argument_list|)
condition|)
name|log
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|value
argument_list|)
operator|!=
literal|0
condition|)
name|log
operator|=
name|HOST_BITS_PER_WIDE_INT
operator|+
name|floor_log2
argument_list|(
name|TREE_INT_CST_HIGH
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log
operator|=
name|floor_log2
argument_list|(
name|TREE_INT_CST_LOW
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|log
operator|+
literal|1
operator|+
operator|!
name|unsignedp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print an error message for invalid operands to arith operation CODE.    NOP_EXPR is used as a special case (see truthvalue_conversion).  */
end_comment

begin_function
name|void
name|binary_op_error
parameter_list|(
name|code
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|opname
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|NOP_EXPR
case|:
name|error
argument_list|(
literal|"invalid truth-value expression"
argument_list|)
expr_stmt|;
return|return;
case|case
name|PLUS_EXPR
case|:
name|opname
operator|=
literal|"+"
expr_stmt|;
break|break;
case|case
name|MINUS_EXPR
case|:
name|opname
operator|=
literal|"-"
expr_stmt|;
break|break;
case|case
name|MULT_EXPR
case|:
name|opname
operator|=
literal|"*"
expr_stmt|;
break|break;
case|case
name|MAX_EXPR
case|:
name|opname
operator|=
literal|"max"
expr_stmt|;
break|break;
case|case
name|MIN_EXPR
case|:
name|opname
operator|=
literal|"min"
expr_stmt|;
break|break;
case|case
name|EQ_EXPR
case|:
name|opname
operator|=
literal|"=="
expr_stmt|;
break|break;
case|case
name|NE_EXPR
case|:
name|opname
operator|=
literal|"!="
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|opname
operator|=
literal|"<="
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|opname
operator|=
literal|">="
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
name|opname
operator|=
literal|"<"
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|opname
operator|=
literal|">"
expr_stmt|;
break|break;
case|case
name|LSHIFT_EXPR
case|:
name|opname
operator|=
literal|"<<"
expr_stmt|;
break|break;
case|case
name|RSHIFT_EXPR
case|:
name|opname
operator|=
literal|">>"
expr_stmt|;
break|break;
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
name|opname
operator|=
literal|"%"
expr_stmt|;
break|break;
case|case
name|TRUNC_DIV_EXPR
case|:
case|case
name|FLOOR_DIV_EXPR
case|:
name|opname
operator|=
literal|"/"
expr_stmt|;
break|break;
case|case
name|BIT_AND_EXPR
case|:
name|opname
operator|=
literal|"&"
expr_stmt|;
break|break;
case|case
name|BIT_IOR_EXPR
case|:
name|opname
operator|=
literal|"|"
expr_stmt|;
break|break;
case|case
name|TRUTH_ANDIF_EXPR
case|:
name|opname
operator|=
literal|"&&"
expr_stmt|;
break|break;
case|case
name|TRUTH_ORIF_EXPR
case|:
name|opname
operator|=
literal|"||"
expr_stmt|;
break|break;
case|case
name|BIT_XOR_EXPR
case|:
name|opname
operator|=
literal|"^"
expr_stmt|;
break|break;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
name|opname
operator|=
literal|"rotate"
expr_stmt|;
break|break;
default|default:
name|opname
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"invalid operands to binary %s"
argument_list|,
name|opname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of build_binary_op, used for comparison operations.    See if the operands have both been converted from subword integer types    and, if so, perhaps change them both back to their original type.    This function is also responsible for converting the two operands    to the proper common type for comparison.     The arguments of this function are all pointers to local variables    of build_binary_op: OP0_PTR is&OP0, OP1_PTR is&OP1,    RESTYPE_PTR is&RESULT_TYPE and RESCODE_PTR is&RESULTCODE.     If this function returns nonzero, it means that the comparison has    a constant value.  What this function returns is an expression for    that value.  */
end_comment

begin_function
name|tree
name|shorten_compare
parameter_list|(
name|op0_ptr
parameter_list|,
name|op1_ptr
parameter_list|,
name|restype_ptr
parameter_list|,
name|rescode_ptr
parameter_list|)
name|tree
modifier|*
name|op0_ptr
decl_stmt|,
decl|*
name|op1_ptr
decl_stmt|;
end_function

begin_decl_stmt
name|tree
modifier|*
name|restype_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|tree_code
modifier|*
name|rescode_ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|tree
name|type
decl_stmt|;
name|tree
name|op0
init|=
operator|*
name|op0_ptr
decl_stmt|;
name|tree
name|op1
init|=
operator|*
name|op1_ptr
decl_stmt|;
name|int
name|unsignedp0
decl_stmt|,
name|unsignedp1
decl_stmt|;
name|int
name|real1
decl_stmt|,
name|real2
decl_stmt|;
name|tree
name|primop0
decl_stmt|,
name|primop1
decl_stmt|;
name|enum
name|tree_code
name|code
init|=
operator|*
name|rescode_ptr
decl_stmt|;
comment|/* Throw away any conversions to wider types      already present in the operands.  */
name|primop0
operator|=
name|get_narrower
argument_list|(
name|op0
argument_list|,
operator|&
name|unsignedp0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|get_narrower
argument_list|(
name|op1
argument_list|,
operator|&
name|unsignedp1
argument_list|)
expr_stmt|;
comment|/* Handle the case that OP0 does not *contain* a conversion      but it *requires* conversion to FINAL_TYPE.  */
if|if
condition|(
name|op0
operator|==
name|primop0
operator|&&
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp0
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|primop1
operator|&&
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|unsignedp1
operator|=
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If one of the operands must be floated, we cannot optimize.  */
name|real1
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
name|real2
operator|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
expr_stmt|;
comment|/* If first arg is constant, swap the args (changing operation      so value is preserved), for canonicalization.  Don't do this if      the second arg is 0.  */
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|primop0
argument_list|)
operator|&&
operator|!
name|integer_zerop
argument_list|(
name|primop1
argument_list|)
operator|&&
operator|!
name|real_zerop
argument_list|(
name|primop1
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|tem
init|=
name|primop0
decl_stmt|;
specifier|register
name|int
name|temi
init|=
name|unsignedp0
decl_stmt|;
name|primop0
operator|=
name|primop1
expr_stmt|;
name|primop1
operator|=
name|tem
expr_stmt|;
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
operator|*
name|op0_ptr
operator|=
name|op0
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|op1
expr_stmt|;
name|unsignedp0
operator|=
name|unsignedp1
expr_stmt|;
name|unsignedp1
operator|=
name|temi
expr_stmt|;
name|temi
operator|=
name|real1
expr_stmt|;
name|real1
operator|=
name|real2
expr_stmt|;
name|real2
operator|=
name|temi
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
case|case
name|GT_EXPR
case|:
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
name|code
operator|=
name|GE_EXPR
expr_stmt|;
break|break;
case|case
name|GE_EXPR
case|:
name|code
operator|=
name|LE_EXPR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
operator|*
name|rescode_ptr
operator|=
name|code
expr_stmt|;
block|}
comment|/* If comparing an integer against a constant more bits wide,      maybe we can deduce a value of 1 or 0 independent of the data.      Or else truncate the constant now      rather than extend the variable at run time.       This is only interesting if the constant is the wider arg.      Also, it is not safe if the constant is unsigned and the      variable arg is signed, since in this case the variable      would be sign-extended and then regarded as unsigned.      Our technique fails in this case because the lowest/highest      possible unsigned results don't follow naturally from the      lowest/highest possible values of the variable operand.      For just EQ_EXPR and NE_EXPR there is another technique that      could be used: see if the constant can be faithfully represented      in the other operand's type, by truncating it and reextending it      and see if that preserves the constant's value.  */
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|TREE_CODE
argument_list|(
name|primop1
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|int
name|min_gt
decl_stmt|,
name|max_gt
decl_stmt|,
name|min_lt
decl_stmt|,
name|max_lt
decl_stmt|;
name|tree
name|maxval
decl_stmt|,
name|minval
decl_stmt|;
comment|/* 1 if comparison is nominally unsigned.  */
name|int
name|unsignedp
init|=
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
decl_stmt|;
name|tree
name|val
decl_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If TYPE is an enumeration, then we need to get its min/max 	 values from it's underlying integral type, not the enumerated 	 type itself.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
condition|)
name|type
operator|=
name|type_for_size
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|unsignedp0
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|minval
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
operator|*
name|restype_ptr
operator|=
name|signed_type
argument_list|(
operator|*
name|restype_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
operator|!=
operator|*
name|restype_ptr
condition|)
name|primop1
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
operator|*
name|restype_ptr
condition|)
block|{
name|minval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|maxval
operator|=
name|convert
argument_list|(
operator|*
name|restype_ptr
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsignedp
operator|&&
name|unsignedp0
condition|)
block|{
name|min_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT_UNSIGNED
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|min_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|minval
argument_list|)
expr_stmt|;
name|max_gt
operator|=
name|INT_CST_LT
argument_list|(
name|primop1
argument_list|,
name|maxval
argument_list|)
expr_stmt|;
name|min_lt
operator|=
name|INT_CST_LT
argument_list|(
name|minval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
name|max_lt
operator|=
name|INT_CST_LT
argument_list|(
name|maxval
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
comment|/* This used to be a switch, but Genix compiler can't handle that.  */
if|if
condition|(
name|code
operator|==
name|NE_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|EQ_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
operator|||
name|min_gt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LT_EXPR
condition|)
block|{
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GT_EXPR
condition|)
block|{
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|LE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|max_gt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
name|min_gt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|GE_EXPR
condition|)
block|{
if|if
condition|(
operator|!
name|min_lt
condition|)
name|val
operator|=
name|boolean_true_node
expr_stmt|;
if|if
condition|(
name|max_lt
condition|)
name|val
operator|=
name|boolean_false_node
expr_stmt|;
block|}
comment|/* If primop0 was sign-extended and unsigned comparison specd, 	 we did a signed comparison above using the signed type bounds. 	 But the comparison we output must be unsigned.  	 Also, for inequalities, VAL is no good; but if the signed 	 comparison had *any* fixed result, it follows that the 	 unsigned comparison just tests the sign in reverse 	 (positive values are LE, negative ones GE). 	 So we can generate an unsigned comparison 	 against an extreme value of the signed type.  */
if|if
condition|(
name|unsignedp
operator|&&
operator|!
name|unsignedp0
condition|)
block|{
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT_EXPR
case|:
case|case
name|GE_EXPR
case|:
name|primop1
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LE_EXPR
case|:
case|case
name|GT_EXPR
case|:
name|primop1
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|type
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|max_gt
operator|&&
operator|!
name|unsignedp0
operator|&&
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* This is the case of (char)x>?< 0x80, which people used to use 	     expecting old C compilers to change the 0x80 into -0x80.  */
if|if
condition|(
name|val
operator|==
name|boolean_false_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 0 due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|boolean_true_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 1 due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|min_lt
operator|&&
name|unsignedp0
operator|&&
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
block|{
comment|/* This is the case of (unsigned char)x>?< -1 or< 0.  */
if|if
condition|(
name|val
operator|==
name|boolean_false_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 0 due to limited range of data type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|boolean_true_node
condition|)
name|warning
argument_list|(
literal|"comparison is always 1 due to limited range of data type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|val
argument_list|)
return|;
return|return
name|val
return|;
block|}
comment|/* Value is not predetermined, but do the comparison 	 in the type of the operand that is not constant. 	 TYPE is already properly set.  */
block|}
elseif|else
if|if
condition|(
name|real1
operator|&&
name|real2
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|)
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
expr_stmt|;
comment|/* If args' natural types are both narrower than nominal type      and both extend in the same manner, compare them      in the type of the wider arg.      Otherwise must actually extend both to the nominal      common type lest different ways of extending      alter the result.      (eg, (short)-1 == (unsigned short)-1  should be 0.)  */
elseif|else
if|if
condition|(
name|unsignedp0
operator|==
name|unsignedp1
operator|&&
name|real1
operator|==
name|real2
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|type
operator|=
name|common_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
operator|||
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Make sure shorter operand is extended the right way 	 to match the longer operand.  */
name|primop0
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp0
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop0
argument_list|)
argument_list|)
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
name|primop1
operator|=
name|convert
argument_list|(
name|signed_or_unsigned_type
argument_list|(
name|unsignedp1
argument_list|,
name|TREE_TYPE
argument_list|(
name|primop1
argument_list|)
argument_list|)
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here we must do the comparison on the nominal type 	 using the args exactly as we received them.  */
name|type
operator|=
operator|*
name|restype_ptr
expr_stmt|;
name|primop0
operator|=
name|op0
expr_stmt|;
name|primop1
operator|=
name|op1
expr_stmt|;
if|if
condition|(
operator|!
name|real1
operator|&&
operator|!
name|real2
operator|&&
name|integer_zerop
argument_list|(
name|primop1
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
operator|*
name|restype_ptr
argument_list|)
condition|)
block|{
name|tree
name|value
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|GE_EXPR
case|:
comment|/* All unsigned values are>= 0, so we warn if extra warnings 		 are requested.  However, if OP0 is a constant that is>= 0, the signedness of the comparison isn't an issue, 		 so suppress the warning.  */
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|convert
argument_list|(
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|primop0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"unsigned value>= 0 is always 1"
argument_list|)
expr_stmt|;
name|value
operator|=
name|boolean_true_node
expr_stmt|;
break|break;
case|case
name|LT_EXPR
case|:
if|if
condition|(
name|extra_warnings
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|primop0
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
operator|!
name|TREE_OVERFLOW
argument_list|(
name|convert
argument_list|(
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|primop0
argument_list|)
argument_list|)
operator|)
condition|)
name|warning
argument_list|(
literal|"unsigned value< 0 is always 0"
argument_list|)
expr_stmt|;
name|value
operator|=
name|boolean_false_node
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* Don't forget to evaluate PRIMOP0 if it has side effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|primop0
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|,
name|primop0
argument_list|,
name|value
argument_list|)
return|;
return|return
name|value
return|;
block|}
block|}
block|}
operator|*
name|op0_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop0
argument_list|)
expr_stmt|;
operator|*
name|op1_ptr
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|primop1
argument_list|)
expr_stmt|;
operator|*
name|restype_ptr
operator|=
name|boolean_type_node
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Prepare expr to be an argument of a TRUTH_NOT_EXPR,    or validate its data type for an `if' or `while' statement or ?..: exp.     This preparation consists of taking the ordinary    representation of an expression expr and producing a valid tree    boolean expression describing whether expr is nonzero.  We could    simply always do build_binary_op (NE_EXPR, expr, boolean_false_node, 1),    but we optimize comparisons,&&, ||, and !.     The resulting type should always be `boolean_type_node'.  */
end_comment

begin_function
name|tree
name|truthvalue_conversion
parameter_list|(
name|expr
parameter_list|)
name|tree
name|expr
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|ERROR_MARK
condition|)
return|return
name|expr
return|;
if|#
directive|if
literal|0
comment|/* This appears to be wrong for C++.  */
comment|/* These really should return error_mark_node after 2.4 is stable.      But not all callers handle ERROR_MARK properly.  */
block|switch (TREE_CODE (TREE_TYPE (expr)))     {     case RECORD_TYPE:       error ("struct type value used where scalar is required");       return boolean_false_node;      case UNION_TYPE:       error ("union type value used where scalar is required");       return boolean_false_node;      case ARRAY_TYPE:       error ("array type value used where scalar is required");       return boolean_false_node;      default:       break;     }
endif|#
directive|endif
comment|/* 0 */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|expr
argument_list|)
condition|)
block|{
comment|/* It is simpler and generates better code to have only TRUTH_*_EXPR 	 or comparison expressions as truth values at this level.  */
if|#
directive|if
literal|0
block|case COMPONENT_REF:
comment|/* A one-bit unsigned bit-field is already acceptable.  */
block|if (1 == TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (expr, 1)))&& TREE_UNSIGNED (TREE_OPERAND (expr, 1))) 	return expr;       break;
endif|#
directive|endif
case|case
name|EQ_EXPR
case|:
comment|/* It is simpler and generates better code to have only TRUTH_*_EXPR 	 or comparison expressions as truth values at this level.  */
if|#
directive|if
literal|0
block|if (integer_zerop (TREE_OPERAND (expr, 1))) 	return build_unary_op (TRUTH_NOT_EXPR, TREE_OPERAND (expr, 0), 0);
endif|#
directive|endif
case|case
name|NE_EXPR
case|:
case|case
name|LE_EXPR
case|:
case|case
name|GE_EXPR
case|:
case|case
name|LT_EXPR
case|:
case|case
name|GT_EXPR
case|:
case|case
name|TRUTH_ANDIF_EXPR
case|:
case|case
name|TRUTH_ORIF_EXPR
case|:
case|case
name|TRUTH_AND_EXPR
case|:
case|case
name|TRUTH_OR_EXPR
case|:
case|case
name|TRUTH_XOR_EXPR
case|:
case|case
name|TRUTH_NOT_EXPR
case|:
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|=
name|boolean_type_node
expr_stmt|;
return|return
name|expr
return|;
case|case
name|ERROR_MARK
case|:
return|return
name|expr
return|;
case|case
name|INTEGER_CST
case|:
return|return
name|integer_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
return|;
case|case
name|REAL_CST
case|:
return|return
name|real_zerop
argument_list|(
name|expr
argument_list|)
condition|?
name|boolean_false_node
else|:
name|boolean_true_node
return|;
case|case
name|ADDR_EXPR
case|:
comment|/* If we are taking the address of a external decl, it might be zero 	 if it is weak, so we cannot optimize.  */
if|if
condition|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|'d'
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|boolean_true_node
argument_list|)
return|;
else|else
return|return
name|boolean_true_node
return|;
case|case
name|COMPLEX_EXPR
case|:
return|return
name|build_binary_op
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|NEGATE_EXPR
case|:
case|case
name|ABS_EXPR
case|:
case|case
name|FLOAT_EXPR
case|:
case|case
name|FFS_EXPR
case|:
comment|/* These don't change whether an object is non-zero or zero.  */
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|LROTATE_EXPR
case|:
case|case
name|RROTATE_EXPR
case|:
comment|/* These don't change whether an object is zero or non-zero, but 	 we can't ignore them if their second arg has side-effects.  */
if|if
condition|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build
argument_list|(
name|COMPOUND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
return|;
else|else
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
case|case
name|COND_EXPR
case|:
comment|/* Distribute the conversion into the arms of a COND_EXPR.  */
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|COND_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|2
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|CONVERT_EXPR
case|:
comment|/* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE, 	 since that affects how `default_conversion' will behave.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
break|break;
comment|/* fall through...  */
case|case
name|NOP_EXPR
case|:
comment|/* If this is widening the argument, we can ignore it.  */
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
condition|)
return|return
name|truthvalue_conversion
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|MINUS_EXPR
case|:
comment|/* With IEEE arithmetic, x - x may not equal 0, so we can't optimize 	 this case.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|==
name|IEEE_FLOAT_FORMAT
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|REAL_TYPE
condition|)
break|break;
comment|/* fall through...  */
case|case
name|BIT_XOR_EXPR
case|:
comment|/* This and MINUS_EXPR can be changed into a comparison of the 	 two objects.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|,
name|fold
argument_list|(
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|BIT_AND_EXPR
case|:
if|if
condition|(
name|integer_onep
argument_list|(
name|TREE_OPERAND
argument_list|(
name|expr
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
operator|!=
name|boolean_type_node
condition|)
comment|/* Using convert here would cause infinite recursion.  */
return|return
name|build1
argument_list|(
name|NOP_EXPR
argument_list|,
name|boolean_type_node
argument_list|,
name|expr
argument_list|)
return|;
break|break;
case|case
name|MODIFY_EXPR
case|:
if|if
condition|(
name|warn_parentheses
operator|&&
name|C_EXP_ORIGINAL_CODE
argument_list|(
name|expr
argument_list|)
operator|==
name|MODIFY_EXPR
condition|)
name|warning
argument_list|(
literal|"suggest parentheses around assignment used as truth value"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|expr
argument_list|)
argument_list|)
operator|==
name|COMPLEX_TYPE
condition|)
block|{
name|tree
name|tem
init|=
name|save_expr
argument_list|(
name|expr
argument_list|)
decl_stmt|;
return|return
operator|(
name|build_binary_op
argument_list|(
operator|(
name|TREE_SIDE_EFFECTS
argument_list|(
name|expr
argument_list|)
condition|?
name|TRUTH_OR_EXPR
else|:
name|TRUTH_ORIF_EXPR
operator|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|build_unary_op
argument_list|(
name|REALPART_EXPR
argument_list|,
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|truthvalue_conversion
argument_list|(
name|build_unary_op
argument_list|(
name|IMAGPART_EXPR
argument_list|,
name|tem
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
return|return
name|build_binary_op
argument_list|(
name|NE_EXPR
argument_list|,
name|expr
argument_list|,
name|integer_zero_node
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|USE_CPPLIB
end_if

begin_comment
comment|/* Read the rest of a #-directive from input stream FINPUT.    In normal use, the directive name and the white space after it    have already been read, so they won't be included in the result.    We allow for the fact that the directive line may contain    a newline embedded within a character or string literal which forms    a part of the directive.     The value is a string in a reusable buffer.  It remains valid    only until the next time this function is called.  */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|yy_cur
decl_stmt|,
modifier|*
name|yy_lim
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GETC
parameter_list|()
value|(yy_cur< yy_lim ? *yy_cur++ : yy_get_token ())
end_define

begin_define
define|#
directive|define
name|UNGETC
parameter_list|(
name|c
parameter_list|)
value|((c), yy_cur--)
end_define

begin_function
name|int
name|yy_get_token
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|parse_in
operator|.
name|limit
operator|=
name|parse_in
operator|.
name|token_buffer
expr_stmt|;
name|cpp_token
operator|=
name|cpp_get_token
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp_token
operator|==
name|CPP_EOF
condition|)
return|return
operator|-
literal|1
return|;
name|yy_lim
operator|=
name|CPP_PWRITTEN
argument_list|(
operator|&
name|parse_in
argument_list|)
expr_stmt|;
name|yy_cur
operator|=
name|parse_in
operator|.
name|token_buffer
expr_stmt|;
if|if
condition|(
name|yy_cur
operator|<
name|yy_lim
condition|)
return|return
operator|*
name|yy_cur
operator|++
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|get_directive_line
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|directive_buffer
init|=
name|NULL
decl_stmt|;
specifier|static
name|unsigned
name|buffer_length
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer_limit
decl_stmt|;
specifier|register
name|int
name|looking_for
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|char_escaped
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|buffer_length
operator|==
literal|0
condition|)
block|{
name|directive_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|buffer_length
operator|=
literal|128
expr_stmt|;
block|}
name|buffer_limit
operator|=
operator|&
name|directive_buffer
index|[
name|buffer_length
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|directive_buffer
init|;
condition|;
control|)
block|{
name|int
name|c
decl_stmt|;
comment|/* Make buffer bigger if it is full.  */
if|if
condition|(
name|p
operator|>=
name|buffer_limit
condition|)
block|{
specifier|register
name|unsigned
name|bytes_used
init|=
operator|(
name|p
operator|-
name|directive_buffer
operator|)
decl_stmt|;
name|buffer_length
operator|*=
literal|2
expr_stmt|;
name|directive_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|directive_buffer
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|directive_buffer
index|[
name|bytes_used
index|]
expr_stmt|;
name|buffer_limit
operator|=
operator|&
name|directive_buffer
index|[
name|buffer_length
index|]
expr_stmt|;
block|}
name|c
operator|=
name|GETC
argument_list|()
expr_stmt|;
comment|/* Discard initial whitespace.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
operator|&&
name|p
operator|==
name|directive_buffer
condition|)
continue|continue;
comment|/* Detect the end of the directive.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|looking_for
operator|==
literal|0
condition|)
block|{
name|UNGETC
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|directive_buffer
return|;
comment|/* Handle string and character constant syntax.  */
if|if
condition|(
name|looking_for
condition|)
block|{
if|if
condition|(
name|looking_for
operator|==
name|c
operator|&&
operator|!
name|char_escaped
condition|)
name|looking_for
operator|=
literal|0
expr_stmt|;
comment|/* Found terminator... stop looking.  */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|looking_for
operator|=
name|c
expr_stmt|;
comment|/* Don't stop buffering until we see another 				   another one of these (or an EOF).  */
comment|/* Handle backslash.  */
name|char_escaped
operator|=
operator|(
name|c
operator|==
literal|'\\'
operator|&&
operator|!
name|char_escaped
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Read the rest of a #-directive from input stream FINPUT.    In normal use, the directive name and the white space after it    have already been read, so they won't be included in the result.    We allow for the fact that the directive line may contain    a newline embedded within a character or string literal which forms    a part of the directive.     The value is a string in a reusable buffer.  It remains valid    only until the next time this function is called.     The terminating character ('\n' or EOF) is left in FINPUT for the    caller to re-read.  */
end_comment

begin_function
name|char
modifier|*
name|get_directive_line
parameter_list|(
name|finput
parameter_list|)
specifier|register
name|FILE
modifier|*
name|finput
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|directive_buffer
init|=
name|NULL
decl_stmt|;
specifier|static
name|unsigned
name|buffer_length
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer_limit
decl_stmt|;
specifier|register
name|int
name|looking_for
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|char_escaped
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|buffer_length
operator|==
literal|0
condition|)
block|{
name|directive_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|128
argument_list|)
expr_stmt|;
name|buffer_length
operator|=
literal|128
expr_stmt|;
block|}
name|buffer_limit
operator|=
operator|&
name|directive_buffer
index|[
name|buffer_length
index|]
expr_stmt|;
for|for
control|(
name|p
operator|=
name|directive_buffer
init|;
condition|;
control|)
block|{
name|int
name|c
decl_stmt|;
comment|/* Make buffer bigger if it is full.  */
if|if
condition|(
name|p
operator|>=
name|buffer_limit
condition|)
block|{
specifier|register
name|unsigned
name|bytes_used
init|=
operator|(
name|p
operator|-
name|directive_buffer
operator|)
decl_stmt|;
name|buffer_length
operator|*=
literal|2
expr_stmt|;
name|directive_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|directive_buffer
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|directive_buffer
index|[
name|bytes_used
index|]
expr_stmt|;
name|buffer_limit
operator|=
operator|&
name|directive_buffer
index|[
name|buffer_length
index|]
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* Discard initial whitespace.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
operator|&&
name|p
operator|==
name|directive_buffer
condition|)
continue|continue;
comment|/* Detect the end of the directive.  */
if|if
condition|(
name|looking_for
operator|==
literal|0
operator|&&
operator|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
operator|)
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|directive_buffer
return|;
comment|/* Handle string and character constant syntax.  */
if|if
condition|(
name|looking_for
condition|)
block|{
if|if
condition|(
name|looking_for
operator|==
name|c
operator|&&
operator|!
name|char_escaped
condition|)
name|looking_for
operator|=
literal|0
expr_stmt|;
comment|/* Found terminator... stop looking.  */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
literal|'"'
condition|)
name|looking_for
operator|=
name|c
expr_stmt|;
comment|/* Don't stop buffering until we see another 				   one of these (or an EOF).  */
comment|/* Handle backslash.  */
name|char_escaped
operator|=
operator|(
name|c
operator|==
literal|'\\'
operator|&&
operator|!
name|char_escaped
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_CPPLIB */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Make a variant type in the proper way for C/C++, propagating qualifiers    down to the element type of an array.  */
end_comment

begin_function
name|tree
name|c_build_type_variant
parameter_list|(
name|type
parameter_list|,
name|constp
parameter_list|,
name|volatilep
parameter_list|)
name|tree
name|type
decl_stmt|;
name|int
name|constp
decl_stmt|,
name|volatilep
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
return|return
name|build_array_type
argument_list|(
name|c_build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
return|return
name|build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the typed-based alias set for T, which may be an expression    or a type.  */
end_comment

begin_function
name|int
name|c_get_alias_set
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
specifier|static
name|int
name|next_set
init|=
literal|0
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
name|type
operator|=
operator|(
name|TREE_CODE_CLASS
argument_list|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
literal|'t'
operator|)
condition|?
name|t
else|:
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_ALIAS_SET_KNOWN_P
argument_list|(
name|type
argument_list|)
condition|)
comment|/* If we've already calculated the value, just return it.  */
return|return
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|BIT_FIELD_REF
condition|)
comment|/* Perhaps reads and writes to this piece of data alias fields        neighboring the bitfield.  Perhaps that's impossible.  For now,        let's just assume that bitfields can alias everything, which is        the conservative assumption.  */
return|return
literal|0
return|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|COMPONENT_REF
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
comment|/* Permit type-punning when accessing a union, provided the        access is directly through the union.  For example, this code does        not permit taking the address of a union member and then        storing through it.  Even the type-punning allowed here is a        GCC extension, albeit a common and useful one; the C standard        says that such accesses have implementation-defined behavior.  */
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|type
condition|)
block|{
comment|/* The C standard specifically allows aliasing between 	 cv-qualified variants of types.  */
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
operator|=
name|c_get_alias_set
argument_list|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
condition|)
block|{
name|tree
name|signed_variant
decl_stmt|;
comment|/* The C standard specifically allows aliasing between signed and 	 unsigned variants of the same type.  We treat the signed 	 variant as canonical.  */
name|signed_variant
operator|=
name|signed_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|signed_variant
operator|!=
name|type
condition|)
block|{
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
operator|=
name|c_get_alias_set
argument_list|(
name|signed_variant
argument_list|)
expr_stmt|;
return|return
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|signed_variant
operator|==
name|signed_char_type_node
condition|)
comment|/* The C standard guarantess that any object may be accessed 	   via an lvalue that has character type.  We don't have to 	   check for unsigned_char_type_node or char_type_node because 	   we are specifically looking at the signed variant.  */
block|{
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|UNION_TYPE
condition|)
block|{
comment|/* If TYPE is a struct or union type then we're reading or 	 writing an entire struct.  Thus, we don't know anything about 	 aliasing.  (In theory, such an access can only alias objects 	 whose type is the same as one of the fields, recursively, but 	 we don't yet make any use of that information.)  */
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
return|;
block|}
comment|/* TYPE is something we haven't seen before.  Put it in a new alias      set.  */
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
operator|=
operator|++
name|next_set
expr_stmt|;
return|return
name|TYPE_ALIAS_SET
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

end_unit

